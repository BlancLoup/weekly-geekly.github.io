<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÄúWhat's new in Swift 2?‚Äù With examples. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part, we considered only a part of the new features of Swift 2: 



- fundamental language constructs such as enums , scoping (scope), ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>‚ÄúWhat's new in Swift 2?‚Äù With examples. Part 2</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/269171/">first part,</a> we considered only a part of the new features of Swift 2: <br><br><ul><li>  fundamental language constructs such as <font color="#0000FF">enums</font> , scoping (scope), argument syntax, etc. </li><li>  <b>pattern matching</b> </li><li>  <b>error handling</b> </li></ul><br>  In the second part, we will look at the rest: <br><br><ul><li>  protocol <b>extensions</b> </li><li>  availability check </li><li>  interaction with <b>Objective-C</b> and <b>C</b> </li></ul><br>  I will consider the new features of Swift 2, accompanying them with examples whose code is on <a href="https://github.com/BestKora/WhatsNewInSwift2">Github</a> . <br><a name="habracut"></a><br><h2>  Protocol extensions </h2><br>  Protocol extensions were made possible in Swift 2, which made it possible to add new functions (complete with an implementation) to any classes, structures, and enumerations that implement the protocol. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Prior to Swift 2, both in Objective-C and Swift 1.x, the protocols contained only a declaration of methods.  With protocol extensions in Swift 2, protocols can now include, along with the declaration, the implementation of methods.  We have been waiting for this opportunity for Objective-C for years, so it's nice to see its implementation in a new language. <br><br>  It often happens that some functionality needs to be added to all types that confirm a particular protocol (interface).  For example, all collections can support the concept of creating a new collection based on the transformations of its elements.  With old-style protocols, we could implement this possibility in two ways: 1) place the method in the protocol and require that each type confirming this protocol implement the method, or 2) write a global function that works on the values ‚Äã‚Äãof the types confirming the protocol. <br><br>  Cocoa (Objective-C) in most cases prefers the first solution. <br><br>  Swift 1.x used the second solution.  Global functions such as <font color="#0000FF">map</font> operated on any <font color="#0000FF">CollectionType</font> .  This provided an excellent separation of code in the implementation, but terrible syntax and the inability to override the implementation for a specific type. <br><br><pre><code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">filter</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(numbers) { $<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span> }) { $<span class="hljs-number"><span class="hljs-number">0</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-comment"><span class="hljs-comment">//-- Swift 1</span></span></code> </pre> <br><br>  With extensions of protocols, a third possibility has appeared, which significantly exceeds the other two.  <font color="#0000FF">The map</font> can be implemented in the protocol extension <font color="#0000FF">CollectionType</font> .  All types that support the <font color="#0000FF">CollectionType</font> protocol will automatically receive <font color="#0000FF">map</font> implementations for free. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = numbers.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span> }.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-comment"><span class="hljs-comment">//-- Swift 2</span></span></code> </pre><br>  For example, consider in Swift 2 the implementation of the new <font color="#0000FF">myMap</font> method as an extension of the <font color="#0000FF">CollectionType</font> protocol. <br><br><img src="https://habrastorage.org/files/450/69c/850/45069c85017d47df86ecb7f54f6e4cd9.png" width="420" height="140"><br><br>  As a result, we can immediately use <font color="#0000FF">myMap</font> for <font color="#0000FF">Array &lt;T&gt;</font> arrays <br><img src="https://habrastorage.org/files/65f/0bb/825/65f0bb8259c041ac89706cdfbc94c11f.png" width="550" height="92"><br><br>  for dictionaries <font color="#0000FF">Dictionary &lt;Key: Value&gt;</font> <br><img src="https://habrastorage.org/files/e33/23c/e4d/e3323ce4d930451faebeaa2b88e4f8d7.png" width="600" height="121"><br><br>  for sets <font color="#0000FF">Set &lt;T&gt;</font> <br><img src="https://habrastorage.org/files/22e/926/c5d/22e926c5dedb427884284481be5b4bbd.png" width="580" height="93"><br><br>  for <font color="#0000FF">strings.characters</font> <br><img src="https://habrastorage.org/files/580/a89/4ac/580a894aca224c59aa0fdfec9d3d5d48.png" width="600" height="192"><br><br>  for ArraySlice <font color="#0000FF">&lt;T&gt; slices</font> <br><img src="https://habrastorage.org/files/c82/af1/ef3/c82af1ef38784a48b4b3498aebf62745.png" width="540" height="105"><br><br>  for StrideThrough <font color="#0000FF">&lt;T&gt;</font> straights, but not directly, but through a <font color="#0000FF">map</font> that converts a sequence ( <font color="#0000FF">SequenceType</font> protocol) to a collection ( <font color="#0000FF">CollectionType</font> protocol) <br><img src="https://habrastorage.org/files/909/960/e74/909960e7403e4ef39e764e255f08648f.png" width="540" height="112"><br><br>  Protocol extensions underlie the new approach to software design, announced by Apple as a Protocol-Oriented Programming (EPP), existing in Swift along with traditional Object-Oriented Programming (OOP) and elements of Functional Programming (AF).  It must overcome such OOP problems as ‚Äúfragile base class‚Äù and the rigidity of inheritance (rigidity and fragility of inheritance), <a href="https://en.wikipedia.org/wiki/Multiple_inheritance">‚Äúdiamond problem‚Äù</a> , implicit separation of references to objects, the need for frequent use of ‚Äúcasting‚Äù down (downcasting ) in overridden methods.  It is also difficult for many developers to describe polymorphism with words, and it is easier to show with an example, we will demonstrate the capabilities of Protocol-Oriented Programming with examples. <br><br><h2>  Example 1. Fischer-Jens shuffle algorithm </h2><br>  For a deeper consideration of these differences, let us consider the implementation of <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B0%25D1%2581%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A4%25D0%25B8%25D1%2588%25D0%25B5%25D1%2580%25D0%25B0%25E2%2580%2593%25D0%2599%25D0%25B5%25D1%2582%25D1%2581%25D0%25B0">the Fisher ‚Äì Jens</a> <font color="#0000FF">Shuffle</font> <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B0%25D1%2581%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A4%25D0%25B8%25D1%2588%25D0%25B5%25D1%2580%25D0%25B0%25E2%2580%2593%25D0%2599%25D0%25B5%25D1%2582%25D1%2581%25D0%25B0">algorithm for</a> ‚Äúmixing‚Äù elements of a collection using the example of the <font color="#0000FF">shuffle</font> function for Swift 1.2 (OOP) and Swift 2 (POP).  This algorithm is often used when dealing cards in a card game. <br><br>  In Swift 1.2, we would add the global <font color="#0000FF">shuffle</font> function for working with collections according to method 2, that is, when using the global function with <b>generics</b> : <br><br><img src="https://habrastorage.org/files/28c/151/90a/28c15190a6824cd683564220d80a3b2e.png" width="550" height="206"><br><br>  Let's look at this feature in more detail.  The input of this global function takes as its argument the collection <font color="#0000FF">var list: C itself</font> and returns a new collection of the same type <font color="#0000FF">C</font> with ‚Äúmixed‚Äù values ‚Äã‚Äãof the original <font color="#0000FF">list</font> collection.  This global function can be used for all types that support the <font color="#0000FF">MutableCollectionType</font> protocol and have integer indices.  There are two such collections: <font color="#0000FF">Array &lt;T&gt;</font> and <font color="#0000FF">ArraySlice &lt;T&gt;</font> slice <br><br><img src="https://habrastorage.org/files/d40/439/5fc/d404395fcd0340d98db0b04fc4cc502a.png" width="650" height="288"><br><br>  But look, what is the appeal to this global function? <br><pre> <code class="hljs lisp">shuffle(<span class="hljs-name"><span class="hljs-name">strings1</span></span>) shuffle(<span class="hljs-name"><span class="hljs-name">numbers1</span></span>)</code> </pre><br><br>  This function does not allow using the ‚Äúdot‚Äù notation; in the round brackets you need to specify the collection itself.  This is very inconvenient if you have a whole chain of transformations, which leads to a lot of nested parentheses, and if this all alternates with the methods of the type, then in general - trouble.  We have already seen a similar syntax above. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">filter</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(numbers) { $<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span> }) { $<span class="hljs-number"><span class="hljs-number">0</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-comment"><span class="hljs-comment">//-- Swift 1</span></span></code> </pre><br><br>  If we want to work with the ‚Äúdot‚Äù notation in Swift 1.2, then we add the <font color="#0000FF">shuffle</font> function to the extension of each individual type, for example, the <font color="#0000FF">Array</font> class (this is method 1).  Moreover, we can add both the locally changing (mutating) method <font color="#0000FF">shuffleInPlace</font> and the shuffle method, which returns a new array with ‚Äúmixed‚Äù elements of the original array (non ‚Äî mutating)): <br><br><img src="https://habrastorage.org/files/adc/fab/b97/adcfabb97417425884dbe5c127c6cee5.png" width="450" height="276"><br><br>  The last two methods are extensions for the <font color="#0000FF">Array array</font> and are available only for arrays. <br><img src="https://habrastorage.org/files/c3a/3bd/77b/c3a3bd77bee04d84b1bd9a961a7351fe.png" width="540" height="126"><br><br>  Neither <font color="#0000FF">Set</font> nor <font color="#0000FF">ArraySlice</font> , no other <font color="#0000FF">CollectionType</font> can use them. <br><br>  In Swift 2, we add the <font color="#0000FF">shuffle</font> and <font color="#0000FF">shuffleInPlace methods</font> exclusively to extend the <font color="#0000FF">CollectionType</font> and <font color="#0000FF">MutableCollectionType protocols</font> (method 3): <br><img src="https://habrastorage.org/files/b79/852/f09/b79852f092be42cdbacbdc15e92a23eb.png" width="460" height="351"><br><br>  And with the extension of the protocols, the <font color="#0000FF">shuffle</font> and <font color="#0000FF">shuffleInPlace methods</font> can now be applied to <font color="#0000FF">Set</font> , and to <font color="#0000FF">Array</font> , and to <font color="#0000FF">ArraySlice</font> and any other <font color="#0000FF">CollectionType</font> without any additional effort, and in the ‚Äúdotted‚Äù notation we need: <br><br><img src="https://habrastorage.org/files/91e/8fe/be7/91e8febe70944f7ba74eb491acf5be4a.png" width="600" height="447"><br><br>  When extending protocols in Swift 2, we can set restrictions on the type.  As you can see from the code, we first perform the protocol extension only for the <font color="#0000FF">mutableCollectionType</font> collection that is variable, which uses integers as indices, and then distribute it to the <font color="#0000FF">CollectionType</font> . <br><br>  At the end, you need to make a small remark about the algorithm of "mixing" the elements of the collection.  In Swift 2, there is already an efficient and correct implementation of the Fisher-Jens shuffle algorithm in <font color="#0000FF">GameplayKit</font> (which, despite its name, is not only suitable for games).  True, this method works only with arrays. <br><img src="https://habrastorage.org/files/992/c0c/b46/992c0cb4600b44439428dd34878309e4.png" width="650" height="52"><br><br><h2>  Example 2. Farewell pipe (pipeline) operator <font color="#0000FF">|&gt;</font> with the advent of the possibility of extending protocols </h2><br>  With the advent of Swift and the creation of custom operators, including functional programming operators, attempts have been made and quite successful to solve some problems using functional programming techniques.  In particular, for the Moon algorithm for calculating the check digit of a plastic card, it was proposed to use a pipe (pipeline) operator <font color="#0000FF">|&gt;</font> to avoid annoying throwing between functions and methods.  But Swift 2 came out and the protocol extension technique made it even easier to solve this problem. <br><br>  The original algorithm described by the developer <br><br><ul><li>  1. Numbers of the checked sequence are numbered from right to left. </li><li>  2. Figures that appear in odd places remain unchanged. </li><li>  3. Numbers in even places are multiplied by 2. </li><li>  4. If as a result of such multiplication a number greater than 9 appears (for example, 8 √ó 2 = 16), it is replaced by the sum of digits of the resulting work (for example, 16: 1 + 6 = 7, 18: 1 + 8 = 9) - by a single-digit number that is, a number. </li><li>  5. All the resulting conversion figures are added.  If the sum is a multiple of 10, then the source data is correct. </li></ul><br>  The algorithm consists of a sequence of steps, each of which will be described using an extension of either a protocol, or a type, or using known methods. <br><br>  First, you need to be reminded that in Swift 2 the <font color="#0000FF">String is</font> no longer a sequence, but <font color="#0000FF">String.characters</font> is a sequence of characters, and we need to convert a character to an integer.  We construct this transformation on an extension of type <font color="#0000FF">Int</font> .  That is, instead of <font color="#0000FF">String.toInteger</font> we get <font color="#0000FF">Int.init (String)</font> : <br><br><img src="https://habrastorage.org/files/948/101/c3b/948101c3b7c942a4be37bdf9e1b8c7e4.png" width="390" height="87"><br><br>  This conversion returns an Optional, since there may be spaces in the credit card number, and we need to continue to perform arithmetic operations on the obtained integers, so we use the <font color="#0000FF">flatMap</font> method that appeared in Swift 2, which will remove all spaces in the card number <br><br><img src="https://habrastorage.org/files/d78/194/c3a/d78194c3a987469eaedc095291ac360e.png" width="550" height="143"><br><br>  According to our algorithm, we have to consider numbers from right to left, and here they follow from left to right, therefore we will arrange our sequence of numbers in the opposite direction using the <font color="#0000FF">reverse</font> method and the trivial <font color="#0000FF">map</font> method <br><br><img src="https://habrastorage.org/files/eae/11d/9f0/eae11d9f011b4ad597f7fa693883d9e2.png" width="550" height="164"><br><br>  But we need not a simple <font color="#0000FF">map</font> , but a <font color="#0000FF">map</font> that performs transformations only on each Nth member of the sequence.  Again we execute the extension, but now not of the type, but of the protocol <font color="#0000FF">SequenceType</font> <br><br><img src="https://habrastorage.org/files/7cb/c42/4db/7cbc424db784433288eea84889a400f6.png" width="550" height="205"><br><br>  We get the following result <br><br><img src="https://habrastorage.org/files/9f4/e21/236/9f4e21236e5b4d118851db68f8323f2b.png" width="550" height="160"><br><br>  Then we need a method to calculate the sum of any sequence containing integers: <br><br><img src="https://habrastorage.org/files/281/755/1b9/2817551b931a4eefbeaf6bb8214168b2.png" width="450" height="79"><br><br>  and method of calculating the number modulo another number <br><br><img src="https://habrastorage.org/files/d7d/69f/e51/d7d69fe51718420a86d0778a5779b629.png" width="320" height="75"><br><br>  As a result, we get the <font color="#0000FF">luhnchecksum ()</font> method, which we add to the <font color="#0000FF">String</font> type and which calculates the checksum in one string <br><br><img src="https://habrastorage.org/files/40b/5c3/b51/40b5c3b51b37469c81ecd98e64b3cc84.png" width="420" height="148"><br><br>  Now it's very easy to get the result: <br><br><img src="https://habrastorage.org/files/c74/ef1/5b1/c74ef15b190646f2ad9a9ab1ac06d74d.png" width="500" height="57"><br><br><h2>  Some features of the protocol extension </h2><br>  I think that protocol extensions can be Apple‚Äôs answer to the question of optional protocol methods.  Pure Swift protocols cannot and should not have optional (optional) methods.  But we are used to the optional (optional) methods in Objective-C protocols, for example, for such things as delegates: <br><br><pre> <code class="hljs pgsql">@protocol MyClassDelegate @optional - (<span class="hljs-type"><span class="hljs-type">BOOL</span></span>)shouldDoThingOne; - (<span class="hljs-type"><span class="hljs-type">BOOL</span></span>)shouldDoThingTwo @<span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Pure Swift has no equivalent: <br><img src="https://habrastorage.org/files/782/0bc/984/7820bc984f9c4637b104c18d991d8dc3.png" width="280" height="76"><br><br>  Until now, everyone who confirmed this protocol had to implement all these methods.  This conflicts with the idea of ‚Äã‚Äãdelegating Cocoa as an option to optionally configure all delegate methods, preferring the default implementation of the methods.  With the advent of protocol extensions in Swift 2, reasonable default behavior can be provided by the protocol itself: <br><br><img src="https://habrastorage.org/files/fad/a06/3dd/fada063dd30b4278bfef12484261e72a.png" width="550" height="160"><br><br>  Ultimately, this provides the same functionality as Objective-C‚Äôs <font color="#0000FF">@optional</font> , but without mandatory checks at runtime. <br><br><h2>  API availability check </h2><br>  One professional problem that depresses iOS developers is the need to be very careful when using new <b>APIs</b> .  For example, if you try to use <font color="#0000FF">UIStackView</font> in iOS 8, then your application will crash.  In ancient times, Objective-C developers would write similar code: <br><br><pre> <code class="hljs objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSClassFromString</span></span>(<span class="hljs-string"><span class="hljs-string">@"UIAlertController"</span></span>) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre><br><br>  This means ‚Äúif the <font color="#0000FF">UIAlertControllerl</font> class exists,‚Äù and is a way to check whether it runs on iOS 8 or later.  But due to the fact that Xcode did not guess the true purpose of this code, it did not guarantee us the correctness of its execution.  Everything changed in Swift 2, because you can write such code explicitly: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> #available(iOS <span class="hljs-number"><span class="hljs-number">9</span></span>, *) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> stackView = <span class="hljs-type"><span class="hljs-type">UIStackView</span></span>() <span class="hljs-comment"><span class="hljs-comment">//  ... }</span></span></code> </pre><br><br>  The magic happens with the appearance of the <font color="#0000FF">#available clause</font> : it automatically checks whether you are running on iOS version 9 or later, and if ‚Äúyes‚Äù, then the code from <font color="#0000FF">UIStackView</font> will be launched.  The presence of a ‚Äú*‚Äù after ‚ÄúiOS 9‚Äù means that this offer will be executed for any future platform that Apple will introduce. <br><br>  The <font color="#0000FF">#available</font> clause is <font color="#0000FF">also</font> remarkable because it gives you the opportunity to write code in the <font color="#0000FF">else</font> block, because Xcode now knows that this block will be executed if iOS 8 or less is on the device and can warn you if you will use new APIs here .  For example, if you wrote something like this: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-meta"><span class="hljs-meta">#available(iOS 9, *) { // do cool iOS 9 stuff } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { let stackView = UIStackView() }</span></span></code> </pre><br>  ... then you get an error: <br><br><img src="https://habrastorage.org/files/569/876/be9/569876be9ae94b3da5a9d5293d35918f.png" width="450" height="168"><br><br>  Xcode sees that you are trying to use <font color="#0000FF">UIStackView</font> where it is not available and it simply will not allow this to happen.  So, switching from ‚Äúwhether this class is‚Äú available ‚Äùto telling Xcode about our real intentions, we received tremendous support for our security. <br><br><h2>  Compatibility </h2><br>  When you write code in Swift, that is, a number of pre- <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html">written rules</a> that tell the compiler whether you need and how, expose methods, properties, etc. on Objective-C.  Moreover, at your disposal there are a small number of attributes with the help of which you can control this process.  These attributes are: <br><br><ul><li>  <font color="#0000FF">@IBOutlet</font> and <font color="#0000FF">@IBAction</font> allow Swift properties and methods to be interpreted as <b>outlets</b> and <b>Actions</b> in Interface Builder; </li><li>  <font color="#0000FF">dynamic</font> , which allows you to use <b>KVO</b> for a given property; </li><li>  <font color="#0000FF">@objc</font> , which is used to make a class or property called from Objective-C. </li></ul><br><br><img src="https://habrastorage.org/files/bbe/6f9/b01/bbe6f9b01a7e4aadba2db0018a32a8fc.png" width="550" height="314"><br><br>  In Swift 2, a new such attribute <font color="#0000FF">@nonobjc has appeared</font> , which clearly prevents the use of properties or methods from being exposed in Objective-C.  This attribute is very useful, for example, in the following case.  In the Calculator application (see below), in the <font color="#0000FF">ViewController</font> class, which inherits from the <font color="#0000FF">UIViewController</font> Cocoa class, you define 3 methods with the same name <font color="#0000FF">performOperation</font> , but with different arguments.  This is normal, Swift is able to distinguish between these methods, simply based on the different types of argument.  But Objective-C doesn't work that way.  In Objective-C, methods differ only by name, not by type.  If these methods are exposed for use in Objective-C, then you will get an error saying that you cannot use them in this form in Objecrive-C.  The thing is that our <font color="#0000FF">ViewController</font> class, which we created for the calculator interface, inherits the <font color="#0000FF">UIViewCiontroller</font> class from Cocoa, and the compiler automatically implicitly marks all properties and methods with the <font color="#0000FF">@objc</font> attribute.  If you do not intend to use methods in Objective-C, then you must supply them with the <font color="#0000FF">@noobjc</font> attribute and the error disappears: <br><br><img src="https://habrastorage.org/files/033/fdc/8f0/033fdc8f08a24a5588491be79a41a8d2.png" width="550" height="157"><br>  ......................... <br><img src="https://habrastorage.org/files/6d0/66f/efc/6d066fefc5484c5a9947954688d948a2.png" width="600" height="300"><br>  Another area in which Swift 2 is trying to improve compatibility is compatibility with C function pointers.  The purpose of this improvement is to fix the Swift annoying constraint, which does not allow you to fully work with such an important C - framework as <b>Core Audio</b> , which intensively uses callback functions.  In Swift 1.x, it was not possible to directly replace the pointer with the Swift function with a function.  You needed to write a small ‚Äúwrapper‚Äù in C or Objective-C that encapsulates the callback function.  In Swift 2, it became possible to do this in a completely natural way for Swift 2.  Pointers to C functions are imported into Swift as closures.  You can pass any Swift 2 closure or function with suitable parameters to a code that expects a pointer to a C function ‚Äî with one significant limitation: in contrast to closures, pointers to C functions do not have the concept of a ‚Äúcaptured‚Äù state (they are just pointers).  As a result, for compatibility with pointers to C functions, the compiler will allow using only those Swift 2 closures that do not ‚Äúcapture‚Äù any external context.  Swift 2 uses the new <font color="#0000FF">@ convention ¬©</font> notation to indicate this agreement when calling: <br><br><img src="https://habrastorage.org/files/ae5/7e4/c9e/ae57e4c9e53a43c8932a8e718a6fdc69.png" width="500" height="55"><br><br>  For example, for the standard C sorting function <font color="#0000FF">qsort,</font> it would look like this: <br><br><img src="https://habrastorage.org/files/abe/e5d/5bd/abee5d5bdfa04902afaf461d4219e0c3.png" width="550" height="142"><br>  A very good example is presented in <a href="http://oleb.net/blog/2015/06/c-callbacks-in-swift/">C Callbacks in Swift</a> , which shows how to access <font color="#0000FF">CGPath</font> or <font color="#0000FF">UIBezierPath</font> elements by calling the <font color="#0000FF">CGPathApply</font> function and passing a pointer to the callback function.  <font color="#0000FF">CGPathApply</font> then calls this callback for each path element. <br><br><img src="https://habrastorage.org/files/189/d81/13b/189d8113b985445d80b4b91cc89b3b03.png" width="600" height="183"><br><br><img src="https://habrastorage.org/files/b08/461/167/b084611670314bcfa4d46b9728ad8d9c.png" width="380" height="469"><br><br>  Now go through the entire <font color="#0000FF">path</font> and print a description of its elements: <br><br><img src="https://habrastorage.org/files/714/c00/dda/714c00ddab8b4fec97887d40fc78e67d.png" width="320" height="230"><br><br>  Or you can count how many <font color="#0000FF">closepath</font> commands in this <font color="#0000FF">path are</font> : <br><br><img src="https://habrastorage.org/files/581/88d/d57/58188dd57c9547d9b7956e936648171c.png" width="400" height="68"><br><br>  In conclusion, we can say that Swift 2 automatically provides compatibility (bridges) of pointers to C functions and closures.  This makes it possible (and very convenient) to work with a large number of C APIs that use function pointers as callbacks.  Because conventions on calls to C functions do not allow these closures to ‚Äúcapture‚Äù an external state, you often have to pass external variables that your callback needs to access, via a <font color="#0000FF">void</font> pointer, which many C APIs <br><br><h2>  New Objective-C Features </h2><br>  Apple introduced three new features in Objective-C in Xcode 7 with an eye to using them for smoother Swift compatibility: <br><br><ul><li>  nullability; </li><li>  lightweight generics; </li><li>  <font color="#0000FF">__kindof</font> types. </li></ul><br><br><h3>  Nullability </h3><br>  This feature was introduced already in Xcode 6.3, but it is worth mentioning that Objective-C now allows you to accurately characterize the behavior of any methods and properties to determine whether they can be <font color="#0000FF">nil</font> or not.  This is addressed directly to Swift's requirements for <b>Optional</b> or non- <b>Optional</b> types and makes the Objective-C interface more expressive.  There are three qualifiers for <b>nullability</b> : <br><br><ul><li>  <font color="#0000FF">nullable</font> ( <font color="#0000FF">__nullable</font> for C pointers), meaning that the pointer can be <font color="#0000FF">nil</font> and is converted to Swift as an <b>Optional</b> type - <font color="#0000FF">?</font>  ; </li><li>  <font color="#0000FF">nonnull</font> ( <font color="#0000FF">__nonnull</font> for C pointers), meaning that <font color="#0000FF">nil is</font> not allowed and is converted to Swift as a non- <b>Optional</b> type; </li><li>  <font color="#0000FF">null_unspecified</font> ( <font color="#0000FF">__null_unspecified</font> for C pointers), no information on what behavior is supported;  in this case, such a pointer is converted to Swift as an automatically ‚Äúexpanded‚Äù Optional - <font color="#0000FF">!</font>  . </li></ul><br><br>  The qualifiers listed above can be used to annotate Objective-C classes, as in the following example: <br><br><img src="https://habrastorage.org/files/4d4/062/01f/4d406201f0ab4c639b0ec0d639927474.png" width="580" height="137"><br><br>  In this example, the whole area marked with the brackets <font color="#0000FF">NS_ASSUME_NONNULL_BEGIN and NS_ASSUME_NONNULL_END</font> is selected so that <font color="#0000FF">nonnull has</font> a value that is used by default.  This allows the developer to annotate only those elements that do not correspond to the default value. <br><br><h3>  Lightweight <b>generics</b> </h3><br>  Lightweight <b>generics</b> in Objective-C may be the most desirable in Objective-C over the past decade, especially for Apple engineers.  They are necessary for use with collections like <font color="#0000FF">NSArray</font> , <font color="#0000FF">NSDictionary</font> , etc ... One of the disadvantages of collections in Objective-C is the loss of almost all type information when porting them to Swift, by default in Swift we get the <font color="#0000FF">AnyObject</font> collection and have to apply down "casting "In the overwhelming number of cases.  But now you can declare the type of array elements in Xcode 7 as follows: <br><br><img src="https://habrastorage.org/files/b57/38d/a33/b5738da337314770ac8753ef955ffea1.png" width="580" height="114"><br><br>  In our case, we declare a variable array of strings.  If you try to write a number into it, the compiler will issue a warning about the type mismatch. <br>  Lightweight <b>generics</b> have proven very useful for interoperability between Objective-C and Swift in terms of representing the <font color="#0000FF">NSArray</font> , <font color="#0000FF">NSDictionary</font> , etc. classes, because now you don‚Äôt need to do a lot of "castings" in your Swift code because all Apple frameworks are written in Objective-C. <br><br><img src="https://habrastorage.org/files/045/de8/2eb/045de82eb53043b6bd62d6cbdb93ac14.png" width="580" height="87"><br><br>  Do you see?  Now the <font color="#0000FF">subviews</font> are not an <font color="#0000FF">[AnyObject]</font> array, they are passed to Swift as <font color="#0000FF">[UIView]</font> . <br>  Now in Objective-C you can declare your own <b>generic</b> class: <br><br><img src="https://habrastorage.org/files/e35/167/7f5/e351677f5c66410e85dfb7ccf8c689c9.png" width="400" height="182"><br><br>  And use it <br><br><img src="https://habrastorage.org/files/470/b2a/1fc/470b2a1fc4304d92a3be7e30c8b55f8f.png" width="400" height="105"><br>  In case of a type mismatch, a warning is issued.  Unfortunately, using your own <b>generic</b> types takes precedence only within Objective-C code and is ignored by Swift.  They operate only at the compiler level, they are not in runtime. <br><br><h3>  <font color="#0000FF">__kindof</font> types </h3><br>  <font color="#0000FF">__kindof</font> types belong to <b>generics</b> , and their appearance is motivated by the following case.  As is known, the <font color="#0000FF">UIView</font> class has a <font color="#0000FF">subviews</font> property, which is an array of <font color="#0000FF">UIView</font> objects: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@interface</span></span> UIView <span class="hljs-meta"><span class="hljs-meta">@property(nonatomic,readonly,copy)</span></span> NSArray&lt; UIView *&gt; *subviews; <span class="hljs-meta"><span class="hljs-meta">@end</span></span></code> </pre><br><br>  If you add <font color="#0000FF">UIButton</font> to the parent <font color="#0000FF">UIView</font> as the most remote <font color="#0000FF">subview</font> in the background, and try to send him a message that matters only for <font color="#0000FF">UIButton</font> , the compiler will issue a warning.  This is good, but we know for sure that the <font color="#0000FF">subview</font> in the background is a <font color="#0000FF">UIButton</font> and we want to send a message to it: <br><br><pre> <code class="hljs ruby">[view <span class="hljs-symbol"><span class="hljs-symbol">insertSubview:</span></span>button <span class="hljs-symbol"><span class="hljs-symbol">atIndex:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>-- <span class="hljs-symbol"><span class="hljs-symbol">warning:</span></span> UIView may <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> respond to <span class="hljs-symbol"><span class="hljs-symbol">setTitle:</span></span><span class="hljs-symbol"><span class="hljs-symbol">forState:</span></span> [view.subviews[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">setTitle:</span></span>@<span class="hljs-string"><span class="hljs-string">"Cancel"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">forState:</span></span>UIControlStateNormal];</code> </pre><br><br>  Using the <font color="#0000FF">__kindof</font> type, we can provide some flexibility to the typing system in Objective-C so that the implicit "casting" of both the superclass and any subclass works: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@interface</span></span> UIView <span class="hljs-meta"><span class="hljs-meta">@property(nonatomic,readonly,copy)</span></span> NSArray&lt; _kindof UIView *&gt; *subviews; <span class="hljs-meta"><span class="hljs-meta">@end</span></span> <span class="hljs-comment"><span class="hljs-comment">//-- no warnings here: [view.subviews[0] setTitle:@"Cancel" forState:UIControlStateNormal]; UIButton *button = view.subviews[0];</span></span></code> </pre><br><br>  The lightweight <b>generics</b> and <font color="#0000FF">__kindof</font> types allow the developer to remove <font color="#0000FF">id / AnyObject</font> almost everywhere from most of their APIs.  <font color="#0000FF">The id</font> may still be required in cases where there really is no information on what type you are dealing with: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nullable</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&gt; *userInfo;</code> </pre><br><br>  Links to articles used <br><br>  <a href="https://www.hackingwithswift.com/new-features-swift-2">New features in Swift 2</a> <br>  <a href="http://blog.zuehlke.com/en/what-i-like-in-swift-2-the-return-part-1-of-3/">What I Like in Swift 2</a> <br>  <a href="http://www.appcoda.com/swift2/">A Beginner's guide to Swift 2</a> <br>  <a href="http://www.thomashanning.com/error-handling-in-swift-2-0/">Error Handling in Swift 2.0</a> <br>  <a href="http://natashatherobot.com/swift-2-0-try/">Swift 2.0: Let's try?</a> <br>  <a href="http://www.raywenderlich.com/109655/video-tutorial-whats-new-in-swift-2-part-4-pattern-matching">Video Tutorial: What's New in Swift 2 Part 4: Pattern Matching</a> <br>  <a href="http://robnapier.net/throw-what-dont-throw">Throw What Don't Throw</a> <br>  <a href="https://www.mikeash.com/pyblog/friday-qa-2015-06-19-the-best-of-whats-new-in-swift.html">The Best of What's New in Swift</a> <br>  <a href="https://www.hackingwithswift.com/swift2">What's new in Swift 2</a> <br>  <a href="http://www.thomashanning.com/api-availability-checking-in-swift-2-0/">Swift 2.0: Availability Checking API</a> <br>  <a href="http://stackoverflow.com/questions/24026510/how-do-i-shuffle-an-array-in-swift">How do I shuffle an array in Swift?</a> <br>  <a href="https://gist.github.com/natecook1000/ef096622dab1981823c5">Swift 2.0 shuffle / shuffleInPlace</a> <br>  <a href="http://oleb.net/blog/2015/06/c-callbacks-in-swift/">C Callbacks in Swift,</a> <br> <a href="http://airspeedvelocity.net/2015/06/23/protocol-extensions-and-the-death-of-the-pipe-forward-operator/">Protocol extensions and the death of the pipe-forward operator</a> <br> <a href="https://medium.com/ios-os-x-development/swift-protocol-extension-method-dispatch-6a6bf270ba94">Swift protocol extension method dispatch</a> <br> <a href="http://www.codingexplorer.com/api-availability-checking-in-swift-2/">API Availability Checking in Swift 2</a> <br> <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html">Interacting with C APIs</a> <br> <a href="http://www.infoq.com/articles/whats-new-ios9-swift-objc">What's new in iOS 9: Swift and Objective-C</a> <br> <a href="https://developer.apple.com/library/prerelease/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc7_release_notes.html">Xcode 7 Release Notes</a> </div><p>Source: <a href="https://habr.com/ru/post/269719/">https://habr.com/ru/post/269719/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269705/index.html">Sharing checkstyle and gerrit</a></li>
<li><a href="../269707/index.html">Duke, take out the trash! - Part 2</a></li>
<li><a href="../269709/index.html">Validation of complex structures with PHPixie Validate</a></li>
<li><a href="../269711/index.html">Another build Vivaldi 1.0.303.37 - Beta Candidate</a></li>
<li><a href="../269717/index.html">Maybe monad on steroids</a></li>
<li><a href="../269721/index.html">Latest article about setting up a server for Rails</a></li>
<li><a href="../269723/index.html">Test Recipes for Ruby and Rails Applications</a></li>
<li><a href="../269725/index.html">How did we manage to build a video hosting for 1 ¬¢ / GB</a></li>
<li><a href="../269727/index.html">Multi-tier, extensible business information repository architecture. LSA and SAP BW. Traditional approach</a></li>
<li><a href="../269729/index.html">Certificate Transparency Overview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>