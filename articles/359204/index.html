<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Build projects with dapp. Part 2: JavaScript (frontend)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This material continues the cycle about building Docker images for applications in various programming languages ‚Äã‚Äãusing the dapp utility. The previou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Build projects with dapp. Part 2: JavaScript (frontend)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/bg/1v/sl/bg1vslqn5pvxnwundz5hakdzmae.png"><br><br>  This material continues the cycle about building Docker images for applications in various programming languages ‚Äã‚Äãusing the <a href="https://github.com/flant/dapp">dapp</a> utility.  <a href="https://habr.com/company/flant/blog/348436/">The previous article</a> was about building Java applications - now let's talk about JavaScript applications.  For a start, this will be a frontend application, and in the next part we plan to tell about building a backend and launching everything in Kubernetes. <br><br>  As an illustration, the <a href="https://github.com/Snipa22/nodejs-pool">nodejs-pool</a> and <a href="https://github.com/mesh0000/poolui">poolui</a> applications will be used.  Yes, let's prepare for the launch in Kubernetes your mining pool with blockchain and payouts! <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/d0/ad/ud/d0adudsg2shdarhlqscwocpnwao.jpeg"><br><br>  Mining pool is an application for coordinating miner programs.  The pool distributes miners tasks and collects answers from them.  If by common efforts we managed to find a block that the network recognizes as valid, then the reward for this block is divided among the participants of the pool according to a particular strategy.  Nodejs-pool is the server side of the pool with which miner programs communicate.  Poolui is a frontend application with which participants interact with the pool: they register, see the general and their statistics on blocks, miners, and payments. <br><br><h2>  Build the poolui application "as is" </h2><br>  The first description of the assembly may be a repetition of the finished Dockerfile (as in the <a href="https://habr.com/company/flant/blog/348436/">article on Java</a> ), but if there is no such, then it is enough to start by running the application in the container according to the recommendations of the developers.  In our case <a href="">it is written</a> in the README that to build and run, it suffices to execute the <code>npm start</code> command ‚Äî this is where we will begin. <br><br>  Take the official node image, which already has npm, for example, version <a href="https://hub.docker.com/_/node/">9.11-alpine</a> .  You need to add the application source code to the image, and the container will be launched with the <code>npm start</code> command using the <code>dapp dimg run</code> .  Sources are usually added to some directory ‚Äî for example, / app ‚Äî so the <code>docker.WORKDIR</code> directive is needed so that the command <code>docker.WORKDIR</code> in the correct directory and not in the root of the image.  The result was such a simple <code>dappfile.yaml</code> : <br><br><pre> <code class="hljs cs">dimg: poolui <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: node:<span class="hljs-number"><span class="hljs-number">9.11</span></span>-alpine git: - <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>: / to: /app docker: WORKDIR: /app</code> </pre> <br>  Build command: <br><br><pre> <code class="bash hljs">dapp dimg build</code> </pre> <br>  <i>(For details on some of the conveniences for working with this build team, see the <a href="https://habr.com/company/flant/blog/354866/">article from a colleague</a> .)</i> <br><br>  Application launch command: <br><br><pre> <code class="bash hljs">dapp dimg run poolui -p 8080:8080 -ti --rm -- npm start</code> </pre> <br>  After such a start, the application in the browser will look something like this: <br><br><img src="https://habrastorage.org/webt/7q/om/p2/7qomp2azf4cqhgzfmkkefonhoca.png"><br><br><h2>  Improved dappfile.yaml </h2><br>  By the look of the page, it can be understood that one <code>npm start</code> command is not enough to fully launch the application as a container. <br><br>  Such a launch ‚Äúas is‚Äù does not work for all projects, but it can be used to ‚Äúobserve‚Äù the launch of an unfamiliar application in a container.  Having a <code>Dockerfile</code> in the project <code>Dockerfile</code> it easy to create <code>dappfile.yaml</code> , because  immediately see all the commands to create an image. <br><br>  To create <code>dappfile.yaml</code> for a project without a <code>Dockerfile</code> , you need to determine from the description of the application assembly which commands to run.  Our company engineers do this work either on the basis of their knowledge of utilities in different languages ‚Äã‚Äã(npm, gulp, maven, composer, etc.), or in some cases, together with the customer‚Äôs developers, change the description files ( <code>package.json</code> , <code>gulpfile.js</code> , <code>pom.xml</code> , <code>composer.json</code> ), so that the application build describes all the necessary dependencies. <br><br>  Usually, everything starts with the <code>beforeInstall</code> stage, where installation of system packages is described, for example, if there are not enough tools in the selected base image.  Then the <code>install</code> stage is added, where the application sources are already available and you can run the build tools.  After successfully assembling an image with two stages, you can go ahead and highlight some commands into other stages ( <code>beforeSetup</code> , <code>setup</code> ), as well as describe sets of directories and files, changes in which will lead to reassembly. <br><br>  A similar launch "as is" for projects that do not have a <code>Dockerfile</code> is usually not applicable in the production environment.  For rolling out an application in production, you need to work on defining commands for each stage of image assembly and on defining dependency files for these stages. <br><br>  The project under consideration has three description files: <br><br><ul><li>  <code>package.json</code> - description of dependencies and actions for npm; </li><li>  <code>bower.json</code> - description of application dependencies; </li><li>  <code>gulpfile.js</code> - description of tasks. </li></ul><br>  From <code>package.json</code> can see that gulp and bower will be needed for the build - these tools can be installed at the <code>beforeInstall</code> stage, since  their version will not change often.  At the same stage git will be added, since  It is needed for downloading dependencies.  In the same file you can see the commands that were not enough: <code>npm install</code> , <code>bower install</code> .  These commands will go to the <code>install</code> stage, where dependencies are downloaded.  The difference is small - for simplicity, <code>bower install</code> is performed with the <code>--allow-root</code> key.  Rebuilding the <code>install</code> stage depends on changes in the <code>package.json</code> and <code>bower.json</code> description files. <br><br>  <code>npm start</code> runs the <code>gulp</code> command, which will execute the default task from <code>gulpfile.js</code> .  This task sequentially launches three others: <code>build</code> , <code>connect</code> , <code>watch</code> .  Those.  build and launch tasks are merged.  This is convenient for a quick start, but in order to build an image, you will have to explicitly call the <code>gulp build</code> at the <code>setup</code> stage and install the reassembly <code>setup</code> depending on the changes in the <code>app</code> directory and the <code>gulpfile.js</code> file. <br><br>  To start the application, <code>gulp connect</code> now used not <code>npm start</code> , but.  You <code>gulp watch</code> not need to run <code>gulp watch</code> , because  This is a team to simplify development. <br><br>  The final <code>dappfile.yaml</code> looks like this: <br><br><pre> <code class="hljs cmake">dimg: poolui from: node:<span class="hljs-number"><span class="hljs-number">9.11</span></span>-alpine git: - add: / to: /app stageDependencies: <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>: - package.json - bower.json beforeSetup: - app - gulpfile.js shell: beforeInstall: - apk update - apk add git - npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> --global bower - npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> --global gulp <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>: - cd /app - npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> - bower <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> --allow-root beforeSetup: - cd /app - gulp build docker: WORKDIR: <span class="hljs-string"><span class="hljs-string">"/app"</span></span> CMD: [<span class="hljs-string"><span class="hljs-string">"gulp"</span></span>, <span class="hljs-string"><span class="hljs-string">"connect"</span></span>]</code> </pre> <br>  The application build log can be seen in this asciicast: <br><br> <a href="https://asciinema.org/a/7VsrQvUZEI1spUzVwiNvcaT6T"><img src="https://habrastorage.org/getpro/habr/post_images/cf6/076/255/cf6076255e0cb9a5804ec4a71e7c37a9.png"></a> <br><br>  To check, if you run the assembly again, then everything will be collected from the cache: <br><br> <a href="https://asciinema.org/a/QU5kdZxoTeloJnzQIiQp89huV"><img src="https://habrastorage.org/getpro/habr/post_images/2d4/660/7fe/2d46607fe508bdb67cbcaaeb9d350bdf.png"></a> <br><br>  Now you can start the application with the <code>dapp dimg run poolui -p 8080:8080 -ti --rm</code> : <br><br><img src="https://habrastorage.org/webt/jm/2l/gu/jm2lgug7uq68yohbhrdzkvlraga.png"><br><br>  In the launch output, the following line is noticeable: <code>Server started http://localhost:8080</code> . <br>  This means that you will not be able to connect to the server from a browser on the host machine.  You need to fix <code>gulpfile.js</code> so that the server <code>gulpfile.js</code> on the address 0.0.0.0.  Changes need to commit and run <code>dapp dimg build</code> to build a new image.  Since  <code>gulpfile.js</code> changes, then only the <code>beforeSetup</code> stage needs to be rebuilt.  The result can be seen in this asciicast: <br><br> <a href="https://asciinema.org/a/4HXwnQVDfP65806xcKbUJSt7Q"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/889/0aa/0ce8890aad8b92217649ff8b39980e06.png"></a> <br><br>  <code>dapp dimg run poolui -p 8080:8080 -ti --rm</code> with <code>dapp dimg run poolui -p 8080:8080 -ti --rm</code> : <br><br> <a href="https://asciinema.org/a/ht5cXxYQL34HwPNh1sFqRezen"><img src="https://habrastorage.org/getpro/habr/post_images/4a7/9de/044/4a79de044a2d6b70927df7865290f6fd.png"></a> <br><br>  If you connect to the application with a browser (go to <code>http://localhost:8080</code> ), then you can see a similar page: <br><br><img src="https://habrastorage.org/webt/hk/fo/lc/hkfolczp0pj-uadl4xh0kr8lrre.png"><br><br>  Done!  The frontend pool is running and looks good.  However, <code>gulp connect</code> is a module designed for development, and for production I would like to pack the application ‚Äúcorrectly‚Äù.  This option could be an image with nginx where the contents of the <code>/app/build</code> directory will be copied.  In dapp there are artifacts and intermediate or instrumental images - this feature will be used further. <br><br><h2>  Packing in an image with nginx </h2><br>  The application is assembled into the <code>/app/build</code> directory and it suffices to turn the described dimg into an artifact.  It is worth noting that artifact cannot contain Docker directives, so they need to be removed, but otherwise there are no differences from dimg.  Now you need to add a second dimg based on, for example, nginx: stable-ansible.  The ready nginx image is configured to return static files from <code>/usr/share/nginx/html</code> ‚Äî import <code>/app/build</code> into this directory.  The finished <code>dappfile.yml</code> looks like this: <br><br><pre> <code class="hljs cs">artifact: poolui-builder <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: node:<span class="hljs-number"><span class="hljs-number">9.11</span></span>-alpine git: - <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>: / to: /app stageDependencies: install: - package.json - bower.json beforeSetup: - app - gulpfile.js shell: beforeInstall: - apk update - apk <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> git - npm install --<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> bower - npm install --<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> gulp install: - cd /app - npm install - bower install --allow-root beforeSetup: - cd /app - gulp build --- dimg: poolui <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: nginx:stable-ansible import: - artifact: poolui-builder <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>: /app/build to: /usr/share/nginx/html after: install</code> </pre> <br>  The build command does not change: <br><br><pre> <code class="bash hljs">dapp dimg build</code> </pre> <br>  But the startup command must be changed - nginx listens on port 80. <br><br><pre> <code class="bash hljs">dapp dimg run poolui -p 8080:80 -ti --rm</code> </pre> <br>  When accessing localhost: 8080, the result is the same as with the launch of <code>gulp connect</code> : the page is shown in full. <br><br><img src="https://habrastorage.org/webt/0j/y1/vt/0jy1vtllzj5fsz3r2a6shwxt898.png"><br><br>  In the build log, you can look at the id stages and estimate the size of the intermediate and final images. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   dimgstage-poolui 0e27eaebff1f23312d18f83370ee30000a97139311fa141b86aa3f34b15e544d 6a1a7fc1aa98 8 minutes ago 25.1MB #   poolui-builder dimgstage-poolui f000dbe70d25a5abb998997e6c0530db52f228fee4cdd0390046657bdb3a6d32 8f300d169e5e 17 minutes ago 241MB</span></span></code> </pre> <br>  Now the frontend part is exactly ready!  Next you need to build and run the backend, which is somewhat more complicated and will be described in the next article. <br><br><h2>  Conclusion </h2><br>  The application is quite simple, but even with such an example it can be shown that the containerization of applications originally written without regard to Docker requires some thoughtful analysis.  But as a result, <code>dappfile.yaml</code> may turn <code>dappfile.yaml</code> , which will reassemble only the necessary stages, speeding up the incremental builds. <br><br>  The specificity of containerization of applications in JavaScript is precisely this - in determining what needs to be run at the assembly stage, since  There are a lot of tools and each customer has their own set of developers. <br><br><h2>  PS </h2><br>  Read also in our blog: <br><br><ul><li>  ‚Äú <a href="https://habrahabr.ru/company/flant/blog/348436/">Build projects with dapp.</a>  <a href="https://habrahabr.ru/company/flant/blog/348436/">Part 1: Java</a> ; </li><li>  ‚Äú <a href="https://habrahabr.ru/company/flant/blog/345580/">Build and heat applications in Kubernetes using dapp and GitLab CI</a> ‚Äù; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/336212/">Practice with dapp.</a>  <a href="https://habrahabr.ru/company/flant/blog/336212/">Part 1: Build simple applications</a> "; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/336170/">Practice with dapp.</a>  <a href="https://habrahabr.ru/company/flant/blog/336170/">Part 2. Deploying Docker images in Kubernetes with the help of Helm</a> ‚Äù; </li><li>  ‚Äú <a href="https://habrahabr.ru/company/flant/blog/324274/">We assemble Docker images for CI / CD quickly and conveniently along with dapp (review and video of the report)</a> ‚Äù; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/333682/">Officially present dapp - a DevOps utility to maintain the CI / CD</a> ." </li></ul></div><p>Source: <a href="https://habr.com/ru/post/359204/">https://habr.com/ru/post/359204/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../359192/index.html">Classic JavaScript algorithms and data structures</a></li>
<li><a href="../359194/index.html">Java and Project Reactor. Episode 2</a></li>
<li><a href="../359196/index.html">Google Tag Manager usage examples for customTask</a></li>
<li><a href="../359198/index.html">Create a calculator with units</a></li>
<li><a href="../359200/index.html">Google accused of spying on users Safari on iPhone</a></li>
<li><a href="../359206/index.html">Caution. How to use process metrics without harming process health</a></li>
<li><a href="../359208/index.html">How to quickly and efficiently work with priorities according to the Lean Prioritization method?</a></li>
<li><a href="../359210/index.html">VPNFilter infected more than 500,000 devices worldwide</a></li>
<li><a href="../359212/index.html">Add Distribution to SObjectizer-5 using MQTT and libmosquitto</a></li>
<li><a href="../359214/index.html">Recognizing scenes in images using deep convolutional neural networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>