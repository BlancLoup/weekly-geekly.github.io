<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flask Mega-Tutorial, Part 14: I18n and L10n</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the fourteenth article in the series, where I describe my experience of writing a Python web application using the Flask mic framework. 

 The...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flask Mega-Tutorial, Part 14: I18n and L10n</h1><div class="post__text post__text-html js-mediator-article">  This is the fourteenth article in the series, where I describe my experience of writing a Python web application using the Flask mic framework. <br><br>  The purpose of this guide is to develop a fairly functional microblog application, which I decided to call microblog, in the absence of originality. <br><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text">  <a href="http://habrahabr.ru/post/193242/">Part 1: Hello, World!</a> <br>  <a href="http://habrahabr.ru/post/193260/">Part 2: Templates</a> <br>  <a href="http://habrahabr.ru/post/194062/">Part 3: Forms</a> <br>  <a href="http://habrahabr.ru/post/196810/">Part 4: Database</a> <br>  <a href="http://habrahabr.ru/post/222983/">Part 5: User Login</a> <br>  <a href="http://habrahabr.ru/post/223375/">Part 6: Profile Page and Avatars</a> <br>  <a href="http://habrahabr.ru/post/223783/">Part 7: Unit Testing</a> <br>  <a href="http://habrahabr.ru/post/230643/">Part 8: Subscribers, Contacts and Friends</a> <br>  <a href="http://habrahabr.ru/post/230897/">Part 9: Pagination</a> <br>  <a href="http://habrahabr.ru/post/234613/">Part 10: Full Text Search</a> <br>  <a href="http://habrahabr.ru/post/234737/">Part 11: Email Support</a> <br>  <a href="http://habrahabr.ru/post/234785/">Part 12: Reconstruction</a> <br>  <a href="http://habrahabr.ru/post/236753/">Part 13: Date and Time</a> <br>  <a href="http://habrahabr.ru/post/236861/">Part 14: I18n and L10n (this article)</a> <br>  <a href="http://habrahabr.ru/post/237065/">Part 15: Ajax</a> <br>  <a href="http://habrahabr.ru/post/237317/">Part 16: Debugging, Testing, and Profiling</a> <br>  <a href="http://habrahabr.ru/post/237489/">Part 17: Deploying to Linux (even to Raspberry Pi!)</a> <br>  <a href="http://habrahabr.ru/post/237517/">Part 18: Deploying to Heroku Cloud</a> <br></div></div><br><a name="habracut"></a><br>  The topics of today's article are Internationalization and Localization, abbreviated I18n and L10n.  We would like to make our microblog available to as many people as possible, so we should not forget that many people in the world do not speak English, or perhaps speak, but prefer their native language. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To make our application accessible to foreign visitors, we will use the <a href="http://packages.python.org/Flask-Babel/">Flask-Babel</a> extension, which is an easy-to-use framework for translating the application into various languages. <br><br>  If you have not installed Flask-Babel, then it is time to do it.  For Linux and Mac users: <br><br><pre><code class="bash hljs">flask/bin/pip install flask-babel</code> </pre> <br>  And for Windows users: <br><br><pre> <code class="bash hljs">flask\Scripts\pip install flask-babel</code> </pre><br><br><h4>  <b>Customization</b> </h4><br>  Flask-Babel is initialized by simply creating an instance of the Babel class and passing our main Flask application to it (file app / __ init__.py): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask.ext.babel <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Babel babel = Babel(app)</code> </pre><br>  We also need to decide which languages ‚Äã‚Äãwe will support in our application.  Let's start with the support of the Spanish language, because we have a translator at hand with this language (your humble servant), but do not worry - in the future it will be enough just to add support for other languages.  We will put the list of supported languages ‚Äã‚Äãin our configuration file (config.py file): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # ... # available languages LANGUAGES = { 'en': 'English', 'es': 'Espa√±ol' }</span></span></code> </pre><br>  The LANGUAGES dictionary contains keys representing the codes of supported languages, and values ‚Äã‚Äãcontain the names of languages.  Here we use short versions of codes, but if necessary, full codes indicating the language and region can also be used.  For example, if we want to support British and American variations of the English language separately, we can add 'en-US' and 'en-GB' to our dictionary. <br><br>  Note that since the word Espa√±ol contains a character not included in the basic ascii character set, we need to add a coding comment line to the beginning of the file to tell the python interpreter that we use UTF-8 encoding, rather than ascii (in which naturally, there is no symbol √±). <br><br>  The next step in customization is to create a function that Babel will use to determine which language to use (app / views.py file): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> babel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LANGUAGES @babel.localeselector <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_locale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.accept_languages.best_match(LANGUAGES.keys())</code> </pre><br>  This function, wrapped by the localeselector decorator, will be called before each request, giving us a chance to choose a language to generate a response.  To begin, we will use a very simple approach, we will read the contents of the Accept-Languages ‚Äã‚Äãheader, which came from the browser along with the http request and will select the most appropriate language from our list of supported languages.  In fact, it is even easier than it seems - the best_match method will do all the work for us. <br><br>  The Accept-Languages ‚Äã‚Äãheader in most browsers defaults to the language installed in the OS, but all browsers allow the user to select other languages.  The user can even specify a list of languages, indicating the priority (weight) of each language.  As an example, consider the complex Accept-Languages ‚Äã‚Äãheader: <br><br><pre> <code class="html hljs xml">Accept-Language: da, en-gb;q=0.8, en;q=0.7</code> </pre><br>  This heading tells us that the user's preferred language is Danish (weight = 1.0), then comes British English (weight = 0.8) and the last option is just English (without specifying a region) (weight = 0.7). <br><br>  And the final step in customization will be the Babel configuration file, which tells Babel where to look for texts for translation contained in our code and templates (babel.cfg file): <br><br><pre> <code class="python hljs">[python: **.py] [jinja2: **/templates/**.html] extensions=jinja2.ext.autoescape,jinja2.ext.with_</code> </pre><br>  The first two lines tell Babel the file name patterns for our python code files and templates, respectively.  The third line tells Babel the extensions that need to be activated, and thanks to which it becomes possible to search for the text to be translated in Jinja2 templates. <br><br><h4>  <b>Mark the text for translation</b> </h4><br>  We start the most tiresome stage of this task.  We need to review all our code and templates and check all English sentences to be translated so that Babel can find them.  For an example, take a look at this after_login function code snippet: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> resp.email <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> resp.email == <span class="hljs-string"><span class="hljs-string">""</span></span>: flash(<span class="hljs-string"><span class="hljs-string">'Invalid login. Please try again.'</span></span>) redirect(url_for(<span class="hljs-string"><span class="hljs-string">'login'</span></span>))</code> </pre><br>  Here we have a flash message that we would like to translate.  To mark this text for Babel, we simply pass the string to the gettext () function: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask.ext.babel <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gettext <span class="hljs-comment"><span class="hljs-comment"># ... if resp.email is None or resp.email == "": flash(gettext('Invalid login. Please try again.')) redirect(url_for('login'))</span></span></code> </pre><br>  In the template we will act in a similar way, but here we have an alternative option - to use the _ () function, which is essentially an alias for the same gettext () function.  For example, the word Home in a link from our basic template: <br><br><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{{ url_for('index') }}"</span></span></span><span class="hljs-tag">&gt;</span></span>Home<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  can be noted for translation as follows: <br><br><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{{ url_for('index') }}"</span></span></span><span class="hljs-tag">&gt;</span></span>{{ _('Home') }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Unfortunately, not all the text we would like to translate is as simple as the one presented above.  As a more complex example, consider the following code snippet from our post.html template: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{{url_for('user', nickname = post.author.nickname)}}"</span></span></span><span class="hljs-tag">&gt;</span></span>{{post.author.nickname}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> said {{momentjs(post.timestamp).fromNow()}}:<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Here the sentence we would like to translate has the following structure: "&lt;nickname&gt; said &lt;when&gt;".  It is tempting to mark only the word ‚Äúsaid‚Äù for translation, but we cannot be 100% sure that the order of the name and the time in the sentence will be the same in different languages.  The correct solution here is to mark the entire proposal for translation, using placeholders for the name and time, so that the translator can change the order if necessary.  The situation is further complicated by the fact that the name component is a link! <br><br>  There is no simple and beautiful solution to this problem.  The gettext function supports placeholders using the% (name) syntax and that‚Äôs all we can do.  Here is a simple example of applying placeholders in a much simpler situation: <br><br><pre> <code class="python hljs">gettext(<span class="hljs-string"><span class="hljs-string">'Hello, %(name)s'</span></span>, name = user.nickname)</code> </pre><br>  The translator must be aware that there are placeholders and they do not need to be touched.  It is clear that the name of the placeholder (that is between ‚Äú% (‚Äú and ‚Äú) s‚Äù) should not be translated, otherwise we will simply lose the true value of the variable. <br>  But back to our post template.  Here is how we mark the text to be translated: <br><br><pre> <code class="html hljs xml">{% autoescape false %} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>{{ _('%(nickname)s said %(when)s:', nickname = '<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"%s"</span></span></span><span class="hljs-tag">&gt;</span></span>%s<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span>' % (url_for('user', nickname = post.author.nickname), post.author.nickname), when = momentjs(post.timestamp).fromNow()) }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> {% endautoescape %}</code> </pre><br>  Text that the translator sees for this example: <br><br><pre> <code class="html hljs xml">%(nickname)s said %(when)s:</code> </pre><br>  Which is quite good.  The value of the nickname and when variables is what constitutes the main difficulty of the translated sentence, but they are passed as additional arguments to the _ () function and are not visible to the translator. <br>  The nickname and when placeholders contain a lot of things.  In particular, for nickname we have to create a whole hyperlink, since we want the username to be a link to his profile. <br><br>  Since  The nickname placeholder contains html, we have to turn off auto-shielding when rendering, otherwise Jinja2 will render our html elements as screened text.  However, a request to render a string without shielding is deservedly considered a security risk; it is very unsafe to render the text entered by the user without shielding. <br><br>  The text that will be assigned to the when placeholder is safe, because this text is fully generated by our momentjs () function.  The value that comes to the place of the nickname placeholder, however, comes from the nickname field of our User model, which, in turn, is taken from the database, which gets from the web form filled by the user.  If someone signs up in our application with a nickname that contains html markup or javascript, and then we render this nickname unshielded, then this can be considered an invitation to cracking.  Of course, we want to avoid this, so we will conduct an inspection and remove all potential risks. <br><br>  The most reasonable solution is to limit the possibility of attacks, by limiting the set of characters allowed for use in a nickname.  We will start by creating a function that will convert incorrect usernames to correct ones (file app / models.py): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(db.Model)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#... @staticmethod def make_valid_nickname(nickname): return re.sub('[^a-zA-Z0-9_\.]', '', nickname)</span></span></code> </pre><br>  Here we simply remove from the nick all characters that are not letters, numbers, periods, or underscores. <br>  When a user registers on the site, we get his (her) nickname from the OpenID provider, and convert it, if necessary, to the correct view (file app / views.py): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@oid.after_login def after_login(resp): #... nickname = User.make_valid_nickname(nickname) nickname = User.make_unique_nickname(nickname) user = User(nickname = nickname, email = resp.email, role = ROLE_USER) #...</span></span></code> </pre><br>  In addition, in the profile editing form, where the user can change his nickname, we must extend the validation by checking the new nickname for the presence of invalid characters (file app / forms.py): <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EditForm</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Form)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#... def validate(self): if not Form.validate(self): return False if self.nickname.data == self.original_nickname: return True if self.nickname.data != User.make_valid_nickname(self.nickname.data): self.nickname.errors.append(gettext('This nickname has invalid characters. Please use letters, numbers, dots and underscores only.')) return False user = User.query.filter_by(nickname = self.nickname.data).first() if user != None: self.nickname.errors.append(gettext('This nickname is already in use. Please choose another one.')) return False return True</span></span></code> </pre><br>  With the help of such rather simple measures, we excluded the possibility of an attack when rendering a nickname on a page without screening. <br><br><h4>  <b>Extract text to be translated</b> </h4><br>  I will not list here all the necessary changes to mark all the text in the code and in the templates.  Interested readers can explore <a href="https://github.com/miguelgrinberg/microblog/commit/cac572cb0e427654edd3ac599f6197f1f6ee29f6">the change page</a> on GitHub. <br>  Let's imagine that we found all the text that needs translation, and wrapped it in gettext () or _ () calls.  What's next? <br>  Now we will run pybabel to extract all the text into a separate file: <br><br><pre> <code class="bash hljs">flask/bin/pybabel extract -F babel.cfg -o messages.pot app</code> </pre><br>  Windows users, use this command: <br><br><pre> <code class="bash hljs">flask\Scripts\pybabel extract -F babel.cfg -o messages.pot app</code> </pre><br>  The extract command of the pybabel utility reads the resulting configuration file, then scans all the code and template files in the folders specified by the command (in our case, only the app) and when it finds the text marked for translation, copies it to the messages.pot file. <br>  The messages.pot file is a template file that contains all the text that needs translation.  This file is used as a model for creating language files. <br><br><h4>  <b>Language Reference Generation</b> </h4><br>  The next step is to create a translation for a new language.  As we planned, we will add support for the Spanish language (es language code).  Here is a team that will add Spanish to the languages ‚Äã‚Äãsupported by our application: <br><br><pre> <code class="bash hljs">flask/bin/pybabel init -i messages.pot -d app/translations -l es</code> </pre><br>  running pybabel with the init parameter takes the .pot file as an input value and creates a directory of the new language in the directory specified in the -d parameter for the language specified in the -l parameter.  By default, Babel expects to find translations in the translations directory at the same level as the templates directory, so there we will create them. <br><br>  After running the above command, the app / translations / es directory will be created.  Inside, another LC_MESSAGES directory will be created, and inside it is the messages.po file.  The command can be run several times with different language codes to add support for these languages. <br><br>  The messages.po file created in each language directory uses a format that is the de facto standard for language translations, the same format used by <a href="http://www.gnu.org/software/gettext/">gettext</a> .  There are many applications for working with .po files.  For the needs of the translation, we will use poedit, since this is one of the most popular applications, which is also cross-platform. <br><br>  If you are not going to stop, and decide to make the same translation - download poedit at <a href="http://www.poedit.net/">this link</a> .  Using this application is quite simple.  Below is a screenshot of the program window after translating all the text into Spanish: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e69/607/91b/e6960791b0baa5a6ecea945786d22235.jpg" alt="image"><br><br>  At the top of the window is the text in the original and in the target language.  At the bottom left is a window in which the translator makes a translation. <br><br>  After finishing the translation and saving it to the messages.po file, it remains to take the last step: <br><br><pre> <code class="bash hljs">flask/bin/pybabel compile -d app/translations</code> </pre><br>  running pybabel with the compile option simply reads the contents of the .po file and saves the compiled version as a .mo file in the same directory.  This file contains the translated text in an optimized form that can be used by our application. <br><br>  Translation is ready to use.  To test it, you can specify the Spanish language preferred in your browser settings, or, if you don‚Äôt want to bother with the browser settings, you can just always return ‚Äúes‚Äù (Spanish language code) from the localeselector function (file app / views.py): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@babel.localeselector def get_locale(): return "es" #request.accept_languages.best_match(LANGUAGES.keys())</span></span></code> </pre><br>  Now, after the server is restarted, each time the gettext () or _ () function is called instead of English text, the translation will be given in the language defined by the localeselector function. <br><br><h4>  <b>Translation update</b> </h4><br>  What if we create messages.po is incomplete, that is, if some of the text to be translated is not represented in it?  Nothing bad will happen, just the text without a translation will be displayed in English ... <br><br>  What happens if we miss some text in English in our code or in templates?  All lines that are not wrapped in a call to the gettext () or _ () function will simply be missing from the translation files, and therefore Babel will not pay attention to them and they will remain in English.  As soon as we notice the missing text, we can wrap it in a call to the gettext () function, and then run the following commands to update the translation files: <br><br><pre> <code class="bash hljs">flask/bin/pybabel extract -F babel.cfg -o messages.pot app flask/bin/pybabel update -i messages.pot -d app/translations</code> </pre><br>  The extract command is identical to the one we used earlier; it simply generates an updated message.pot file with new text.  The update call accepts the new messages.pot file and adds the new text to all translation files found in the directory specified by the -d parameter. <br><br>  When the messages.po files in all directories are updated, we can run poedit again to translate the new texts, and then repeat the pybabel compile command to make the translation of new texts available to our application. <br><br><h4>  <b>Translation moment.js</b> </h4><br>  Now that we have added a Spanish translation for all the text found in our code and in the templates, we can launch the application to check how it looks in reality. <br><br>  And then we notice that all the time stamps remained in English.  The moment.js library, which we used to display dates and times, does not know anything about our desire to support some other language. <br><br>  After reading the <a href="http://momentjs.com/docs/">documentation</a> for the moment.js, we find that there is a decent list of supported languages ‚Äã‚Äãand that we just need to download another javascript file with the required language.  Thus, we simply download the Spanish version from the site moment.js and place it in the static / js directory with the name moment-es.min.js.  Here we follow the naming convention for the moment.js library files using the pattern moment- &lt;language code&gt; .min.js to be able to select the desired file dynamically. <br><br>  To be able to choose which javascript file to download, we must pass the language code to the template.  The easiest way is to add a language code to the global variable g, just as the user information is added (file app / views.py): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@app.before_request def before_request(): g.user = current_user if g.user.is_authenticated(): g.user.last_seen = datetime.utcnow() db.session.add(g.user) db.session.commit() g.search_form = SearchForm() g.locale = get_locale()</span></span></code> </pre><br>  And now when the language code is available in the template, we can load the required moment.js in our basic template (file app / templates / base.html): <br><br><pre> <code class="html hljs xml">{% if g.locale != 'en' %} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/static/js/moment-{{g.locale}}.min.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> {% endif %}</code> </pre><br>  Note that there is a condition here, because if we display the English version of the site, then we have all the texts in the right form after downloading the first moment.js. <br><br><h4>  <b>Lazy computing</b> </h4><br>  If we continue to work with the Spanish version of the site for a while, we will notice another problem.  When we log in to the site and then try to log in again, we see a flash message saying ‚ÄúPlease log in to access this page.‚Äù In English.  Where does this message come from?  Unfortunately, it is not we who display this message, it belongs and is displayed by a third-party Flask-Login extension. <br><br>  Flask-Login allows the user to customize this message, and we are going to use this opportunity, not to change the message, but to translate it.  So, the first attempt (file app / __ init__.py): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask.ext.babel <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gettext lm.login_message = gettext(<span class="hljs-string"><span class="hljs-string">'Please log in to access this page.'</span></span>)</code> </pre><br>  But it does not work.  The gettext function should be used in the context of the request to display the translated message.  If we call this function outside the request, it will simply give us the default text, and this is the English version ... <br><br>  For cases like this, Flask-Babel provides another function lazy_gettext, which does not immediately look for a translation like gettext () and _ (), but instead postpones the search until the time the string is used.  And here is how to properly configure this message (file app / __ init__.py): <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask.ext.babel <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lazy_gettext lm.login_message = lazy_gettext(<span class="hljs-string"><span class="hljs-string">'Please log in to access this page.'</span></span>)</code> </pre><br>  Finally, when using lazy_gettext, we must inform the pybabel extract command that the lazy_gettext function is also used to wrap the text to be translated.  This can be done with the -k option: <br><br><pre> <code class="bash hljs">flask/bin/pybabel extract -F babel.cfg -k lazy_gettext -o messages.pot app</code> </pre><br>  So after creating the next messages.pot, we update the language directories (pybabel update), translate the added text (poedit) and re-compile the translations (pybabel compile). <br><br>  And now we can say that our application is fully internationalized! <br><br><h4>  <b>Shortcuts</b> </h4><br>  Since the pybabel commands are rather long and difficult to remember, we will end this article with small scripts designed to simplify the most complex tasks we have seen before. <br>  Script to add a language to the translation catalog (file tr_init.py): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!flask/bin/python import os import sys if sys.platform == 'win32': pybabel = 'flask\\Scripts\\pybabel' else: pybabel = 'flask/bin/pybabel' if len(sys.argv) != 2: print "usage: tr_init &lt;language-code&gt;" sys.exit(1) os.system(pybabel + ' extract -F babel.cfg -k lazy_gettext -o messages.pot app') os.system(pybabel + ' init -i messages.pot -d app/translations -l ' + sys.argv[1]) os.unlink('messages.pot')</span></span></code> </pre><br>  Script for updating the directory with new text from source codes and templates (file tr_update.py): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!flask/bin/python import os import sys if sys.platform == 'win32': pybabel = 'flask\\Scripts\\pybabel' else: pybabel = 'flask/bin/pybabel' os.system(pybabel + ' extract -F babel.cfg -k lazy_gettext -o messages.pot app') os.system(pybabel + ' update -i messages.pot -d app/translations') os.unlink('messages.pot')</span></span></code> </pre><br>  Script to compile the directory (file tr_compile.py): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!flask/bin/python import os import sys if sys.platform == 'win32': pybabel = 'flask\\Scripts\\pybabel' else: pybabel = 'flask/bin/pybabel' os.system(pybabel + ' compile -d app/translations')</span></span></code> </pre><br>  These scripts should turn work with translation into a simple task. <br><br><h4>  <b>Conclusion</b> </h4><br>  Today we have implemented an aspect of our application that often falls outside the developer‚Äôs vision.  Users prefer to deal with their native language, t.ch.  we can provide translation for the number of languages, how many translators we can find.  If you are looking for a huge accomplishment. <br><br>  In the next article we will look at what is perhaps the most difficult task in the field of I18n and L10n - automatic translation of user-generated content in real time.  And we use this as a pretext for adding some Ajax magic to our application. <br><br>  Here is a link to the latest microblog, including a full translation into Spanish: <br><br>  Download <a href="">microblog-0.14.zip.</a> <br><br>  Or, if you like it better, you can find the source code on <a href="">GitHub</a> . <br><br>  Miguel </div><p>Source: <a href="https://habr.com/ru/post/236861/">https://habr.com/ru/post/236861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../236845/index.html">How to celebrate the day of the programmer at work and make everyone happy?</a></li>
<li><a href="../236847/index.html">Utah truck driver built the world's largest amateur telescope with a mirror diameter of 1.8 meters</a></li>
<li><a href="../236849/index.html">The History of the Titans, Part 2</a></li>
<li><a href="../236853/index.html">How to stop making executive project documentation</a></li>
<li><a href="../236859/index.html">Fail2ban and nginx: blocking unwanted traffic to a specific URL</a></li>
<li><a href="../236863/index.html">Parable about programmers and coders</a></li>
<li><a href="../236865/index.html">Website development (web applications) in C ++ (and not only) in the form of link libraries (* .so, * .dll)</a></li>
<li><a href="../236867/index.html">How Om Nom from Cut the Rope 2 moved to Amazon Fire Phone</a></li>
<li><a href="../236871/index.html">HP Unified Wired and Wireless Access</a></li>
<li><a href="../236873/index.html">A battery-free pacemaker works like a clock</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>