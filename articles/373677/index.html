<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MK AVR programming in the assembler language in the Linux environment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 It's no secret that microcontrollers of the AVR family are firmly established in the practice of home crafts. In addition, for several ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MK AVR programming in the assembler language in the Linux environment</h1><div class="post__text post__text-html js-mediator-article"><h1>  Introduction </h1><br>  It's no secret that microcontrollers of the AVR family are firmly established in the practice of home crafts.  In addition, for several years, there has been a massive ( <s>on the verge of an epidemic)</s> enthusiasm for debugging Arduino boards built on the basis of the same AVR.  I will not judge whether this is good or bad, because there are more than enough articles on this topic on the resource.  I want to protect my reader from the debate on "what is Arduino and good or bad."  The article is not about that. <br><br>  Sooner or later, for any ‚Äúarduinschik‚Äù (assuming that he wants to reach a higher professional level), the moment comes when within the framework of the Arduino platform it becomes cramped and he begins to think about what actually happens under the hood.  And the answers to all his questions already exist, for example, in the form of the remarkable course <a href="http://easyelectronics.ru/category/avr-uchebnyj-kurs">‚ÄúAVR.</a>  <a href="http://easyelectronics.ru/category/avr-uchebnyj-kurs">Training course "</a> from the respected <a href="https://geektimes.ru/users/dihalt/" class="user_link">DIHALT</a> .  If you are a user of Windows OS, then you will not have a shortage of development tools, a free Atmel Studio is enough to cover all software development issues for AVR MC. <br><br>  Although I am a team leader in the software development team of the application level, the issues of ‚Äúhardware‚Äù which in our office is being done on the basis of AVR have recently become very interesting for me.  There was a desire to understand well all aspects of software development for MK.  And since I am a staunch supporter of using Linux kernel-based OS in development, I was interested in the question, how is it in Linux: is it possible to / is it possible to write and debug software, stitch it into a crystal with the same (or approximately the same) level of convenience which is available to us in Windows.  Those who are also interested in this question, and in particular those to whom the topic of the post seems far-fetched, I invite you to the cat. <br><a name="habracut"></a><br>  With regard to development in C / C ++, there is no particular problem with Linux, in view of the general orientation of this system to the use of this language and the availability of a decent set of tools.  However, the same <a href="https://geektimes.ru/users/dihalt/" class="user_link">DIHALT</a> , for example, asserts that programming for MK is inseparable from knowledge of assembler, which I agree with, in view of the consistency of its theses set forth in the ‚ÄúTraining Course‚Äù and its own (albeit small) experience of system development under x86. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Guided by the thesis that we cannot get away from ASMA AVR and we are sitting under Linux, we will try to look at how to write and debug programs.  I use the Arch Linux distribution, so in my story I will rely on its ecosystem. <br><br><h1>  1. Choose a compiler </h1><br>  At once I will say that I will not offer a bunch of Atmel Studio + wine.  I do not like wine (although I use it as needed).  Let us dwell on the native means, first of all, compilers, the review of which in the network and the personal picks gave access to the triumvirate of <b>gavrasm</b> , <b>avra</b> and <b>avr-as</b> .  The choice was made according to two conflicting criteria: support for the syntax of the proposed Atmel and the ability to debug the firmware step by step in the emulator.  The latter is more important to me, and in the plane of the course @DIHAL is so straightforwardly necessary for understanding the process of the microcontroller.  The commonality of syntax with Atmel compilers gives, again from my point of view, only the ability to easily adapt Atmel Studio projects to work in Linux, which is a very dubious advantage, because the same avr-as also exists under Windows.  I offer the reader an overview of the listed trinity. <br><br><h2>  gavrasm and avra </h2><br>  Support Atmel syntax.  The first <a href="https://aur.archlinux.org/packages/gavrasm/">was found in the AUR</a> and is set by the command <br><br><pre><code class="bash hljs">$ yaourt -S gavrasm</code> </pre> <br>  The second is also <a href="https://aur.archlinux.org/packages/avra/">available in AUR</a> <br><br><pre> <code class="bash hljs">$ yaourt -S avra</code> </pre><br>  View Program <br><br>  <b>test.S</b> <br><br><pre> <code class="hljs css">;<span class="hljs-selector-tag"><span class="hljs-selector-tag">----</span></span>    <span class="hljs-selector-class"><span class="hljs-selector-class">.device</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">atmega16</span></span> ;<span class="hljs-selector-tag"><span class="hljs-selector-tag">----</span></span>   <span class="hljs-selector-class"><span class="hljs-selector-class">.dseg</span></span> ;<span class="hljs-selector-tag"><span class="hljs-selector-tag">----</span></span>   <span class="hljs-selector-class"><span class="hljs-selector-class">.cseg</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.org</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x0000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r16</span></span>, 10 <span class="hljs-selector-tag"><span class="hljs-selector-tag">M1</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">inc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r16</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rjmp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">M1</span></span> ;<span class="hljs-selector-tag"><span class="hljs-selector-tag">----</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">EEPROM</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.eseg</span></span></code> </pre><br>  It is compiled by both compilers at once in * .hex and the result of the work looks approximately the same.  In order not to disturb the noble Dons with long footcloths, I put the compilation results under the spoilers <br><br><div class="spoiler">  <b class="spoiler_title">Exhaust gavrasm</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ gavrasm test.S +------------------------------------------------------------+ | gavrasm gerd<span class="hljs-string"><span class="hljs-string">'s AVR assembler Version 3.5 (C)2015 by DG4FAC | +------------------------------------------------------------+ Compiling Source file: test.S ------- Pass: 1 14 lines done. Pass 1 ok. ------- Pass: 2 14 lines done. 3 words code, 0 words constants, total=3 = 0.0% No warnings! Compilation completed, no errors. Bye, bye ... $ ls -l  12 -rw-rw----+ 1 maisvendoo users 52  29 15:46 test.hex -rw-rw----+ 1 maisvendoo users 741  29 15:46 test.lst -rw-rw----+ 1 maisvendoo users 92  29 15:46 test.S</span></span></code> </pre><br><br>  The contents of the firmware hex file <br> <code>:020000020000FC <br> :060000000AE00395FECFAB <br> :00000001FF <br></code> <br>  Listing file contents <br><br> <code>gavrasm Gerd's AVR assembler version 3.5 (C)2015 by DG4FAC <br> ---------------------------------------------------------- <br> Source file: test.S <br> Hex file: test.hex <br> Eeprom file: test.eep <br> Compiled: 29.07.2017, 15:46:38 <br> Pass: 2 <br> 1: .device atmega16 <br> 2: <br> 3: .dseg <br> 4: <br> 5: .cseg <br> 6: .org 0x0000 <br> 7: <br> 8: 000000 E00A ldi r16, 10 <br> 9: M1: <br> 10: 000001 9503 inc r16 <br> 11: 000002 CFFE rjmp M1 <br> 12: <br> 13: .eseg <br> 14: <br> <br> Program : 3 words. <br> Constants : 0 words. <br> Total program memory: 3 words. <br> Eeprom space : 0 bytes. <br> Data segment : 0 bytes. <br> Compilation completed, no errors. <br> Compilation endet 29.07.2017, 15:46:38 <br></code> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Exhaust avra</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ avra -l test.lst test.S AVRA: advanced AVR macro assembler Version 1.3.0 Build 1 (8 May 2010) Copyright (C) 1998-2010. Check out README file <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more info AVRA is an open <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> assembler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Atmel AVR microcontroller family It can be used as a replacement of <span class="hljs-string"><span class="hljs-string">'AVRASM32.EXE'</span></span> the original assembler shipped with AVR Studio. We <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> not guarantee full compatibility <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> avra. AVRA comes with NO WARRANTY, to the extent permitted by law. You may redistribute copies of avra under the terms of the GNU General Public License. For more information about these matters, see the files named COPYING. Pass 1... Pass 2... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Used memory blocks: Code : Start = 0x0000, End = 0x0002, Length = 0x0003 Assembly complete with no errors. Segment usage: Code : 3 words (6 bytes) Data : 0 bytes EEPROM : 0 bytes $ ls -l  16 -rw-rw----+ 1 maisvendoo users 92  29 15:46 test.S -rw-rw----+ 1 maisvendoo users 0  29 15:55 test.S.cof -rw-rw----+ 1 maisvendoo users 13  29 15:55 test.S.eep.hex -rw-rw----+ 1 maisvendoo users 55  29 15:55 test.S.hex -rw-rw----+ 1 maisvendoo users 61  29 15:55 test.S.obj</code> </pre><br>  Hex file content <br> <code>:020000020000FC <br> :060000000AE00395FECFAB <br> :00000001FF <br></code> <br>  Listing is generated with the -l option when building <br> <code>$ cat test.lst <br> <br> AVRA Ver. 1.3.0 test.S Sat Jul 29 16:02:05 2017 <br> <br> .device atmega16 <br> <br> .dseg <br> <br> .cseg <br> .org 0x0000 <br> <br> C:000000 e00a ldi r16, 10 <br> M1: <br> C:000001 9503 inc r16 <br> C:000002 cffe rjmp M1 <br> <br> .eseg <br> <br> <br> Segment usage: <br> Code : 3 words (6 bytes) <br> Data : 0 bytes <br> EEPROM : 0 bytes <br> <br> Assembly completed with no errors. <br></code> <br></div></div><br>  Analyzing the results we can say that: <br><br><ol><li>  Generates a file in Intel HEX format, suitable immediately for firmware in the MK </li><li>  Syntax compatible with Atmel </li></ol><br>  There are definitely differences in the avra syntax, for example <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.device</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">atmel16</span></span></code> </pre><br>  gives an indication of the MC, hiding from the programmer an explicit indication of references to the * .inc file of macros.  There are a number of other nuances that are easier to read in the <a href="http://avra.sourceforge.net/README.html">documentation</a> or in a <a href="http://crafting.be/2013/08/avr-assemblers/">good overview article of Valber</a> in Russian.  About the features of gavrasm can be <a href="http://www.avr-asm-tutorial.net/gavrasm/GAVRASMI.html">read here</a> . <br><br>  Both of the considered compilers have a significant <s>fatal</s> flaw - they do not generate debug information.  Although in avra documentation this possibility is stated <br><blockquote>  Debugging support AVRA creates a coff file everytime the assembly was sucessful.  This file allows you to use the program. <br></blockquote><br>  but the * .cof file in the exhaust invariably turns out to be empty.  The absence of debugging information eliminates adequate debugging in steps, which is very necessary for beginners.  So from these (by the way, pretty old alternatives) we move on to another, more powerful compiler from the GNU family. <br><br><h2>  avr-as </h2><br>  The installation of this toolkit is available from the official repositories of any fairly popular distribution.  In the case of Arch Linux <br><br><pre> <code class="bash hljs">$ sudo pacman -S avr-gcc avr-libc avr-binutils</code> </pre><br>  GNU assembler (gas) is a backend to the gcc compiler and is usually not explicitly invoked.  This is due to the ideology of * nix systems, focused on the development of C / C ++, in which the assembler plays the role of the youngest unloved son.  At the same time, it provides deep integration of assembler code into C / C ++ programs, which is rare, but sometimes necessary.  In addition, if we talk about x86 / x86_64 architectures, the ‚Äúbent‚Äù assembler (AT &amp; T) syntax is very different from the adopted Intel notation (although the Intel-syntax can be used on gas, the compiler allows this).  What is the reverse order of the operands in the commands in relation to intel-notation, for example <br><br>  With regard to AVR gas, it does not depart from the Atmel notation regarding the design of commands - the order of operands is usual here, for example, the command: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">ldi</span></span> r16, <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  in gas for AVR looks familiar.  Macroes and compiler directives are another matter; they differ from Atmel.  The above test program will look like this: <br><br>  <b>test.S</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/usr/avr/include/avr/io.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> .data </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> .section .text .org 0x0000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  ,    avr-gcc  avr-as */</span></span></span><span class="hljs-meta"> .global main main: ldi r16, 10 M1: inc r16 rjmp M1</span></span></code> </pre><br>  As can be seen from the source, the code section is defined by the preprocessor directive .section .text (analogous to .cseg).  Analog to .dseg is .data.  The only thing I have not yet understood and saw in the documentation is how the contents of the EEPROM (analogue .eseg) are determined.  I hope among the readers there is a kind guru who will push me to answer.  For newbies like me, I advise you to smoke the documentation <a href="http://www.nongnu.org/avr-libc/user-manual/assembler.html">here</a> and <a href="http://microsin.net/programming/avr/avr-gcc-options.html">here</a> to understand the specifics of using gas for AVR. <br><br>  We will now compile a hex file suitable for the MK firmware.  Team: <br><br><pre> <code class="hljs cmake">$ avr-as -mmcu=atmega16 -o <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.o <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.S</code> </pre><br>  generates an object file for the corresponding controller (in our case, ATMega 16).  This object file is then converted to hex. <br><br><pre> <code class="hljs cmake">$ avr-objcopy -O ihex <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.o <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.hex</code> </pre><br>  Getting the output hex file <br><br>  <b>test.hex</b> <br> <code>:060000000AE00395FECFAB <br> :00000001FF <br></code> <br>  Nevertheless, we did not answer the main question and did not identify the advantage of gas on the possibility of organizing step by step debugging.  For this first of all <br><br><h1>  2. Choose a debugger </h1><br>  In Linux there is no decent alternative to GDB.  For its use in relation to the AVR MK set frontend <br><br><pre> <code class="hljs ruby">$ sudo pacman -S avr-gdb</code> </pre><br>  This debugger possesses the entire complex of contradictions, frightening beginners: with fairly stated thermonuclear power, the threshold for its entry is rather high.  To unlearn the fear of gdb and start working in it, I highly recommend the article of the greatest and mighty and, unfortunately, now deceased (earth you down, Myshch!) Nikolai Likhachev aka Chris Kaspersky <a href="http://l.wzm.me/_nezumi/gdb.htm">"Immersion in GDB technique and philosophy"</a> . <br><br>  The first thing you need to use gdb is to build the code accordingly, generating an ELF image containing debugging symbols. <br><br><pre> <code class="hljs pgsql">$ avr-<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> -mmcu=atmega16 -g <span class="hljs-comment"><span class="hljs-comment">--gstabs -o test.o test.S</span></span></code> </pre><br>  The -g and --gstabs keys generate debugging symbols, respectively, and add the ability to use the image for remote debugging in gdb.  Compose the resulting object file in ELF <br><br> <code>$ avr-ld -m avr4 -o test.elf test.o <br></code> <br>  The resulting image we use to debug our test.  You can also generate a hex file from it. <br><br><pre> <code class="hljs matlab">$ avr-objcopy -<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> .text -<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> .data -O ihex test.elf test.hex</code> </pre><br>  explicitly specifying the -j key to include in the firmware section, the key -O ihex output format (intel HEX).  We get the same file as in the previous case: <br><br>  <b>test.hex</b> <br> <code>:060000000AE00395FECFAB <br> :00000001FF <br></code> <br>  It remains to load the received code into the emulator and check the debugging options available. <br><br><h1>  3. AVR emulator in Linux </h1><br>  This question is more difficult than others.  I found two worthy candidates: <b>simavr</b> , available <a href="http:">in the official archa repositories</a> and installed by simple: <br><br><pre> <code class="hljs ruby">$ sudo pacman -S simavr</code> </pre><br>  and the more popular <b>simulavr</b> simulator, which was not found even in AUR, while the majority of useful information on the network is about it.  I did not get out of the source code to create a PKGBUILD for the AUR, although I went through all the appropriate branches in the <a href="">official repository</a> .  I had to beat the atrocious crutch by downloading the <a href="https://packages.debian.org/stretch/simulavr">Debian DEB package</a> , turning it into an archa package with the help <a href="https://aur.archlinux.org/packages/debtap/">of the debtap utility</a> . <br><br><pre> <code class="hljs ruby"> $ debtap simulavr_<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1.2</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">7</span></span>+b2_amd64.deb</code> </pre><br>  and then the resulting arch package without any problems put in the system. <br><br>  This version is quite old, and the current release (judging by the date of the last commit in the repository) has gone quite far. <br><br>  As for simavr, it is installed without problems, it supports a larger number of MCs, but when trying to connect to it with a debugger, it issues messages on the emulator crash to the console and I haven‚Äôt managed to figure it out yet.  Here I again appeal to the reader who is knowledgeable in the question and look forward to a hint. <br><br>  In the meantime, we use the simulavr set up with a crutch <br><br><h1>  4. Step-by-step debugging on the GDB + simulavr bundle </h1><br>  So, first we will debug the program hardcore - from the console we will launch the emulator <br><br><pre> <code class="hljs swift">$ simulavr -d atmega16 -<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-number"><span class="hljs-number">8000000</span></span> -g -<span class="hljs-type"><span class="hljs-type">P</span></span> simulavr-disp</code> </pre><br>  We start the ATMega 16 emulator (-d key) at 8 MHz (-c key) with the option of remote debugging and the possibility to view controller registers beautifully (the -P option, which has been removed from the network in the latest emulator version).  We see the terminal window with the contents of the registers and memory <br><br><img src="https://habrastorage.org/web/834/191/e9e/834191e9e43746cc9c839bb12be363aa.png"><br><br>  we observe in the start console the message <br><br><pre> <code class="hljs vhdl">Waiting <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">port</span></span> <span class="hljs-number"><span class="hljs-number">1212</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> gdb client <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> connect...</code> </pre><br>  telling us that the emulator waits for the debugger to be connected on port 1212 (the port can be specified at startup with the -p switch).  In another console, start the debugger: <br><br><pre> <code class="hljs ruby">$ avr-gdb -q -tui</code> </pre><br>  the first key removes the pathetic exhaust of gdb at startup, the second group of keys activates the viewing of sources in the debugging process and is applied by me for clarity (in fact, this option is inconvenient for several reasons).  In the console we will see the following: <br><br><img src="https://habrastorage.org/web/f13/b3c/d55/f13b3cd55ea14b5fbe6487e2b1abdc62.png"><br><br>  We are connected to the emulator <br><br><pre> <code class="hljs css">(<span class="hljs-selector-tag"><span class="hljs-selector-tag">gdb</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">remote</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:1212</span></span></code> </pre><br>  We load the ELF-image into the emulator (yes, it is his and not hex, which I burned at the very beginning) d 'vekznjh <br><br><pre> <code class="hljs pgsql">(gdb) <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> test.elf</code> </pre><br>  Load the debug symbols: <br><br><pre> <code class="hljs cmake">(gdb) <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.elf</code> </pre><br>  answering "yes" to the question asked, getting the following picture: <br><br><img src="https://habrastorage.org/web/e74/2b6/527/e742b6527f884b969b2c6d17b150b6b9.png"><br><br>  Well, we see our source and debugger, ready to receive commands.  Give the command next <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">gdb</span></span>) n</code> </pre><br>  and see the debugger move cheerfully through the code. <br><br><img src="https://habrastorage.org/web/4a2/d93/09b/4a2d9309bff747a6a62d84976e770d33.png"><br><br>  we can see the changed state of the controller registers as in the emulator console <br><br><img src="https://habrastorage.org/web/c3f/7e4/aa7/c3f7e4aa79d3447ebf0aee30ce4e5d2d.png"><br><br>  and in the debugger window: <br><br><pre> <code class="hljs xml">(gdb) info registers . . . r16 0xa 10 . . . SREG 0x0 0 SP 0x0 0x0 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">main</span></span></span><span class="hljs-tag">&gt;</span></span> PC2 0x2 2 pc 0x2 0x2 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">M1</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  From this point on, all the rich tools provided by the gdb debugger are available to us.  However, <s>the Linux kernel is well</s> reproached for saying that ‚Äúdude, Atmel Studio has normal debugging with displaying source codes, moving the hot keys along the code in a sensible graphical way‚Äù and will try to solve the problem of friendliness of debugging at least partially by combining its development <br><br><h1>  5. Step-by-step debugging in the Eclipse IDE </h1><br>  IDE Eclipse is known for a long time.  During its existence, it has firmly established itself in various areas of software development and can "stupidly everything", thanks to an extensive set of plug-ins that extend its functionality.  At one time, I was delighted with her, but this time has passed, since in everyday work she has a lot of small nuances that swell into flaws (at work in production I preferred for the same C / C ++ QtCreator due to the specifics of the activity, which I don‚Äôt regret ). <br><br>  Nevertheless, from the point of view of the problem we are solving, it completely satisfies its requirements.  To work with AVR in Eclipse, you will need to install the following plugins <br><br><img src="https://habrastorage.org/web/38d/65b/dec/38d65bdec9aa4a149413473ba095b858.png"><br><br>  and, in order not to overload the article, I refer the reader to a search in which the installation of plug-ins for Eclipse is described in great detail.  Important here is the setting up of the project, which I will discuss in detail. <br><br>  Eclipse is essentially C / C ++ development oriented, so to create an assembly project we will use the project generation through the existing Makefile, which we will write for our test.  Here he is <br><br>  <b>Makefile</b> <br><pre> <code class="hljs mel">#    DEVICE = atmega16 TARGET = test OBJECTS = $(TARGET).o ELF = $(TARGET).elf HEX = $(TARGET).hex #    COMPILE = avr-as -mmcu=$(DEVICE) -g --gstabs #   - HEX-  all: hex #    :    #   *.S      *.o .So: $(COMPILE) -c $&lt; -o $@ #   -     clean: rm -f $(HEX) $(ELF) $(OBJECTS) #      ELF elf: $(OBJECTS) avr-ld -m avr4 -o $(ELF) $(OBJECTS) #  ELF  HEX hex: elf avr-objcopy -j .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span> -j .data -O ihex $(ELF) $(HEX)</code> </pre><br>  Having written this opus, open Eclipse and create a new project File -&gt; New -&gt; Project, choosing a sish project based on the Makefile <br><br><img src="https://habrastorage.org/web/af9/724/36a/af972436aa654a0cb2c0032acfe89253.png"><br><br>  Click Next, in the next window, select the location of the source directory and the Makefile <br><br><img src="https://habrastorage.org/web/06f/c0f/41d/06fc0f41ddf643eda420a3763c6a2d98.png"><br><br>  Spank Finish and see our project in all its glory <br><br><img src="https://habrastorage.org/web/510/b13/0ea/510b130ead7d4dcca2640f79d5c0e510.png"><br><br>  Go to the menu Project -&gt; Build all and get all the binaries we need: <br><br><pre> <code class="hljs cmake"><span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">34</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span> **** Build of configuration Default for <span class="hljs-keyword"><span class="hljs-keyword">project</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> **** make all avr-as -mmcu=atmega16 -g --gstabs -c <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.S -o <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.o avr-ld -m avr4 -o <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.elf <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.o avr-objcopy -j .text -j .data -O ihex <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.elf <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.hex <span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">34</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span> Build Finished (took <span class="hljs-number"><span class="hljs-number">128</span></span>ms)</code> </pre><br>  Now let's set up the emulator launch as an external project tool by going to Run -&gt; External Tools, creating a new configuration with settings corresponding to the given screens. <br><br><img src="https://habrastorage.org/web/7b7/914/0fc/7b79140fc75c406f983f758f96dd3cb2.png"><br><br><img src="https://habrastorage.org/web/c41/9ec/0f2/c419ec0f28f744038918efcac5c20a6a.png"><br><br>  Here we inform the environment that we want to run the emulator with the command line parameters we need by placing the launch point in the Run ‚Üí External Tools menu. <br><br>  Apply the settings, go to the Run ‚Üí External Tools ‚Üí atmega16 menu and watch the emulator start: <br><br><img src="https://habrastorage.org/web/573/7b3/c96/5737b3c96da84057b57daae7f8594bcc.png"><br><br>  Ok, now let's set up the debug configuration of our project.  Go to the Run ‚Üí Debug Configuratuions menu and configure hardware debugging via GDB. <br><br><img src="https://habrastorage.org/web/64d/48e/01a/64d48e01af1040dcb99e43b513db08a2.png"><br><br>  without forgetting to specify the type of connection to the simulation server: <br><br><img src="https://habrastorage.org/web/430/ec5/81c/430ec581c2454594b4c2222752556f29.png"><br><br>  and specifying what actions should be performed when debugging starts: <br><br><img src="https://habrastorage.org/web/7f2/f30/2fe/7f2f302febcc42ada6ee5b56803900a8.png"><br><br>  Be sure to put daws on Load image and Load Symbols - this allows the debugger to load the firmware into the emulator and read the debugging symbols.  Put a breakpoint on the label M1. <br><br>  Click the Apply and Debug buttons and ... voila! <br><br><img src="https://habrastorage.org/web/747/6c0/751/7476c075175844628467b52347daf9b2.png"><br><br>  The debugger obediently became at the specified breakpoint.  Viewable memory dump and register contents.  Hit F5 (or F6) and trace our code step by step. <br><br><img src="https://habrastorage.org/web/c01/83b/1b9/c0183b1b99114432a63c48ad98a73844.png"><br><br>  Now you can even trace the code until blue in the face, watch the values ‚Äã‚Äãof the registers and variables, edit the code, trace again, and generally engage in the usual development process. <br><br><h1>  Conclusion </h1><br>  What do I want to say in the final?  I have already said a thousand times that all my articles on Habr and Hyktimes resources are a reflection of personal experience and a mouthpiece of subjective opinion.  Solved the problem - the organization of software development for AVR controllers in the Linux environment.  This article is a product of long googling and gathering information from disparate network sources.  Its goal is to push the beginner to search in the right direction.  The article does not pretend to be academic, it is only a product of my own digging and an attempt to share the collected information, as well as to attract interested people to an interesting topic for me. <br><br>  There is not much to be said about it, for example, about firmware via avrdude, which (sic!) Is a cross-platform firmware utility for the AVR family.  If readers have a desire, but I have the opportunity, we will consider it, blink LEDs, send the word <s>"ass"</s> "happiness" through USART and so on.  The topic is inexhaustible and worthy of continuation.  Time will tell. <br><br>  In the meantime, thank my reader for your attention and hope for a new meeting! </div><p>Source: <a href="https://habr.com/ru/post/373677/">https://habr.com/ru/post/373677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../373663/index.html">Dell Latitude 5289: a long-running and compact laptop-transformer</a></li>
<li><a href="../373665/index.html">Bondic Light Cured Plastic</a></li>
<li><a href="../373669/index.html">Supernovae neutrinos. How they are born, how we wait for them, and why it is interesting.</a></li>
<li><a href="../373671/index.html">Friday format: how to start working in the music industry (part 2)</a></li>
<li><a href="../373673/index.html">Working with a digital oscilloscope (mastering only the AUTO button is dedicated)</a></li>
<li><a href="../373679/index.html">We and everything that surrounds us is 50% made up of matter that came here from distant galaxies.</a></li>
<li><a href="../373681/index.html">Breakthrough Starshot launched the world's smallest satellite into Earth orbit</a></li>
<li><a href="../373683/index.html">Mobile Commerce with Social Overtones</a></li>
<li><a href="../373685/index.html">Repair of the pulse power supply unit PRN150M-6 (EM9005 PS / AC)</a></li>
<li><a href="../373689/index.html">Cybersecurity experts: tens of thousands of smart cameras can be hacked effortlessly</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>