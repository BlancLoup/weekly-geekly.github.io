<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About source code analysis and automatic generation of exploits</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, only lazy has not written about the analysis of source code security. It is understandable, because the guy from Gartner, as suggested to co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About source code analysis and automatic generation of exploits</h1><div class="post__text post__text-html js-mediator-article">  Recently, only lazy has not written about the analysis of source code security.  It is understandable, because the guy from Gartner, as <a href="http://blogs.gartner.com/neil_macdonald/2011/01/19/static-or-dynamic-application-security-testing-both/">suggested to</a> consider the analysis of the source code as a new HYIP a few years ago, still has not given the go-ahead to stop doing this.  And, given the current direction of my work (participation in the development of <a href="http://vimeo.com/76045841">PT Application Inspector</a> , then AI), and the fact that recently there were no valid articles on the topic of source code analysis, it‚Äôs somehow even strange that until today of the day there were no dirty details on this burning topic on this blog.  Well, correcting. <a name="habracut"></a><br><br>  Actually everything that could be said about our approach to automating the analysis of source code security in AI was already said by Sergey Plekhov and Alexey Moskvin in the report ‚Äú <a href="http://live.digitaloctober.ru/embed/2994">Problems of automatic generation of exploits by source code</a> ‚Äù on PHDays IV.  For those who did not attend the report and did not watch its recording, I highly recommend doing this before reading the article further.  However, at the end of the report from Ivan Novikov, aka <a href="https://twitter.com/d0znpp">@ d0znpp</a> , several questions were raised on the topic ‚Äúwhat is the case?‚Äù, ‚ÄúHow does your approach differ from the same RIPS?‚Äù And ‚Äúhow do you get entry points then?‚Äù In the context of the statement that without deploying an application, it is impossible to obtain external data necessary for building an exploit (such as, for example, the privileged user name and password, routes to entry points, etc.).  I want to immediately make a reservation that some terminological confusion takes place here: the name ‚Äúthe problem of automatically deriving sets of attack vectors from the source code‚Äù would more accurately reflect the essence of the problems solved during the work on AI.  Calling what turns out at the output of AI exploit is really not quite correct.  If only because it is cooler than just an exploit in the traditional understanding of this term :) And then I will try to uncover this thought and supplement my colleagues with a more detailed answer to the questions asked by Ivan. <br><br><h2>  What is the case? </h2><br>  First of all, the case consists in finding flaws in the code and confirming their vulnerability to certain classes of attacks.  The task of automatic generation of exploits in this case is reduced to the conclusion of the minimum attack vector, confirming the existence of vulnerability.  At the same time, a vector means not a specific HTTP request, but a certain combination of factors leading the system into a state of vulnerability and allowing a successful attack on it.  I will say even more: in the general case, it is not possible to express the attack vector in the form of an HTTP request only.  First, because this vector may require multiple queries.  Secondly (and this is important), because the vector can include conditions on any properties of the environment that cannot be described in the context of an HTTP request.  Nevertheless, within the framework of the case under consideration, we must: a) derive all such conditions;  b) somehow make them in the results of the analysis.  This is what led to such an intricate definition of a vector.  I‚Äôll give a simple example (hereinafter, C # code under ASP.NET Web Forms is considered): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> settings = Settings.ReadFromFile(<span class="hljs-string"><span class="hljs-string">"settings.xml"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> str1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (settings[<span class="hljs-string"><span class="hljs-string">"key1"</span></span>] == <span class="hljs-string"><span class="hljs-string">"validkey"</span></span>) { Response.Write(Request.Params[<span class="hljs-string"><span class="hljs-string">"parm"</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Response.Write(<span class="hljs-string"><span class="hljs-string">"Wrong key!"</span></span>); }</code> </pre> <br>  Obviously, in this case, the vulnerability to the XSS attack depends on the value of the key1 parameter in the configuration file settings.xml.  And, if we honestly read it (that is, in fact, rather than symbolically calling the Settings.ReadFromFile ("settings.xml") call and assigning the result to the variable settings), then we will go only along one of two possible ways run, which will inevitably lead us to skip the vulnerability in the event that the key1 parameter in the file is not set to ‚Äúvalidkey‚Äù.  By performing the first call symbolically, we will end up with the following formula, which will be the desired vector: <br><br><pre> <code class="cs hljs">Settings.ReadFromFile(<span class="hljs-string"><span class="hljs-string">"setings.xml"</span></span>)[<span class="hljs-string"><span class="hljs-string">"key1"</span></span>] == <span class="hljs-string"><span class="hljs-string">"validkey"</span></span> -&gt; {Request.Params[<span class="hljs-string"><span class="hljs-string">"Parm"</span></span>] = &lt;script&gt;alert(<span class="hljs-number"><span class="hljs-number">0</span></span>)&lt;/script&gt;}</code> </pre><br>  We can also infer from this and the HTTP exploit: <br><br><pre> <code class="cs hljs">GET http:<span class="hljs-comment"><span class="hljs-comment">//host.domain/path/to/document.aspx?parm=%3Cscript%3Ealert%280%29%3C%2fscript%3E HTTP/1.1</span></span></code> </pre><br>  which, however, is not self-sufficient and depends on the conditions imposed on the environment of the web application. <br><br>  Obtaining any values ‚Äã‚Äãfrom a database, file system or any other external source leads to a simple dilemma: either we get external data and have the opportunity to build full-fledged exploits (where theoretically possible), but skip the potential vulnerabilities due to for loss of execution paths, or we process calls to external sources symbolically and, thereby, cover all possible sets of values ‚Äã‚Äãand execution paths that may occur as a result of such calls.  And since we were faced with the task of not creating a universal attacker-all-powerful device, but rather maximally automating the human routine for analyzing the code security, obtaining vectors in the form of proven logical formulas that require further human work in terms of building full-fledged exploits is preferable to automated functional. <br><br>  However, situations are possible where without reading external data it really is nowhere: this is defining routes to entry points to a web application if they are defined in external configuration files and not in application code, and connecting additional source code files through their listing in configuration files (relevant for dynamic languages), and a number of similar tasks.  But there are no questions here: if it‚Äôs necessary, it means that we‚Äôll read with our fingers crossed.  Where we can, of course. <br><br>  Summing up: at the moment, there are no obstacles to teaching AI to read data from the database and use it during the symbolic execution of the analyzed code.  However, this will require the deployment of at least a database of a web application on the one hand and will significantly decrease the analyzer‚Äôs ability to detect vulnerabilities on the other, without giving any tangible advantages within the framework of the task set before us, which I described above. <br><br><h2>  How is your approach different from RIPS? </h2><br>  As far as I can judge the <a href="http://syssec.rub.de/media/emma/veroeffentlichungen/2014/01/21/rips-NDSS14.pdf">approach</a> adopted in RIPS, AI'shny - differs slightly more than all.  Starting with the fact that RIPS implements classic static-taint-analysis via tagging paths in a data flow graph with emulation of a number of standard library functions, and the AI ‚Äã‚Äãtrip involves building a model (one for each entry point) as a system of logical statements describing the state of the application in each CFG node and the conditions for its achievement, which makes it possible to resolve any paths in it (including ifs, conditional returns, exception handling, etc.) also with partial execution of the real code instead of emulating it, where it gives the best re  result compared to symbolic execution.  And ending (but not limited to) the fact that RIPS stupidly breaks off on custom filtering functions, while the AI ‚Äã‚Äãis trying to work with them (and very successfully in most real cases). <br><br>  Probably better show by example.  Let's say we have the following source code fragment <a name="cite_ref-1"></a>  <sup><a href="https://habr.com/ru/company/pt/blog/224547/">[1]</a></sup> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name = Request.Params[<span class="hljs-string"><span class="hljs-string">"name"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> key1 = Request.Params[<span class="hljs-string"><span class="hljs-string">"key1"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> parm = Request.Params[<span class="hljs-string"><span class="hljs-string">"parm"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(parm)) { data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { data = Convert.FromBase64String(parm); } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> str1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name + <span class="hljs-string"><span class="hljs-string">"in"</span></span> == <span class="hljs-string"><span class="hljs-string">"admin"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key1 == <span class="hljs-string"><span class="hljs-string">"validkey"</span></span>) { str1 = Encoding.UTF8.GetString(data); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { str1 = <span class="hljs-string"><span class="hljs-string">"Wrong key!"</span></span>; Response.Write(str1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { str1 = <span class="hljs-string"><span class="hljs-string">"Wrong role!"</span></span>; } Response.Write(<span class="hljs-string"><span class="hljs-string">"&lt;a href='http://host.domain' onclick='"</span></span> + CustomSanitize(str1) + <span class="hljs-string"><span class="hljs-string">"'&gt;Click me&lt;/a&gt;"</span></span>);</code> </pre><br>  Obviously, a potentially dangerous operation takes place here (hereinafter PVO - Potentially Vulnerable Operation) - calling the Response.Write method, which writes to the HTTP request response generated by the server.  In the first case, the constant ‚ÄúWrong Key!‚Äù Is passed to the method, which is of no interest to us.  But in the second, the response is the result of calling the CustomSanitize method with an argument whose value is calculated from the values ‚Äã‚Äãof the parameters of the received request.  But what should they be in order for us to be able to pass a value to str1 sufficient to confirm the possibility of carrying out an XSS attack through the injection of HTML markup elements?  Let's look at how the process of finding the answer to this question might look like. <a name="cite_ref-2"></a>  <sup><a href="https://habr.com/ru/company/pt/blog/224547/">[2]</a></sup> . <br><br>  To begin with, we derive the reachability condition of the second Response.Write.  Despite the fact that he himself is not nested in any constructions affecting the control flow, in the preceding blocks of code there is a return from the function common to the whole code, the condition of reachability of which is at the same time the condition of the unattainability of our PVO.  It is obvious that the condition for the execution of the operator return is a logical expression: (name == "adm" &amp;&amp; key1! = "Validkey").  Therefore, the condition of its unattainability will be the expression: (name! = "Adm" || name == "adm" &amp;&amp; key1 == "validkey").  Since this return is the only statement that affects the reachability of the second Response.Write, the last expression will be the condition of the reachability of the PVO. <br><br>  In fact, the expression (name! = "Adm" || name == "adm" &amp;&amp; key1 == "validkey") gives us two mutually exclusive conditions for the formation of the path to the PVO on the control flow graph.  Consider the possible values ‚Äã‚Äãof str1 when executing each of them.  When (name! = "Adm"), the variable str1 gets the constant value "Wrong role!", Which definitely cannot lead us to a successful attack.  But with (name == "adm" &amp;&amp; key1 == "validkey") str1 gets the result of calling the method Encoding.UTF8.GetString with the argument data, which in turn can take two values: new byte [0] with string.IsNullOrEmpty (parm) and Convert.FromBase64String (parm) with! string.IsNullOrEmpty (parm).  Throwing away uninteresting ones with t.ch.  exploitation of vulnerability values ‚Äã‚Äãand unwinding the values ‚Äã‚Äãof all variables up to their taint-sources, we obtain the following formula: <br><br><pre> <code class="cs hljs">(Request.Params[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] == <span class="hljs-string"><span class="hljs-string">"adm"</span></span> &amp;&amp; Request.Params[<span class="hljs-string"><span class="hljs-string">"key1"</span></span>] == <span class="hljs-string"><span class="hljs-string">"validkey"</span></span> &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(Request.Params[<span class="hljs-string"><span class="hljs-string">"parm"</span></span>])) -&gt; Response.Write(<span class="hljs-string"><span class="hljs-string">"&lt;a href='http://host.domain' onclick='"</span></span> + CustomSanitize(Convert.FromBase64String(Request.Params[<span class="hljs-string"><span class="hljs-string">"parm"</span></span>])) + <span class="hljs-string"><span class="hljs-string">"'&gt;Click me&lt;/a&gt;"</span></span>)</code> </pre><br>  A graphical representation of the execution model built in this case will look like (clickable): <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/aa3/d47/7ba/aa3d477ba9048e3dd72e636fe4a4ce2b.png"></a> </div><br>  Thus, we already have the values ‚Äã‚Äãof the request parameters name and key1 and all that remains to be done is to find the Request.Params [‚Äúparm‚Äù] value, at which the final value of the CustomSanitize expression (Convert.FromBase64String (Request.Params [‚Äúparm "])) Will give us exploitation of the vulnerability leading to XSS. <br><br>  And here a problem arises, which traditional means of statistical analysis cannot cope with.  The Convert.FromBase64String method is library and can be described in the analyzer knowledge base as having the inverse function Convert.ToBase64String, from which we can conclude that the result of CustomSanitize should go to the input of Convert.ToBase64String.  But what to do with CustomSanitize, which is not a library, is not described anywhere and is a black-black box at this stage of the analysis?  It is good if the source code of this method is available to us - in this case, we can ‚Äúfall through‚Äù into its body and continue the symbolic execution of the code in a manner similar to that described above.  But what to do if the source is not?  The answer was made in the previous sentence: forget for a while about that, our analysis is static and work with this method as with a black box.  We have the expression Convert.ToBase64String already output (CustomSanitize (Request.Params ["parm"])), there are many possible XSS vectors (let it be {`&lt;script&gt; alert (0) &lt;/ script&gt;`, `' onmouseover = 'a [alert]; a [0] .call (a [1], 1) `and` "onmouseover =" a [alert]; a [0] .apply (a [1], [1]) `}) - so why not declassify this formula by specifying the character variable Request.Params [" parm "] with vector values ‚Äã‚Äãand directly executing the resulting expression? <br><br>  Suppose that CustomSanitize only removes angle brackets.  Then, as a result of fuzzing, we get three values: <br><br><pre> <code class="javascript hljs">scriptalert(<span class="hljs-number"><span class="hljs-number">0</span></span>)/script <span class="hljs-string"><span class="hljs-string">'onmouseover='</span></span>a[alert];a[<span class="hljs-number"><span class="hljs-number">0</span></span>].call(a[<span class="hljs-number"><span class="hljs-number">1</span></span>],<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"onmouseover="</span></span>a[alert];a[<span class="hljs-number"><span class="hljs-number">0</span></span>].apply(a[<span class="hljs-number"><span class="hljs-number">1</span></span>],[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br>  of which the last two seem worthy of consideration as attack vectors.  So, we know the full expression passed in as the PVO argument.  We know the exact place where the value of the symbol variable Request.Params ["parm"] will fall when it is specified with the values ‚Äã‚Äãof vectors.  What else do we need to choose from these two that vector, the use of which will lead to injections?  Those who listened attentively to the webinar " <a href="http://blog.vladimir.pe/2013/07/blog-post.html">How to develop a secure web application and do not go crazy with it?</a> " Will immediately say that we don‚Äôt need anything more :) <br><br>  So  The final result of the analysis of this code is the contextual (defining the values ‚Äã‚Äãof symbolic variables in the context of the execution of PVO) exploit: <br><br><pre> <code class="cs hljs">Request.Params[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"adm"</span></span> Request.Params[<span class="hljs-string"><span class="hljs-string">"key1"</span></span>] = <span class="hljs-string"><span class="hljs-string">"validkey"</span></span> Request.Params[<span class="hljs-string"><span class="hljs-string">"parm"</span></span>] = <span class="hljs-string"><span class="hljs-string">"'onmouseover='a[alert];a[0].call(a[1],1)"</span></span></code> </pre><br>  from which it is already possible to deduce and HTTP (defining the requirements for the actual parameters of the HTTP request) exploit: <br><br><pre> <code class="cs hljs">GET http:<span class="hljs-comment"><span class="hljs-comment">//host.domain/path/to/document.aspx?name=adm&amp;key1=validkey&amp;parm=%27onmouseover%3D%27a%5Balert%5D%3Ba%5B0%5D.call%28a%5B1%5D%2C1%29 HTTP/1.1</span></span></code> </pre><br>  In AI, if you're interested, it looks like this (clickable): <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7f2/f8d/9d7/7f2f8d9d7142c0ff5deea232011eba83.png" alt=" " title="Console version"></a> </div><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/939/b11/411/939b114115fc10f90f09e370c4a3541d.png" alt="GUI " title="GUI version"></a> </div><br>  Of course, in a harsh reality, everything is slightly more complicated: even a vector modified by a filtering function can ‚Äúshoot‚Äù, which, together with the appearance of regular expressions in such functions, makes it necessary to manipulate the state machines describing them instead of constant values;  the fact that the input parameter of the query can be inserted into an arbitrary grammatical construction of the output language leads to the need for parsing and / or heuristic deduction of the properties of island languages, etc.  etc.  But these are already topics for individual (and, probably, slightly more scientific) articles.  I note only that within the framework of our task, these problems were also successfully solved. <br><br><h2>  How do you get entry points? </h2><br>  I deliberately omitted in all examples the issue of getting "/path/to/document.aspx" (i.e. the route to the entry point to the web application), since  This task does not have a universal solution and requires a description of the specifics of various frameworks in the analyzer's knowledge base.  For ASP.NET Webforms, for example, entry points are handler methods of the so-called.  postbacks of web form controls (which requires parsing .aspx files and linking them with the corresponding codebehind files).  In ASP.NET MVC, routes are defined through populating the RouteCollection collection directly in the application initialization code.  We should not forget about the possibility of appearing in WebConfig sections urlMappings, urlrewritingnet and the like, also affect the routing of HTTP requests to the application.  Yes, and the developer does not interfere with the definition of a custom HTTP handler that implements custom routing logic, the reverse of which is an algorithmically unsolvable task.  In this case, we have nothing left but to consider as public entry points all public and protected methods in the case of Java / C # or all .php files in the case of PHP, accepting the growth in the likelihood of false-positive on the outside unreachable code.  However, I personally have not yet met such .NET applications, but the existing zoo does not inspire PHP frameworks, but it is completely formalized in the analyzer's knowledge base, including the part concerning getting routes to the entry points.  Exotics such as the description of routing rules in the database, as is probably clear, we are processing the above-mentioned direct search of all potential entry points (which, by the way, doesn‚Äôt give such bad results as it may seem at first glance). <br><br><h2>  That's all </h2><br>  I hope that I still managed to answer the questions posed.  But if new ones suddenly appeared, or incomprehensible moments remained - welcome, as they say :) <br><hr><ol><li><a name="cite_note-1"></a>  <a href="https://habr.com/ru/company/pt/blog/224547/">‚Üë</a> Immediately make a reservation that the example is unconditionally synthetic and is intended to demonstrate, rather, possible problems in the way of analyzing the code of the average lousy, rather than some real example from the living system.  If someone from the readers wants to offer his own version of a code fragment, then it will be possible to consider the analysis process and on it - no question at all </li><li><a name="cite_note-2"></a>  <a href="https://habr.com/ru/company/pt/blog/224547/">‚Üë A</a> description of the step-by-step execution of the process of analyzing even such a simple code would result in a multipage chain of transformations of uniform logic formulas, therefore the calculations are not given here.  Those interested can familiarize themselves with a sufficiently detailed description of the approach and its individual stages in the recording of the report mentioned at the beginning of the article. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/224547/">https://habr.com/ru/post/224547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224531/index.html">DevConf 2014 Master Class: Promotions and Punishments. How to use non-administrative techniques?</a></li>
<li><a href="../224535/index.html">Ext JS 5: MVC, MVVM, etc</a></li>
<li><a href="../224537/index.html">Coursera experiments with on-demand model</a></li>
<li><a href="../224541/index.html">Encryption GOST 28147-89 in Acronis Backup 11.5</a></li>
<li><a href="../224545/index.html">The effectiveness of reviews of simple games for iOS</a></li>
<li><a href="../224553/index.html">Japanese view on IT Infrastructure. Fujitsu Solutions</a></li>
<li><a href="../224555/index.html">Free copy of Battlefield 3</a></li>
<li><a href="../224565/index.html">Strooder: recycling 3D printing waste at home (waste => work material)</a></li>
<li><a href="../224569/index.html">Acronis Disk Director: split disks without problems</a></li>
<li><a href="../22457/index.html">Photos from the section "New technologies and creative in online advertising"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>