<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We generate arbitrary sequences on the findings of the Raspberry Pi board.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Author: Nikolai Khabarov, Embedded Expert DataArt, Evangelist for Smart Home Technologies. 

 In this article I will tell you how to write a standard ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We generate arbitrary sequences on the findings of the Raspberry Pi board.</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/ab2/295/840/ab22958408144746a9961c0ce03bef5e.jpg"><br><br>  <i>Author: Nikolai Khabarov, Embedded Expert DataArt, Evangelist for Smart Home Technologies.</i> <br><br>  In this article I will tell you how to write a standard user space-Python application for a modern ARM processor with Linux OS to generate complex sequences of impulses on board outputs.  The idea is to use a processor DMA-module for copying from a previously prepared buffer in memory to GPIO with high accuracy in time. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When it comes to the need to generate a complex sequence of pulses, for example, for stepper motors, they usually use good old simple microcontrollers with a special real-time operating system installed or without an operating system at all.  The implementation is, at best, written in C ++.  Now the processors have made great strides and have a lot of advantages: performance, the ability to use the Linux operating system with all the infrastructure and software, as well as high-level programming languages ‚Äã‚Äãsuch as Python.  And yet, modern microcontrollers for generating complex sequences on GPIO pins, as a rule, are not used. <br><br>  I implemented the pulse generation for controlling the stepper motors <a href="https://github.com/Nikolay-Kha/PyCNC">of the PyCNC project</a> - a project of a CNC machine controller, machine tools, 3D printers, written entirely in Python and running on a modern ARM processor on the Raspberry Pi board. <br><br>  The article may be useful to those who want to implement the generation of complex level setting sequences on the outputs of one or several GPIOs in other high-level programming languages ‚Äã‚Äãusing the DMA modules of other processors. <a name="habracut"></a><br><br><h2>  GPIO </h2><br>  General Purpose Input Output (GPIO) is a processor module that is responsible for setting the logic levels on the physical outputs.  As you know, in the digital world on the output can be "0", i.e., the leg is attracted to the "ground" or "1", i.e. the leg is attracted to power. <br><br>  Surely many of you have lit the LED, control one of the legs of the microcontroller.  For example, in AVR microcontrollers, this was done by setting the corresponding bit in a variable, or, as it is often called, the PORTx register.  What is this variable?  If you look at the header files, there will be something like: <br><br><pre><code class="hljs delphi">#define PORT <span class="hljs-comment"><span class="hljs-comment">(*(volatile uint8_t *)</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x12345678))</code> </pre> <br>  In other words, the output status record is a record of this value at a previously known address.  Please note that this is not an address in RAM, moreover, not an address in the virtual memory of the process, it is an address in the address space of the processor itself.  Physical, somewhere inside the chip, this address is connected to a real GPIO module, to which we access this address through the processor core, passing a byte of information to set the output state.  And almost any processor has such modules.  ARM-processor Raspberry Pi - is no exception.  To find out exactly where each module is located in the address space, you need to look at the documentation of the processor you are interested in. <br><br>  For Raspberry Pi, this document is <a href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf">here</a> . <br><br>  It contains the GPIO registers at the bus address 0x7E200000, in other words, by writing data to the corresponding addresses, you can control the status of the pins.  Immediately, we note that all the peripherals of the Raspberry Pi 1, 2 and 3 processors are the same, only the physical addresses differ, in which the peripheral bus addresses are mapped, starting at address 0x7E000000.  For version 1 of the Raspberry Pi, this will be 0x20000000, for versions 2 and 3 - 0x3F000000.  That is, for the RPi3 processor, to access the bus address 0x7E200000, you need to write to the physical address 0x3F200000.  In the documentation for the link above, all the addresses are bus addresses. <br><br>  In most cases, Linux will be installed on the ARM processor.  The question immediately arises how to access the physical memory.  Access to it is in the core of the OS.  We want to make a normal application running in a virtual address space.  Fortunately, the Linux kernel provides access to the physical memory through the virtual device '/ dev / mem', by opening which (we need root privileges), we can write to the physical memory.  To be fair, we note that in the official Raspberry Pi OS for Raspbian, there is also a device '/ dev / gpiomem,' provided by the driver 'bcm2835_gpiomem', access to which is even without superuser rights - access to the first GPIO register is immediately zero. <br><br>  Let's practice a little bit, I think it will be easier to understand everything written above.  Let's write a simple Python application that will light the LED connected to the GPIO21 pin running on Raspberry Pi 2 and 3 (for RPi1, correct the address in the listing).  Instead of Python, you can use any other programming language that can call system functions from libc.so.  Here is the actual code: <br><br><div class="oembed"><script type="text/javascript" src="https://gist.github.com/85d8b88e8ad5178e871eb5f7cce12602.js"></script><link rel="stylesheet" href="https://github.githubassets.com/assets/gist-embed-6a0c0e7fc2e433191d469ef5051df9f8.css"><div id="gist48714899" class="gist">
    <div class="gist-file">
      <div class="gist-data">
        <div class="js-gist-file-update-container js-task-list-container file-box">
  <div id="file-1" class="file">
    

  <div itemprop="text" class="blob-wrapper data type-python ">
      
<table class="highlight tab-size js-file-line-container" data-tab-size="8">
      <tbody><tr>
        <td id="file-1-L1" class="blob-num js-line-number" data-line-number="1"></td>
        <td id="file-1-LC1" class="blob-code blob-code-inner js-file-line"><span class="pl-c"><span class="pl-c">#</span>!/usr/bin/env python</span></td>
      </tr>
      <tr>
        <td id="file-1-L2" class="blob-num js-line-number" data-line-number="2"></td>
        <td id="file-1-LC2" class="blob-code blob-code-inner js-file-line"><span class="pl-k">import</span> os</td>
      </tr>
      <tr>
        <td id="file-1-L3" class="blob-num js-line-number" data-line-number="3"></td>
        <td id="file-1-LC3" class="blob-code blob-code-inner js-file-line"><span class="pl-k">import</span> mmap</td>
      </tr>
      <tr>
        <td id="file-1-L4" class="blob-num js-line-number" data-line-number="4"></td>
        <td id="file-1-LC4" class="blob-code blob-code-inner js-file-line"><span class="pl-k">import</span> time</td>
      </tr>
      <tr>
        <td id="file-1-L5" class="blob-num js-line-number" data-line-number="5"></td>
        <td id="file-1-LC5" class="blob-code blob-code-inner js-file-line"><span class="pl-k">import</span> ctypes</td>
      </tr>
      <tr>
        <td id="file-1-L6" class="blob-num js-line-number" data-line-number="6"></td>
        <td id="file-1-LC6" class="blob-code blob-code-inner js-file-line"> </td>
      </tr>
      <tr>
        <td id="file-1-L7" class="blob-num js-line-number" data-line-number="7"></td>
        <td id="file-1-LC7" class="blob-code blob-code-inner js-file-line">fd <span class="pl-k">=</span> os.open(<span class="pl-s"><span class="pl-pds">"</span>/dev/mem<span class="pl-pds">"</span></span>, os.<span class="pl-c1">O_SYNC</span> <span class="pl-k">|</span> os.<span class="pl-c1">O_RDWR</span>)</td>
      </tr>
      <tr>
        <td id="file-1-L8" class="blob-num js-line-number" data-line-number="8"></td>
        <td id="file-1-LC8" class="blob-code blob-code-inner js-file-line">mem <span class="pl-k">=</span> mmap.mmap(fd, mmap.<span class="pl-c1">PAGESIZE</span>, <span class="pl-v">flags</span><span class="pl-k">=</span>mmap.<span class="pl-c1">MAP_SHARED</span>, <span class="pl-v">offset</span><span class="pl-k">=</span><span class="pl-c1"><span class="pl-k">0x</span>3F200000</span>)</td>
      </tr>
      <tr>
        <td id="file-1-L9" class="blob-num js-line-number" data-line-number="9"></td>
        <td id="file-1-LC9" class="blob-code blob-code-inner js-file-line">os.close(fd)</td>
      </tr>
      <tr>
        <td id="file-1-L10" class="blob-num js-line-number" data-line-number="10"></td>
        <td id="file-1-LC10" class="blob-code blob-code-inner js-file-line"> </td>
      </tr>
      <tr>
        <td id="file-1-L11" class="blob-num js-line-number" data-line-number="11"></td>
        <td id="file-1-LC11" class="blob-code blob-code-inner js-file-line">v <span class="pl-k">=</span> ctypes.c_uint32.from_buffer(mem, <span class="pl-c1"><span class="pl-k">0x</span>8</span>).value</td>
      </tr>
      <tr>
        <td id="file-1-L12" class="blob-num js-line-number" data-line-number="12"></td>
        <td id="file-1-LC12" class="blob-code blob-code-inner js-file-line">v <span class="pl-k">&amp;=</span> <span class="pl-k">~</span>(<span class="pl-c1"><span class="pl-k">0b</span>111</span> <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">3</span>)</td>
      </tr>
      <tr>
        <td id="file-1-L13" class="blob-num js-line-number" data-line-number="13"></td>
        <td id="file-1-LC13" class="blob-code blob-code-inner js-file-line">v <span class="pl-k">|=</span> <span class="pl-c1"><span class="pl-k">0b</span>001</span> <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">3</span></td>
      </tr>
      <tr>
        <td id="file-1-L14" class="blob-num js-line-number" data-line-number="14"></td>
        <td id="file-1-LC14" class="blob-code blob-code-inner js-file-line">ctypes.c_uint32.from_buffer(mem, <span class="pl-c1"><span class="pl-k">0x</span>8</span>).value <span class="pl-k">|=</span> v</td>
      </tr>
      <tr>
        <td id="file-1-L15" class="blob-num js-line-number" data-line-number="15"></td>
        <td id="file-1-LC15" class="blob-code blob-code-inner js-file-line"> </td>
      </tr>
      <tr>
        <td id="file-1-L16" class="blob-num js-line-number" data-line-number="16"></td>
        <td id="file-1-LC16" class="blob-code blob-code-inner js-file-line"><span class="pl-k">try</span>:</td>
      </tr>
      <tr>
        <td id="file-1-L17" class="blob-num js-line-number" data-line-number="17"></td>
        <td id="file-1-LC17" class="blob-code blob-code-inner js-file-line">    <span class="pl-k">while</span> <span class="pl-c1">True</span>:</td>
      </tr>
      <tr>
        <td id="file-1-L18" class="blob-num js-line-number" data-line-number="18"></td>
        <td id="file-1-LC18" class="blob-code blob-code-inner js-file-line">        ctypes.c_uint32.from_buffer(mem, <span class="pl-c1"><span class="pl-k">0x</span>1C</span>).value <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">21</span></td>
      </tr>
      <tr>
        <td id="file-1-L19" class="blob-num js-line-number" data-line-number="19"></td>
        <td id="file-1-LC19" class="blob-code blob-code-inner js-file-line">        time.sleep(<span class="pl-c1">0.5</span>)</td>
      </tr>
      <tr>
        <td id="file-1-L20" class="blob-num js-line-number" data-line-number="20"></td>
        <td id="file-1-LC20" class="blob-code blob-code-inner js-file-line">        ctypes.c_uint32.from_buffer(mem, <span class="pl-c1"><span class="pl-k">0x</span>28</span>).value <span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">21</span></td>
      </tr>
      <tr>
        <td id="file-1-L21" class="blob-num js-line-number" data-line-number="21"></td>
        <td id="file-1-LC21" class="blob-code blob-code-inner js-file-line">        time.sleep(<span class="pl-c1">0.5</span>)</td>
      </tr>
      <tr>
        <td id="file-1-L22" class="blob-num js-line-number" data-line-number="22"></td>
        <td id="file-1-LC22" class="blob-code blob-code-inner js-file-line"><span class="pl-k">except</span> <span class="pl-c1">KeyboardInterrupt</span>:</td>
      </tr>
      <tr>
        <td id="file-1-L23" class="blob-num js-line-number" data-line-number="23"></td>
        <td id="file-1-LC23" class="blob-code blob-code-inner js-file-line">    <span class="pl-k">pass</span></td>
      </tr>
      <tr>
        <td id="file-1-L24" class="blob-num js-line-number" data-line-number="24"></td>
        <td id="file-1-LC24" class="blob-code blob-code-inner js-file-line"> </td>
      </tr>
      <tr>
        <td id="file-1-L25" class="blob-num js-line-number" data-line-number="25"></td>
        <td id="file-1-LC25" class="blob-code blob-code-inner js-file-line">ctypes.c_uint32.from_buffer(mem, <span class="pl-c1"><span class="pl-k">0x</span>8</span>).value <span class="pl-k">&amp;=</span> <span class="pl-k">~</span>(<span class="pl-c1"><span class="pl-k">0b</span>111</span> <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">3</span>)</td>
      </tr>
      <tr>
        <td id="file-1-L26" class="blob-num js-line-number" data-line-number="26"></td>
        <td id="file-1-LC26" class="blob-code blob-code-inner js-file-line">mem.close()</td>
      </tr>
</tbody></table>


  </div>

  </div>
</div>

      </div>
      <div class="gist-meta">
        <a href="" style="float:right">view raw</a>
        <a href="">1</a>
        hosted with ‚ù§ by <a href="">GitHub</a>
      </div>
    </div>
</div>
</div><br>  I left the magic numbers in the code intentionally - it would be easier to explain this way.  Let's sort the code line by line. <br><br>  The top five lines are the import of the required standard Python modules. <br><br>  In the 7th line, we directly open the file '/ dev / mem' to access the memory. <br><br>  In the 8th line, we call the <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">memmap</a> system function, which will project our, albeit virtual, file into the virtual address space of the process.  That is, writing to the virtual memory of the process, we will actually write to the physical memory.  The code also indicates the indent, starting from which address to project the memory, and the length (mmap.PAGESIZE).  We specify the address of the first GPIO register and the length of one page of memory.  At first glance it may seem that it is enough just to open '/ dev / mem', retreat to the desired address and start writing the file, but, alas, this will not work. <br><br>  In the 9th line, we close the file, since we don‚Äôt have to keep the handle open, the mapping will not disappear anywhere. <br><br>  In the 11th ‚Äì 14th lines we read and write to the register with indentation 0x08.  If you look at the documentation, this is the GPFSEL2 GPIO Function Select 2 register. With these registers, we choose what function the chip leg will perform.  In this case, we set (first clear, then set using OR) 3 bits starting from the third at 001, so that the output works as an output.  The fact is that there are quite a few conclusions to expose various modes, one register is not enough, so the registers are divided into groups of 10 conclusions each - hence this magic with numbers. <br><br>  In the 16th and 22nd lines, we install a handler, waiting for Ctrl + C on the keyboard to exit the program. <br><br>  On the 17th line, we run an infinite loop. <br><br>  In the 18th line, we translate the output to a high state by writing a bit mask to the GPSET0 register. <br><br>  On the 19th and 21st lines, we realize a half second delay. <br><br>  In the 20th row, we translate the output to a low state by writing the GPCLR0 bit mask. <br><br>  On lines 25 and 26, we tidy up after ourselves: we deinitialize the pin, translating into the default state - the input - and close the memory mapping. <br><br>  A small note: the BCM2835 does not have registers similar to PORTA, like the AVR, that is, we cannot immediately record the state (high or low level) of all the pins at once.  There is only the SET register, which allows you to set logical units on all pins, where units are in the bit mask, and the CLEAR register, which allows you to set logical zeros on all pins, where ones are in the bit mask. <br><br>  By running this code with superuser privileges on Raspberry Pi 2 or 3, for example, via the command 'sudo python gpio.py', and connecting the LED to pin 21, we will see that it is flashing. <br><br>  If you need a ready implementation of GPIO pin management, you can use the GPIO class from this <a href="https://github.com/Nikolay-Kha/PyCNC/blob/master/cnc/hal_raspberry/rpgpio.py">file</a> . <br><br><h2>  Stepper motors </h2><br>  Control of stepper motors is not so simple as it may seem at first glance.  Let's take a brief insight into the essence of the problem and see why there is a need to generate such sequences at all.  We will not go into the details of the theory of the device of a stepper motor, those who wish can read about it <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D0%25B3%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B9_%25D1%258D%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2582%25D1%2580%25D0%25BE%25D0%25B4%25D0%25B2%25D0%25B8%25D0%25B3%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C">here</a> . <br><br>  Instead, we will immediately turn to reality, where a stepping motor has 4 or 5 leads from four windings.  The currents needed to rotate the motor are quite large ‚Äî not a single microcontroller or processor can provide such.  Also, to create such currents, you need a voltage that is usually higher than the voltage of the processor logic.  Therefore, with stepper motors used specialized chips - drivers, sometimes even integrated into the motor housing.  The simplest drivers (for example, ULN2003) simply provide low-current winding control inputs compatible with standard microcontroller logic voltages.  With such a driver, it is necessary to generate a sequence of pulses for each winding.  Most of the drivers, including some of the most popular A4988 and DRV8825, take all the headache to work with the motor windings.  They provide a simple interface with two low-current pins, STEP and DIR.  As you can guess from their names, when a pulse is applied to STEP, the driver moves the engine one step (the driver can also be configured for so-called microsteps, i.e. movements 1/2, 1/4, etc. of the step - this is achieved techniques for working with windings).  The DIR pin is used to select the direction of rotation of the engine, depending on whether a low or high level is applied to it. <br><br>  The typical A4988 switching scheme looks like this (I borrowed the picture on the Internet): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/954/412/560/95441256015447f6a088b9df6a54b5ff.png"></div><br>  In the simplest case, it is possible, by applying pulses to the STEP terminal, to rotate the engine with a certain frequency.  Just to play with him is enough.  But the laws of physics act on a real device, and it is impossible to instantly accelerate an engine to the required speed, simply by applying pulses with a fixed frequency, it is impossible if you do not want to break the mechanics.  It is necessary to spin the engine with a certain acceleration to the desired speed, and then slow it down to a complete stop.  Therefore, the pulse repetition frequency should change during acceleration and acceleration, and the required signal should no longer be periodic. <br><br>  This approach to the control of motors with STEP and DIR pins is the most universal, since such a connection allows realizing almost any delights on the microcontroller itself.  For example, the reader may be asked if there are drivers with I2C or UART-interface?  Theoretically, such a driver can be made, but to control the same 3D printer, you need to synchronously control several stepper motors.  Moreover, each of them may have different acceleration parameters, the number of steps per millimeter, maximum speeds.  As a result, a similar driver in its complexity would be analogous to the CNC controller (CNC). <br><br>  As you might have guessed, the GPIO control method described above cannot achieve the correct formation of impulses on pins.  It's not just that delays in executing Python code are unpredictable.  Even if you implement everything in C and in the form of a Linux kernel OC, we will not achieve a good result, since Linux is not a real-time operating system.  At any time, the processor cores can switch to performing some other task, and we will not give impetus in time.  But unless such trifles can stop us on the way to what was intended! <br><br><h2>  DMA </h2><br>  Direct Memory Access is a specialized hardware processor module that allows you to copy memory from one place to another without resorting to the services of the cores of the CPU itself.  Such modules exist even in simple microcontrollers, but the implementation varies greatly from one processor model to another.  The Raspberry Pi implementation is pretty mediocre - it has everything you need, but no frills.  And, for example, the Rockchip RK3399 DMA-module is more like a mini-processor core with its own, albeit small, set of instructions. <br><br>  I do not set myself the task of writing a complete translation of the original documentation.  And I‚Äôll tell you only about the main registers, which will allow us to launch the DMA-module in the mode of copying data into the GPIO-module. <br><br>  As you could imagine, we will generate a buffer in memory and copy it to the address of the location of the GPIO module.  But for the DMA module to work, it is necessary that this buffer be located somewhere in the physical memory.  Naturally, any virtual memory, if it does not fall into the swap, will also be in physical memory.  Using '/ proc / self / pagemap' you can get the memory mapping table of your own process into physical memory, that is, allocate a buffer and then find its physical address. <br><br>  But you shouldn‚Äôt do this with DMA - all because of the same possibility of memory getting into the swap and the fact that the operating system memory manager can transfer your allocated memory to another place.  You can write a simple nuclear module that, when loaded, calls a method from the Linux kernel kmalloc () - this method allocates and also blocks memory from possible transfers.  Then you give the application the address of the allocated memory, for example, through a virtual device.  Having this address, the application can access memory using the exact same method described in the GPIO section.  The address or buffer we allocated can be used with the DMA module. <br><br>  But you probably will not want to write a core module, even if it is extremely simple. <br><br>  Well, there is a ready-made solution - the virtual device '/ dev / vcio'.  It is created by the Raspberry Pi video card driver.  For communication VideoCore and the CPU uses the so-called mailboxes, which, in fact, pieces allocated in the memory allocated for the video card.  By default, the video card is allocated 64 MB, and if desired, this value can be changed.  The fact that we will allocate some resources from the video memory for our needs will not affect the work of the video card, the main thing is not to take too much away.  In practice, 30-35 MB of memory is enough for normal functioning of the Raspbian OS desktop, that is, about half.  So the second half is fully accessible to us if we do not plan to run applications using OpenGL.  Moreover, allocating a part of the memory for transfer to the GPU itself is a regular procedure.  And, if we allocate memory, but do not give it to the video processor, there will be no problems.  Here is an <a href="">official example</a> that uses this kind of memory allocation. <br><br>  This process is rather trivial, although it is hidden behind the magic numbers in the code.  Open / dev / vcio, then, using the ioctl () method, pass the structure with the request and get the answer.  We need to allocate memory and block it so that the memory manager will not drag away the piece we have selected.  You can see the implementation of the link above, we are interested in the methods mem_alloc (), mem_lock () and, of course, the methods that allow you to tidy up the mem_unlock (), mem_free ().  If you are confused by the implementation in C, you can rewrite these methods to any other language. <br><br>  Oh well.  We found the place where to allocate the buffer.  Now you need to somehow program the DMA so that it performs what we want.  Once again, the DMA module is just a few registers in physical memory.  It is managed in the same way - by recording the structures at the necessary addresses.  In total, the Raspberry Pi has 16 DMA channels.  The first eight are fully functional, the other eight are somewhat limited in functionality.  Each channel has its own set of registers.  The base address of the DMA bus of the module is 0x7E007000, i.e. for the Raspberry Pi 2 or 3 you need to write to the address 0x3F007000.  Here is the first register of the first DMA channel.  Each subsequent is located with a shift of 0x100 (with the exception of 15, it is located at 0x7EE05000). <br><br>  What kind of channel to use?  The choice is rather complicated, since the channels can be used by the core.  You can find out which channels are used from the kernel itself via sysfs with the command 'cat / sys / class / dma / dma0chan * / in_use'.  As a rule, you should avoid using 0, 1, 2, 3, 6, 7 channels, since they are used by a microSD card reader and a video card driver. <br><br>  The main registers for controlling the DMA module are CS and CONBLK_AD.  It is by filling them in, we run DMA.  The first register is CS, in which we are interested in the fields: <br><table><tbody><tr><th>  Bit <br>  number </th><th>  Field </th><th>  Description </th><th>  Access </th></tr><tr><td>  31 </td><td>  RESET </td><td>  The unit record resets the DMA module. </td><td>  W </td></tr><tr><td>  one </td><td>  END </td><td>  When the unit is written, the transmission end flag is reset. </td><td>  W </td></tr><tr><td>  0 </td><td>  ACTIVE </td><td>  When writing units, DMA will start working.  Using this field <br>  You can pause DMA.  After the end of the transfer field <br>  will automatically take the value 0. </td><td>  Rw </td></tr></tbody></table><br><br>  There are much more fields in the registers; an inquisitive reader can find a description of each of them in the official document by the <a href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf">link that we met above</a> on page 47. <br><br>  An address is written to the CONBLK_AD register, in which lies the so-called control block, which describes what the DMA module should do.  At the same time, control blocks are a linked list, i.e. with the help of several control blocks, one can build a chain of different tasks.  DMA-module, completing the task, automatically passes through all control blocks.  It is from the address in CONBLK_AD that the DMA module will start copying when the ACTIVE bit is set in the CS register. <br><br>  The control block must be stored in memory with alignment of 32 bytes (the 5 low bits of the address must be zero).  And now let's see how the control block is arranged: <br><table><tbody><tr><th>  Indent byte </th><th>  Field </th><th>  Description </th></tr><tr><td>  0 </td><td>  Ti </td><td>  A set of various flags that specify the parameters for copying data. </td></tr><tr><td>  four </td><td>  SOURCE_AD </td><td>  Source address from which to start copying. </td></tr><tr><td>  eight </td><td>  DEST_AD </td><td>  Destination address to copy. </td></tr><tr><td>  12 </td><td>  TXFR_LEN </td><td>  The number of bytes to copy. <br>  In a special 2D mode, the upper 16 bits set <br>  number of copy cycles, lower 16 bits - <br>  The number of bytes to copy per cycle. </td></tr><tr><td>  sixteen </td><td>  STRIDE </td><td>  Used only in 2D mode.  Low 16 bytes <br>  store a sign number that specifies how much to move <br>  source address before the next cycle. <br>  The upper 16 bytes store the sign number you need <br>  move the destination address before the next cycle. </td></tr><tr><td>  20 </td><td>  NEXTCONBK </td><td>  Pointer to the next control block. </td></tr></tbody></table><br>  Channels 0 to 7 support 2D mode (set by the TDMODE flag (bit 1) in the TI field of the control block), which allows you to organize X copies by Y bytes.  At the same time, the destination and / or source addresses can be increased / decreased by a certain amount before each copying, according to the STRIDE field in the control block. <br><br>  Each DMA channel also has a set of registers TI, SOURCE_AD, DEST_AD, TXFR_LEN, STRIDE, NEXTCONBK, which can only be read.  They are loaded from the current control unit. <br><br>  Well, let's try to do something simple with DMA and GPIO modules in Python.  So that the listing of the program is not tediously long and does not contain unnecessary magic numbers, let's take some ready-made code from this <a href="https://github.com/Nikolay-Kha/PyCNC/blob/master/cnc/hal_raspberry/rpgpio_private.py">file</a> . <br><br>  From it, we will use constants and the classes 'PhysicalMemory' (access to physical memory, as we did in the example with GPIO) and 'CMAPhysicalMemory' (this is the implementation of allocating physical memory using the video driver / dev / vcio, which we wrote above) . <br><br><div class="oembed"><script type="text/javascript" src="https://gist.github.com/1efdab133dcb27c21a250e072c85c991.js"></script><link rel="stylesheet" href="https://github.githubassets.com/assets/gist-embed-6a0c0e7fc2e433191d469ef5051df9f8.css"><div id="gist48718215" class="gist">
    <div class="gist-file">
      <div class="gist-data">
        <div class="js-gist-file-update-container js-task-list-container file-box">
  <div id="file-2" class="file">
    

  <div itemprop="text" class="blob-wrapper data type-python ">
      
<table class="highlight tab-size js-file-line-container" data-tab-size="8">
      <tbody><tr>
        <td id="file-2-L1" class="blob-num js-line-number" data-line-number="1"></td>
        <td id="file-2-LC1" class="blob-code blob-code-inner js-file-line"><span class="pl-c"><span class="pl-c">#</span>!/usr/bin/env python</span></td>
      </tr>
      <tr>
        <td id="file-2-L2" class="blob-num js-line-number" data-line-number="2"></td>
        <td id="file-2-LC2" class="blob-code blob-code-inner js-file-line"><span class="pl-k">import</span> time</td>
      </tr>
      <tr>
        <td id="file-2-L3" class="blob-num js-line-number" data-line-number="3"></td>
        <td id="file-2-LC3" class="blob-code blob-code-inner js-file-line"><span class="pl-k">from</span> rpgpio_private <span class="pl-k">import</span> <span class="pl-k">*</span></td>
      </tr>
      <tr>
        <td id="file-2-L4" class="blob-num js-line-number" data-line-number="4"></td>
        <td id="file-2-LC4" class="blob-code blob-code-inner js-file-line"> </td>
      </tr>
      <tr>
        <td id="file-2-L5" class="blob-num js-line-number" data-line-number="5"></td>
        <td id="file-2-LC5" class="blob-code blob-code-inner js-file-line"><span class="pl-c1">DMA_CHANNEL</span> <span class="pl-k">=</span> <span class="pl-c1">14</span></td>
      </tr>
      <tr>
        <td id="file-2-L6" class="blob-num js-line-number" data-line-number="6"></td>
        <td id="file-2-LC6" class="blob-code blob-code-inner js-file-line"><span class="pl-c1">PIN</span> <span class="pl-k">=</span> <span class="pl-c1">21</span></td>
      </tr>
      <tr>
        <td id="file-2-L7" class="blob-num js-line-number" data-line-number="7"></td>
        <td id="file-2-LC7" class="blob-code blob-code-inner js-file-line"> </td>
      </tr>
      <tr>
        <td id="file-2-L8" class="blob-num js-line-number" data-line-number="8"></td>
        <td id="file-2-LC8" class="blob-code blob-code-inner js-file-line">gpio <span class="pl-k">=</span> PhysicalMemory(<span class="pl-c1">PERI_BASE</span> <span class="pl-k">+</span> <span class="pl-c1">GPIO_REGISTER_BASE</span>)</td>
      </tr>
      <tr>
        <td id="file-2-L9" class="blob-num js-line-number" data-line-number="9"></td>
        <td id="file-2-LC9" class="blob-code blob-code-inner js-file-line">gpio_fsel_offset <span class="pl-k">=</span> <span class="pl-c1">4</span> <span class="pl-k">*</span> <span class="pl-c1">int</span>(<span class="pl-c1">PIN</span> <span class="pl-k">/</span> <span class="pl-c1">10</span>) <span class="pl-k">+</span> <span class="pl-c1">GPIO_FSEL_OFFSET</span></td>
      </tr>
      <tr>
        <td id="file-2-L10" class="blob-num js-line-number" data-line-number="10"></td>
        <td id="file-2-LC10" class="blob-code blob-code-inner js-file-line">v <span class="pl-k">=</span> gpio.read_int(gpio_fsel_offset)</td>
      </tr>
      <tr>
        <td id="file-2-L11" class="blob-num js-line-number" data-line-number="11"></td>
        <td id="file-2-LC11" class="blob-code blob-code-inner js-file-line">v <span class="pl-k">&amp;=</span> <span class="pl-k">~</span>(<span class="pl-c1">7</span> <span class="pl-k">&lt;&lt;</span> ((<span class="pl-c1">PIN</span> <span class="pl-k">%</span> <span class="pl-c1">10</span>) <span class="pl-k">*</span> <span class="pl-c1">3</span>))</td>
      </tr>
      <tr>
        <td id="file-2-L12" class="blob-num js-line-number" data-line-number="12"></td>
        <td id="file-2-LC12" class="blob-code blob-code-inner js-file-line">v <span class="pl-k">|=</span> (<span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span> ((<span class="pl-c1">PIN</span> <span class="pl-k">%</span> <span class="pl-c1">10</span>) <span class="pl-k">*</span> <span class="pl-c1">3</span>))</td>
      </tr>
      <tr>
        <td id="file-2-L13" class="blob-num js-line-number" data-line-number="13"></td>
        <td id="file-2-LC13" class="blob-code blob-code-inner js-file-line">gpio.write_int(gpio_fsel_offset, v)</td>
      </tr>
      <tr>
        <td id="file-2-L14" class="blob-num js-line-number" data-line-number="14"></td>
        <td id="file-2-LC14" class="blob-code blob-code-inner js-file-line">gpio.write_int(<span class="pl-c1">GPIO_SET_OFFSET</span>, <span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">PIN</span>)</td>
      </tr>
      <tr>
        <td id="file-2-L15" class="blob-num js-line-number" data-line-number="15"></td>
        <td id="file-2-LC15" class="blob-code blob-code-inner js-file-line">time.sleep(<span class="pl-c1">1</span>)</td>
      </tr>
      <tr>
        <td id="file-2-L16" class="blob-num js-line-number" data-line-number="16"></td>
        <td id="file-2-LC16" class="blob-code blob-code-inner js-file-line"> </td>
      </tr>
      <tr>
        <td id="file-2-L17" class="blob-num js-line-number" data-line-number="17"></td>
        <td id="file-2-LC17" class="blob-code blob-code-inner js-file-line">physmem <span class="pl-k">=</span> CMAPhysicalMemory(<span class="pl-c1">64</span>)</td>
      </tr>
      <tr>
        <td id="file-2-L18" class="blob-num js-line-number" data-line-number="18"></td>
        <td id="file-2-LC18" class="blob-code blob-code-inner js-file-line">cb1 <span class="pl-k">=</span> (</td>
      </tr>
      <tr>
        <td id="file-2-L19" class="blob-num js-line-number" data-line-number="19"></td>
        <td id="file-2-LC19" class="blob-code blob-code-inner js-file-line">       <span class="pl-c1">DMA_TI_NO_WIDE_BURSTS</span> <span class="pl-k">|</span> <span class="pl-c1">DMA_TI_WAIT_RESP</span>,    <span class="pl-c"><span class="pl-c">#</span> info</span></td>
      </tr>
      <tr>
        <td id="file-2-L20" class="blob-num js-line-number" data-line-number="20"></td>
        <td id="file-2-LC20" class="blob-code blob-code-inner js-file-line">       physmem.get_bus_address() <span class="pl-k">+</span> <span class="pl-c1">24</span>,              <span class="pl-c"><span class="pl-c">#</span> source</span></td>
      </tr>
      <tr>
        <td id="file-2-L21" class="blob-num js-line-number" data-line-number="21"></td>
        <td id="file-2-LC21" class="blob-code blob-code-inner js-file-line">       <span class="pl-c1">PHYSICAL_GPIO_BUS</span> <span class="pl-k">+</span> <span class="pl-c1">GPIO_SET_OFFSET</span>,         <span class="pl-c"><span class="pl-c">#</span> destination</span></td>
      </tr>
      <tr>
        <td id="file-2-L22" class="blob-num js-line-number" data-line-number="22"></td>
        <td id="file-2-LC22" class="blob-code blob-code-inner js-file-line">       <span class="pl-c1">4</span>,                                           <span class="pl-c"><span class="pl-c">#</span> length</span></td>
      </tr>
      <tr>
        <td id="file-2-L23" class="blob-num js-line-number" data-line-number="23"></td>
        <td id="file-2-LC23" class="blob-code blob-code-inner js-file-line">       <span class="pl-c1">0</span>,                                           <span class="pl-c"><span class="pl-c">#</span> stride</span></td>
      </tr>
      <tr>
        <td id="file-2-L24" class="blob-num js-line-number" data-line-number="24"></td>
        <td id="file-2-LC24" class="blob-code blob-code-inner js-file-line">       physmem.get_bus_address() <span class="pl-k">+</span> <span class="pl-c1">32</span>,              <span class="pl-c"><span class="pl-c">#</span> next control block</span></td>
      </tr>
      <tr>
        <td id="file-2-L25" class="blob-num js-line-number" data-line-number="25"></td>
        <td id="file-2-LC25" class="blob-code blob-code-inner js-file-line">       <span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">PIN</span>,                                    <span class="pl-c"><span class="pl-c">#</span> padding, use as source</span></td>
      </tr>
      <tr>
        <td id="file-2-L26" class="blob-num js-line-number" data-line-number="26"></td>
        <td id="file-2-LC26" class="blob-code blob-code-inner js-file-line">       <span class="pl-c1">0</span>                                            <span class="pl-c"><span class="pl-c">#</span> padding</span></td>
      </tr>
      <tr>
        <td id="file-2-L27" class="blob-num js-line-number" data-line-number="27"></td>
        <td id="file-2-LC27" class="blob-code blob-code-inner js-file-line">      )</td>
      </tr>
      <tr>
        <td id="file-2-L28" class="blob-num js-line-number" data-line-number="28"></td>
        <td id="file-2-LC28" class="blob-code blob-code-inner js-file-line">cb2 <span class="pl-k">=</span> (</td>
      </tr>
      <tr>
        <td id="file-2-L29" class="blob-num js-line-number" data-line-number="29"></td>
        <td id="file-2-LC29" class="blob-code blob-code-inner js-file-line">       <span class="pl-c1">DMA_TI_NO_WIDE_BURSTS</span> <span class="pl-k">|</span> <span class="pl-c1">DMA_TI_WAIT_RESP</span>,    <span class="pl-c"><span class="pl-c">#</span> info</span></td>
      </tr>
      <tr>
        <td id="file-2-L30" class="blob-num js-line-number" data-line-number="30"></td>
        <td id="file-2-LC30" class="blob-code blob-code-inner js-file-line">       physmem.get_bus_address() <span class="pl-k">+</span> <span class="pl-c1">32</span> <span class="pl-k">+</span> <span class="pl-c1">24</span>,         <span class="pl-c"><span class="pl-c">#</span> source</span></td>
      </tr>
      <tr>
        <td id="file-2-L31" class="blob-num js-line-number" data-line-number="31"></td>
        <td id="file-2-LC31" class="blob-code blob-code-inner js-file-line">       <span class="pl-c1">PHYSICAL_GPIO_BUS</span> <span class="pl-k">+</span> <span class="pl-c1">GPIO_CLEAR_OFFSET</span>,       <span class="pl-c"><span class="pl-c">#</span> destination</span></td>
      </tr>
      <tr>
        <td id="file-2-L32" class="blob-num js-line-number" data-line-number="32"></td>
        <td id="file-2-LC32" class="blob-code blob-code-inner js-file-line">       <span class="pl-c1">4</span>,                                           <span class="pl-c"><span class="pl-c">#</span> length</span></td>
      </tr>
      <tr>
        <td id="file-2-L33" class="blob-num js-line-number" data-line-number="33"></td>
        <td id="file-2-LC33" class="blob-code blob-code-inner js-file-line">       <span class="pl-c1">0</span>,                                           <span class="pl-c"><span class="pl-c">#</span> stride</span></td>
      </tr>
      <tr>
        <td id="file-2-L34" class="blob-num js-line-number" data-line-number="34"></td>
        <td id="file-2-LC34" class="blob-code blob-code-inner js-file-line">       physmem.get_bus_address(),                   <span class="pl-c"><span class="pl-c">#</span> next control block</span></td>
      </tr>
      <tr>
        <td id="file-2-L35" class="blob-num js-line-number" data-line-number="35"></td>
        <td id="file-2-LC35" class="blob-code blob-code-inner js-file-line">       <span class="pl-c1">1</span> <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">PIN</span>,                                    <span class="pl-c"><span class="pl-c">#</span> padding, use as source</span></td>
      </tr>
      <tr>
        <td id="file-2-L36" class="blob-num js-line-number" data-line-number="36"></td>
        <td id="file-2-LC36" class="blob-code blob-code-inner js-file-line">       <span class="pl-c1">0</span>                                            <span class="pl-c"><span class="pl-c">#</span> padding</span></td>
      </tr>
      <tr>
        <td id="file-2-L37" class="blob-num js-line-number" data-line-number="37"></td>
        <td id="file-2-LC37" class="blob-code blob-code-inner js-file-line">      )</td>
      </tr>
      <tr>
        <td id="file-2-L38" class="blob-num js-line-number" data-line-number="38"></td>
        <td id="file-2-LC38" class="blob-code blob-code-inner js-file-line">physmem.write(<span class="pl-c1">0</span>, <span class="pl-s"><span class="pl-pds">"</span>8I<span class="pl-pds">"</span></span>, cb1)</td>
      </tr>
      <tr>
        <td id="file-2-L39" class="blob-num js-line-number" data-line-number="39"></td>
        <td id="file-2-LC39" class="blob-code blob-code-inner js-file-line">physmem.write(<span class="pl-c1">32</span>, <span class="pl-s"><span class="pl-pds">"</span>8I<span class="pl-pds">"</span></span>, cb2)</td>
      </tr>
      <tr>
        <td id="file-2-L40" class="blob-num js-line-number" data-line-number="40"></td>
        <td id="file-2-LC40" class="blob-code blob-code-inner js-file-line"> </td>
      </tr>
      <tr>
        <td id="file-2-L41" class="blob-num js-line-number" data-line-number="41"></td>
        <td id="file-2-LC41" class="blob-code blob-code-inner js-file-line">dma <span class="pl-k">=</span> PhysicalMemory(<span class="pl-c1">PERI_BASE</span> <span class="pl-k">+</span> <span class="pl-c1">DMA_BASE</span> <span class="pl-k">+</span> <span class="pl-c1">DMA_CHANNEL</span> <span class="pl-k">*</span> <span class="pl-c1"><span class="pl-k">0x</span>100</span>)</td>
      </tr>
      <tr>
        <td id="file-2-L42" class="blob-num js-line-number" data-line-number="42"></td>
        <td id="file-2-LC42" class="blob-code blob-code-inner js-file-line">dma.write_int(<span class="pl-c1">DMA_CS</span>, <span class="pl-c1">DMA_CS_RESET</span>)</td>
      </tr>
      <tr>
        <td id="file-2-L43" class="blob-num js-line-number" data-line-number="43"></td>
        <td id="file-2-LC43" class="blob-code blob-code-inner js-file-line">dma.write_int(<span class="pl-c1">DMA_CS</span>, <span class="pl-c1">DMA_CS_END</span>)</td>
      </tr>
      <tr>
        <td id="file-2-L44" class="blob-num js-line-number" data-line-number="44"></td>
        <td id="file-2-LC44" class="blob-code blob-code-inner js-file-line">dma.write_int(<span class="pl-c1">DMA_CONBLK_AD</span>, physmem.get_bus_address())</td>
      </tr>
      <tr>
        <td id="file-2-L45" class="blob-num js-line-number" data-line-number="45"></td>
        <td id="file-2-LC45" class="blob-code blob-code-inner js-file-line">dma.write_int(<span class="pl-c1">DMA_CS</span>, <span class="pl-c1">DMA_CS_ACTIVE</span>)</td>
      </tr>
      <tr>
        <td id="file-2-L46" class="blob-num js-line-number" data-line-number="46"></td>
        <td id="file-2-LC46" class="blob-code blob-code-inner js-file-line"> </td>
      </tr>
      <tr>
        <td id="file-2-L47" class="blob-num js-line-number" data-line-number="47"></td>
        <td id="file-2-LC47" class="blob-code blob-code-inner js-file-line"><span class="pl-v">raw_input</span>(<span class="pl-s"><span class="pl-pds">"</span>Press Enter to stop<span class="pl-pds">"</span></span>)</td>
      </tr>
      <tr>
        <td id="file-2-L48" class="blob-num js-line-number" data-line-number="48"></td>
        <td id="file-2-LC48" class="blob-code blob-code-inner js-file-line"> </td>
      </tr>
      <tr>
        <td id="file-2-L49" class="blob-num js-line-number" data-line-number="49"></td>
        <td id="file-2-LC49" class="blob-code blob-code-inner js-file-line">dma.write_int(<span class="pl-c1">DMA_CS</span>, <span class="pl-c1">DMA_CS_RESET</span>)</td>
      </tr>
      <tr>
        <td id="file-2-L50" class="blob-num js-line-number" data-line-number="50"></td>
        <td id="file-2-LC50" class="blob-code blob-code-inner js-file-line">v <span class="pl-k">=</span> gpio.read_int(gpio_fsel_offset)</td>
      </tr>
      <tr>
        <td id="file-2-L51" class="blob-num js-line-number" data-line-number="51"></td>
        <td id="file-2-LC51" class="blob-code blob-code-inner js-file-line">v <span class="pl-k">&amp;=</span> <span class="pl-k">~</span>(<span class="pl-c1">7</span> <span class="pl-k">&lt;&lt;</span> ((<span class="pl-c1">PIN</span> <span class="pl-k">%</span> <span class="pl-c1">10</span>) <span class="pl-k">*</span> <span class="pl-c1">3</span>))</td>
      </tr>
      <tr>
        <td id="file-2-L52" class="blob-num js-line-number" data-line-number="52"></td>
        <td id="file-2-LC52" class="blob-code blob-code-inner js-file-line">gpio.write_int(gpio_fsel_offset, v)</td>
      </tr>
</tbody></table>


  </div>

  </div>
</div>

      </div>
      <div class="gist-meta">
        <a href="" style="float:right">view raw</a>
        <a href="">2</a>
        hosted with ‚ù§ by <a href="">GitHub</a>
      </div>
    </div>
</div>
</div><br>  When you start this program (do not forget to run with superuser rights), the LED connected to the 21st pin lights up for half a second at full brightness (so that the difference is noticeable), and then it will glow at half brightness until you press the enter key .  Let's break down line by line. <br><br>  2‚Äì3 lines - import of modules. <br><br>  5th and 6th - variables indicating which DMA channel and GPIO output we use. <br><br>  8‚Äì15th ‚Äî we initialize the specified GPIO output as an output and light it for half a second (so that the difference is noticeable when the DMA is turned on).  In essence, this is the same thing that we did in the first program, but written at a slightly higher level. <br><br>  17th line - we ask the video driver to allocate us 64 bytes in memory.  In the CMAPhysicalMemory class, memory is allocated with alignment equal to the page size, that is, 4096 bytes, therefore when using this memory, the beginning of the allocated memory will also always be aligned with the 32 bytes that are required by the DMA module. <br><br>  18th line - we fill the first structure of the control block.  On this dwell a little more. <br><br>  19th line - the first 4 bytes - TI flags (Transfer Information).   DMA_TI_NO_WIDE_BURSTS ‚Äî  burst- ‚Äî     ‚Äî   ,    ,   . <br> DMA_TI_WAIT_RESP ‚Äî DMA-           . <br><br>      DMA_TI_SRC_INC  DMA_TI_DST_INC ‚Äî  , DMA-          4 .   ,   DMA-,         / .      . <br><br> 20-  ‚Äî      ,   .  ,  ,    ()      (  get_bus_address()).      ,    ,      ,    .    . <br><br> 21-  ‚Äî      GPIO-   SET, . .        ,       . <br><br> 22- ‚Äî    ‚Äî 4 . <br><br> 23-  ‚Äî stride,    ,   0. <br><br> 24-  ‚Äî  next control block,    32 . <br><br> 25-  ‚Äî ,    ,  21-      4   ,     ,   ‚Äî  ,      GPIO. <br><br> 26  ‚Äî . <br><br> 28‚Äì37-  ‚Äî  ,   .       CLEAR  GPIO,      .         ,   . <br><br> 38‚Äì39-  ‚Äî       . <br><br> 41-  ‚Äî      DMA-   . <br><br> 42-43-  ‚Äî  DMA-. <br><br> 44-  ‚Äî     . <br><br> 45-  ‚Äî  DMA-. <br><br> 47-  ‚Äî    Enter. <br><br> 49‚Äì52-  ‚Äî   .  DMA-        (). <br><br>     ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/f9e/46f/b6f/f9e46fb6f9ad4d84a35dcfc7781256d0.jpg"></div><br>      Raspberry Pi 2.  ,   1.5  ‚Äî   (      ~2 )   ,     ,       . <br><br><h2>  DMA </h2><br>  ,  ,  ‚Äî      DMA-      GPIO-.  DMA ‚Äî  ,       ,    ‚Ä¶  ,    . <br><br>   DMA       1 .  ,      STEP, ,  ,    2 .   ,            2 , . . 500 000   .      4 ,    .   :     1  (    200    200 / ‚Äî   ),   114 .         ‚Äî    228 .  ,   ? ,  ,         .    114    . <br><br>        DMA- ‚Äî       . DMA-        ‚Äî    .    , ,   ,   , ,   ,   16   4     .     , . . -       ,            .   ,    ,        . <br><br>     GPIO  DMA     ,      - . ,          3D-.      .      ? <br><br>       . <br><br>            : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/78d/963/ed5/78d963ed56294858adbb70c148a7ac13.png"></div><br>   ,       GPIO,          DMA (  ). ¬´ 1¬ª    , ¬´ 2¬ª ‚Äî   .          .         200    200 /.          ¬´ 2¬ª,       .       ,    , . .   ,     .     CNC- . <br><br>     (200   400    ‚Äî 80 000 )     128  (    32 ),     DMA  ~9.8 .  . ,        ,       .    3D-  , . .     39.2 ,  ,           (     -    ),   . <br><br>       ,     ?     ,     ,       , . .     GPIO  .      DMA- ‚Äî     .     PWM (, ,      ,         ).   PWM     ,      ,  DMA   FIFO-  PMW.    PWM-          .   ,      PWM    ,      FIFO. <br><br>   DMA-    PWM-,    PERMAP   TI  ,  ,   5,   PWM-       . <br><br>                 ,        <a href="https://github.com/Nikolay-Kha/PyCNC/blob/master/cnc/hal_raspberry/rpgpio.py"></a> ,  DMAGPIO.         rpgpio,    ,          (  1, 2, 3, 4  5 ).   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/fd1/864/a1b/fd1864a1b4974f3692ced2b80c9acce2.png"></div><br>   ,  , ,  . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> rpgpio PIN=<span class="hljs-number"><span class="hljs-number">21</span></span> PINMASK = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; PIN PULSE_LENGTH_US = <span class="hljs-number"><span class="hljs-number">1000</span></span> PULSE_DELAY_US = <span class="hljs-number"><span class="hljs-number">1000</span></span> DELAY_US = <span class="hljs-number"><span class="hljs-number">2000</span></span> g = rpgpio.GPIO() g.init(PIN, rpgpio.GPIO.MODE_OUTPUT) dma = rpgpio.DMAGPIO() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, i): dma.add_pulse(PINMASK, PULSE_LENGTH_US) dma.add_delay(PULSE_DELAY_US) dma.add_delay(DELAY_US) dma.run(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) raw_input(<span class="hljs-string"><span class="hljs-string">"Press Enter to stop"</span></span>) dma.stop() g.init(PIN, rpgpio.GPIO.MODE_INPUT_NOPULL)</code> </pre> <br><h3>        DMA- </h3><br>   DMA-,      ,  FM-   Raspberry Pi ‚Äî <a href="http://www.icrobotics.co.uk/wiki/index.php/Turning_the_Raspberry_Pi_Into_an_FM_Transmitter"> </a> . <br><br>    DMA-,        250 . ,  DMA-             .    .    PWM (    PWM   ,       PWM-   ),         . ,  ,                . ,  DMA-,       PWM-,   ,      . <br><br><h2> PRU </h2><br>   BeagleBone     <a href="http://beagleboard.org/pru">PRU</a> (programmable real-time unit),    200  32-     ,      AM3358.           .               .           ‚Äî      . <br><br><h2>  Conclusion </h2><br>  DMA-      ,         ,    . <br><br>  ,      ,      .                ,         .     Raspberry Pi Zero,  ,          . <br><br>   ‚Äî  , ,       : <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pzpMoJy_YNQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/330536/">https://habr.com/ru/post/330536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330522/index.html">New products and services at Citrix Synergy</a></li>
<li><a href="../330524/index.html">How Yandex.Taxi technologies bring the future of personal and public transport closer</a></li>
<li><a href="../330526/index.html">FabricPool - saving technology for All Flash repositories</a></li>
<li><a href="../330530/index.html">Fast data recovery. How will LRC help us?</a></li>
<li><a href="../330532/index.html">iOS 11: what will be the video in the App Store and how to use it</a></li>
<li><a href="../330538/index.html">Innovation Summit: ‚ÄúInnovation at every level‚Äù</a></li>
<li><a href="../330544/index.html">PostgreSQL indexes - 4</a></li>
<li><a href="../330546/index.html">VDS for all the gift and let no one go offended</a></li>
<li><a href="../330550/index.html">What is Zimbra</a></li>
<li><a href="../330552/index.html">What the! do you still want the law? I have them! We block VPN</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>