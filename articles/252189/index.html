<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Taming dinosaurs, or as I wrote my own host controller for a 3D printing lab</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I want to talk about my experience in developing free software for managing 3D printers on Qt5, problems and features of communication...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Taming dinosaurs, or as I wrote my own host controller for a 3D printing lab</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d90/e4d/ee5/d90e4dee5a374495ab802dbeab99ac67.png"><br><br>  In this article I want to talk about my experience in developing free software for managing 3D printers on Qt5, problems and features of communication with RepRap and other joys. <br><br>  The result of this experience was RepRaptor - a minimalistic free host-controller for 3D printers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/afc/ac0/582/afcac058283a4e0ab5ed108fe2095580.png"><br><br>  I invite everyone interested under the cat. <br><a name="habracut"></a><br><h2>  A bit of background </h2><br>  Over the past year I have become very interested in 3D printing, and not just 3D printing, but its free component - the <a href="http://reprap.org/">RepRap</a> project.  The administration of the university supported the undertakings, and during this year, by my efforts and like-minded people, the laboratory of 3D printing was opened in MSTU MIREA. <br>  Very soon a problem arose - the software existing in the ecosystem had shortcomings that strongly interfered with the work.  Therefore, it was decided to eliminate these problems by creating your own software. <br><br>  In order not to hurt the authors of the existing software inadvertently, I will not poke a finger, especially the problems in a number of free 3D printing software are common: <br><ul><li>  They are all written in interpreted languages, sometimes opening and parsing files on a weak gland sometimes takes up to 10 minutes; </li><li>  Those of them that are written in <a href="http://www.mono-project.com/">Mono</a> also periodically fall, and doom a bunch of plastic to an untimely demise (The fault here, most likely, is not Mono itself, but minimal attention to the assemblies on it from the authors); </li><li>  There are few codes in the interface, but there is a very redundant functionality (I apologize for my minimalism); </li></ul><br><h2>  Why Qt? </h2><br><img height="300" src="https://habrastorage.org/files/198/d2d/07e/198d2d07ecd94691a1a656df4a661981.png"><br><br>  How to fix it all?  It's pretty simple to write a host in a language that will work faster and make it as simple as possible.  No sooner said than done.  Qt was chosen for development, and not by chance.  This wonderful framework not only spreads freely, but also allows you to write cross-platform applications without the accompanying multiplatform in C ++ pain, as well as the <a href="http://doc.qt.io/qt-5/qserialport.html">QSerialPort that</a> I periodically use not so long ago became the official part of the framework. <br><br>  In addition, I do not know a single IDE, which is as fast and convenient for me as QtCreator. <br><br>  Since all the windows, and indeed Ui itself, were generally made using .ui files in the Qt WSIWYG editor, I will omit everything connected directly to the interface.  We will look "under the hood." <br><br><h2>  Where to start, or how printers talk </h2><br>  It is necessary to communicate with a whole zoo of various boards (Melzi, RAMPS 1.4, Teensylu, Gen7 1.5.1, etc.), since the community of the RepRap project has long been determined with the protocol and the list of commands.  To communicate with any board using the serial port and the <a href="http://reprap.org/wiki/Gcode">G-code</a> protocol. <br><br>  In our laboratory of 3D printing, we use the <a href="http://www.repetier.com/">Repetier</a> firmware, which, along with the Marlin and Teacup firmware, supports most of the standard codes. <br><br><h3>  First disappointment - protocol </h3><br>  The specification of serial ports RS-232 is extensive and interesting, but, unfortunately, it is rarely used where it is fully used.  When emulating a serial port via USB, very often only the TX and RX lines responsible for data transfer are connected to the microcontroller.  Lines, such as DTR (connection reset), are not commonly used, and this is sad. <br><br>  Instead of hardware control over data transfer, RepRap-compatible printers use a very simple protocol, organized on the PingPong principle: <br><ol><li>  The printer reports a simple <b>wait</b> line; </li><li>  The host sends a G-Code command ending in a line break; </li><li>  The printer confirms receipt of the command with the line <b>Ok &lt;line number&gt;</b> . </li></ol><br><br>  It looks like this: <br><blockquote>  wait <br>  G1 X10 Y10 Z10 <br>  ok 0 <br>  G1 X20 Y5 Z3 <br>  ok 0 </blockquote><br>  Notice the 0 after ‚Äúok‚Äù?  This is the line number.  If desired, you can use the checksum and line number when <br>  sending commands to the printer: <br><blockquote>  N1 G1 X10 Y10 Z10 * cs <br>  ok 1 <br>  N2 G1 X20 Y5 Z3 * cs <br>  ok 2 </blockquote><br>  Where cs is the calculated check for the string. <br><br>  Typically, code generators that convert 3D models to G-Code for printing checksums do not generate, but leave it at the discretion of the host. <br><br>  The printer has a buffer, the size of which in most cases is 16 commands. <br><br><h3>  Protocol implementation </h3><br>  Qt has a great feature for making life easier for the developer ‚Äî signals and slots. <br>  Signal is a new concept for C ++.  A signal is declared in a class like a slot: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Example(); signals: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleSignal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; }</code> </pre> <br>  The signal can not return anything, so it is always of type void, and instead of the argument, the type of the variable transmitted by the signal is indicated.  It is not required to initialize it. <br><br>  The signal is called from any method of the parent class, and it is very simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleSignal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre><br>  After such a call, all slots attached to this signal will be called as soon as possible in the order of attachment, and the value 100 is transmitted to them. <br>  What is a slot?  In short, this is the most common method declared by the slot. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example2</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Example(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleSlot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; }</code> </pre><br>  Connecting the signal to the slot is also very simple: <br><br><pre> <code class="cpp hljs">Example e1; Example2 e2; connect(&amp;e1, SIGNAL(exampleSignal(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)), &amp;e2, SLOT(exampleSlot(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)));</code> </pre><br>  There is a limitation - the signal and the slot must have the same transmitted type. <br><br>  Given the signals and slots, it is very easy to write an asynchronous receiver / transmitter for communication over a serial port. <br><br>  The easiest part is reading. <br><br>  To implement serial port communication, use the above-mentioned QSerialPort (an instance of which we call ‚Äúprinter‚Äù), which has a readyRead () signal, which is called every time information arrives at the port.  All that is required of us is to create a slot in its class, which we will call when this signal appears, connect them, and wait.  What are we going to read?  As already described above, we are primarily interested in the answers <b>ok</b> and <b>wait</b> .  Since our code is executed asynchronously, and the printer has a buffer, we need to save somewhere the number of lines we have taken, so that when we send it, we need to know how much we can send.  Store them in the variable "readyRecieve". <br><br>  Slot: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MainWindow::readSerial() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(printer.canReadLine()) <span class="hljs-comment"><span class="hljs-comment">//   ,      { QByteArray data = printer.readLine(); //   if(data.startsWith("ok")) readyRecieve++; //     else if(data.startsWith("wait")) readyRecieve = 1; //   ,     -   1  printMsg(QString(data)); // ,      } }</span></span></code> </pre><br>  Excellent, with the reception figured out.  And what about shipping?  Here we see a protocol defect.  We have no hardware command to indicate readiness to receive data, which means that we do not have a corresponding signal from our QSerialPort.  So we will send by timer.  The timer in Qt works to disgrace is simple and convenient - we create an instance of the QTimer class, connect its timeout () signal with our slot, which will be executed by this timer, and then launch it - timer.start (ms).  Subsequently, it was found that, depending on the performance of the PC, the optimal interval is from 1 to 5 ms.  By the way, if you specify the timer interval 0, then it will be executed as soon as Qt has a free minute. <br><br>  It is also worth mentioning that we are sending either a command from the user or a file.  Since parsing a file comes down to an ordinary file loading into an array, as well as filtering lines entirely from comments (so as not to send too much to the printer and not cluttering up memory), I decided to omit this part.  An array of lines from a file is called gcode. <br><br>  Implementing send: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MainWindow::sendNext() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(injectingCommand &amp;&amp; printer.isWritable() &amp;&amp; readyRecieve &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//     { sendLine(userCommand); //   (userCommand   injectingCommand      ) readyRecieve--; //  ,     injectingCommand=false; //  ,      return; //   } else if(sending &amp;&amp; !paused &amp;&amp; readyRecieve &gt; 0 &amp;&amp; !sdprinting &amp;&amp; printer.isWritable()) //,      { if(currentLine &gt;= gcode.size()) //    { sending = false; //    -       currentLine = 0; //      ui-&gt;sendBtn-&gt;setText("Send"); //  ui-&gt;pauseBtn-&gt;setDisabled("true"); //  ui-&gt;filelines-&gt;setText(QString::number(gcode.size()) //  + QString("/") + QString::number(currentLine) + QString(" Lines")); return; //   } sendLine(gcode.at(currentLine)); //    -    currentLine++; //      readyRecieve--; //   ui-&gt;filelines-&gt;setText(QString::number(gcode.size()) //     + QString("/") + QString::number(currentLine) + QString(" Lines")); ui-&gt;progressBar-&gt;setValue(((float)currentLine/gcode.size()) * 100); //  } }</span></span></code> </pre><br>  Well, have you figured out the serial port?  Not yet.  We also need to catch errors.  To do this, we again resort to signals and slots, this time we will listen to the error signal (SerialPort :: SerialPortError error) from our QSerialPort instance: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MainWindow::serialError(QSerialPort::SerialPortError error) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error == QSerialPort::NoError) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  -   if(printer.isOpen()) printer.close(); //      -     ,     if(sending) paused = true; // -    -     ui-&gt;connectBtn-&gt;setText("Connect"); //  ui-&gt;sendBtn-&gt;setDisabled(true); //  ui-&gt;pauseBtn-&gt;setDisabled(true); //  ui-&gt;controlBox-&gt;setDisabled(true); //  ui-&gt;consoleGroup-&gt;setDisabled(true); //  qDebug() &lt;&lt; error; //       QString errorMsg; //      switch(error) { case QSerialPort::DeviceNotFoundError: errorMsg = "Device not found"; break; case QSerialPort::PermissionError: errorMsg = "Insufficient permissions\nAlready opened?"; break; case QSerialPort::OpenError: errorMsg = "Cant open port\nAlready opened?"; break; case QSerialPort::TimeoutError: errorMsg = "Serial connection timed out"; break; case QSerialPort::WriteError: case QSerialPort::ReadError: errorMsg = "I/O Error"; break; case QSerialPort::ResourceError: errorMsg = "Disconnected"; break; default: errorMsg = "Unknown error\nSomething went wrong"; break; } ErrorWindow errorwindow(this, errorMsg); //     errorwindow.exec(); }</span></span></code> </pre><br><br><img src="//habrastorage.org/files/32d/99d/080/32d99d080c0a4975bc75f911a15a733b.png"><br><br>  Inaccurate handling of the printer upsets the dinosaur,% username%. <br><br><h2>  Making our host smarter </h2><br><h3>  We take out the command buttons </h3><br>  We learned how to send a file to the serial port and properly keep the protocol, but for a full-fledged host this is not enough.  In addition to the ability to send a file line by line, you must also give the user the ability to send commands himself.  As hammered by hand, and displayed on the buttons in the interface. <br>  What teams should withdraw?  Opinions of the authors of different, already existing programs diverge, but I tried to bring out the maximum: <br><br><img src="//habrastorage.org/files/219/a38/be4/219a38be46f04c3491625a439be72412.png"><br><br>  There are no icons yet, but they will definitely appear in future releases.  The implementation of most of these buttons is quite simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MainWindow::homeall() { injectCommand(<span class="hljs-string"><span class="hljs-string">"G28"</span></span>); }</code> </pre><br><br>  The injectCommand method, which we have already learned how to work earlier, is also quite simple in the implementation of the code sender: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MainWindow::injectCommand(QString command) { injectingCommand = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    userCommand = command; //  }</span></span></code> </pre><br><h3>  Get additional data </h3><br>  RepRap is a harsh DIY.  So severe that anything happens: <br><br><img height="600" src="//habrastorage.org/files/c01/86f/b41/c0186fb416824a0ebbecddcb6a5dad6f.jpg"><br><br>  It is not always during setup that you can be sure that the printer will behave as it should.  One of the very important values ‚Äã‚Äãis temperature, and it is vital to monitor it.  Some people on the printer have displays that display operational information, but not all.  In addition, you can physically located far from the printer, or at the wrong angle, and the display will no longer be read.  That is why you want to display the temperature, and the more quickly - the better. <br><br><img src="//habrastorage.org/files/d31/36e/fd8/d3136efd80d44d06925cc312f3705fb7.png"><br>  <i>Under the temperature we define a separate group of elements.</i> <br><br>  How to know her?  During heating, the printer stops receiving commands, and instead of <b>ok</b> or <b>wait, it</b> starts sending temperature.  The temperature string looks like this: <br><blockquote>  T: 196.94 / 210 B: 23.19 / 0 B @: 0 @: 4 </blockquote><br>  Readable for humans, but not very convenient for parsing.  In the first versions I analyzed this line right in the slot responsible for receiving information, but tests showed that parsing the line right in this slot slows down the program too much.  Until recently, I tried to avoid working with streams, since one of the main reasons why RepRaptor was written was speed.  Multithreading perfectly speeds up the work of software on multi-core systems, but everything was not so rosy with the hardware.  However, there was no choice left - it was necessary to transfer to a separate stream either the parsing or the connection itself.  It was decided to compromise - move the analysis to a separate stream, and allow the user to turn off the temperature check. <br><br>  How is multithreading implemented in Qt?  Very comfortably.  There are several ways to create a separate thread.  The full-fledged way is to create a stream using <a href="https://qt-project.org/doc/qt-4.8/qthread.html">QThread</a> , but we do not need a full-fledged stream for simple parsing of the string, so we will use another method ‚Äî we will pass our parse function along with the arguments to the QFuture object, and will follow it.  It is done this way - first we need to create an instance of QFutureWatcher, a class that monitors QFuture and informs us about its status.  Then you need to write our parse function.  Since the function can return only one variable, I decided to create a special type for temperature transfer: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> e, b; } TemperatureReadings;</code> </pre><br>  And the parsing function: <br><br><pre> <code class="cpp hljs">TemperatureReadings MainWindow::parseStatus(QByteArray data) { QString extmp = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      QString btmp = ""; //      for(int i = 2; data.at(i) != '/'; i++) //   { extmp+=data.at(i); } for(int i = data.indexOf("B:")+2; data.at(i) != '/'; i++) //   { btmp+=data.at(i); } TemperatureReadings t; te = extmp.toDouble(); //    tb = btmp.toDouble(); return t; //  }</span></span></code> </pre><br>  Now it only remains to give this function to the stream when conveniently (we insert an additional check into the receive function automaton): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//.... else if(checkingTemperature &amp;&amp; data.startsWith("T:")) // ,    { QFuture&lt;TemperatureReadings&gt; parseThread = QtConcurrent::run(this, &amp;MainWindow::parseStatus, data); //  QFuture (QtConcurrent::run   QFuture   parseStatus) statusWatcher.setFuture(parseThread); //   QFuture  ui-&gt;tempLine-&gt;setText(data); //    } //...</span></span></code> </pre><br>  It remains only to create a slot to connect a signal to it, which sends the results of the function execution from QFutureWatcher: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MainWindow::updateStatus() { TemperatureReadings r = statusWatcher.future().result(); <span class="hljs-comment"><span class="hljs-comment">//    ui-&gt;extruderlcd-&gt;display(re); //  ui-&gt;bedlcd-&gt;display(rb); sinceLastTemp.restart(); //     }</span></span></code> </pre><br>  That's all, now every time the printer informs us about the temperature - we parse this line and display it beautifully in the interface. <br><br>  The problem is that the printer itself sends it only during heating, but we can ask it to send it to us at any other time by sending a command to check the temperature M105.  We will send it on a timer, if several conditions are met.  Just as before, we create a new timer for the sending function, and a new slot for connecting to its signal.  This time we set a larger value to the timer, for example, 1500ms: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MainWindow::checkStatus() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checkingTemperature &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">//  .... (sinceLastTemp.elapsed() &gt; statusTimer.interval()) //      ,   &amp;&amp; statusWatcher.isFinished()) injectCommand("M105"); //     ,    M105 }</span></span></code> </pre><br>  Someone might say that these checks are superfluous, but when you control the printer with the Asus EEEPC 900AX, and you want to simultaneously read the Habr - this is a necessity. <br><br><h3>  Printing from SD card </h3><br><img src="//habrastorage.org/files/597/afe/cb7/597afecb7ba44e24bb363c2afe2176e2.png"><br><br>  A lot of standard boards for 3D printers have a built-in slot for an SD card, or a way to connect such a slot.  This method of printing is preferred, since at any time you can disconnect from the printer and leave, but every time you take out the SD card is often too lazy, especially if you print many small details.  Of course, you can transfer the file through the serial port, but transferring the file in this way takes hardly less time than printing itself. <br><br>  In any case, the host must be able to work with the SD card, which means: <br><ul><li>  Get file list </li><li>  Select file </li><li>  Print file </li><li>  Pause print </li><li>  Report progress </li></ul><br>  And that means more parsing!  But this time, polling the list of files, we can not worry about performance - at this moment it is not important.  To display a list of files, we need a dialog.  In the dialogue, we will transmit an array of strings with files, and it will return one file to us, and at the same time tell our program that it is in print mode with SD. <br><br>  Every time when a line comes to the host, from which the list of files on SD begins, we will open a dialog with a list of files.  To do this, change our receiver again: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//... if(readingFiles) //   { if(!data.contains("End file list")) sdFiles.append(data); //    -      else { readingFiles = false; //   emit sdReady(); //      } } //... else if(data.startsWith("Done")) sdprinting = false; //  Done -   SD  else if(data.startsWith("SD printing byte") &amp;&amp; sdWatcher.isFinished()) //  SD  { QFuture&lt;double&gt; parseSDThread = QtConcurrent::run(this, &amp;MainWindow::parseSDStatus, data); //     sdWatcher.setFuture(parseSDThread); //   } else if(data.contains("Begin file list")) //   SD  { sdFiles.clear();    readingFiles = true; // ,    } //...</span></span></code> </pre><br>  The flag is needed because our read method is called for <b>each line</b> . <br><br>  For one to open the dialogue will send a signal.  To myself.  Yes, you can even connect signals with slots of the same object. <br><br>  The slot we connect to this signal is: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MainWindow::initSDprinting() { <span class="hljs-function"><span class="hljs-function">SDWindow </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sdwindow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sdFiles, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; connect(&amp;sdwindow, SIGNAL(fileSelected(QString)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(selectSDfile(QString))); sdwindow.exec(); }</code> </pre><br>  After that, you need to put the interface in print mode.  I did this by introducing the additional sdprinting flag.  The status of printing from an SD card is checked in a similar manner with temperature. <br><br><h2>  Soft - to the masses </h2><br>  No matter how much I love GitHub, not everyone likes to collect software themselves.  Despite the cross-platform nature of Qt, it is a framework, not a cross-compilation environment.  And this means, in addition to binarikov for the Linux-amd64 platform, binarikas for Linux-i386, Windows 32 and OSX 64 are needed. Well, the first two are simple - just add the necessary sets to QtCreator.  And what about Windows 32 and OSX 64?  With the latter - no way.  I tried, but I wash my hands.  The only way to build something under OSX is to do it on OSX.  Unfortunately, it is not possible to do it legally. <br><br><h3>  Debian and its packages </h3><br>  I really wanted to build a package for my favorite Linux Mint, on which development is underway.  At first, I wanted to build packages for PPA, but eventually I came to the conclusion that I needed to build with static Qt libraries, and therefore I had to assemble the packages for the first time.  Why static linking?  Everything is very simple - even in Ubuntu 14.04, on which Mint is based, there is only Qt 5.2.1 in the sources.  During the tests of the first two releases on different systems, QSerialPort's bugs were fixed, corrected in new versions, and therefore it was decided to ship everything with the latest versions.  In addition, the Qt wiki says that statically linked libraries work somewhat faster. <br><br>  Hands on the package is going to be quite simple - it should contain a directory tree for the Debian file system, which contains all the files that we are going to install.  Having written a .desktop file in order to get an item in the menu on the target system, I wrote a small bash script to build the version of the packages I needed: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bashcd # $1 -       mkdir repraptor-$1-1-i386 mkdir repraptor-$1-1-amd64 mkdir repraptor-$1-1-i386/DEBIAN/ mkdir repraptor-$1-1-i386/usr/ mkdir repraptor-$1-1-i386/usr/local/ mkdir repraptor-$1-1-i386/usr/local/bin mkdir repraptor-$1-1-i386/usr/local/share mkdir repraptor-$1-1-amd64/DEBIAN/ mkdir repraptor-$1-1-amd64/usr/ mkdir repraptor-$1-1-amd64/usr/local/ mkdir repraptor-$1-1-amd64/usr/local/bin cp ../RepRaptor-linux32/RepRaptor repraptor-$1-1-i386/usr/local/bin/repraptor cp ../RepRaptor-linux64/RepRaptor repraptor-$1-1-amd64/usr/local/bin/repraptor cp share repraptor-$1-1-i386/usr/local/ -r cp share repraptor-$1-1-amd64/usr/local/ -r echo "Package: repraptor Version: $1-1 Section: base Priority: optional Architecture: i386 Maintainer: [Hello Habr!] Description: RepRaptor A Qt RepRap gcode sender/host controller" &gt; repraptor-$1-1-i386/DEBIAN/control echo "Package: repraptor Version: $1-1 Section: base Priority: optional Architecture: amd64 Maintainer: [Hello Habr!] Description: RepRaptor A Qt RepRap gcode sender/host controller" &gt; repraptor-$1-1-amd64/DEBIAN/control dpkg-deb --build repraptor-$1-1-i386 dpkg-deb --build repraptor-$1-1-amd64</span></span></code> </pre><br><br>  All he does is create a directory tree, copy the icons and the .desktop file, and then generate a package description for the package manager, inserting the correct version. <br><br><h3>  Windows and MXE </h3><br>  It's one thing to collect packages for your OS, another thing for someone else.  It requires tulchein - a set of tools for assembly.  Benefit under Windows there is an excellent MinGW, and for Linux there is an equally excellent MXE - the environment manager for cross-compiling using free libraries. <br><br>  Installation is ridiculously simple - we clone MXE and tell it which libraries we need: <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/mxe/mxe.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> mxe make qtbase qtserialport</code> </pre><br>  After that, you can safely go to drink coffee - the assembly of all this good takes a decent time. <br><br>  After the build is finished - you can write a project build script for Windows automatically: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #   MXE  PATH export PATH=/home/neothefox/src/mxe/usr/bin:$PATH #   rm -rf RepRaptor-win32 #        git clone https://github.com/NeoTheFox/RepRaptor RepRaptor-win32 cd RepRaptor-win32 # Makefile   QtCreator    /home/neothefox/src/mxe/usr/bin/i686-w64-mingw32.static-qmake-qt5 RepRaptor.pro make # ZIP       cp LICENCE release/ cd release zip RepRaptor-$1-win32.zip RepRaptor.exe LICENCE #       mv RepRaptor-$1-win32.zip ../../RepRaptor-$1-win32.zip</span></span></code> </pre><br>  Simple and angry.  Health is easily checked in Wine: <br><br><img src="//habrastorage.org/files/e98/53e/538/e9853e53824f4819b2c2b4d2ddf5a5e2.png"><br><br><h2>  findings </h2><br>  When I started this, I was hoping to write a simple sending of G-code files, which would not do anything else, but would plan it in the evening.  But, as is often the case - the project has gone beyond the original plan, and now is something more.  There is still a lot to do - at least the same graphic EEPROM editor, which is so lacking, as well as support for checksums. <br><br>  However, RepRaptor already allows me to safely use my ASUS EEEPC as a stable host for a printer, which no other host I have tried could achieve.  Well, Qt's knowledge I have definitely improved, and still there is still room for optimizations. <br><br>  This article is also timed to the release of the first stable version, which I myself now use every day - 0.2. <br><br>  Thank you all for your attention!  I hope my experience was useful to you. <br><br>  Finally, here is an army of objects printed during the tests: <br><br><img height="600" src="//habrastorage.org/files/afe/e26/cd0/afee26cd0f204e7aa8d89846ba85ca8b.jpg"><br><br><h2>  Links </h2><br>  <a href="">First stable version</a> <br>  <a href="http://reprap.org/wiki/RepRaptor">Reprap wiki</a> <br>  <a href="https://github.com/NeoTheFox/RepRaptor">Github</a> </div><p>Source: <a href="https://habr.com/ru/post/252189/">https://habr.com/ru/post/252189/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252175/index.html">Resize images in the browser. All very bad</a></li>
<li><a href="../252177/index.html">I hack you in my eyes</a></li>
<li><a href="../252179/index.html">IBM AbilityLab Mobile Accessibility Checker: a tool to automate the checking of the availability of a mobile application interface</a></li>
<li><a href="../252181/index.html">Quantitative CSS selectors</a></li>
<li><a href="../252187/index.html">Evolution of data carriers</a></li>
<li><a href="../252191/index.html">How to combine services for teamwork: Sameroom project</a></li>
<li><a href="../252193/index.html">Swift Books</a></li>
<li><a href="../252195/index.html">GDC 2015: a major news digest. March, 3rd</a></li>
<li><a href="../252197/index.html">The world's best ghost with a motor, or integration testing of complex client-server applications</a></li>
<li><a href="../252199/index.html">Zend Certification. Not so devil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>