<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[CppCon 2017] Matt Godbolt: What did my compiler do for me?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing the cycle of review articles from the CppCon 2017 conference. 
 Cycle content 

- Bjarne Stroustrup: Learning and teaching modern C ++ 
- L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[CppCon 2017] Matt Godbolt: What did my compiler do for me?</h1><div class="post__text post__text-html js-mediator-article"><p>  Continuing the cycle of review articles from the CppCon 2017 conference. </p><br><div class="spoiler">  <b class="spoiler_title">Cycle content</b> <div class="spoiler_text"><ul><li>  <a href="https://habrahabr.ru/post/339036/">Bjarne Stroustrup: Learning and teaching modern C ++</a> </li><li>  <a href="https://habrahabr.ru/post/339180/">Lars Knoll: C ++ Qt framework: History, Present and Future</a> </li><li>  <a href="https://habrahabr.ru/post/339186/">Herb Sutter: Metaprogramming and Code Generation in C ++</a> </li><li>  Matt Godbolt: What did my compiler do for me? </li></ul></div></div><br><p>  This time a very interesting speech from the author Compiler Explorer ( <a href="http://godbolt.org/">godbolt.org</a> ).  Be sure to read to everyone who, for speed, multiplies by 2 using shift (at least x86-64).  If you are familiar with x86-64 assembler, you can rewind to the sections with examples ("Multiplication", "Division", etc.).  Next, the words of the author.  My comments are in square brackets in italics. </p><br><p>  My goal is to make you not afraid of the assembler, this is a useful thing.  And used it.  Not necessarily all the time.  And I'm not saying that you have to drop everything and teach the assembler.  But you should be able to see the result of the compiler.  And when you do this, you will appreciate how much work the compiler has done, and how smart it is. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bSkpMdDe4g4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2 id="predystoriya">  Prehistory </h2><br><p>  So, there is a classic way of summing up (before C ++ 11): </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); ++i) result += v[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  With the advent of Range-For-Loop, we wondered if we could replace it with a more pleasant code: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x : v) result += x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Our concerns were related to the fact that we were already "bitten" by iterators in other languages.  We had the experience of container iteration in which iterators were constructed, which added work to the garbage collector.  We knew that there was no such thing in C ++, but we had to check it out. </p><br><h2 id="preduprezhdenie">  A warning </h2><br><p>  Reading assembler code: you can easily be misled if you think that you can see what is happening here, that it works faster than that due to fewer instructions.  In a modern processor, very complex things happen and you cannot predict.  If you make performance predictions, then always run benchmarks.  For example from Google or online interactive <a href="http://quick-bench.com/">http://quick-bench.com</a> . </p><br><h2 id="osnovy-assemblera-x86-64">  X86-64 assembler basics </h2><br><h3 id="registry">  Registers </h3><br><ul><li>  16 integer 64-bit general purpose registers (RAX, RBX, RCX, RDX, RBP, RSI, RDI, RSP, R8 - R15) </li><li>  8 80-bit floating point registers (ST0 - ST7) </li><li>  16 128-bit SSE registers (XMM0 - XMM15) </li></ul><br><p>  There are <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">conventions for calling ABI functions</a> , this is how functions "communicate" with each other, in particular: </p><br><ul><li>  rdi, rsi, rdx - arguments </li><li>  rax - the return value </li></ul><br><p>  There are also rules that tell which registers you can overwrite, which ones to save.  But if you do not write in assembler, then you don‚Äôt need to know them. </p><br><p><img src="https://habrastorage.org/webt/59/df/55/59df55b54f675313635534.png" alt="registers"></p><br><p>  General-purpose registers are 64-bit, but have different names.  For example, turning to the eax register, we get the bottom 32 bits of the rax register.  But for complex reasons, writing to eax will reset the top 32 bits of rax <a href="https://stackoverflow.com/questions/11177137/why-do-most-x64-instructions-zero-the-upper-part-of-a-32-bit-register"><em>(why)</em></a> .  This does not apply to ax, ah, al. </p><br><h3 id="operacii">  Operations </h3><br><p>  I am using <a href="https://ru.wikipedia.org/wiki/Intel-%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2581">Intel syntax</a> .  Who uses Intel syntax in the room?  And <a href="https://ru.wikipedia.org/wiki/AT%2526T-%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2581">AT &amp; T</a> ?  Oh, it seems today I made myself enemies. </p><br><p>  Types of operations (Intel syntax): </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">op</span></span> op dest op dest, src op dest, src1 src2</code> </pre> <br><p>  Examples of mnemonic (op): call, ret, add, sub, cmp.  Operands (dest, src) can be registers or references to memory of the form: </p><br><pre> <code class="hljs json">[base + reg1 + reg2 * (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> or <span class="hljs-number"><span class="hljs-number">8</span></span>)]</code> </pre> <br><p>  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B4%25D1%2580%25D0%25B5%25D1%2581%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D0%25B8">A reference to memory is</a> rarely an absolute value.  We can use the register value, as well as add some offset, set by the value of another register. </p><br><p>  Consider an example: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r14]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rdi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r14+4]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r14+4*rbx]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lea</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rax</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r14+4*rbx]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span></code> </pre> <br><p>  His pseudocode: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> eax = *r14; <span class="hljs-comment"><span class="hljs-comment">// int *r14; rax += rdi; eax += r14[1]; eax -= r14[rbx]; int *rax = &amp;r14[rbx]; edx = 0;</span></span></code> </pre> <br><p>  Let's sort in the lines: </p><br><ol><li>  Reading 4 bytes from r14 register and placing in eax. </li><li>  Adding the rdi value to rax. </li><li>  Adding a 4-byte value stored at r14 + 4 to eax.  Such a memory access is analogous to receiving the first (if we count from zero) array values, if r14 is a pointer to the beginning of an array of 4-byte numbers. </li><li>  Similar to the previous one, but you can change the index of the array. </li><li>  The lea command is used to load an effective address.  [ <em>Approximately how <code>mov rax, r14+4*rbx</code> , if so it would be possible to write</em> .] </li><li>  Here is such a strange way to zero.  The fact is that <code>mov edx, 0</code> is 4 bytes, and <code>xor edx, edx</code> is 2. </li></ol><br><h2 id="compiler-explorer-v01">  Compiler Explorer v0.1 </h2><br><p>  First, to study the work of the compiler, I did the following.  Compiled with the command: </p><br><pre> <code class="bash hljs">$ g++ /tmp/test.cc -O2 -c -S -o - -masm=intel \ | c++filt \ | grep -vE <span class="hljs-string"><span class="hljs-string">'\s+\.'</span></span></code> </pre> <br><p>  Explanation: </p><br><ul><li>  Running <code>g++</code> : <br><ul><li>  compile test.cc </li><li>  optimization enabled (-O2) </li><li>  without calling the linker (-c) </li><li>  with assembler listing generation (-S) </li><li>  with output to standard stream (-o -) </li><li>  using Intel notation (-masm = intel) </li></ul></li><li>  <code>c++filt</code> is a name decoding utility (demangling). </li><li> <code>grep -vE '\s+\.'</code>  - delete all the funny lines. </li></ul><br><p>  This command was launched at a certain interval using the watch utility, which set the <code>-d</code> (diff) flag to display the differences.  Then I just split the terminal in half using <a href="https://ru.wikipedia.org/wiki/Tmux">tmux</a> , put the script in one, vi in ‚Äã‚Äãanother.  And so got a compiler explorer. </p><br><h2 id="compiler-explorer">  Compiler explorer </h2><br><p>  Now briefly about the modern version of Compiler Explorer.  To create a new window with a code, click on the "Editor" item and hold down dragging to the right place.  To create a window with the result of the compilation, you need to click on the button with the arrow up and hold it down.  If I hover over the yellow line, the corresponding lines in the assembler part will become fatter. </p><br><p>  <a href="https://godbolt.org/g/73nKPW">Link</a> </p><br><p><img src="https://habrastorage.org/webt/59/df/53/59df5334de475392865742.png" alt="compile explorer"></p><br><p>  I chose GCC 7.1 with the arguments <code>-O2 -std=c++1z -march=haswell</code> .  We see that <code>int result = 0;</code>  corresponds to <code>xor eax eax</code> .  The rdx register contains a pointer to the current element of the vector.  Accumulation <code>result += x;</code>  implemented as an increase in the value of the register <code>eax</code> by the value located at the address in rdx, with the subsequent transition to the next element of the array.  String <code>return result;</code>  not highlighted in color, which means that there is no explicit match for it.  This is because after the loop completes, the eax register (which is often used to store the return value) already contains a value.  With optimization, the compiler did exactly what we asked for. </p><br><p>  Now I will show the result of the compilation without optimization (-O0). </p><br><p><img src="https://habrastorage.org/webt/59/df/53/59df534158732514499235.png" alt="o1"></p><br><p>  If you compile with <code>-O1</code> , then GCC for some reason does not consider it necessary to use <code>xor eax, eax</code> instead of <code>mov eax, 0</code> . </p><br><p>  Change to <code>-O3</code> .  This is amazing, just take a look: </p><br><p><img src="https://habrastorage.org/webt/59/df/53/59df5341575da551667587.png" alt="o3"></p><br><p>  Awesome, all these cool operations are used!  But you need to use benchmarks to make sure that such code is faster than the simple version. </p><br><p>  Let's return to our example: </p><br><p>  <a href="https://godbolt.org/g/D4TU2g">Two windows with code</a> : </p><br><p><img src="https://habrastorage.org/webt/59/df/53/59df533569cb1016552746.png" alt="compile explorer"></p><br><p>  <a href="https://godbolt.org/g/NMkv3T">Comparison (diff)</a> : </p><br><p><img src="https://habrastorage.org/webt/59/df/53/59df5335209ef324240697.png" alt="compile explorer"></p><br><p>  Left cycle from 0 to size, right range for.  The code implementing loops is identical in both cases.  Let's try this way: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::accumulate(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(v), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(v), <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>  Same. </p><br><h2 id="podrobnyy-razbor">  Detailed analysis </h2><br><p>  Let's start with the first two lines: </p><br><pre> <code class="hljs pgsql">; rdi = const vector&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt; * mov rdx, QWORD PTR [rdi] ; rdx = *rdi ‚â° <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>() mov rcx, QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>] ; rcx = *(rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>) ‚â° <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>()</code> </pre> <br><p>  We passed the vector by reference.  But there is no such thing as a link.  Only pointers.  The rdi register indicates the transmitted vector.  The values ‚Äã‚Äãare read at addresses rdi and rdi + 8. It is a mistake to think that rdi is a pointer directly to an array of ints.  This is a pointer to a vector.  At least in GCC, the implementation of the vector is as follows: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector_impl</span></span></span><span class="hljs-class"> {</span></span> T *_M_start; T *_M_finish; T *_M_end_of_storage; };</code> </pre> <br><p>  That is, a vector is a structure containing three pointers.  The first pointer is the beginning of the array, the second is the end, the third is the end of the reserved memory (allocated) for this vector.  The size of the array is clearly not stored here.  It is interesting.  Let's look at the differences in implementations before the cycle begins.  The first example (a normal loop with an index): </p><br><pre> <code class="hljs sql">sub rcx, rdx ; rcx = <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> mov rax, rcx shr rax, <span class="hljs-number"><span class="hljs-number">2</span></span> ; (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>)/<span class="hljs-number"><span class="hljs-number">4</span></span> je .L4 <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rcx, rdx <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> eax, eax</code> </pre> <br><p>  The first line calculates the number of bytes in the array.  In the third, this value is divided by 4 to find the number of elements (since int is 4-byte).  That is, it‚Äôs just a size function: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _M_finish - _M_start; }</code> </pre> <br><p>  If you get a size of 0 after the shift operation, then Equal Flag is set and the jump operation <code>je</code> (Jump If Equal), and the program returns 0. Thus, the check for equality of the size to zero occurred.  Further, we assume that during the iterations an index with a size will be checked.  But the compiler guesses that in fact we don‚Äôt need this index, and in the loop it will compare the current pointer to the array element with the end of the array (rcx). </p><br><p>  Now the second example (with range for): </p><br><pre> <code class="hljs erlang"><span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> eax, eax cmp rdx, rcx ; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>==<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>? je .L4</code> </pre> <br><p>  Here it is simply compared whether the initial pointer is equal to the final one, and if so, then jump to the end of the program.  In fact, it happened: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __begin = begin(v); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __end = end(v); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __it = __begin; __it != __end; ++it)</code> </pre> <br><p>  The cycle itself is identical in both cases: </p><br><pre> <code class="hljs pgsql">; rcx ‚â° <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, rdx = <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>, eax = <span class="hljs-number"><span class="hljs-number">0</span></span> .L3: <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> eax, DWORD PTR [rdx] ; eax += *rdx <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rdx, <span class="hljs-number"><span class="hljs-number">4</span></span> ; rdx += sizeof(<span class="hljs-type"><span class="hljs-type">int</span></span>) cmp rdx, rcx ; <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> rdx == <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>? jne .L3 ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> ret ; w<span class="hljs-string"><span class="hljs-string">e're done</span></span></code> </pre> <br><p>  We found: </p><br><ul><li>  Range-for turned out to be a slightly more preferred option. </li><li>  Compiler options are important. </li><li>  std :: accumulate shows the same result. </li></ul><br><h2 id="umnozhenie">  Multiplication </h2><br><p>  Further I will show small, but cool examples. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mulByY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * y; }</code> </pre> <br><pre> <code class="hljs objectivec">mulByY(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>): mov eax, edi imul eax, esi ret</code> </pre> <br><p>  edi is the first parameter, esi is the second.  Normal multiplication with imul.  This is what 4-bit manual multiplication looks like: </p><br><pre> <code class="hljs lisp"> <span class="hljs-number"><span class="hljs-number">1101</span></span> (<span class="hljs-number"><span class="hljs-number">13</span></span>) x <span class="hljs-number"><span class="hljs-number">0101</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>) -------- <span class="hljs-number"><span class="hljs-number">1101</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">1101</span></span> + <span class="hljs-number"><span class="hljs-number">0000</span></span> -------- <span class="hljs-number"><span class="hljs-number">01000001</span></span> (<span class="hljs-number"><span class="hljs-number">65</span></span>)</code> </pre> <br><p>  We had to perform 4 additions.  It is a miracle that the Haswell 32-bit multiplication takes place in just 4 clock cycles.  Addition per 1 clock.  But let's see examples in which even faster: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mulByConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br><p>  You can expect the left shift to occur by 1. Check: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">lea</span></span> eax, [rdi+rdi]</code> </pre> <br><p>  One operation.  The advantage of lea is that you can set the source very flexibly.  To implement using the shift, you would have to do 2 operations: copy the value to eax and shift. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mulByConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">lea</span></span> eax, [<span class="hljs-number"><span class="hljs-number">0</span></span>+rdi*<span class="hljs-number"><span class="hljs-number">4</span></span>]</code> </pre> <br><p>  lea supports multiplication by 2, 4, 8. Therefore, multiplying by 8 will be the same: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">lea</span></span> eax, [<span class="hljs-number"><span class="hljs-number">0</span></span>+rdi*<span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre> <br><p>  At 16 already with a shift: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> eax, edi sal eax, <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  On 65599: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">imul</span></span> eax, edi, <span class="hljs-number"><span class="hljs-number">65599</span></span></code> </pre> <br><p>  Yeah, these compiler developers are not as smart as they think they are.  I can implement more efficiently: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mulBy65599</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) + (a &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>) - a; <span class="hljs-comment"><span class="hljs-comment">// ^ ^ // a * 65536 | // a * 64 // 65536a + 64a - 1a = 65599a }</span></span></code> </pre> <br><p>  Checking: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">imul</span></span> eax, edi, <span class="hljs-number"><span class="hljs-number">65599</span></span></code> </pre> <br><p>  OU!  [ <em>Laughter, applause</em> ].  Is this what the compiler is smarter than me?  Yes, indeed, multiplication is more effective than these few shifts and additions.  But it is on modern processors.  Let's return to the past <code>-O2 -std=c++1z -march=i486 -m32</code> : </p><br><pre> <code class="hljs cs">mov edx, DWORD PTR [esp+<span class="hljs-number"><span class="hljs-number">4</span></span>] mov eax, edx sal eax, <span class="hljs-number"><span class="hljs-number">16</span></span> mov ecx, edx sal ecx, <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> eax, ecx sub eax, edx</code> </pre> <br><p>  Well, return back <code>return a * 65599;</code>  : </p><br><pre> <code class="hljs cs">mov edx, DWORD PTR [esp+<span class="hljs-number"><span class="hljs-number">4</span></span>] mov eax, edx sal eax, <span class="hljs-number"><span class="hljs-number">16</span></span> mov ecx, edx sal ecx, <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> eax, ecx sub eax, edx</code> </pre> <br><p>  Let the compiler do all these things for you. </p><br><h2 id="delenie">  Division </h2><br><p>  In general: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divByY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x / y; }</code> </pre> <br><pre> <code class="hljs objectivec">divByY(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>): mov eax, edi cdq idiv esi ret</code> </pre> <br><p>  On Haswell, 32-bit division is performed in 22-29 cycles.  Can we do better? </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divByConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x / <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> eax, edi shr eax</code> </pre> <br><p>  No magic, just a shift to the right.  Also, no surprises if we divide by 4, 8, 16, etc. Let's try on 3: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> eax, edi mov edx, -<span class="hljs-number"><span class="hljs-number">1431655765</span></span> mul edx mov eax, edx shr eax</code> </pre> <br><p>  What happened? </p><br><pre> <code class="hljs markdown">mov eax, edi ; eax = x mov edx, 0xaaaaaaab mul edx ; eax:edx = x <span class="hljs-bullet"><span class="hljs-bullet">* 0xaaaaaaab mov eax, edx ; (x *</span></span> 0xaaaaaaab) &gt;&gt; 32 ; ‚â° (x <span class="hljs-bullet"><span class="hljs-bullet">* 0xaaaaaaab) / 0x10000000 ; ‚â° x *</span></span> 0.6666666667 shr eax ; x * 0.333333333 ret</code> </pre> <br><p>  The value of 2/3 * x turned out to be in edx, the high-order 32 bits of the 64-bit multiplication result.  That is, in fact, there was a multiplication by 2/3 and a shift of 1 to the right.  [ <em>If it is not very clear, then multiply in some hex-calculator 0xaaaaaaab by 3, 4, 5, 6 ... and watch the high-order digits</em> ]. </p><br><h2 id="ostatok-ot-deleniya">  Remainder of the division </h2><br><p>  In general: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modByY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x % y; }</code> </pre> <br><pre> <code class="hljs objectivec">modByY(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>): mov eax, edi cdq idiv esi mov eax, edx ret</code> </pre> <br><p>  In particular, the remainder of dividing by 3: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modBy3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x % <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br><pre> <code class="hljs perl">mov eax, edi mov edx, <span class="hljs-number"><span class="hljs-number">0xaaaaaaab</span></span> mul edx mov eax, edx shr eax lea eax, [rax+rax*<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edi</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mov</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eax</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edi</span></span></span></span></code> </pre> <br><p>  The first 5 lines - already considered division.  And in the following, the result of the division is multiplied by 3 and subtracted from the original value.  That is, x-3 * [x / 3].  Why do I pay attention to the division by module?  Because it is used in hash-map - a favorite container of all.  To find or add an object to the container, the remainder of the hash division by the size of the hash table is calculated.  This remainder is the index of the table element (bucket).  It is very important that this operation works as quickly as possible.  In general, it works for quite a long time.  Therefore, libc ++ uses powers of two for the allowable table sizes.  But these are not very good values.  The Boost multi_index implementation contains many acceptable sizes, and a switch with their enumeration. </p><br><p>  [ <em>Judging by the question from the audience, not everyone understood this explanation.</em>  <em>Roughly speaking, such an implementation:</em> ] </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(size_index): { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x % <span class="hljs-number"><span class="hljs-number">53</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x % <span class="hljs-number"><span class="hljs-number">97</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x % <span class="hljs-number"><span class="hljs-number">193</span></span>; ... }</code> </pre> <br><h2 id="podschet-bitov">  Counting bits </h2><br><p>  The following function counts unit bits: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countSetBits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (a) { count++; a &amp;= (a<span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br><p>  At each iteration, the number of the youngest one disappears until the whole number turns zero.  GCC did cleverly: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">countSetBits</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>): <span class="hljs-selector-tag"><span class="hljs-selector-tag">xor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">je</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L4</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">blsr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jne</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L4</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre> <br><p>  Here, the expression <code>a &amp;= (a-1);</code>  replaced by <code>blsr</code> instruction.  I have never seen her before preparing for this talk.  It clears the last unit and places the result in the specified register.  Let's try to choose another compiler - <code>x86-64 clang (trunk)</code> : </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">popcnt</span></span> eax, edi</code> </pre> <br><p>  This instruction, which performs the counting of bits that people so wanted, that intel added it.  Just think what a clang should do.  For him there were no clues "I want to count the bits." </p><br><h2 id="slozhenie">  Addition </h2><br><p>  The addition of all integers from 0 to x inclusive: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= x; ++i) sum += i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumTo(<span class="hljs-number"><span class="hljs-number">20</span></span>); }</code> </pre> <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> eax, <span class="hljs-number"><span class="hljs-number">210</span></span></code> </pre> <br><p>  OK understood!  Here constexpr is not so important.  If we replace it with static [ <em>so that the function is visible only in one translation unit</em> ], then we get the same result.  If you call <code>sumTo(argc)</code> , then the loop is not going anywhere.  Let's try clang: </p><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">js</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LBB0_1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ecx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lea</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rdi - 1]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">imul</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rcx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LBB0_1</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">xor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre> <br><p>  Interestingly, the cycle is gone.  The first two lines check the argument to zero.  In the following 5, just the sum formula is: x (x + 1) / 2 == x + x (x-1) / 2.  Implemented the second version of the formula, because the first option will cause an overflow if you pass INT_MAX. </p><br><h2 id="kak-rabotaet-compiler-explorer">  How Compiler Explorer Works </h2><br><p>  [ <em>I don‚Äôt understand Frontend, Docker, virtualization and other things that the author was talking about, so I decided not to describe all the details of the implementation so as not to blurt out the nonsense</em> ] </p><br><p>  Written on node.js.  Launched on Amazon EC2.  This is my second speech at this conference, in which I speak about JavaScript and I feel so bad.  Of course, we sometimes criticize C ++ ... but if you just look at javascript, oh ... </p><br><p>  It all looks something like this: </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, next)</span></span></span></span> { // exec compiler, feed it req.body, parse <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> } var webServer = express(); var apiHandler = express.Router(); apiHandler.param(<span class="hljs-string"><span class="hljs-string">'compiler'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, next, compiler)</span></span></span></span> { req.compiler = compiler; <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(); }); apiHandler.post(<span class="hljs-string"><span class="hljs-string">'/compiler/:compiler/compile'</span></span>, compile); webServer.use(<span class="hljs-string"><span class="hljs-string">'/api'</span></span>, apiHandler); webServer.listen(<span class="hljs-number"><span class="hljs-number">10240</span></span>);</code> </pre> <br><h3 id="amazon-ec2">  Amazon EC2 </h3><br><p>  The following features: </p><br><ul><li>  Edge cache </li><li>  Load balancer </li><li>  Virtual machines </li><li>  Docker images </li><li>  Shared compiler storage </li></ul><br><h3 id="kompilyatory">  Compilers </h3><br><p>  I installed them using apt-get.  Microsoft compilers work through WINE. </p><br><h3 id="bezopasnost">  Security </h3><br><p>  A huge security hole.  Although compilers only compile, not run, GCC, for example, supports plugins, and you can load the dynamic library ( <code>-fplugin=/path/to/name.so</code> ).  Or specs files.  At first I tried to find possible vulnerabilities, but I came to the conclusion that it is very difficult to take everything into account.  And I began to ponder what is the worst that can happen?  You can stop the docker container, but it will start again.  Even if you get beyond it in a virtual machine, there will be no privileges.  Docker protects me from such tricks. </p><br><h3 id="frontend">  Frontend </h3><br><p>  Microsoft Monaco is used as an online code editor.  Drag-drop for windows is implemented using GoldenLayout. </p><br><h3 id="ishodniki">  Sources </h3><br><ul><li>  <a href="http://github.com/mattgodbolt/compiler-explorer">github.com/mattgodbolt/compiler-explorer</a> </li><li>  <a href="http://github.com/mattgodbolt/compiler-explorer-image">github.com/mattgodbolt/compiler-explorer-image</a> </li></ul><br><h2 id="skoro">  Soon </h2><br><ul><li>  CFG - control graph viewer [ <em>I understand, as in IDA</em> ]. </li><li>  Unification of languages.  Compiler Explorer supports other languages ‚Äã‚Äã({d, swift, haskell, go, ispc} .godbolt.org).  I would like to combine them in one place, and not across different domains.  So that you can compare the implementation of the same in different languages. </li><li>  Running the code! </li></ul><br><h2 id="voprosy">  Questions </h2><br><blockquote>  I would like to see support for other libraries, for example Boost. </blockquote><p>  Some already have: </p><br><p><img src="https://habrastorage.org/webt/59/df/53/59df5334bcbdb737842573.png"></p><br><blockquote>  You talked about switch for all possible table sizes in Boost multi_index.  But such an implementation is inefficient - since the values ‚Äã‚Äãare very sparse, you will not be able to use the jump table, but only binary search. </blockquote><p>  The switch lists not the dimensions themselves, but their indices. </p><br><blockquote>  Is web assembly support planned? </blockquote><p>  There are many compilers that do not have backends for webassembly.  Well, yes, it would be nice, but still busy with other things. </p><br><blockquote>  How much is it? </blockquote><p>  I spend about $ 120-150 per month on Amazon servers. </p><br><blockquote>  Whether support of llvm intermediate representation is planned? </blockquote><p>  Yes, already there, if you run with the <code>-emit-llvm</code> flag.  The compiler itself produces this dump, I do nothing.  Improved backlight is planned. </p><br><blockquote>  How do you tint the relevant lines of source code and assembler? </blockquote><p>  Just run with the "-g" flag.  The resulting listing has comments with line numbers. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/339962/">https://habr.com/ru/post/339962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339952/index.html">Dynamic analysis of iOS applications without Jailbreak</a></li>
<li><a href="../339954/index.html">How to teach your neural network to analyze morphology</a></li>
<li><a href="../339956/index.html">Data Science Week 2017. Review of the second and third day</a></li>
<li><a href="../339958/index.html">Total exhaustion, or is there life after IPv4</a></li>
<li><a href="../339960/index.html">ServiceNow-conference "Knowledge17"</a></li>
<li><a href="../339966/index.html">Five stages of the evolution of CRM users</a></li>
<li><a href="../339968/index.html">Data Geometry 5. Base Conversion</a></li>
<li><a href="../339970/index.html">IoTmanager is a mobile MQTT client with an unusual concept</a></li>
<li><a href="../339972/index.html">Raiffeisenbank DevOps: Flight Phase</a></li>
<li><a href="../339974/index.html">How we did and do memed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>