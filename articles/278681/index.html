<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to parse text with bare hardware, without a processor and without software</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Someone is parsing a text file with a program on Python, another is writing a script with regular expressions on Perl, a C programmer bashfully tinker...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to parse text with bare hardware, without a processor and without software</h1><div class="post__text post__text-html js-mediator-article">  Someone is parsing a text file with a program on Python, another is writing a script with regular expressions on Perl, a C programmer bashfully tinkering with buffers and pointers, sometimes using Yacc and Lex. <br><br>  Is it possible to parse the text with bare iron?  No program at all? <br><br>  ‚ÄúAnd how is it ?,‚Äù a friend asked me, ‚ÄúWith the help of Arduino?‚Äù 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ‚ÄúInside Arduino, there is quite a von Neumann processor and the program works,‚Äù I replied. ‚ÄúNo, even more bare hardware.‚Äù <br><br>  ‚ÄúAhhhhhhh, this microcode?‚Äù My companion guessed and looked at me triumphantly. <br><br>  - No, the term "microcode" was used for the specific organization of processors in the 1970s, then its use came to naught, - I answered and added, - Truth, there are still microoperations in Intel processors, into which x86 is recoded, but this is also <i>different</i> .  No, I mean text parsing by a device consisting of AND-OR-NOT logical gates and D-triggers, as in the picture below. <br><br>  - Impossible!  - exclaimed my friend, - in such a device somewhere on the side should sit the processor and slyly wink! <br><br>  ‚ÄúWhy is this impossible?‚Äù I retorted, ‚ÄúYou know the Turing machine?‚Äù  Parsing text on the tape, and no Intel and arduino at the side wink. <br><br>  ‚ÄúWell, Turing machine,‚Äù drawled his friend, ‚Äúthis is an abstraction, such as Demon Maxwell.‚Äù <br><br>  ‚ÄúNo abstraction, now you will see a working scheme parsing the text,‚Äù I said, and added, ‚Äúbut first I‚Äôll tell you why I needed it at all.‚Äù <br><br> <a href="" rel="attachment wp-att-863"><img src="https://habrastorage.org/getpro/habr/post_images/6c1/1d7/bf2/6c11d7bf23818087189b65cf20e7b142.png" alt="mfp_srec_parser_fragment"></a> <br><a name="habracut"></a><br><h3>  1. Why did I need to parse the text with a hardware without software </h3><br><br>  Last year, I participated as one of the organizers in a <a href="http://www.silicon-russia.com/2015/12/19/mipsfpga-russia-trip-report-in-russian/">series of seminars</a> on <a href="http://www.silicon-russia.com/2016/01/04/mipsfpga-how-to-start/">MIPSfpga</a> .  MIPSfpga is a package that contains the processor core in the source code on Verilog, which can be changed, add new instructions, build multiprocessor systems, simultaneously change software and hardware, etc.  The MIPSfpga system can be simulated in the simulator verilogue, synthesized and implemented <a href="http://www.silicon-russia.com/2015/02/14/first-steps-with-fpga/">on the FPGA board</a> , or with a strong desire to make a chip on it at the factory. <br><br>  FPGA / FPGA board with MIPSfpga needs to be programmed twice - first fill the PC hardware configuration into it (determine the logical function of each FPGA cell and the connections between them), and then pour the software (processor sequence) into the synthesized hardware memory (also with the PC) systems (which includes the <a href="http://imgtec.com/mips/aptiv/microaptiv/">MIPS microAptiv UP</a> processor core, interconnect, two memory blocks and an I / O unit). <br><br>  There are no problems with uploading a hardware - both Xilinx ISE / Vivado and Altera Quartus II contain software that allows you to upload the hardware configuration to the boards I work with using a simple USB cable without any additions from the user.  Such boards include <a href="http://store.digilentinc.com/basys-3-artix-7-fpga-trainer-board-recommended-for-introductory-users/">Digilent Basys 3</a> and <a href="http://store.digilentinc.com/nexys-4-ddr-artix-7-fpga-trainer-board-recommended-for-ece-curriculum/">Nexys 4 DDR</a> , <a href="http://de0-cv.terasic.com.tw/">Terasic DE0-CV</a> and others. <br><br>  Unlike the hardware configuration, the software in the standard MIPSfpga Getting Started package is poured through the EJTAG debugging interface using an additional fee, called <a href="http://blog.imgtec.com/mips-processors/bus-blaster-v3c-is-an-affordable-debug-probe-for-mips-cpus">BusBlaster</a> , in combination with the software, which is called <a href="http://openocd.org/">OpenOCD</a> .  Unfortunately, the BusBlaster / Open OCD combination is quite raw - it may have driver problems in some versions of Windows and Linux.  In addition, BusBlaster is nontrivial to buy in Russia.  Therefore, before the seminars, I thought about how to fill the software part of the system in MIPSfpga without BusBlaster / OpenOCD. <br><br> <a href="" rel="attachment wp-att-165"><img src="https://habrastorage.org/getpro/habr/post_images/ff1/0c4/940/ff10c4940953bcf05407f86e687309b8.jpg" alt="mipsfpga_setup_on_de0_cv_for_seminars_in_russia_20151018_114617"></a> <br><br><h3>  2. Which file you need to parse and upload to the system‚Äôs memory </h3><br><br>  Software that needs to be uploaded to MIPSfpga is the most common C or assembler program that is compiled and linked by regular GCC to an ELF file.  The GNU package also contains the <i>objcopy</i> program, which can turn ELF into a variety of formats, including text-based Intel HEX, Motorola S-record, and a format that the built-in subroutine $ readmemh in the Verilog hardware description language understands.  At first I wanted to use the Intel HEX format, but found that it does not support the one of the <i>objcopy</i> options for MIPS that I used.  The second option was to use the format <br>  <a href="http://en.wikipedia.org/wiki/SREC_(file_format)">Motorola S-record</a> , and with them everything turned out well.  Here is a cheat sheet for this format: <br><br> <a href="" rel="attachment wp-att-366"><img src="https://habrastorage.org/getpro/habr/post_images/a95/5f3/388/a955f3388dc1c9f2591b6c3048dcb257.png" alt="Motorola_SREC_Chart"></a> <br><br><h3>  3. How to fill and how - engineering solutions options </h3><br><br>  3.1.  The easiest way to avoid uploading software through BusBlaster is to simply put it into the MIPSfpga system during its synthesis ‚Äî a process in which the code in the Verilog hardware description language is converted into a graph from logic elements and triggers.  Both the Xilinx ISE / Vivado synthesizer and Altera Quartus II <a href="http://stackoverflow.com/questions/4321067/is-readmem-synthesizable-in-verilog">recognize the Verilog $ readmemh structure during the synthesis and create a memory that is initialized with data from a text file</a> .  Unfortunately, this solution is very impractical if the user is going to frequently recompile the software, since each time he will also have to re-synthesize the hardware, which can take from 15 to 30 minutes. <br><br>  3.1.1.  Option 3.1 is a partial reconfiguration of the FPGA.  I did not investigate it, because I learned that in this case I would have to wait a long time, and I want to wait no more than a few seconds.  In addition, I wanted something that did not depend on the manufacturer of FPGAs. <br><br>  3.2.  The most intuitively expected way for embedded programmers is to make part of the program fixed, which is placed into the system during its synthesis (bootloader), and another part of the program is downloaded from the PC via the serial port.  The boot program would have to initiate the transfer of the loadable program from the PC, receive this program in the form of data, which is then stored in memory.  This method was described by <a href="http://habrahabr.ru/users/Frantony/">@Frantony</a> in a note on Habr√© <a href="http://habrahabr.ru/post/274839/">"MIPSfpga: outside the canon"</a> <br><br>  3.2.1.  At method 3.2.  There are two variations - transfer the loadable program as a text file in a format like Motorola S-record and parse this file in the bootloader on the board, or, alternatively, parse the text file on the PC and transfer the data to the board in binary form. <br><br>  3.3.  The method that I used - all data reception, parsing and data stuffing from memory is done completely in the hardware implemented in the FPGA.  The advantage of this method is that the software on the board is completely unaware of the existence of a hardware downloader.  When the hardware loader notices the data coming from the PC, it sets the processor to reset, receives and places all the data in memory, removes the processor from the reset, after which the processor starts reading and executing the reset exception handler code. <br><br>  3.3.1.  In the process of discussing the task with other users and developers, MIPSfpga also expressed the idea of ‚Äã‚Äãmaking a full-fledged DMA port for recording data from a PC into memory at the same time as the processor works with the memory (and not when the processor is reset), but it was rejected as too complicated and by and large meaningless for the types of tasks in which it was supposed to use MIPSfpga during seminars in Russia. <br><br><h3>  4. How is the connection to the PC? </h3><br><br>  The serial port is a very old invention.  <a href="http://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">UART</a> / <a href="http://en.wikipedia.org/wiki/RS-232">RS-232C</a> appeared in the late 1960s.  All PCs in the 1980s were with COM ports that could be written as to a file.  You will not believe it, but it has survived MS-DOS and has remained in Windows so far.  Yes, yes, in order to transfer a file from a PC to an external serial port, you can now write ‚Äútype COM <i>file-name</i> COM <i>-port number</i> ‚Äù on the command line: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/946/5d7/3cd/9465d73cd646fa12763d00488fffe91c.png"></a> <br><br>  In Linux, there is also such a connection (although I have not tried MIPSfpga connected to Linux yet, but it was tried by a friend in Italy who sent me an email about it).  The Linux user who copies the data to the file corresponding to the COM port should belong to the <i>dialup</i> group: <br><br><pre> stty -F / dev / ttyUSB0 raw 115200
 cat srec program.rec&gt; / dev / ttyUSB0
</pre><br><br>  At the same time, the ancient RS-232C ports in modern PCs are not installed, instead they make a ‚Äúvirtual COM port‚Äù via USB, using <a href="http://nazya.com/freeshipping/product/elektronnie-komponenti-arduino-55v-33v-ft232rl-ftdi-usbttl-3321_32264320671.html">this</a> <a href="http://www.ftdichip.com/Products/ICs/FT232R.htm">FTD32RL</a> chip <a href="http://www.ftdichip.com/Products/ICs/FT232R.htm">adapter</a> from the <a href="http://en.wikipedia.org/wiki/FTDI">FTDI</a> company (Attention! This chip has <a href="http://habrahabr.ru/company/zeptobars/blog/212859/">many buggy fakes</a> ) I also pay attention that for working with FPGA the 3.3 / 5V switch on the adapter should be set to 3.3V, otherwise theoretically it is possible to damage the pins / pins of the FPGA, which are usually softer than, for example, microcontrollers: <br><br> <a href="" rel="attachment wp-att-752"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/b54/e3d/a1fb54e3dffb936a43518ebe740f0ae7.jpg" alt="IMG_1423"></a> <br><br>  In addition to the adapter shown in the photo above, you can use a cable called <a href="http://www.aliexpress.com/wholesale%3FcatId%3D0%26initiative_id%3DSB_20151231182357%26SearchText%3DPL2303TA%2Bcable">PL2303TA USB TTL to RS232 Converter XP / VISTA / 7/8 / 8.1</a> for connecting the PC and UART to the FPGA.  This cable is useful for small Terasic DE0-Nano boards with male GPIO pins.  On sites like AliExpress, a cheaper cable based on the <a href="http://www.aliexpress.com/wholesale%3FcatId%3D0%26initiative_id%3DSB_20151231182718%26SearchText%3DPL2303HX">PL2303HX</a> chip is also being sold, but this chip had some compatibility issues with Windows 8.x, so it's better to use a cable based on the PL2303TA (UPD: I changed the latest version of MIPSfpga + the used pins for the DE0-Nano board, so this snapshot needs to be replaced, the connection in it is not true): <br><br> <a href="" rel="attachment wp-att-182"><img src="https://habrastorage.org/getpro/habr/post_images/25b/0c8/2cf/25b0c82cf8b7ee2eba8e544fa59936bd.jpg" alt="IMG_0099"></a> <br><br><h3>  5. Where did the data from the PC need to be uploaded? </h3><br><br>  Before I inserted the modules of the downloadable program from the PC into the memory of the synthesized system MIPSfpga + (as I called my version MIPSfpga), its modular hierarchy looked like this: <br><br> <a href="http://silicon-russia.com/pages/2015_12_28/hierarchy_de0_cv__narrow_write_support__light_sensor.html"><img src="https://habrastorage.org/getpro/habr/post_images/ef7/039/9b9/ef70399b95006db1f1d1a2a76b483149.png"></a> <br><br>  What is in each module: <br><br><ul><li>  <a href="">de0_cv</a> is an external module specific to each type of FPGA board.  The findings of this module correspond to the physical findings on the chip itself.  The specific module <i>de0_cv is</i> written for the Terasic DE0-CV board with FPGA Altera Cyclone V </li><li>  <a href="">mfp_single_digit_seven_segment_display</a> <i>display_0, display_1, ...</i> - seven-segment indicator drivers for Alter cards (one per digit) </li><li>  <a href="">mfp_system</a> - system module, the same for all FPGA boards <br><ul><li>  <a href="http://www.silicon-russia.com/2015/12/11/mipsfpga-download-instructions">m14k_top</a> is the upper module of the microprocessor core <a href="http://imgtec.com/mips/aptiv/microaptiv/">MIPS microAptiv UP (also called MIPS microAptiv MPU)</a> , the name <i>m14k</i> remains from the previous processor version - MIPS M14Kc </li><li>  <a href="">mfp_ejtag_reset</a> - auxiliary module for resetting the <a href="http://www.linux-mips.org/wiki/JTAG">EJTAG</a> debugging interface </li><li>  <a href="">mfp_ahb_lite_matrix</a> is a module that combines memory blocks, a circuit implementation of <a href="http://www.eecs.umich.edu/courses/eecs373/readings/ARM_IHI0033A_AMBA_AHB-Lite_SPEC.pdf">AHB-Lite</a> bus logic, and I / O logic.  The latter links the addresses on the bus coming from the software with the signals of the hardware I / O devices ‚Äî buttons, LED indicators, etc. <br><ul><li>  <a href="">mfp_ahb_lite_decoder</a> - the module that decodes the address on the AHB-Lite bus and determines which of the slaves (memory blocks or the I / O logic module) should process the transaction on the bus </li><li>  <a href="">mfp_ahb_ram_slave</a> <i>reset_ram</i> is a memory block shell that implements the AHB-Lite bus slave protocol.  This group of blocks ( <i>reset_ram</i> ) is intended for the part of the program that starts immediately after the processor <i>leaves the</i> reset state. <br><ul><li>  <a href="">mfp_dual_port_ram</a> <i>i0-i3</i> - modules, the code on the chain in which the synthesizer recognizes as an indication to create a block memory inside the FPGA.  In order for the synthesizer to correctly perceive this code, it must be written in a <a href="http://quartushelp.altera.com/14.1/mergedProjects/hdl/vlog/vlog_pro_ram_inferred.htm">certain way</a> .  Four blocks with 8-bit memory width (instead of 1 block of 32-bits width) so that you can record one byte from the 4-byte AHB-Lite bus (the synthesizer does not understand the masked memory) </li></ul></li><li>  <a href="">mfp_ahb_ram_slave</a> <i>ram</i> is another shell of memory blocks that implements the protocol of the AHB-Lite bus slave.  This group of blocks ( <i>ram</i> ) is intended for the main part of the program that runs on cached memory. <br><ul><li>  <a href="">mfp_dual_port_ram</a> <i>i0-i3</i> - see the same four blocks above </li></ul></li><li>  <a href="">mfp_ahb_gpio_slave</a> - module of the slave device for general purpose input-output (GPIO - General Purpose Input / Output).  Displays the addresses on the bus, coming from the software to the signals of the hardware input-output devices - buttons, LED-indicators, etc. </li><li>  <a href="">mfp_ahb_lite_response_mux</a> - auxiliary module for AHB-Lite bus operation - multiplexer to send read data from the correct memory block or I / O module to the master device (microprocessor core) </li></ul></li><li>  <a href="">mfp_pmod_als_spi_receiver</a> is a module that implements a variant of the SPI protocol for the <a href="http://store.digilentinc.com/pmodals-ambient-light-sensor/">Digilent PmodALS light sensor</a> , one of the examples of devices connected to the MIPSfpga + system.  In this post, this module is not discussed, I may write a separate post about the integration of the light sensor with MIPSfpga + </li></ul></li></ul><br><br><h3>  6. How did the system hierarchy change when I inserted a hardware loader into it? </h3><br><br> <a href="http://silicon-russia.com/pages/2015_12_28/hierarchy_de0_cv__narrow_write_support__light_sensor__serial_loader.html"><img src="https://habrastorage.org/getpro/habr/post_images/1ba/42a/3ed/1ba42a3ed8eae155138c23e20db5f17f.png"></a> <br><br>  Four new modules: <br><br><ul><li>  <a href="">mfp_ahb_lite_matrix_with_loader</a> - is put in place of the <a href="">mfp_ahb_lite_matrix</a> module from the previous hierarchy.  <a href="">mfp_ahb_lite_matrix_with_loader</a> contains both the <a href="">mfp_ahb_lite_matrix</a> module and three modules with new functionality: <br><ul><li>  <a href="">mfp_uart_receiver</a> - receives data from PC via UART and turns it into a stream of bytes / alphanumeric characters </li><li>  <a href="">mfp_srec_parser</a> - parses the chain of bytes received from the <i>mfp_uart_receiver</i> module as text in the Motorola S-Record format and generates a sequence of translations (address / data) to fill the memory of the synthesized system with the data specified in the text </li><li>  <a href="">mfp_srec_parser_to_ahb_lite_bridge</a> - converts transactions received from the <i>mfp_srec_parser</i> module into transactions that comply with the AHB-Lite bus protocol.  It also turns the virtual addresses that the software uses into physical addresses that the hardware uses, using a simple fixed mapping. </li></ul><br></li></ul><br><br>  Below is the scheme at the hierarchy level of the <i>mfp_ahb_lite_matrix_with_loader</i> module, obtained after compiling the code on the verification, but before complete synthesis (optimization, mapping to FPGA-specific elements, placement and tracing).  Pay attention to the multiplexer between <i>mfp_srec_parser_to_ahb_lite_bridge</i> and <i>mfp_ahb_lite_matrix</i> , it sends to the memory and I / O subsystem transactions from the microprocessor core, or transactions from the hardware loader: <br><br> <a href="" rel="attachment wp-att-861"><img src="https://habrastorage.org/getpro/habr/post_images/84b/81d/8db/84b81d8db08d3167574fb03f141ce41e.png" alt="mfp_ahb_lite_matrix_with_loader"></a> <br><br><h3>  7. A few words about the serial port, UART </h3><br><br>  The UART topic has been discussed on Habr√© many times, including <a href="http://habrahabr.ru/post/278005/">quite recently</a> , so I will not dwell on it in detail.  My receiver implementation uses the simplest version of <a href="http://reference.digilentinc.com/pmod:communication_protocols:uart">the UART protocol</a> , without control signals, with one leading bit, without parity checks, with a fixed transmission rate and for a fixed clock / clock frequency.  The <i>mfp_uart_receiver</i> module receives data from the RX signal sequentially and outputs an 8-bit byte in parallel when it is ready.  The module contains a finite state machine, which waits for a negative edge of the RX signal (thus determining the initial bit), and then reads the data bits at the correct times, which are determined by counting clock cycles using a counter.  Since the number of clock cycles per bit is rather large, 50,000,000 Hz / 115,200 baud = 434 clock cycles (or 217 clock cycles for 25 MHz), data reception is fairly reliable.  Here is the module interface: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/939/aa7/c72/939aa7c72b4e3b4a13ff05db60381f43.png"><br><br>  The full code of the module is <a href="">http://github.com/MIPSfpga/mipsfpga-plus/blob/master/mfp_uart_receiver.v</a> . <br><br>  Scheme of the <i>mfp_uart_receiver</i> module after initial compilation: <br><br> <a href="" rel="attachment wp-att-865"><img src="https://habrastorage.org/getpro/habr/post_images/d4d/f0b/efe/d4df0befe22172dd63dffdc57c65ff82.png" alt="mfp_uart_receiver"></a> <br><br><h3>  8. And finally, the promised: parser text in the format of Motorola S-Record naked hardware, without a processor and without software </h3><br><br>  The <i>mfp_srec_parser</i> module receives the bytes from the <i>mfp_uart_receiver</i> module and parses them as text in a <i>Motorola S-record</i> format using a state machine.  During parsing, the formation of transactions to the memory of the synthesized system MIPSfpga + also takes place;  these transactions fill the memory with the bytes specified from the parsed text at the addresses specified in the text.  Module Interface: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df5/34c/fab/df534cfabce5a751a984c3608d2ee39c.png"><br><br>  We determine the identifiers of constants for the states of the finite state machine and the ASCII symbols used: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb8/811/e47/bb8811e4756fa99a6ef57e525606e4ec.png"><br><br>  Combination logic for converting the character constants '0', '1', ... '9', 'A', 'B', ... 'F' into four-bit numbers 0, 1, 2, ... 9, 10, 11, ... 15. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd5/e71/5a7/fd5e715a794255831599e635e31161b7.png"><br><br>  Variables for the state machine.  On the left - the new value created in the current cycle / cycle, on the right - the value recorded in the register / D-flip-flop / D-flip-flop, formed in the previous cycle.  I note that the synthesizer doesn‚Äôt always make a D-flip-flop / register from the verilog ‚Äúreg‚Äù in the hardware sense.  The key word ‚Äúreg‚Äù should be perceived only as a kind of variable that can be assigned to assignments inside the ‚Äúalways‚Äù -blocks: <br><br>  Assignments after defining variables are assignments to the module outputs of the generated addresses (which are previously written to the registers): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/113/8da/41e/1138da41e9bcd30a7be3c09f05336d33.png"><br><br>  The logic of a finite state machine consists of a combination part and a sequence part.  If you are not familiar with these concepts, you can read them in the free <a href="http://www.silicon-russia.com/2016/01/04/harris-harris-in-russian/">Harris &amp; Harris</a> tutorial. <br><br>  In the combinational part, we calculate the values ‚Äã‚Äãfor the next state, and the word ‚Äústate‚Äù means not only the group of D-flip-flops, into which the <i>reg_state</i> variable <i>turns</i> , but generally all D-flip-flops / D-flip-flop / hardware registers in the scheme (all three terms in the context of this post are interchangeable).  There are purists who say that this is a ‚Äúfinite automaton,‚Äù and a ‚Äúfinite automaton with data,‚Äù but we will leave these scholastics and their devils on the tip of the needle alone. <br><br>  Here is the beginning of the combination part.  In order not to follow the appearance of latches (D-latch) that are undesirable in the synchronous design methodology, we will assign a default value to all calculated variables at the very beginning of the always-combinational block: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/350/b79/7d2/350b797d2850358ee591040884ee53ca.png"><br><br>  Any changes occur only when we receive a new letter from the UART receiver (‚Äúif (char_ready)‚Äù).  In our finite state machine, we first wait for the appearance of the letter 'S', after which we parse the record type (we are interested in the type '3') and the address at which we will write the next bytes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c18/668/cf1/c18668cf11bf5ffafee284f7b2f01255.png"><br><br>  Now we begin to parse the data and at the same time generate the address / data transaction to the output from the module: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9be/832/7e3/9be8327e3bc13cf082f08deb8b97558f.png"><br><br>  On the positive front of the clock signal generator, write the previously calculated values ‚Äã‚Äãto the registers that do not require a reset: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bbd/587/3b3/bbd5873b32df349d967059c4e11416c0.png"><br><br>  And now we make an entry in the registers that require a reset ‚Äî either to start the operation of the state machine with an unambiguous state, or registers that define control signals at the output of the module: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e86/0f6/2b9/e860f62b985d41c1087cac32b89f1bef.png"><br><br>  The <i>in_progress</i> signal (‚Äúin progress‚Äù) has been enabled since the recognition of the first entry with the address (type <i>S3</i> ) and turned off when the module recognizes the last entry in the file (type <i>S7</i> ).  This signal can be output to an external indicator on the board, it is also used for the multiplexer in <a href="">mfp_ahb_lite_matrix_with_loader</a> and determines whether the microprocessor core or the hardware loader writes to memory.  In addition, <i>in_progress is</i> used to reset the microprocessor core, so that it is "cut down" while the hardware loader writes to memory.  When the software is stored in memory, the microprocessor ‚Äúwakes up‚Äù and starts reading instructions (from the fixed physical address 1FC0_0000). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/694/932/93c/69493293ceedb5f045590d682c77ee03.png"><br><br>  Logic for detecting errors in the input text.  It works in parallel with the main state machine and uses its states: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c6/c2a/f90/8c6c2af904dad1dd4974aa0023b4f490.png"><br><br>  Logic for calculating checksums and comparing them with checksums from S-Record text.  It works in parallel with the main state machine and uses its states: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e8/b88/abc/5e8b88abc1d9e0e36af2adde93f06fec.png"><br><br>  Generate error signal.  The hardware parser even tells the user which line the error occurred on: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/176/eb6/567/176eb65679b8549b7c5576cad7c23dac.png"><br><br>  The full code of the module is <a href="">http://github.com/MIPSfpga/mipsfpga-plus/blob/master/mfp_srec_parser.v</a> <br><br><h3>  9. A few words about the bridge to the bus AHB-Lite </h3><br><br>  The <i>mfp_srec_parser_to_ahb_lite_bridge</i> module turns address / data translations obtained from the <i>mfp_srec_parser</i> module into a transaction for the AHB-Lite bus that MIPSfpga uses. <br><br>  The module also edits addresses - turns the virtual addresses that the software uses into physical addresses that the hardware uses.  Although the MIPS microAptiv UP processor has a MMU TLB that allows flexible and complex mapping of virtual addresses to physical ones, but in my examples of using MIPSfpga, the conversion is simple and fixed - simply zeroing the three upper bits of the address.  If you are interested in the work of the virtual memory management device in MIPSfpga, you can watch the presentation in Russian <a href="http://silicon-russia.com/public_materials/2015_11_14_mipsfpga_related_presentations/tlb_mmu_in_mips_microaptiv_up_2015_10_25.pdf">‚ÄúMemory management device in MIPS processors‚Äù</a> . <br><br>  Bridge code <i>mfp_srec_parser_to_ahb_lite_bridge</i> : <br><br>  <a href="">http://github.com/MIPSfpga/mipsfpga-plus/blob/master/mfp_srec_parser_to_ahb_lite_bridge.v</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68e/1a3/a5d/68e1a3a5d506bfee39e1dc87c8332be0.png"><br><br>  Scheme of the <i>mfp_srec_parser_to_ahb_lite_bridge</i> module after the initial compilation: <br><br> <a href="" rel="attachment wp-att-864"><img src="https://habrastorage.org/getpro/habr/post_images/962/cef/610/962cef610e24e48776200a5e676e4d60.png" alt="mfp_srec_parser_to_ahb_lite_bridge"></a> <br><br>  And finally, about the AHB-Lite bus itself, which is used to connect devices in systems on a chip. <br><br>  Below is an excerpt from the documentation from Imagination Technologies, which can be downloaded <a href="http://www.silicon-russia.com/2015/12/11/mipsfpga-download-instructions/">using the following instructions</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/32e/e9f/8da/32ee9f8da601685a717ba146edfb8587.png"><br><br>  In particular, you can see why data transfer has to be delayed by one cycle in relation to the transmission of an address.  In the AHB-Lite protocol, the new transaction address is laid out on the bus simultaneously with the data from the previous transaction: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/21f/3b0/080/21f3b0080771d5c6ccb621fe868bc7f9.png"><br><br>  Diagram of the <i>mfp_ahb_lite_matrix</i> module after the initial compilation.  This module contains three slave modules ‚Äî two memory blocks and a module that displays the software‚Äôs memory access to general-purpose I / O ‚Äî GPIO (General Purpose IO): <br><br> <a href="" rel="attachment wp-att-862"><img src="https://habrastorage.org/getpro/habr/post_images/9f3/3ec/873/9f33ec8736a2de74969a1dc610a07e87.png" alt="mfp_ahb_lite_matrix"></a> <br><br><h3>  10. And now what?  Proceedings, additions and suggestions </h3><br><br>  In this post, I described only one aspect of the MIPSfpga project and its improvement, MIPSfpga +, which I did not have to worry about the problems of Bus Blaster / Open OCD during my trip to Russia at the end of last year.  Note that if you want to use a GDB-based debugger with MIPSfpga, then you will still have to use Bus Blaster or another debugging adapter that supports EJTAG. <br><br>  But the MIPSfpga theme is much more.  After all, the package contains an industrial processor, which is used in new products from Samsung, Microchip and other companies - and you, dear readers, can experiment with its structure, using the same code that is used by the engineers in these companies.  You can write your own cache module with a different row push policy, develop multi-core systems, attach various peripherals to MIPSfpga.  If you are interested in making a project with MIPSfpga and you are working at some provincial university, which is difficult to get the budget for purchasing FPGA boards, you can get one board for free, though there are few of them left - see <a href="http://www.silicon-russia.com/2015/12/11/board-giveaway-for-mipsfpga/">‚ÄúDistribution of elephants: FPGA boards for educational projects with MIPSfpga</a> . <a href="http://www.silicon-russia.com/2015/12/11/board-giveaway-for-mipsfpga/">"</a> <br><br>  Also on Habr√©, there was already a note about how to tie a coprocessor to the MIPSfpga - see <a href="https://habrahabr.ru/post/276205/">https://habrahabr.ru/post/276205/</a> . </div><p>Source: <a href="https://habr.com/ru/post/278681/">https://habr.com/ru/post/278681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278671/index.html">HTML and CSS in Oracle Application Express. Part 1</a></li>
<li><a href="../278673/index.html">Long story about date localization without a year in PHP</a></li>
<li><a href="../278675/index.html">The legend of the silver pool, or how I looked for logical caching and retrieval errors</a></li>
<li><a href="../278677/index.html">AudioCodes Routers</a></li>
<li><a href="../278679/index.html">Own "Who called?" On the basis of Multifon</a></li>
<li><a href="../278683/index.html">iTrace. How are the letters written?</a></li>
<li><a href="../278685/index.html">Overview of synchronization primitives - spinlock and secrets of the processor core</a></li>
<li><a href="../278689/index.html">iBeacon. Myths and Reality</a></li>
<li><a href="../278691/index.html">PowerShell Remoting - setup and remote management</a></li>
<li><a href="../278693/index.html">turn string into scriptblock</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>