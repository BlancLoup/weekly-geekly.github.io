<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fragmented video stream compression method</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I decided to present my development to the court of the respected community - the method of fragmentary compression of the video stream. A feature of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fragmented video stream compression method</h1><div class="post__text post__text-html js-mediator-article">  I decided to present my development to the court of the respected community - the method of fragmentary compression of the video stream.  A feature of the proposed method is the full compliance of the compressed video stream with the original, that is, the method performs lossless compression. <br><a name="habracut"></a><br><h1>  Terminology used </h1><br>  Before describing the method itself, it is necessary to agree on the terminology used.  All terms used are intuitive, but nevertheless, it is worth defining them strictly: <br><ul><li>  Pixel is the minimum image unit.  The numerical value of a pixel expresses the value of the image brightness function at one point on the screen.  The number of bits allocated for coding the brightness is called the color depth and is referred to as bpp; </li><li>  Frame - a set of all pixels at a specific point in time.  A frame is represented as a two-dimensional array of pixels with a height of N <sub>1</sub> and a width of N <sub>2</sub> pixels. </li><li>  Video stream (movie) - a sequence of frames ordered by time.  The total number of frames in the film is hereinafter referred to as M. </li><li>  The window is a rectangular area of ‚Äã‚Äãpixels of height n <sub>1</sub> and width n <sub>2</sub> . </li><li>  A fragment is a part of the frame bounded by a window. </li><li>  The logical difference is the result of applying the modulo 2 addition (exclusive OR) operation to two digital representations of the corresponding fragments in adjacent frames. </li><li>  The arithmetic difference is the result of the arithmetic subtraction of the digital representations of the corresponding fragments in adjacent frames. </li><li>  Element - as an element, depending on the characteristics of the task, there is either a fragment or various kinds of differences.  The digital representation of the element is a bit string of length k.  In the case of fragments or logical differences, k = n <sub>1</sub> * n <sub>2</sub> * bpp, and in the case of arithmetic differences, k = n <sub>1</sub> * n <sub>2</sub> * bpp + n <sub>1</sub> * n <sub>2</sub> , since an additional sign bit is required for each window pixel. </li><li>  The volume of the film (N <sub>f</sub> ) - the total number of elements in the film.  N <sub>f</sub> = (N <sub>1</sub> * N <sub>2</sub> * M) / (n <sub>1</sub> * n <sub>2</sub> ) </li><li>  The frequency of the element - the ratio of the number of occurrences of this element in the film to the volume of the film. </li><li>  Base elements - a set of all elements present in the video stream and their frequencies.  The power of the base elements is denoted by N <sub>b</sub> . </li><li>  Element code is a binary code that uniquely identifies an element in the database. </li></ul><br><h1>  The main idea of ‚Äã‚Äãthe fragmentary compression method </h1><br>  The main idea of ‚Äã‚Äãthe fragmentary compression method is to represent a video stream in the form of a chain of elements of length N <sub>f</sub> from the base of elements.  Since the video stream is a set of meaningful images (frames), rather slowly varying in time, one should expect a significant correlation both between adjacent elements of one frame and between corresponding elements on neighboring frames.  This should lead to two effects: <br><ul><li>  Relatively low base power (N <sub>b</sub> ) relative to the power of the set of all possible fragment values ‚Äã‚Äã(2 <sup>k <sub>f</sub></sup> ) even with a sufficiently large movie volume; </li><li>  Significant irregularity of the frequency of occurrences of various elements from the base elements in the film.  This should allow the use of efficient entropy coding-compression algorithms for a chain of elements in a video stream. </li></ul><br>  Thus, the main idea of ‚Äã‚Äãthe fragmentary compression method is to represent the video stream as a well-compressible sequence of elements from some specially compiled element base.  The experiments conducted by the authors confirm this hypothesis. <br>  The concept of the method allows the video stream to be compressed both lossless and lossy.  In the case of lossy compression, both preprocessing (filtering) is possible, smoothing the original image, and post-processing, consisting in analyzing the element base and then isolating and removing both random noise and visually redundant information from the video stream.  Sharing pre-and post-processing allows you to create a new compressed video stream with the desired properties. <br>  The method of fragmented compression can be represented as a sequence of four steps: <br><ul><li>  The formation of the base elements.  In the case of lossy compression, pre-filtering of video stream frames is possible; </li><li>  Analysis of the obtained base of elements and its frequency characteristics; </li><li>  Construction of short codes for the elements of the base; </li><li>  Formation of the compressed film transmission scheme. </li></ul><br>  These steps are discussed in more detail below. <br><h2>  The formation of the base elements </h2><br>  The process of forming the base of elements is one of the most resource-intensive steps of the fragmentary compression method.  The final compression rate depends largely on how effectively this stage is performed. <br>  Due to the extremely high requirements for speed, the algorithm for forming the base of elements is performed in several stages, with different algorithms and data structures being used at each step. <br>  The formation of the base elements of the frame - the first and easiest step.  At this stage, the next frame is received from the video stream, pre-processed if necessary, and, depending on the type of element, the corresponding ‚Äúpseudo frame‚Äù is formed. <br><img src="https://habrastorage.org/files/705/604/3df/7056043dfccf4b28aaf63616041418a0.PNG"><br>  When viewing a pseudo frame, the window shifts n <sub>2</sub> pixels in width and n <sub>1</sub> pixels in height.  The figure shows an example of a frame of N <sub>1</sub> = 30 rows on N <sub>2</sub> = 45 columns, the viewing is performed using the square window n <sub>1</sub> = n <sub>2</sub> = 5.  The thin lines in the figure show individual pixels, the thick lines show the borders of the window, and the numbers inside the window show the sequence number when viewed. <br>  If the elements are logical or arithmetic differences, then the scan will result in the following set of differences: <br><img src="https://habrastorage.org/files/4ab/174/894/4ab1748949ca4d878f958f6474ecd109.PNG"><br>  For most real-life movies, the assumption is that there is a significant correlation between the corresponding elements in the neighboring frames.  This is also seen in the table: most of the elements correspond to zero differences.  To save memory, the resulting base elements of the frame is compacted.  First, sorting is performed by some efficient algorithm, and then the matching elements are combined into one record.  That is, instead of 48 zero differences in the compacted base there will be only one record. <br><img src="https://habrastorage.org/files/208/187/6ef/2081876ef3034115833cf2c281de883a.PNG"><br>  At the second stage, the compacted base elements of the frame are recorded in a special buffer of elements - a separate memory area where a plurality of frame bases are accumulated, and then one large block is written to the global storage.  The peculiarity of the buffer is that any element can have random access by index, i.e.  in fact, it‚Äôs just a large array of elements located in RAM: <br>  It is also worth noting that the base elements of the frame are recorded in the buffer "as is" without any additional re-sorting.  This leads to the fact that the buffer contains a lot of ordered sequences of elements, but it is not ordered: <br><img src="https://habrastorage.org/files/d93/78b/41e/d9378b41e3174d6cbfaba930ecd6abc1.PNG"><br>  When there is not enough space to record the next frame base, the procedure for updating the list of actually encountered items is called. <br>  At the third stage, the elements accumulated in the buffer are moved to a special global storage, which is a simply connected list of elements, ordered by their values.  The representation of the global storage in the form of a list does not allow performing random access in constant time, but it does allow adding and deleting elements in constant time. <br>  Before adding the items from the buffer to the global storage, the procedure of sorting and compacting the buffer already discussed earlier is performed.  This allows you to add items in a linear time relative to the size of the list: <br><img src="https://habrastorage.org/files/cf4/0eb/f97/cf40ebf970dc4896981cc74a661f0a02.PNG"><br>  Three considered stages operate with data placed in the RAM.  The final stage involves working with data placed on hard drives.  In the overwhelming majority of cases, a sufficiently powerful modern computer allows you to fully assemble the base of elements in RAM, but there are situations when there is not enough RAM to place the entire base there (for example, if a common base is formed for hundreds of hours of shooting).  In this case, it is necessary to save the received bases to disk as the RAM is exhausted, and then perform the procedure of merging the databases. <br>  Thus in the process of forming the base of elements the following sequence of steps is performed: <br><img src="https://habrastorage.org/files/7a8/67f/360/7a867f3606b4489a8237fba341149e2c.PNG"><br><h2>  Analysis of the obtained base of elements and its frequency characteristics </h2><br>  Analysis of the base of the elements involves the analysis of both the individual values ‚Äã‚Äãof each element and the frequency characteristics of the base.  This allows, firstly, to choose effective combinations of compression methods (building short codes and methods of their transmission), and, secondly, in the case of lossy compression, consciously reduce the base (filtering). <br><h2>  Construction of short codes for base elements </h2><br>  The base of elements includes an array of N <sub>b</sub> lines of length k bits and a table of frequencies of the appearance of these lines in a video stream (film).  This information is sufficient for applying well-known entropy coding methods (Huffman tree, arithmetic coding, etc.).  The listed algorithms have very high efficiency scores, but their actual use is associated with significant implementation difficulties. <br>  For the construction of short codes of elements, the authors propose and use the method of constructing prefix codes proposed by them earlier with the help of cutting functions.  In this method, the short codes of the elements of the base are based on the content of the rows of the elements themselves.  The author proved that the average length of such codes does not exceed the value of H <sub>b</sub> * 1,049, where H <sub>b</sub> is the entropy of the base of elements, calculated from the frequency of occurrence of elements in the video stream.  In numerical experiments with real films, H <sub>b</sub> never exceeded 20, which means that H <sub>b</sub> * 1,049 &lt;H <sub>b</sub> +1, from which it follows that the average length of secant codes fits into the same prior estimates of redundancy that Shannon-Fano and Huffman  At the same time, encoding with the help of secant functions is devoid of the disadvantages that arise when encoding and decoding the above-mentioned methods of large digital arrays (N <sub>b</sub> ‚âà 10 <sup>7</sup> -10 <sup>9</sup> ). <br><h2>  Formation of the compressed film transmission scheme </h2><br>  In a compressed video stream, the elements are replaced with the previously received short codes.  When playing a compressed video stream, a decoding problem arises.  For decoding, it is necessary to have information on the compliance of short codes and base elements.  The simplest way to transfer such information is the direct transfer of the element and its frequency (number of occurrences).  This method involves the transfer of the base itself, as well as an additional 64 bits for each element.  After receiving the data, the receiving party itself must build a code tree using a previously reported algorithm. <br>  A method was proposed for recording and transmitting a tree, in whose leaves the entire base of elements is recorded.  The volume of the transmission is equal to the base volume plus two additional bits for each base element ((k + 2) * N <sub>b</sub> ). <br>  We agree on the tree traversal order: for example, we will use a wide traversal.  If a dividing tree node is encountered, then bit 0 is transmitted, if a leaf was detected during the traversal, then bit 1 and the corresponding base element are transmitted.  As a result, it is easy to show that only 2 extra bits are additionally transmitted to each base element.  The figure shows the representation of a binary tree as a binary string using the described method: <br><img src="https://habrastorage.org/files/f55/2d4/10a/f552d410a1614081857933d0c5cc7bfc.PNG"><br>  The specified representation is reversible: for each line constructed by the described method, it is possible to build an initial code tree.  In addition to the obvious memory savings, the described transmission method eliminates the need to build a code tree during decoding (it is restored in a natural way).  That is, a code tree is built only once during compression. <br>  Thus, the paper proposes a scheme for transmitting a video stream consisting of two parts: a code tree with base elements and a chain of compressed element codes. <br>  The approximate structure of the compressed video stream is shown in the figure: <br><img src="https://habrastorage.org/files/80a/61c/412/80a61c412e204a118c2550ee4b442e5b.PNG"><br><h1>  Selection of algorithm parameters </h1><br>  The degree of compression provided by the fragmented compression algorithm largely depends on the properties and characteristics of the formed base of elements.  The main characteristics of the base are the size (number of elements) and frequency characteristics (primarily entropy). <br>  To estimate the achievable compression ratio, we use the following formulas.  Let l <sub>cf</sub> - the average length of the codes of the elements of the base, then the volume of the compressed transmission is V s = N <sub>b</sub> (k + 2) + l <sub>cf</sub> * N <sub>f</sub> , and the volume of the uncompressed film is equal to V <sub>f</sub> = N <sub>f</sub> * k. <br>  The compression ratio is the value: <br>  R <sub>SG</sub> = V <sub>SG</sub> / V <sub>f</sub> .  The inverse of the compression ratio is called the compression ratio and is denoted by K <sub>contra</sub> . <br>  The main goal to strive for is maximization of K <sub>szh</sub> .  In the formula above, N <sub>1</sub> , N <sub>2</sub> , M, bpp are the characteristics of the original video stream, which we cannot influence.  And the values ‚Äã‚Äãof l <sub>cf</sub> , N <sub>bases</sub> depend on the area and configuration of the scan window (n <sub>1</sub> , n <sub>2</sub> ).  Those.  The only variable parameters in the fragmented compression method are the geometric dimensions of the window. <br>  For any window size, there is a maximum possible base volume of 2 <sup>bpp * n <sub>1</sub> * n <sub>2</sub></sup> , and this value is growing extremely fast.  Of course, in real films there are far from all possible elements, but with an increase in the window size, the number of bits needed to represent the corresponding base element also grows.  In addition, a significant number (more than 70% of the total) of elements appears that occur in the video stream no more than once.  In the end, all these effects lead to a decrease in the compression ratio. <br>  On the other hand, too small a window size will lead to an increase in N <sub>f</sub> and a restriction on N <sub>b</sub> , which in turn will cause the elements to repeat more evenly and the ‚Äútilting‚Äù of frequencies will smooth out.  The more evenly the elements of the base are repeated, the closer its entropy is to log <sub>2</sub> N <sub>b</sub> .  This, in turn, also leads to a decrease in the compression ratio. <br>  Consider the two extreme cases window 1 * 1 and window N <sub>1</sub> * N <sub>2</sub> .  And in the first and in the second case, K <sub>szh</sub> ‚âà1.  In the process of research, it was found that the dependence of K <sub>cr</sub> on the scan window area (n <sub>1</sub> * n <sub>2</sub> ) has approximately the following form: <br><img src="https://habrastorage.org/files/4e5/3ec/202/4e53ec2029ff4a7db07be1bbff7478e6.PNG"><br>  The task is to find the point where the compression level is maximum.  Since  the level of compression largely depends on the characteristics of the film; it is clear that there is no ‚Äúideal‚Äù configuration that will give the optimum compression for all films.  But the experiments allowed to find a relatively small area where compression is optimal. <br>  All analyzed video streams were divided into two groups depending on their features: <br><ul><li>  Natural shooting.  This group includes most movies, TV shows and amateur filming.  For films of this group is characterized by a smooth change of frames over time.  The changes are rather smooth and concentrated in the center of the frame.  The background is in most cases uniform, but slight variations in brightness are possible. </li></ul><br>  To select the optimal configuration of the window, the video streams belonging to each group were compressed using the fragmentary compression method.  During the research, all possible configurations of windows ranging from one to eight pixels were analyzed (logical differences were used as elements).  In total, about ten thousand hours of video were analyzed, which is about a billion frames.  The results are presented in graphs. <br><img src="https://habrastorage.org/files/0cb/75f/898/0cb75f8989204820b3f9d5fbc6279929.PNG"><br><img src="https://habrastorage.org/files/2d0/627/2f9/2d06272f95864a8eaa1c16aaf34d4b81.PNG"><br>  From the presented data it is obvious that the maximum compression ratio can be achieved using windows with an area of ‚Äã‚Äãthree, four or five pixels.  Also, in practical use of the method of fragmentary compression of a video stream, it is necessary to take into account that with a fixed window area the highest compression efficiency is observed when using a rectangular window with a ratio of the sides close to 2/1. <br><h2>  Video encoding in various color spaces </h2><br>  The results discussed earlier were related to the coding situation of a video stream containing only the luminance component (the so-called monochrome video stream).  Of greater practical interest are methods that allow encoding color video streams. <br>  The easiest way to encode a color video stream is to independently encode color channels.  The way in which the element bases collected for independent color channels were combined into one common base was also considered.  In spite of the fact that the base share in transmission decreased at the same time, the increase in compression efficiency was insignificant.  It was also shown that the efficiency of the fragmentary compression method in YIQ space is significantly higher than in the RGB space.  Primarily, this effect is associated with losses arising from the transformation of color spaces. <br><img src="https://habrastorage.org/files/b95/a3c/50c/b95a3c50c38a4c40a74a83d6d4c8d32c.PNG"><br><img src="https://habrastorage.org/files/af2/ae7/be1/af2ae7be1d034ea19ab543c11a0991e0.PNG"><br>  It is also worth noting that the compression efficiency in the YIQ space can be significantly improved due to coarse quantization of the color difference channels. <br><h1>  Comparison of the effectiveness of the fragmentary video compression method with the methods used </h1><br>  To date, there are methods to compress video streams without loss.  Some of them are highly specialized and effective only on one type of video streams (for example, on screen recordings), other methods are effective on different video streams.  This section is devoted to comparing the effectiveness of the proposed method of fragmentary compression of a video stream with known methods. <br>  In the Graphics &amp; Media Lab Video Group at Moscow State University.  Lomonosov was carried out an extensive comparison of lossless video compression algorithms for a variety of parameters (compression speed, resource consumption, compression efficiency, etc.).  The most important characteristic is compression efficiency.  By this criterion, the following codecs were analyzed: <br><ul><li>  Alpary </li><li>  Arithyuv </li><li>  AVIzlib </li><li>  CamStudio GZIP </li><li>  Corepng </li><li>  Fastcode </li><li>  FFV1 </li><li>  Huffyuv </li><li>  Lagarith </li><li>  LOCO </li><li>  Lzo </li><li>  MSU Lab </li><li>  PICVideo </li><li>  Snow </li><li>  x264 </li><li>  Yuls </li></ul><br>  The comparison was performed on standard test sequences.  Each video sequence was compressed by each codec independently.  The results are shown in the graph: <br><img src="https://habrastorage.org/files/b01/088/50d/b0108850df1d4f61ba14d651065b82fb.PNG"><br>  For convenience of analysis, the resulting values ‚Äã‚Äãof compression ratios were averaged, and the resulting average estimates are given below: <br><img src="https://habrastorage.org/files/b3e/362/9fa/b3e3629faeab4419ac6416845d52c140.PNG"><br>  Direct application of the fragmented compression method on these test video sequences is ineffective.  This is explained by the fact that the duration of the test video streams is very small and the essential element in the film compressed by the fragmentary compression method is the base of the elements: <br><img src="https://habrastorage.org/files/2a9/675/912/2a967591262340ef98a1bd7804e5e588.PNG"><br>  With a sufficient duration of the video stream (from 5,000 frames), the average compression ratio of the fragmented compression method is 3.38, which exceeds the compression ratios of the best methods considered. <br><br>  If the community is interested, I‚Äôll tell you about the secant tree, which made it possible to achieve such a very good result. </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/252445/">https://habr.com/ru/post/252445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252435/index.html">Configuring Amazon Elastic Load Balancing: with email forwarding and redirects</a></li>
<li><a href="../252437/index.html">Unexpected exception filter behavior in C # 6</a></li>
<li><a href="../252439/index.html">Auto registration of tests on C language tools</a></li>
<li><a href="../252441/index.html">Reconnect - Facebook Login Vulnerability</a></li>
<li><a href="../252443/index.html">Documentation in Doxygen</a></li>
<li><a href="../252447/index.html">Overview of the video on Go c FOSDEM 2015</a></li>
<li><a href="../252449/index.html">Freemium vs. Free: why we got rid of the free subscription</a></li>
<li><a href="../252451/index.html">Perl 6 command line interaction from MAIN function</a></li>
<li><a href="../252453/index.html">Making the code cleaner: Special vsnprintf () extensions in the Linux kernel</a></li>
<li><a href="../252455/index.html">Go and Protocol Buffers practice (or quick start, for those who are not familiar yet)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>