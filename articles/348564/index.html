<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write scalable and supported servers on Node.js and TypeScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For the last three years I have been developing servers on Node.js and in the process of working I have accumulated some code base, which I decided to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write scalable and supported servers on Node.js and TypeScript</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/b9/pv/hx/b9pvhxtraz-ekmkex3bbzi2yapm.png"></p><br><p>  For the last three years I have been developing servers on Node.js and in the process of working I have accumulated some code base, which I decided to take as a framework and put it in open-source. </p><br><p>  The main features of the framework include: </p><br><ul><li>  simple architecture without any js magic </li><li>  automatic serialization / deserialization of models (for example, it is not necessary to check whether the field came from the client, everything is checked automatically) </li><li>  ability to generate an API schema </li><li>  schema-based documentation generation </li><li>  generation of a fully typed SDK for the client (at the moment we are talking about the JS frontend) </li></ul><br><p>  In this article we will talk a little about Node.js and consider this framework. </p><br><p>  Anyone who cares - I ask under the cat </p><a name="habracut"></a><br><h2 id="v-chem-zhe-problema-i-zachem-pisat-ocherednoy-velosiped">  What is the problem and why write another bike? </h2><br><p>  The main problem with server development on Node.js is two things: </p><br><ul><li>  lack of a developed community and infrastructure </li><li>  reasonably low entry level </li></ul><br><p>  With the lack of infrastructure, everything is simple: Node.js is a rather young platform, so things that can be conveniently and quickly written on older platforms (for example, the same PHP or .NET) in Node.js cause difficulties. </p><br><p>  What about low entry level?  The main problem here is that with every turn of the hyip wheel and the arrival of new libraries / frameworks, everyone is trying to simplify.  It would seem easier - better, but because  these solutions are not always used by experienced developers as a result - there arises a cult of worshiping libraries and frameworks.  Probably the most obvious example is express. <br>  What is wrong with express?  Never mind!  No, of course you can find flaws in it, but express is a tool, a tool that needs to be able to use, problems start when express, or any other framework, plays a major role in your project when you are too tied to it. </p><br><p>  Based on the above, starting to develop a new project, I started by writing some "core" server, later it was transferred to other projects, finalized and, of course, became an Airship framework. </p><br><h2 id="osnovnaya-koncepciya">  Basic concept </h2><br><p>  Starting to think through the architecture, I asked myself the question: "What does the server do?".  At the highest level of abstraction, the server does three things: </p><br><ul><li>  receives requests </li><li>  processes requests </li><li>  gives answers </li></ul><br><p>  Still, why complicate your life?  I decided that the architecture should be something like the following: each request supported by our north has a model, request models are sent to request handlers, and handlers, in turn, give response models. <br>  It is important to note that our code does not know anything about the network, it only works with the instances of the usual classes of requests and responses.  This fact allows us not only to finish the more flexible architecture, but even to change the transport layer.  For example, we can switch from HTTP to TCP without changing our code.  Of course this is a very rare case, but this possibility shows us the flexibility of the architecture. </p><br><h2 id="modeli">  Models </h2><br><p>  Let's start with the models, what do you need from them?  First of all, we need a simple way to serialize and deserialize models, validation of types during deserialization still does not hinder, since  custom queries are also models. </p><br><p>  In the following description, I will omit some details that can be read in the documentation so as not to inflate the article. </p><br><p>  Here's how it works: </p><br><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@serializable()</span></span> readonly x: number <span class="hljs-meta"><span class="hljs-meta">@serializable()</span></span> readonly y: number <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x: number, y: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y } }</code> </pre> <br><p>  As you can see, the model is a normal class, the only difference is the use of the <code>serializable</code> decorator.  With the help of this decorator we specify the fields to the serializer. <br>  Now we can sarialize and deserialize our model: </p><br><pre> <code class="hljs pgsql">JSONSerializer.serialize(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">Point</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)) // { "x": <span class="hljs-number"><span class="hljs-number">1</span></span>, "y": <span class="hljs-number"><span class="hljs-number">2</span></span> } JSONSerializer.deserialize(<span class="hljs-type"><span class="hljs-type">Point</span></span>, { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }) // <span class="hljs-type"><span class="hljs-type">Point</span></span> { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre> <br><p>  If we pass data of the wrong type, the serializer will throw an exception: </p><br><pre> <code class="hljs pgsql">JSONSerializer.deserialize(<span class="hljs-type"><span class="hljs-type">Point</span></span>, { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: "2" }) // Error: y must be number <span class="hljs-keyword"><span class="hljs-keyword">instead</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> string</code> </pre> <br><h2 id="modeli-zaprosov">  Query models </h2><br><p>  Requests are the same models, the difference is that all requests are inherited from <code>ASRequest</code> and use the <code>@queryPath</code> decorator to specify the query path: </p><br><pre> <code class="hljs scala"><span class="hljs-meta"><span class="hljs-meta">@queryPath</span></span>('/getUser') <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GetUserRequest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ASRequest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@serializable</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> userId: number constructor( userId: number ) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userId = userId } }</code> </pre> <br><h2 id="modeli-otvetov">  Answer Models </h2><br><p>  Response models are also written as usual, but inherited from <code>ASResponse</code> : </p><br><pre> <code class="hljs scala"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GetUserResponse</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ASResponse</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@serializable</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> user: <span class="hljs-type"><span class="hljs-type">User</span></span> constructor(user: <span class="hljs-type"><span class="hljs-type">User</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user = user } }</code> </pre> <br><h2 id="obrabotchiki-zaprosov">  Request Handlers </h2><br><p>  Request handlers are inherited from <code>BaseRequestHandler</code> and implement two methods: </p><br><pre> <code class="hljs scala"> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GetUserHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseRequestHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//          public async handle(request: GetUserRequest): Promise&lt;GetUserResponse&gt; { return new GetUserResponse(new User(....)) } //        public supports(request: Request): boolean { return request instanceof GetUserRequest } }</span></span></code> </pre> <br><p>  Since  with this approach, it is not very convenient to implement processing of several requests in one handler - there is a descendant of <code>BaseRequestHandler</code> , which is called <code>MultiRequestHandler</code> and allows you to process several requests: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsersHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiRequestHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       @handles(GetUserRequest) //    GetUserRequest      public async handleGetUser(request: GetUserRequest): Promise&lt;ASResponse&gt; { } @handles(SaveUserRequest) public async handleSaveUser(request: SaveUserRequest): Promise&lt;ASResponse&gt; { } }</span></span></code> </pre> <br><h2 id="poluchenie-zaprosov">  Receive requests </h2><br><p>  There is a base class <code>RequestsProvider</code> , which describes the request provider to the system: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RequestsProvider</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRequests</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> callback: ( request: ASRequest, answerRequest: (response: ASResponse</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> }</code> </pre> <br><p>  The system calls the <code>getRequests</code> method, waits for requests, processes them, and sends the response to the <code>answerRequest</code> . </p><br><p>  <code>HttpRequestsProvider</code> implemented for receiving requests via HTTP, it works very simply: all requests come through POST, and data comes to json.  Using it is also easy, just pass the port and the list of supported requests: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpRequestsProvider( logger, <span class="hljs-number"><span class="hljs-number">7000</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   GetUserRequest, SaveUserRequest )</span></span></code> </pre> <br><h2 id="soedinyaem-vse-vmeste">  We connect all together </h2><br><p>  The main class of the server is <code>AirshipAPIServer</code> , to which we pass the request handler and the request provider.  Since  <code>AirshipAPIServer</code> accepts only one handler - the handler manager has been implemented, which accepts a list of handlers and calls the necessary one.  As a result, our server will look like this: </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleLogger() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">server</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AirshipAPIServer({ requestsProvider: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpRequestsProvider( logger, <span class="hljs-number"><span class="hljs-number">7000</span></span>, GetUserRequest, SaveUserRequest ), requestsHandler: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestHandlersManager([ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GetUserHandler(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SaveUserRequest() ]) }) <span class="hljs-built_in"><span class="hljs-built_in">server</span></span>.start()</code> </pre> <br><h2 id="generaciya-shemy-api">  API Schema Generation </h2><br><p>  The API scheme is such a special JSON that describes all the models, requests and responses of our server, it can be generated using the special utility <code>aschemegen</code> . </p><br><p>  First of all, you need to create a config that will indicate all our requests and answers: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {AirshipAPIServerConfig} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"airship-server"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config: ApiServerConfig = { <span class="hljs-attr"><span class="hljs-attr">endpoints</span></span>: [ [TestRequest, TestResponse], [GetUserRequest, GetUserResponse] ] } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> config</code> </pre> <br><p>  After that we can run the utility by specifying the path to the config and to the folder where the schema will be written: </p><br><pre> <code class="bash hljs">node_modules/.bin/aschemegen --o=/Users/altox/Desktop/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-server/scheme --c=/Users/altox/Desktop/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-server/build/config.js</code> </pre> <br><h2 id="generaciya-klientskogo-sdk">  Client SDK generation </h2><br><p>  Why do we need a circuit?  For example, we can generate a fully typed SDK for the frontend in TypeScript.  The SDK consists of four files: </p><br><ul><li>  API.ts - the main file with all methods and work with the network </li><li>  Models.ts - here are all the models </li><li>  Responses.ts - here are all the answer models </li><li>  MethodsProps.ts - here the interfaces describing the queries </li></ul><br><p>  Here is a piece of API.ts from the working draft: </p><br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-comment">/** * This is an automatically generated code (and probably compiled with TSC) * Generated at Sat Aug 19 2017 16:30:55 GMT+0300 (MSK) * Scheme version: 1 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> API_PATH = <span class="hljs-string"><span class="hljs-string">'/api/'</span></span> import * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Responses <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Responses'</span></span> import * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MethodsProps <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./MethodsProps'</span></span> export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AirshipApi</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">method: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Object, responseType?: Function</span></span></span><span class="hljs-function">): Promise&lt;any&gt;</span></span> {...} <span class="hljs-comment"><span class="hljs-comment">/** * * * @param {{ * appParams: (string), * groupId: (number), * name: (string), * description: (string), * startDate: (number), * endDate: (number), * type: (number), * postId: (number), * enableNotifications: (boolean), * notificationCustomMessage: (string), * prizes: (Prize[]) * }} params * * @returns {Promise&lt;SuccessResponse&gt;} */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addContest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params">: MethodsProps.AddContestParams</span></span></span><span class="hljs-function">): Promise&lt;Responses.SuccessResponse&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.call( <span class="hljs-string"><span class="hljs-string">'addContest'</span></span>, { appParams: <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.appParams, groupId: <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.groupId, name: <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.name, description: <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.description, startDate: <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.startDate, endDate: <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.endDate, type: <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.type, postId: <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.postId, enableNotifications: <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.enableNotifications, notificationCustomMessage: <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.notificationCustomMessage, prizes: <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.prizes ? <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.prizes.map((v: any) =&gt; v ? v.serialize() : undefined) : undefined }, Responses.SuccessResponse ) } ...</code> </pre> <br><p>  All this code is written automatically, it allows you not to be distracted by writing a client and get hints of field names and their types for free, if your IDE knows how. </p><br><p>  It is also easy to generate the SDK, you need to run the <code>asdkgen</code> utility and pass it the path to the schemas and the path where the SDK will be located: </p><br><pre> <code class="bash hljs">node_modules/.bin/asdkgen --s=/Users/altox/Desktop/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-server/scheme --o=/Users/altox/Desktop/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-server/sdk</code> </pre> <br><h2 id="generaciya-dokumentacii">  Documentation generation </h2><br><p>  I did not stop generating the SDK and wrote the documentation generation.  The documentation is quite simple, it is plain HTML with a description of requests, models, responses.  From the interesting: for each model there is a generated code for JS, TS and Swift: </p><br><p><img src="https://habrastorage.org/webt/0o/ib/g1/0oibg1xdxtzhrccfd7sc3nwkdzo.png"></p><br><p><img src="https://habrastorage.org/webt/h3/w2/6e/h3w26eypd23djq9zee2nc0h3wmu.png"></p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  This solution has been used in production for a long time, it helps to maintain the old code, write new code and not write code for the client. <br>  To many, both the article and the framework itself may seem very obvious, I understand that, others may say that there are already such solutions and even stick my nose at the link to such a project.  In my defense, I can only say two things: </p><br><ul><li>  I did not find such solutions at one time, or they did not suit me </li><li>  writing your bikes is fun! </li></ul><br><p>  If someone liked all of the above, welcome to <a href="https://github.com/Naltox/airship">GitHub</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348564/">https://habr.com/ru/post/348564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348552/index.html">Extending and using the Linux Crypto API</a></li>
<li><a href="../348554/index.html">Welcome to Cradle: Rave. And no, this is not a disco</a></li>
<li><a href="../348558/index.html">The fundamental HTML vulnerability when embedding scripts</a></li>
<li><a href="../348560/index.html">Relationship functionality</a></li>
<li><a href="../348562/index.html">BI & Blockchain is a collective intelligence based solution. Part 2</a></li>
<li><a href="../348566/index.html">Flask Mega-Tutorial, Part X: Email Support (Edition 2018)</a></li>
<li><a href="../348570/index.html">7 Free Data Science Courses for Beginners</a></li>
<li><a href="../348572/index.html">Security week 3: a thief from a bitcoin thief stole, your trojan could be here, ten days without computers</a></li>
<li><a href="../348574/index.html">From regular office to fully distant work: how we built an effective corporate culture</a></li>
<li><a href="../348578/index.html">Serverless application with AWS and Bitbucket Pipelines CI / CD implementation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>