<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>NULL Note</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 Long thought, that would write useful about Orakl, tried a bunch of topics. Each time it turned out too long, because it was carried deep int...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>NULL Note</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br>  Long thought, that would write useful about Orakl, tried a bunch of topics.  Each time it turned out too long, because it was carried deep into the wilds.  Therefore, I decided to start with the simplest topic to assess the interest of the audience and its relation to my style of presentation (IMHO, the writer from me is not very).  A few notes: <ul><li>  The note applies to Oracle DBMS, but most of the written concerns other DBMS; </li><li>  It did not work out nicely: the source tag lang = "sql" highlights too little, how to do something else not up to date.  If anyone shows, quickly bring everything in a more readable form. </li></ul>  So. <br><br><h1>  Main provisions </h1> The special value NULL means the absence of data, a statement of the fact that the value is unknown.  By default, columns and variables of any type can accept this value, unless <code>NOT NULL</code> imposed on them.  Also, the DBMS automatically adds the <code>NOT NULL</code> to the columns included in the primary key of the table. <br><br>  The main feature of NULL is that it is not equal to anything, even to another NULL.  You cannot compare any value with it using any operators: <code>=</code> , <code>&lt;</code> , <code>&gt;</code> , <code>like</code> ... Even the expression <code>NULL != NULL</code> will not be true, because it is impossible to unambiguously compare one uncertainty with another.  By the way, this expression will not be false either, because when calculating conditions, Oracle is not limited to the <code></code> and <code></code> states.  Due to the presence of an element of uncertainty in the form of NULL, there is another state - <code></code> . <br><a name="habracut"></a><br>  Thus, Oracle does not operate with two-digit, but three-valued logic.  Grandpa Codd put this feature into his relational theory, and Oracle, being a relational DBMS, completely follows its precepts.  In order not to meditate on the ‚Äústrange‚Äù results of queries, the developer needs to know the truth table of three-valued logic.  You can get acquainted with it, for example, on the English Wikipedia: <a href="http://en.wikipedia.org/wiki/Three-valued_logic">Three-valued_logic</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>For convenience, we will do a procedure that prints the state of the boolean parameter:</i> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> test_bool( p_bool <span class="hljs-built_in"><span class="hljs-built_in">boolean</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> p_bool = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> dbms_output.put_line(<span class="hljs-string"><span class="hljs-string">'TRUE'</span></span>); when p_bool = false then dbms_output.put_line('FALSE'); else dbms_output.put_line('UNKNOWN'); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> test_bool;</code> </pre> <br>  <i>and enable the option to print messages to the console:</i> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span> serveroutput <span class="hljs-keyword"><span class="hljs-keyword">on</span></span></code> </pre> <br>  <i>The usual comparison operators pass before NULL:</i> <br><pre> <code class="sql hljs">exec test_bool( null = null ); <span class="hljs-comment"><span class="hljs-comment">-- UNKNOWN exec test_bool( null != null ); -- UNKNOWN exec test_bool( null = 'a' ); -- UNKNOWN exec test_bool( null != 'a' ); -- UNKNOWN</span></span></code> </pre> <br><br><h1>  NULL Comparison </h1><br>  There are special operators <code>IS NULL</code> and <code>IS NOT NULL</code> that allow you to make comparisons with NULLs.  <code>IS NULL</code> returns true if the operand is <code>NULL</code> and false if it is not. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'YES'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">'NO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual; <span class="hljs-comment"><span class="hljs-comment">-- YES select case when 'a' is null then 'YES' else 'NO' end from dual; -- NO</span></span></code> </pre> <br>  Accordingly, <code>IS NOT NULL</code> does the opposite: returns true if the value of the operand is different from NULL and false if it is NULL: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'YES'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">'NO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual; <span class="hljs-comment"><span class="hljs-comment">-- YES select case when null is NOT null then 'YES' else 'NO' end from dual; -- NO</span></span></code> </pre> <br>  In addition, there are a couple of exceptions to the rules regarding comparisons with missing values.  First, it is a <code>DECODE</code> function that considers two NULLs equivalent to each other.  Second, these are composite indices: if the two keys contain empty fields, but all their non-empty fields are equal, then Oracle considers these two keys to be equivalent. <br><br>  <i><code>DECODE</code> goes against the system:</i> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decode</span></span>( <span class="hljs-literal"><span class="hljs-literal">null</span></span> , <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'ONE'</span></span> , <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">'EMPTY'</span></span> <span class="hljs-comment"><span class="hljs-comment">--     , 'DEFAULT' ) from dual;</span></span></code> </pre> <br>  An example with composite indices is in the paragraph about indices. <br><br><h1>  Boolean operations and NULL </h1>  Usually, the condition <code></code> treated the same as <code></code> .  For example, if you select rows from a table and the calculation of the condition <code>x = NULL</code> in the <code>WHERE</code> gave an <code></code> result, then you will not get a single row.  However, there is a difference: if the expression <code>()</code> returns true, then <code>()</code> returns <code></code> .  The logical operators <code>AND</code> and <code>OR</code> also have their own characteristics when processing an unknown state.  The specifics in the example below. <br><br>  <i>In most cases, the unknown result is processed as <code></code> :</i> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dummy = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">--    </span></span></code> </pre> <br>  <i>Denial of the unknown gives the unknown:</i> <br><pre> <code class="sql hljs">exec test_bool( not(null = null) ); <span class="hljs-comment"><span class="hljs-comment">-- UNKNOWN exec test_bool( not(null != null) ); -- UNKNOWN exec test_bool( not(null = 'a') ); -- UNKNOWN exec test_bool( not(null != 'a') ); -- UNKNOWN</span></span></code> </pre> <br>  <i><code>OR</code> operator:</i> <br><pre> <code class="sql hljs">exec test_bool( null or true ); <span class="hljs-comment"><span class="hljs-comment">-- TRUE &lt;- !!!!! exec test_bool( null or false ); -- UNKNOWN exec test_bool( null or null ); -- UNKNOWN</span></span></code> </pre> <br>  <i><code>AND</code> operator:</i> <br><pre> <code class="sql hljs">exec test_bool( null and true ); <span class="hljs-comment"><span class="hljs-comment">-- UNKNOWN exec test_bool( null and false ); -- FALSE &lt;- !!!!! exec test_bool( null and null ); -- UNKNOWN</span></span></code> </pre> <br><br><h1>  IN and NOT IN operators </h1><br>  To begin, we will do some preliminary actions.  For tests, create a table <code>T</code> with one numeric column <code>A</code> and four lines: <code>1, 2, 3</code> and <code>NULL</code> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column_value</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(sys.odcinumberlist(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-literal"><span class="hljs-literal">null</span></span>));</code> </pre> <br>  Enable trace request (for this you must have the role <code>PLUSTRACE</code> ). <br>  In the listings for tracing, only a part of the filter is left to show where the conditions specified in the request unfold. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span> autotrace <span class="hljs-keyword"><span class="hljs-keyword">on</span></span></code> </pre> <br>  Preliminary actions are finished, let's work with operators now.  Let's try to select all the records that are included in the set <code>(1, 2, NULL)</code> : <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">--  [1,2] -- Predicate Information: -- filter("A"=1 OR "A"=2 OR "A"=TO_NUMBER(NULL))</span></span></code> </pre> <br>  As you can see, the string with NULL is not selected.  This happened because the calculation of the predicate <code>"A"=TO_NUMBER(NULL)</code> returned the state <code></code> .  In order to include NULLs in the query result, you will have to specify this explicitly: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">--  [1,2,NULL] -- Predicate Information: -- filter("A" IS NULL OR "A"=1 OR "A"=2)</span></span></code> </pre> <br>  Let's try now with <code>NOT IN</code> : <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">-- no rows selected -- Predicate Information: -- filter("A"&lt;&gt;1 AND "A"&lt;&gt;2 AND "A"&lt;&gt;TO_NUMBER(NULL))</span></span></code> </pre> <br><br>  No records at all!  Let's see why the troika did not hit the query results.  Calculate manually the filter that the DBMS applied for the case <code>A=3</code> : <br><br><pre>  3 &lt;&gt; 1 AND 3 &lt;&gt; 2 AND 3 &lt;&gt; to_number (NULL)
    \ / \ / \ /
    true AND true AND unknown
        \ / /
         true AND unknown
             \ /
              unknown </pre><br>  Because of the peculiarities of the three-valued logic, <code>NOT IN</code> is not at all friendly with NULLs: as soon as NULL has fallen into the selection conditions, don't wait for the data. <br><br><h1>  NULL and empty string </h1><br>  Here, Oracle departs from the ANSI SQL standard and declares the equivalence of NULL and the empty string.  This is perhaps one of the most controversial features, which from time to time gives rise to multi-page discussions with the transition to the individual, watering each other with feces and other indispensable attributes of tough disputes.  Judging by the documentation, Oracle itself would not mind changing this situation (it says that even now the empty string is treated as NULL, this may change in future releases), but today such a huge amount of code is written under this DBMS that and change the behavior of the system is hardly realistic.  Moreover, they started talking about this at least from the seventh version of the DBMS (1992-1996), and now it is the twelfth on the way. <br><br>  <em>NULL and empty string are equivalent:</em> <br><pre> <code class="sql hljs">exec test_bool( '' is null ); <span class="hljs-comment"><span class="hljs-comment">-- TRUE</span></span></code> </pre> <br><br>  <em>an indispensable attribute of a tough dispute:</em> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) comments_count, <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(c.vote) avg_vote <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> habr.comments c <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> habr.posts p <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>( c.post_id = p.id ) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lower</span></span>(p.title) <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'%%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lower</span></span>(p.title) <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'%%'</span></span>; COMMENTS_COUNT AVG_VOTE <span class="hljs-comment"><span class="hljs-comment">--------------- --------- 100500 -100</span></span></code> </pre> <br>  If you follow the testament of the classic and look at the root, then the reason for the equivalence of the empty string and NULL can be found in the storage format of varchar and NULLs inside data blocks.  Oracle stores the rows of the table in a header structure followed by columns of data.  Each column is represented by two fields: the length of the data in the column (1 or 3 bytes) and, in fact, the data itself.  If <code>varchar2</code> has zero length, then there is nothing to write to the data field, it does not occupy a single byte, and a special value of <code>0xFF</code> , indicating the absence of data, is written in the field with length.  NULL is presented exactly the same: there is no data field, and <code>0xFF</code> is written in the field with length.  Developers Orakla could, of course, to separate these two states, but since ancient times they have been led. <br><br>  Personally, the equivalence of the empty string and NULL seems quite natural and logical.  The name ‚Äúempty line‚Äù implies the absence of meaning, emptiness, a donut hole.  NULL, in general, means the same thing.  But there is an unpleasant consequence: if one can say with confidence about an empty string that its length is zero, then the length of a NULL is not determined at all.  Therefore, the expression <code>length('')</code> will return NULL for you, and not zero, as you obviously expected.  Another problem: you can not compare with an empty string.  The expression <code>val = ''</code> returns the state <code></code> , since, in fact, equivalent to <code>val = NULL</code> . <br><br>  <em>The length of the empty string is not defined:</em> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual; <span class="hljs-comment"><span class="hljs-comment">-- NULL</span></span></code> </pre> <br>  <em>A comparison with an empty string is impossible:</em> <br><pre> <code class="sql hljs">exec test_bool( 'a' != '' ); <span class="hljs-comment"><span class="hljs-comment">-- UNKNOWN</span></span></code> </pre> <br>  Critics of the approach proposed by Orakl suggest that the empty string does not necessarily indicate uncertainty.  For example, a sales manager fills a customer card.  He may indicate his contact phone number (555-123456), may indicate that he is unknown (NULL), or may indicate that there is no contact phone number (blank line).  With storage of empty lines to implement the last variant will be problem.  From the point of view of semantics, the argument is correct, but I always have a question for him that I never received a full answer: how does the manager enter an empty line in the ‚Äúphone‚Äù field and how will he further distinguish it from NULL?  There are options, of course, but still ... <br><br>  Actually, if we talk about PL / SQL, then somewhere deep inside its engine there is an empty string and NULL are different.  One way to see this is because associative collections allow you to save an element with an index of <code>''</code> (empty string), but do not allow you to save an element with an index of NULL: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> empty_or_null( p_val varchar2 ) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> tt <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> varchar2(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> varchar2(<span class="hljs-number"><span class="hljs-number">10</span></span>); t tt; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p_val <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> dbms_output.put_line(<span class="hljs-string"><span class="hljs-string">' '</span></span>); else <span class="hljs-comment"><span class="hljs-comment">--      p_val t(p_val) := 'x'; -- ! ,   dbms_output.put_line(' '); end if; exception --     p_val  . , NULL when others then dbms_output.put_line('NULL'); end; begin empty_or_null( 'qwe' ); --   empty_or_null( '' ); --   empty_or_null( NULL ); -- NULL end;</span></span></code> </pre> <br>  Use these feints ears in practice is not worth it.  To avoid problems, it is better to learn the rule from the docks: the empty string and the NULL in the Oracle are indistinguishable. <br><br><h1>  NULL math </h1>  <sup>This small paragraph was written on a Friday evening for beer, against the backdrop of the Friday REN-TVshnogo film.</sup>  <sup>Rewrite his laziness, I'm sorry.</sup> <br><br>  Task.  Before the marriage with Kolya, Masha had an unknown number of lovers.  Kolya knows that after marriage, Masha had sex with him, Sasha and Vitya.  Help Kolya find the exact number of Masha's lovers. <br><br>  Obviously, we will not be able to help Kolya: an unknown number of Masha's lovers before marriage reduces all calculations to one value - is unknown.  Oracle, although it was called an oracle, in this matter goes no further than the participants in the battle of psychics: it gives obvious answers only to obvious questions.  Although, I must admit that Oracle is much more honest: in the case of Kolya, he will not be engaged in psychoanalysis and will immediately say: ‚ÄúI don‚Äôt know‚Äù: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decode</span></span>( <span class="hljs-literal"><span class="hljs-literal">null</span></span> + <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual; <span class="hljs-comment"><span class="hljs-comment">--  select decode( null * 10, null, '', '') a from dual; --  select decode( abs(null), null, '', '') a from dual; --  select decode( sign(null), null, '', '') a from dual; -- </span></span></code> </pre> <br>  With concatenation, things are different: you can add NULL to the string and this will not change it.  Such is the policy of double standards. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> ||<span class="hljs-string"><span class="hljs-string">'AA'</span></span>|| <span class="hljs-literal"><span class="hljs-literal">null</span></span> ||<span class="hljs-string"><span class="hljs-string">'BB'</span></span>|| <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual; <span class="hljs-comment"><span class="hljs-comment">-- AABB</span></span></code> </pre> <br><br><h1>  NULL and aggregate functions </h1><br>  Almost all aggregate functions, with the exception of <code>COUNT</code> (and even then not always), ignore null values ‚Äã‚Äãduring calculations.  If they did not do this, then the first null that has flown in would have led to the result of the function to an unknown value.  Take for example the <code>SUM</code> function, which needs to sum the series <code>(1, 3, null, 2)</code> .  If it took null values, we would get the following sequence of actions: <br> <code>1 + 3 = 4; 4 + null = null; null + 2 = null</code>  <code>1 + 3 = 4; 4 + null = null; null + 2 = null</code> . <br>  It is unlikely that you will be satisfied with this calculation when calculating the aggregates, because you probably didn‚Äôt want to get this.  And what would be hemorrhoids with the construction of data warehouses ... Brrrrr ... <br><br>  <i>Table with data.</i>  <i>Used below many times:</i> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> agg( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, n <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> agg <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> agg <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> agg <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>( <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> agg <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>( <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>;</code> </pre> <br>  <i>Empty values ‚Äã‚Äãare ignored by aggregates:</i> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(n) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> agg; <span class="hljs-comment"><span class="hljs-comment">-- 6</span></span></code> </pre> <br>  The <code>COUNT</code> counting function, if used as a <code>COUNT(*)</code> or <code>COUNT()</code> , will take null values ‚Äã‚Äãinto account.  However, if it is used in the form <code>COUNT()</code> , then empty values ‚Äã‚Äãwill be ignored. <br><br>  <i>with constant:</i> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> agg; <span class="hljs-comment"><span class="hljs-comment">-- 4 select count(1+1) from agg; -- 4 select count(user) from agg; -- 4</span></span></code> </pre> <br>  <i>With the expression:</i> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(n) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> agg; <span class="hljs-comment"><span class="hljs-comment">-- 3 select count(id) from agg; -- 4 select count(abs(n)) from agg; -- 3</span></span></code> </pre> <br>  Also, be careful with features like <code>AVG</code> .  Since it ignores empty values, the result for the <code>N</code> field will be <code>(1+3+2)/3</code> , and not <code>(1+3+2)/4</code> .  Perhaps this calculation of the average you do not need.  To solve such problems, there is a standard solution - use the <code>NVL</code> function: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(n) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> agg; <span class="hljs-comment"><span class="hljs-comment">-- (1 + 3 + 2) / 3 = 2 select avg(nvl(n,0)) from agg; -- (1 + 3 + 0 + 2) / 4 = 1.5</span></span></code> </pre> <br>  Aggregate functions return the state <code></code> , if they are applied to an empty dataset, or if it consists only of NULLs.  The exceptions are the <code>REGR_COUNT</code> and <code>COUNT()</code> functions intended for counting the number of rows.  They in the above cases will return zero. <br><br>  <i>Data set from NULLs only:</i> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(n) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> agg <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">--  select avg(n) from agg where n is null; --  select regr_count(n,n) from agg where n is null; -- 0 select count(n) from agg where n is null; -- 0</span></span></code> </pre> <br>  <i>Empty data set:</i> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(n) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> agg <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">--  select avg(n) from agg where 1 = 0; --  select regr_count(n,n) from agg where 1 = 0; -- 0 select count(n) from agg where 1 = 0; -- 0</span></span></code> </pre> <br><h3>  NULL in OLAP </h3><br>  Very briefly about another feature associated with the aggregates.  In multidimensional cubes, NULL in a query result can mean both a lack of data and a sign of grouping by dimension.  The most disgusting thing is that you cannot distinguish between his two incarnations.  Fortunately, there are special functions <code>GROUPING</code> and <code>GROUPING_ID</code> , which have a sharper eye.  <code>GROUPING()</code> will return one if NULL in the dimension column indicates the grouping attribute on this column and zero if it contains a specific value (in particular, NULL).  The <code>GROUPING_ID</code> function is a bit vector from <code>GROUPING</code> , in this post it is definitely superfluous. <br><br>  In general, such a brief and confused information about dualism NULL in multidimensional analysis.  Below is an example of using <code>GROUPING</code> , and for details on using the <a href="http://download.oracle.com/docs/cd/E11882_01/server.112/e16579/aggreg.htm">Data Warehousing Guide, chapter 21</a> . <br><br>  <i>Convenient feature sqlplus: when outputting data, replaces NULL with the specified string:</i> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> [<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>]</code> </pre> <br>  <i>Check NULL dualism in a multidimensional cube:</i> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-comment"><span class="hljs-comment">--   1  select 'IVAN' customer, 'KEFIR' product, 1 qty from dual union all --    2  select NULL customer, 'MOLOKO' product, 2 qty from dual union all --   2  select 'IVAN' customer, 'MOLOKO' product, 2 qty from dual ) select customer cust, grouping(customer) grp_c , product prod, grouping(product) grp_p , sum(qty) qty from t group by cube(customer, product) order by grp_c, grp_p; CUST GRP_C PROD GRP_P QTY ---- ----- ------ ----- ---- [NULL] 0 MOLOKO 0 2 --    2   IVAN 0 KEFIR 0 1 --   1   IVAN 0 MOLOKO 0 2 --   2   IVAN 0 [NULL] 1 3 --   3    [NULL] 0 [NULL] 1 2 --    2    [NULL] 1 MOLOKO 0 4 --    4   [NULL] 1 KEFIR 0 1 --    1   [NULL] 1 [NULL] 1 5 --    5   </span></span></code> </pre> <br><br><h1>  What's left overs </h1><br>  It turned out quite long, so some of the information had to be cut out.  Namely: <br><ul><li>  NULL in indexes (regular, compound, binary, functional).  There I have more listings than text; </li><li>  analysis of functions for working with NULLs: documented and not so much; </li><li>  work with NULLs in queries (all sorts of cases) </li><li>  maybe I forgot to mention some other moments, write in the comments, add. </li></ul>  Criticism, additions and hints of the incompetence of the author (with reference to the dock) are welcome.  Actually, for this purpose everything was started. </div><p>Source: <a href="https://habr.com/ru/post/127327/">https://habr.com/ru/post/127327/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../127321/index.html">Stationary cell phone in dacha conditions</a></li>
<li><a href="../127322/index.html">Current Cost EnviR - electricity consumption monitoring</a></li>
<li><a href="../127323/index.html">Joke as a hint</a></li>
<li><a href="../127324/index.html">Mari0</a></li>
<li><a href="../127325/index.html">Lamborghini among the phones</a></li>
<li><a href="../127328/index.html">We use the government website zakupki.gov.ru as a means of free hosting static files</a></li>
<li><a href="../127330/index.html">Another way to present a startup</a></li>
<li><a href="../127332/index.html">Microsoft Research Announces Breakthrough Speech Recognition</a></li>
<li><a href="../127334/index.html">Eric Schmidt considers Google+ as not only a social network, but also an identification service.</a></li>
<li><a href="../127336/index.html">Automation of calculations of the municipal center of the city based on 1C: Enterprise 8</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>