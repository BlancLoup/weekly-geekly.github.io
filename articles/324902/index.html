<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How Discord Indexes Billions of Posts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Millions of users send billions of messages to Discord every month . A search in these messages has become one of the most requested features we have ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How Discord Indexes Billions of Posts</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/d88/dd7/f7d/d88dd7f7d1ef3c461a37c1d14998685d.png"><br><br>  <a href="https://habrahabr.ru/post/323694/">Millions of users send billions of messages to Discord every month</a> .  A search in these messages has become <a href="https://feedback.discordapp.com/forums/326712-discord-dream-land/suggestions/10313166-add-a-search-function-ctrl-f">one of the most requested features</a> we have done.  <i>Let there be a search!</i> <br><br><h1>  Requirements </h1><br><ul><li>  <b>Cost-effective:</b> The main user interaction with Discord is our text and voice chat.  Search is an auxiliary function, and the cost of the infrastructure should reflect this.  Ideally, this means that the search should not be more expensive than the actual storage of messages. </li><li>  <b>Fast and intuitive:</b> All the functions we create must be fast and intuitive, including search.  It should look and feel to a higher standard. </li><li>  <b>Self-healing:</b> We do not have a DevOps department (yet), so the search must withstand failures with minimal human intervention or without it at all. </li><li>  <b>Linearly scalable:</b> As with the storage of messages, increasing the capacity of the search infrastructure <a href="https://blog.discordapp.com/how-discord-stores-billions-of-messages-7fa6ec7ee4c7">should include the addition of nodes</a> . </li><li>  <b>Lazy indexing:</b> Not everyone uses the search - we do not have to index the messages until someone tries to find them at least once.  In addition, after an index failure, there should be a possibility to re-index servers on the fly. </li></ul><a name="habracut"></a><br>  Looking at these requirements, we asked ourselves two key questions: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Q.</b> Can I submit the search to a managed SaaS?  (a simple solution) <br><br>  <b>A.</b> No.  All of the managed search solutions we reviewed go beyond our budget (an astronomical sum) for this feature.  In addition, our guys do not like the idea of ‚Äã‚Äãtransferring messages outside our data center.  Being aware of the risks, I want to keep control over the security of user messages, and not trusting it to a third party. <br><br>  <b>Q.</b> Is there an open source search solution for us? <br><br>  <b>Oh</b> yes!  We studied everything and, after a brief discussion, quickly came to the choice of Elasticsearch vs Solr, since both systems may well be suitable for our case.  Elasticsearch had the advantage: <br><br><ul><li>  Detection of nodes in Solr requires ZooKeeper.  Etcd works for us, and we did not want to multiply the infrastructure specifically for Solr.  But Zen Discovery in Elasticsearch is self-sufficient. </li><li>  Elasticsearch supports automatic rebalancing of shards, which will allow adding new nodes to the cluster, thereby ‚Äúout of the box‚Äù fulfilling our requirement for linear scalability. </li><li>  Elasticsearch has built-in structured DSL for requests, and Solr would otherwise have to programmatically create a query string using a third-party library. </li><li>  Our engineers have more experience with Elasticsearch. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/0c8/350/26c/0c835026c9720d02e4e1565f21c8303c.png"><br><br><h1>  Elasticsearch will work? </h1><br>  Elasticsearch seems to fit all our requirements, and our engineers have experience working with it.  It allows you to replicate data between different nodes to withstand the failure of each of them, scales the cluster by adding new nodes and can swallow messages for indexing without getting tired.  But while studying the topic, we found some scary stories about managing large Elasticsearch clusters, but in reality no one from our backend group had any experience with managing Elasticsearch clusters, not counting our log processing infrastructure. <br><br>  We wanted to avoid problems with bulky large clusters, and then the idea came to delegate sharding and routing to the application layer in order to index messages in the pool of smaller Elasticsearch clusters.  This also means that in the event of a single cluster being discontinued, only a portion of the Discord messages, those in the outgoing cluster, will become inaccessible.  It also gives us a useful opportunity to drop the data of the whole cluster if it cannot be recovered (the system will lazily re-index the server data the next time the user tries to search for them). <br><br><h1>  Components </h1><br>  Elasticsearch likes to index documents <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html">in large quantities</a> .  This means that we can not index messages as they are published in real time.  Instead, we designed a queue in which the worker captures message bursts and indexes them with single operations.  We decided that the slight delay between posting the message and its accessibility to search is a reasonable limitation.  After all, most users search for messages posted in the past, not just what they said. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/36b/efb/a99/36befba991a988388443af4e0068df70.png"><br><br>  On the side of receiving information, you had to do a couple of things: <br><br><ul><li>  <b>Message queue:</b> It was necessary to make a queue where all messages arrive as they are posted online (for parsing by the pool of workers). </li><li>  <b>Indexing Workers:</b> Workers who do the actual routing and bulk insertion into the Elasticsearch from the queue. </li></ul><br>  We have previously made a system of setting tasks in a queue based on <a href="http://docs.celeryproject.org/en/latest/">Celery</a> , so we used it for history indexing workers as well. <br><br><ul><li>  <b>Workers indexing history:</b> Workers whose task is to search the message history on a given server and insert it into the Elasticsearch index. </li></ul><br>  We still needed simple and fast mapping, which Elasticsearch cluster and index belong to the messages of each Discord server.  <i>We called this pair ‚Äúcluster + index‚Äù Shard (not to be confused with Elasticsearch native shards in the index)</i> .  The mapping system created by us consists of two layers: <br><br><ul><li>  <b>Permanent mapping of shards:</b> It was placed in Cassandra, our main persistent data store, as a reference. </li><li>  <b>Shard mapping cache:</b> When processing messages by workers, requests to Cassandra about Shard are a slow operation.  We cache these cards in Redis, so we can perform <a href="https://redis.io/commands/mget">mget</a> operations to quickly figure out where to route the message. </li></ul><br>  If the server is being indexed for the first time, you also need to choose to which Shard to send messages to this Discord server.  Since the Shards are an abstraction of the application layer, it becomes possible to distribute them more intelligently.  Using the power of Redis, we applied a sorted set to create a load aware allocator for shards. <br><br><ul><li>  <b>Shard Dispenser:</b> With the help of a sorted set in Redis, we store a set of Shards with ratings that correspond to their load.  For the nearest distribution, a shard is selected that corresponds to the Shard with the lowest estimate.  This score increases with each distribution, and each message, after being indexed in Elasticsearch, is also likely to increase its Shard score.  The more data in Shard, the less chance that it will choose to distribute the new Discord server. </li></ul><br>  Of course, the entire search infrastructure would be incomplete without a cluster and host detection system from the application layer. <br><br><ul><li>  <b>etcd:</b> In other parts of our system, <a href="https://github.com/coreos/etcd">etcd is</a> used to locate services, so we applied it to Elasticsearch clusters.  The nodes in the cluster are able to declare themselves in etcd for the rest of the system, so it is not necessary to firmly fix some Elasticsearch topologies. </li></ul><br>  In the end, it was necessary to enable customers to actually search for messages. <br><br><ul><li>  <b>Search API:</b> Program interfaces through which requests from users come.  It was necessary to implement all the permissions checks so that users could only search for messages to which they have access rights. </li></ul><br><br><img src="https://habrastorage.org/files/df0/e82/05b/df0e8205b23d4a93abcd91757862c37f.png"><br><br><h1>  Indexing and data mapping </h1><br>  At a really high level in Elasticsearch, we have the concept of an ‚Äúindex‚Äù within which there are ‚Äúshards‚Äù.  In this case, the shard is a <a href="https://lucene.apache.org/">Lucene index</a> .  Elasticsearch is responsible for distributing the data in the index before the shard belonging to this index.  If you want, you can control how the data is distributed among shards, using the "routing key".  The index also stores the "replication factor", which means the number of nodes to which the index (and shards in it) should be replicated.  If the node on which the index is located fails, then its replicated copy will take over the load.  (By the way, these copies are also able to handle search queries, so you can scale the search bandwidth by adding more replicated copies). <br><br>  Since we transferred all the logic of shards to the application level (our Shards), the sharding on the side of Elasticsearch in reality did not make sense.  However, we could use it to replicate and balance indices between nodes in a cluster.  In order for Elasticsearch to automatically create an index using the correct configuration, we used an index template that contains the index configuration and data mapping.  Index configuration is quite simple: <br><br><ul><li>  The index should contain only one shard (do not do any sharding for us) </li><li>  The index must replicate to one node (withstand the failure of the main node that carries the index) </li><li>  The index should be updated once every 60 minutes (why it had to be done, we will explain below) </li><li> The index contains a single document type: <code>message</code> </li></ul><br>  Storing the original message data in Elasticsearch did not make much sense, because in this format, the message data is difficult to search.  Instead, we decided to take each message and convert it to a set of fields with metadata that can be indexed for searching: <br><br><pre> <code class="plaintext hljs">INDEX_TEMPLATE = { 'template': 'm-*', 'settings': { 'number_of_shards': 1, 'number_of_replicas': 1, 'index.refresh_interval': '3600s' }, 'mappings': { 'message': { '_source': { 'includes': [ 'id', 'channel_id', 'guild_id' ] }, 'properties': { # This is the message_id, we index by this to allow for greater than/less than queries, so we can search # before, on, and after. 'id': { 'type': 'long' }, # Lets us search with the "in:#channel-name" modifier. 'channel_id': { 'type': 'long' }, # Lets us scope a search to a given server. 'guild_id': { 'type': 'long' }, # Lets us search "from:Someone#0001" 'author_id': { 'type': 'long' }, # Is the author a user, bot or webhook? Not yet exposed in client. 'author_type': { 'type': 'byte' }, # Regular chat message, system message... 'type': { 'type': 'short' }, # Who was mentioned, "mentions:Person#1234" 'mentions': { 'type': 'long' }, # Was "@everyone" mentioned (only true if the author had permission to @everyone at the time). # This accounts for the case where "@everyone" could be in a message, but it had no effect, # because the user doesn't have permissions to ping everyone. 'mention_everyone': { 'type': 'boolean' }, # Array of [message content, embed title, embed author, embed description, ...] # for full-text search. 'content': { 'type': 'text', 'fields': { 'lang_analyzed': { 'type': 'text', 'analyzer': 'english' } } }, # An array of shorts, specifying what type of media the message has. "has:link|image|video|embed|file". 'has': { 'type': 'short' }, # An array of normalized hostnames in the message, traverse up to the domain. Not yet exposed in client. # "http://foo.bar.com" gets turned into ["foo.bar.com", "bar.com"] 'link_hostnames': { 'type': 'keyword' }, # Embed providers as returned by oembed, ie "Youtube". Not yet exposed in client. 'embed_providers': { 'type': 'keyword' }, # Embed type as returned by oembed. Not yet exposed in client. 'embed_types': { 'type': 'keyword' }, # File extensions of attachments, ie "fileType:mp3" 'attachment_extensions': { 'type': 'keyword' }, # The filenames of the attachments. Not yet exposed in client. 'attachment_filenames': { 'type': 'text', 'analyzer': 'simple' } } } } }</code> </pre> <br>  You may notice that we did not include a timestamp in the field set, and if you remember from our <a href="https://habrahabr.ru/post/323694/">past post</a> , our IDs are created in the <a href="https://blog.twitter.com/2010/announcing-snowflake">Snowflake</a> format, that is, they essentially contain a timestamp (which can be used to implement the function of selecting search results by time, choosing corresponding ID range). <br><br>  However, these fields are not ‚Äústored‚Äù in this form in Elasticsearch; rather, they are stored only in an <a href="https://en.wikipedia.org/wiki/Inverted_index">inverted index</a> .  The only actually stored and returned fields are the message, channel, and server ID on which the message was published.  This means that the message data is not duplicated in Elasticsearch.  The tradeoff is that we have to take data from Cassandra when returning search results, but this is absolutely normal, because in any case we would have to take the context of the message (two messages before and after) from Cassandra to display in the interface.  Storing a real message object outside of Elasticsearch means that we don‚Äôt need to spend extra disk space on it.  However, this also means that we cannot use Elasticsearch to highlight matches in the search results.  We'll have to embed tokens and linguistic analyzers into the client program to highlight matches (which was really easy to do). <br><br><h1>  Implementation </h1><br>  We decided that microservice was probably not required for searching - instead, we put a library for Elasticsearch into which the logic of routing and queries was wrapped.  It took only one additional service to start - these are indexers (who will use this library to do the actual work of indexing).  The part of the program interfaces exposed for the rest of the team was also minimal, so if it were necessary to switch to our own service, it could be easily wrapped in an RPC layer.  The library can be imported into our API workers, and it can actually perform search queries and return results to the user via HTTP. <br><br>  For the rest of the command, the library shows the minimum part to search for messages: <br><br><pre> <code class="plaintext hljs">results = router.search(SearchQuery( guild_id=112233445566778899, content="hey jake", channel_ids=[166705234528174080, 228695132507996160] )) results_with_context = gather_results(results, context_size=2)</code> </pre> <br>  Queuing a message for indexing or deletion: <br><br><pre> <code class="plaintext hljs"># When a message was created or updated: broker.enqueue_message(message) # When a message was deleted: broker.enqueue_delete(message)</code> </pre> <br>  Bulk message indexing (almost) in real time by a worker: <br><br><pre> <code class="plaintext hljs">def gather_messages(num_to_gather=100): messages = [] while len(messages) &lt; num_to_gather: messages.append(broker.pop_message()) return messages while True: messages = gather_messages() router.index_messages(messages)</code> </pre> <br>  To index old messages, a historical indexing task is created on the server, which performs a unit of work and creates a new task to continue indexing this server.  Each task is a pointer to a place in the server message history and a fixed unit of the indexing volume (in this case, the default is set to 500 messages).  The job returns a new pointer to the next batch of messages to be indexed or to <i>None</i> if there is nothing more to do.  In order to quickly get results for a large server, we divided historical indexing into two phases: ‚Äúinitial‚Äù and ‚Äúdeep‚Äù.  In the ‚Äúinitial‚Äù phase, messages for the last 7 days are indexed - and the index becomes available to users.  After that, we begin the ‚Äúdeep‚Äù phase, which is performed with low priority.  <a href="https://support.discordapp.com/hc/en-us/articles/115000414847-What-is-Server-Indexing-">This article</a> explains how this looks to the user.  Tasks are performed in a pool of workers, which allows you to plan them among other tasks that workers perform.  It looks like this: <br><br><pre> <code class="plaintext hljs">@task() def job_task(current_job) # .process returns the next job to execute, or None if there are no more jobs to execute. next_job = current_job.process(router) if next_job: job_task.delay(next_job, priority=LOW if next_job.deep else NORMAL) initial_job = HistoricalIndexJob(guild_id=112233445566778899) job_task.delay(initial_job)</code> </pre> <br><h1>  Production Testing </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/ee8/405/9a8/ee84059a8e1552415df65fa701141508.png"><br><br>  After coding all of the above and testing in the development environment, we decided it was time to see how it works in production.  We raised the only Elasticsearch cluster with three nodes, started indexing workers and assigned 1000 Discord servers for indexing.  Everything seemed to work, but when we looked at the cluster indicators, we noticed two things: <br><br><ol><li>  CPU usage turned out to be higher than we expected. </li><li>  Disk space consumption grew too fast for the volume of messages that was actually indexed. </li></ol><br>  This surprised us quite a lot, and after continuing for some time using too much disk space, we canceled the indexing tasks and decided to sort it out the next day.  <i>Something was clearly wrong</i> . <br><br>  When we returned in the morning, we noticed a SIGNIFICANT disk space release.  Has Elasticsearch discarded our data?  We tried to run a search query on one of our servers, which was indexed and where one of our employees was registered.  There is!  The results returned well - and very quickly!  <i>What the heck?</i> <br><br>  <b>Disk space usage grows rapidly and then decreases.</b> <br><img src="https://habrastorage.org/files/6d6/a7a/75b/6d6a7a75be8347ed9f69843a50f223d8.png"><br><br>  <b>CPU load</b> <br><img src="https://habrastorage.org/files/696/939/1be/6969391bed6e4caa9a74dc7e139610f6.png"><br><br>  After a little investigation, we had a hypothesis!  By default, Elasticsearch updates the index once per second.  This is what provides the search "almost in real time."  Every second (in each of the thousands of indexes), Elasticsearch filled the buffer in memory with the Lucene segment and opened it to make it searchable.  During the night during idle time, Elasticsearch combined a large number of small fragments and generated much larger fragments (and much more efficient in disk space). <br><br>  Testing the hypothesis was quite simple.  We reset all indexes in the cluster, set the update interval to an arbitrarily large number, and then assigned the same servers for indexing.  CPU utilization fell to insignificant values, while documents continued to be processed, and disk space consumption did not grow at an alarmingly high rate.  <i>Hooray!</i> <br><br>  <b>Disk space usage after an increase in the refresh interval</b> <br><img src="https://habrastorage.org/files/b2e/22a/523/b2e22a523d3143a98f93d8c8ff2e6787.png"><br><br>  <b>CPU load</b> <br><img src="https://habrastorage.org/files/1cc/a91/ff0/1cca91ff02e34ef6a607c3d91946e576.png"><br><br>  Unfortunately, however, the complete disabling of the update interval did not work in practice ... <br><br><h1>  Trouble with the update interval </h1><br>  It became obvious that the automatic indexing function in near real-time Elasticsearch does not satisfy our needs.  It happens that the server works for hours without a single search query.  We needed to find a way to control the update interval from the application layer.  We did this with an obsolete Redis hash card.  Since Discord servers are shared by shards on common indexes in Elasticsearch, we can build a quick map that changes with the index and keeps track of whether the index needs to be updated - depending on the server you are searching on.  The data structure is simple: the Redis key storing the hash map, <code>prefix + shard_key</code> , to the hash map of the <code>guild_id</code> values, to the signal value that indicates that the index needs to be updated.  <i>In retrospect, this could probably be a lot.</i> <br><br>  The indexing cycle turns into: <br><br><ol><li>  Take N messages from the queue. </li><li>  Figure out where to send these messages, by their <code>guild_id</code> . </li><li>  Perform a bulk insert operation in the corresponding clusters. </li><li>  Update the Redis map, indicating that the shard and the updated <code>guild_id</code> on Shard have become dirty.  This key should expire after 1 hour (Elasticsearch will have an automatic update by then). </li></ol><br>  And the search cycle turned into this: <br><br><ol><li>  Find the shard on which you want to query <code>guild_id</code> . </li><li>  Check the Redis card for the fact that the shard, and also the <code>guild_id</code> , are dirty. </li><li>  If dirty, update the Elasticsearch index for Shard, and mark the whole Shard as clean. </li><li>  Run a search query and return results. </li></ol><br>  You may notice that although we are now clearly controlling the logic of the Elasticsearch update, we still have the main index updated every hour.  If data is lost on Redis cards, the system will be automatically corrected within an hour. <br><br><h1>  Future </h1><br>  Since deploying in January, our Elasticsearch infrastructure has grown to 14 nodes in two clusters, using n1-standard-8 instance types on GCP with Provisioned SSD drives of 1 TB each.  The total number of documents is almost 26 billion. The indexing rate reaches a peak of about 30,000 messages per second.  Elasticsearch copes with this effortlessly, retaining the figure of 5-15% of the CPU throughout the deployment of our search. <br><br>  So far, we have added nodes into clusters without difficulty.  At some point, we will deploy new clusters, so that the new Discord servers being indexed will get there (thanks to our automatic distribution system for shards).  In existing clusters, it will be necessary to limit the number of main select nodes as we add more nodes with data to the cluster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4b/887/aa5/b4b887aa583c3735eadff605f28bc1d1.png"><br><br>  We also stumbled upon four key indicators that we use to determine when to increase the cluster: <br><br><ol><li>  <b>heap_free:</b> (aka heap_committed - heap_used).  When we run out of space on the heap, the JVM is forced to stop so that the garbage collector can quickly free up space.  If it cannot free enough space, then the node crashes.  Before this, the JVM enters a state where it stops continuously, because the heap is full and too little memory is released during each pass of the garbage collector.  We track this along with the statistics of the garbage collector to check how much time is spent on garbage collection. </li><li>  <b>disk_free:</b> Obviously, you need to add new nodes when disk space runs out or if more space is needed to index new documents.  This is very easy to do on GCP, since we can simply increase the disk space without restarting the instance.  The choice between adding a new node or changing the disk size depends on other parameters mentioned here.  For example, if the disk space usage is high, but the other indicators are normal, then we will select the disk space expansion, rather than adding a new node. </li><li>  <b>cpu_usage:</b> If we have reached the CPU utilization threshold at peak hours. </li><li>  <b>io_wait:</b> If the I / O operations in the cluster have become too slow. </li></ol><br><br><h3>  Unhealthy cluster (ends with a bunch) </h3><br>  <b>Free Heap (MiB)</b> <br><img src="https://habrastorage.org/files/0aa/7df/7c1/0aa7df7c1e00460fa6fcaf2cc3f9524f.png"><br><br>  <b>Time for garbage collection, GC per second</b> <br><img src="https://habrastorage.org/files/b03/4d2/b59/b034d2b5950d46e6969e5418b6276826.png"><br><br><h3>  Healthy cluster </h3><br>  <b>Free Heap (GiB)</b> <br><img src="https://habrastorage.org/files/ad9/e23/855/ad9e238552f84e108624e371204897c8.png"><br><br>  <b>Time for garbage collection, GC per second</b> <br><img src="https://habrastorage.org/files/c27/854/d69/c27854d69bae4bc4a8d3982f543b9ede.png"><br><br><h1>  Conclusion </h1><br>  A little more than three months have passed since the moment when we launched the search function, and since then the system has been working with little or no problems. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d62/c71/587/d62c715875a836c45a1daa1be863ab88.gif"><br><br>  Elasticsearch showed stable and confident performance from 0 to 26 billion documents on approximately 16,000 indexes and millions of Discord servers.  We will continue scaling by adding new clusters or more nodes to existing clusters.  At some point, we can think about writing code that will allow indexes to be transferred between clusters as a way to reduce the load on the cluster or to allocate our own index to the Discord server if it is an extremely talkative server (although our sharding system handles the distribution of weights, so that Discord servers and so usually get their own shards). </div><p>Source: <a href="https://habr.com/ru/post/324902/">https://habr.com/ru/post/324902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324892/index.html">PHP Digest number 105 - interesting news, materials and tools (March 13 - 26, 2017)</a></li>
<li><a href="../324894/index.html">Making your first game on the Phaser. Part 0 - Getting Started</a></li>
<li><a href="../324896/index.html">Making your first game on the Phaser. Part 1 - Introduction</a></li>
<li><a href="../324898/index.html">Tensorflow deep learning library</a></li>
<li><a href="../324900/index.html">MIPSfpga and interrupts</a></li>
<li><a href="../324904/index.html">Five important principles of working with data, which we forget when preparing a project presentation</a></li>
<li><a href="../324906/index.html">The story of how I went to Google Next 17. A brief pressing on the announcements and the most important</a></li>
<li><a href="../324908/index.html">A brief history of javascript. Part 3</a></li>
<li><a href="../324910/index.html">Why do you need a manufacturer‚Äôs service for IT equipment and its cost estimate?</a></li>
<li><a href="../324912/index.html">PayPal Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>