<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>I want sites to open instantly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, my name is Alexander Zelenin and I am a web developer. I will tell you how to make your website open quickly. Very fast. 



 Introduction 
 Th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>I want sites to open instantly</h1><div class="post__text post__text-html js-mediator-article">  Hello, my name is Alexander Zelenin and I am a web developer.  I will tell you how to make your website open quickly.  Very fast. <br><br><img src="https://habrastorage.org/files/ad1/9b5/2cb/ad19b52cba9640e7a577e4307b8365b2.jpg"><br><a name="habracut"></a><br><h1>  Introduction </h1><br>  There will be no advice to make "A" and get a super win.  This does not happen.  In this article I want to consider the factors that can be accelerated and due to what.  There are no other factors.  The next time you make your site faster, there will be an understanding of how you will win. <br><br>  <b>The article is focused on advanced developers!</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Each of the topics considered deserves a separate post, if not one.  If it is interesting, I will definitely tell you more. <br><br>  Let's start with what really matters to the user: <br><br><img src="https://habrastorage.org/files/b21/125/219/b211252196dd4c25823b8f30597726fd.png"><br><br><ol><li>  HTML starts loading ( <abbr title="Time to first byte">TTFB</abbr> ) </li><li>  HTML, CSS and scripts at the top of the page are loaded.  Page rendered ( <abbr title="Time to interact">TTI</abbr> ) </li><li>  Full functionality: additional content is available, control buttons work ( <abbr title="Time to last byte">TTLB</abbr> ) * </li></ol><br>  * it is not entirely correct to call it TTLB, since  we loaded a number of separate files, but we can assume that the last required byte is loaded. <br><br>  <b>It is enough to display the main content within 1 second so</b> that the user thinks that the site is fast.  This is much simpler than it seems. <br><br><h2>  What to optimize first? </h2><br>  It is necessary to measure the described metrics of the site and select the largest of them - in this order and optimize.  Now it is easier to do this than ever - just open, for example, in the chrome Network panel in the web developer's tools. <br><br><h2>  Before you start optimizing you need to know </h2><br><ol><li>  The geographical location of the target audience (city (s), country (s). Sometimes even a district may be important.) </li><li>  The parameters of the communication channels of users (What tariffs are distributed in this geographic location? And the mobile Internet?) </li><li>  Types of access devices (PC, phones, tablets) </li></ol><br>  <b>All recommendations are given for modern PC machines and connections of 8 megabits per second with a ping to the capital not exceeding 50ms.</b>  In your case, you need to adjust the numbers depending on the desired conditions. <br><br><h1>  What does page opening consist of </h1><br><ol><li>  Expectation <br><ol><li>  Waiting queue </li><li>  Proxy passing </li><li>  Resolve DNS </li><li>  Connection establishment (TCP handshakes) </li><li>  SSL handshake </li><li>  Submit request </li><li>  Waiting for response (time before receiving the first byte) </li></ol><br></li><li>  Data loading </li><li>  Running scripts </li><li>  Rendering </li><li>  Drawing </li></ol><br><h2>  Expectation </h2><br>  Waiting is all that happens until the moment the first byte is received. <br><br><h4>  Waiting queue </h4><br>  <b>Impact</b> : every request, if the limit is exceeded <br>  <b>Factors</b> : the number of simultaneously requested files from one domain <br>  <b>Good value</b> : 0 for meaningful content <br>  <b>Note if</b> for meaningful content the value is greater than zero. <br><br>  Browsers have a limit on the simultaneous number of connections (simultaneous downloads) with the same domain.  On average, from 4 to 8, but may vary depending on the device, browser and its version.  However, this limitation applies simultaneously to all tabs. <br><br>  If the browser needs to load more resources than the limit, it will start downloading the first and put the rest in the queue. <br><br>  Necessary steps: <br><br><ol><li>  Move the loading of meaningful content to the top of the queue </li><li>  If meaningful content still creates a queue, combine the relevant resources *.  CSS files in one, JS files in one, combine icons into sprites or place them directly into CSS (the cost usually does not exceed 10-20% and is worth it). </li><li>  Move loading optional content to end of queue </li><li>  Combine optional resources into groups.  It is not necessary to combine everything, everything - it is best to combine scripts, styles and graphics in blocks, because  they are sometimes independent and can be displayed asynchronously. </li></ol><br>  * And you can <a href="http://habrahabr.ru/post/242255/">do</a> it <a href="http://habrahabr.ru/post/242255/">like this</a> <br><div class="spoiler">  <b class="spoiler_title">Optimization errors</b> <div class="spoiler_text">  <b>Combine everything into 1 file (i.e., put everything straight into an HTML file, including graphics via inline image)</b> <br>  This will give some acceleration due to the fact that there will be no expectations, but: <br><ol><li>  Drawing will be only when everything is loaded.  HTML + CSS would be enough. </li><li>  Now the cache is useless.  If the site opens a second, then the second time will be a second (instead of a quarter, as described below). </li></ol><br>  Ideally, both the communication channel and processor resources should be loaded simultaneously, and not sequentially.  I did it on <a href="https://github.com/Zav39/yac2013/blob/gh-pages/index.html">yac2013</a> , not having time to properly separate these processes and having lost more than 100ms. <br><br>  <b>Well, then we put CSS right in HTML.</b> <br><br>  Yes, it will give a win on the first download.  But only. <br><br><ol><li>  The cache is useless, CSS is loaded every time. </li><li>  If the fonts are connected (you also connect them inline, right? And not by a separate file, otherwise just wait), we get + 200-500kb to download </li></ol><br>  <b>Mm, okay.</b>  <b>Let's then merge all-all js files into 1 and all-all css files into 1. Then we will fit into the limits of any browser, well, it will load quickly.</b> <br><br>  On the right track, but this is still incorrect.  You do not need all-all js and css files for the initial page rendering.  Even if the part is not used - they still take the channel and processor time.  Well and still at any change of the smallest file the cache is invalid and the user to load everything anew. <br></div></div><br>  <b>How to organize everything right away?</b> <br><br>  Fonts and inline icons in CSS.  Make the CSS necessary for drawing, and the rest of the load on 1 through the dependency manager.  The required CSS is loaded from the page header, the rest via js.  Js exactly the same.  Post static on CDN. <br><br><h4>  Proxy passing </h4><br>  If the work occurs through any proxy connection, then it imposes its own limitations and increases the latency of response and final load.  We cannot influence this parameter, therefore there is no sense to linger on its consideration. <br><br><h4>  Recognition of DNS records </h4><br>  <b>Impact</b> : once per <abbr title="Time to live">TTL</abbr> <br>  <b>Factors</b> : number of used domains, location of registrar name servers <br>  <b>Good value</b> : 20-50ms <br>  <b>Pay attention if</b> your value exceeds 80ms for the target audience <br><br>  Each domain used (including the first document) on the page requires a full domain recognition cycle, which usually takes from 10 to 120ms.  Many DNS servers have mirrors around the world. <br><br>  Necessary steps: <br><br><ol><li>  Determine the geographical location of your target audience and choose a registrar with a good location of name servers for you. </li><li>  If you do not plan to migrate servers, you can increase the domain <abbr title="Time to live">TTL</abbr> to large values ‚Äã‚Äã- a day, or even a week. </li><li>  If you are planning to request subdomains or other domains from scripts or other deferred sources, you must specify <pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dns-prefetch"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"//example.com"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre>  in the main document. </li></ol><br><h4>  Connection setup </h4><br>  <b>Impact</b> : every request after idle <br>  <b>Factors</b> : distance to server with data <br>  <b>Good value</b> : 50-80ms <br>  <b>Note if the</b> value is 150ms or more. <br><br>  Before you start sending and receiving data, the browser establishes a connection to the server.  It consists of three packet transmissions and passes for 1.5 <abbr title="Round-trip time">RTT</abbr> (ping to server x 1.5).  A connection is established each time, as it is necessary to download data if there are no connections available.  As we remember, the browser does not open more than a certain number of connections.  If the data enters the queue for loading and there are active connections, then they will be used as soon as they become free, i.e.  no additional delay.  If all relevant information is immediately contained in the first html document, we get a delay of 1.5 pings, and if at least something else is loaded, we get a delay of 3 pings.  If the ping is 100ms, we get a total loss of 300ms already. <br><br>  Steps: <br><br><ol><li>  Return meaningful information in the first request (immediately reduces the impact of this factor by half). </li><li>  Determine the geographical location of the target audience, place the server (s) as close as possible. </li></ol><br><h4>  SSL </h4><br>  <b>Influence, overclocking options, factors</b> : the same as when setting up a connection <br>  <b>Good value</b> : 100-150ms <br>  <b>Note if the</b> value is 250ms or higher. <br><br>  Using SSL increases the connection setup <a href="http://www.semicomplete.com/blog/geekery/ssl-latency.html">time several times</a> . <br><br>  The number of transmitted packets to establish a connection is increased by 3 to 12 and 3 <abbr title="Round-trip time">RTT</abbr> .  This means that at a delay of 100ms, if the data is not contained in the original document, we will receive at least 600ms of delay.  Server time can be neglected, because  in this case it will be small. <br><br>  Steps: <br><br><ol><li>  Understand that SSL is really needed and refuse where it is not needed </li><li>  Steps to speed up the connection also speed up the SSL download. </li></ol><br><h4>  Submit request </h4><br>  Usually takes <a href="https://developers.google.com/web/tools/chrome-devtools/profile/network-performance/resource-loading">less than 1ms</a> .  Honestly, from practice, I do not remember a single situation when there was more. <br><br>  Quite an important point that I would like to point out - absolutely with each request a series of headers is sent.  Cookies are also headers.  If you put a lot of data in a cookie, it will be sent to the server every time.  If you really need to use a lot of heavy cookies (I don‚Äôt know why, but let's say), specify the correct paths with them, so that they would be sent only to the right place. <br><br><h4>  waiting for an answer </h4><br>  <b>Impact</b> : each request <br>  <b>Factors</b> : server uptime <br>  <b>Good value</b> : 10-50ms <br>  <b>Note if the</b> value is more than 100ms <br><br>  Usually this step gives the greatest speed increase.  The server cache is worth a separate article, and, perhaps, I will ripen to write it somehow.  The main influence on waiting for a response is played by the execution time of scripts on the server - processing the request, database requests, generating a response, etc.  The main secret of the speed of this stage is to have a ready answer to what they want to request.  Simply put - cache. <br><br>  Steps: <br><br><ol><li>  Determine what data to cache and how. </li><li>  Return all cached data </li></ol><br><h3>  Data loading </h3><br>  <b>Impact</b> : each request <br>  <b>Factors</b> : data size, (user channel) <br>  <b>Good value:</b> depending on the providers in geography, up to a second, taking into account the previous steps <br>  <b>Note if</b> more than 2 seconds <br><br>  Finally, the server began to return data.  The main criterion for loading them is their size. <br>  We will not consider the high speed of a small amount of data, since  An ordinary site, nevertheless, takes from 500kb. <br><br>  <b>Important</b> : with increasing bandwidth user channel decreases the influence of this factor.  If the main target audience is in the capital and has 100mb / s (vs. 8ms / s taken as the standard), then 1 megabyte will load an order of magnitude faster and from the longest factor it can become one of insignificant. <br><br>  It is also worth mentioning about "TCP slow start", but this is a topic for a separate post (it was somewhere in Habr√©, I did not find it). <br><br>  Steps: <br><br><ol><li>  Enable data compression on the server.  But, it is necessary to take into account that unarchiving data also takes time (depends on the end device), and, in some situations, sending uncompressed data is justified. </li><li>  Remove unused data from the download.  It often happens that a number of libraries are connected, and, after a while, some become irrelevant, but they are forgotten to be removed. </li><li>  Separate data into necessary and secondary, and load in that order.  Sometimes you can get an order of magnitude gain. </li></ol><br><h3>  Running scripts </h3><br>  <b>Influence</b> : always <br>  <b>Factors</b> : volume of scripts, algorithms used <br>  <b>Good value</b> : 0-50ms to display meaningful content, no further significant <br>  <b>Pay attention if</b> after downloading the data more than 200ms go "nowhere" <br><br>  After downloading the scripts, the browser takes some time to parse and execute them. <br><br><h3>  Rendering </h3><br>  <b>Influence</b> : always <br>  <b>Factors</b> : the volume and quality of styles and nesting of site blocks <br>  <b>Good value</b> : up to 50ms <br>  <b>Pay attention if</b> rendering takes more than 200ms <br><br>  After loading all the styles, the browser starts the calculations where to place which block, where to transfer lines, etc. <br>  Once I saw a 20% effect on the speed of the site operation of extremely large HTML nesting.  Seriously - the optimization of just HTML nesting gave a 20% more responsive site. <br><br>  Steps: <br><br><ol><li>  Reduce the number of styles </li><li>  Get rid of the reassigning styles whenever possible (when there is a bunch of overlapping rules for one property and only one is executed. Look towards OOCSS </li></ol><br><h3>  Drawing </h3><br>  <b>Influence</b> : always <br>  <b>Factors</b> : the number of "heavy" items with post-processing, such as, for example, shadows.  Number of graphics. <br>  <b>Good value</b> : up to 50ms <br>  <b>Pay attention if</b> drawing takes more than 200ms <br><br>  The main influence on the rendering time is played by changing parts on the page.  Tritely one gif'ka will give growth more than anything else. <br><br>  Steps: <br><ol><li>  Reduce the number of graphics and dynamic elements on the page </li></ol><br><h2>  <abbr title="Content Delivery Network">CDN</abbr> </h2><br>  Proper use of CDN will allow you to solve many problems and significantly speed up the loading of your site. <br>  Starting with the fact that the delay in creating a connection will be within 20ms, so, sometimes, the CDN provides the download speed faster than the user‚Äôs tariff rate, due to the location on the provider's servers (as Google does, for example). <br><br><h2>  Browser Cache </h2><br>  When a user opens a site for the first time - the cache will not help us in any way (except for using public CDN with libraries, but this is a topic for a separate article and a security control issue).  But with repeated visits, the cache provides tremendous benefits.  All unchangeable content should be placed in the browser cache.  Graphics, styles, scripts.  Also in the cache, you can add responses to the API, but very carefully.  With proper management of the cache, we will have: <br><br><ol><li>  75ms to establish a connection (without additional connections, data from the cache) </li><li>  25ms server timeout </li><li>  50ms to render </li><li>  10ms to draw </li><li>  100ms of data load (instead of 650) </li></ol><br>  Those.  <b>full site loading within a quarter of a second!</b> <br><br><h2>  Sockets </h2><br>  First of all, to work with sockets it is necessary that any scripts be loaded and executed.  Subsequently, of course, we get rid of the costs of creating a connection and queue restrictions, but we get problems with managing the cache (we will have to manage it manually). <br><br>  <b>Verdict</b> : Sockets must be used for dynamic, non-cached, non-bulk content. <br><br><h2>  I have a <abbr title="Single page application">SPA</abbr> , how to be? </h2><br>  All tips apply more to the SPA.  Usually, a SPA has at least 1 step more until the content is rendered, i.e.  Received HTML -&gt; Received scripts -&gt; Download content from API.  From here we receive at least one more RTT, and after loading of scripts. <br><br>  Actions: <br><br><ol><li>  Return HTML immediately with data.  Modern template engines (such as handlebars) are not tied to the language, and they are easy to generate both on the server and on the client.  At least for unauthorized users.  The authorized already have a cache and the cost will be minimal. </li><li>  Download in the first place only the necessary controllers, models, views and what else do you have there?  It's easier than it seems, if you prescribe dependencies or use <abbr title="Asynchronous module definition">AMD</abbr> </li></ol><br><div class="spoiler">  <b class="spoiler_title">Optimization errors</b> <div class="spoiler_text">  <b>But what if you move the data requests directly to the HTML file, so that they would be added to the cache, and when the scripts are loaded everything was already there?</b> <br><br>  First try to understand what you can win.  With this approach, we can only win 1 RTT (due to parallelism, although we will block one channel with this) and the server timeout. <br><br>  If your server responds for a long time and for some reason you do not want to optimize it, so that this expectation would be ~ 20ms, then yes, this approach will give a gain (compared to 3 steps).  But if you did everything right, then we get RTT + 20ms.  Those.  maximum 50-70 milliseconds.  It is so not serious gain in comparison with potential problems from this action that it is not worth it that much. <br><br>  Possible problems: <br><br><ol><li>  The script was loaded before the data was received and has already sent a new request. </li></ol><br></div></div><br><h2>  Subjective optimizations </h2><br>  It happens that you can do so that it would seem that it works faster when, in fact, the same way.  Good to use.  As an example, I can give the translation of listening to events in the SPA with a click on mousedown (in addition to the click!).  A small hack that allows you to "try": <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.onmousedown = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ e.target.click(); }</code> </pre><br>  The trick is that the whole click of the user takes up to 50ms, and the onmousedown event takes place in the middle.  Thus, starting processing earlier, we can give the result earlier.  If our processing does not exceed the speed of a user‚Äôs click, then the latter will have the feeling that he hasn‚Äôt even clicked yet, but everything has already seemed - wow!  Similar tricks should be done for each project individually. <br><br>  In general, of course, this is a special case - if you can calculate everything in advance, you can immediately show it. <br><br>  You can also cache in mouseover more than 0.1s, for example. <br><br><h1>  Total </h1><br>  User: without proxy, with a channel width of 8 megabits per second and <abbr title="Round-trip time">RTT</abbr> 50ms to our server has: <br><br><ol><li>  50ms DNS resolution </li><li>  75ms to establish a connection (without SSL) (+ 75ms second and subsequent parallel connections) </li><li>  25ms server timeout </li><li>  0ms to run scripts </li><li>  50ms to render </li><li>  10ms to draw </li></ol><br>  <b>285ms cost</b> <br><br>  It remains 700ms to download content, which under our conditions is approximately equal to 700kb of data.  Given the compression, this may be around 3.5MB of data, which is enough for most sites. <br><br>  <b>Total: 1 second</b> <br><br>  When reopened, the delay goes to the DNS and some of the data is loaded from the cache. <br><br>  <b>Total: ~ 0.4 seconds with cache</b> <br><br>  Make quick sites and everyone will be happy.  If with all this you still <a href="http://habrahabr.ru/post/242161/">show information to the user when the connection is disconnected</a> , then it will generally be gorgeous. <br><br>  Bonus you can read <a href="http://www.amazon.com/High-Performance-Browser-Networking-performance/dp/1449344763">High Performance Browser Networking</a> <br><br>  Ask questions - I will answer, I will add article. <br><br>  looking for a job. </div><p>Source: <a href="https://habr.com/ru/post/274129/">https://habr.com/ru/post/274129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274103/index.html">Simple algebraic data types</a></li>
<li><a href="../274105/index.html">GOTPass: new passwordless user authentication system</a></li>
<li><a href="../274107/index.html">Erlang for web development (2) -> DB and deploy;</a></li>
<li><a href="../274109/index.html">The digest of interesting materials for the mobile developer # 135 (December 21-27)</a></li>
<li><a href="../274117/index.html">The botnet of thousands of hacked Aethra routers was used to attack Wordpress sites</a></li>
<li><a href="../274131/index.html">Monitoring Dynamic XML Documents</a></li>
<li><a href="../274135/index.html">Animator - what is it? Why is it needed? Why use it instead of Animation?</a></li>
<li><a href="../274137/index.html">Development of digital hardware in C ++ / SystemC through the eyes of the programmer SystemVerilog</a></li>
<li><a href="../274139/index.html">Functional Expressions in JavaScript</a></li>
<li><a href="../274141/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ191 (December 20 - 27, 2015)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>