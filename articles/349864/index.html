<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Natasha - a library for extracting structured information from texts in Russian</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is a standard task of extracting named entities from text ( NER ). At the input, text, output structured, normalized objects, for example, with ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Natasha - a library for extracting structured information from texts in Russian</h1><div class="post__text post__text-html js-mediator-article">  There is a standard task of extracting named entities from text ( <a href="https://en.wikipedia.org/wiki/Named-entity_recognition">NER</a> ).  At the input, text, output structured, normalized objects, for example, with names, addresses, dates: <br><br><img src="https://habrastorage.org/webt/8q/ml/f1/8qmlf1nmng_9r73nc42p2vhceia.png"><br><br>  The task is old and well studied, for English there are a lot of commercial and open solutions: <a href="https://spacy.io/">Spacy</a> , <a href="https://nlp.stanford.edu/software/CRF-NER.shtml">Stanford NER</a> , <a href="https://opennlp.apache.org/">OpenNLP</a> , <a href="http://www.nltk.org/">NLTK</a> , <a href="https://github.com/mit-nlp/MITIE">MITIE</a> , <a href="https://cloud.google.com/natural-language/">Google Natural Language API</a> , <a href="https://www.paralleldots.com/named-entity-recognition">ParallelDots</a> , <a href="https://aylien.com/text-api/">Aylien</a> , <a href="https://www.basistech.com/text-analytics/rosette/entity-extractor/">Rosette</a> , <a href="https://www.textrazor.com/">TextRazor</a> .  There are also good solutions for the Russian, but they are mostly closed: <a href="https://dadata.ru/">DaData</a> , <a href="http://pullenti.ru/%3FAspxAutoDetectCookieSupport%3D1">Pullenti</a> , <a href="https://www.abbyy.com/ru-ru/infoextractor/">Abbyy Infoextractor</a> , <a href="http://dictum.ru/ru/named-entities-extraction/blog">Dictum</a> , <a href="http://eurekaengine.ru/">Eureka</a> , <a href="http://www.promt.ru/press/news/57586/">Promt</a> , <a href="http://www.rco.ru/%3Fpage_id%3D3554">RCO</a> , <a href="http://www.aot.ru/">AOT</a> , <a href="http://www.ixlab.ru/site/onwork">Ahunter</a> .  From the open, I know only <a href="https://tech.yandex.ru/tomita/">Tomita-parser</a> and fresh <a href="https://github.com/deepmipt/ner">Deepmipt NER</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I do data analysis, word processing is one of the most frequent tasks.  In practice, it turns out that, for example, to extract names from the Russian text is not at all easy.  There is a <a href="">ready-made solution in Tomita-parser</a> , but there is inconvenient integration with Python.  Recently there was a <a href="https://github.com/deepmipt/ner">solution from the guys from iPavlov</a> , but there the names do not lead to normal form.  For extracting, for example, addresses (‚Äú8, Marta St., 4‚Äù, ‚ÄúLeninsky passage, 15‚Äù) I don‚Äôt know open solutions, there is a <a href="https://github.com/openvenues/pypostal">pypostal</a> , but to parse the addresses, and not search for them in the text.  With non-standard tasks such as extracting references to normative acts (‚ÄúArt. 11 of the Civil Code of the Russian Federation‚Äù, ‚ÄúClause 1, Art. 6 of the Law No. 122-FZ‚Äù), it is not at all clear what to do. <br><br>  A year ago, <a href="https://github.com/dveselov">Dima Veselov</a> began the project <a href="https://github.com/natasha">Natasha</a> .  Since then, the code has been significantly improved.  Natasha has been used in several large projects.  Now we are ready to tell Habr users about it. <br><blockquote>  Natasha is an analogue of Tomita-parser for Python ( <a href="https://github.com/natasha/yargy">Yargy-parser</a> ) plus a set of ready-made rules for retrieving names, addresses, dates, amounts of money and other entities. </blockquote>  The article shows how to use the ready-made rules of Natasha and, most importantly, how to add your own using the Yargy-parser. <br><a name="habracut"></a><br><h2>  Ready rules </h2><br>  Now in Natasha there are rules for retrieving names, addresses, dates and amounts of money.  There are also rules for names of organizations and geographical objects, but they are not of very high quality. <br><br><h3>  Names </h3><br>  Using ready-made rules is simple: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> natasha <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> NamesExtractor <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> natasha.markup <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> show_markup, show_json extractor = NamesExtractor() text = <span class="hljs-string"><span class="hljs-string">'''      ,   , :       .       ,     .    1""  -   ,  ,  -  ,   ,    , !  ! '''</span></span> matches = extractor(text) spans = [_.span <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matches] facts = [_.fact.as_json <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matches] show_markup(text, spans) show_json(facts) &gt;&gt;&gt;      ,   , : [[  ]]  [[  ]].       ,     .    <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>  - [[  ]],  ,  - [[ ]],   ,    , !  ! [ { <span class="hljs-string"><span class="hljs-string">"first"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"middle"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"last"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-string"><span class="hljs-string">"first"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"middle"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"last"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-string"><span class="hljs-string">"first"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"middle"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"last"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-string"><span class="hljs-string">"first"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"middle"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ]</code> </pre> <br>  In 2016, the <a href="https://github.com/dialogue-evaluation/factRuEval-2016">factRuEval-2016</a> competition was held to retrieve named entities.  Among the participants were large companies: ABBYY, RCO.  In the top solutions, the F1-measure for names was 0.9+.  Natasha's <a href="https://github.com/natasha/natasha-factRuEval-2016/blob/master/notes.ipynb">result is worse - 0.78</a> .  The problem is mainly with foreign names and complex names, for example: "Haruki Murakami", "... the head of Afghanistan Hamid Karzai", "Ostap Bender meets Kisa Vorobyaninov ...".  For texts with Russian names, the <a href="https://github.com/natasha/natasha-examples/blob/master/02_sad/notes.ipynb">quality is ~ 0.95</a> .  You can, for example, extract the names of teachers from school sites, aggregate reviews: <br><img src="https://habrastorage.org/webt/nt/6z/or/nt6zorg21cs3wq_kg7xdeth-dns.png"><br><br><h3>  Addresses </h3><br>  The interface is the same as for names, only <code>NamesExtractor</code> changed to <code>AddressExtractor</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> natasha <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AddressExtractor <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> natasha.markup <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> show_markup, show_json extractor = AddressExtractor() text = <span class="hljs-string"><span class="hljs-string">'''       ‚Ññ71    2.     .51 (   :  , )  .               7 881 574-10-02   ,.,. , .8 , 4 '''</span></span> matches = extractor(text) spans = [_.span <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matches] facts = [_.fact.as_json <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matches] show_markup(text, spans) show_json(facts) &gt;&gt;&gt;       ‚Ññ<span class="hljs-number"><span class="hljs-number">71</span></span>  [[  <span class="hljs-number"><span class="hljs-number">2</span></span>]].   [[  <span class="hljs-number"><span class="hljs-number">.51</span></span>]] (   :  , )  .               <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">881</span></span> <span class="hljs-number"><span class="hljs-number">574</span></span><span class="hljs-number"><span class="hljs-number">-10</span></span><span class="hljs-number"><span class="hljs-number">-02</span></span>  [[ ,.,. , <span class="hljs-number"><span class="hljs-number">.8</span></span> , <span class="hljs-number"><span class="hljs-number">4</span></span>]] [ { <span class="hljs-string"><span class="hljs-string">"parts"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-string"><span class="hljs-string">"number"</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span> } ] }, { <span class="hljs-string"><span class="hljs-string">"parts"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-string"><span class="hljs-string">"number"</span></span>: <span class="hljs-string"><span class="hljs-string">"51"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ] }, { <span class="hljs-string"><span class="hljs-string">"parts"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-string"><span class="hljs-string">"number"</span></span>: <span class="hljs-string"><span class="hljs-string">"8 "</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-string"><span class="hljs-string">"number"</span></span>: <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ] } ]</code> </pre><br>  In factRuEval-2016, participants were asked to retrieve names, organizations, and geographical features.  Independent test data for assessing the quality of work with addresses, as far as I know, does not exist.  For several years of work we have accumulated hundreds of thousands of lines of the form ‚ÄúAddress: 443041, Samara, ul.  Leninskaya, d.168 ‚Äù,‚Äú Address Irkutsk, ul.  Baikal, d. 133, office 1 (entrance from the courtyard). ‚Äù.  To assess the quality, a random sample of 1000 addresses was made, the results were checked manually, <a href="https://github.com/natasha/natasha-examples/blob/master/04_address/notes.ipynb">~ 90% of the lines were processed correctly</a> .  Problems arise mainly with street names, for example: ‚Äú  Volzhsk, 2nd Industrial, p. 2 ‚Äù,‚Äú 111674, Moscow, Dmitrievskogo, d. 17 ‚Äù. <br><br>  In 2017, in parallel with the history of reconstruction in Moscow, new Land Use and Development Rules (PZZ) were discussed.  A survey of the population was conducted.  More than 100,000 comments were made publicly available in the form of a huge pdf-file.  <a href="http://telegra.ph/PZZ---analitika-proshedshih-slushanij-05-01">Nikita Kuznetsov, with the help of Natasha, extracted the mentioned addresses</a> and looked in which districts supported the law, and in which not: <br><img src="https://habrastorage.org/webt/wb/dy/ro/wbdyropt6zv2mnpkc__eghmmw3u.png"><br><br>  Visually assess the quality of the <code>AddressExtractor</code> on the dataset with comments to the DSS can be in the <a href="https://github.com/natasha/natasha-examples/blob/master/03_pzz/notes.ipynb">repository with examples</a> . <br><br><h3>  Other rules </h3><br>  There are also rules for dates and money in Natasha.  The interface is the same as <code>AddressExtractor</code> and <code>NamesExtractor</code> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> natasha <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( NamesExtractor, AddressExtractor, DatesExtractor, MoneyExtractor ) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> natasha.markup <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> show_markup, show_json extractors = [ NamesExtractor(), AddressExtractor(), DatesExtractor(), MoneyExtractor() ] text = <span class="hljs-string"><span class="hljs-string">'''          10  1970 ,     -, . ,  5/1 8 000 ( )  00       '''</span></span> spans = [] facts = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> extractor <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> extractors: matches = extractor(text) spans.extend(_.span <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matches) facts.extend(_.fact.as_json <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matches) show_markup(text, spans) show_json(facts) &gt;&gt;&gt;     [[  ]]   [[<span class="hljs-number"><span class="hljs-number">10</span></span>  <span class="hljs-number"><span class="hljs-number">1970</span></span> ]],    [[ -, . ,  <span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>]][[]],  <span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span> [[<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span> ( )  <span class="hljs-number"><span class="hljs-number">00</span></span>]]       [ { <span class="hljs-string"><span class="hljs-string">"first"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"middle"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"last"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-string"><span class="hljs-string">"last"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-string"><span class="hljs-string">"parts"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"-"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-string"><span class="hljs-string">"number"</span></span>: <span class="hljs-string"><span class="hljs-string">"5/1"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ] }, { <span class="hljs-string"><span class="hljs-string">"year"</span></span>: <span class="hljs-number"><span class="hljs-number">1970</span></span>, <span class="hljs-string"><span class="hljs-string">"month"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"day"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> }, { <span class="hljs-string"><span class="hljs-string">"integer"</span></span>: <span class="hljs-number"><span class="hljs-number">8000</span></span>, <span class="hljs-string"><span class="hljs-string">"currency"</span></span>: <span class="hljs-string"><span class="hljs-string">"RUB"</span></span>, <span class="hljs-string"><span class="hljs-string">"coins"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ]</code> </pre><br>  Natasha's interface is very simple: <code>e = Extractor(); r = e(text); ...</code> <code>e = Extractor(); r = e(text); ...</code>  <code>e = Extractor(); r = e(text); ...</code>  User is not available any settings.  In practice, getting by with ready-made rules is rarely obtained.  For example, Natasha will not understand the date "April 21, 2017," because the rules do not include the day number in quotes.  The library will not understand the address ‚ÄúLyubertsy district, village Motyakovo, d. 61/2‚Äù, because there is no street name in it. <br><br>  Often you have to go down to a lower level, add ready-made rules and write your own.  For this uses Yargy-parser.  All the rules in Natasha are written on it.  Yargy is a complex and interesting library, in this article we will consider only simple examples of use. <br><br><h2>  Yargy parser </h2><br>  Yargy-parser is an analogue of Yandex <a href="https://tech.yandex.ru/tomita/">Tomita parser</a> for Python.  The rules for extracting entities are described using <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D0%25BD%25D0%25BE-%25D1%2581%25D0%25B2%25D0%25BE%25D0%25B1%25D0%25BE%25D0%25B4%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0">context-free grammars</a> and dictionaries. <br><br><h3>  Grammar </h3><br>  Grammar in Yargy are written on a special <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> .  So, for example, a simple rule for extracting dates in ISO format (‚Äú2018-02-23‚Äù, ‚Äú2015-12-31‚Äù) will look like: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> yargy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> rule, and_, Parser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> yargy.predicates <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gte, lte DAY = and_( gte(<span class="hljs-number"><span class="hljs-number">1</span></span>), lte(<span class="hljs-number"><span class="hljs-number">31</span></span>) ) MONTH = and_( gte(<span class="hljs-number"><span class="hljs-number">1</span></span>), lte(<span class="hljs-number"><span class="hljs-number">12</span></span>) ) YEAR = and_( gte(<span class="hljs-number"><span class="hljs-number">1</span></span>), lte(<span class="hljs-number"><span class="hljs-number">2018</span></span>) ) DATE = rule( YEAR, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, MONTH, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, DAY ) parser = Parser(DATE) text = <span class="hljs-string"><span class="hljs-string">''' 2018-02-23, 2015-12-31; 8 916 364-12-01'''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parser.findall(text): print(match.span, [_.value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> match.tokens]) &gt;&gt;&gt; [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>) [<span class="hljs-string"><span class="hljs-string">'2018'</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">'02'</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">'23'</span></span>] &gt;&gt;&gt; [<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>) [<span class="hljs-string"><span class="hljs-string">'2015'</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">'12'</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">'31'</span></span>] &gt;&gt;&gt; [<span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>) [<span class="hljs-string"><span class="hljs-string">'364'</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">'12'</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">'01'</span></span>]</code> </pre><br>  While not very impressive, similar functionality can be obtained by the regularity <code>r'\d\d\d\d-\d\d-\d\d'</code> , although it will throw a nonsense like "1234-56-78". <br><br><h3>  Predicates </h3><br>  <code>gte</code> and <code>lte</code> in the example above are predicates.  <a href="http://yargy.readthedocs.io/ru/latest/reference.html">Many ready-made predicates</a> <a href="http://yargy.readthedocs.io/ru/latest/reference.html">are</a> built into the parser, <a href="http://yargy.readthedocs.io/ru/latest/reference.html">there is an opportunity to add your own</a> .  <a href="http://pymorphy2.readthedocs.io/">Pymorphy2 is</a> used to determine the morphology of words.  For example, the predicate, <code>gram('NOUN')</code> works on nouns, <code>normalized('')</code> marks all forms of the word "January."  Add rules for dates like "January 8, 2014", "June 15, 2001": <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> yargy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> or_ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> yargy.predicates <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> caseless, normalized, dictionary MONTHS = { <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span> } MONTH_NAME = dictionary(MONTHS) YEAR_WORDS = or_( rule(caseless(<span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-string"><span class="hljs-string">'.'</span></span>), rule(normalized(<span class="hljs-string"><span class="hljs-string">''</span></span>)) ) DATE = or_( rule( YEAR, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, MONTH, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, DAY ), rule( DAY, MONTH_NAME, YEAR, YEAR_WORDS.optional() ) ) parser = Parser(DATE) text = <span class="hljs-string"><span class="hljs-string">''' 8  2014 , 15  2001 ., 31  2018'''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parser.findall(text): print(match.span, [_.value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> match.tokens]) &gt;&gt;&gt; [<span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-number"><span class="hljs-number">36</span></span>) [<span class="hljs-string"><span class="hljs-string">'15'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'.'</span></span>] &gt;&gt;&gt; [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>) [<span class="hljs-string"><span class="hljs-string">'8'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'2014'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>] &gt;&gt;&gt; [<span class="hljs-number"><span class="hljs-number">38</span></span>, <span class="hljs-number"><span class="hljs-number">53</span></span>) [<span class="hljs-string"><span class="hljs-string">'31'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'2018'</span></span>]</code> </pre><br><h3>  Interpretation </h3><br>  Finding a substring with a fact is usually not enough.  For example, for the text ‚ÄúMay 8 by order of President Vladimir Putin‚Äù, the parser should return not just ‚ÄúMay 8th‚Äù, ‚ÄúVladimir Putin‚Äù, but <code>Date(month=5, day=8)</code> , <code>Name(first='', last='')</code> , Yargy provides an interpretation procedure for this.  The result of the parser is the parse tree: <br><br><pre> <code class="python hljs">match = parser.match(<span class="hljs-string"><span class="hljs-string">'05  2011 '</span></span>) match.tree.as_dot</code> </pre><br><img src="https://habrastorage.org/webt/-7/pd/ed/-7pdedivb-jrdjeenxdgkkglv9s.png"><br>  (R0, R1 - technical vertices, ‚ÄúR‚Äù short for ‚ÄúRule‚Äù) <br><br>  For interpretation, the user ‚Äúhangs‚Äù tagging on the tree nodes using the <code>.interpretation(...)</code> method: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> yargy.interpretation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fact Date = fact( <span class="hljs-string"><span class="hljs-string">'Date'</span></span>, [<span class="hljs-string"><span class="hljs-string">'year'</span></span>, <span class="hljs-string"><span class="hljs-string">'month'</span></span>, <span class="hljs-string"><span class="hljs-string">'day'</span></span>] ) DAY = and_( gte(<span class="hljs-number"><span class="hljs-number">1</span></span>), lte(<span class="hljs-number"><span class="hljs-number">31</span></span>) ).interpretation( Date.day ) MONTH = and_( gte(<span class="hljs-number"><span class="hljs-number">1</span></span>), lte(<span class="hljs-number"><span class="hljs-number">12</span></span>) ).interpretation( Date.month ) YEAR = and_( gte(<span class="hljs-number"><span class="hljs-number">1</span></span>), lte(<span class="hljs-number"><span class="hljs-number">2018</span></span>) ).interpretation( Date.year ) MONTH_NAME = dictionary( MONTHS ).interpretation( Date.month ) DATE = or_( rule(YEAR, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, MONTH, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, DAY), rule( DAY, MONTH_NAME, YEAR, YEAR_WORDS.optional() ) ).interpretation(Date) match = parser.match(<span class="hljs-string"><span class="hljs-string">'05  2011 '</span></span>) match.tree.as_dot</code> </pre><br><img src="https://habrastorage.org/webt/xf/z2/oo/xfz2oo5qbkkm434hwpkqogsatjq.png"><br><br><pre> <code class="python hljs">parser = Parser(DATE) text = <span class="hljs-string"><span class="hljs-string">'''8  2014 , 2018-12-01'''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parser.findall(text): print(match.fact) &gt;&gt;&gt; Date(year=<span class="hljs-string"><span class="hljs-string">'2018'</span></span>, month=<span class="hljs-string"><span class="hljs-string">'12'</span></span>, day=<span class="hljs-string"><span class="hljs-string">'01'</span></span>) &gt;&gt;&gt; Date(year=<span class="hljs-string"><span class="hljs-string">'2014'</span></span>, month=<span class="hljs-string"><span class="hljs-string">''</span></span>, day=<span class="hljs-string"><span class="hljs-string">'8'</span></span>)</code> </pre><br><h3>  Normalization </h3><br>  In the example with dates, you need to bring the names of the months, days and years to numbers; for this, the normalization procedure is built into Yargy.  Inside <code>.interpretation(...)</code> user specifies how to normalize the fields: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> date Date = fact( <span class="hljs-string"><span class="hljs-string">'Date'</span></span>, [<span class="hljs-string"><span class="hljs-string">'year'</span></span>, <span class="hljs-string"><span class="hljs-string">'month'</span></span>, <span class="hljs-string"><span class="hljs-string">'day'</span></span>] ) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Date)</span></span></span><span class="hljs-class">:</span></span> @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_datetime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> date(self.year, self.month, self.day) MONTHS = { <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span> } DAY = and_( gte(<span class="hljs-number"><span class="hljs-number">1</span></span>), lte(<span class="hljs-number"><span class="hljs-number">31</span></span>) ).interpretation( Date.day.custom(int) ) MONTH = and_( gte(<span class="hljs-number"><span class="hljs-number">1</span></span>), lte(<span class="hljs-number"><span class="hljs-number">12</span></span>) ).interpretation( Date.month.custom(int) ) YEAR = and_( gte(<span class="hljs-number"><span class="hljs-number">1</span></span>), lte(<span class="hljs-number"><span class="hljs-number">2018</span></span>) ).interpretation( Date.year.custom(int) ) MONTH_NAME = dictionary( MONTHS ).interpretation( Date.month.normalized().custom(MONTHS.__getitem__) ) DATE = or_( rule(YEAR, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, MONTH, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, DAY), rule( DAY, MONTH_NAME, YEAR, YEAR_WORDS.optional() ) ).interpretation(Date) parser = Parser(DATE) text = <span class="hljs-string"><span class="hljs-string">'''8  2014 , 2018-12-01'''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parser.findall(text): record = match.fact print(record, repr(record.as_datetime)) &gt;&gt;&gt; Date(year=<span class="hljs-number"><span class="hljs-number">2018</span></span>, month=<span class="hljs-number"><span class="hljs-number">12</span></span>, day=<span class="hljs-number"><span class="hljs-number">1</span></span>) datetime.date(<span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt;&gt; Date(year=<span class="hljs-number"><span class="hljs-number">2014</span></span>, month=<span class="hljs-number"><span class="hljs-number">1</span></span>, day=<span class="hljs-number"><span class="hljs-number">8</span></span>) datetime.date(<span class="hljs-number"><span class="hljs-number">2014</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>) match = parser.match(<span class="hljs-string"><span class="hljs-string">'31  2014 .'</span></span>) match.fact.as_datetime &gt;&gt;&gt; ValueError: day <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> out of range <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> month</code> </pre><br>  Hurray, we repeated a small piece of the <a href="https://github.com/scrapinghub/dateparser">dateparser</a> library <a href="https://github.com/scrapinghub/dateparser">functionality</a> .  If you need to extract from the text, for example, only dates, then you should choose a ready-made specialized library.  The solution will work faster, the quality will be higher.  Yargy is needed for voluminous, non-standard tasks. <br><br><h3>  Matching </h3><br>  Consider a simple rule for retrieving names.  The <a href="http://opencorpora.org/">Opencorpora</a> dictionary, which uses pymorphy2, is labeled <a href="http://opencorpora.org/dict.php%3Fact%3Dedit%26id%3D210873"><code>Name</code></a> for names, <a href="http://opencorpora.org/dict.php%3Fact%3Dedit%26id%3D390709"><code>Surn</code></a> for names.  Let's take the name as a couple of words <code>Name Surn</code> or <code>Surn Name</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> yargy.predicates <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gram Name = fact( <span class="hljs-string"><span class="hljs-string">'Name'</span></span>, [<span class="hljs-string"><span class="hljs-string">'first'</span></span>, <span class="hljs-string"><span class="hljs-string">'last'</span></span>] ) FIRST = gram(<span class="hljs-string"><span class="hljs-string">'Name'</span></span>).interpretation( Name.first.inflected() ) LAST = gram(<span class="hljs-string"><span class="hljs-string">'Surn'</span></span>).interpretation( Name.last.inflected() ) NAME = or_( rule( FIRST, LAST ), rule( LAST, FIRST ) ).interpretation( Name )</code> </pre><br>  There are two problems with this solution: <br><br>  1. The rule marks the name and surname in different cases (‚ÄúIvanova Lyosha‚Äù, ‚ÄúPetrova Roma‚Äù) <br>  2. Female names become male after normalization <br><br><pre> <code class="python hljs">parser = Parser(NAME) text = <span class="hljs-string"><span class="hljs-string">''' ...       ... ...      ... '''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parser.findall(text): print(match.fact) &gt;&gt;&gt; Name(first=<span class="hljs-string"><span class="hljs-string">''</span></span>, last=<span class="hljs-string"><span class="hljs-string">''</span></span>) &gt;&gt;&gt; Name(first=<span class="hljs-string"><span class="hljs-string">''</span></span>, last=<span class="hljs-string"><span class="hljs-string">''</span></span>) &gt;&gt;&gt; Name(first=<span class="hljs-string"><span class="hljs-string">''</span></span>, last=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre><br>  To solve these problems in Yargy there is a matching mechanism.  Using the <code>.match(...)</code> method, the user specifies restrictions on the rules: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> yargy.relations <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gnc_relation gnc = gnc_relation() <span class="hljs-comment"><span class="hljs-comment">#   gender, number  case (,   ) Name = fact( 'Name', ['first', 'last'] ) FIRST = gram('Name').interpretation( Name.first.inflected() ).match(gnc) LAST = gram('Surn').interpretation( Name.last.inflected() ).match(gnc) NAME = or_( rule( FIRST, LAST ), rule( LAST, FIRST ) ).interpretation( Name ) parser = Parser(NAME) text = ''' ...       ... ...      ... ''' for match in parser.findall(text): print(match.fact) &gt;&gt;&gt; Name(first='', last='') &gt;&gt;&gt; Name(first='', last='')</span></span></code> </pre><br><h2>  Advantages and disadvantages </h2><br>  Natasha provides solutions licensed under the MIT license, which were not previously available (or I don‚Äôt know about them).  For example, previously it was impossible to simply take and extract structured names and addresses from a Russian-language text, but now it is possible.  Earlier for Python there wasn‚Äôt something like a Tomita parser, now there is. <br><br>  I will try to summarize the shortcomings: <br><ol><li>  Manually compiled rules. <br>  Natasha examines only those phrases for which the rules were drawn up in advance.  It may seem unrealistic to write rules, for example, for names in arbitrary text, they are too different.  In practice, everything is not so bad: <br><ol><li>  If you sit for a week, you can still make up rules for 80% of names. </li><li>  Usually you need to work not with arbitrary texts, but with texts in a <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25BE%25D0%25BB%25D0%25B8%25D1%2580%25D1%2583%25D0%25B5%25D0%25BC%25D1%258B%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA">controlled natural language</a> : summary, court decisions, regulations, a section of the site with contacts. </li><li>  In the rules for the Yargy-parser, you can use markup obtained by machine learning methods. </li></ol><br></li><li>  Slow work speed. <br>  Let's start with the fact that Yargy implements the <a href="https://en.wikipedia.org/wiki/Earley_parser">Earley parser</a> algorithm, its complexity is <code>O(n <sup>3</sup> )</code> , where <code>n</code> is the number of tokens.  The code is written on pure Python, with an emphasis on readability, not optimization.  In short, the library is slow.  For example, on the task of extracting names, Natasha <a href="https://github.com/natasha/natasha-benchmarks/blob/master/tomita/notes.ipynb">is 10 times slower than Tomita-parser</a> .  In practice, you can live with it: <br><ol><li>  PyPy helps well.  There is an acceleration of 10 times, on average, ~ 3-4 times. </li><li>  Running in multiple threads on multiple machines.  The task is well parallel, the cars for rent are now easily accessible. </li></ol><br></li><li>  Errors in standard rules. <br>  For example, the quality of extracting names from Natasha is very far from <a href="https://en.wikipedia.org/wiki/State_of_the_art">SOTA</a> .  In practice, the library does not always show good quality out of the box, you need to refine the rules for yourself. <br><br>  We hope the community will help improve the accuracy and completeness of the rules.  Write <a href="https://github.com/natasha/natasha/issues">bugreports</a> , send <a href="https://github.com/natasha/natasha/pulls">pullrequests</a> . <br></li></ol><br><br><h2>  Links </h2><br>  The address of the project on Gitkhab is simple - <a href="https://github.com/natasha/">github.com/natasha</a> . <br><br>  Installation - <code>pip install natasha</code> .  The library is tested on Python 2.7, 3.3, 3.4, 3.5, 3.6, PyPy and PyPy3. <br><br>  The documentation for the standard rules package is short, the interface is very simple - <a href="http://natasha.readthedocs.io/">natasha.readthedocs.io</a> .  The documentation for Yargy is more voluminous and complex - <a href="http://yargy.readthedocs.io/">yargy.readthedocs.io</a> .  Yargy is an interesting and challenging tool, perhaps existing documentation will not be enough.  There is a desire to publish on Habr√© a series of lessons on Yargy.  You can write in the comments, what topics should be covered, for example: <br><ol><li>  Execution speed, processing large volumes of text; </li><li>  Manual rules and machine learning, hybrid solutions; </li><li>  Examples of the use of the library in different areas: summary analysis, parsing of product names, chat bots. </li></ol><br><br>  Chat Natasha users - <a href="https://t.me/natural_language_processing">t.me/natural_language_processing</a> .  There you can try to ask questions about the library. <br><br>  Stand to demonstrate the standard rules - <a href="https://natasha.github.io/demo/">natasha.github.io/demo</a> .  You can enter your text, see how standard rules work out on it: <br><img src="https://habrastorage.org/webt/hr/_8/vi/hr_8vifjexel0um0qqaxxaps454.png"></div><p>Source: <a href="https://habr.com/ru/post/349864/">https://habr.com/ru/post/349864/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349852/index.html">Extension methods for .NET standard library types</a></li>
<li><a href="../349854/index.html">Migrate API and what it eat. On the example of the migration of the forum Drupal 7. Part 1</a></li>
<li><a href="../349858/index.html">How JS Works: Service Workers</a></li>
<li><a href="../349860/index.html">Regular expressions in Python from simple to complex. Details, examples, pictures, exercises</a></li>
<li><a href="../349862/index.html">Application Release Automation: Release Management Automation "Goes to the Cloud"</a></li>
<li><a href="../349866/index.html">W3View - straight web UI path</a></li>
<li><a href="../349868/index.html">Changes in the Java 10 Standard Library</a></li>
<li><a href="../349870/index.html">Parsing ICO TenX: scam or not?</a></li>
<li><a href="../349872/index.html">How are the address tips "Dadata"</a></li>
<li><a href="../349874/index.html">Blue Shift or iOS application launch time optimization. Yandex lecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>