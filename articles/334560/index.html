<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Let's play in Firebase</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inside: board games, NFC tags, Firebase, ESP 8266, RFID-RC522, Android and a pinch of magic. 

 My name is Oksana and I am an Android developer in a s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Let's play in Firebase</h1><div class="post__text post__text-html js-mediator-article">  Inside: board games, NFC tags, Firebase, ESP 8266, RFID-RC522, Android and a pinch of magic. <br><br><img src="https://habrastorage.org/web/abb/f48/60f/abbf4860f24c4dc4b1aadeefc431f7dc.png" alt="image" width="200" align="right">  My name is Oksana and I am an Android developer in a small but very cool <a href="https://www.facebook.com/trinitydigitalrus/">Trinity Digital</a> team.  Here I will talk about the experience of creating a desktop toy based on Firebase and all sorts of different pieces of hardware. <br><a name="habracut"></a><br>  It just so happened that the desire to gash something funny with us coincided with the need to conduct a Firebase meeting in the <a href="https://www.meetup.com/GDG-PTZ/">Google Developer Group</a> format in Petrozavodsk.  We began to think what could be arranged, so that it was interesting, and it was possible to show on the mitap, and then work on the development, but in the end got carried away in earnest and came up with a whole intellectual board game. <br><br><h2>  Idea: </h2><br>  Suppose there is a whole bunch of games of varying degrees of ‚Äúboardness‚Äù - MTG, Munchkin, DND, Evolution, Mafia, Scrabble, thousands of them.  We love the desktops for their atmosphericity and ‚Äúmateriality‚Äù, that is, for the opportunity to hold beautiful cards / chips in their hands, look at them, soundfully slam them on the table.  And all the desktops are different in many ways, but they have a number of drawbacks that prevent you from plunging into the game with your head: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  The need to remember the rules: you must keep in mind which actions are correct and which are not, how the order of moves is determined, what are the exceptions in the process, at which point you need to count the glasses for a whole lot more; </li><li>  Counting values: how much health do I have now?  And what bonus will give me this card with all my stats?  Did I pass the skill check now under these environmental conditions? </li><li>  A waste of time in the proceedings in the system, recording, throwing dice ... </li><li>  The inability to create a fairly complete and realistic model, because it lives in the heads of the players, and the heads are limited in capacity; </li><li>  The players have meta-information about the system and the rules: you can not enjoy the knowledge of the system and discover new things in the game world, because you need to know everything in advance, because you control the gameplay. </li></ul><br>  All these things are a little unsettling, make distractions, reduce the dynamics.  And we came up with what needs to be done: shove them ... into the server!  The basic idea of ‚Äã‚Äãour toy is this: let all the rules, sequence of moves, counting values, randomizer and other logical parts be the responsibility of some external system.  And players will make moves with full dedication, learn the patterns of the game world, build strategies, try new things and become emotionally involved. <br><br>  About the concept of the toy, to which we want to come to the finals, I will not even tell here: this, of course, is interesting, but why share the skin of an unkilled project.  I will tell you about the demo that we made in order to find out if it‚Äôs really possible to do what is intended. <br>  Proof of concept, so to speak. <br><br><h2>  Task: </h2><br>  We need to make a small, simple game like ‚Äúmagic combat‚Äù.  A couple of opponents throws spells at each other, the one who finishes the opponent first wins.  Players have some stats, for example, health and mana.  Each spell is a card, the spell costs some mana and produces some effect (heals, cripples, or something else). <br><br><h4>  To implement we need the following: </h4><br><ul><li>  a bunch of NFC tags to make cards of them (hello Moscow subway tickets!); </li><li>  two pieces (for each player) ESP8266 + RFID-RC522 to read them when a move is made and send to the network; </li><li>  Firebase - to store data, process moves and change values ‚Äã‚Äãin the model in accordance with the rules; </li><li>  Android - to display everything that happens (your stats, other people's stats) for players. </li></ul><br><img src="https://habrastorage.org/web/6aa/4d8/704/6aa4d87045fb4375baf3ff1fc432aa61.png"><br><br>  Anything like ‚Äúhello world‚Äù about Firebase I will not cover, the benefit of materials on this subject is enough, including in Habr√©.  I will not mention any subtleties of the model either, in order not to load with details.  More interesting is how we will read, write and process data. <br><br><h2>  A little bit about the model </h2><br><br>  So in our database look game games. <img src="https://habrastorage.org/web/241/f0b/c49/241f0bc49b614c49aac3611f9935269e.png" alt="image" align="left"><br>  <b>‚Äú35: 74: d6: 65‚Äù</b> is the batch id <br>  <b>states</b> are players <br>  <b>turns</b> is a sequence of moves <br><br>  In addition to information about the parties themselves, we need to keep a list of cards and some preliminary settings (for example, the maximum possible values ‚Äã‚Äãof health and mana). <br><img src="https://habrastorage.org/web/adc/77e/143/adc77e143db74dceac9cd99d12e2410c.png" alt="image" width="300" align="right"><br>  Each NFC tag can memorize some information.  Since we use tickets of the Moscow metro as cards, each of them already has a unique key, which is what we need.  Consider these keys can, for example, any application under the android, which is able to NFC. <br><br>  Here is a piece from the base, which puts its name, the amount of mana required for a cast, and a set of effects, each with its own duration (in turns), according to the unique key of the card. <br><br><h4>  The move is as follows: </h4><br><br><ul><li>  the player chooses a card, brings it to one of the readers (depending on whether he wants to apply effects - to himself or his opponent); </li><li>  he writes in the Firebase Database - ‚ÄúN card played on player M‚Äù; </li><li>  The Firebase function sees that a new entry has appeared in the sequence of moves and processes it: it takes the player mana for the played card, assigns effects to the target player from the current card, and then applies all the effects that already hang on the players and reduces their duration by 1; </li><li>  Well, the Android client simply tracks changes in the Firebase Database and displays the latest player stats in a readable form. </li></ul><br><img src="https://habrastorage.org/web/773/cac/1db/773cac1db51f40e39d557741ca89b061.jpg" alt="image"><br><br><h2>  Smoothly move to the glands and code </h2><br>  And we have these glands: ESP 8266 microcontroller and RFID / NFC RFID-RC522 reader.  ESP 8266 in our case is good because it is small in size, eats little, there is a built-in WI-FI module, as well as Arduino compatibility (which allows you to write firmware in the usual Arduino IDE). <br>  For the prototype, we took the Node MCU v3 board, which is made on the basis of ESP 8266. It allows you to upload firmware and eat directly via USB, which is beautiful in prototyping.  You can write for it in C and Lua.  Leaving aside our love for scripting languages ‚Äã‚Äãin general, and for Lua in particular, we chose C because  almost immediately found the necessary stack of libraries to implement our idea. <br><br>  Well, RFID-RC522 is probably the easiest and most common card reader.  The module works through SPI and has the following pinout for connecting to ESP 8266: <br><img src="https://habrastorage.org/web/450/1dd/dbc/4501dddbc700473dad9a423703c81039.png" alt="image"><br>  Talk is cheap, show me the code! <br><br><h2>  Our task is this: </h2><br><ul><li>  Read the card; </li><li>  If this is a batch creation key card, create a new batch in Firebase; </li><li>  If this is a game card, then get the card and send it to Firebase (create a new turn); </li><li>  Blink light bulb. </li></ul><br><h4>  Scanner </h4><br>  Used library MFRC522.  Interaction with the scanner goes through SPI: <br><br><pre><code class="cpp hljs">&lt;code&gt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Scanner::init() { SPI.begin(); <span class="hljs-comment"><span class="hljs-comment">//   SPI rc522-&gt;PCD_Init(); //   rc522-&gt;PCD_SetAntennaGain(rc522-&gt;RxGain_max); //    } String Scanner::readCard() { //    if(rc522-&gt;PICC_IsNewCardPresent() &amp;&amp; rc522-&gt;PICC_ReadCardSerial()) { //      XX:XX String uid = ""; int uidSize = rc522-&gt;uid.size; for (byte i = 0; i &lt; uidSize; i++) { if(i &gt; 0) uid = uid + ":"; if(rc522-&gt;uid.uidByte[i] &lt; 0x10) uid = uid + "0"; uid = uid + String(rc522-&gt;uid.uidByte[i], HEX); } return uid; } return ""; }</span></span></code> </pre> <br><h4>  <b>Firebase</b> </h4><br>  For Firebase there is a wonderful library FirebaseArduino, which out of the box allows you to send data and track events.  Supports the creation and sending of Json requests. <br><br>  Interaction with Firebase turned out well, very simple and can be briefly described in two lines: <br><br><pre> <code class="cpp hljs">Firebase.setInt(<span class="hljs-string"><span class="hljs-string">"battles/"</span></span> + battleId + <span class="hljs-string"><span class="hljs-string">"/states/"</span></span> + player + <span class="hljs-string"><span class="hljs-string">"/hp"</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firebaseFailed()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br>  Where firebaseFailed () is: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Cloud::firebaseFailed() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Firebase.failed()) { digitalWrite(ERROR_PIN, HIGH); <span class="hljs-comment"><span class="hljs-comment">//   Serial.print("setting or getting failed:"); Serial.println(Firebase.error()); //    delay(1000); digitalWrite(ERROR_PIN, LOW); //   return 1; } return 0; }</span></span></code> </pre> <br>  Json request can be sent as follows: <br><br><pre> <code class="cpp hljs">StaticJsonBuffer&lt;<span class="hljs-number"><span class="hljs-number">200</span></span>&gt; jsonBuffer; JsonObject&amp; turn = jsonBuffer.createObject(); turn[<span class="hljs-string"><span class="hljs-string">"card"</span></span>] = cardUid; turn[<span class="hljs-string"><span class="hljs-string">"target"</span></span>] = player; Firebase.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-string"><span class="hljs-string">"battles/"</span></span> + battleId + <span class="hljs-string"><span class="hljs-string">"/turns/"</span></span> + turnNumber, turn); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firebaseFailed()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  That's basically all that we needed from the ‚Äúiron part‚Äù.  We initially wanted to abstract from it as much as possible, and on the whole we succeeded.  Since writing the first firmware, it has changed only once, and only slightly. <img src="https://habrastorage.org/web/7ec/668/8d2/7ec6688d20cd49a0bf43c2353633f951.png" alt="image" width="280" align="right"><br><br><h4>  <b>Now, about the specially trained Firebase functions.</b> </h4><br>  This is a piece of the base where the moves of the current game are stored.  In each course, it is indicated what card was played and which player it was directed at.  If we want something to happen during the new move, we write a Firebase function that will track changes at the ‚Äúturns‚Äù node: <br><br><pre> <code class="javascript hljs">exports.newTurn = functions.database.ref(<span class="hljs-string"><span class="hljs-string">'/battles/{battleId}/turns/{turnId}'</span></span>).onWrite(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      ,    if (event.data.previous.val()) return; //   admin.database().ref('/battles/' + event.params.battleId + '/turns').once('value') .then(function(snapshot) { // ,      var whoCasts = (snapshot.numChildren() + 1) % 2; //   admin.database().ref('/battles/' + event.params.battleId + '/states').once('value') .then(function(snapshot) { var states = snapshot.val(); var castingPlayer = states[whoCasts]; var notCastingPlayer = states[(whoCasts + 1) % 2]; var targetPlayer; if (whoCasts == event.data.current.val().target) targetPlayer = castingPlayer; else targetPlayer = notCastingPlayer; //     admin.database().ref('/cards/' + event.data.current.val().card).once('value') .then(function(snapshot) { var card = snapshot.val(); //  castingPlayer.mana -= card.mana; //      var cardEffects = card.effects; if (!targetPlayer.effects) targetPlayer.effects = []; for (var i = 0; i &lt; cardEffects.length; i++) targetPlayer.effects.push(cardEffects[i]); //   ,      playEffects(castingPlayer); playEffects(notCastingPlayer); //   return event.data.adminRef.root.child('battles').child(event.params.battleId) .child('states').update(states); }) }) }) });</span></span></code> </pre><br>  The playEffects function looks like this (yes, there is an eval, but we think that this is quite acceptable in a demo project): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">playEffects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">player</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!player.effects) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; player.effects.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> effect = player.effects[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect.duration &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(effect.id + <span class="hljs-string"><span class="hljs-string">'(player)'</span></span>); effect.duration--; } } }</code> </pre><br>  Each of the effects will be something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fire_damage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">targetPlayer</span></span></span><span class="hljs-function">) </span></span>{ targetPlayer.hp -= getRandomInt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); }</code> </pre><br><br>  It is probably worth explaining here that the players in our database are represented as follows: <br><br><img src="https://habrastorage.org/web/736/468/5bb/7364685bb0b643228fe098cbb0b2a3a1.png" alt="image"><br><br>  That is, each of them has a name, health and mana.  And if something arrives in them, then effects will also appear: <br><br><img src="https://habrastorage.org/web/161/512/74a/16151274a4cc40ce98236e544357ccd3.png" alt="image"><br><br>  By the way, there is another task related to the effects: those that have already completed their duration should be removed.  Let's write another function: <br><br><pre> <code class="javascript hljs">exports.effectFinished = functions.database.ref(<span class="hljs-string"><span class="hljs-string">'/battles/{battleId}/states/{playerId}/effects/{effectIndex}'</span></span>) .onWrite(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> { effect = event.data.current.val(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect.duration === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.data.adminRef.root.child(<span class="hljs-string"><span class="hljs-string">'battles'</span></span>).child(event.params.battleId).child(<span class="hljs-string"><span class="hljs-string">'states'</span></span>) .child(event.params.playerId).child(<span class="hljs-string"><span class="hljs-string">'effects'</span></span>).child(event.params.effectIndex).remove(); });</code> </pre><br><h4>  <b>And it remains to make so that all this beauty was visible on the screen of the phone.</b> </h4> <b><br></b> <br>  For example, like this: <br><img src="https://habrastorage.org/web/e76/07a/39a/e7607a39a4db4838872ec069d2867c11.png" alt="image"><br><br>  Yes exactly: <br><br><img src="https://habrastorage.org/web/d74/031/32b/d7403132bbe543b8973c1eb3435e62e6.jpg" alt="image"><br><br>  We select the game and which of the opponents to keep track of, and then we observe our stats in numbers, and the opponent's stats in a generalized form (let it be a smiley of different degrees of gaiety). <br>  Here is the conditional scheme of the application, so that further the code is easier to read: <br><br><img src="https://habrastorage.org/web/273/801/0cd/2738010cd3ca46fa8830f797225f2ad1.png" alt="image"><br><br>  Reading data from Firebase on Android is simple enough: we hang the listeners on certain nodes in the database, catch DataSnapshot's and send them to the UI.  This is how we will show the list of batches on the first screen (I greatly shorten the code in order to highlight only moments about receiving and displaying data): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @Override protected void onCreate(Bundle savedInstanceState) { // ... FirebaseDatabase database = FirebaseDatabase.getInstance(); //    "battles"   (    , //      -    ) database.getReference().child("battles").addValueEventListener(new ValueEventListener() { @Override public void onDataChange(DataSnapshot battles) { final List&lt;String&gt; battleIds = new ArrayList&lt;String&gt;(); for (DataSnapshot battle : battles.getChildren()) battleIds.add(battle.getKey()); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;&gt;(MainActivity.this, android.R.layout.simple_list_item_1, battleIds.toArray(new String[battleIds.size()])); battlesList.setAdapter(adapter); battlesList.setOnItemClickListener(new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) { PlayerActivity.start(MainActivity.this, battleIds.get(i)); } }); } @Override public void onCancelled(DatabaseError databaseError) { // ... } }); } }</span></span></code> </pre><br><br>  I probably will not give the markup files - everything is quite trivial. <br>  So, we want to launch PlayerActivity when clicking on a certain party: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayerActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChoosePlayerFragment</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnPlayerChooseListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @Override protected void onCreate(Bundle savedInstanceState) { // ... battleId = getIntent().getExtras().getString(EXTRA_BATTLE_ID); //    ,       if (savedInstanceState == null) getSupportFragmentManager() .beginTransaction() .replace(R.id.container, ChoosePlayerFragment.newInstance(battleId)) .commit(); } @Override public void onPlayerChoose(String playerId, String opponentId) { //   -       getSupportFragmentManager() .beginTransaction() .replace(R.id.container, StatsFragment.newInstance(battleId, playerId, opponentId)).addToBackStack(null) .commit(); } }</span></span></code> </pre><br>  ChoosePlayerFragment reads the states node for the selected batch, pulls out two opponents from there and puts their names in the buttons (for details, see the source code, links at the end of the article). <br><br>  At this point, it is worthwhile to talk about StatsFragment, which tracks changes in the stats of opponents and displays them: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatsFragment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fragment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) { // ... //     ,        // addSingleValueEventListener    , //       database.getReference().child("settings") .addSingleValueEventListener(new ValueEventListener() { @Override public void onDataChange(DataSnapshot settings) { maxHp = Integer.parseInt(settings.child("max_hp").getValue().toString()); maxMana = Integer.parseInt(settings.child("max_mana").getValue().toString()); } // ... }); //         database.getReference().child("battles").child(battleId).child("states").child(playerId) .addValueEventListener(new ValueEventListener() { @Override public void onDataChange(DataSnapshot player) { hp = player.child("hp").getValue().toString(); mana = player.child("mana").getValue().toString(); hpView.setText("HP: " + hp + "/" + maxHp); manaView.setText("MANA: " + mana + "/" + maxMana); } // ... }); //         database.getReference().child("battles").child(battleId).child("states").child(opponentId) .addValueEventListener(new ValueEventListener() { @Override public void onDataChange(DataSnapshot opponent) { opponentName.setText(opponent.child("name").getValue().toString()); if (opponent.hasChild("hp") &amp;&amp; opponent.hasChild("mana")) { int hp = Integer.parseInt(opponent.child("hp").getValue().toString()); float thidPart = maxHp / 3.0f; if (hp &lt;= 0) { opponentView.setImageResource(R.drawable.grumpy); return; } else if (hp &lt; thidPart) { opponentView.setImageResource(R.drawable.sad); return; } else if (hp &lt; thidPart * 2) { opponentView.setImageResource(R.drawable.neutral); return; } opponentView.setImageResource(R.drawable.smile); } } // ... }); } }</span></span></code> </pre><br>  That's all the parts from which we collected our demo toy.  The full source code lives on a githaba, and further ideas live in our imagination.  Now we are modifying the model with a file, stumble over design and produce content.  And if the idea survives, then it will surely generate some more stateek. </div><p>Source: <a href="https://habr.com/ru/post/334560/">https://habr.com/ru/post/334560/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334550/index.html">Company Development with Open Source</a></li>
<li><a href="../334552/index.html">A quarter of a million for the "beetle": Microsoft is beginning an active struggle with bugs</a></li>
<li><a href="../334554/index.html">Characteristics of the PVS-Studio analyzer on the example of EFL Core Libraries, 10-15% of false positives</a></li>
<li><a href="../334556/index.html">Machine Learning for an Insurance Company: Improving the Model through Algorithm Optimization</a></li>
<li><a href="../334558/index.html">Differentiation of access rights in PostgreSQL</a></li>
<li><a href="../334562/index.html">hh and in production: how to release a new feature</a></li>
<li><a href="../334564/index.html">Defice ask.mcdonalds.ru</a></li>
<li><a href="../334566/index.html">7 ways to use blue in your company colors</a></li>
<li><a href="../334568/index.html">Generative models from OpenAI</a></li>
<li><a href="../334570/index.html">Upgrading traders' workplace infrastructure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>