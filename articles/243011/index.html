<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Software renderer - 1: materiel</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Software rendering is software image creation without the help of a GPU. This process can go in one of two modes: in real time (calculation of a large...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Software renderer - 1: materiel</h1><div class="post__text post__text-html js-mediator-article"> Software rendering is software image creation without the help of a GPU.  This process can go in one of two modes: in real time (calculation of a large number of frames per second ‚Äî necessary for interactive applications, for example, games) and in offline mode (at which the time that can be spent on calculating one frame, not so strictly limited - calculations can take hours or even days).  I will only consider the real-time rendering mode. <br><br>  This approach has both disadvantages and advantages.  The obvious disadvantage is the performance - the CPU is not able to compete with modern video cards in this area.  The advantages should be attributed to the independence of the video card - that is why it is used as a replacement for hardware rendering in cases where the video card does not support this or that feature (the so-called software fallback).  There are also projects whose purpose is to completely replace hardware rendering with software, for example, WARP, which is part of Direct3D 11. <br><br>  But the main advantage is the possibility of writing such a renderer independently.  It serves educational purposes and, in my opinion, it is the best way to understand the underlying algorithms and principles. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is exactly what will be discussed in a series of these articles.  We will start with the ability to paint a pixel in a window with a specified color and build on it the ability to render a three-dimensional scene in real time, with moving textured models and lighting, as well as with the ability to move around this scene. <br><br>  But in order to display at least the first polygon, it is necessary to master the mathematics on which it is built.  The first part will be dedicated to her, so there will be many different matrices and other geometry in it. <br><br>  At the end of the article there will be a link to the githab project, which can be considered as an example of implementation. <br><a name="habracut"></a><br>  Despite the fact that the article will describe the very basics, the reader still needs a certain foundation for its understanding.  This foundation: the basics of trigonometry and geometry, an understanding of Cartesian coordinate systems and basic operations on vectors.  Also, it would be a good idea to read an article about the basics of linear algebra for game developers (for example, <a href="http://habrahabr.ru/post/131931/">this one</a> ), since I will skip the descriptions of some operations and dwell only on the most important ones from my point of view.  I will try to show with the help of which some important formulas are drawn, but I will not describe them in detail - you can make full proofs yourself or find them in the relevant literature.  In the course of the article, I will first try to give algebraic definitions of a particular concept, and then describe their geometric interpretation.  Most of the examples will be in two-dimensional space, since my skills in drawing three-dimensional and, even more so, four-dimensional spaces leave much to be desired.  Nevertheless, all examples are easily generalized to spaces of other dimensions.  All articles will be more focused on the description of algorithms, rather than on their implementation in the code. <br><br><h4>  Vectors </h4><br>  Vector - one of the key concepts in three-dimensional graphics.  And although linear algebra gives it a very abstract definition, in the framework of our tasks, under the <i>n-</i> dimensional vector, we can simply understand an array of <i>n</i> real numbers: an element of the space <i>R <sup>n</sup></i> : <br><br><img src="https://habrastorage.org/files/979/b2d/17f/979b2d17ffea421daf59a92db1f19926.png"><br><br>  The interpretation of these numbers depends on the context.  The two most frequent: these numbers specify the coordinates of a point in space or a directional displacement.  Despite the fact that their representation is the same ( <i>n</i> real numbers), their concepts are different - the point describes the position in the coordinate system, and the displacement does not have a position as such.  In the future, we can also determine the point using the offset, implying that the offset occurs from the origin. <br><br>  As a rule, in the majority of game and graphic engines there is a class of a vector just like a set of numbers.  The meaning of these numbers depends on the context in which they are used.  In this class, methods are defined both for working with geometric vectors (for example, calculating the vector product) and with points (for example, calculating the distance between two points). <br><br>  In order to avoid confusion, within the framework of the article we will no longer understand the abstract set of numbers by the word "vector", but we will call so the offset. <br><br><h5>  Scalar product </h5><br>  The only operation on vectors that I want to dwell on in detail (because of its fundamental nature) is a scalar product.  As the name implies, the result of this work is a scalar, and it is determined by the following formula: <br><br><img src="https://habrastorage.org/files/d99/7f3/4be/d997f34bee9e4be2a181bf61ae3a1f13.png"><br><br>  The dot product has two important geometric interpretations. <br><br><ol><li>  Measure the angle between vectors. <br>  Consider the following triangle derived from three vectors: <br><br><img src="https://habrastorage.org/files/ec3/a41/b49/ec3a41b49b654e7faae70365e8f8a04e.png"><br><br>  Writing for him the cosine theorem and reducing the expression, we come to the record: <br><br><img src="https://habrastorage.org/files/f18/75f/f6a/f1875ff6a43d42228609a258b6e2c559.png"><br><br>  Since, by definition, the length of a nonzero vector is greater than 0, the cosine of an angle determines the sign of the scalar product and its equality to zero.  We get (assuming that the angle is from 0 to 360 degrees): <br><br><img src="https://habrastorage.org/files/3cd/0d5/2a8/3cd0d52a8ebc4871a3a0863a6d294fdc.png"><br><br></li><li>  The dot product calculates the length of the projection of the vector on the vector. <br><br><img src="https://habrastorage.org/files/cd4/ad9/10b/cd4ad910bec540ef9db643828a99028a.png"><br><br>  From the definition of the cosine of an angle we get: <br><br><img src="https://habrastorage.org/files/b55/c35/ffe/b55c35ffe1bd491e80486f7c429a5341.png"><br><br>  We also already know from the previous paragraph that: <br><br><img src="https://habrastorage.org/files/f18/75f/f6a/f1875ff6a43d42228609a258b6e2c559.png"><br><br>  Expressing the cosine of the angle from the second expression, substituting in the first and multiplying by <i>|| w ||</i>  , we get the result: <br><br><img src="https://habrastorage.org/files/e4f/633/34f/e4f63334ff4e414c845feb21cc17cfb4.png"><br><br>  Thus, the scalar product of two vectors is equal to the length of the projection of the vector <i>v</i> on the vector <i>w</i> multiplied by the length of the vector <i>w</i> .  A frequent special case of this formula - <i>w</i> has a unit length and, therefore, the scalar product calculates the exact length of the projection. <br><br>  This interpretation is very important because it shows that the scalar product calculates the coordinates of a point (given by vector <i>v</i> , implying an offset from the origin) along a given axis.  The simplest example: <br><br><img src="https://habrastorage.org/files/d4d/542/6a2/d4d5426a2d7f47bb887b3d1cb45aa598.png"><br><br>  We will use this later when building a transformation into the camera's coordinate system. <br><br></li></ol><br><h4>  Coordinate systems </h4><br>  This section is intended to prepare the basis for the introduction of matrices.  I, using the example of the world and local systems, will show for what reasons several coordinate systems are used, rather than one, and how to describe one coordinate system relative to another. <br><br>  Imagine that we needed to draw a scene with two models, for example: <br><br><img src="https://habrastorage.org/files/c76/8fe/f7e/c768fef7ed7141dfacc61c2f93aaa187.png"><br><br>  What coordinate systems naturally follow from such a statement?  The first is the coordinate system of the scene itself (which is shown in the figure).  This is a coordinate system describing the world that we are going to draw - this is why it is called ‚Äúworld‚Äù (in the pictures it will be marked with the word ‚Äúworld‚Äù).  She "binds" all the objects of the scene together.  For example, the coordinates of the center of the object <i>A</i> in this coordinate system are <i>(1, 1)</i> , and the coordinates of the center of the object <i>B</i> are <i>(-1, -1)</i> . <br><br>  Thus, one coordinate system is already there.  Now we need to think about the way in which models come to us, which we will use in the scene. <br><br>  For simplicity, we assume that the model is described simply as a list of points (‚Äúvertices‚Äù) of which it consists.  For example, model <i>B</i> consists of three points that come to us in the following format: <br><br>  <i>v <sub>0</sub> = (x <sub>0</sub> , y <sub>0</sub> )</i> <i><br></i>  <i>v <sub>1</sub> = (x <sub>1</sub> , y <sub>1</sub> )</i> <i><br></i>  <i>v <sub>2</sub> = (x <sub>2</sub> , y <sub>2</sub> )</i> <i><br></i> <br>  At first glance, it would be great if they were already described in the ‚Äúworld‚Äù system we need!  Imagine, you are adding a model to the stage, and it is already where we need it.  For model <i>B,</i> it might look like this: <br><br>  <i>v <sub>0</sub> = (-1.5, -1.5)</i> <i><br></i>  <i>v <sub>1</sub> = (-1.0, -0.5)</i> <i><br></i>  <i>v <sub>2</sub> = (-0.5, -1.5)</i> <i><br></i> <br>  But to use this approach will not work.  There is an important reason for this: it makes it impossible to use the same model again in different scenes.  Imagine that you were given model <i>B</i> , which was modeled in such a way that when you add it to the stage, it appears in the right place for us, as in the example above.  Then, suddenly, the demand has changed - we want to move it to a completely different position.  It turns out that the person who created this model will have to move it independently and then give it back to you.  Of course, this is complete absurdity.  An even stronger argument is that in the case of interactive applications, the model can move, rotate, animate on the stage - what can an artist do a model in all possible positions?  That sounds even more stupid. <br><br>  The solution to this problem is the ‚Äúlocal‚Äù coordinate system of the model.  We model the object in such a way that its center (or that which can be conventionally taken as such) is located at the origin.  Then we programmatically orient (move, rotate, etc.) the local coordinate system of the object to the position we need in the world system.  Returning to the scene above, object <i>A</i> (unit square, rotated 45 degrees clockwise) can be modeled as follows: <br><br><img src="https://habrastorage.org/files/128/5fa/788/1285fa7882554a40abcce6bd2733b58a.png"><br><br>  The description of the model in this case will look as follows: <br><br>  <i>v <sub>0</sub> = (-0.5, 0.5)</i> <i><br></i>  <i>v <sub>1</sub> = (0.5, 0.5)</i> <i><br></i>  <i>v <sub>2</sub> = (0.5, -0.5)</i> <i><br></i>  <i>v <sub>3</sub> = (-0.5, -0.5)</i> <i><br></i> <br>  And, accordingly, the position in the scene of two coordinate systems - the world and local object <i>A</i> : <br><br><img src="https://habrastorage.org/files/32e/d80/368/32ed80368d274cb29ea0e2530cfcdce3.png"><br><br>  This is one example of why having multiple coordinate systems makes life easier for developers (and artists!).  There is another reason - the transition to a different coordinate system can simplify the necessary calculations. <br><br><h5>  Description of one coordinate system relative to another </h5><br>  There is no such thing as "absolute coordinates".  A description of something always happens relative to some kind of coordinate system.  Including the description of another coordinate system. <br><br>  We can build a peculiar hierarchy of coordinate systems in the example above: <br><br><pre> - world space
    - local space (object A)
    - local space (object B)
</pre><br>  In our case, this hierarchy is very simple, but in real situations it can have much stronger branching.  For example, a local coordinate system of an object may have child systems that are responsible for the position of one or another part of the body. <br><br>  Each child coordinate system can be described relative to the parent using the following values: <br><ul><li>  the origin point of the child system relative to the parent </li><li>  coordinates of the basis vectors of the child system relative to the parent </li></ul><br>  For example, in the picture below, the origin of the system <i>x'y '</i> (denoted as <i>O'</i> ) is located at <i>(1, 1)</i> , and the coordinates of its base vectors <i>i '</i> and <i>j'</i> are <i>(0.7, -0.7)</i> and <i>(0.7, 0.7 )</i> respectively (which roughly corresponds to the axes rotated 45 degrees clockwise). <br><br><img src="https://habrastorage.org/files/07f/d54/28a/07fd5428a1fc4de58b1e973542db973c.png"><br><br>  We do not need to describe the world coordinate system relative to any other, because the world system is the root of the hierarchy, we do not care where it is located or how it is oriented.  Therefore, to describe it, we use the standard basis: <br><br><img src="https://habrastorage.org/files/d0f/df3/2c3/d0fdf32c35cf4f36ad5f6d903755043e.png"><br><br><h5>  Transfer coordinates of points from one system to another </h5><br>  The coordinates of the point <i>P</i> in the parent coordinate system (denoted by <i>P <sub>parent</sub></i> ) can be calculated using the coordinates of this point in the child system (denoted as <i>P <sub>child</sub></i> ) and the orientation of this child system relative to the parent (described using the origin <i>O</i> and the base vectors <i>i '</i> and <i>j '</i> ) as follows: <br><br><img src="https://habrastorage.org/files/e3a/aa5/91d/e3aaa591db7f495cba14fa5eef733a38.png"><br><br>  Let's go back to the example scene above.  We orient the local coordinate system of object <i>A</i> relative to the world: <br><br><img src="https://habrastorage.org/files/32e/d80/368/32ed80368d274cb29ea0e2530cfcdce3.png"><br><br>  As we already know, in the process of drawing we will need to transfer the coordinates of the vertices of the object from the local coordinate system to the world one.  For this we need a description of the local coordinate system relative to the world.  It looks like this: the origin is at the point <i>(1, 1)</i> , and the coordinates of the basis vectors are <i>(0.7, -0.7)</i> and <i>(0.7, 0.7)</i> (the method of calculating the coordinates of the basis vectors after the rotation will be described later, so far we have enough result) . <br><br>  For example, take the first vertex <i>v = (-0.5, 0.5)</i> and calculate its coordinates in the world system: <br><br><img src="https://habrastorage.org/files/8c5/971/cb8/8c5971cb8b1b4fc78f4892c9341f7a55.png"><br><br>  The fidelity of the result can be seen by looking at the image above. <br><br><h4>  Matrices </h4><br>  The matrix of dimension <i>mxn</i> is the corresponding dimension table of numbers.  If the number of columns in the matrix is ‚Äã‚Äãequal to the number of rows, then the matrix is ‚Äã‚Äãcalled square.  For example, a <i>3 x 3</i> matrix looks like this: <br><br><img src="https://habrastorage.org/files/160/79b/1ce/16079b1ce6e145f998ce6f037cdb4cc9.png"><br><br><h5>  Matrix Multiplication </h5><br>  Suppose we have two matrices: <i>M</i> (dimension <i>axb</i> ) and <i>N</i> (dimension <i>cxd</i> ).  The expression <i>R = M ¬∑ N is</i> defined only if the number of columns in the matrix <i>M</i> is equal to the number of rows in the matrix <i>N</i> (that is, <i>b = c</i> ).  The dimension of the resulting matrix will be equal to <i>axd</i> (i.e., the number of rows is equal to the number of rows <i>M</i> and the number of columns is the number of columns in <i>N</i> ), and the value located at position <i>ij</i> is calculated as the scalar product of the <i>i</i> -th row <i>M</i> by the <i>jth</i> column <i>n</i> : <br><br><img src="https://habrastorage.org/files/fdb/9e1/034/fdb9e103472a4beb974e4573ad783fc5.png"><br><br>  If the result of multiplying two matrices <i>M ¬∑ N is</i> defined, then this does not mean that the multiplication in the opposite direction is also determined - <i>N ¬∑ M</i> (the number of rows and columns may not coincide).  In the general case, the operation of matrix multiplication is also not commutative: <i>M ¬∑ N ‚â† N ¬∑ M.</i> <br><br>  A unit matrix is ‚Äã‚Äãa matrix that does not change another matrix multiplied by it (ie, <i>M ¬∑ I = M</i> ) - a kind of analogue of one for ordinary numbers: <br><br><img src="https://habrastorage.org/files/5ed/6d5/c65/5ed6d5c6538a4e3bb62963f61d913e2c.png"><br><br><h5>  Representation of vectors in the form of matrices </h5><br>  We can also represent a vector as a matrix.  There are two possible ways to do this, which are called ‚Äúrow vector‚Äù and column vector ‚Äú‚Äù.  As the name implies, a row vector is a vector represented as a matrix with one row, and a column vector is a vector represented as a matrix with one column. <br><br>  Row Vector: <br><br><img src="https://habrastorage.org/files/8e7/f40/565/8e7f405658c648f9b19d5bfeb2b9d5ad.png"><br><br>  Column Vector: <br><br><img src="https://habrastorage.org/files/e17/afe/b38/e17afeb387e54c7495b3c253248cbcc2.png"><br><br>  Further, we will often come across the operation of multiplying the matrix by a vector (which will be explained in the next section), and, running ahead, the matrices with which we will work will have the dimension of either <i>3 x 3</i> or <i>4 x 4</i> . <br><br>  Consider how we can multiply the three-dimensional vector by a <i>3 x 3</i> matrix (similar arguments apply for other dimensions).  By definition, two matrices can be multiplied if the number of columns in the first matrix equals the number of rows in the second.  Thus, since we can represent a vector both as a <i>1 x 3</i> matrix (row vector) and as a <i>3 x 1</i> matrix (column vector), we get two possible options: <br><br><ul><li>  The multiplication of the vector by the matrix "on the left": <br><br><img src="https://habrastorage.org/files/a28/1f0/d67/a281f0d67bbd4f029028bd86c0365332.png"><br><br></li><li>  Multiplying the vector by the matrix "on the right": <br><br><img src="https://habrastorage.org/files/b26/957/d8d/b26957d8db2d4703948f3a6f6ca1d1c9.png"></li></ul><br>  As you can see, we get a different result in each case.  This can lead to random errors if the API allows you to multiply a vector by a matrix on both sides, because, as we will see later, the transformation matrix implies that the vector will be multiplied by one of two methods.  So, in my opinion, the API is better to stick with only one of two options.  Within these articles I will use the first option - i.e.  the vector is multiplied by the matrix on the left.  If you decide to use a different order, then, in order to get correct results, you will need to transpose all the matrices that will later be found in this article, and replace the word ‚Äúrow‚Äù with a ‚Äúcolumn‚Äù.  It also affects the order of matrix multiplication in the presence of several transformations (it will be discussed in more detail later). <br><br>  It is also seen from the result of the multiplication that the matrix in a certain way (depending on the value of its elements) changes the vector that was multiplied by it.  It can be such transformations as rotation, scaling and others. <br><br>  Another very important property of the matrix multiplication operation, which will be useful to us later, is distributivity with respect to addition: <br><br><img src="https://habrastorage.org/files/0a9/712/17c/0a971217cef64afba874ee90d7d186e0.png"><br><br><h5>  Geometric interpretation </h5><br>  As we saw in the previous section, the matrix in a certain way transforms the vector multiplied by it. <br><br>  Once again, remember that any vector can be represented as a linear combination of basis vectors: <br><br><img src="https://habrastorage.org/files/68b/a9f/3e1/68ba9f3e157748f9a7a5aa34806abfeb.png"><br><br><img src="https://habrastorage.org/files/81b/975/f9c/81b975f9cb104246aec0c6d1bbc83a78.png"><br><br>  Multiply this expression by the matrix: <br><br><img src="https://habrastorage.org/files/cea/27d/e70/cea27de70c6d4447bf9a5b057c657420.png"><br><br>  Using distributivity with respect to addition, we get: <br><br><img src="https://habrastorage.org/files/a35/20e/e60/a3520ee60dc14c03acba0a5f9b35a078.png"><br><br>  We have already seen this before, when we considered how to transfer the coordinates of a point from the child system to the parent system, then it looked like this (for three-dimensional space): <br><br><img src="https://habrastorage.org/files/513/eb1/49f/513eb149f78c4804a52ed358481feb8d.png"><br><br>  There are two differences between these two expressions - in the first expression there is no movement ( <i>O <sub>child</sub></i> , we will consider this moment in more detail when we talk about linear and affine transformations), and the vectors <i>i '</i> , <i>j'</i> and <i>k 'are</i> replaced by <i>iM</i> , <i>jM</i> and <i>kM</i> respectively.  Consequently, <i>iM</i> , <i>jM</i> and <i>kM</i> are the basis vectors of the child coordinate system and we transfer the point <i>v <sub>child</sub> (v <sub>x</sub> , v <sub>y</sub> , v <sub>y</sub> )</i> from this child coordinate system to the parent ( <i>v <sub>transformed</sub> = v <sub>parent</sub> M</i> ). <br><br>  The transformation process can be depicted as follows using the counterclockwise rotation as an example ( <i>xy</i> is the original, parental coordinate system, <i>x'y '</i> is a daughter one resulting from the transformation): <br><br><img src="https://habrastorage.org/files/ee5/75f/e11/ee575fe111eb4cc8baf05077fa9e4f1f.gif"><br><br>  Just in case, to make sure that we understand the meaning of each of the vectors used above, we list them again: <br><ul><li>  <i>v <sub>parent</sub></i> is the vector we initially multiplied by the matrix <i>M.</i>  Its coordinates are described relative to the parent coordinate system. </li><li>  <i>v <sub>child</sub></i> is a vector whose coordinates are equal to the vector <i>v <sub>parent</sub></i> , but they are described relative to the child coordinate system.  This is the vector <i>v <sub>parent</sub></i> transformed in the same way as the basic vectors (since we use the same coordinates) </li><li>  <i>v <sub>transformed</sub></i> is the same vector as <i>v <sub>child</sub></i> but with coordinates recalculated relative to the parent coordinate system.  This is the final result of the transformation of the vector <i>v <sub>parent</sub></i> </li></ul><br>  Now consider what happens when you multiply the basis vectors by the matrix <i>M</i> : <br><br><img src="https://habrastorage.org/files/a44/cfe/64f/a44cfe64f20a483a8ab8078483404526.png"><br><img src="https://habrastorage.org/files/179/766/a02/179766a0290a4136aee3ccb389981e63.png"><br><img src="https://habrastorage.org/files/6c0/033/235/6c00332355b647d59c5c9a381fc99fb6.png"><br><br>  It can be seen that the basis vectors of the new child coordinate system obtained as a result of multiplication by the matrix <i>M</i> coincide with the rows of the matrix.  This is the very geometric interpretation we were looking for.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, having seen the transformation matrix, we will know where to look, in order to understand what it is doing - it is enough to present its rows as basis vectors of the new coordinate system. </font><font style="vertical-align: inherit;">The transformation that occurs with the coordinate system will be the same as the transformation that occurs with the vector multiplied by this matrix. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can also combine transformations presented in the form of matrices by multiplying them by each other: </font></font><br><br><img src="https://habrastorage.org/files/21d/121/afe/21d121afef404d57a4eb76bf5428c277.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, matrices are a very convenient tool for describing and combining transformations.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linear transformations </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To begin, consider the most commonly used linear transformations. </font><font style="vertical-align: inherit;">Linear transformation is a transformation that satisfies two properties: </font></font><br><br><img src="https://habrastorage.org/files/1f6/681/5f8/1f66815f89c7454bbffc48239133ac6e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An important consequence is that a linear transformation cannot contain displacements (this is also the reason why the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">child</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> term was </font><font style="vertical-align: inherit;">absent in the previous section) because, according to the second formula, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> always displayed as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rotation </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider rotation in two-dimensional space. </font><font style="vertical-align: inherit;">This is a transformation that rotates the coordinate system at a given angle. </font><font style="vertical-align: inherit;">As we already know, it is enough for us to calculate the new coordinate axes (obtained after rotation at a given angle), and use them as rows of the transformation matrix. </font><font style="vertical-align: inherit;">The result is easily obtained from the basic geometry:</font></font><br><br><img src="https://habrastorage.org/files/292/a0d/3fa/292a0d3fa33f41ee90ee50ad61fb0b7c.png"><br><br><img src="https://habrastorage.org/files/48f/277/8fc/48f2778fc89c466f8912e288f3dd308e.png"><br><br>  Example: <br><br><img src="https://habrastorage.org/files/ce3/ec3/1c2/ce3ec31c22a1496d98e8037419ad0b1d.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result for rotation in three-dimensional space is obtained in a similar way, with the only difference that we rotate the plane composed of two coordinate axes, and fix the third (around which rotation takes place). </font><font style="vertical-align: inherit;">For example, the rotation matrix around the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> axis </font><font style="vertical-align: inherit;">looks like this:</font></font><br><br><img src="https://habrastorage.org/files/e3f/8d5/870/e3f8d5870d1e4dc19364f5f26f4a7431.png"><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Scaling </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can change the scale of the object with respect to all axes using the following matrix: The </font></font><br><br><img src="https://habrastorage.org/files/916/986/f74/916986f74b904ca4a4331d02e05bf608.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">axes of the transformed coordinate system will be directed the same way as the original coordinate system, but will require </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> times the length for one unit of measurement:</font></font><br><br><img src="https://habrastorage.org/files/f10/abd/40c/f10abd40ca5f45dbb42e9b9e17a378b8.png"><br><br>  Example: <br><img src="https://habrastorage.org/files/497/99c/039/49799c0398cb441e97658a4ecc9a0a9c.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scaling with the same ratio relative to all axes is called uniform. </font><font style="vertical-align: inherit;">But we can also scale with different coefficients along different (nonuniform) axes:</font></font><br><br><img src="https://habrastorage.org/files/68d/4f0/9e0/68d4f09e0d0d45c58dd41ee3d2425916.png"><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shift </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As the name implies, this transformation shifts along the coordinate axis, leaving the remaining axes intact: </font></font><br><br><img src="https://habrastorage.org/files/ffa/617/91d/ffa61791d0e6405ca98a2174211c776f.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accordingly, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> axis shift matrix is </font><font style="vertical-align: inherit;">as follows:</font></font><br><br><img src="https://habrastorage.org/files/747/a37/1de/747a371deff64fd084bf60d898428b44.png"><br><br>  Example: <br><br><img src="https://habrastorage.org/files/660/d18/41e/660d1841e05f40de9ed88e77181a71f3.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The matrix for the three-dimensional space is constructed in a similar way. </font><font style="vertical-align: inherit;">For example, the option for shifting the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> axis </font><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/files/db9/ef6/008/db9ef60082aa4db39bf4de0ab87228ce.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although this transformation is used very rarely, it will be useful to us in the future when we consider affine transformations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is already a decent number of transformations in our stock, which can be represented as a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 x 3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> matrix, but we lack one more ‚Äî displacement. </font><font style="vertical-align: inherit;">Unfortunately, </font><font style="vertical-align: inherit;">it is impossible </font><font style="vertical-align: inherit;">to express displacement in three-dimensional space using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 x 3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> matrices, since displacement is not a linear transformation. </font><font style="vertical-align: inherit;">The solution to this problem is homogeneous coordinates, which we will consider later.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Central projection </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our final goal is to draw a three-dimensional scene on a two-dimensional screen. Thus, we need to project our stage onto a plane in one way or another. There are two most commonly used types of projections - orthographic and central (another name is perspective). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the human eye looks at the three-dimensional scene, the objects that are farther from it become smaller in the final image, which the person sees - this effect is called perspective. The orthographic projection ignores the perspective, which is a useful feature when working in various CAD systems (as well as in 2D games). The central projection has this property and therefore adds a significant proportion of realism. In this article we will consider only her.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unlike the orthographic projection, the lines in the perspective projection are not parallel to each other, but intersect at a point called the center of the projection. The center of the projection is the ‚Äúeye‚Äù with which we look at the scene ‚Äî the virtual camera: </font></font><br><br><img src="https://habrastorage.org/files/0b7/f31/ae1/0b7f31ae1e184cf0a2d5cb96089fb802.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The image is formed on a plane located at a given distance from the virtual camera. Accordingly, the greater the distance from the camera, the larger the projection size: </font></font><br><br><img src="https://habrastorage.org/files/505/4c3/1fe/5054c31fe5d24bda8c00045eaa46092b.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the simplest example: the camera is located at the origin of coordinates, and the projection plane is at a distance </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the camera. We know the coordinates of the point we want to project: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(x, y, z)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Find the coordinate </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p of the</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> projection of this point on the plane:</font></font><br><br><img src="https://habrastorage.org/files/cc6/5bb/be1/cc65bbbe1d884d11b25185524528656d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This picture shows two similar triangles - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CDP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBA</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (at three angles): </font></font><br><br><img src="https://habrastorage.org/files/b1d/38a/a45/b1d38aa454764b8c85168d4ed7fdcce8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accordingly, the relationship between the parties remains: </font></font><br><br><img src="https://habrastorage.org/files/4c2/208/cd6/4c2208cd62f742999308fe1cde2cea67.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We get the result for the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinates: </font></font><br><br><img src="https://habrastorage.org/files/847/c27/0ba/847c270bae764229853571ab214951c1.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, similarly, for the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinates: </font></font><br><br><img src="https://habrastorage.org/files/6fb/3ec/786/6fb3ec786e3b457387f046e9afaa4f55.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Later, we will need to use this transformation to form projected image. </font><font style="vertical-align: inherit;">And here a problem arises - we cannot imagine dividing by </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinate in three-dimensional space using a matrix. </font><font style="vertical-align: inherit;">The solution to this problem, as well as in the case of the displacement matrix, are homogeneous coordinates.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projective geometry and homogeneous coordinates </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To date, we are faced with two problems: </font></font><br><ul><li>          <i>3 x 3</i>  </li><li>          </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both of these problems solves the use of uniform coordinates. Homogeneous coordinates - a concept from projective geometry. Projective geometry studies projective spaces, and, in order to understand the geometric interpretation of homogeneous coordinates, it is necessary to get to know them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below we will consider definitions for two-dimensional projective spaces, since they are easier to portray. Similar reasoning applies to three-dimensional projective spaces (we will use them in the future). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We define a ray in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as follows: a ray is a set of vectors of the form </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kv</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a scalar, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a non-zero vector, an element of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the vector </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> defines the direction of the ray: </font></font><br><br><img src="https://habrastorage.org/files/ef5/1c3/862/ef51c38620574ad586ec75bea3133501.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can proceed to the definition of the projective space. The projective plane (i.e., a projective space with a dimension equal to two) </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , associated with the space </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , is the set of rays in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Thus, the ‚Äúpoint‚Äù in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a ray in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accordingly, two vectors in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> set the same element in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , if one of them can be obtained by multiplying the second by a scalar (since in this case they lie on the same ray):</font></font><br><br><img src="https://habrastorage.org/files/cf6/993/6b4/cf69936b43ce46a890045400b9db47a5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, the vectors </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1, 1, 1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(5, 5, 5)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> represent the same ray, and therefore are the same ‚Äúpoint‚Äù in the projective plane. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we came to homogeneous coordinates. Each element in the projective plane is defined by a ray of three coordinates </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(x, y, w)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (the last coordinate is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instead of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äî the generally accepted convention) ‚Äîthe coordinates are called homogeneous and are determined with an accuracy to a scalar. This means that we can multiply (or divide) homogeneous coordinates by a scalar, and they will still represent the same ‚Äúpoint‚Äù in the projective plane.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the following, we will use homogeneous coordinates to represent affine (containing displacement) transformations and projections. But before that, one more question needs to be solved: how to represent in the form of homogeneous coordinates the vertices of the model already given to us? Since the ‚Äúaddition‚Äù to the homogeneous coordinates occurs due to the addition of the third coordinate </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the question boils down to what value of w we need to use. The answer to this question is any non-zero. The difference in the use of different values ‚Äã‚Äãof </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the convenience of working with them. </font></font><br><br><img src="https://habrastorage.org/files/936/4ea/111/9364ea111c72479bbaab74dde17844db.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, as will be understood later (and partly clear intuitively), the most convenient value of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is one. The advantages of this choice are as follows:</font></font><br><ul><li>            (  ) </li><li>    (  )  <i>w</i>  ,           (..     w): <br><br><img src="https://habrastorage.org/files/9b6/490/6f1/9b64906f11694dd4994c0a4d9bf10cfc.png"><br><br>    ‚Äî <i>w = 1</i> ,        <i>w</i> ‚Äî  ,     w  </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we choose the value </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w = 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which means that our input data in homogeneous coordinates will now look like this (of course, we‚Äôve already added one, and will not be in the model description itself): </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = (x </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = (x </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = (x </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , 1)</font></font><br></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we need to consider a special case when working with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinate. Namely - its equality to zero. Above we said that we can choose any value of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, not equal to zero, for expansion to homogeneous coordinates. We cannot take </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in particular, because it will not allow moving this point (since, as we will see later, the movement occurs precisely due to the value in the w coordinate). Also, if the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coordinate of the point </font><font style="vertical-align: inherit;">is zero, we can consider it as a point "at infinity", because when we try to return to the plane </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w = 1,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we get the division by zero:</font></font><br><br><img src="https://habrastorage.org/files/fd1/444/494/fd14444942f64cf8bce90f93d872df97.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, although we cannot use the zero value for the model vertices, we can use it for vectors! </font><font style="vertical-align: inherit;">This will lead to the fact that the vector will not be subject to movement during transformations - which makes sense, because the vector does not describe the position. </font><font style="vertical-align: inherit;">For example, when transforming the normal, we cannot move it, otherwise we will get an incorrect result. </font><font style="vertical-align: inherit;">We will take a closer look at this when the need arises to transform vectors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this connection, it is often written that for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w = 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we describe a point, and for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a vector. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I already wrote, we used the example of two-dimensional projective projective spaces, but in fact we will use three-dimensional projective spaces, which means each point will be described by 4 coordinates: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(x, y, z, w)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moving using homogeneous coordinates </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have all the necessary tools to describe affine transformations. </font><font style="vertical-align: inherit;">Affine transformations are linear transformations with subsequent displacement. </font><font style="vertical-align: inherit;">They can be described as follows: </font></font><br><br><img src="https://habrastorage.org/files/f82/7e6/3e3/f827e63e33a94a7695b22354153d9cee.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can also use </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 x 4</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> matrices to describe affine transformations using homogeneous coordinates: </font></font><br><br><img src="https://habrastorage.org/files/7ed/131/648/7ed13164816a47b0bd674ecf5022e207.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the result of multiplying the vector, represented as homogeneous coordinates, and multiplying by </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 x 4</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> matrix: </font></font><br><br><img src="https://habrastorage.org/files/0a3/6d7/e13/0a36d7e135984aef83036e8a3bcabc26.png"><br><br><img src="https://habrastorage.org/files/241/31b/59b/24131b59bddb4a7a96a03f937ee310c9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, the difference from the transformation , represented in the form of a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 x 3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> matrix, consists in the presence of the 4th coordinate, as well as the new terms in each of the coordinates of the form v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬∑ m </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Using this, and implying </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w = 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we can imagine the movement as follows: </font></font><br><br><img src="https://habrastorage.org/files/b06/72a/89f/b0672a89f03f4cb9ad9c2a3bc7463941.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can make sure that the choice of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w = 1 is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correct </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To represent the displacement dx, we use a term of the form </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w ¬∑ dx / w</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Accordingly, the last row of the matrix looks like </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dx / w, dy / w, dz / w, 1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In the case of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w = 1,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we can simply omit the denominator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This matrix also has a geometric interpretation. </font><font style="vertical-align: inherit;">Recall the shift matrix, which we considered earlier. </font><font style="vertical-align: inherit;">It has exactly the same format, the only difference is that the fourth axis is shifted, thus shifting the three-dimensional subspace located in the hyperplane </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w = 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by the corresponding values.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Description of the virtual camera </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A virtual camera is the ‚Äúeye‚Äù with which we look at the scene. Before proceeding further, it is necessary to understand how to describe the position of the camera in space, and what parameters are necessary for the formation of the final image. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The camera parameters set the truncated view pyramid (view frustum), which determines which part of the scene falls into the final image: </font></font><br><br><img src="https://habrastorage.org/files/07f/0c7/6cb/07f0c76cb67c4dcfa4775da853adf4ab.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider them in turn:</font></font><br><br><ul><li>      . , ,  .     .      ¬´UVN¬ª , ..         . ,     <i>u</i> , <i>v</i>  <i>n</i> (   ),     <i>right</i> , <i>up</i>  <i>forward</i> ‚Äî     ,    .      . <br><br><img src="https://habrastorage.org/files/0cb/281/f18/0cb281f183904b61b3019e2e0352be22.png"><br><br>      API      ‚Äî      .  ,        ,       <i>up</i> (    <i>up'</i> ).               : <br><br><ul><li>   <i>right</i>   <i>forward</i>  <i>up'</i>    : <br><img src="https://habrastorage.org/files/14b/281/52e/14b28152ed2949c1b45aa0e176e8d069.png"></li><li>    <i>up</i> ,  <i>right</i> <i> forward</i> : <br><img src="https://habrastorage.org/files/a1a/61f/16a/a1a61f16a2f44d44aeb72af6a44ebde1.png"></li></ul><br>  ,  <i>up'</i>   <i>forward</i>  ,        <i>up</i> .       OpenGL,         <a href="">gluLookAt</a> . <br><br>         ‚Äî     ,       <br><br></li><li> <i>z</i> -      (near/far clipping plane)     <br><br></li><li> Camera viewing angles.  They set the dimensions of the truncated view pyramid: <br><br><img src="https://habrastorage.org/files/39e/d1b/c09/39ed1bc0959a4ef29d0ba3a37a8d38dd.png"><br><br>  Since the scene will later be projected onto the projection plane, the image on this plane will later be displayed on the computer screen.  Therefore, it is important that the aspect ratio of this plane and the window (or part thereof) in which the image will be shown coincides.  This can be achieved by giving the API user the ability to set only one viewing angle, and the second to calculate in accordance with the aspect ratio of the window.  For example, knowing the horizontal viewing angle, we can calculate the vertical as follows: <br><br><img src="https://habrastorage.org/files/8c5/299/b7c/8c5299b7c3f44ff8959c9be12d29848a.png"><br><br>  When we discussed the central projection, we saw that the farther the projection plane from the camera, the larger the size of the resulting image - we denoted the distance from the camera (assuming that it is located at the origin) along the <i>z</i> axis from the projection plane of the variable <i>d</i> .  Accordingly, the question should be solved, what value of <i>d</i> we need to choose.  In fact, any non-zero.  Despite the fact that the image size increases with increasing <i>d</i> , that part of the projection plane, which intersects with the pyramid of view, increases proportionally, leaving the same image scale relative to the dimensions of this part of the plane.  In the future, we will use <i>d = 1</i> for convenience. <br><br>  Example in 2D: <br><br><img src="https://habrastorage.org/files/be3/319/273/be3319273d044ffe977d0fa439c7c0d9.gif"><br><br>  As a result, for zooming, we need to change the viewing angles - this will change the size of the part of the projection plane that intersects with the pyramid of the review, leaving the projection size the same. <br></li></ul><br><br>  We can move and rotate the camera, changing the position and orientation of its coordinate system.  Code example: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> camera::move_right(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance) { m_position += m_right * distance; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> camera::move_left(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distance) { move_right(-distance); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> camera::move_up(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distance) { m_position += m_up * distance; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> camera::move_down(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distance) { move_up(-distance); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> camera::move_forward(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distance) { m_position += m_forward * distance; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> camera::move_backward(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distance) { move_forward(-distance); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> camera::yaw(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> radians) { matrix3x3 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rotation{matrix3x3::rotation_around_y_axis(radians)}; m_forward = m_forward * rotation; m_right = m_right * rotation; m_up = m_up * rotation; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> camera::pitch(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> radians) { matrix3x3 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rotation{matrix3x3::rotation_around_x_axis(radians)}; m_forward = m_forward * rotation; m_right = m_right * rotation; m_up = m_up * rotation; }</code> </pre> <br></div></div><br><h4>  Graphics pipeline </h4><br>  Now we have all the necessary foundation in order to describe by steps the steps that are necessary to obtain an image of a three-dimensional scene on a computer screen.  For simplicity, we will assume that the pipeline draws one object at a time. <br><br>  Incoming parameters of the pipeline: <br><ul><li>  Object and its orientation in the world coordinate system </li><li>  The camera whose parameters we will use when composing the image </li></ul><br><h5>  1. Transition to the world coordinate system </h5><br>  At this stage, we transform the object vertices from the local coordinate system into the world one. <br><br>  Suppose that the orientation of an object in the world coordinate system is defined by the following parameters: <br><ul><li>  At what point in the world coordinate system is the object: <i>(x <sub>world</sub> , y <sub>world</sub> , z <sub>world</sub> )</i> </li><li>  How the object is rotated: <i>(r <sub>x</sub> , r <sub>y</sub> , r <sub>z</sub> )</i> </li><li>  Object scale: <i>(s <sub>x</sub> , s <sub>y</sub> , s <sub>z</sub> )</i> </li></ul><br>  We call the matrices of these transformations <i>T</i> , <i>R,</i> and <i>S,</i> respectively.  To obtain the final matrix, which will transform an object into a world coordinate system, we need only to multiply them.  It is important to note here that the order of multiplication of matrices plays a role - this directly follows from the fact that the multiplication of matrices is noncommutative. <br><br>  Recall that scaling occurs relative to the origin.  If we first displace the object to the desired point, and then apply a scale to it, we will get the wrong result - the position of the object will change again after scaling.  A simple example: <br><br><img src="https://habrastorage.org/files/086/a40/938/086a40938302440abc396d61908015d6.png"><br><br>  A similar rule applies with respect to rotation - it occurs relative to the origin, which means that the position of the object will change if we first make a movement. <br><br>  Thus, the correct sequence in our case is as follows: scaling - rotation - offset: <br><br><img src="https://habrastorage.org/files/3c2/7f5/2dc/3c27f52dc8b347c9a8c2b8330f6b2013.png"><br><br><h5>  2. Transition to camera coordinate system </h5><br>  The transition to the camera's coordinate system, in particular, is used to simplify further calculations.  In this coordinate system, the camera is located at the origin, and its axes are the <i>forward</i> , <i>right</i> , <i>up</i> vectors, which we considered in the previous section. <br><br>  The transition to the camera coordinate system consists of two steps: <br><ul><li>  Move the world so that the position of the camera coincides with the origin </li><li>  Using the calculated axes <i>right</i> , <i>up</i> , <i>forward</i> , we calculate the coordinates of the object's vertices along these axes (this step can be viewed as a rotation of the camera's coordinate system so that it coincides with the world coordinate system) </li></ul><br>  The first step can be easily represented as a matrix of displacement on <i>(-pos <sub>x</sub> , -pos <sub>y</sub> , -pos <sub>z</sub> )</i> , where <i>pos</i> is the position of the camera in the world coordinate system: <br><br><img src="https://habrastorage.org/files/4cf/f16/af0/4cff16af0c7a41b88643a0d870bbae28.png"><br><br>  To implement the second item, we use the property of the scalar product, which we considered at the very beginning - the scalar product calculates the length of the projection along a given axis.  Thus, in order to transfer point <i>A</i> to the camera's coordinate system (taking into account the fact that the camera is at the origin, we did this in the first paragraph), we just need to take its scalar product with the vectors <i>right</i> , <i>up</i> , <i>forward</i> .  Denote a point in the world coordinate system <i>v</i> , and the same point translated into the camera coordinate system, <i>v '</i> , then: <br><br><img src="https://habrastorage.org/files/310/ddf/c39/310ddfc39bec4eb2aa65aeeeeda9acdf.png"><br><br>  This operation can be represented as a matrix: <br><br><img src="https://habrastorage.org/files/248/221/b15/248221b157ff49c1a429539d15a69dce.png"><br><br>  Combining these two transformations, we get the transition matrix to the camera coordinate system: <br><br><img src="https://habrastorage.org/files/7e6/df8/c9b/7e6df8c9bff84d8abaf7727407ffc383.png"><br><br>  Schematically, this process can be depicted as follows: <br><br><img src="https://habrastorage.org/files/1d6/b3f/f7b/1d6b3ff7bbdc4f96a92057e68a0b3fdd.gif"><br><br><h5>  3. Transition to homogeneous clipping space and normalization of coordinates </h5><br>  As a result of the previous point, we obtained the coordinates of the object's vertices in the camera's coordinate system.  The next thing to do is to make a projection of these vertices on the plane and ‚Äúcut off‚Äù the extra vertices.  The vertex of the object is cut off if it lies outside the pyramid of the review (i.e. its projection does not lie on that part of the plane which the pyramid of the survey covers).  For example, vertex <i>v <sub>1</sub></i> in the figure below: <br><br><img src="https://habrastorage.org/files/c05/915/1c3/c059151c35254771bbcbfbe80e233e4b.png"><br><br>  Both of these tasks are partially solved by the projection matrix.  ‚ÄúPartially‚Äù - because it does not produce the projection itself, but prepares the <i>w-</i> coordinate of the vertex for this.  Because of this, the name ‚Äúprojection matrix‚Äù does not sound very appropriate (although this is a fairly common term), and I will call it the clip matrix in the future, since it also displays the truncated view pyramid in a uniform clipping space (homogeneous clip space). <br><br>  But first things first.  So, the first is preparation for the projection.  For this, we put the <i>z-</i> coordinate of the vertex in its <i>w-</i> coordinate.  The projection itself (that is, division by <i>z</i> ) will occur upon further normalization of the w-coordinate ‚Äî that is,  when returning to the space <i>w = 1</i> . <br><br>  The next thing this matrix has to do is translate the coordinates of the vertices of the object from the camera space into a homogeneous clip space.  This space, the coordinates of the non-clipped vertices in which are such that after applying the projection (i.e., dividing by the <i>w-</i> coordinate, since we saved the old <i>z-</i> coordinate in it), the coordinates of the vertex are normalized;  satisfy the following conditions: <br><br><img src="https://habrastorage.org/files/da7/746/a96/da7746a96370469d8bf6ed21ceb4c3e6.png"><br><br>  Inequality for <i>z</i> coordinates can vary for different APIs.  For example, in OpenGL, it corresponds to what is above.  In Direct3D, the <i>z</i> coordinate is displayed in the interval <i>[0, 1]</i> .  We will use the OpenGL interval, i.e.  <i>[-1, 1]</i> . <br>  Such coordinates are called normalized device coordinates (normalized device coordinates or simply NDC). <br><br>  Since we obtain the NDC coordinates by dividing the coordinates by <i>w</i> , the vertices in the cut-off space satisfy the following conditions: <br><br><img src="https://habrastorage.org/files/cc9/09b/1fb/cc909b1fbaf34bbd949ff35ecba27617.png"><br><br>  Thus, by transferring the vertices to this space, we can find out whether it is necessary to cut the vertex simply by checking its coordinates for the inequalities above.  Any vertex that does not satisfy these conditions must be cut off.  The cut-off itself is a topic for a separate article, because its correct implementation leads to the creation of new vertices.  So far, as a quick fix, we will not draw a face if at least one of its vertices is clipped.  Of course, the result will not be very neat.  For example, for a car model, it looks like this: <br><br><img src="https://habrastorage.org/files/663/80c/22c/66380c22c48f477597b6682575a53e6a.gif"><br><br>  Total, this stage consists of the following steps: <br><ul><li>  Get vertices in camera space </li><li>  Multiply by the clipping matrix - go to the clipping space </li><li>  Mark clipped vertices by checking for the inequalities described above. </li><li>  We divide the coordinates of each vertex into its <i>w-</i> coordinate - go to the normalized coordinates </li></ul><br>  Now consider how we map the coordinates from the camera space to the clipping space.  Recall that we decided to use the projection plane <i>z = 1</i> .  First we need to find a function that displays the coordinates lying on the intersection of the pyramid of the review and the projection plane in the interval <i>[-1, 1]</i> .  For this we find the coordinates of the points defining this part of the plane.  These two points have coordinates <i>(left, top)</i> and <i>(right, bottom)</i> .  We will consider only the case when the pyramid of view is symmetrical about the direction of the camera. <br><br><img src="https://habrastorage.org/files/067/81d/a4c/06781da4c0ba4118814cc1e08e5497e5.png"><br><br>  We can calculate them using viewing angles: <br><br><img src="https://habrastorage.org/files/7e8/63e/0b4/7e863e0b46364a49924c79f164854772.png"><br><br>  We get: <br><br><img src="https://habrastorage.org/files/497/ce9/f06/497ce9f0632a4b5da1a2ce3930ebd167.png"><br><br>  Similarly for <i>top</i> and <i>bottom</i> : <br><br><img src="https://habrastorage.org/files/efa/f96/5cd/efaf965cd28c4e8ca54a23fbd9e9dd03.png"><br><br>  Thus, we need to display the interval <i>[left, right]</i> , <i>[bottom, top]</i> , <i>[near, far]</i> in <i>[-1;</i>  <i>1]</i> .  Find a linear function that gives this result for <i>left</i> and <i>right</i> : <br><br><img src="https://habrastorage.org/files/f7b/857/c6c/f7b857c6c125433e8a9677b88b9c54f4.png"><br><br>  Similarly, the function for the <i>bottom</i> and <i>top is</i> obtained: <br><br><img src="https://habrastorage.org/files/dbc/d90/a37/dbcd90a37f754139892b8955babe0990.png"><br><br>  The expression for <i>z</i> is different.  Instead of considering a function of the form <i>az + b,</i> we will consider the function <i>a ¬∑ 1 / z + b</i> , because later, when we implement the depth buffer, we will need to linearly interpolate the inverse of the z-coordinate.  We will not consider this issue now, and just take it for this.  We get: <br><br><img src="https://habrastorage.org/files/ca5/7ff/0b7/ca57ff0b75984c599ed0cbea63c74ca9.png"><br><br>  Thus, we can write that the normalized coordinates are obtained as follows from the coordinates in the camera space: <br><br><img src="https://habrastorage.org/files/c79/8df/85f/c798df85fe4d48c59c87c4e7c86e1b61.png"><br><br>  We cannot immediately apply these formulas, because division by <i>z</i> will occur later, with normalization of <i>w-</i> coordinates.  We can use this, and instead calculate the following values ‚Äã‚Äã(multiplying by z), which after dividing by <i>w</i> , will result in normalized coordinates: <br><br><img src="https://habrastorage.org/files/b58/f5c/a72/b58f5ca72c6240dfa156355980c371ce.png"><br><br>  It is by these formulas that we transform into the cut-off space.  We can write this transformation in matrix form (remembering additionally that we put <i>z</i> in the <i>w</i> coordinate): <br><br><img src="https://habrastorage.org/files/d54/36e/e75/d5436ee75d074e45a77e562c1cce08c7.png"><br><br><h5>  Transition to screen coordinate system </h5><br>  To the current stage, we have the coordinates of the object vertices in the NDC.  We need to translate them into screen coordinate system.  Recall that the upper left corner of the projection plane was mapped to (-1, 1), and the lower right to (1, -1).  For the screen, I will use the upper left corner as the origin of the coordinate system, with the axes pointing right and down: <br><br><img src="https://habrastorage.org/files/0c1/158/68b/0c115868bfee4ab7b092527005eaf4c3.png"><br><br>  This viewport transformation can be made using simple formulas: <br><br><img src="https://habrastorage.org/files/079/623/619/07962361968248389c0fddc9f08557d9.png"><br><br>  Or, in matrix form: <br><br><img src="https://habrastorage.org/files/380/2c4/825/3802c48256434fb182255eeb9083bbd0.png"><br><br>  We will leave using z <sub>ndc</sub> until the implementation of the depth buffer. <br><br>  As a result, we have the coordinates of the vertices on the screen, which we use for drawing. <br><br><h5>  Implementation in code </h5><br>  Below is an example of code that implements a pipeline using the method described above and performing drawing in wireframe mode (i.e., simply connecting vertices with lines).  It also implies that the object is described by a set of vertices and a set of indexes of the vertices (faces) of which its polygons consist: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> pipeline::draw_mesh( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;mesh <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&gt; mesh, vector3 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; position, vector3 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; rotation, camera <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; camera, bitmap_painter&amp; painter) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { matrix4x4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> local_to_world_transform{ matrix4x4::rotation_around_x_axis(rotation.x) * matrix4x4::rotation_around_y_axis(rotation.y) * matrix4x4::rotation_around_z_axis(rotation.z) * matrix4x4::translation(position.x, position.y, position.z)}; matrix4x4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> camera_rotation{ camera.get_right().x, camera.get_up().x, camera.get_forward().x, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, camera.get_right().y, camera.get_up().y, camera.get_forward().y, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, camera.get_right().z, camera.get_up().z, camera.get_forward().z, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>}; matrix4x4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> camera_translation{ <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, -camera.get_position().x, -camera.get_position().y, -camera.get_position().z, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>}; matrix4x4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> world_to_camera_transform{camera_translation * camera_rotation}; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> projection_plane_z{<span class="hljs-number"><span class="hljs-number">1.0f</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> near{camera.get_near_plane_z()}; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> far{camera.get_far_plane_z()}; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> right{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(camera.get_horizontal_fov() / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>) * projection_plane_z}; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> left{-right}; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> top{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(camera.get_vertical_fov() / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>) * projection_plane_z}; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bottom{-top}; matrix4x4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> camera_to_clip_transform{ <span class="hljs-number"><span class="hljs-number">2.0f</span></span> * projection_plane_z / (right - left), <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span> * projection_plane_z / (top - bottom), <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, (left + right) / (left - right), (bottom + top) / (bottom - top), (far + near) / (far - near), <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-2.0f</span></span> * near * far / (far - near), <span class="hljs-number"><span class="hljs-number">0.0f</span></span>}; matrix4x4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> local_to_clip_transform{ local_to_world_transform * world_to_camera_transform * camera_to_clip_transform}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;vector4&gt; transformed_vertices; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (vector3 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; v : mesh-&gt;get_vertices()) { vector4 v_transformed{vector4{vx, vy, vz, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>} * local_to_clip_transform}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((v_transformed.x &gt; v_transformed.w) || (v_transformed.x &lt; -v_transformed.w)) { mark_vector4_as_clipped(v_transformed); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((v_transformed.y &gt; v_transformed.w) || (v_transformed.y &lt; -v_transformed.w)) { mark_vector4_as_clipped(v_transformed); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((v_transformed.z &gt; v_transformed.w) || (v_transformed.z &lt; -v_transformed.w)) { mark_vector4_as_clipped(v_transformed); } transformed_vertices.push_back(v_transformed); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> width{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(painter.get_bitmap_width())}; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> height{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(painter.get_bitmap_height())}; matrix4x4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ndc_to_screen{ width / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, -height / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, width / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, height / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (vector4&amp; v : transformed_vertices) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_vector4_marked_as_clipped(v)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> w_reciprocal{<span class="hljs-number"><span class="hljs-number">1.0f</span></span> / vw}; vx *= w_reciprocal; vy *= w_reciprocal; vz *= w_reciprocal; vw = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; v = v * ndc_to_screen; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (face <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; f : mesh-&gt;get_faces()) { vector4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; v1{transformed_vertices[f.index1]}; vector4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; v2{transformed_vertices[f.index2]}; vector4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; v3{transformed_vertices[f.index3]}; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v1_clipped{is_vector4_marked_as_clipped(v1)}; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v2_clipped{is_vector4_marked_as_clipped(v2)}; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v3_clipped{is_vector4_marked_as_clipped(v3)}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!v1_clipped &amp;&amp; !v2_clipped) { painter.draw_line( point2d{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(v1.x), <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(v1.y)}, point2d{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(v2.x), <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(v2.y)}, color{<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>}); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!v3_clipped &amp;&amp; !v2_clipped) { painter.draw_line( point2d{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(v2.x), <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(v2.y)}, point2d{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(v3.x), <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(v3.y)}, color{<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>}); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!v1_clipped &amp;&amp; !v3_clipped) { painter.draw_line( point2d{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(v3.x), <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(v3.y)}, point2d{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(v1.x), <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(v1.y)}, color{<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>}); } } }</code> </pre><br></div></div><br><h4>  An example of using SDL2 for implementation </h4><br>  In this section, I will briefly explain how SDL2 can be used to implement rendering. <br><br><h5>  Texture initialization </h5><br>  The first is, of course, the initialization of the library and the creation of the window.  If only graphics are needed from SDL, then you can initialize with the <b>SDL_INIT_VIDEO</b> flag: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SDL_Init(SDL_INIT_VIDEO) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(SDL_GetError()); } m_window = SDL_CreateWindow( <span class="hljs-string"><span class="hljs-string">"lantern"</span></span>, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, width, height, SDL_WINDOW_SHOWN); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_window == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(SDL_GetError()); } m_renderer = SDL_CreateRenderer(m_window, <span class="hljs-number"><span class="hljs-number">-1</span></span>, SDL_RENDERER_ACCELERATED); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_renderer == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(SDL_GetError()); }</code> </pre><br></div></div><br>  Then, create a texture into which we will render.  I will use the <b>ARGB8888</b> format, which means that each pixel in the texture will be allocated 4 bytes - three bytes on the RGB channels, and one on the alpha channel. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">m_target_texture = SDL_CreateTexture( m_renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, width, height); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_target_texture == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(SDL_GetError()); }</code> </pre><br></div></div><br>  You need to remember to ‚Äúclear‚Äù the SDL and all variables taken from it when the application exits: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_target_texture != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { SDL_DestroyTexture(m_target_texture); m_target_texture = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_renderer != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { SDL_DestroyRenderer(m_renderer); m_renderer = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_window != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { SDL_DestroyWindow(m_window); m_window = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } SDL_Quit();</code> </pre><br></div></div><br><h5>  Drawing, display on the screen </h5><br>  We can use <b>SDL_UpdateTexture</b> to update the texture, which we will then display on the screen.  This function accepts, among others, the following parameters: <br><ul><li>  Data is an array of bytes, which is an array of pixels with corresponding values. </li><li>  The number of bytes in one line of the image (pitch) is calculated as the number of pixels multiplied by 4 (because the format is <b>ARGB8888</b> ) </li></ul><br>  It is logical to allocate the drawing functionality to the texture, represented by an array of bytes, in a separate class.  It will allocate memory for the array, clear the texture, draw pixels and lines.  Drawing a pixel can be done as follows (the order of bytes differs depending on <b>SDL_BYTEORDER</b> ): <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> bitmap_painter::draw_pixel(point2d <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; point, color <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; c) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixel_first_byte_index{m_pitch * point.y + point.x * <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SDL_BYTEORDER == SDL_BIG_ENDIAN m_data[pixel_first_byte_index + 0] = cb; m_data[pixel_first_byte_index + 1] = cg; m_data[pixel_first_byte_index + 2] = cr; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// m_data[pixel_first_byte_index + 3] is alpha, we don't use it for now #else // m_data[pixel_first_byte_index + 0] is alpha, we don't use it for now m_data[pixel_first_byte_index + 1] = cr; m_data[pixel_first_byte_index + 2] = cg; m_data[pixel_first_byte_index + 3] = cb; #endif }</span></span></span></span></code> </pre><br></div></div><br>  Line drawing can be implemented, for example, by <a href="http://en.wikipedia.org/wiki/Bresenham%2527s_line_algorithm">the Brezenham algorithm</a> . <br><br>  After using <b>SDL_UpdateTexture</b> , you must copy the texture into <b>SDL_Renderer</b> and display it on the screen using <b>SDL_RenderPresent</b> .  Together: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">SDL_UpdateTexture(m_target_texture, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, m_painter.get_data(), m_painter.get_pitch()); SDL_RenderCopy(m_renderer, m_target_texture, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); SDL_RenderPresent(m_renderer);</code> </pre><br></div></div><br>  That's all.  Link to the project: <a href="https://github.com/loreglean/lantern">https://github.com/loreglean/lantern</a> . </div><p>Source: <a href="https://habr.com/ru/post/243011/">https://habr.com/ru/post/243011/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242999/index.html">Postgres. Sample N random entries</a></li>
<li><a href="../243001/index.html">Memo: How startups provide data protection in the cloud</a></li>
<li><a href="../243005/index.html">Monospaced fonts with programmer ligatures</a></li>
<li><a href="../243007/index.html">How a non-programmer created his mobile app</a></li>
<li><a href="../243009/index.html">Developer vulnerability in Raindrop.io</a></li>
<li><a href="../243013/index.html">Enthusiast designed a homemade 8-bit processor in Minecraft</a></li>
<li><a href="../243015/index.html">At any given time about the third part of Internet users are on-line.</a></li>
<li><a href="../243017/index.html">10 lessons on how to increase productivity, which I learned by working 90 hours a week for a month</a></li>
<li><a href="../243021/index.html">Vibration of the XboxOne gamepad for Unity3d</a></li>
<li><a href="../243023/index.html">Why Spritz has become so popular over the past few weeks.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>