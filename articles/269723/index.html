<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Test Recipes for Ruby and Rails Applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post I would like to talk about the approaches, techniques and means of test preparation. I‚Äôll tell you how not to write too much, duplicate c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Test Recipes for Ruby and Rails Applications</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/6ba/386/d57/6ba386d5794b3b6ba6f689f0a59ce8e9.png" alt="image"><br><br>  In this post I would like to talk about the approaches, techniques and means of test preparation.  I‚Äôll tell you how not to write too much, duplicate code less, write tests so that they are easy to maintain, and how to gain performance in some situations. <br><br>  Who will it be interesting? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  If you started writing tests recently. </li><li>  If you write tests and consider that they have a lot of copy-paste, or you can significantly improve them. </li><li>  If you write tests occasionally or do not write at all, because you do not like it or think it is a long time. </li><li>  If you are a master in writing tests.  Perhaps you will learn some subtleties or find some useful trifles. </li></ul><br><a name="habracut"></a><br>  I will give examples of code for RSpec, but most of them will work with MiniTest (some will need to be brought by a file).  Those who use RSpec, but have not yet read <a href="http://betterspecs.org/">betterspecs.org</a> , I advise you to look at it - it shows how to write well and how to write it with examples. <br><br><h4>  On every day </h4><br><h5>  RSpec DSL </h5><br>  RSpec actually creates a class for each context.  This means that you can declare instance and class methods in the spec text and use them in all nested contexts.  There are several helper who will help with this. <br><br><h5>  let </h5><br>  In RSpec, <code>let</code> is the preferred way to set local "variables."  It defines a new instance method that returns a block result calculated in the context of the test.  The result is calculated lazily, so there is nothing to worry about if you define `let` and do not use it in the part of the tests - this will not affect the testing time.  A block of one <code>let</code> can use the result of another <code>let</code> or a result from an external context through <code>super</code> : <br><br><pre> <code class="ruby hljs">let(<span class="hljs-symbol"><span class="hljs-symbol">:project</span></span>) { Project.new(project_attrs) } let(<span class="hljs-symbol"><span class="hljs-symbol">:project_attrs</span></span>) { {<span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-string"><span class="hljs-string">'new_name'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">description:</span></span> <span class="hljs-string"><span class="hljs-string">'new_description'</span></span>} } context <span class="hljs-string"><span class="hljs-string">'when empty name is given'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> let(<span class="hljs-symbol"><span class="hljs-symbol">:project_attrs</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>().merge!(<span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>) } <span class="hljs-comment"><span class="hljs-comment">#    ruby super     ,   . #   ,  (). end</span></span></code> </pre><br>  When using <code>let</code> should note that the result of the block is cached for the duration of the example.  The values ‚Äã‚Äãdetermined by him are, in fact, constants at the time of the test.  Therefore, <code>let</code> not suitable for creating shortcuts.  If it is assumed that the value will change, then it will be correct to declare the method. <br><br><h5>  subject </h5><br>  <code>subject</code> is the "special" <code>let</code> .  The main feature is that all matchers who do not have a recipient are applied to the <code>subject</code> . <br><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'#valid?'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> subject { user.valid? } it { should eq <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-comment"><span class="hljs-comment">#  it { is_expected.to eq true } # subject    c   context 'when name is empty' do it 'adds error' do expect { subject }.to change(user.errors, :any?).to true end end end</span></span></code> </pre><br>  Using <code>subject</code> reduces the amount of duplicated code, increases readability and allows you to determine situations when you are testing a functionality other than that specified in <code>describe</code> .  In most cases, you will be able to use a single <code>subject</code> on the <code>describe</code> , influencing its behavior with the help of <code>let</code> in nested contexts: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#    RSpec.describe ProjectsController do describe '#index' do subject { get :index } it { should redirect_to new_user_session_path } context 'for signed in user' do sign_in { create(:user) } # ,    it { should be_forbidden } context 'with permissions' do add_permissions(:manager) #       it { should be_ok } end end end #         describe '#create' do subject { post :create, project: resource_params } let(:resource_params) { {name: 'new_project'} } it 'creates resource and redirects to its page' do expect { subject }.to change(Project, :count).by(1) resource = Project.last expect(project.name).to eq 'new_name' expect(subject).to redirect_to project_path(resource) end context 'when params are invalid' do let(:resource_params) { super().merge!(name: '') } it { should render_template :new } it 'doesnt create resource' do expect { subject }.to_not change(Project, :count) end end end end</span></span></code> </pre><br>  In `type:: request` tests, <code>get</code> , <code>post</code> and other methods do not return a <code>response</code> .  But you can slightly correct our <code>subject</code> to use the same approach in them: <br><br><pre> <code class="ruby hljs">subject <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/projects'</span></span> response <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Prior to this, we placed an expression in the <code>subject</code> , the result of which was checked.  It often happens that the result checks are much less than the checks that the state of the system has changed.  In such cases, help lambda: <br><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'#like!'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> subject { -&gt; { user.like! post } } it { should change(post, <span class="hljs-symbol"><span class="hljs-symbol">:likes_count</span></span>).by(<span class="hljs-number"><span class="hljs-number">1</span></span>) } it { should change(user, <span class="hljs-symbol"><span class="hljs-symbol">:favorite_posts</span></span>).by(post) } context <span class="hljs-string"><span class="hljs-string">'when post is already favorite'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> before { subject.call } it { should raise_error /Already favorite/ } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Lambdas are also useful in cases where you need to check the result of a method on a large amount of input data, and it makes no sense to create a context for each option: <br><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'.cleanup_str'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> subject { -&gt;(*args) { described_class.cleanup_str(*args) } } it <span class="hljs-string"><span class="hljs-string">'removes non-word symbols'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> expect(subject.call(<span class="hljs-string"><span class="hljs-string">'xY12'</span></span>)).to eq <span class="hljs-string"><span class="hljs-string">'xY12'</span></span> expect(subject.call(<span class="hljs-string"><span class="hljs-string">'x+Y-1_2'</span></span>)).to eq <span class="hljs-string"><span class="hljs-string">'xY12'</span></span> expect(subject.call(<span class="hljs-string"><span class="hljs-string">'xY 1;2'</span></span>)).to eq <span class="hljs-string"><span class="hljs-string">'xY12'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Note that in all examples we do not refer to the method being tested, except through <code>subject</code> . <br><br><h6>  its </h6><br>  For RSpec, there is an excellent <a href="https://github.com/rspec/rspec-its">rspec-its</a> plugin, which they brought to a separate gem in version 3.  With this thing, the tests can become even more compact and expressive.  <a href="">Here is an example</a> where <code>its</code> exactly would come in handy. <br><br>  Not quite obvious, but very useful trick - using <code>its</code> with lambdas: <br><br><pre> <code class="ruby hljs">RSpec.describe ProjectsController <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> let(<span class="hljs-symbol"><span class="hljs-symbol">:resource</span></span>) { create(<span class="hljs-symbol"><span class="hljs-symbol">:project</span></span>) } describe <span class="hljs-string"><span class="hljs-string">'#update'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> subject { -&gt; { patch <span class="hljs-symbol"><span class="hljs-symbol">:update</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> project, <span class="hljs-symbol"><span class="hljs-symbol">project:</span></span> resource_params } } let(<span class="hljs-symbol"><span class="hljs-symbol">:resource_params</span></span>) { {<span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-string"><span class="hljs-string">'updated_name'</span></span>} } it { should change { resource.reload.name }.to <span class="hljs-string"><span class="hljs-string">'updated_name'</span></span> } its(<span class="hljs-symbol"><span class="hljs-symbol">:call</span></span>) { should redirect_to project_path(resource) } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Another situation where <code>its</code> very useful - when checking JSON responses.  If you define the <code>ActionDispatch::TestResponse#json_body</code> , which passes <code>#body</code> via <code>JSON.parse</code> and turns the result into <code>Mash</code> (for example, <a href="">this way</a> ), then it becomes very convenient to check the fields: <br><br><pre> <code class="ruby hljs">RSpec.describe UsersController <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> let(<span class="hljs-symbol"><span class="hljs-symbol">:resourse</span></span>) { create(<span class="hljs-symbol"><span class="hljs-symbol">:user</span></span>) } describe <span class="hljs-string"><span class="hljs-string">'#show'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> subject { get <span class="hljs-symbol"><span class="hljs-symbol">:show</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> resource, <span class="hljs-symbol"><span class="hljs-symbol">format:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:json</span></span> } its(<span class="hljs-string"><span class="hljs-string">'json_body.keys'</span></span>) { should contain_exactly(*w(name projects avatar)) } its(<span class="hljs-string"><span class="hljs-string">'json_body.avatar.keys'</span></span>) { should contain_exactly(*w(url size)) } its(<span class="hljs-string"><span class="hljs-string">'json_body.projects.first.keys'</span></span>) { should contain_exactly(*w(name created_at)) } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><h5>  described_class </h5><br>  <code>described_class</code> is another ‚Äúspecial‚Äù <code>let</code> .  This is the helper for accessing the object that you specified in <code>RSpec.describe</code> .  When using it instead of explicitly specifying the module, the code is ‚Äúdetached‚Äù: the class as a <code>describe</code> argument, and it is accessed as an argument.  Such code is more suitable for reuse, for example, it is easier to allocate it in <code>shared_examples</code> .  <code>described_class</code> works without problems with constants: <code>should raise_error described_class::Error</code> , or <code>described_class::LIMIT</code> . <br><br><h5>  Variable naming </h5><br>  Try using common neutral names for some variables in all tests.  We, for example, use <code>instance</code> to denote instances of tested classes and <code>resource</code> to denote the resource being processed in controller / query tests.  I cannot name the objective advantages of this approach, but subjectively, tests are written and read faster. <br><br><h5>  shared_examples </h5><br>  Local <code>shared_examples</code> can be defined within any context, and they will not be accessible outside this context.  This is useful when you need to repeat checks in several nested contexts: <br><br><pre> <code class="ruby hljs">RSpec.describe ProjectsController <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> let(<span class="hljs-symbol"><span class="hljs-symbol">:resource</span></span>) { create(<span class="hljs-symbol"><span class="hljs-symbol">:project</span></span>) } shared_examples <span class="hljs-string"><span class="hljs-string">'rendering resource'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it { should be_ok } its(<span class="hljs-symbol"><span class="hljs-symbol">:json_body</span></span>) { should <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; resource.id, <span class="hljs-string"><span class="hljs-string">'name'</span></span> =&gt; resource.name } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> describe <span class="hljs-string"><span class="hljs-string">'#show'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> subject { get <span class="hljs-symbol"><span class="hljs-symbol">:show</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> resource.id } include_examples <span class="hljs-string"><span class="hljs-string">'rendering resource'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> describe <span class="hljs-string"><span class="hljs-string">'#search'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> subject { get <span class="hljs-symbol"><span class="hljs-symbol">:search</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">q:</span></span> resource.name } include_examples <span class="hljs-string"><span class="hljs-string">'rendering resource'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Sometimes when using <code>shared_examples</code> it is necessary to add special checks only in certain cases or to give the opportunity to replace some checks with others for some tests.  In such cases, you can split large blocks of <code>shared_examples</code> into smaller ones and copy contexts between files.  But you can pass the necessary checks in the parameters to <code>include_examples</code> : <br><br><pre> <code class="ruby hljs">RSpec.shared_examples <span class="hljs-string"><span class="hljs-string">'hooks controller #create'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|**options|</span></span> describe <span class="hljs-string"><span class="hljs-string">'#create'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> subject { post <span class="hljs-symbol"><span class="hljs-symbol">:create</span></span>, params } context <span class="hljs-string"><span class="hljs-string">'on success'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> let(<span class="hljs-symbol"><span class="hljs-symbol">:params</span></span>) { valid_params } <span class="hljs-comment"><span class="hljs-comment">#   it { should change { something } } #   instance_exec(&amp;options[:on_success]) if options[:on_success] end context 'on failure' do let(:params) { invalid_params } it { should_not change { something } } if options[:on_failure] instance_exec(&amp;options[:on_failure]) else its(:status) { should eq 422 } #   end end end end RSpec.describe BrandedHooksController do include_examples 'hooks controller #create', on_success: -&gt; { its(:json_body) { should eq 'status' =&gt; 'ok' } }, on_failure: -&gt; { its(:json_body) { should eq 'status' =&gt; 'rejected' } } do let(:valid_params) { {type: 'hook'} } let(:invalid_params) { {type: 'unsupported'} } end end</span></span></code> </pre><br><h4>  Accelerate Tests </h4><br>  I will not write about spring / zeus / spork / etc., but I will tell you how to reduce testing time in some other situations. <br><br><h5>  Disable long tests </h5><br>  :) But not really.  Of course, this approach may not be suitable for many reasons, but if you have tasks that require long calculations, mark them with an RSpec tag and disable them when you start <code>rspec</code> .  These can be calls to external applications, long queries to the database, work with large files. <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># spec_helper.rb # Exclude some tags by default. Running 1 file won't use exclusions. # Use `FULL=true bin/rspec` to disable filters. if (!ENV.key?('FULL') || !ENV.key?('CI')) &amp;&amp; config.files_to_run.size &gt; 1 config.filter_run_excluding :external, :elastics end # some_job_spec.rb describe '.process_file', :external do it 'does somithing heavy' end</span></span></code> </pre><br>  With such settings, Joba tests will not be executed every time, but will be executed if you run: <br><ul><li>  only one file <code>some_job_spec.rb</code> </li><li>  `FULL = true bin / rspec` </li><li>  on the CI server (if envar CI is installed) </li></ul><br><h5>  Disable image processing </h5><br>  I guess it will suit everyone who uses it.  If you do not use fixtures, and you have a mandatory image field in the model, then in each test that creates an instance of this class, the image will be processed. <br><br>  The way to disable processing depends on the library used.  In tests, the approach will be the same: disable processing for all tests and enable it by tag or in around-hook. <br><br><div class="spoiler">  <b class="spoiler_title">Example for carrierwave</b> <div class="spoiler_text"><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecHelpers</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># All image uploaders are descendants of ImageUploader. This module # toggles &lt;code&gt;enable_processing&lt;/code&gt; of it and all its descendants. module ImageProcessing module_function # Overwrites cached values in ancestors. def enable_processing=(val) ImageUploader.enable_processing = val ImageUploader.descendants.each { |x| x.enable_processing = val } end def with_processing(val) old_value = ImageUploader.enable_processing self.enable_processing = val yield ensure self.enable_processing = old_value unless old_value == ImageUploader.enable_processing end end end # rails_helper.rb around process_images: true do |ex| SpecHelpers::ImageProcessing.with_processing(true) { ex.run } end</span></span></span></span></code> </pre></div></div><br><br><h4>  Useful stuff </h4><br><ul><li>  RSpec3 uses <code>.rspec</code> to set default flags.  After installation, it has the line `--require spec_helper`.  If we replace it with `--require rails_helper`, then it will be possible not to write` require 'rails_helper' `in each spec. </li><li>  ^^ <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># spec_helper.rb require 'bigdecimal' BigDecimal.class_eval do alias_method :inspect_orig, :inspect alias_method :inspect, :to_s end</span></span></code> </pre><br></li></ul><br>  Thanks for attention!  Please share your recipes in comments. </div><p>Source: <a href="https://habr.com/ru/post/269723/">https://habr.com/ru/post/269723/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269709/index.html">Validation of complex structures with PHPixie Validate</a></li>
<li><a href="../269711/index.html">Another build Vivaldi 1.0.303.37 - Beta Candidate</a></li>
<li><a href="../269717/index.html">Maybe monad on steroids</a></li>
<li><a href="../269719/index.html">‚ÄúWhat's new in Swift 2?‚Äù With examples. Part 2</a></li>
<li><a href="../269721/index.html">Latest article about setting up a server for Rails</a></li>
<li><a href="../269725/index.html">How did we manage to build a video hosting for 1 ¬¢ / GB</a></li>
<li><a href="../269727/index.html">Multi-tier, extensible business information repository architecture. LSA and SAP BW. Traditional approach</a></li>
<li><a href="../269729/index.html">Certificate Transparency Overview</a></li>
<li><a href="../269731/index.html">Why Go is a badly designed programming language.</a></li>
<li><a href="../269733/index.html">Concepts of natural language versus formal classifications in OpenStreetMap</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>