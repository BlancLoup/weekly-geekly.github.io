<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Arrow functions in JavaScript: why they are needed, how to handle them, when they should be used, and when not</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the most notable innovations in modern JavaScript has been the emergence of arrow functions (arrow function), which are sometimes called ‚Äúfat‚Äù ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Arrow functions in JavaScript: why they are needed, how to handle them, when they should be used, and when not</h1><div class="post__text post__text-html js-mediator-article"> One of the most notable innovations in modern JavaScript has been the emergence of arrow functions (arrow function), which are sometimes called ‚Äúfat‚Äù arrow functions (fat arrow function).  When declaring such functions use a special combination of characters - <code>=&gt;</code> . <br><br>  Switch functions have two main advantages over traditional functions.  The first is a very convenient and compact syntax.  The second is that the approach to working with the value of <code>this</code> in the switch functions looks more intuitive than in normal functions. <br><br><div style="text-align:center;"> <a href="https://habr.com/company/ruvds/blog/428566/"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/09a/721/b1a09a721fe985d3700f4f74305e68d6.jpg" alt="image"></a> </div><br>  Sometimes these and other advantages lead to the fact that the switch syntax is given unconditional preference over other methods of function declaration.  For example, the popular <a href="https://github.com/airbnb/javascript">eslint configuration</a> from Airbnb forces that, whenever an anonymous function is created, such a function would be a switch. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, like other concepts and mechanisms used in programming, the switch functions have their pros and cons.  Their use can cause negative side effects.  In order to use the switch functions correctly, you need to know about possible problems associated with them. <br><br>  In the material, the translation of which we are publishing today, we will discuss how the switch functions.  Here we will consider situations in which their use can improve code, and situations in which they should not be used. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Features of arrow functions in JavaScript</font> </h2><br>  Arrow functions in javascript are something like <a href="https://www.programiz.com/python-programming/anonymous-function">lambda functions</a> in python and <a href="http://ruby-for-beginners.rubymonstas.org/blocks.html">blocks</a> in ruby. <br><br>  These are anonymous functions with a special syntax that take a fixed number of arguments and operate in the context of their scope, that is, in the context of a function or other code in which they are declared. <br><br>  Let's talk about this in more detail. <br><br><h3>  <font color="#3AC1EF">The syntax of the switch functions</font> </h3><br>  Arrow functions are built according to a unified scheme, and the structure of functions can be, in special cases, simplified.  The basic structure of the arrow function looks like this: <br><br><pre> <code class="hljs php">(argument1, argument2, ... argumentN) =&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br>  The list of function arguments is in parentheses, followed by an arrow composed of the characters <code>=</code> and <code>&gt;</code> , and then the function body is in curly braces. <br><br>  This is very similar to how ordinary functions are arranged, the main differences are that the <code>function</code> keyword is omitted here and an arrow is added after the argument list. <br><br>  In certain cases, however, simple arrow functions can be declared using much more compact constructions. <br><br>  Consider a variant of the syntax that is used if the body of the function is represented by a single expression.  It allows you to do without curly brackets framing the body of the function, and eliminates the need to explicitly return the results of the evaluation of the expression, since this result will be returned automatically.  For example, it might look like this: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b;</code> </pre> <br>  Here is another version of the abbreviated function write, used when the function has only one argument. <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFirst = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br>  As you can see, the parentheses framing the argument list are omitted here.  In addition, the function body, which in this example is represented by a single command, is also written without brackets.  Later we will talk about the advantages of such structures. <br><br><h3>  <font color="#3AC1EF">‚ñçReturn objects and abbreviated recording of pointer functions</font> </h3><br>  When working with the arrow functions, some more complex syntax structures are used, which are useful to know about. <br><br>  For example, we will try to use a single-line expression to return an object literal from a function.  It may seem, given what we already know about the arrow functions, that the function declaration will look like this: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-type"><span class="hljs-type">name</span></span>, description) =&gt; {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>, description: description};</code> </pre> <br>  The problem with this code is its ambiguity.  Namely, the curly braces that we want to use to describe the object literal look like we are trying to enclose the function body in them. <br><br>  In order to indicate to the system that we mean the object literal, we need to enclose it in parentheses: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-type"><span class="hljs-type">name</span></span>, description) =&gt; ({<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>, description: description});</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçFishers and their execution context</font> </h3><br>  Unlike other functions, the switch functions do not have their own <a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0">execution context</a> . <br><br>  In practice, this means that they inherit the <code>this</code> and <code>arguments</code> entities from the parent function. <br><br>  For example, compare the two functions presented in the following code.  One of them is normal, the second - arrow. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'test object'</span></span>, <span class="hljs-attr"><span class="hljs-attr">createAnonFunction</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name);     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>);   }; }, <span class="hljs-attr"><span class="hljs-attr">createArrowFunction</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name);     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>);   }; } };</code> </pre> <br>  There is a <code>test</code> object with two methods.  Each of them is a function that creates and returns an anonymous function.  The difference between these methods lies only in the fact that in the first method the traditional functional expression is used, and in the second - the arrow function. <br><br>  If you experiment with this code in the console, passing the same arguments to the object's methods, then although the methods look very similar, we will get different results: <br><br><pre> <code class="hljs cs">&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anon = test.createAnonFunction(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>); &gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrow = test.createArrowFunction(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>); &gt; anon(); undefined {} &gt; arrow(); test <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-string"><span class="hljs-string">'0'</span></span>: <span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-string"><span class="hljs-string">'world'</span></span> }</code> </pre> <br>  An anonymous function has its own context, therefore, when it is called, when accessing <code>test.name</code> <code>name</code> property of the object will not be displayed, and when <code>arguments</code> are called, the list of arguments of the function that was used to create and return the function being examined will not be displayed. <br><br>  In the case of the arrow function, it turns out that its context coincides with the context of the function that created it, which gives it access to both the list of arguments passed by this function and the <code>name</code> property of the object of which this function is. <br><br><h2>  <font color="#3AC1EF">Situations in which the switch functions improve code</font> </h2><br><h3>  <font color="#3AC1EF">‚ñçProcessing lists of values</font> </h3><br>  Traditional lambda functions, as well as arrow functions, after their appearance in JavaScript, are usually used in the situation when a certain function is applied to each element of a certain list. <br><br>  For example, if there is an array of values ‚Äã‚Äãthat needs to be converted using the array method <code>map</code> , an arrow function is ideal for describing such a conversion: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> words = [<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'WORLD'</span></span>, <span class="hljs-string"><span class="hljs-string">'Whatever'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> downcasedWords = words.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word</span></span></span><span class="hljs-function"> =&gt;</span></span> word.toLowerCase());</code> </pre> <br>  Here is an extremely common example of this use of switch functions, which is to work with the properties of objects: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names = objects.map(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>);</code> </pre> <br>  Similarly, if instead of traditional <code>for</code> loops, modern <code>forEach</code> loops based on iterators are used, the fact that the switch functions use <code>this</code> parent entity makes their use intuitively clear: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.examples.forEach(example =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.runExample(example); });</code> </pre> <br><h3>  <font color="#3AC1EF">Promises and promise chains</font> </h3><br>  Another situation where the arrow functions allow you to write cleaner and more understandable code is represented by asynchronous software constructs. <br><br>  So, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">promises</a> greatly simplify working with asynchronous code.  At the same time, even if you prefer to use the async / await <a href="https://medium.com/%40bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8">construction,</a> you cannot do without an <a href="https://medium.com/%40bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8">understanding of the promises</a> , since this construction is based on them. <br><br>  However, when using promises, you need to declare functions that are called after the completion of an asynchronous code or the completion of an asynchronous call to an API. <br><br>  This is the ideal place to use the switch functions, especially if the resulting function has a state, refers to something in the object.  For example, it might look like this: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomethingAsync().<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storeResult(result); });</code> </pre> <br><h3>  <font color="#3AC1EF"> Transformation of objects</font> </h3><br>  Another common example of using switch functions is to encapsulate object transformations. <br><br>  For example, in Vue.js, there is a generally accepted <a href="https://vuex.vuejs.org/guide/state.html">pattern for</a> including fragments of Vuex storage directly into a Vue component using <code>mapState</code> . <br><br>  This operation includes declarations of a set of "converters" that select from the initial full state exactly what is needed for a particular component. <br><br>  Such simple transformations are an ideal place for using switch functions.  For example: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">export</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">computed</span></span>: {   ...<span class="hljs-built_in"><span class="hljs-built_in">mapState</span></span>({     results: state =&gt; state.results,     users: state =&gt; state.users,   }); } }</code> </pre> <br><h2>  <font color="#3AC1EF">Situations in which you should not use the arrow function</font> </h2><br><h3>  <font color="#3AC1EF"> Object methods</font> </h3><br>  There are a number of situations in which the use of switch functions is not the best idea.  Arrow functions, if they are used thoughtlessly, not only do not help programmers, but also become a source of problems. <br><br>  The first such situation is the use of switch functions as methods of objects.  Here, the execution context and the <code>this</code> , characteristic of traditional functions, are important. <br><br>  At one time, it was popular to use a combination of class properties and switch functions to create methods with ‚Äúautomatic binding‚Äù, that is, those that can be used by event handlers but remain attached to a class.  It looked like this: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span></span>{ counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter++; } }</code> </pre> <br>  When using such a construction, even if the <code>handleClick</code> function <code>handleClick</code> called by an event handler, and not in the context of an instance of the <code>Counter</code> class, this function had access to the data of that instance. <br><br>  However, this approach has a lot of minuses to which <a href="https://medium.com/%40charpeni/arrow-functions-in-class-properties-might-not-be-as-great-as-we-think-3b3551c440b1">this material is</a> dedicated. <br><br>  Although the use of the arrow function here is certainly a convenient-looking way to bind a function, the behavior of this function in many aspects is far from intuitive, interfering with testing and creating problems in situations where, for example, they try to use the corresponding object as a prototype. <br><br>  In such cases, instead of switch functions, use normal functions, and, if necessary, bind to them an instance of an object in the constructor: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Counter <span class="hljs-comment"><span class="hljs-comment">{ counter = 0; handleClick() {   this.counter++; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{   this.handleClick = this.handleClick.bind(this); }</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">Long call chains</font> </h3><br>  Arrow functions can become a source of problems if they are planned to be used in many different combinations, in particular, in long chains of function calls. <br><br>  The main reason for such problems, as with the use of anonymous functions, is that they provide extremely uninformative results of the <a href="https://hackernoon.com/three-reasons-i-avoid-anonymous-js-functions-like-the-plague-7f985c27a006">call stack</a> trace. <br><br>  This is not so bad if, for example, there is only one level of nesting of function calls, say, if we are talking about the function used in the iterator.  However, if all the functions used are declared as pointer functions, and they call each other functions, then if an error occurs, it will not be easy to understand what is happening.  Error messages will look something like this: <br><br><pre> <code class="hljs">{anonymous}() {anonymous}() {anonymous}() {anonymous}() {anonymous}()</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçFunctions with dynamic context</font> </h3><br>  The last of the situations we are discussing in which the switch functions can be a source of trouble is to use them where you need this dynamic link. <br><br>  If pointer functions are used in such situations, then this dynamic link will not work.  This unpleasant surprise can make you think over the causes of what is happening to those who will have to work with code in which the pointer functions are used incorrectly. <br><br>  Here are some things to keep in mind when considering the use of dial functions: <br><br><ul><li>  Event handlers are called with <code>this</code> , bound to the <code>currentTarget</code> event attribute. </li><li>  If you're still using jQuery, keep in mind that most jQuery methods bind <code>this</code> to the selected DOM element. </li><li>  If you use Vue.js, then methods and computed functions usually bind <code>this</code> to a Vue component. </li></ul><br>  Of course, the switch functions can be used intentionally, in order to change the standard behavior of software mechanisms.  But, especially in the cases of jQuery and Vue, this often conflicts with the normal functioning of the system, which leads to the fact that the programmer cannot understand why some code that looks quite normal suddenly refuses to work. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Arrow functions are a great fresh JavaScript feature.  They allow, in many situations, to write more convenient code than before.  But, as is the case with other features, they have both advantages and disadvantages.  Therefore, it is necessary to use the switch functions where they can be useful, without considering them as a complete replacement for ordinary functions. <br><br>  <b>Dear readers!</b>  Have you encountered situations in which the use of switch functions leads to errors, inconveniences or unexpected behavior of programs? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/428566/">https://habr.com/ru/post/428566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428556/index.html">‚ÄúProduction environment out of your control‚Äù: Rian Lewis about testing blockchain projects</a></li>
<li><a href="../428558/index.html">How I created a ‚Äúwizard‚Äù for WordPress from my deep laziness</a></li>
<li><a href="../428560/index.html">Unscheduled Friday Announcement</a></li>
<li><a href="../428562/index.html">Droidcon London. How it was</a></li>
<li><a href="../428564/index.html">Search MapKit: Tips & Tricks</a></li>
<li><a href="../428568/index.html">React Native Web Application Development Guide</a></li>
<li><a href="../428570/index.html">Higher Order Functions in JavaScript</a></li>
<li><a href="../428572/index.html">Higher-order components in React</a></li>
<li><a href="../428574/index.html">We take corporate communication to a new level with Zextras Chat</a></li>
<li><a href="../428576/index.html">[bookmark] Node.js pdf guide and new javascript guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>