<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Conversations about functional programming in C ++ Siberia 2019</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 


 Recently, another C ++ Siberia 2019 was held in Novosibirsk. At the conference there was a cozy atmosphere and many good reports. Taking th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Conversations about functional programming in C ++ Siberia 2019</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello! </p><br><p>  Recently, another C ++ Siberia 2019 was held in Novosibirsk. At the conference there was a cozy atmosphere and many good reports.  Taking this opportunity, I spoke with two of our speakers, whom you will soon be able to see in Moscow. </p><br><p><img width="100" align="left" src="https://habrastorage.org/webt/yk/tc/m6/yktcm6h7qrfisa5rcudmirsl6ys.jpeg">  <strong>Ivan Chukic</strong> is one of the KDE developers, a teacher and researcher in the design of programming languages ‚Äã‚Äãat the University of Belgrade. <br clear="all"></p><br><p><img width="100" align="left" src="https://habrastorage.org/webt/21/vg/0y/21vg0ybouvc_hip9zys9-dkznew.jpeg">  <strong>Alexander Granin</strong> ( <a href="https://habr.com/en/users/graninas/" class="user_link">graninas</a> ) is a well-known speaker and developer specializing in FP, the organizer of the Novosibirsk FP community LambdaNsk. <br clear="all"></p><br><p><img src="https://habrastorage.org/webt/fj/9f/nr/fj9fnrzzgxrmy9ur1vpzyjuyyau.png"></p><a name="habracut"></a><br><p>  <strong>Sergey:</strong> Hello everyone, let's get acquainted.  Alexander is the keynout speaker on this C ++ Siberia, and Ivan was the keynout speaker last year.  Let's talk about functional programming.  As far as I remember, OP in C ++ was the theme of your previous keyout, Ivan ... </p><br><p>  <strong>Ivan:</strong> Not entirely, but partially - yes. </p><br><p>  <strong>Sergey:</strong> And Alexander has a topic for a report on functional programming.  Therefore, I have prepared a couple of questions, and the first is how do you define the FI? </p><br><p>  <strong>Alexander:</strong> I don‚Äôt think that there is any one ‚Äúcorrect‚Äù definition of the OP, but speaking personally about me, then the OP is something with a functional composition and first-class functions. </p><br><p>  <strong>Ivan:</strong> I agree, but I would add more functions of a higher order - those that can take other functions as arguments and return as a result. </p><br><p>  <strong>Sergey</strong> : Reference to a function in C - is it considered? </p><br><p>  <strong>Ivan:</strong> No, C is not a functional programming language :-) </p><br><p>  <strong>Sergey:</strong> Tell me why? </p><br><p>  <strong>Ivan:</strong> Because you cannot create a new function from a combination of function pointers, you can only point to already existing ones.  Of course, if some assembly hacks didn't go into action. </p><br><p>  <strong>Sergey:</strong> Great, now I have an official answer!  People constantly ask this question why C is not a functional programming language, because there are full-fledged functions.  But why C ++ is a functional language, it is already clearer ... </p><br><p>  <strong>Alexander:</strong> I would not say that C ++ is downright functional programming language, it supports a bunch of paradigms merged into one language. </p><br><p>  <strong>Sergey: It</strong> meant - C ++ supports the functional paradigm, of course.  By the way, why?  Does it support because you can manipulate higher order functions? </p><br><p>  <strong>Ivan:</strong> Well, it seems to me that it has always been like this, because even in C ++ 98, a higher order function already exists, even in STL.  This is not the most convenient functional language - there are languages ‚Äã‚Äãthat implement FP and better.  But for my needs, it has always been quite functional. </p><br><p>  <strong>Sergey:</strong> But from this place in more detail.  What are your needs like that? </p><br><p> <strong>Ivan:</strong> It is difficult.  Come on, tell the story.  When I was at university, we went through a LISP, and everyone hated this LISP because it is ugly.  But what I understood from it is how to simulate C constructs right in the LISP code.  And then one day a new version of Java was released, which was released for things like the built-in <code>foreach</code> , and I thought: wow, you need a new compiler, a new version of the language and everything that is new just to realize something I did at the university on LISP which generally doesn't even support loops.  At that moment, I realized that the OP is a pretty nice thing to build high-level abstractions, and that's why I use functional C ++ in 2019. </p><br><p>  <strong>Sergey:</strong> In fact, you use the OP for high-level design. </p><br><p>  <strong>Ivan:</strong> Exactly. </p><br><p>  <strong>Alexander:</strong> Right now I am not working on C ++, but I would not refuse to use it for data manipulation, this is much more pleasant than in the imperative approach.  Even if we compare it with OOP, in contrast, only transformations are acceptable here, and this is convenient. </p><br><p>  <strong>Sergey:</strong> Well, you can use the OP not only with C ++, right?  Ok, then the next question is: which part of C ++ do you use?  If only design issues are important, you can choose only the part that fits well with the OP, the one that you actually use. </p><br><p>  <strong>Ivan:</strong> These will definitely be lambda functions.  And even more important are the templates, because they allow you to pass other functions as arguments and everything else, and lambdas are just a nice syntax for writing functional objects. </p><br><p>  <strong>Sergey:</strong> Yes, we already understood that you really like lambdas :-) </p><br><p>  <strong>Ivan:</strong> Not that they like them <em>very much</em> , but this is clearly the best that we had in C ++ 98, it is more convenient to work with them. </p><br><p>  <strong>Alexander:</strong> Yes, I also like lambda - this feature is so universal that you could only write on them alone.  This is something like a universal combinator, allowing to construct any logic - maybe not as beautiful as in other languages, but no less useful. </p><br><p>  <strong>Sergey:</strong> Ivan, you mentioned here that there are standards up to C ++ 11, for example, C ++ 03, which is very common, and there are already functional features.  And there are more functional features in the new standards ... Is it possible to say that C ++ is moving towards the OP?  Will this move continue or stop?  And then what will lead? </p><br><p>  <strong>Ivan:</strong> There is a good talk by <a href="https://en.wikipedia.org/wiki/Simon_Peyton_Jones">Simon Peython Jones</a> about programming languages ‚Äã‚Äãin general, and he drew a graph there showing a variety of safe languages ‚Äã‚Äãand languages ‚Äã‚Äãused.  Haskell began its history as a completely safe language, with which nothing can be done - because there is no I / O, and nothing at all.  SPJ attributed the C language and assembly languages ‚Äã‚Äãto those that are very useful, but at the same time extremely unsafe.  Since then, Haskell has begun to move toward greater security.  On the other hand, those features that appear in C ++ - they appear mainly to increase security, so that you can write correct programs more simply.  It so happens that most of these things come from functional programming languages. </p><br><p>  <strong>Sergey:</strong> Why do you think so?  Because of the very nature of OP? </p><br><p>  <strong>Ivan:</strong> Yes, maybe by nature ... but I don‚Äôt know for sure. </p><br><p>  <strong>Alexander:</strong> I think that the OP is so fascinating to all just because we are tired of fighting patterns, with rearranging baits, with some kind of low-level mud - we want something decent to apply our own intelligence. </p><br><p>  <strong>Sergey:</strong> That is, for you this is something like an intellectual exercise? </p><br><p>  <strong>Alexander:</strong> Yes, sort of. </p><br><p>  <strong>Sergey:</strong> I understand.  Where as it is more interesting to the developer to think about high-level abstractions, than to implement stupid standard features - it is unpleasant.  Then this question <strong>C:</strong> do you have any experience of practical application of the OP in C ++?  Any production projects? </p><br><p>  <strong>Ivan:</strong> Of course.  One of the largest projects in the world, KDE, has several parts inside it that use the functional style intensively.  Of course, this is a mixture of, as it were, a more traditional object-oriented C ++ with a set of concepts from the functional area.  I never intended to be a purist or something.  I always try to combine the best of different worlds. </p><br><p>  <strong>Sergey:</strong> What about Haskell or Scala?  They are widely used in production.  How do you like the idea that Haskell is now considered the benchmark of a functional language?  This is especially noted by purists. </p><br><p>  <strong>Ivan:</strong> Yes, I agree that Haskell today is a synonym for OP.  In fact, any feature from Haskell is perceived by people as something related to FP.  This is not necessarily true, but I think that Haskell has truly become the most popular academic language of functional programming.  I know that several banks in London and Northern Europe widely use Haskell, but still Scala is much more popular right now. </p><br><p>  <strong>Alexander:</strong> I agree that Scala is more popular, but Haskell looks more functional language, most of its features are implemented more correctly.  That is, when you have a currying, which is easy to do, when there is an easy way to make a song, programming becomes easy and simple, it's like walking in the woods and enjoying the views. </p><br><p>  <strong>Ivan:</strong> But sometimes there are bears in the forest.  If you are in Russia. </p><br><p>  <strong>Sergey:</strong> Do you think C ++ is mainly inspired by Haskell too?  Is it worth doing? </p><br><p>  <strong>Ivan:</strong> Are you hinting at any specific committee members?  :-) Someone hinted that concepts came about as a result of thinking about taykklassov, but Bj√∂rn stopped these rumors and even wrote some kind of document about how concepts differ from taykklassov.  From my point of view, they differ in all, but serve one purpose.  Just different approaches. </p><br><p>  <strong>Sergey:</strong> Are the future / promise somehow connected with FP?  It seems Bartosh claimed that these are poorly implemented monads. </p><br><p>  <strong>Ivan:</strong> Well, yes, they are implemented as monads, transmitting continuations, but I'm not sure that the most important thing in this matter. </p><br><p>  <strong>Sergey:</strong> Do we need improved support for monads in C ++? </p><br><p>  <strong>Alexander:</strong> Of course, this is the most important feature that can turn C ++ into a really good language. </p><br><p>  <strong>Ivan:</strong> By the way, since we are at the conference, let me ask you a question too, Sergey.  You said that conferences are an exciting job.  Share what is so interesting in it, and would you advise me or Comrade Granin to independently organize conferences in other parts of the world? </p><br><p>  <strong>Sergey:</strong> Organizing conferences is really cool, you meet a lot of interesting people, but this is only the tip of the iceberg.  And down there - a lot of work, all this preparation of the hall, food for the participants, not to mention the search for speakers.  C ++ Russia is still not the most famous conference in the world, and the speakers have to explain that we are a new conference, that interesting things are happening here.  It is necessary to convince the speaker, especially well-known star speakers, who are not particularly interested to fly to Russia just to see a new country.  Organizing work is hard, especially if you also work in your main job.  But everything pays off by communicating with these wonderful people.  Nevertheless, I have now reached the point that I will rather attend someone else's conference than I will do my own. </p><br><p>  <strong>Ivan:</strong> That is, you suggest to attend conferences, and not to do them. </p><br><p>  <strong>Sergey:</strong> Yes, if you can avoid organizing a conference, you should take a chance.  When organizing, a huge burden will fall on you, it's like another 8-hour job.  Personally, I begin to work an additional 8 hours a day about 3 months before the conference.  It's fun to do ... but I hope my family is having fun too.  Thanks for asking! </p><br><p>  And now, back to the topic.  We talked about functional programming, and you almost convinced me, in the sense that your reports convinced me.  There is a suspicion that the functional approach in C ++ will help me with multithreading when I need to synchronize different things.  It really helps? </p><br><p>  <strong>Ivan:</strong> Of course. </p><br><p>  <strong>Alexander:</strong> Despite the fact that I have limited experience with functional multithreading specifically in C ++, I have to say that when you have a world of pure functions, it‚Äôs much easier to talk about them in a multi-threaded environment.  If you write logic, for example, competitive, you can not think about the synchronization of all these pieces, about mutexes, about critical sections, about anything.  All this simply disappears, because you think of the code as a normal sequential code, and all the multithreading and synchronization are hidden somewhere inside.  There are a lot of approaches to multithreaded programming, and to functional.  I'm not sure that this happens in absolutely all approaches, but for example, software transactional memory is an excellent approach to reduce complexity in competitive applications.  Unfortunately, this is a question of choosing the right compromises. </p><br><p>  <strong>Ivan:</strong> When the compiler does all the work for you, you have to pay for it with efficiency. </p><br><p>  <strong>Alexander:</strong> Well, there are different problems.  First of all, you need to understand all these things like STM, and continue to transfer this secret knowledge to your colleagues.  And then there are errors in the specific implementation and places that can work much better when using manual thread management.  But you can write faster and easier than with such manual control.  It will be executed more slowly, but the code will be with fewer errors.  By the way, Ivan, what do you think about how well this issue is well covered at conferences? </p><br><p>  <strong>Ivan:</strong> This topic is flourishing.  In recent years, all the big conferences - CPPConf, C ++ Russia, Meeting C ++, etc.  - Received reports either directly on the FP, or on algebraic data structures, or on something like that.  Sometimes the speakers do not even suspect that in their report they talk about some concept from the OP.  In C ++, things come from various places ... People usually do not write only in one language.  Imagine Ivan Ivanov, working on a project written in Erlang and C ++.  Then Tatyana Petrovna comes, and she is already working on Haskell with pure functions and all that, they take their favorite mechanisms and port them into C ++, and as a result a huge number of people from different communities bring more and more things to C ++.  All this is happening before our eyes.  At a minimum, this happens in the C ++ developer community, but I‚Äôm not so sure about C ++ companies.  However, many people from the C ++ community are currently working on functional concepts. </p><br><p>  <strong>Alexander:</strong> I correctly understood that a lot of top C ++ developers are learning Haskell only to understand what is happening with C ++? </p><br><p>  <strong>Ivan:</strong> Not sure if they teach Haskell for this very reason.  I think C ++ developers are just very selfish.  They learned C ++ so well just because it is complicated.  And if you want to learn something really new, your path is clearly not in any Java, which is specifically designed to be simple.  You need to look in the area of ‚Äã‚Äãunusual and strange languages, the strangest, and Haskell will automatically be among the most popular answers.  The person sees it, understands: oh, this is something more complicated than C ++, you need to learn.  When I studied Haskell, it was the same with me, and I have friends who went through exactly the same chain of reasoning. </p><br><p>  <strong>Alexander:</strong> When Eric Nibler was here in Siberia and showed his library for rengers, he was often asked what was the source of inspiration.  He replied that this is Haskell.  Maybe all the features in a row from it should not be taken, but some are clearly needed in the community. </p><br><p>  <strong>Ivan:</strong> This is something like evolution.  Genetic material.  And Haskell can also be improved by taking something from C ++.  Most languages ‚Äã‚Äãare now undergoing this evolution.  Java tried to adapt LINQ from C # for itself, and LINQ creators from C # took inspiration from Haskell, etc.  It turns out such a beautiful tangled network of interaction between different languages. </p><br><p>  <strong>Alexander:</strong> Still, is C ++ still a low-level language? </p><br><p>  <strong>Ivan:</strong> Most people think so. </p><br><p>  <strong>Sergey:</strong> What kind of "low-level" are you talking about now? </p><br><p>  <strong>Ivan:</strong> Compiled into low-level code.  But it works with high-level abstractions.  The whole point and purpose is that such abstractions do not lead to unnecessary overhead in terms of performance.  C ++ should generate such code from its abstractions that is not worse than written by hand.  At least theoretically. </p><br><p>  <strong>Alexander:</strong> What will happen if someone breaks this rule?  For example, rengy. </p><br><p>  <strong>Ivan:</strong> Compilation performance suffers - yes.  All new features, especially - features supplied in libraries, increase the compile time.  But there is no reason why the hedge should be slow.  If rengy slows down, then the only thing you can blame here is compilers, not optimized for this particular case. </p><br><p>  <strong>Sergey:</strong> It's not the rengies themselves that are slowing down, but the debts in debugging mode - that's the essence of the whole discussion.  In release mode, they work fine. </p><br><p>  <strong>Ivan:</strong> This is normal. </p><br><p>  <strong>Sergey:</strong> Not everyone agrees :-) </p><br><p>  <strong>Ivan:</strong> Yes, I know in practice.  In one company, in its most frequently used library ... I will not say what kind of company and library it is ... there are algorithms that are asymptotically substantially slower in debug mode.  And who will now complain that renegues are doing the same thing? </p><br><p>  <strong>Sergey:</strong> In the article we are discussing now, the essence was not in the domain itself, they were only an example for the author, who was enraged that this situation was becoming a trend, poor performance in debug mode.  In his domain, game engines, this is simply unacceptable. </p><br><p>  <strong>Alexander:</strong> These people do not like STL at all, because it works slower than they need.  Renji simply expands the library in the same direction, and for them it looks like another useless feature that they cannot use. </p><br><p>  <strong>Sergey:</strong> Haters gonna hate. </p><br><p>  <strong>Ivan:</strong> Exactly.  For example, everyone uses sorting.  Just imagine that there is no more sorting in the standard library.  How would you implement it? </p><br><p>  <strong>Sergey:</strong> I usually ask this question at an interview :-) This is a very frequent question. </p><br><p>  <strong>Ivan:</strong> Yes, a frequent question is how to implement sorting.  And then you tell some basic version of quick sort, which is actually not used anywhere in the world at all, because it can be very slow in certain cases.  The standard library does not allow using it, because it requires a guaranteed N log N, and quick sorting cannot do this.  For the most part, it can, but the standard in this place is very hard, and does not speak of accumulated N log N, it should be pure N log N, and how will you implement such an algorithm?  It is necessary to conduct research, find many different optimizations for quick sorting, and merge them into one algorithm consisting of at least three different algorithms, as is done in libstdc ++.  This is the meaning of standard libraries - you do not need to know all these things in order to program.  No need to figure out how to realize everything in the most efficient way, someone else has already taken care of it for you.  Therefore, I don‚Äôt like this approach when people declare: ‚ÄúSTL is very complicated, let's not use it and write everything from scratch manually.‚Äù </p><br><p>  <strong>Sergey:</strong> We are coming to the end of the interview, so the last question is: how are you in Russia? </p><br><p>  <strong>Alexander:</strong> Cold. </p><br><p>  <strong>Sergey:</strong> Even for you?  You're local! </p><br><p>  <strong>Ivan:</strong> And for me here is warmer than expected. </p><br><p>  <strong>Sergey:</strong> Now -16, and we told you that it will be -40. </p><br><p>  <strong>Ivan:</strong> Yes, you promised!  I specially prepared for minus forty.  And then I look at the thermometer, and everything is warmer and warmer there. </p><br><p>  <strong>Sergey:</strong> Well, now we will meet only in C ++ Russia 2019, it will be in Moscow, and there will be a positive temperature.  Thank you for the interview and see you soon! </p><br><blockquote>  Minute advertising.  On April 19-20, a C ++ Russia conference will be held, at which Ivan will give a talk on <a href="https://cppconf.ru/talks/11auqe0dbeawgemasoqws2/%3Futm_source%3Dhabr%26utm_medium%3D444212">‚ÄúMove-only C ++ design‚Äù</a> , and Alexander will talk about monadic parsers.  In addition, Ivan will conduct one of <a href="https://cppconf.ru/trainings/%3Futm_source%3Dhabr%26utm_medium%3D444212">three large training sessions</a> - <a href="https://cppconf.ru/trainings/applied-functional-programming-in-c/%3Futm_source%3Dhabr%26utm_medium%3D444212">‚ÄúApplied functional programming in C ++‚Äù</a> .  A month remains before the conference and the program continues to be refined.  On the official website you can see what reports <a href="https://cppconf.ru/%3Futm_source%3Dhabr%26utm_medium%3D444212">have already entered the program</a> and purchase <a href="https://cppconf.ru/registration/%3Futm_source%3Dhabr%26utm_medium%3D444212">tickets</a> .  Please note that the tickets are of different types, and choosing the right one can save a lot. </blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/444212/">https://habr.com/ru/post/444212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444198/index.html">Dropbox limits syncing: now only 3 devices</a></li>
<li><a href="../444200/index.html">Problem Solving Session</a></li>
<li><a href="../444204/index.html">Introduction to Testing in Python. Part 3</a></li>
<li><a href="../444206/index.html">March 27, Moscow - JavaScript MeetUP</a></li>
<li><a href="../444210/index.html">Internet Archive plans to keep public posts of closing Google+</a></li>
<li><a href="../444234/index.html">DeepMind and Google: the battle for control of a strong AI</a></li>
<li><a href="../444236/index.html">Telegraph - e-mail without internet</a></li>
<li><a href="../444238/index.html">Deny one click, or as a designer get a dream job</a></li>
<li><a href="../444242/index.html">Checking FreeRDP using PVS-Studio analyzer</a></li>
<li><a href="../444244/index.html">Move through space and time</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>