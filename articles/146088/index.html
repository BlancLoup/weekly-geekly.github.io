<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Minimax on the example of the game in the hare and wolves</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is intended to clarify the essence of the fundamental methods of building and optimizing "artificial intelligence" for computer games (mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Minimax on the example of the game in the hare and wolves</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/3a3/6e6/b1b/3a36e6b1b12214f156e7c645a932633a.jpg" align="left" alt="image">  This article is intended to clarify the essence of the fundamental methods of building and optimizing "artificial intelligence" for computer games (mostly <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BD%25D1%2582%25D0%25B0%25D0%25B3%25D0%25BE%25D0%25BD%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0">antagonistic</a> ).  On the example of the game of hare and wolves, the Minimax algorithm and the Alpha Beta Clipping algorithm will be considered.  In addition to the text description, the article contains illustrations, tables, sources, and a ready-made cross-platform game with open source, in which you can compete with an intelligent agent. <a name="habracut"></a><br clear="all"><br clear="all"><h1>  Game "Hare and wolves" </h1><br clear="all"><img src="https://habrastorage.org/getpro/habr/post_images/9b4/816/362/9b481636254845ba6cc34c14201576ad.png" alt="image"><br clear="all"><br clear="all">  On the chessboard there are 4 wolves on top (on the black squares), and 1 hare on the bottom (on one of the black ones).  The hare goes first.  You can walk only one space diagonally, besides, wolves can only walk down, and the hare in any direction.  The hare wins when it has reached one of the upper cages, and the wolves, when they have surrounded or pressed the hare (when the hare has nowhere to go). <br clear="all"><br clear="all">  Before continuing to read, I recommend to <a href="">play</a> , it will be easier to understand. <br clear="all"><br clear="all"><h1>  Heuristic </h1>  In practical engineering understanding, the minimax method relies on <a href="http://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25B2%25D1%2580%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC">heuristics</a> , which we will consider before proceeding to the essence of the algorithms. <br clear="all"><br clear="all">  In the context of a minimax, heuristics are needed to estimate the probability of a player‚Äôs victory, for a particular state.  The task is to build a heuristic <b>evaluation function</b> , which is sufficiently quickly and accurately, in the selected metric, can indicate an estimate of the probability of a particular player's victory for a particular location of the figures, not relying on how the players came to this state.  In my example, the evaluation function returns values ‚Äã‚Äãfrom 0 to 254, where 0 is the victory of the hare, 254 is the victory of the wolf, intermediate values ‚Äã‚Äãare the interpolation of the two estimates above.  Estimation of probability is not a probability, and does not have to be limited, linear, continuous. <br clear="all"><br clear="all">  <b>An example of the evaluation function 1</b> .  The higher the hare, the greater his chances of winning.  Such heuristics are effective in terms of speed (O (1)), but they are completely algorithmically unsuitable.  The ‚Äúheight‚Äù of the hare correlates with the probability of victory, but it distorts the main goal of the hare ‚Äî to win.  This evaluation function tells the hare to move up, but with a small depth of calculation it will cause the hare to move up, regardless of obstacles, and fall into traps. <br clear="all"><br clear="all">  <b>An example of the evaluation function 2</b> .  The hare is more likely to win, the less he needs to make moves to win, with frozen wolves.  This is a more cumbersome algorithm with complexity O (n), where n is the number of cells.  Calculating the number of moves is reduced to the search in width: <br clear="all"><img src="https://habrastorage.org/getpro/habr/post_images/029/df1/918/029df1918b2e9cd7921b7b1595a19d06.png" alt="image"><br clear="all"><br clear="all">  <i>Attention.</i>  <i>The sources in the article are modified in such a way that the reader can understand their essence outside the context of the main application.</i>  <i>Look for reliable sources at the end of the article.</i> <br clear="all"><br clear="all">  The code that performs the search in width, or rather filling the map with values ‚Äã‚Äãequal to the ‚Äúdistance‚Äù from the hare: <br clear="all"><br clear="all"><pre><code class="hljs markdown">this-&gt;queue.enqueue(this-&gt;rabbitPosition); while (!this-&gt;queue.empty()) { QPoint pos = this-&gt;queue.dequeue(); for (int i = 0; i <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">++) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">canMove</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">pos</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">this-</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>possibleMoves[<span class="hljs-string"><span class="hljs-string">i</span></span>])) { QPoint n = pos + this-&gt;possibleMoves[<span class="hljs-string"><span class="hljs-string">i</span></span>]; this-&gt;map[<span class="hljs-string"><span class="hljs-string">ny()</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">nx()</span></span>] = this-&gt;map[<span class="hljs-string"><span class="hljs-string">pos.y()</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">pos.x()</span></span>] + 1; this-&gt;queue.enqueue(n); } }</code> </pre> <br clear="all">  The result of the evaluation function should be a value equal to the ‚Äúdistance‚Äù to the nearest upper cell, or 254, if it is impossible to reach them.  Despite the shortcomings that I will describe below, it is this heuristics used in the game. <br clear="all"><br clear="all">  <i>For those who will look at the source and understand - attention!</i>  <i>The application architecture is designed so that the evaluation function can be redone without affecting other parts of the code.</i>  <i>But, you should use the previously selected metric, otherwise the algorithms will not understand the indications of the evaluation function.</i> <br clear="all"><br clear="all"><h1>  Minimax </h1>  We introduce some concepts and notation: <br clear="all"><br clear="all"><ul><li>  The state, it is the node <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BD%25D1%258F%25D1%2582%25D0%25B8%25D1%258F_%25D1%2580%25D0%25B5%25D1%2588%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9">of the decision tree</a> - the location of the pieces on the board </li><li>  Terminal state is a state from which there are no more moves (someone won / draw). <br clear="all"></li><li>  <i>Vi</i> is the <i>i</i> state. </li><li>  <i>Vik</i> is the <i>k</i> -th state, which can be reached in one move from the Vi state.  In the context of a decision tree, this is a child node of Vi. </li><li>  <i>f (Vi)</i> is a calculated estimate of the probability of victory for the state Vi. </li><li>  <i>g (Vi)</i> is the heuristic estimate of the probability of victory for the state Vi. </li></ul><br clear="all">  <i>f (Vi)</i> differs from <i>g (Vi)</i> in that <i>g (Vi)</i> uses information only about <i>Vi</i> , and <i>f (Vi)</i> also uses <i>Vik</i> and other states, recursively. <br clear="all"><br clear="all">  The method is designed to solve the problem of choosing a move from the <i>Vi</i> state  It is logical to choose a move for which the probability estimate will be the most profitable for the player who walks.  In our metric, for wolves - the maximum score for the hares minimum.  And the score is considered as follows: <br clear="all"><br clear="all"><ul><li>  <i>f (Vi) = g (Vi)</i> , if <i>Vi</i> is a terminal state, or the depth limit of the calculations is reached. </li><li>  <i>f (Vi) = max (f (Vi1), f (Vi2) ... f (Vik))</i> , if <i>Vi</i> is the state from which the player goes with the search for the maximum score. </li><li>  <i>f (Vi) = min (f (Vi1), f (Vi2) ... f (Vik))</i> , if <i>Vi</i> is the state from which the player goes with the search for the minimum score. </li></ul><br clear="all">  The method relies on common sense.  We go in such a way as to maximize our own victory P‚Äôs estimate, but in order to calculate at least something, we need to know how the enemy will walk, and the enemy will walk so as to maximize his victory score (minimize the P score).  In other words, we know how the enemy will walk, and thus we can build estimates of probabilities.  It's time to point out that the algorithm is optimal if the enemy has the same evaluation function, and it acts optimally.  In this case, intelligence depends on the depth of the calculation, and on the quality of the evaluation function. <br clear="all"><br clear="all">  It's time to give an example: <br clear="all"><img src="https://habrastorage.org/getpro/habr/post_images/cbf/dae/ee0/cbfdaeee0b98be936ef7f88523f2c1e1.png" alt="image"><br clear="all"><br clear="all">  In this example, the player plays the hare, and the computer wolves.  After the hare was like, the computer starts the minimax algorithm, in this example with a depth of 1. What does the algorithm do?  <s>Who knows?</s>  The algorithm goes through all possible moves for a wolf, and for them it gets an estimate of the probability of victory.  This estimate, as we said earlier, consists of the same launch of the minimax algorithm, but for other states, and with the move of another player, and with minimization, instead of maximization.  This will already be the second level, the last one for the specified depth 1, and the minimax algorithm does not start any further, but returns the heuristic evaluation function. <br clear="all"><br clear="all">  This example will be easier to understand if viewed from below.  At the second level, we have states for which we get a heuristic estimate (it is written down by numbers).  For the second level, the first one gets its estimates, respectively, by choosing the minimum values ‚Äã‚Äãfrom those that are checked at the next level.  Well, the zero level, selects the maximum grade, from those that are provided to him by the first level. <br clear="all"><br clear="all">  Now that we have all the grades, what to do?  <s>Rejoice.</s>  Need to choose a move.  Everything is obvious here; for a wolf, the move that shows the highest estimate chooses, for the hare, the move that shows the smallest.  But after all, the estimates for different moves can be equal, and then ideally you need to choose randomly, but then the nuances begin.  I‚Äôll say right away that for me the first move from the list with the maximum rating is taken for the wolf, and the last of the list with the minimum rating for the wolf.  And this is sad, since a rather serious optimization relies on the fact that the first move will always be selected from the desired list.  But for a hare it does not fit.  The fact is that the wolf very often (as far as possible) moves so that the estimate is equal to infinity (254), which makes any move of the hare ‚Äúmeaningless‚Äù, and if he chooses any move, he will walk down or whatever , and we need to make him go up, breaking through the front of the wolves.  It would be correct to make the heuristic function take into account how high the hare is, but with a lower coefficient than the main heuristics, but I did not do it, but as I described earlier.  Therefore, the last move from the list is selected, which indicates the hare to go up. <br clear="all"><br clear="all">  An example implementation of the algorithm: <br clear="all"><pre> <code class="hljs perl"> //    f(Vi) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Game::runMinMax(MonsterType monster, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> recursiveLevel) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> test = NOT_INITIALIZED; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ( )     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recursiveLevel &gt;= this-&gt;AILevel * <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getHeuristicEvaluation(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  . <span class="hljs-number"><span class="hljs-number">0</span></span>-<span class="hljs-number"><span class="hljs-number">7</span></span> -   , <span class="hljs-number"><span class="hljs-number">8</span></span>-<span class="hljs-number"><span class="hljs-number">11</span></span> -    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bestMove = NOT_INITIALIZED; bool isWolf = (monster == MT_WOLF); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MinMax = isWolf ? MIN_VALUE : MAX_VALUE; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (isWolf ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">8</span></span>); i &lt; (isWolf ? <span class="hljs-number"><span class="hljs-number">8</span></span> : <span class="hljs-number"><span class="hljs-number">12</span></span>); i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curMonster = isWolf ? i / <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; QPoint curMonsterPos = curMonster == <span class="hljs-number"><span class="hljs-number">0</span></span> ? rabbit : wolfs[curMonster - <span class="hljs-number"><span class="hljs-number">1</span></span>]; QPoint curMove = possibleMoves[isWolf ? i % <span class="hljs-number"><span class="hljs-number">2</span></span> : i % <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (canMove(curMonsterPos + curMove)) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>...,     temporaryMonsterMovement(curMonster, curMove); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>,   ,    test = runMinMax(isWolf ? MT_RABBIT : MT_WOLF, recursiveLevel + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,     - ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((test &gt; MinMax &amp;&amp; monster == MT_WOLF) || (test &lt;= MinMax &amp;&amp; monster == MT_RABBIT)) { MinMax = test; bestMove = i; } //...     temporaryMonsterMovement(curMonster, -curMove); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bestMove == NOT_INITIALIZED) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getHeuristicEvaluation(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  , ,      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recursiveLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bestMove != NOT_INITIALIZED) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (monster == MT_WOLF) wolfs[bestMove / <span class="hljs-number"><span class="hljs-number">2</span></span>] += possibleMoves[bestMove % <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> rabbit += possibleMoves[bestMove % <span class="hljs-number"><span class="hljs-number">4</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MinMax; }</code> </pre><br clear="all">  <i>Attention!</i>  <i>Here the variable bestMove encapsulates a lot of sense (I‚Äôll clarify it when prompted), I urge you never to invest so much sense in 4 bits, if you are not sure that you are doing everything right.</i> <br clear="all"><br clear="all">  Being literate and educated people, you have already guessed that where there are decision trees, there is also a treasure for optimizations.  This example is no exception. <br clear="all"><br clear="all"><h1>  Alpha beta clipping </h1>  The alpha-beta pruning is based on the idea that the analysis of some moves can be stopped early, ignoring the result of their testimony.  Alpha-beta pruning is often described as a separate algorithm, but I find it invalid and will describe it as an optimizing modification.  Alpha-beta belongs to the class of branch and bound methods. <br clear="all"><br clear="all">  Roughly speaking, optimization introduces two additional variables, <i>alpha</i> and <i>beta</i> , where <i>alpha</i> is the current maximum value, less than which the maximization player (wolves) will never choose, and <i>beta</i> - the current minimum value, more than which the minimization player (hare) will never choose.  Initially, they are set to -‚àû, + ‚àû, respectively, and as the estimates of <i>f (Vi) are</i> obtained, they are modified: <br clear="all"><br clear="all"><ul><li>  <i>alpha = max (alpha, f (Vi));</i>  for the level of maximization. </li><li>  <i>beta = min (beta, f (Vi));</i>  for minimization level. </li></ul><br clear="all">  As soon as the condition <i><i>alpha&gt; beta</i></i> becomes true, which means a conflict of expectations, we interrupt the analysis of Vik and return the last estimate of this level. <br clear="all"><br clear="all">  In our example, in the second figure, with the help of alpha-beta clipping, the 3 lower rows are completely truncated, but without the leftmost column.  I believe that this is not a good example for an explanation, and therefore I will take an example from Wikipedia, which is a little more successful. <br clear="all"><img src="http://habrastorage.org/storage3/1d7/5cc/0f2/1d75cc0f2fe37d03a0fb586744449d68.png" alt="image"><br clear="all"><br clear="all">  Legend in the example: <br clear="all"><br clear="all"><ul><li>  Vi are the nodes of the decision search tree; i in no way correlates with the tree traversal order. </li><li>  Vi [alpha, beta] - nodes with the indicated current values ‚Äã‚Äãof alpha, beta. </li><li>  Ci is the i-th alpha-beta clipping. </li><li>  MIN, MAX - levels of maximization and minimization, respectively.  Be careful, the states at the maximum level will choose their maxima from the states of the next level, where MIN is indicated, and vice versa.  That is, the maximum is chosen from those on which MIN is written, and the minimum of those on which MAX is written, do not confuse. </li></ul><br clear="all">  Consider clipping 1. After the variant with node V3 has been fully processed for node V1, and its estimate is f (V3) = 6, the algorithm refines the value of alpha for this node (V1) and passes its value to the next node - V4 .  Now, for all child nodes of V4, the minimum alpha = 6. After the node V4 has processed the variant with node V5, and obtained the estimate f (V5) = 5, the algorithm refines the value beta for the node V4.  After the update, for the V4 node we got a situation in which alpha&gt; beta, and therefore no other variants of the V4 node need be considered.  And it does not matter to us what grade the cut-off node will have: <br clear="all"><br clear="all"><ul><li>  If the value of the clipped node is less than or equal to 5 (beta), then an estimate that is no more than 5 will be selected in node V4, and accordingly the option with node V4 will never be selected by node V1, because the estimate of node V3 is better. </li><li>  If the value of the cut-off node is greater than or equal to 6 (beta + 1), then the node will not be considered all the more, since the V4 node will choose the variant with the V5 node, since its estimate is lower (better). </li></ul><br clear="all">  Cut-off 2 is absolutely identical in structure, and I would recommend that you try to disassemble it yourself.  Cut-off 3 is much more interesting, the <b>attention</b> , the example on Wikipedia is clearly somewhat wrong.  He allows himself to cut off if (alpha&gt; = beta), although alpha-beta should be an optimization, and not influence the choice of the path.  The fact is that everywhere they write that clipping should work when alpha&gt; = beta, although in the general case, only when alpha&gt; beta. <br clear="all"><br clear="all">  Suppose for some decision tree, all children show the same score.  Then you could choose any of them, randomly, and that would be correct.  But you will not be able to do so, using the conditions alpha&gt; = beta, because after the first assessment all the others can be cut off.  But it doesn't matter, for example, your algorithm will not implement stochastic behavior, it is not so important, but if in your algorithm the choice of the best of the values ‚Äã‚Äãwith the same rating is important, then such a cut-off condition will result in the algorithm simply failing and going not optimal.  Be carefull! <br clear="all"><br clear="all">  Alpha-beta pruning is a very simple algorithm to implement, and its essence is that you need to add 2 alpha and beta variables to the minimax function in the interface of the minimax procedure, and a small piece of code into its body immediately after receiving the estimate. <br clear="all"><br clear="all">  An example of a modification of the minimax algorithm with alpha-beta clipping (for greater clarity, the modifications made are commented out, but remember that this is an important code, not comments): <br clear="all"><br clear="all"><pre> <code class="hljs kotlin">int Game::runMinMax(MonsterType monster, int recursiveLevel<span class="hljs-comment"><span class="hljs-comment">/*, int alpha, int beta*/</span></span>) { int test = NOT_INITIALIZED; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recursiveLevel &gt;= <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;AILevel * <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getHeuristicEvaluation(); int bestMove = NOT_INITIALIZED; bool isWolf = (monster == MT_WOLF); int MinMax = isWolf ? MIN_VALUE : MAX_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = (isWolf ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">8</span></span>); i &lt; (isWolf ? <span class="hljs-number"><span class="hljs-number">8</span></span> : <span class="hljs-number"><span class="hljs-number">12</span></span>); i++) { int curMonster = isWolf ? i / <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; QPoint curMonsterPos = curMonster == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;rabbit : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;wolfs[curMonster - <span class="hljs-number"><span class="hljs-number">1</span></span>]; QPoint curMove = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;possibleMoves[isWolf ? i % <span class="hljs-number"><span class="hljs-number">2</span></span> : i % <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (canMove(curMonsterPos + curMove)) { temporaryMonsterMovement(curMonster, curMove); test = runMinMax(isWolf ? MT_RABBIT : MT_WOLF, recursiveLevel + <span class="hljs-number"><span class="hljs-number">1</span></span>, alpha, beta); temporaryMonsterMovement(curMonster, -curMove); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((test &gt; MinMax &amp;&amp; monster == MT_WOLF) || (test &lt;= MinMax &amp;&amp; monster == MT_RABBIT)) { MinMax = test; bestMove = i; } <span class="hljs-comment"><span class="hljs-comment">/* if (isWolf) alpha = qMax(alpha, test); else beta = qMin(beta, test); if (beta &lt; alpha) break; */</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bestMove == NOT_INITIALIZED) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getHeuristicEvaluation(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recursiveLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bestMove != NOT_INITIALIZED) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (monster == MT_WOLF) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;wolfs[bestMove / <span class="hljs-number"><span class="hljs-number">2</span></span>] += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;possibleMoves[bestMove % <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;rabbit += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;possibleMoves[bestMove % <span class="hljs-number"><span class="hljs-number">4</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MinMax; }</code> </pre><br clear="all">  As I said earlier, alpha-beta clipping is very effective, and the following indicators are proof of this.  For each case, at three different levels of calculation depth, I measured the number of entries in the heuristic evaluation function (less is better), and this is what happened: <br clear="all"><img src="http://habrastorage.org/storage3/d3d/18c/3cf/d3d18c3cfe38768363309f659df69934.png" alt="image"><br clear="all">  As a conclusion, I can say that the use of this cut-off algorithm will not only speed up the work of the intellect, but will also increase its level. <br clear="all"><br clear="all"><h1>  Nuances </h1>  The algorithm makes optimal moves only if its opponent thinks optimally.  The quality of the course mainly depends on the depth of the recursion, and on the quality of the heuristics.  But it should be noted that this algorithm evaluates the quality of the course deep enough, and in no way is tied (if not explicitly prescribed somewhere in the heuristics) for the number of moves.  In other words, if you apply this algorithm to chess, without additional modifications, it will put the mats later than it could.  And in this example, if the hare realizes that he has no way to win, with the optimal strategy of the wolves, he can commit suicide, despite the fact that he could delay the loss. <br clear="all"><br clear="all">  Again, never make alpha-beta cut-off for alpha-beta, unless you are 100% sure that this is acceptable for your implementation.  Otherwise, your alpha beta will degrade the intelligence of the algorithm as a whole, with a high probability. <br clear="all"><br clear="all">  The algorithm is fundamental, in the sense that it is the foundation for a large variety of different modifications.  In the form in which it is presented here, it cannot be used for checkers, chess, go.  Most modifications seek: <br clear="all"><br clear="all"><ul><li>  Reuse calculations. </li><li>  Analyze different situations with different depths. </li><li>  Increase the number of cuts, due to the general principles and heuristics for a particular game. </li><li>  Introduce move patterns.  For example, in chess, the first few moves are openings, not a minimax job. </li><li>  Introduce third-party quality measures moves.  For example, to check whether it is possible to win in one move, and if it is possible to win, and not to launch the minimax. </li><li>  Much more. </li></ul><br clear="all">  A huge number of modifications and allow the computer to play chess, and even beat the person.  Without such modifications, minimax is practically not applicable to chess, even on modern super computers.  Without optimizations, in chess for three moves, it would be necessary to check about 30 ^ 6 moves (729 billion), but we need the depth of calculation to be more ... <br clear="all"><br clear="all"><h1>  Happy end </h1>  As promised - the <a href="https://github.com/TheHorse/RabbitMinMax">source</a> , the <a href="">version for Windows</a> (should work in vayne).  I recommend trying to write the same thing for checkers, chess is useful. </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/146088/">https://habr.com/ru/post/146088/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../146081/index.html">ABBYY Cup: Debriefing</a></li>
<li><a href="../146082/index.html">Russian audio card: my attempt at production and crowdfunding</a></li>
<li><a href="../146083/index.html">Novice developers: the history of one bug, or for what you can not like the new version of iOS</a></li>
<li><a href="../146086/index.html">The Android Energy Management API can cause increased consumption</a></li>
<li><a href="../146087/index.html">BlueStacks emulator testing</a></li>
<li><a href="../146089/index.html">How to find an investor for 2 cups of coffee</a></li>
<li><a href="../146090/index.html">There was a translation of the standard EcmaScript 5</a></li>
<li><a href="../146091/index.html">You can control the quality of services automatically: KwikPik Experience</a></li>
<li><a href="../146092/index.html">Group stream state</a></li>
<li><a href="../146093/index.html">IBM Sequoia supercomputer has become the fastest in the world, having overtaken Fujitsu K by a factor of 1.5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>