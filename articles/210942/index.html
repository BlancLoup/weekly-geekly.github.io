<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How I invent a method of simulating annealing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good time, Habr! 

 I was inspired to write this paper reading ‚ÄúIntroduction to optimization. Imitation annealing . It so happened that just recently ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How I invent a method of simulating annealing</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/eb8/9ba/0e7/eb89ba0e7933d4523d8262a2f158b3f3.jpg" align="left"><br>  Good time, Habr! <br><br>  I was inspired to write this paper reading <a href="http://habrahabr.ru/post/209610/">‚ÄúIntroduction to optimization.</a>  <a href="http://habrahabr.ru/post/209610/">Imitation annealing</a> .  It so happened that just recently I ran into the task of a traveling salesman, and to solve it I came up with an algorithm, the essence of which, as it turned out, is very close to the idea of ‚Äã‚Äãthe annealing simulation algorithm described in this article.  Moreover, there is even a ‚Äúreference‚Äù to my idea, and similar discussions were held in the comments, so I decided that it would be interesting for the community to look at the implementation. <br><a name="habracut"></a><br>  I'll start with a little intro.  I am a student of the 1st year of the master's program in the specialty "Software Engineering", and this semester we had a course of distributed systems, in which I got the task of a traveling salesman.  And it would be okay, but with the requirement to implement it in parallel and using four different technologies (Windows Azure, openmpi library, Go programming language, Limbo programming language in OS Inferno).  If I came across such a qualitatively described solution, the problems would be much less, but at that time I was able to find out only the branch and bound method.  Vile thing must be said, because the idea to implement it in parallel, and besides using technologies previously unknown, seemed to me at once unsuccessful.  As a result of much deliberation of this problem, I came to an algorithm that turned out to be surprisingly simple, although not very effective.  Nevertheless, I managed to pass it on to the teacher, and the ‚Äúresearch‚Äù work on the algorithm, as it turned out, would be quite suitable for this article.  Unless for article I will give the program code on pure C # and without use of parallel troubles. <br>  I will not dwell on the issues of what is optimization and annealing method, I think that in the article <a href="http://habrahabr.ru/post/209610/">‚ÄúIntroduction to optimization.</a>  <a href="http://habrahabr.ru/post/209610/">Annealing imitation ¬ª</a> it is explained just fine, and for those who wish to understand more, I advise you to read it.  I will go straight to the description of the traveling salesman problem and my solution. <br><br><h2>  Task analysis </h2><br>  The traveling salesman problem is one of the most well-known combinatorial optimization problems, which consists in finding the most profitable route that passes through the specified cities once and then returns to the source city.  In terms of the problem, the route profitability criterion is indicated (shortest, cheapest, aggregate criterion, etc.). <br>  If we formalize the task, then we are talking about a kind of weighted graph (for simplicity, for the sake of discussion, we set it undirected, although in the general case this may not be so), in which we need to find a circumvention path that passes through all the vertices exactly once and returns to the starting point, at the same time the minimum weight (for further reasoning I will call the vertices of the graph cities, and the weight of the edge - the distance between cities). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b4/c8c/b43/8b4c8cb4321d8625d5a5d3597c411be6.jpg"></div><br><br>  Such a graph can be represented as a symmetric matrix with zeros on the main diagonal (the length of the path from the city to itself is zero). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f81/79b/1f1/f8179b1f1af5b3b0ffd0fb67af537c06.jpg"></div><br><br><h2>  Algorithm of the decision </h2><br>  In this part I will describe both ways of implementing the algorithm (sequential and parallel), and give the program code for the sequential version. <br><br>  <b>Sequential implementation</b> <br>  Create an arbitrary starting path containing all the vertices once and returning to the starting position.  Then we randomly swap two cities and compare the lengths of the old and the new ways.  If the new path is shorter, save it.  If not, then we increase the counter.  When the counter takes a predetermined value, stop the algorithm, the last path found in this way will be considered the best. <br><br>  <b>Parallel implementation</b> <br>  Create an arbitrary initial path containing all the vertices once and returning to the initial position and ‚Äúdistribute‚Äù it to each of the parallel processes / threads.  Each of them, independently of each other, performs the described operations to find the optimal path and returns the result found.  The main stream, if implied, chooses the best from the results obtained. <br><br>  As you can see, the idea is very simple.  What is great, it is also very easy to implement that in the serial, in the parallel version, since  in the second case, there is no struggle for shared resources and there is no exchange of information between the threads themselves, which simplifies programming unimaginably. <br><br>  <b>C # software implementation</b> <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CCities</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   public Point[] Coordinate; public CCities(int N, int maxValue) //maxValue -   pictureBox   { Random random = new Random(); Coordinate = new Point[N]; //   ,   pictureBox,        //     int minBorder = (int)(maxValue * 0.05); int maxBorder = (int)(maxValue * 0.95); for (int i = 0; i &lt; N; i++) { Coordinate[i] = new Point(random.Next(minBorder, maxBorder), random.Next(minBorder, maxBorder)); } } }</span></span></code> </pre> <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CPath</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   double[,] distance; //     public int[] Path; public CPath(CCities map) { //      distance = new double[map.Coordinate.Length, map.Coordinate.Length]; //  ,        for (int j = 0; j &lt; map.Coordinate.Length; j++) { distance[j, j] = 0; for (int i = 0; i &lt; map.Coordinate.Length; i++) { double value = Math.Sqrt(Math.Pow(map.Coordinate[i].X - map.Coordinate[j].X, 2) + Math.Pow(map.Coordinate[i].Y - map.Coordinate[j].Y, 2)); distance[i, j] = distance[j, i] = value; } } //   //  1  - ,       0 -      ""  Path = new int[map.Coordinate.Length + 1]; for (int i = 0; i &lt; map.Coordinate.Length; i++) { Path[i] = i; } Path[map.Coordinate.Length] = 0; } //,      public void FindBestPath() { Random random = new Random(); for (int fails = 0, F = Path.Length * Path.Length; fails &lt; F; ) { //    //      int p1 = 0, p2 = 0; while (p1 == p2) { p1 = random.Next(1, Path.Length - 1); p2 = random.Next(1, Path.Length - 1); } //  double sum1 = distance[Path[p1 - 1], Path[p1]] + distance[Path[p1], Path[p1 + 1]] + distance[Path[p2 - 1], Path[p2]] + distance[Path[p2], Path[p2 + 1]]; double sum2 = distance[Path[p1 - 1], Path[p2]] + distance[Path[p2], Path[p1 + 1]] + distance[Path[p2 - 1], Path[p1]] + distance[Path[p1], Path[p2 + 1]]; if (sum2 &lt; sum1) { int temp = Path[p1]; Path[p1] = Path[p2]; Path[p2] = temp; } else { fails++; } } } //   public double PathLength() { double pathSum = 0; for (int i = 0; i &lt; Path.Length - 1; i++) { pathSum += distance[Path[i], Path[i + 1]]; } return pathSum; } }</span></span></code> </pre><br><br><h2>  Examples of the algorithm </h2><br><div style="text-align:center;"><img src="//habrastorage.org/files/199/179/915/1991799157614f328d7de07241d1ade6.jpg"></div><br><div style="text-align:center;"><img src="//habrastorage.org/files/bdf/228/90c/bdf22890cc08423185abd078d447fdff.jpg"></div><br><br><h2>  Algorithm health analysis </h2><br>  Let me prove first the parallelization efficiency of such an algorithm.  Since each of the parallel processes starts working with the same initial conditions, the probability of finding the optimal solution for each of them will be the same.  Take it for <i>p</i> .  Then the probability of not finding such a solution is <i>q = 1 - p</i> .  Thus, the probability <i>P</i> that at least one of the processes will find the optimal path is equal to: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/577/82b/93e/57782b93e462f5b138eef7fc17affa45.jpg"></div><br>  where <i>K</i> is the number of processes running in parallel.  Such a dependence very quickly tends to 1 even for small <i>p</i> .  The figure shows a plot of <i>P (K)</i> for <i>p = 0.1</i> (the ‚Äúde jure‚Äù schedule should be discrete, but I hope you will forgive me such a liberty): <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/344/946/255/344946255f2b86c29119919d9293d301.jpg"></div><br><br>  It can be seen that already at <i>K</i> = 6..7 the probability <i>P</i> becomes equal to 0.5.  That is, the benefits of using multiple processes are obvious - a very rapid increase in probability. <br>  We now find the probability <i>p</i> for one process.  Obviously, it is inversely proportional to the size of the <i>N</i> matrix and is directly proportional to the value of <i>F</i> , which the counter reaches when the algorithm stops its work.  A more accurate estimate, unfortunately, is almost impossible to give.  Almost the only thing we can say about the graph is that the number of different paths is equal to <i>(N-1)! ‚ÅÑ2</i> (subtract one because one city is the starting one and obviously does not participate in the search, but we divide by two because that the same path can be walked in both directions). <br>  Thus, it is possible to estimate the desired probability only experimentally.  A series of experiments was carried out for different parameters of <i>N.</i>  The limit for the counter is <i>F = N ^ 2</i> .  For each <i>N</i> , 10,000 runs were performed and the results are listed in the table: <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/546/287/864/5462878640eb4cb7851053c7a98f75cf.jpg"></div><br><br>  Let me explain the notation: <br>  <i>P (min)</i> is the probability to find the optimal solution.  <i>P (X%)</i> is the probability to find a solution that differs from the optimal one by no more than <i>X%</i> .  That is, for example, for <i>P (10%),</i> such solutions will be those that fall in the interval <i>[min, min + (max-min) * 0.1]</i> , where <i>min</i> and <i>max</i> are the minimum and maximum respectively found paths. <br>  There should be a digression and say this.  Of course, such an analysis does not claim any real accuracy, since even 10,000 experiments are very few for obtaining the desired regularities (when restarting, the result may be completely different), and, most importantly, there is no guarantee that the algorithm has found best possible path.  For evaluation, he operates with knowledge of the best of those found, but far from the fact that he is also the best of all.  Nevertheless, I think it is possible to use the results obtained, if not for quantitative, but at least for a qualitative understanding of the operation of the algorithm. <br>  We illustrate the same results: <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/0eb/f3a/9d6/0ebf3a9d683e44a0a4139706962f2986.jpg"></div><br><br>  <b>Advantages of the method</b> <br><ul><li>  "Ideological" simplicity of the algorithm; </li><li>  Ease of implementation in both sequential and parallel versions; </li><li>  The rapidly growing efficiency of the algorithm with its parallel implementation; </li><li>  High probability of finding a solution that is close to optimal. </li></ul><br>  <b>Disadvantages of the method</b> <br><ul><li>  Very quickly, the falling probability of finding the exact solution with increasing N; </li><li>  The difficulty of accurately estimating the probability of finding a solution; </li><li>  The lack of interconnection between threads in a parallel version leads to the fact that each of the threads can find the same bad solutions and not optimize the overall result (with very bad luck, all threads can just do the same work up to each iteration and return one and the same the same way in the end. It is very unlikely, but it is possible). </li></ul><br>  <b>Algorithm optimization</b> <br>  In the process of work and research method, I suggested the following possible ways to improve the algorithm: <br><ul><li>  Adding "history" already proven paths.  At the moment, the algorithm does not remember the tested paths and does not control the new variants obtained at each iteration.  Adding the function of checking and screening out such paths should greatly affect the accuracy of the result; </li><li>  Perhaps there is a way to more "fine" setting the control value of the counter.  As can be seen from the test graphs, with the current settings ( <i>F = N ^ 2</i> ), a ‚Äúhole‚Äù appears in the area of <i>N</i> = 20 matrixes. I do not have an accurate understanding of the reasons for this behavior of the graph, but there is probably a way to select this value in a better way. . </li></ul><br><h2>  Conclusion </h2><br>  I will be frank - it works so-so.  I showed all the graphics and other results; you can see that the result of the work leaves much to be desired.  In any case, this algorithm cannot be used to find the exact solution at this stage.  On the other hand, he still finds more or less sane options, does not slip into frank lazy.  If the task does not require an exact solution, and it comes down close to optimal, then this algorithm is quite efficient.  Alternatively, you can use this algorithm to initially approximate the optimal value, and then run something like a search for options. <br>  If you have any ideas for improving the performance of the algorithm, I will be very happy to hear them out. <br>  I am also ready to listen to any constructive criticism of the article itself (design, presentation style, etc.). <br><br>  For those who want to dig into the codes themselves, they uploaded an <a href="">archive of the project</a> to the mail cloud (written in VS2012, the project will be incompatible with earlier versions of VS; you will need .net framework 4.5 to run the program, the .exe file is located in the \ Salesman \ Salesman \ bin \ folder Debug) <br></div><p>Source: <a href="https://habr.com/ru/post/210942/">https://habr.com/ru/post/210942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210930/index.html">As I classes in Vim wrote</a></li>
<li><a href="../210932/index.html">ODR - On-Demand Routing</a></li>
<li><a href="../210934/index.html">Data migration between different e-commerce engines</a></li>
<li><a href="../210936/index.html">Is it necessary to make a client a friend, and a friend a client?</a></li>
<li><a href="../210938/index.html">Dislocker Or find a common language with BitLocker in Linux Mint</a></li>
<li><a href="../210946/index.html">Analyzing traffic sources to increase conversion</a></li>
<li><a href="../210948/index.html">Critical analysis of the games of the genre "hidden objects"</a></li>
<li><a href="../210950/index.html">Stresstest Apache and Nginx on EC2 MicroInstance</a></li>
<li><a href="../210952/index.html">Two stories about vulnerabilities in Google services</a></li>
<li><a href="../210954/index.html">Game developers troll creators Candy Crush</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>