<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Setting up a routing for a home multihomed server</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Now having multiple connections to the Internet on one, including the home server, is not uncommon. City lokalki, ADSL, 3G modems ... Add home local a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Setting up a routing for a home multihomed server</h1><div class="post__text post__text-html js-mediator-article">  Now having multiple connections to the Internet on one, including the home server, is not uncommon.  City lokalki, ADSL, 3G modems ... Add home local and external virtual networks (VPNs) to this network, and we get a core mix of interfaces between which you need to route traffic, balance traffic between different channels to the Internet (when they are), and switch from non-working channels to workers (when they fall off). <br><br>  Judging by the posts in the internet, most people who are confronted with this situation, very poorly imagine how it is configured.  It should be noted that, in linux, routing management is very complicated and confusing - a consequence of evolutionary development and support (partial) compatibility.  I want to describe the principles of setting up routing for <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B5%25D1%2581%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">multihomed</a> servers on a specific, rather complicated example: on the server there are three physical network interfaces (one to the home LAN and two to the ADSL modems), two ADSL connections (ADSL modems in the bridge mode, so pppd raises the same server) to different providers (one with a static IP, the second with a dynamic one), plus a VPN to the company's server - a total of six interfaces. <br><br>  The topic is quite complicated, so to understand the material, you will need at least a minimal understanding of the routing operation (what default route and gateway are), firewall (packet marking, connection tracking, connection between different tables and firewall chains and routing), pppd (ip-up / ip-down) and IP and TCP protocols. <br><a name="habracut"></a><br><h4>  General configuration and problem statement </h4><br>  So, we have three network interfaces: <ul><li>  <b>eth0</b> (192.168.0.2), connected to the first ADSL modem (192.168.0.1) </li><li>  <b>eth1</b> (192.168.1.2), connected to the second ADSL modem (192.168.1.1) </li><li>  <b>eth2</b> (192.168.2.1), is connected to the home LAN (192.168.2.x) and is the gateway to the Internet for this lokalki </li></ul>  Two more interfaces appear when a connection to the Internet via ADSL is established: <ul><li>  <b>ppp0</b> (ssss), static IP through the first ADSL modem to the first provider (8Mbps) </li><li>  <b>ppp1</b> (dddd), dynamic IP via second ADSL modem to the second provider (2Mbps) </li></ul>  And, if there is at least one connection to the Internet, another interface is added: <ul><li>  <b>tun0</b> (vvvv), static IP over VPN to company server </li></ul>  It is necessary to implement: <ul><li>  access from the server and home LAN to the Internet in the presence of any of the ADSL connections </li><li>  balancing traffic between ADSL connections if both are available, according to the width of the channels </li><li>  VPN should be raised through any ADSL connection, and if both are available, then through the first provider (wider channel) </li><li>  mail should be sent through the first provider (there is a static IP linked to my domain) </li><li>  access to the website with statistics and the control panel of the second provider must go through the second ADSL (the provider has closed access to his site outside) </li></ul>  So, you have already set up all these connections, you can raise / lower any of them one at a time, if only one ADSL connection is raised, then everything works fine ... it only remains to configure multihoming. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  A bit of theory </h4><br>  To configure routing earlier (and even now - in simple cases) the route command was used.  You can forget about it - such settings are made only via the ip command (from the iproute2 package), and using ip and route at the same time will bring nothing but trouble.  At the time of the route command, the <i>routing table</i> was one.  Now there are several routing tables (and one of them is <b>main</b> ‚Äî the same one that the route command works with).  These tables are listed in / etc / iproute2 / rt_tables: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># cat /etc/iproute2/rt_tables # # reserved values # 255 local 254 main 253 default 0 unspec # # local # #1 inr.ruhep</span></span></code> </pre> <br>  You can view their contents with the command <b>ip route list table &lt;table name&gt;</b> .  There is nothing interesting in the <b>local</b> table - there are link-local rules for routing through the available interfaces;  in the <b>main</b> table, the <b>main</b> routing rules;  <b>default</b> table is empty;  The <b>unspec</b> table (which can also be accessed as <b>all</b> ) displays all the routing rules from all existing tables. <br>  To create new tables, you need to add their names to this file (more precisely, this is necessary only for referring to your tables by names ‚Äî by numbers you can refer to them as well). <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 127.0.0.0 127.0.0.1 255.0.0.0 UG 0 0 0 lo 192.168.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0 192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth1 192.168.2.0 0.0.0.0 255.255.255.0 U 0 0 0 eth2 # ip route list table main 127.0.0.0/8 via 127.0.0.1 dev lo scope link 192.168.0.0/24 dev eth0 proto kernel scope link src 192.168.0.2 192.168.1.0/24 dev eth1 proto kernel scope link src 192.168.1.2 192.168.2.0/24 dev eth2 proto kernel scope link src 192.168.2.1</span></span></code> </pre><br>  As soon as we had more than one routing table, we also needed a mechanism by which it was possible to select the routing table used ‚Äî its name is <i>the routing rules (RPDB, routing policy database)</i> .  The main advantage of this mechanism is the ability to choose routing not only based on the destination address (as the <b>route</b> command did and do <b>ip route ...</b> ), but also by other criteria (source address, interface, tos, fwmark, ...) fields.  It works like this: you specify (via the <b>ip rule ...</b> command) any number of rules in the format ‚Äúcriteria-&gt; routing table‚Äù.  If for this packet the criteria in the routing rules match, and in the specified routing table there is a route for this packet (based on the destination address), then it will be executed;  and if not, then we return to the routing rules and check other options.  Here are the default routing rules: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ip rule list 0: from all lookup local 32766: from all lookup main 32767: from all lookup default</span></span></code> </pre><br>  The first column is priority;  rules are viewed in order of increasing priority.  These rules mean that you first look at the <b>local</b> table (where link-local routing rules are), then the <b>main</b> table (which you usually run through the <b>route</b> command) and where the default route is usually specified ‚Äî that is,  in this case, the execution of the routing rules stops, then (if the default route was not specified in <b>main</b> ) the <b>default</b> table (empty by default). <br><br>  Here is a simple example of how all this farm can be used to process packets from the home localhost 192.168.2.100 address using separate routing rules other than the default routing (we give it access only to the first ADSL modem and to the Internet through the first provider ): <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># echo '100 local100' &gt;&gt; /etc/iproute2/rt_tables # ip route add 192.168.0.0/24 dev eth0 table local100 # ip route add default via &lt;__&gt; dev ppp0 table local100 # ip rule add from 192.168.2.100 lookup local100 priority 5 # ip route list table local100 192.168.0.0/24 dev eth0 scope link default via &lt;__&gt; dev ppp0 # ip rule list 0: from all lookup local 5: from 192.168.2.100 lookup local100 32766: from all lookup main 32767: from all lookup default</span></span></code> </pre><br>  Now a little about the firewall.  With it, it is also possible to influence the routing. <br><img src="https://habrastorage.org/getpro/habr/post_images/734/f70/8a1/734f708a1c6a7a696c386f60f633ede9.jpg"><br>  As you can see in the diagram, packages from, for example, local applications go through the ‚ÄúRouting Decision‚Äù stage twice.  As far as I understand, the first time this happens at the time of the package creation is in order to determine the outgoing interface and outgoing IP for it (which can check the firewall rules, so they should already be known when the packet enters the firewall), plus rerouting for This package is calculated after the firewall chain MANGLE is executed, which could change any packet fields that could affect the routing of this package. <br><br>  In our case, the easiest way to influence routing through a firewall is to change the fwmark field of the package in the MANGLE chain, and then use the routing rules to select the routing table based on the value of the fwmark field of the package (this requires creating several routing tables with different rules - for example, one table to write the default route through one provider, and the other through another provider). <br><br><h4>  Setting up the routing: the end result </h4><br>  The path to this end result is thorny in some places (the <s>bugs of the</s> features of pppd and openvpn do not allow us to relax) and therefore will be described below.  In the meantime, let's see what we need to get. <br><br><h5>  Balancing between two providers </h5><br>  To begin with, let's configure the simultaneous use of both providers, with load balancing in the ratio of 8 to 2 (according to the width of the channels).  This method selects the routing for each individual destination address - i.e.  if the connection initially went through the first provider, then all its packets will leave only through the first provider, and all subsequent connections to this address will leave <i>for some time</i> only through this provider.  Balancing not by connection but by package is done differently, and will work only if we have several connections to one provider. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ip route replace default scope global \ nexthop via &lt;_isp1&gt; dev ppp0 weight 8 \ nexthop via &lt;_isp2&gt; dev ppp1 weight 2</span></span></code> </pre><br>  Because  the kernel caches information about the connection of the destination addresses and the default routing selected for them, you may need to reset this cache (so that the kernel again, with a probability of 8 to 2, chooses the default routing for this destination address): <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ip route flush cache</span></span></code> </pre><br><h5>  Manual channel selection for specific connections </h5><br>  Because  In some cases, we need to control through which of the external channels to send a packet, we will create for each channel a separate routing table with its own default route: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># echo '1 isp1' &gt;&gt; /etc/iproute2/rt_tables # echo '2 isp2' &gt;&gt; /etc/iproute2/rt_tables # echo '3 vpn' &gt;&gt; /etc/iproute2/rt_tables # ip route add default via &lt;_isp1&gt; dev ppp0 table isp1 # ip route add default via &lt;_isp2&gt; dev ppp1 table isp2 # ip route add default via &lt;_vpn&gt; dev tun0 table vpn</span></span></code> </pre><br>  Now add the routing rules so that using the firewall by setting the desired fwmark values, we can select the desired routing table: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ip rule add priority 100 fwmark 0x4/0x4 lookup vpn # ip rule add priority 101 fwmark 0x1/0x1 lookup isp1 # ip rule add priority 102 fwmark 0x2/0x2 lookup isp2</span></span></code> </pre><br>  The value 0x4 / 0x4 (value / mask) means that the bits from the fxmark field will be taken using the 0x4 mask (i.e., only the third bit) which should match the value 0x4.  Those.  In fwmark, the third bit must be set in order for the rule for the vpn table to work, and the remaining bits do not matter.  This approach allows the firewall to set several bits in the fwmark, thus specifying several "suitable" channels for this packet.  The priority of these channels (if they are all available) is determined by the priority of the routing rules.  If a channel is unavailable, then the corresponding routing table will still be viewed, but the default route will not appear in it, so a return to the following routing rules will occur and the next appropriate channel will be found. <br><br>  All these commands haven‚Äôt affected anything yet - the fwmark firewall doesn‚Äôt set, then the routing rules for the <b>isp1</b> , <b>isp2</b> and <b>vpn</b> tables do not work, and the default routing is determined by the <b>main</b> table as before: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ip route list ### "table main"    &lt;_vpn&gt; dev tun0 proto kernel scope link src &lt;vvvv&gt; &lt;_isp1&gt; dev ppp0 proto kernel scope link src &lt;ssss&gt; &lt;_isp2&gt; dev ppp1 proto kernel scope link src &lt;dddd&gt; 192.168.2.0/24 dev eth2 proto kernel scope link src 192.168.2.1 192.168.1.0/24 dev eth1 proto kernel scope link src 192.168.1.2 192.168.0.0/24 dev eth0 proto kernel scope link src 192.168.0.2 127.0.0.0/8 via 127.0.0.1 dev lo scope link default nexthop via &lt;_isp1&gt; dev ppp0 weight 8 nexthop via &lt;_isp2&gt; dev ppp1 weight 2 # ip route list table isp1 default via &lt;_isp1&gt; dev ppp0 # ip route list table isp2 default via &lt;_isp2&gt; dev ppp1 # ip route list table vpn default via &lt;_vpn&gt; dev tun0 # ip rule list 0: from all lookup local 100: from all fwmark 0x4/0x4 lookup vpn 101: from all fwmark 0x1/0x1 lookup isp1 102: from all fwmark 0x2/0x2 lookup isp2 32766: from all lookup main 32767: from all lookup default</span></span></code> </pre><br>  Now we can specify that access to the website with statistics and control panel of the second provider should go through the second ADSL: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># iptables -t mangle -A OUTPUT -d &lt;ip__isp2&gt;/32 -j MARK --set-mark 0x2</span></span></code> </pre><br>  If it is necessary that these rules work not only for packets outgoing from our server, but also for packets from home LAN, then all these rules must be added to the firewall not only in the OUTPUT chain, but also in the FORWARD chain. <br><br><h5>  Answer from the same interface </h5><br>  All this will work fine while we are talking only about outgoing connections.  But we have a server ... and there are incoming connections to the server.  Let's say we have a website raised on static IP ssss (channel of the first provider).  Now, if the admin of the second provider from the &lt;ip_site_isp2&gt; server wants to look (via lynx) on our website, it will not work!  The fact is that he will send a request to our IP ssss (on which website) through the channel of our first provider, and our server will send the answer to this request through the channel of the second provider (and, accordingly, from the dddd address - we have, Of course, SNAT / MASQUERADE packets outgoing via the <b>ppp0</b> , <b>ppp1</b> and <b>tun0</b> interfaces are <b>configured</b> - according to the firewall settings that we just made: send packets to the &lt;ip_site_isp2&gt; address via the second provider channel.  The admin web browser that sent the request to the ssss address does not expect to receive a response from the dddd address, so it will not work. <br><br>  To solve this problem, it is necessary to guarantee answers to incoming connections from the interface from which the packets were originally received.  To do this, unfortunately, you have to use firewall connection tracking (conntrack) to set fwmark (connmark).  Unfortunately - because conntrack is a big complex and buggy garbage, but there is no choice.  It is done this way (these rules must be added to the firewall first, BEFORE the rules establishing a fwmark like the one described above): <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># iptables -t mangle -A INPUT -i ppp0 -j CONNMARK --set-mark 0x1 # iptables -t mangle -A INPUT -i ppp1 -j CONNMARK --set-mark 0x2 # iptables -t mangle -A INPUT -i tun0 -j CONNMARK --set-mark 0x4 # iptables -t mangle -A INPUT -i eth+ -j CONNMARK --set-mark 0x8 # iptables -t mangle -A OUTPUT -j CONNMARK --restore-mark # iptables -t mangle -A OUTPUT -m mark ! --mark 0x0 -j ACCEPT</span></span></code> </pre><br>  Here we label incoming packets (more precisely, the connections to which they relate) according to the interfaces from which they came.  Moreover, the fwmark value (more precisely, connmark) is chosen so that it corresponds to the routing table, through which you need to send responses to these packets (1,2,4 - for isp1, isp2 and vpn; 8 is not used in the routing rules fwmark, t .e. packets with this fwmark will be sent according to the usual routing in the <b>main</b> table - for packets from local networks, this is quite suitable). <br><br>  This marking does not affect the routing of incoming packets, but this allows us to actually bind this marking to all packets of this connection, including  outgoing packets.  Next, for outgoing packets on the same connection (responses to incoming packets), we set the fwmark value to the same value as the incoming packets and which is bound to this connection (more precisely, copy the connmark value to fwmark).  And if the result of outgoing packets is set to fwmark (not 0), then all subsequent fwmark installation rules for selecting the outgoing channel cannot be applied - this packet must be sent through the same interface through which the incoming packet came, so we stop (-j ACCEPT ). <br><br>  So, the correct way to configure the firewall according to our problem statement is as follows: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># iptables -t mangle -A INPUT -i ppp0 -j CONNMARK --set-mark 0x1 # iptables -t mangle -A INPUT -i ppp1 -j CONNMARK --set-mark 0x2 # iptables -t mangle -A INPUT -i tun0 -j CONNMARK --set-mark 0x4 # iptables -t mangle -A INPUT -i eth+ -j CONNMARK --set-mark 0x8 # iptables -t mangle -A OUTPUT -j CONNMARK --restore-mark # iptables -t mangle -A OUTPUT -m mark ! --mark 0x0 -j ACCEPT # iptables -t mangle -A OUTPUT -p tcp -m tcp --dport 25 -j MARK --set-mark 0x1 # iptables -t mangle -A OUTPUT -d &lt;ip__vpn&gt;/32 -p udp -m udp --dport 1130 -j MARK --set-mark 0x1 # iptables -t mangle -A OUTPUT -d &lt;ip__isp2&gt;/32 -j MARK --set-mark 0x2</span></span></code> </pre><br>  Together with the settings of the rules and routing tables, we get exactly what we needed.  It remains to figure out how to set these settings in the dynamics, given the fact that the channels may fall and rise. <br><br><h4>  Thorny path to the final result </h4><br>  Honestly, the article turned out and so rather big, so in addition to clutter it with your ip-up / down scripts, as I was going to, I will not now.  If someone asks in the comments - add to the article later.  And now I will briefly describe the main tasks and problems encountered in the implementation of the above settings. <ul><li>  pppd cannot build a multiple default route by itself, so it needs to be started with the nodefaultroute option, and install default route with handles in / etc / ppp / ip- {up, down} scripts (or user scripts that are automatically called from these scripts in different distributions it is configured differently). <ul><li>  Since the channels go up one by one, then at the moment of calling the ip-up script there can be no default route (this channel rose first) and then it should establish the usual single default route through this channel;  or the default route may already exist through another channel (this channel has risen to the second), and then it needs to replace the single default route with a double one (with nexthop and weight) - this is done in the <b>main</b> routing table. </li><li>  It is also necessary to add a single default route through this channel to the corresponding routing table ( <b>isp1</b> or <b>isp2</b> ). </li><li>  Logically, in the ip-down script, you need to do the reverse operation (if one of the two channels disconnects, then double the default route should be replaced with the normal one through the remaining channel, if the last channel is disconnected, then you need to delete the default route altogether) ... But in practice <b>pppd removes the default route</b> , even if it was double, and even if pppd was started with the nodefaultroute option (this is probably a bug in pppd).  Therefore, the ip-down task is reversed: if it was not the only channel, then raise the normal default route through the remaining channel.  Unfortunately, not everything is simple here either: <b>pppd deletes the default route in parallel with the execution of the ip-down script, i.e.</b>  <b>there is a race condition</b> !  So in ip-down, you must first wait until pppd removes the default route, and only then raise it again. </li><li>  After making changes to the routing (in both ip-up and ip-down) it doesn‚Äôt hurt to make <b>ip route flush cache</b> . </li><li>  One more thing: both channels can rise / fall simultaneously, and their ip-up / down scripts can also work at the same time.  Most often this will lead to race condition and damage to the default route.  :) Therefore, <b>it is necessary to provide blocking when running these scripts</b> , ensuring that only one of them will work at a time - the easiest way to do this is through the chpst utility from the runit package or the setlock utility from the daemontools package. </li></ul></li><li>  openvpn is also able to call custom up / down scripts ... <ul><li>  In up, you need to add a single default route through this channel to the appropriate routing table ( <b>vpn</b> ). </li><li>  After making changes to the routing (in both up and down), it will not hurt to make <b>ip route flush cache</b> . </li><li>  In the down configuration, nothing is required (the default route from the vpn table will be removed by the kernel automatically when this channel drops), but if you need to do something, keep in mind that the up script runs as root, and down from the user openvpn ( or what you specified in the openvpn settings) (this is probably also a bug), and the openvpn user usually does not have enough rights to manage the routing (you have to use sudo). </li></ul></li></ul></div><p>Source: <a href="https://habr.com/ru/post/100919/">https://habr.com/ru/post/100919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../100912/index.html">Opera games with right click menu</a></li>
<li><a href="../100914/index.html">On gosuslugi.ru now you can see information about your traffic violations</a></li>
<li><a href="../100915/index.html">"Server" for nomadic life</a></li>
<li><a href="../100916/index.html">CHIP-8 based emulation principles</a></li>
<li><a href="../100917/index.html">Ed Arnoun: public / civic journalism is not a service, but a philosophy</a></li>
<li><a href="../100920/index.html">IPad iPad browser emulator</a></li>
<li><a href="../100921/index.html">The main futurist CiscoSystems in the new video talks about the "Internet of things" and technology in general</a></li>
<li><a href="../100924/index.html">Linux. Conky. Monitor Counter-Strike Servers</a></li>
<li><a href="../100925/index.html">Apple iOS 4.1 beta 3</a></li>
<li><a href="../100927/index.html">Review: Kindle DX - Amazon's bastard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>