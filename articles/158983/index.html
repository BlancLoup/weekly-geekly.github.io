<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding shaders in Unity3D with a specific example</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some theory 
 To understand the work of shaders, you need to be well aware of how the video card builds an image. The overall structure of the visuali...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding shaders in Unity3D with a specific example</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/751/0a2/62f/7510a262f470620e2b630454fe552450.png"><br><br><h4>  Some theory </h4><br>  To understand the work of shaders, you need to be well aware of how the video card builds an image.  The overall structure of the visualization of a 3D object on the screen is shown in the figure below: <br><img src="https://habrastorage.org/storage2/3ef/ccb/7c7/3efccb7c7df30b63f921bbfa040694e0.png"><br><a name="habracut"></a><habracut text=" "><br>  To begin with, let's look at a concept like Graphics Rendering Pipeline.  This is a pipeline, the stages of which are the video card for constructing the final image.  Let's delve a bit into history.  The first computers used software rendering.  The central processor was engaged in all miscalculations.  And the conveyor looked like this: <br><img align="right" src="https://habrastorage.org/storage2/42b/874/30b/42b87430b97a93a9fd868335f25d2538.png"><br>  The very first 3D accelerators used the so-called Fixed-Function Pipeline.  From the name it follows that it was fixed and strictly consistent.  To intervene in the construction of the picture was impossible.  Now we will consider all the stages of this pipeline.  In the future, it will be useful to us. <br><ol><li>  Input data.  As input parameters, the video card receives the object as separate vertices with multiple attributes.  For example, the position of the vertex in space, its color, normal, texture coordinates and others. </li><li>  Transformation and lighting.  At this stage, geometric operations are performed on the object (displacement, rotation, scale).  Here is the calculation of the scene illumination.  For each vertex, the illuminance values ‚Äã‚Äãare calculated based on the location and type of light sources, as well as the parameters characterizing the object surface (reflections, absorption). <img align="left" src="https://habrastorage.org/storage2/49b/34b/314/49b34b3145259c2b2e8280682d4c38c4.png"></li><li>  Triangulation.  At this stage, the vertices are combined into triangles. </li><li>  Rasterization  The purpose of this stage is to calculate the color of the pixels based on the data that has already been prepared.  Since we only have information about the color of the vertices, to obtain the color of the pixel, we interpolate linearly the value between the color values ‚Äã‚Äãof the corresponding vertices. </li><li>  Pixel processing.  At this stage there is a coloring of pixels.  Input data are the previous level data.  Also here we can apply additional effects to the pixels.  For example texturing. </li><li>  Formation of the finished image.  Now we have to build the final frame.  At this stage, Z-buffer data is taken into account in order to determine which object is closer to the camera.  Also here is an alpha test.  Layer by layer objects are ‚Äúplotted‚Äù on the final image.  Also post effects can be applied here.  After that, the finished frame is placed in the Frame Buffer. </li></ol><br>  So, we reviewed the stages of Fixed-Function Pipeline.  As we see, we can only influence the final image by selecting certain options at certain stages, but we cannot write, for example, our lighting model.  In those days, you had to be content with supporting a particular video adapter.  That was before the appearance of the first video cards with hardware support for DirectX 8.0 - 8.1.  From this point on, it was possible to write programs for processing vertices and pixels.  The conveyor for such a model is shown in the figure below. <br><img align="right" src="https://habrastorage.org/storage2/cd2/3e4/0f8/cd23e40f8a3f9853ad10d42f7bd45141.png"><br><br>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the future, it is planned to make all stages of the pipeline programmable. <br>  Now, knowing how a video card builds an image, it‚Äôs worth talking a bit about 3D objects.  A model is a collection of vertices, connections between them, as well as materials, animations, etc. Vertices have attributes.  For example, UV coordinates.  They show where this vertex is located on the texture scan.  The material determines the appearance of the object and includes a reference to the shader used to visualize the geometry or particles.  Thus, these components will not be displayed without material. <br>  A shader is a program for one of the stages of the graphics pipeline.  All shaders can be divided into two groups: vertex and fragmentary (pixel).  Unity3D has a simplified approach to writing shaders - Surface Shader.  This is just a higher level of abstraction.  When compiling the Surface shader, the compiler will create a shader consisting of vertex and pixel.  Unity3D has its own language.  Called <a href="http://docs.unity3d.com/Documentation/Components/SL-Reference.html">ShaderLab</a> .  It supports inserts on CG and HLSL. <br><br><h4>  Practice </h4><br>  As an example, consider writing a shader that imposes a texture, a normal map, a reflection map (based on Cubemap) on the diffuse object, and cuts pixels along the alpha channel in the diffuse texture. <br>  To begin, consider the general syntax of ShaderLab.  Even if we write a shader in CG or HLSL, we still need to know the ShaderLab syntax, so that we can set the parameters of our shader in the inspector. <br><br><pre><code class="cs hljs">Shader <span class="hljs-string"><span class="hljs-string">"Group/SomeShader"</span></span> { <span class="hljs-comment"><span class="hljs-comment">// properties that will be seen in the inspector Properties { _Color ("Main Color", Color) = (1,0.5,0.5,1) } // define one subshader SubShader { Pass { } } } Fallback "Diffuse" }</span></span></code> </pre> <br>  The first keyword is the <b>shader</b> .  After it in quotes the name of the shader is indicated.  Moreover, you can specify via '/' the path where the shader will be located in the drop-down menu when setting up the material in the editor.  After that there is a description of the <b>Properties {}</b> parameters, which will be visible in the inspector and with which the user can interact. <br>  Each shader in Unity3D contains at least one <b>Subshader</b> in its body.  When it is necessary to display the geometry, the engine searches for the necessary shader and uses the first Subshader from the list that the video card can process.  This is done to ensure that the same shader can be correctly displayed on various video cards that support different shader models.  The <b>Pass {}</b> keyword defines a block of instructions for a single pass.  A shader can contain from one to several passes.  The use of several passes can be useful, for example, in the case of optimization of shaders for old hardware or to achieve special effects (outline, toon shading, etc.). <br>  If Unity3D in the body of the shader has not found a single SubShader'a, which can correctly display the geometry, use a rollback to another shader, announced after the <b>Fallback</b> instruction.  In the example above, the Diffuse shader will be used if the video card cannot correctly display the current one. <br><br>  Now consider a specific example. <br><br><pre> <code class="cs hljs">Shader <span class="hljs-string"><span class="hljs-string">"Example/Bumped Reflection Clip"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _BumpMap (<span class="hljs-string"><span class="hljs-string">"Bumpmap"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"bump"</span></span> {} _Cube (<span class="hljs-string"><span class="hljs-string">"Cubemap"</span></span>, CUBE) = <span class="hljs-string"><span class="hljs-string">""</span></span> {} _Value (<span class="hljs-string"><span class="hljs-string">"Reflection Power"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> } SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span> = <span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> } Cull Off CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Lambert struct Input { float2 uv_MainTex; float2 uv_BumpMap; float3 worldRefl; INTERNAL_DATA }; sampler2D _MainTex; sampler2D _BumpMap; samplerCUBE _Cube; float _Value; void surf (Input IN, inout SurfaceOutput o) { float4 tex = tex2D (_MainTex, IN.uv_MainTex); clip (tex.a - 0.5); o.Albedo = tex.rgb; o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap)); float4 refl = texCUBE (_Cube, WorldReflectionVector (IN, o.Normal)); o.Emission = refl.rgb * _Value * refl.a; } ENDCG } Fallback "Diffuse" }</span></span></code> </pre><br><br>  The <b>Properties</b> field contains four variables that will be displayed in the Unity3D inspector. <br>  <b>_MainTex</b> - the name displayed in the inspector, the type and the default value are indicated in brackets. <br>  <b>_MainTex</b> and <b>_BumpMap</b> are textures, <b>_Cube</b> is a cube for reflections, <b>_Value</b> is a slider for the degree of reflection effect. <br>  The tag <b>{"RenderType" = "Opaque"}</b> marks the shader as opaque.  This affects the draw queue. <br>  <b>Cull Off</b> indicates that there will be no clipping in the normal directions in the shader.  There are three options for clipping polygons: the normals of which are directed from the camera, into the camera, and without clipping.  The last option means that we will see the polygon from two sides. <br>  When writing code, we will use the CG insert.  The insert is framed by two keywords: <b>CGPROGRAM</b> , <b>ENDCG</b> . <br>  <b>#pragma surface surf Lambert</b> - announcement of the surface-shader function and additional parameters.  In this case, the function is called <b>surf</b> , and the Lambert lighting model is indicated as additional parameters. <br>  Now consider the input structure.  All possible variables of the input structure can be found in the <a href="http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaders.html">help</a> .  We will consider only those that used. <br>  The variables <b>uv_MainTex</b> and <b>uv_BumpMap</b> are the UV coordinates needed by the shader for the correct texture mapping on the object.  These variables must be named the same as the names of the texture variables with the prefix uv_ or uv2_ for the first and second channels, respectively.  <b>worldRefl</b> and <b>INTERNAL_DATA</b> are used for reflections. <br>  Now consider the function of the <b>surf</b> shader. <br>  The first step is a four-component vector that stores information about the color of a pixel texture.  The <b>tex</b> variable will store information about it.  After that, with the <b>clip</b> function, we specify which pixels we skip when rendering.  Since  we cut off according to the information stored in the alpha channel, then in the parameters specify tex.a. <br>  After clipping, we apply our main texture to the object with the following line: <pre> <code class="cs hljs">o.Albedo = tex.rgb;</code> </pre>  The variable <b>o</b> is our output structure.  All its fields can be viewed in the SurfaceShaders help. <br>  The next step is to use the normal map: <pre> <code class="cs hljs">o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));</code> </pre>  Then we make the imposition of reflection: <pre> <code class="cs hljs">float4 refl = texCUBE (_Cube, WorldReflectionVector (IN, o.Normal)); o.Emission = refl.rgb * _Value * refl.a;</code> </pre>  It is worth noting here that we multiply the received information about the reflection by <b>_Value</b> so that we can control the degree of effect in the inspector. <br>  Well, in the end we do not forget to add the Fallback in case the video card cannot display this shader correctly. <br><br>  And here's what we got: <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/K4_pinJ7MaU%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253,15700255,15700259&amp;usg=ALkJrhhmujWQeLxBo9QAYRGkU5RpFgiY4w" frameborder="0" allowfullscreen=""></iframe></habracut></div><p>Source: <a href="https://habr.com/ru/post/158983/">https://habr.com/ru/post/158983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../158971/index.html">Scripting Techniques in Bash</a></li>
<li><a href="../158973/index.html">Good Practice on setting up a small local network based on Active Directory</a></li>
<li><a href="../158975/index.html">Introduction to Pedestrian Modeling</a></li>
<li><a href="../158977/index.html">The digest of interesting news and materials from the world of PHP over the past two weeks, ‚Ññ4 (03.11.2012 - 16.11.2012)</a></li>
<li><a href="../158979/index.html">Experiment with kanban board or how to do everything</a></li>
<li><a href="../158985/index.html">NULL project</a></li>
<li><a href="../158987/index.html">Workflow in Mozilla when creating the Save for Later feature for Firefox</a></li>
<li><a href="../158991/index.html">VKontakte "I like" widget caches parameters</a></li>
<li><a href="../158995/index.html">The digest of interesting news and materials from the world of ayti for the last week ‚Ññ31 (November 10 - 16, 2012)</a></li>
<li><a href="../158997/index.html">3D printing and heart tissue biorobots</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>