<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>8 programming traps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article contains those programming traps that I got into myself, continue to fall and maybe never stop, as well as those in which I found my comr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>8 programming traps</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/434/dc1/606/434dc1606128b254d0972321bb9b306d.jpg"><br><br>  This article contains those programming traps that I got into myself, continue to fall and maybe never stop, as well as those in which I found my comrades. <br><br>  However, I believe that they can be avoided if you know which traps you can get in and how to get out of them.  Perhaps this faith is another trap. <br><a name="habracut"></a><br><h2>  Brief introduction </h2><br>  Imagine that you fell into a hole.  Let it be 3 meters deep.  You will start to get out of it, climb, cling, I do not know what else you will think of, but most likely you will get out. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In programming, you can also fall into the trap.  But if we take the pit as an analogy, then it will be 50 meters deep and covered with a heavy steel plate from above. <br><br>  Do you think you will stay long in such a pit? <br><br>  Most likely, until someone finds you there! <br><br>  But this is not such a big problem; you can get out of each programming trap on your own and almost without any other efforts - you just need to know three things: what kind of trap are you, how did you get there and where is the ‚Äúsecret door‚Äù the exit. <br><br>  There is one amazing thing about programming traps - almost every trap is a commitment to one of two opposing extremes, and getting out of a trap is skillfully balancing between them. <br><br>  It can be said that avoiding traps is a narrow path, where problems are to the left and problems to the right are absurd to the right. <br><br>  Okay, no one reads the introduction anyway, so let's go! <br><br><hr><h2>  Trap # 1: Optimization </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/d37/36a/213/d3736a2130d5d73fffe1626d8db279ba.jpg"><br><br>  As Knut wrote, premature optimization is the root of all evil.  Many people know this rule, some do not follow it, some make it absolute, but few know that late optimization is even worse! <br><br><h4>  Too much optimization attention </h4><br>  Often, this type of programmers is sinning like Olimpiadnik.  Knowledge of efficient algorithms or the internal structure of the processor makes them think that the code should be as efficient as possible. <br><br>  In practice, it takes too much time to optimize, the code becomes completely unsupported, non-extensible and error-proof. <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ Attempt to immediately write fast / undemanding code to resources <br>  ‚Ä¢ The desire to squeeze everything out of the code, to the detriment of other indicators <br>  ‚Ä¢ Believing that O (n) instead of O (n ^ {2}) or replacing all multiplication operations with 2 by a bit shift will make a candy out of the program </blockquote><br><br><h4>  Too little optimization attention </h4><br>  One of my still unfinished projects comes to an end.  Trying to avoid the error of premature optimization, optimization was forgotten before the end - moved to the last (the last but one if absolutely be honest) stage. <br><br>  Now, when more than half is already ready, I understood - trying to avoid one trap, I fell into the opposite! <br><br>  Now, in order to improve performance to an acceptable level, you need not just to run the profiler a couple of times and fix a couple of isolated algorithms as functions, you need to rewrite at least a third of the code already written! <br><br>  This trap is called - late optimization, if you do not anticipate the possibility of optimization in advance, be prepared for the fact that a significant part of your beautiful and clear code will have to be thrown out! <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ Sincere belief that any optimization is premature <br>  ‚Ä¢ Postpone optimization to the final part of the project <br>  ‚Ä¢ Failure to provide some small architectural solutions for future optimization </blockquote><br><br><h4>  Output </h4><blockquote>  ‚Ä¢ Do not try to optimize the code immediately - create opportunities for future optimization. <br>  ‚Ä¢ Do not delay optimization without a reason. <br>  ‚Ä¢ Rule 20/80: waste your time on those 20% of the code that will give 80% of the result (yes, use the profiler) </blockquote><br><br><hr><h2>  Trap number 2: Abstraction </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/e65/304/d7d/e65304d7dc2419146584610608a0f4b3.png"><br><br>  Abstraction in programming is probably the nicest thing.  First there were binary codes, then processor command mnemonics, then imperative programming ‚Äî state and operations (statements), then structural, procedural, modular, object-oriented, functional programming. <br><br>  Imagine that you still need to use goto to organize a loop. <br><br>  Imagine that you still need to produce the same functions, differing only in the type of data (instead of taking advantage of dynamic typing and patterns / generics). <br><br>  Imagine that you can‚Äôt just pick up and resize a collection - you need to allocate a new memory, copy an old collection there, add a new item, free unused memory. <br><br><h4>  Excessive complexity </h4><br>  Again we start with the trap, where the attempt to abstract everything is brought to the point of absurdity. <br><br>  To pile up 20 classes, use 12 different patterns, implement your DSL to parse another DSL, create a cross-platform framework for visualizing cyclic graphs to create the next Tetris - this is about ‚Äúadvocates of abstraction‚Äù. <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ Writing a universal framework before implementing the main functionality, and 30% of the written code will be used on the strength of <br>  ‚Ä¢ Believing that the best way out of any problem is to use any pattern. <br>  ‚Ä¢ Writing the most generalized, receiving everything and issuing correct results for any input function values, instead of a specialized one, even if its functionality will never be used </blockquote><br><br><h4>  Simplify to infinity </h4><br>  Signs of ‚Äúadvocates of abstraction‚Äù are more common among more experienced programmers.  Ignoring abstractions - for beginners.  The best again balance somewhere between these extremes. <br><br>  Newbies often still do not know what abstractions are in programming in general and in the language they use in particular.  Because of this, they often write inexpressive code - one that could be rewritten using built-in language tools or third-party libraries / frameworks making it shorter, clearer and, more often, more efficient. <br><br><h5>  Signs that you're trapped </h5><br>  For this item, it is quite difficult to find common features - it all depends on the language, the task and a lot of other factors, but still: <br><blockquote> ‚Ä¢ Ignoring abstractions that could objectively improve the code (for example, iterators in C ++, monads in Haskell (I mean refusing to write your monad, where it makes sense), generators in Python, interfaces in Java, etc.) <br>  ‚Ä¢ When switching to a new programming language - refusing to study its abstractions, in view of the fact that you lived well without them (again, for example, when switching from C to C ++, refusing to learn from iterators, when switching from an imperative language to Haskell - refusing from studying monads) <br>  ‚Ä¢ Belief that the possibilities of the language that you do not use are actually superfluous (does not concern C ++ programmers; it‚Äôs a joke, of course, but as you know in every joke ...) </blockquote><br><br><h4>  Output </h4><blockquote>  ‚Ä¢ Do not use abstractions for the sake of abstractions. <br>  ‚Ä¢ Use known / accessible abstractions where they belong and don‚Äôt use them where they don‚Äôt have a place <br>  ‚Ä¢ Learn the abstractions that your programming language provides <br>  ‚Ä¢ Before implementing any functionality, consider whether you really need it (YAGNI principle) <br>  ‚Ä¢ Where it is possible to do without special losses without abstractions - do without them (KISS principle) </blockquote><br><br><hr><h2>  Trap # 3: Perfectionism </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f99/689/fe9/f99689fe930ea1e9177208dce02bb0ea.jpg"><br><br>  Perhaps the most popular trap among developers who know too much to just take and write code.  On this topic, quite recently a wonderful small article on Habr√© appeared, you can find a link to it at the end of the article. <br><br><h4>  The pursuit of excellence </h4><br>  On this topic, everything was chewed up and to me, but I want to be consistent, so I will also analyze this trap in the bones. <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ Belief that the main thing in the code is beauty, readability and maintainability <br>  ‚Ä¢ Continuous refactoring and rewriting even acceptable code <br>  ‚Ä¢ Find flaws in any code. <br>  ‚Ä¢ Believing that it is possible to write the perfect code in a reasonable time. <br>  ‚Ä¢ Increased attention to detail <br>  ‚Ä¢ Attempts to achieve the highest possible result. <br>  ‚Ä¢ Long thought over architecture of even the simplest parts of the project </blockquote><br><br><h4>  The path of chaos </h4><br>  From the previous list it is clear that perfectionism is a dangerous trap, can it be abandoned altogether? <br><br>  It is possible to completely ignore the purity of the code, refusal refactoring and turn off critical thinking and be better than absolute perfectionism (after all, a bad result is a result, and an absolute perfectionist only throws out the written code), but as with the other traps, balance is important here. <br><br>  Therefore, a complete abandonment of your striving for perfection will drive you into a completely opposite trap. <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ Belief that readability and extensibility of the code is not important <br>  ‚Ä¢ Lack of critical thinking, especially in relation to your code <br>  ‚Ä¢ Completion, even minimally acceptable result, or unacceptable at all <br>  ‚Ä¢ Full refusal of refactoring <br>  ‚Ä¢ Refusing to think about complex parts of the architecture <br>  ‚Ä¢ Failure to rewrite project or part of it from scratch </blockquote><br><br><h4>  Output </h4><br>  As always somewhere in the middle: <br><blockquote>  ‚Ä¢ Accept that the beauty of the code and the achievement of the result are important, sometimes the second is even more important <br>  ‚Ä¢ Consider rewriting from scratch as a last resort, but accept the fact that it may be necessary <br>  ‚Ä¢ Give yourself the maximum time you can spend on refactoring.  It can be 20, 50, even 80% of the total working time, the main thing is never to exceed it, so as not to get stuck <br>  ‚Ä¢ When you discover a flaw - think about how strong it is to spend time correcting it. <br>  ‚Ä¢ Use the 20/80 rule - try first to do those 20% of work that will bring 80% of the result </blockquote><br><br>  I hope these tips will help habrovchanam to get out of the trap of perfectionism.  All of them were understood in the bitter experience of the fight against this ailment and literally suffered through all the time that I do programming. <br><br><hr><h2>  Trap number 4: Technologies and tools </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/5db/ec0/86a/5dbec086ac67ed49a0eba9c3579f97d5.jpg" alt="image"><br><br>  Programming does not stand still and now you have a thousand and one tools and a library that, if they do not do all the work for you, they will certainly make it easier. <br><br>  However, sometimes they are used either too often or too rarely.  Let's start again with the first case. <br><br><h4>  Laziness </h4><br>  Of course, the use of already created libraries, frameworks and tools is only a reasonable manifestation of laziness, but sometimes even with good intentions this goes too far. <br><br>  Connecting at the same time boost, Qt and the active use of STL when writing Hello World is not the best idea, but sometimes similar things happen and this is another trap. <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ Library connection for 30+ megabytes, for the Mersen Vortex <br>  ‚Ä¢ Belief that everything you need has already been written <br>  ‚Ä¢ Failure that the bike might be better. <br>  ‚Ä¢ Inability to write lines of code without autocompletion in the IDE <br>  ‚Ä¢ Active use of tools, without understanding the principles of their work.  For example, frequent use of tools for visual editing GUI (like Qt Creator, CodeGear Rad Studio, MS Visual Studio) and, at the same time, refusing to try to understand their device </blockquote><br><br><h4>  Workaholism </h4><br>  Does this mean that I urge everyone to abandon the use of all tools and libraries, urge them to write bare code with their bikes in nano (or worse, on papyrus)? <br><br>  By no means.  On the contrary, as you will see, complete disregard for our programmer inheritance is an even worse vice.  And probably the most dangerous trap for programmers. <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ Regular writing of new and new bikes, without good reason for this <br>  ‚Ä¢ Belief that the capacity of the language and the standard library should be enough for the whole <br>  ‚Ä¢ Belief that autocompletion (not as in Sublime Text, but as in IDE) is for sclerotic <br>  ‚Ä¢ Writing your library, albeit monstrous, but not even approaching the functionality of existing analogues <br>  ‚Ä¢ Statements that debuggers and profilers are needed by those who do not understand how their own code works. </blockquote><br><br><h4>  Output </h4><blockquote>  ‚Ä¢ Get to know the tools available to you, but don't try to apply them anywhere <br>  ‚Ä¢ Carefully weigh the pros and cons, before choosing between using a third-party library and writing a bicycle <br>  ‚Ä¢ Try to improve your productivity using modern tools, at the same time do not depend on them <br>  ‚Ä¢ Accept that in training / test projects you can make exceptions to these rules. </blockquote><br><br><hr><h2>  Trap number 5: Golden Hammer </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/527/026/99f/52702699f616f96bfa474e2119d08af6.jpg"><br><br>  Another item in our hit chart is a golden hammer. <br><br>  Golden hammer is a bad habit.  After any method has worked in solving several problems, trapped begins to use this method wherever possible! <br><br>  There are several similar terms - panacea, magic pill, silver bullet, i.e.  such a method, which always, in 100% of cases, performs any task.  Another saying to this topic is to hammer nails with a microscope. <br><br>  The golden hammer is a fairly common but completely different trap.  Anyone can be a gold hammer, someone can fall in love with OOP and write classes for everybody, someone with design patterns and build a program from factories and singletons alone. <br><br>  For someone, a golden hammer is a favorite programming language, for someone - a favorite paradigm, for someone - a development methodology. <br><br>  The main thing that highlights the golden hammer - an attempt to use it always and everywhere. <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ Using one programming language for all tasks <br>  ‚Ä¢ Belief in the fact that one paradigm can solve all the problems of programming (most often they say so about OOP and AF) <br>  ‚Ä¢ Use for all projects, regardless of the conditions of one development methodology, for example, thoughtless use of TDD in all projects <br>  ‚Ä¢ The use of any tool provided by the language for most tasks, for example: <br>  - Passing all arguments by constant link only <br>  - The use of only one type of collections in the entire program, say arrays (vectors) <br>  - Use of non-tricky objects everywhere <br>  - Use in syntax-like languages ‚Äã‚Äã(for example, Java and C) <br>  single indent style and entity naming method </blockquote><br><br><h4>  Silver bullet does not exist </h4><br>  I am afraid that this trap is an exception to the rules and it is possible to avoid it without risking to get into another. <br><br>  This exception to the pattern I noticed once again proves that the golden hammer does not exist - my method of describing the trap as a dual entity misfired, but I am not afraid to abandon its use. <br><br>  This is the right way to get out of this trap. <br><br><h4>  Output </h4><blockquote>  ‚Ä¢ If you know only one programming language - learn another one, or two (you can and more, but within reasonable limits) <br>  ‚Ä¢ If you know several programming languages, but you have an obvious favorite, try using other languages ‚Äã‚Äãmore often. <br>  ‚Ä¢ If you programmed only by adhering to imperative or object-oriented programming, try the functional <br>  ‚Ä¢ If you constantly use any one development methodology, try something new. <br>  ‚Ä¢ Before making inertia decisions (and using your golden hammer) - think about possible alternative solutions. </blockquote><br><br><hr><h2>  Trap # 6: Cross Platform </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c9d/d82/e30/c9dd82e30ff4df062ea0abde59b95a1c.jpg"><br><br>  Cross-platform applications - those that run on multiple operating systems and / or multiple platforms. <br><br>  And here again there are two extremes - some developers are trying to write an application so that it works on all possible operating systems and is equally well suited for PCs and for tablets and smartphones. <br><br><h4>  For everyone </h4><br>  Often, people want to achieve an incredible degree of cross-platform. <br><br>  As a result, they get that the application does not work completely correctly on any OS and it is equally inconvenient to use it on a PC and on a tablet and on a smartphone! <br><br>  They fell into the trap of excessive cross-platform! <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ Belief in the fact that you can write such code that would produce acceptable results on all target platforms, without changes <br>  ‚Ä¢ Attempts to cover as many operating systems and platforms as possible, while not wanting to port and change at least part of the code <br>  ‚Ä¢ Dislike any code that targets only one platform. </blockquote><br><br><h4>  There is only Win32 </h4><br>  And vice versa - some programmers write software that will run only on the same OS as the author, moreover, we need the exact same mouse, keyboard and virtual reality helmet. <br><br>  Often the reason for this is simply that the programmer does not think that there are other operating systems and platforms besides those that he uses. <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ Rewrite all (or most) application code for each target OS / platform <br>  ‚Ä¢ Writing obviously hard-to-port code where it can be avoided <br>  ‚Ä¢ Using non-standard compiler / interpreter extensions </blockquote><br><br><h4>  Output </h4><blockquote>  ‚Ä¢ Carefully identify target OS / platform <br>  ‚Ä¢ Be prepared for the fact that for some OS / platforms you have to change part of the code or even write a separate version from scratch <br>  ‚Ä¢ Do not tie the code to one platform specifically <br>  ‚Ä¢ Try to cover multiple platforms if this complicates the development </blockquote><br><br><hr><h2>  Trap # 7: Protection </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c57/69a/35f/c5769a35f17c75e017a0ae1c9daaa81a.jpg"><br><br>  (Without) defensive programming is another great trap in which you will probably see yourself (present or past). <br><br><h4>  Defenseless programming </h4><br>  Defenseless programming is the opposite of defensive programming practice, it is the belief that the functions will always be passed the correct arguments that there are no side effects, or they will not affect the operation of the code, that the pointer will never be null, and similar things. <br><br>  Sometimes this is good, it makes the code free from many checks, but debugging such code is hell.  That is why it is a trap. <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ Fearlessness before overflowing, dividing by zero and rounding errors <br>  ‚Ä¢ Belief in absolute infallibility of standard and library functions / classes <br>  ‚Ä¢ Believing that the user will not make a mistake when entering <br>  ‚Ä¢ Belief that memory will never end <br>  ‚Ä¢ Belief that all configuration files necessary for an application exist and that they always have access </blockquote><br><br><h4>  Security programming </h4><br>  Millions of tests for obviously working parts of the application, 15 ASSERTs within each function, own library of exceptions, logging, attempts to drop the application with the slightest deviations. <br><br>  This is the other side of the coin - a defensive programming trap. <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ Each function in a project begins with an assertion bundle or excitation exception. <br>  ‚Ä¢ Tests cover absolutely all code, including third-party libraries. <br>  ‚Ä¢ The project has its own class MyProjectException and a complex hierarchy of at least 10 of its heirs, the meaning of which comes down to the message about invalid function arguments <br>  ‚Ä¢ Writing to the log most of what is happening with the application <br>  ‚Ä¢ Even small deviations are unacceptable for you and should drop the application with an error message and automatically send a bug report with a full memory dump. </blockquote><br><br><h4>  Output </h4><blockquote>  ‚Ä¢ Consider carefully what is worth checking and what is not. <br>  ‚Ä¢ Pay special attention to user input and external resources. <br>  ‚Ä¢ If possible, try using standard exception classes. <br>  ‚Ä¢ Do not try to check everything. <br>  ‚Ä¢ Separate critical errors from minor ones, allow the application to work further if nothing really terrible has happened <br>  ‚Ä¢ Log only the most important data in the log, implement the unobtrusive opportunity to send a bug report </blockquote><br><br><hr><h2>  Trap # 8: Putting it Forward </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/4fc/e0b/0c2/4fce0b0c2a113cb25353d9b5c571140b.jpg"><br><br>  The trap is quite interesting, because it is very difficult to find a balance in this issue. <br><br>  The essence of the trap is that often implementing any functionality, we put the marks - TODO, HACK, and some others. <br><br>  Realization of these tasks is delayed for oneself, rarely anyone remembers TODOshki and they remain unfinished for a long time. <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ Many TODO and HACK marks in the project and their number does not decrease <br>  ‚Ä¢ Code Review does not bring any results, except for the placement of new TODO and WTF <br>  ‚Ä¢ The inability to distract from the task being performed for a short time in order to implement an indirectly associated with it (instead of leaving TODO) or correct a detected error (instead of leaving FIX or HACK) </blockquote><br><br><h4>  Multitasking programmers </h4><br>  There are programmers who cannot switch over to the implementation of any part of the project to another, even if directly connected with it (say, write an exception class and throw it away, instead of marking ‚ÄúTODO: check argument to null‚Äù). <br><br>  And vice versa, there are programmers who can do this, I call such multitasking programmers, but the trouble is that there is no real multitasking and in fact they just quickly switch from one task to another. <br><br>  This has its plus - TODO and HACK are not put in the code, but are corrected immediately, errors found in another code are eliminated. <br><br>  And as usual, it is not given free of charge, as a result of a programmer switching too often, the programmer may forget about the original task or not have time to finish it, and when he returns to it again, do not remember which direction he was moving. <br><br>  If you like to quickly and often switch between different parts of a project, I have bad news for you. <br><br><h5>  Signs that you're trapped </h5><blockquote>  ‚Ä¢ You do not leave a single TODO for later to concentrate on the task <br>  ‚Ä¢ You switch so often that starting to implement one functional, you implement two completely unrelated features instead <br>  ‚Ä¢ When you are programming in pairs, the partner cannot keep up with your thoughts. </blockquote><br><br><h4>  Output </h4><blockquote>  ‚Ä¢ Before you postpone the task and put the TODO think, it can be implemented quickly <br>  ‚Ä¢ Do not be afraid to be distracted from the main task, but do not do it too often and for a long time. <br>  ‚Ä¢ Inspect the code, fix the errors found immediately <br>  ‚Ä¢ Postpone a large functionality that is not related to the current task - leave TODO <br>  ‚Ä¢ When programming in a pair, avoid switching in general, defer all extraneous tasks </blockquote><br><br><hr><h2>  Links </h2><br><br>  ‚Ä¢ <a href="http://alenacpp.blogspot.ru/2006/08/blog-post.html">AlenaC ++: Who actually owns the quote about premature optimization</a> <br>  ‚Ä¢ <a href="http://wordpresse.ru/articles/life/chto-takoe-zashhitnoe-programmirovanie/">Wordpresse: Security Programming</a> <br><br>  ‚Ä¢ <a href="http://habrahabr.ru/post/126818/">Habrahabr: Late optimization</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/88443/">Habrahabr: 5 stages of programmer incompetence</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/117365/">Habrahabr: These countless paradigms, concepts, tools and frameworks</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/218345/">Habrahabr: Analysis paralysis: you know too much to just write code</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/144611/">Habrahabr: Three key software principles that you must understand</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/133897/">Habrahabr: Cross-platform is cool</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/116020/">Habrahabr: Hardware cross-platform: is there a way out?</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/post/191548/">Habrahabr: Security Programming</a> <br><br>  ‚Ä¢ <a href="http://ru.wikipedia.org/wiki/KISS_(%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF)">Wikipedia: KISS</a> <br>  ‚Ä¢ <a href="http://ru.wikipedia.org/wiki/YAGNI">Wikipedia: YAGNY</a> <br>  ‚Ä¢ <a href="http://ru.wikipedia.org/wiki/DRY">Wikipedia: DRY</a> <br>  ‚Ä¢ <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D1%2584%25D0%25B5%25D0%25BA%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25B7%25D0%25BC_(%25D0%25BF%25D1%2581%25D0%25B8%25D1%2585%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%258F)">Wikipedia: Perfectionism</a> <br>  ‚Ä¢ <a href="http://ru.wikipedia.org/wiki/%25D0%2597%25D0%25BE%25D0%25BB%25D0%25BE%25D1%2582%25D0%25BE%25D0%25B9_%25D0%25BC%25D0%25BE%25D0%25BB%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA">Wikipedia: Golden Hammer</a> <br>  ‚Ä¢ <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25BA%25D1%2580%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">Wikipedia: Procrastination</a> <br><br><h2>  Instead of conclusion </h2><br>  Good luck to everyone walking on a rope! </div><p>Source: <a href="https://habr.com/ru/post/218603/">https://habr.com/ru/post/218603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../218593/index.html">Introduction of Stephen Wolfram to the Wolfram Language</a></li>
<li><a href="../218595/index.html">RuTracker does not work due to DDOS attack</a></li>
<li><a href="../218597/index.html">Build Systems - Local Repository</a></li>
<li><a href="../218599/index.html">Review of the transformer ASUS Transformer Book T300LA</a></li>
<li><a href="../218601/index.html">Review of the JPoint 2014 conference reports</a></li>
<li><a href="../218607/index.html">Portrait Habra-tutorial</a></li>
<li><a href="../218609/index.html">Critical vulnerability in OpenSSL 1.0.1 and 1.0.2-beta</a></li>
<li><a href="../218611/index.html">Iron sample for HD FPV *</a></li>
<li><a href="../218613/index.html">PVS-Studio and 3DO emulators</a></li>
<li><a href="../218617/index.html">The biggest Tetris in the world: playing on the wall of a skyscraper</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>