<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simplest C ++ Delegate</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C # there are delegates. There are delegates in python. There are delegates in javascript. In Java, there is a closure that performs their role. An...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simplest C ++ Delegate</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/c9f23293/764147f3/3b7a169f/ec3466e2.png" align="left" alt="logo">  In C # there are delegates.  There are delegates in python.  There are delegates in javascript.  In Java, there is a closure that performs their role.  And in C ++ there are no O_O delegates.  Many talented programmers successfully struggle with this shortcoming by developing and using sigslots, boost :: function and other valuable and necessary libraries.  Unfortunately, most implementations differ not only in the method of use, but also in the epic complexity of the patterned magic used.  In order to study the source code of boost :: function, the hair did not stand on end, I wrote this short article showing how to implement a delegate in C ++ in the simplest and most clumsy way.  The described implementation is illustrative, has many drawbacks and can hardly be used in serious projects - but it is as simple as possible and allows you to familiarize yourself with the subject area without disassembling the three-story sigslots templates :). <br><br><a name="habracut"></a><br><br><h1>  Why do you need it </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As practice shows, if a large program consists of a large number of small pieces that are as independent as possible from each other, the easier it is to develop, repair and change.  Modern object-oriented programming languages ‚Äã‚Äãoffer us objects as a piece - hence the name.  An object is usually an instance of a class that does something needed and useful.  You can make the whole program out of one ba-a-a-al-class - 'god object antipattern' - and in a couple of years making any change will turn into a curse of the sixth level.  And you can break the program into small classes, as independent as possible from each other classes, and then everyone will be dry and comfortable.  But breaking the program in this way raises the second question - how will these classes interact with each other?  Here the programmer comes to the aid of decomposition tools provided by the programming language.  The simplest means of decomposition in C ++ is to make classes global and directly call their methods.  The approach is not without flaws - it becomes increasingly difficult to understand who causes whom over time, and in a couple of years this approach will lead to the same consequences as the use of a single class.  An option approved by the Holy Inquisition is the transmission of pointers to classes to those classes with which they need to communicate.  Moreover, it is desirable that the pointers are not simple, but for interfaces - then changing and developing the program over time will become much easier. <br>  However, the interfaces are not a silver bullet (some say that such a bullet, like spoons, are not).  If an object needs only a few interactions, for example, a button must be notified that it has been clicked, then the implementation of a separate interface for these purposes will take a noticeable number of lines of code.  Also, interfaces do not solve the problem when one object needs to notify about several others - creating and maintaining a subscription list based on interfaces is also not the smallest number of lines of code. <br>  In dynamic programming languages, competition to interfaces is delegates.  As a rule, a delegate is very similar to a ‚Äúpointer to a function‚Äù in C ++, with the main difference being that a delegate can point to a method of an arbitrary object.  In terms of code, the use of a delegate usually looks like this: <br><img src="https://habrastorage.org/storage1/ac76a0c4/c15f43d9/856dd09c/8200d741.png" alt="delegate example"><br>  The same thing with the use of the interface illustrates the need and benefit of delegates: <br><img src="https://habrastorage.org/storage1/a324e3f2/e0c65717/b815b585/3a3da7e3.png" alt="interface example"><br><br><h1>  What should a C ++ delegate look like? </h1><br><br>  It should be something that can be associated with an arbitrary class method and then called as a function.  In C ++, this can only be done in the form of a class with an overloaded call operator (such classes are usually called functors).  In C #, the "+ =" operator is used to associate a delegate and a method, but unfortunately it is impossible in C ++ - the + = operator takes only one parameter, while a pointer to a function is a member of a class in C ++ with two parameters.  Therefore, using a C ++ delegate should look something like this: <br><img src="https://habrastorage.org/storage1/88a3541f/e0cb1e50/ea3867cc/2706f4b9.png" alt="delegate usage"><br><br><h1>  The simplest implementation for a single argument </h1><br><br>  Let's try to implement this behavior.  In order for a delegate to get a pointer to <b>any</b> method of <b>any</b> class, its own Connect () method must clearly be template.  Why not make the delegate template itself?  Because then you have to specify a specific class when creating a delegate, and this is contrary to the ability to associate a delegate with any class.  Also, the delegate must have an overloaded call operator, also a template one, so that it can be called with the same types of arguments as the method associated with it.  So, delegate stub will look like: <br><img src="https://habrastorage.org/storage1/74d8325a/e2087042/01d164d9/5c3afa63.png" alt="delegate skeleton"><br>  The Connect () method can be called with a pointer to a method of any class, and the call operator allows the delegate itself to be called with any argument.  Now all that needs to be done is to somehow save the pointer to the i_class class and the i_method method so that they can be used in the call operator.  Here the plug-in happens a number of times - the delegate himself doesn‚Äôt know about T and M, and he shouldn‚Äôt know, save them as fields will not work (these are arguments of the template method that can be called for different delegates many times with different classes and methods).  What to do?  You'll have to turn to a little template magic (believe me, these are spells of the first level compared to those used in boost: function).  The only way in C ++ to save template arguments is to create an instance of a template class that will be parameterized with these arguments, and, accordingly, will remember them.  Therefore, we need a template class that can remember T and M. And to save a pointer to this class, it must be inherited from an interface that does not have template parameters: <br><img src="https://habrastorage.org/storage1/275b4576/677e5b72/f038ca15/ae812a87.png" alt="delegate with container"><br>  In the first approximation, this is enough so that you can call Connect () for any method of any class and remember the arguments.  But remembering is half the battle.  The second half is to call the memorized method with the argument passed to us.  There is a certain complexity with the call - we saved the pointer to the class method as an IContainer interface - how can we call the class method with an arbitrary type parameter that the user passed to operator ()? <br><img src="https://habrastorage.org/storage1/3e6189c4/674808ac/455db70b/6f21024a.png" alt="argument pass problem"><br>  The easiest way is to remember the passed argument in the container just as we did for the pointer to the class method, pass the container with the argument ‚Äúinside‚Äù m_container, and then use dynamic_cast &lt;&gt; () to ‚Äútake out‚Äù the argument from the container.  It sounds scary, but the code is quite simple: <br><img src="https://habrastorage.org/storage1/147b4421/1ff7b9ad/0a0d804e/776580a4.png" alt="argument pass solution draft"><br>  The final problem on the way to a working delegate is to retrieve the argument from the container.  In order to do this you need to know the type of the argument.  But after all, inside the container that stores the pointer to the class method, we do not know the type of the argument?  The type of the argument is not known - but we know the signature of the method, the pointer to which we store.  Therefore, all we need to do is extract the type of the argument from the signature.  To do this, you must use the trick with a partial specialization of templates, described in my <a href="http://habrahabr.ru/blogs/cpp/54762/">article</a> .  It will look like this: <br><img src="https://habrastorage.org/storage1/897f33a3/727eb4b3/1477dc77/c39f879b.png" alt="argument pass trick"><br>  Actually, everything.  The resulting delegate stores a pointer to any method of any class and allows you to call it with the function call syntax. <br><br><h1>  Implementation for an arbitrary number of arguments </h1><br><br>  The implementation shown above has one drawback - it works only with methods that have exactly one argument.  And what if the method takes no arguments?  Or accepts two, and even three arguments?  The solution that is used for C ++ in boost, sigslots and Qt is quite simple: we copy the corresponding parts of the code for all supported cases.  Usually they do support from zero to four arguments, because if you need to pass more than four arguments when linking two objects, then we have something wrong with the architecture and probably we are trying to repeat the WinAPI feat CreateWindow () O_O.  The finished implementation code with support for up to two arguments and an example of use is presented below.  I remind you that it is illustrative and greatly simplified.  Many checks are missing, variable names are sacrificed in favor of compactness, and so forth, so on.  For production, it's better to use something like boost :: function :) <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;assert.h&gt; //     2- . struct NIL {}; class IArguments { public: virtual ~IArguments() {} }; template&lt; class T1 = NIL, class T2 = NIL &gt; class Arguments : public IArguments { public: Arguments() {} public: Arguments( T1 i_arg1 ) : arg1( i_arg1 ) {} public: Arguments( T1 i_arg1, T2 i_arg2 ) : arg1( i_arg1 ), arg2( i_arg2 ) {} public: T1 arg1; T2 arg2; }; //      . class IContainer { public: virtual void Call( IArguments* ) = 0; }; template&lt; class T, class M &gt; class Container : public IContainer {}; //     . template&lt; class T &gt; class Container&lt; T, void (T::*)(void) &gt; : public IContainer { typedef void (T::*M)(void); public: Container( T* c, M m ) : m_class( c ), m_method( m ) {} private: T* m_class; M m_method; public: void Call( IArguments* i_args ) { (m_class-&gt;*m_method)(); } }; //      . template&lt; class T, class A1 &gt; class Container&lt; T, void (T::*)(A1) &gt; : public IContainer { typedef void (T::*M)(A1); typedef Arguments&lt;A1&gt; A; public: Container( T* c, M m ) : m_class( c ), m_method( m ) {} private: T* m_class; M m_method; public: void Call( IArguments* i_args ) { A* a = dynamic_cast&lt; A* &gt;( i_args ); assert( a ); if( a ) (m_class-&gt;*m_method)( a-&gt;arg1 ); } }; //       template&lt; class T, class A1, class A2 &gt; class Container&lt; T, void (T::*)(A1,A2) &gt; : public IContainer { typedef void (T::*M)(A1,A2); typedef Arguments&lt;A1,A2&gt; A; public: Container( T* c, M m ) : m_class( c ), m_method( m ) {} private: T* m_class; M m_method; public: void Call( IArguments* i_args ) { A* a = dynamic_cast&lt; A* &gt;( i_args ); assert( a ); if( a ) (m_class-&gt;*m_method)( a-&gt;arg1, a-&gt;arg2 ); } }; //  . class Delegate { public: Delegate() : m_container( 0 ) {} ~Delegate() { if( m_container ) delete m_container; } template&lt; class T, class U &gt; void Connect( T* i_class, U i_method ) { if( m_container ) delete m_container; m_container = new Container&lt; T, U &gt;( i_class, i_method ); } void operator()() { m_container-&gt;Call( &amp; Arguments&lt;&gt;() ); } template&lt; class T1 &gt; void operator()( T1 i_arg1 ) { m_container-&gt;Call( &amp; Arguments&lt; T1 &gt;( i_arg1 ) ); } template&lt; class T1, class T2 &gt; void operator()( T1 i_arg1, T2 i_arg2 ) { m_container-&gt;Call( &amp; Arguments&lt; T1, T2 &gt;( i_arg1, i_arg2 ) ); } private: IContainer* m_container; }; class Victim { public: void Foo() {} void Bar( int ) {} }; int main() { Victim test_class; Delegate test_delegate; test_delegate.Connect( &amp; test_class, &amp; Victim::Foo ); test_delegate(); test_delegate.Connect( &amp; test_class, &amp; Victim::Bar ); test_delegate( 10 ); return 0; }</span></span></span></span></code> </pre> <br><br></div><p>Source: <a href="https://habr.com/ru/post/78299/">https://habr.com/ru/post/78299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../78292/index.html">Essay competition in English with real prizes!</a></li>
<li><a href="../78294/index.html">Warranty for ASUS laptops. Subtle moments</a></li>
<li><a href="../78295/index.html">Topics of the WebHiTech and WHT Party in Moscow</a></li>
<li><a href="../78297/index.html">Is it possible for 0 rubles at the start and 20 thousand rubles a month to license the server software and update the corporate server park, and also to raise the hosting? I did!</a></li>
<li><a href="../78298/index.html">Will the gosuslugi.ru site open today?</a></li>
<li><a href="../78301/index.html">Send Java / Python SDKs 1.3.0</a></li>
<li><a href="../78302/index.html">jQuery SVG plugin</a></li>
<li><a href="../78304/index.html">Bash scripting is easy</a></li>
<li><a href="../78305/index.html">Long live Electronic Russia! ..</a></li>
<li><a href="../78307/index.html">The results of the contest "The best free project of Russia"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>