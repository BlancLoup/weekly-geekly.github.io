<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I wrote the rainy map</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the wake of a recent publication about working with meteorological maps, I decided to write about my own similar experience. 

 Somewhere at the en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I wrote the rainy map</h1><div class="post__text post__text-html js-mediator-article">  In the wake of a <a href="http://habrahabr.ru/post/266303/">recent publication</a> about working with meteorological maps, I decided to write about my own similar experience. <br><br>  Somewhere at the end of May, once again figuring out whether a thunderstorm from the clouds outside the window gathered, I thought: even if they put on meteorological radar, which they bypass thunderstorms, are there really no similar stationary radar?  And if they are, aren't images available on the Internet? <br><br>  Not the fastest search on the Internet has shown that such radars exist, they are called DMRL (Doppler meteorological radar), and pictures from them are really exposed on the Internet.  There is a Russian site <a href="http://meteorad.ru/">meteorad.ru</a> , Belarusian <a href="http://meteoinfo.by/">meteoinfo.by</a> (although it is not available from Russia, not from Russia, see the drop-down menu on the left), and there is also a site <a href="http://orm.mipt.ru/">orm.mipt.ru.</a>  At the same time, the most pleasant pictures are on meteorad. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I soon realized that the meteorological radius lacked three things: a good cartographic substrate, history over the past few hours, and combining images from several radars.  On some other site I found a map with this functionality, but there wasn‚Äôt the Nizhny Novgorod radar I was most interested in.  Well, it means that you need to make such a card yourself. <br><br><a name="habracut"></a>  Well, let's get started.  <a href="https://github.com/petr-kalinin/radarmap/">GitHab</a> for those who (suddenly?) <a href="https://github.com/petr-kalinin/radarmap/">Want</a> to keep track of the story in more detail than what I am describing here. <br><br>  A typical picture from the meteorological attack looked like this at the time: <br><div class="spoiler">  <b class="spoiler_title">Big pictures under the spoiler, so as not to break the text</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/ec3/973/ba6/ec3973ba674ccf95c631024998b7214f.png" alt="Nizhny Novgorod radar"><br></div></div><br><br>  To begin with, let's just take this type of image from the meteoric radius, cut it off and, without deleting the background, try to apply OSM to the map substrate.  Fortunately, I most likely know exactly where the Nizhny Novgorod radar is located.  I took OpenLayers as a framework, set it up, selected the size of the image so that the cities marked on the radar more or less coincided ... but still the cities, roads and rivers marked on the radar map do not match well with the OSM substrate. <br><br>  Well, maybe the radar background map is not very good?  Here is the Kostroma radar <br><div class="spoiler">  <b class="spoiler_title">picture</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/e5a/27c/cd2/e5a27ccd2d3a08274a0bb10c9ba4b9d8.png" alt="Kostroma radar"><br></div></div><br>  If you look closely at the fine details of the background map, you can see that, most likely, on both radars there is a map from the same source: all the bends of all the lines are the same, etc.  Let's try to align two pictures from the radar? <br><br>  Well, somehow I tried to align the Kostroma and Nizhny Novgorod radars relative to each other.  Here is the <a href="http://radarmap.info/a66dc7f4502cf5dd77165d37e05563f90a860262/main.html">status of the project at that time</a> : <br><div class="spoiler">  <b class="spoiler_title">screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/025/89e/ec6/02589eec6ae4488d90903f9e367f0a0b.png"><br></div></div><br><br>  It can be seen that, although the Vladimir ‚Äì Vyazniki section leveled more or less well (two radars relative to each other, rather than the OSM substrate), the alignment of the remaining sections leaves much to be desired.  Of course, it is possible to align and a little better, but all the same - in different places the alignment error vector is clearly different, so perfect alignment will not work.  Moreover, it can be seen that the alignment error is substantially larger than the pixel size of the rain, so you really want to align better. <br><br>  Actually, the cause of the problems is obvious: hardly on meteorad use the same projection of the Web Mercator, as in OSM and OpenLayers, but what kind of projection on meteorad is not very clear.  Of course, the first thing that comes to mind is an equidistant azimuthal projection ‚Äî it is in this projection that the radar ‚Äúsees‚Äù the terrain (the radar knows the direction and distance from which the signal came ‚Äî if we draw a point corresponding to this signal in polar coordinates, it is at this polar angle and at a proportional distance, this will be an equidistant azimuthal projection.) <br><br>  I didn‚Äôt have exact confidence in this (especially in <i>equilibrium</i> ), but comrade advised a simple test: to compare the sections along the straight line NN ‚Äî Kostroma cut from Nizhny Novgorod and Kostroma radars.  HH ‚Äî Kostroma lines were almost equal in length, and all the objects lying on this line (intersections with rivers and borders) were also in the same place on both radars;  all this clearly spoke in favor of equidistantness.  A little later on the meteorad website I found a separate document describing the operation of radars, and there it was also said that the projection of the final images is an equidistant azimuth. <br><br>  Well, we will assume that we found out.  At the same time, the same comrade advised me to use hugin to stitch pictures from different radars.  I tried.  Yes, it stitches well, but it‚Äôs unclear how to lay OSM on the substrate.  Therefore, I decided that it would be better to sort out the projections and convert honestly. <br><br>  Well, you need to be able to translate a picture from one projection to another.  A quick search in Google, to some of my surprise, did not provide any ready-made tools for conversion.  (Later, in the comments to the post from <a href="http://habrahabr.ru/users/alexkuku/" class="user_link">alexkuku,</a> GDAL was advised to me - although not to say that it‚Äôs easy to understand from their website how to convert images between projections.) Ok, it‚Äôs not so difficult to translate pictures manually, since the library can translate <i>individual coordinates</i> quite to themselves are.  Picked up the scale, determining the coordinates of a number of cities on the Nizhny Novgorod radar (although I could not perfectly reproduce these coordinates using the same scale.) I wrote a simple python conversion script using pyproj, converted it, everything became noticeably better. <br><br>  True, the question of the location of the radar in Kostroma has now become significantly more important, especially since it is necessary to know this not only for the final placement of the picture on the map, but also for conversion (although in the latter case, the error due to the wrong center is probably less).  A quick Google on ‚ÄúDRL Kostroma‚Äù reports that the radar is actually called Sokerkino, and this is a small village at the southern end of Kostroma airport.  (And yes, of course, the airport itself is also called Sokerkino, and the radar is rather named after the airport, not the village, but I realized this only much later. At OSM there is a village name, but there is no airport name, so I found only one object with this name - the village.) I substituted the coordinates of the village as the coordinates of the radar, did the conversion, slightly corrected the coordinates and at the same time the scale - oh, everything became much better! <br><br>  <a href="http://radarmap.info/75f9e76a61e06b2a8f7c0e2416c6ef1ad81b54a8/main.html">Version of the project at that time</a> and <br><div class="spoiler">  <b class="spoiler_title">screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/f9d/3db/bdd/f9d3dbbdd17745c2816b3ed918788401.png"><br></div></div><br><br>  It can be seen that the coincidence of the images from the two radars is very good, the errors are clearly smaller than the size of the pixel of the rain, so the errors can be neglected.  The coincidence with the background substrate is also very good, although it leaves much to be desired in places (especially noticeable on Vyazniki, Ivanovo and Semenov). <br><br>  In fact, the discrepancy is even brighter in Vologda: <br><div class="spoiler"> <b class="spoiler_title">Vologda district on a very large scale</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/956/25c/38d/95625c38dcf3472189fa251b5e145a56.png"><br></div></div><br>  ... and the reason is immediately visible: the <i>roads</i> coincide relatively well, only Vologda itself does not coincide.  But at the same time, on OSM, Vologda is located south of the M-8 highway, and on the map from the radar - to the north!  Clear card error with radar.  Therefore, apparently, all the remaining errors will have to be attributed to the errors of the maps from the radar, and to conclude that it is not possible to superimpose the maps from the radars to OSM because of the inaccuracy of the first ones.  It is possible that on the map from the radar there are not cities, but, for example, meteorological stations, which may be a little apart.  (Actually, maybe because some cities are marked with triangles, and some - by circles?) <br><br>  Great, let's add the Moscow radar as well to check that everything is aligned well with us.  The radar is called ‚ÄúProfsoyuznaya‚Äù, and I even seemed to find on the Internet information about exactly which house on ul.  The trade union is worth the radar, but still had to slightly move the center to get a reasonable alignment with other radars. <br><br>  <a href="http://radarmap.info/3c6c3974bc79e5e0bb209c770bf0e4ab59f65d5e/main.html">New version</a> and <br><div class="spoiler">  <b class="spoiler_title">screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/8f8/8c6/a02/8f88c6a022ca441ebfa1f86d91686393.png"><br></div></div><br>  The match is very good, further confirms that we are doing everything correctly. <br><br>  That's just a converter on python works for a long time.  30 seconds to convert one image is too much.  At first I was very surprised, I thought that the main bottleneck is directly recalculating the coordinates, a few cosines-sines-what-else-there to a point, and it‚Äôs unlikely the speed of this depends on the programming language.  But ok, I rewrote everything in C ++ (with OpenCV for working with pictures), now converting one picture takes a couple of seconds. <br><br>  ... It would seem that little remains: to remove the background from the pictures - and you can use.  It seemed so until the moment when I suddenly discovered that my alignment of Moscow had suddenly moved. <br><br>  How so?  Here you saw on the pictures displayed on meteorad (see examples at the beginning of the post), scroll bars.  And then one day I discovered that the image from the Moscow radar had shifted vertically.  As if the pictures on meteorad are real <i>screenshots</i> from some computer, and someone came up to this computer and moved the scroll bar. <br><br>  Well, we will detect the center of the picture.  Naturally, I did not want to be attached to any features of the background map;  I wanted to come up with a method that will easily work for all radars at once.  I implemented the following approach: the image has gray grid bars.  The vertical center is on one of these horizontal stripes, it remains to determine which one.  To do this, we have a dark gray background outside the radar's visibility range.  The closer to the present center, the less this dark gray on each particular horizontal.  Therefore, from all the strips of the grid, choose the one around which the horizontal (plus or minus 50 pixels in height) is the least dark external background.  Hooray, it works.  Since there is a horizontal scroll bar on the picture, we will implement the same approach for detecting the vertical on which the center is located. <br><br>  Go ahead.  Now you can write a script that regularly pulls out new images from the meteorological radar.  Every minute we will poll the site, download the picture and, if it has changed, then convert it.  As experience has shown, new pictures appear around: 07,: 17,: 27, ...,: 57 minutes of each hour - well, plus or minus a minute.  (On the pictures themselves, in the right upper corner, the time is indicated, I even thought that it was possible to parse it to determine at what time this or that picture exactly belongs, but my hands never reached this point. So, this time is always a multiple of 10 minutes and 6-7 minutes less than the time of putting pictures.) <br><br>  Now, so that it can somehow be used, we will remove the background from the pictures.  To begin with, I wrote a very simple method: all light gray pixels of the internal background and all dark gray pixels of the external background are changed to transparent ones;  at the same time we add the bounds of the radar field of view - to those pixels in the vicinity of which there is both an internal and external background.  The grid and the names of the cities remain, but in principle, what turned out can already be used. <br><br>  All is well, but green clouds are lost on MapQuest's green background.  The idea: make a black and white OSM layer.  I don‚Äôt want to raise my own tile-server (although still the project is already tied to proj and opencv for working with pictures, so it will only work on vps).  Looking for some standard black and white layer, I find nothing.  Apparently, earlier there was a black-and-white Mapnik, but now it does not work.  I find a number of options with OpenMapSurfer or CartoDB, but they do not really suit me. <br><br>  At the same time I discover that with OpenLayers you can set the layer's value to saturation.  I set to zero - nothing changes.  By experimenting, I establish that saturation only works if OpenLayers is switched to webgl mode, and this does not work in many browsers, and in many others it slows down.  Sorry.  In general, I played with different options and so far I returned the color MapQuest. <br><br>  Somewhere here I buy a simple vps and post the project to the network.  While available only through direct ip, I didn‚Äôt want to buy a domain right away.  At the same time I am writing a letter to the administrators of the site meteorad.ru (according to the only email found on the site) asking if their pictures can be used as follows.  I never received an answer, but now my conscience is constantly bothering me: was this letter the cause of all subsequent events, namely, the closure of access to real-time data?  I thought whether they should write or not, understanding that if they write, they can be banned, and if they don‚Äôt write, they may not notice, but decency still overpowered and I wrote. <br><br>  I make a more advanced version of removing the background - namely, now I replace all pixels with transparent pixels that are not in the list of symbols for rains.  This is a fairly obvious option, but there is one problem: black.  Black is used for two things at once: for signatures of cities and for designating winds.  The winds are shown both as small black ‚Äúticks‚Äù in the clouds, and as large black lines protruding from the centers of the radar.  Information about the wind really want to save, without it it is not clear where to expect the movement of clouds.  (I plan to animate the story, but I still want to leave the wind direction.) <br><br>  Here is a simple approach so easy to imagine.  I decided to do this: I take several images from the same radar, but from different days, and leave those pixels that are the same on all the images (the benefit of the city names are applied on top of the precipitation) - I get what I called the ‚Äútemplate‚Äù.  This will be primarily the names of cities, because  the winds will have time to change.  Accordingly, now, when I process the next image and stumble upon a black pixel, I can look at the template and, if there is also a black pixel, then I need to remove this black pixel from the image, otherwise it is the wind - it should be left. <br><br>  I had to tinker a little more to defeat anti-aliasing effects in city signatures (not all pixels are actually black there).  I have no final pictures left, but below will be a rough idea of ‚Äã‚Äãwhat happened at this stage. <br><br>  In the meantime, I am still not satisfied with any variants of the OSM substrate, which I find.  I decide to make a ‚Äúproxying‚Äù tile-server: at the request of a specific box, it will download the same box from some public server, convert it to black and white, and give it to the user.  From a variety of publicly accessible servers, I chose <a href="http://xn--e1aaps0bc.net/">chepetsk.net</a> for the fact that the map is sufficiently detailed even on a small scale.  I wrote a simple proxying script, plus it turned out that simply translating to black and white is bad, you need to lower the contrast and lighten it.  As a result, I stopped at a simple formula: the color of the new pixel is <pre><code class="hljs">(255*2+(r+g+b)/3)/3</code> </pre>  Where <pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">r</span></span>, g, b)</code> </pre>  - the color of the old pixel. <br><br>  <a href="http://radarmap.info/3b89564c45398c6d8fc3e651f63c6c80f219e2b7/index.html">The current result</a> (artifacts from anti-aliasing city signatures have not been completely cleaned here): <br><div class="spoiler">  <b class="spoiler_title">screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/bb0/dd5/1cc/bb0dd51ccc6448f1ba80149ada7efc04.png"><br></div></div><br><br>  Next is easier.  Let's do an auto-update: the download script writes information about new pictures to a json file, the javascript on the client side checks every 10 seconds if new pictures appear in this file.  So far, for simplicity, I did not bind to any database.  In the same json now there is information about all the pictures ever downloaded, so there is no problem to make the story play.  A little fiddling with JS, did.  True, the loading of pictures slows down, so I had to make the client cache them first. <br><br>  (Yes, at this point in json I had information about <i>all the</i> pictures I had ever downloaded, and all those pictures were stored on the disk. I was afraid that the place would quickly end, and json would grow to incredible sizes, but in a couple of months everything was still reasonable. Then, of course, it would be necessary to switch to the database and delete old records and pictures.) <br><br>  There was one more problem: from time to time the individual pictures on the meteorade ceased to be updated.  The update was restored after a few hours, sometimes up to a day, during all this time my download script saw that the picture had not changed, and I thought that everything was in order.  As a result, the last available picture was displayed on the map.  I thought to do something about it - not to display pictures of age more than an hour or the like.  - but so the hands did not reach. <br><br>  The entertainment continued.  On another day, I found that the pictures on my site are not updated, although everything works on the meteo-weather.  It turned out that they decided to change the format of the images on the meteorade: from 32-bit PNG to 8-bit palette.  And for some reason, the standard imread () from OpenCV refused to open such pictures.  Googled a bit how to load palette pictures in OpenCV, didn‚Äôt find anything sensible and decided: since I have everything on vps, you can simply find some command line utility in Linux that translates from 8-bit palette png to 32-bit , and run it before running the actual conversion.  He did.  At the same time, another problem emerged: now, firstly, the colors on the meteorating floated on the pictures and the colors had to be compared not for an exact match, but for a small difference of components;  secondly, in places where roads overlap with the names of cities, due to anti-aliasing (and, apparently, due to the forced formation of a palette), the color sometimes coincided with one of the colors for hail, so the method ‚Äúthrow out all colors, Not coinciding with the colors for precipitation "began to give errors.  I added a special check: if a pixel of a picture has such a ‚Äúbad‚Äù color of hail, and in a ‚Äútemplate‚Äù there is a similar color, then we consider this as a pixel of the road and also throw it out. <br><br>  Around the same days, I discovered that on the Moscow radar, not only does the scroll bar move someone, but sometimes it changes the zoom.  (For some reason, this was not observed on other radars.) At first, the Moscow radar was heavily speculated, and then it was a few days later.  The hypothetical variant spoiled everything in general, even the detection of the center did not work, since  there was no dark gray external background in the picture, but on the stunned version the center was detected more or less, but it is still clear that the binding did not work correctly.  I quickly corrected the dumbfounded version: I already detected grid lines to determine the center, it remains to look at the distance between these bands and compare it with the reference one.  With the primed version, the problem of detecting the center remained, and I did not do anything with it;  but, in principle, not so scary, because  all the same, on the primed version, a substantial part of the information is lost without getting into the field of visibility, so there is little use in processing the primed image. <br><br>  The converter code has already grown pretty big, I had to break it into several files and three classes: for detecting the center and trimming, for removing the background and for translating the projection.  Already even thinking about creating testsuite for the converter. <br><br>  And only I did it, as everything stopped working again.  It turned out that at the meteo-radar they once again redid the format of the pictures, and now the substrate map and the actual precipitation image were spread with different files, and only on the html-page directly did one picture be displayed on top of another. <br><br>  A bunch of code immediately became unnecessary.  Detect the center and zoom is no longer necessary: ‚Äã‚Äãapparently, they began to upload images directly generated by the program, and not screenshots.  Removing the background was the simplest - there was no grid or city names anymore, all that was needed was to remove the light gray internal background and remove everything outside the circumference of a fixed radius (there was a dark gray external background and additional signatures).  The conversion of the projection has remained;  in fact, even a bit complicated, because  I wanted to make the code universal for two options: so that it was possible to convert both the rain picture (for real work) and the substrate map (to check the correctness of the binding), but these two pictures were of different sizes - I had to add a simple accounting for the size of the original picture. <br><br>  It all worked, just too suspicious: not a single cloud on all three radars, not only in the converted pictures, but also on the initial meteorological radar.  But at that time there was really sunny weather in Nizhny without a single rain, and I was ready to believe that there really were no rains within these three radars.  Especially since on some other radars on the meteo-rain the rains drew normally. <br><br>  But one friend wrote to me that there are constant rains in Moscow, but they are not on the radar.  And on the original images on the meteorates either.  We looked at it in more detail and found that part of the radar is clearly not working: the wind speed of 0 m / s is written on them.  At the same time, they suddenly found out that on the site of the meteorological inscription appeared an inscription that the cards are provided with a delay of 24 hours. <br><br>  Hmm.  Non-working radar recovered during the day - apparently, they were transferred to a 24-hour delay.  But the data is really very similar that they go with a delay of 24 hours, and this is not very interesting;  I immediately got rid of the link to the discussion of this delay on vkontakte.  I wrote an appeal to Roshydromet, and at the same time I began to think from where I would receive the pictures, if not from the meteorological equipment.  In the vkontakte discussion, there was a link to the Kazan radar on the Kazan hydromet website, but this is not so interesting to me - I was primarily interested in the Nizhny Novgorod and Kostroma radars.  No similar picture was found on the site of the Nizhny Novgorod hydromet. <br><br>  Then I remembered the second site, which had long been found - <a href="http://meteoinfo.by/">meteoinfo.by</a> .  There, of course, the spatial resolution of the images was clearly worse, but at least something.  And they also explicitly authorized the use of information on other sites on the site in the "Regulations on the procedure for the use of information", provided that they were referred to.  So I just redid the code to work with the Belarusian site.  Of course, their pictures are blocked for Russia, but my vps is not in Russia, so everything opens from it.  True, it was not so easy to bind, but in the end I decided that their background map was even worse than on the meteoric;  for example, the relative position of Nizhny Novgorod relative to the Volga on the maps of the Nizhny Novgorod and Kostroma radars was different. <br><br>  Everything worked for several days, after which Belarusians began <a href="">sending</a> my redirect to <a href="">meteoinfo.by/radar/no_radar.gif</a> specifically to my download script.  In the picture there was an inscription ‚ÄúWe considered that we should limit access to our radar maps‚Äù - and the email of the site administrator.  Well, I wrote to them, indicating that I comply with the requirements of the "Regulations on the procedure for the use of information."  Got a response: <br><br><blockquote>  For information from the Russian radar you need to contact Roshydromet. <br>  Belarusian radars use without restrictions. <br>  Disconnected due to the fact that not to wipe relations with Roshydromet. <br></blockquote><br><br>  Well, here, apparently, and all at the moment.  From Roshydromet I received an answer completely analogous to the fact that other people posted in the comments to the previous entry, in short: ‚Äúwe are not obliged to publish this data, therefore only for individual consumers and for a fee‚Äù.  (Although it is worth noting Rosgidromet's unexpected promptness: the answer came two weeks after the appeal, I expected it to be over a month.) I wrote on data.gov.ru, but so far there is no result. <br><br>  Therefore, I suggest that anyone who is interested in these pictures write both in Roshydromet and on data.gov.ru - all this can be done (if someone suddenly doesn‚Äôt know) via the Internet, maybe some kind of result will be obtained. <br><br>  And yes, the penultimate version of the site, using data from the meteorological report, but with a delay of 24 hours: <a href="http://radarmap.info/">radarmap.info</a> .  Pictures continue to be pumped out, i.e.  now there is real data 24 hours ago.  In the upper right corner there is a button for playing the story. <br><div class="spoiler">  <b class="spoiler_title">screenshot</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/412/d9c/fe6/412d9cfe6889493381f1228c1170503a.png"><br></div></div><br><hr><br>  PS In the discussion of the previous publication, and even earlier, when I told people about this project, I was confronted with the opinion ‚Äúwhy all this is necessary, because there are so many services that provide a cloud and rain map?‚Äù My answer to this question is as follows.  These services are based on the <i>forecast</i> and therefore have a number of <br><div class="spoiler">  <b class="spoiler_title">fundamental flaws</b> <div class="spoiler_text">  First of all, these services do not distinguish the rain from a rainstorm, from a thunderstorm, or hail with a squall.  Of course, the amount of precipitation allows us to understand the intensity of rain, but not nearly so accurately. <br><br>  Secondly, these services have a rather low spatial resolution (tens of kilometers), while radars give a resolution of a few kilometers.  (My personal understanding of the reason, I can be mistaken - now there is simply no power for forecasting for the entire planet with high resolution.) As a result, images from the radar allow you to see which part of the Lower is covered with rain, and forecasts are not. <br><br>  Thirdly, although the forecasts give a good time resolution, but the model itself is usually recalculated units once a day, i.e.  even if you look at the data for the current time, on average, 3-6 hours old data were used as the initial data for the forecast.  Thunderstorms in summer develop on comparable time scales. <br><br>  Finally, due to the low spatial resolution and high temporal resolution;  in my opinion, the benefit from such cards is not much higher than from the standard ‚Äúhourly‚Äù (actually, 3-hour) forecast for gismeteo.  Well, yes, in the morning rain, to 12 o'clock dispel.  But not in more detail. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/266453/">https://habr.com/ru/post/266453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266437/index.html">Says Gartner: Overheated IoT and Practical Clouds</a></li>
<li><a href="../266441/index.html">Assistant program for mastering blind typing on a keyboard in Linux</a></li>
<li><a href="../266443/index.html">How do closures (under the hood) in JavaScript</a></li>
<li><a href="../266447/index.html">LinkedIn's brief history of scaling</a></li>
<li><a href="../266449/index.html">A little about the implementation of the puzzle "Soma Cubes" (Swift & SceneKit)</a></li>
<li><a href="../266455/index.html">Backstage at CyberSoft</a></li>
<li><a href="../266457/index.html">Making a Real Forex Robot Idea</a></li>
<li><a href="../266459/index.html">Old new pywinauto: automate Windows GUI in Python with install / uninstall example</a></li>
<li><a href="../266461/index.html">Adaptive scaling: design of online stores for large screens</a></li>
<li><a href="../266463/index.html">Sophos UTM Web Access Organization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>