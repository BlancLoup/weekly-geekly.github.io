<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a system of placing objects by level using the blueprint editor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, my name is Dmitry. I create computer games on the Unreal Engine as a hobby. For my project, I am developing a procedurally generated level. My ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a system of placing objects by level using the blueprint editor</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/0d5/f4a/c99/0d5f4ac99ea848be93896fdae0531fce.png" alt="image"><br><br>  Hello, my name is Dmitry.  I create computer games on the Unreal Engine as a hobby.  For my project, I am developing a procedurally generated level.  My algorithm puts points in space in a certain order (which I call the roots ‚Äúroots‚Äù), after which I attach meshes to these points.  But here there is a problem in that you need to attach the mesh from the beginning, then compile the project, and after that you can see how it got up.  It is natural to constantly run from the editor window to the VS window for a very long time.  And I thought that it would be possible for this to use the blueprint editor, the more I caught the eye of the Dungeon architect plugin, in which the placement of objects by level is implemented via blueprint.  Actually here I will talk about the creation of such a system, a screenshot of which is shown in the first picture. <br><a name="habracut"></a><br><br>  So from the beginning we will create our own file type (you can see this <a href="https://habrahabr.ru/post/274159/">article in</a> more detail).  In the AssetAction class, we override the OpenAssetEditor function. <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FMyObjectAssetAction::OpenAssetEditor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TArray&lt;UObject*&gt;&amp; InObjects, TSharedPtr&lt;class IToolkitHost&gt; EditWithinLevelEditor) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EToolkitMode::Type Mode = EditWithinLevelEditor.IsValid() ? EToolkitMode::WorldCentric : EToolkitMode::Standalone; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ObjIt = InObjects.CreateConstIterator(); ObjIt; ++ObjIt) { UMyObject* PropData = Cast&lt;UMyObject&gt;(*ObjIt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PropData) { TSharedRef&lt;FCustAssetEditor&gt; NewCustEditor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FCustAssetEditor()); NewCustEditor-&gt;InitCustAssetEditor(Mode, EditWithinLevelEditor, PropData); } } }</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now, if we try to open this file, it will open not the usual window, but the window that we define in the class FCustAssetEditor. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FCustAssetEditor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FAssetEditorToolkit, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FNotifyHook { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~FCustAssetEditor(); <span class="hljs-comment"><span class="hljs-comment">// IToolkit interface virtual void RegisterTabSpawners(const TSharedRef&lt;class FTabManager&gt;&amp; TabManager) override; virtual void UnregisterTabSpawners(const TSharedRef&lt;class FTabManager&gt;&amp; TabManager) override; // FAssetEditorToolkit virtual FName GetToolkitFName() const override; virtual FText GetBaseToolkitName() const override; virtual FLinearColor GetWorldCentricTabColorScale() const override; virtual FString GetWorldCentricTabPrefix() const override; void InitCustAssetEditor(const EToolkitMode::Type Mode, const TSharedPtr&lt; class IToolkitHost &gt;&amp; InitToolkitHost, UMyObject* PropData); int N; protected: void OnGraphChanged(const FEdGraphEditAction&amp; Action); void SelectAllNodes(); bool CanSelectAllNodes() const; void DeleteSelectedNodes(); bool CanDeleteNode(class UEdGraphNode* Node); bool CanDeleteNodes() const; void DeleteNodes(const TArray&lt;class UEdGraphNode*&gt;&amp; NodesToDelete); void CopySelectedNodes(); bool CanCopyNodes() const; void PasteNodes(); void PasteNodesHere(const FVector2D&amp; Location); bool CanPasteNodes() const; void CutSelectedNodes(); bool CanCutNodes() const; void DuplicateNodes(); bool CanDuplicateNodes() const; void DeleteSelectedDuplicatableNodes(); /** Called when the selection changes in the GraphEditor */ void OnSelectedNodesChanged(const TSet&lt;class UObject*&gt;&amp; NewSelection); /** Called when a node is double clicked */ void OnNodeDoubleClicked(class UEdGraphNode* Node); void ShowMessage(); TSharedRef&lt;class SGraphEditor&gt; CreateGraphEditorWidget(UEdGraph* InGraph); TSharedPtr&lt;SGraphEditor&gt; GraphEditor; TSharedPtr&lt;FUICommandList&gt; GraphEditorCommands; TSharedPtr&lt;IDetailsView&gt; PropertyEditor; UMyObject* PropBeingEdited; TSharedRef&lt;SDockTab&gt; SpawnTab_Viewport(const FSpawnTabArgs&amp; Args); TSharedRef&lt;SDockTab&gt; SpawnTab_Details(const FSpawnTabArgs&amp; Args); FDelegateHandle OnGraphChangedDelegateHandle; TSharedPtr&lt;FExtender&gt; ToolbarExtender; TSharedPtr&lt;FUICommandList&gt; MyToolBarCommands; bool bGraphStateChanged; void AddToolbarExtension(FToolBarBuilder &amp;builder); };</span></span></code> </pre><br>  The most important method for us of this class is InitCustAssetEditor.  First, this method creates a new editor about which below, then it creates two new empty tabs: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TSharedRef&lt;FTabManager::FLayout&gt; StandaloneDefaultLayout = FTabManager::NewLayout(<span class="hljs-string"><span class="hljs-string">"CustomEditor_Layout"</span></span>) -&gt;AddArea ( FTabManager::NewPrimaryArea() -&gt;SetOrientation(Orient_Vertical) -&gt;Split ( FTabManager::NewStack() -&gt;SetSizeCoefficient(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>) -&gt;SetHideTabWell(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) -&gt;AddTab(GetToolbarTabId(), ETabState::OpenedTab) ) -&gt;Split ( FTabManager::NewSplitter() -&gt;SetOrientation(Orient_Horizontal) -&gt;SetSizeCoefficient(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>) -&gt;Split ( FTabManager::NewStack() -&gt;SetSizeCoefficient(<span class="hljs-number"><span class="hljs-number">0.8f</span></span>) -&gt;SetHideTabWell(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) -&gt;AddTab(FCustomEditorTabs::ViewportID, ETabState::OpenedTab) ) -&gt;Split ( FTabManager::NewStack() -&gt;SetSizeCoefficient(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>) -&gt;SetHideTabWell(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) -&gt;AddTab(FCustomEditorTabs::DetailsID, ETabState::OpenedTab) ) ) );</code> </pre><br>  One of these tabs will be the tab of our blueprint editor, and the second is needed to display the properties of the nodes.  The actual tabs created need to fill them with something.  Fills tabs with the contents of the RegisterTabSpawners method <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FCustAssetEditor::RegisterTabSpawners(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TSharedRef&lt;class FTabManager&gt;&amp; TabManager) { WorkspaceMenuCategory = TabManager-&gt;AddLocalWorkspaceMenuCategory(FText::FromString(<span class="hljs-string"><span class="hljs-string">"Custom Editor"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> WorkspaceMenuCategoryRef = WorkspaceMenuCategory.ToSharedRef(); FAssetEditorToolkit::RegisterTabSpawners(TabManager); TabManager-&gt;RegisterTabSpawner(FCustomEditorTabs::ViewportID, FOnSpawnTab::CreateSP(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;FCustAssetEditor::SpawnTab_Viewport)) .SetDisplayName(FText::FromString(<span class="hljs-string"><span class="hljs-string">"Viewport"</span></span>)) .SetGroup(WorkspaceMenuCategoryRef) .SetIcon(FSlateIcon(FEditorStyle::GetStyleSetName(), <span class="hljs-string"><span class="hljs-string">"LevelEditor.Tabs.Viewports"</span></span>)); TabManager-&gt;RegisterTabSpawner(FCustomEditorTabs::DetailsID, FOnSpawnTab::CreateSP(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;FCustAssetEditor::SpawnTab_Details)) .SetDisplayName(FText::FromString(<span class="hljs-string"><span class="hljs-string">"Details"</span></span>)) .SetGroup(WorkspaceMenuCategoryRef) .SetIcon(FSlateIcon(FEditorStyle::GetStyleSetName(), <span class="hljs-string"><span class="hljs-string">"LevelEditor.Tabs.Details"</span></span>)); } TSharedRef&lt;SDockTab&gt; FCustAssetEditor::SpawnTab_Viewport(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FSpawnTabArgs&amp; Args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNew(SDockTab) .Label(FText::FromString(<span class="hljs-string"><span class="hljs-string">"Mesh Graph"</span></span>)) .TabColorScale(GetTabColorScale()) [ GraphEditor.ToSharedRef() ]; } TSharedRef&lt;SDockTab&gt; FCustAssetEditor::SpawnTab_Details(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FSpawnTabArgs&amp; Args) { FPropertyEditorModule&amp; PropertyEditorModule = FModuleManager::GetModuleChecked&lt;FPropertyEditorModule&gt;(<span class="hljs-string"><span class="hljs-string">"PropertyEditor"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> FDetailsViewArgs </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetailsViewArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, FDetailsViewArgs::HideNameArea, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; TSharedRef&lt;IDetailsView&gt; PropertyEditorRef = PropertyEditorModule.CreateDetailView(DetailsViewArgs); PropertyEditor = PropertyEditorRef; <span class="hljs-comment"><span class="hljs-comment">// Spawn the tab return SNew(SDockTab) .Label(FText::FromString("Details")) [ PropertyEditorRef ]; }</span></span></code> </pre><br>  The properties panel will suit us the standard one, but we will create our own bluprin editor.  It is created in the CreateGraphEditorWidget method. <br><pre> <code class="cpp hljs">TSharedRef&lt;SGraphEditor&gt; FCustAssetEditor::CreateGraphEditorWidget(UEdGraph* InGraph) { <span class="hljs-comment"><span class="hljs-comment">// Create the appearance info FGraphAppearanceInfo AppearanceInfo; AppearanceInfo.CornerText = FText::FromString("Mesh tree Editor"); GraphEditorCommands = MakeShareable(new FUICommandList); { GraphEditorCommands-&gt;MapAction(FGenericCommands::Get().SelectAll, FExecuteAction::CreateSP(this, &amp;FCustAssetEditor::SelectAllNodes), FCanExecuteAction::CreateSP(this, &amp;FCustAssetEditor::CanSelectAllNodes) ); GraphEditorCommands-&gt;MapAction(FGenericCommands::Get().Delete, FExecuteAction::CreateSP(this, &amp;FCustAssetEditor::DeleteSelectedNodes), FCanExecuteAction::CreateSP(this, &amp;FCustAssetEditor::CanDeleteNodes) ); GraphEditorCommands-&gt;MapAction(FGenericCommands::Get().Copy, FExecuteAction::CreateSP(this, &amp;FCustAssetEditor::CopySelectedNodes), FCanExecuteAction::CreateSP(this, &amp;FCustAssetEditor::CanCopyNodes) ); GraphEditorCommands-&gt;MapAction(FGenericCommands::Get().Paste, FExecuteAction::CreateSP(this, &amp;FCustAssetEditor::PasteNodes), FCanExecuteAction::CreateSP(this, &amp;FCustAssetEditor::CanPasteNodes) ); GraphEditorCommands-&gt;MapAction(FGenericCommands::Get().Cut, FExecuteAction::CreateSP(this, &amp;FCustAssetEditor::CutSelectedNodes), FCanExecuteAction::CreateSP(this, &amp;FCustAssetEditor::CanCutNodes) ); GraphEditorCommands-&gt;MapAction(FGenericCommands::Get().Duplicate, FExecuteAction::CreateSP(this, &amp;FCustAssetEditor::DuplicateNodes), FCanExecuteAction::CreateSP(this, &amp;FCustAssetEditor::CanDuplicateNodes) ); } SGraphEditor::FGraphEditorEvents InEvents; InEvents.OnSelectionChanged = SGraphEditor::FOnSelectionChanged::CreateSP(this, &amp;FCustAssetEditor::OnSelectedNodesChanged); InEvents.OnNodeDoubleClicked = FSingleNodeEvent::CreateSP(this, &amp;FCustAssetEditor::OnNodeDoubleClicked); TSharedRef&lt;SGraphEditor&gt; _GraphEditor = SNew(SGraphEditor) .AdditionalCommands(GraphEditorCommands) .Appearance(AppearanceInfo) .GraphToEdit(InGraph) .GraphEvents(InEvents) ; return _GraphEditor; }</span></span></code> </pre><br>  Here, from the beginning, actions and events are defined to which our editor will respond, and then the editor widget itself is created.  The most interesting parameter is .GraphToEdit (InGraph); it passes a pointer to the class UEdGraphSchema_CustomEditor <br><pre> <code class="cpp hljs">UCLASS() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UEdGraphSchema_CustomEditor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UEdGraphSchema { GENERATED_UCLASS_BODY() <span class="hljs-comment"><span class="hljs-comment">// Begin EdGraphSchema interface virtual void GetGraphContextActions(FGraphContextMenuBuilder&amp; ContextMenuBuilder) const override; virtual void GetContextMenuActions(const UEdGraph* CurrentGraph, const UEdGraphNode* InGraphNode, const UEdGraphPin* InGraphPin, FMenuBuilder* MenuBuilder, bool bIsDebugging) const override; virtual const FPinConnectionResponse CanCreateConnection(const UEdGraphPin* A, const UEdGraphPin* B) const override; virtual class FConnectionDrawingPolicy* CreateConnectionDrawingPolicy(int32 InBackLayerID, int32 InFrontLayerID, float InZoomFactor, const FSlateRect&amp; InClippingRect, class FSlateWindowElementList&amp; InDrawElements, class UEdGraph* InGraphObj) const override; virtual FLinearColor GetPinTypeColor(const FEdGraphPinType&amp; PinType) const override; virtual bool ShouldHidePinDefaultValue(UEdGraphPin* Pin) const override; // End EdGraphSchema interface };</span></span></code> </pre><br>  This class defines such things as the context menu items of the editor, determines how nodes will be connected, etc.  For us, the most important thing is the ability to create your own nodes.  This is done in the GetGraphContextActions method. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UEdGraphSchema_CustomEditor::GetGraphContextActions(FGraphContextMenuBuilder&amp; ContextMenuBuilder) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { FFormatNamedArguments Args; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> FName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AttrName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Attributes"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Args.Add(TEXT(<span class="hljs-string"><span class="hljs-string">"Attribute"</span></span>), FText::FromName(AttrName)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UEdGraphPin* FromPin = ContextMenuBuilder.FromPin; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UEdGraph* Graph = ContextMenuBuilder.CurrentGraph; TArray&lt;TSharedPtr&lt;FEdGraphSchemaAction&gt; &gt; Actions; CustomSchemaUtils::AddAction&lt;URootNode&gt;(TEXT(<span class="hljs-string"><span class="hljs-string">"Add Root Node"</span></span>), TEXT(<span class="hljs-string"><span class="hljs-string">"Add root node to the prop graph"</span></span>), Actions, ContextMenuBuilder.OwnerOfTemporaries); CustomSchemaUtils::AddAction&lt;UBranchNode&gt;(TEXT(<span class="hljs-string"><span class="hljs-string">"Add Brunch Node"</span></span>), TEXT(<span class="hljs-string"><span class="hljs-string">"Add brunch node to the prop graph"</span></span>), Actions, ContextMenuBuilder.OwnerOfTemporaries); CustomSchemaUtils::AddAction&lt;URuleNode&gt;(TEXT(<span class="hljs-string"><span class="hljs-string">"Add Rule Node"</span></span>), TEXT(<span class="hljs-string"><span class="hljs-string">"Add ruleh node to the prop graph"</span></span>), Actions, ContextMenuBuilder.OwnerOfTemporaries); CustomSchemaUtils::AddAction&lt;USwitcherNode&gt;(TEXT(<span class="hljs-string"><span class="hljs-string">"Add Switch Node"</span></span>), TEXT(<span class="hljs-string"><span class="hljs-string">"Add switch node to the prop graph"</span></span>), Actions, ContextMenuBuilder.OwnerOfTemporaries); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TSharedPtr&lt;FEdGraphSchemaAction&gt; Action : Actions) { ContextMenuBuilder.AddAction(Action); } }</code> </pre><br><br>  As you can see, so far I have created only four nodes in the list: <br>  1) The URootNode node is the display of the element root on the graph.  URootNode as well as elements of type root have type. <br>  2) The UBranchNode node this node places at the static level of the mesh (so far only the meshes, but you can easily create the nodes for other furnishing elements or characters) <br>  3) URuleNode node This node can be either open or closed depending on the specified condition.  The condition is naturally set in blueprint. <br>  4) The USwitcherNode node This node has one input and two outputs, depending on the condition, can open either the right output or the left one. <br><br>  So far, only four nodes but if you have any ideas you can write them in the comments.  Let's see how they work.  (To save space, I will give here only the base class for them, the source code can be downloaded from the link at the end of the article) <br><pre> <code class="cpp hljs">UCLASS() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICUSTOM_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UCustomNodeBase</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UEdGraphNode { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> TArray&lt;UCustomNodeBase*&gt; GetChildNodes(FRandomStream&amp; RandomStream); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateNodesMesh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UWorld* World, FName ActorTag, FRandomStream&amp; RandomStream, FVector AbsLocation, FRotator AbsRotation)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PostEditChangeProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct FPropertyChangedEvent&amp; e)</span></span></span><span class="hljs-function"> override</span></span>; TSharedPtr&lt;FNodePropertyObserver&gt; PropertyObserver; FVector Location; FRotator Rotation; };</code> </pre><br><br>  Here we see the GetChildNodes method in which the node passes an array of objects attached to its outputs.  And the CreateNodesMesh method in which the node creates a mesh or does not create it, but simply passes on the AbsLocation and AbsRotation values.  The PostEditChangeProperty method as you probably guessed is executed when someone changes the properties of the node. <br><br>  But as you probably noticed the nodes on the title picture differ in appearance from those that we used to see.  How to achieve this.  For this you need to create for each node the heir of SGraphNode.  Like last time, here I will give only the base class. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SGraphNode_CustomNodeBase</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SGraphNode, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FNodePropertyObserver { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SLATE_BEGIN_ARGS(SGraphNode_CustomNodeBase) { } SLATE_END_ARGS() <span class="hljs-comment"><span class="hljs-comment">/** Constructs this widget with InArgs */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FArguments&amp; InArgs, UCustomNodeBase* InNode)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// SGraphNode interface virtual void UpdateGraphNode() override; virtual void CreatePinWidgets() override; virtual void AddPin(const TSharedRef&lt;SGraphPin&gt;&amp; PinToAdd) override; virtual void CreateNodeWidget(); // End of SGraphNode interface // FPropertyObserver interface virtual void OnPropertyChanged(UEdGraphNode* Sender, const FName&amp; PropertyName) override; // End of FPropertyObserver interface protected: UCustomNodeBase* NodeBace; virtual FSlateColor GetBorderBackgroundColor() const; virtual const FSlateBrush* GetNameIcon() const; TSharedPtr&lt;SHorizontalBox&gt; OutputPinBox; FLinearColor BackgroundColor; TSharedPtr&lt;SOverlay&gt; NodeWiget; };</span></span></code> </pre><br><br>  The inheritance of the FNodePropertyObserver class is required solely for the OnPropertyChanged method.  The most important method is the UpdateGraphNode method in it and the widget that we see on the screen is created. The remaining methods are called from it to create certain parts of this widget. <br><br>  Please do not confuse the SGraphNode class with the UEdGraphNode class.  SGraphNode defines solely the appearance of the node, while the UEdGraphNode class defines the properties of the node itself. <br><br>  But even now if you run the project, the nodes will have the same look.  For appearance changes to take effect, you need to register them.  Where to do it?  Of course, at the start of the module: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FUICustomEditorModule::StartupModule() { <span class="hljs-comment"><span class="hljs-comment">//Registrate asset actions for MyObject FMyObjectAssetAction::RegistrateCustomPartAssetType(); //Registrate detail pannel costamization for TestActor FMyClassDetails::RegestrateCostumization(); // Register custom graph nodes TSharedPtr&lt;FGraphPanelNodeFactory&gt; GraphPanelNodeFactory = MakeShareable(new FGraphPanelNodeFactory_Custom); FEdGraphUtilities::RegisterVisualNodeFactory(GraphPanelNodeFactory); //Registrate ToolBarCommand for costom graph FToolBarCommandsCommands::Register(); //Create pool for icon wich show on costom nodes FCustomEditorThumbnailPool::Create(); }</span></span></code> </pre><br>  I want to note that a storage is also created here, for storing icons that will be displayed on the UBranchNode nodes.  Nodes are registered in the CreateNode method of the FGraphPanelNodeFactory_Custom class. <br><pre> <code class="cpp hljs">TSharedPtr&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SGraphNode</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FGraphPanelNodeFactory_Custom</span></span></span><span class="hljs-class">:</span></span>:CreateNode(UEdGraphNode* Node) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (URootNode* RootNode = Cast&lt;URootNode&gt;(Node)) { TSharedPtr&lt;SGraphNode_Root&gt; SNode = SNew(SGraphNode_Root, RootNode); RootNode-&gt;PropertyObserver = SNode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNode; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UBranchNode* BranchNode = Cast&lt;UBranchNode&gt;(Node)) { TSharedPtr&lt;SGraphNode_Brunch&gt; SNode = SNew(SGraphNode_Brunch, BranchNode); BranchNode-&gt;PropertyObserver = SNode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNode; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (URuleNode* RuleNode = Cast&lt;URuleNode&gt;(Node)) { TSharedPtr&lt;SGraphNode_Rule&gt; SNode = SNew(SGraphNode_Rule, RuleNode); RuleNode-&gt;PropertyObserver = SNode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNode; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (USwitcherNode* SwitcherNode = Cast&lt;USwitcherNode&gt;(Node)) { TSharedPtr&lt;SGraphNode_Switcher&gt; SNode = SNew(SGraphNode_Switcher, SwitcherNode); SwitcherNode-&gt;PropertyObserver = SNode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNode; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre><br><br>  Generation is performed in the TestActor class. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ATestAct::GenerateMeshes() { FRandomStream RandomStream = FRandomStream(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!MyObject) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Roots.Num(); i++) { URootNode* RootBuf; RootBuf = MyObject-&gt;FindRootFromType(Roots[i].RootType); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RootBuf) { RootBuf-&gt;CreateNodesMesh(GetWorld(), ActorTag, RandomStream, Roots[i].Location, FRotator(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Here we loop through all the root objects, each of them is characterized by a coordinate in space and a type.  Having received this object, we are looking for in the graph the node URootNode of the same type.  Having found it, we pass it the initial coordinates and run the method CreateNodesMesh which will go through the chain through the entire graph.  We do this until all root objects are processed. <br><br>  Actually that's all.  For further reference I recommend watching the source. <br><br>  <b>Source code project</b> <a href="https://cloud.mail.ru/public/J3Uj/9XPSMwSRK">here</a> <br><br>  In the meantime, I will tell you how this farm works.  The generation is carried out in the TestActor object, from the beginning it is necessary to manually set the positions and types of root objects (and what you would like a training project). <br><img src="https://habrastorage.org/files/e79/bed/b76/e79bedb76655482980c98fa2000eed8a.png" alt="image"><br>  After that, select in the properties the file MyObject, in which we must build a graph that determines which meshes will be created. <br><br>  So, how to set the rule for the rule node and switcher.  To do this, click the plus sign in the properties to create a new blueprint. <br><img src="https://habrastorage.org/files/3d3/0a1/9ef/3d30a19ef68b425d97f50e76f0e0729c.png" alt="image"><br>  But it turns out to be empty to do next?  You need to click Override NodeBool. <br><img src="https://habrastorage.org/files/d73/a94/efe/d73a94efe312433a90f24d4e721eea5e.png" alt="image"><br>  Now you can either open or close the node. <br><img src="https://habrastorage.org/files/f7a/2ff/8a3/f7a2ff8a3b8a45cd931b77a2a9da081a.png" alt="image"><br>  Everything is the same for switchera.  The Brunch node has the same rule for specifying the coordinates and rotation.  In addition, it has a way out, which means if you attach another Brunch to it, then it will use the coordinate of the previous one as a reference. <br><br>  It remains only to click the Generate Meshes button on the TestActor properties panel, and enjoy the result. <br><img src="https://habrastorage.org/files/e17/7c5/e71/e177c5e7140f478e86f826cb1dca01d1.png" alt="image"><br><br>  Hope you enjoyed this article.  It turned out to be much longer than before, I was afraid that I would not finish it until the end. <br><br>  PS After I wrote the article, I tried to assemble the game and it did not.  In order for the game to be collected it is necessary to make the following corrections in the CustomNods.h file: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICUSTOM_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UCustomNodeBase</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UEdGraphNode { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> TArray&lt;UCustomNodeBase*&gt; GetChildNodes(FRandomStream&amp; RandomStream); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateNodesMesh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UWorld* World, FName ActorTag, FRandomStream&amp; RandomStream, FVector AbsLocation, FRotator AbsRotation)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> WITH_EDITORONLY_DATA virtual void PostEditChangeProperty(struct FPropertyChangedEvent&amp; e) override; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//WITH_EDITORONLY_DATA TSharedPtr&lt;FNodePropertyObserver&gt; PropertyObserver; };</span></span></span></span></code> </pre><br>  That is, we must exclude all functions except GetChildNodes and CreateNodesMesh from the node class using the #if WITH_EDITORONLY_DATA operator.  In the remaining nodes, you must do the same. <br><br>  And accordingly CustomNods.cpp: <br><br><pre> <code class="cpp hljs">TArray&lt;UCustomNodeBase*&gt; UCustomNodeBase::GetChildNodes(FRandomStream&amp; RandomStream) { TArray&lt;UCustomNodeBase*&gt; ChildNodes; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ChildNodes; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UCustomNodeBase::CreateNodesMesh(UWorld* World, FName ActorTag, FRandomStream&amp; RandomStream, FVector AbsLocation, FRotator AbsRotation) { TArray&lt;UCustomNodeBase*&gt;ChailNodes = GetChildNodes(RandomStream); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ChailNodes.Num(); i++) { ChailNodes[i]-&gt;CreateNodesMesh(World, ActorTag, RandomStream, AbsLocation, AbsRotation); } } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> WITH_EDITORONLY_DATA void UCustomNodeBase::PostEditChangeProperty(struct FPropertyChangedEvent&amp; e) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (PropertyObserver.IsValid()) { FName PropertyName = (e.Property != NULL) ? e.Property-&gt;GetFName() : NAME_None; PropertyObserver-&gt;OnPropertyChanged(this, PropertyName); } Super::PostEditChangeProperty(e); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//WITH_EDITORONLY_DATA</span></span></span></span></code> </pre><br><br>  If you have already downloaded the project file, please transfer it again. <br><br>  PPS <a href="https://habrahabr.ru/post/278491/">Continued</a> </div><p>Source: <a href="https://habr.com/ru/post/277515/">https://habr.com/ru/post/277515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277501/index.html">Audio advertising: asked - we answer</a></li>
<li><a href="../277505/index.html">9 secrets of online payments. Part 2: regular payments</a></li>
<li><a href="../277509/index.html">Material on working with Apache Lucene and creating a simple fuzzy search</a></li>
<li><a href="../277511/index.html">List of machine learning resources. Part 1</a></li>
<li><a href="../277513/index.html">Rip network dictionaries using Node.js, part 2: dynamic pages; connect nw.js</a></li>
<li><a href="../277517/index.html">How I transferred the working Ubuntu MATE 14.04 system to a new SSD disk</a></li>
<li><a href="../277519/index.html">About MongoDB Online University</a></li>
<li><a href="../277521/index.html">Setting Safebrowsing from Yandex to Firefox</a></li>
<li><a href="../277525/index.html">Bidirectional rendering with diacritics support</a></li>
<li><a href="../277527/index.html">The benefits of big data technology in everyday life</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>