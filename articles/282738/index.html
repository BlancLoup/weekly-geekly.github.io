<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We present data and code in order: optimization and memory, part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This two-part series describes how data and memory structures affect performance. Some actions are suggested to improve software performance. Even the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We present data and code in order: optimization and memory, part 1</h1><div class="post__text post__text-html js-mediator-article">  This two-part series describes how data and memory structures affect performance.  Some actions are suggested to improve software performance.  Even the simplest actions shown in these articles will lead to significant performance gains.  Many articles on program performance optimization consider load parallelization in the following areas: distributed memory (for example, MPI), shared memory or a set of SIMD commands (vectorization), but in fact parallelization must be applied in all three areas.  These elements are very important, but memory is also important, and often forgotten about it.  Changes to program architecture and the use of parallel processing affect memory and performance. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6a6/240/afd/6a6240afddab40979f0fac4968ebffe1.jpg"></div><a name="habracut"></a><br>  These articles are intended for mid-level developers.  It is assumed that the reader seeks to optimize the performance of programs using common programming capabilities in C ++ and Fortran *.  We use assembler and built-in functions for more experienced users.  The author recommends those who wish to obtain more detailed materials in order to familiarize themselves with the architecture of processor instruction sets and with numerous research journals that publish excellent articles on the analysis and design of data structures. <br><br>  There are two basic principles used to bring data and code into order: you need to minimize data movement and place data as close as possible to the area in which they will be used.  When data gets into a processor register (or as close as possible to a register), you should use it most efficiently before removing it from memory or away from executable processor units. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#0071c5">Data placement</font> </h2><br>  Consider the three levels at which data can be located.  The closest place to executable blocks is the processor registers.  The data in the registers can be processed: apply multiplication and addition to them, use them in comparisons and logical operations.  In a multi-core processor, each core usually has its own first-level cache (L1).  You can very quickly move data from the first-level cache to the register.  There may be several cache levels, but usually the last level cache (LLC) is common to all processor cores.  The device intermediate cache levels vary for different processor models;  These levels can be both common to all nuclei, and separate for each nucleus.  On Intel platforms, consistent cache operation is supported within the same platform (even if there are multiple processors).  Moving data from the cache to the register is faster than getting data from the main memory. <br><br>  The schematic data arrangement, proximity to the processor registers and the relative access time are shown in Fig.  1. The closer the block is to the register, the faster the movement and the shorter the delay when the data enters the register for execution.  Cache - the fastest memory with the lowest latency.  Next in speed - the main memory.  There may be several levels of memory, although we will discuss the multi-level memory device in the second part of this article.  If the memory pages are located in the virtual memory of the paging file on a hard disk or solid state drive, the speed is significantly reduced.  Traditional MPI architecture with sending and receiving data over the network (Ethernet, Infiniband, etc.) has greater latency than receiving data in the local system.  The speed when moving data from a remote system with MPI access may vary depending on the connection method used: Ethernet, Infiniband, Intel True Scale or Intel Omni Scale. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ccb/8ca/392/ccb8ca39263240e4b9488b3fe79540c5.png"></div><br>  <font color="#999999"><i>Figure 1. Memory access speed, relative delays in accessing data</i></font> <br><br>  The closest place to executable blocks is the processor registers.  Due to the number of registers and delays associated with loading data into registers, and also because of the size of the queue of memory operations, it is not possible to use each value in the registers once and submit data quickly enough so that all executable blocks are fully occupied.  If the data is close to the executable block, it is advisable to reuse this data before it is pushed out of the cache or removed from the register.  Some variables exist only in the form of variable registers and are never stored in main memory.  The compiler perfectly recognizes when it is better to use a variable only in a register, so it is not recommended to use the <i>register</i> keyword in C / C ++.  The compilers themselves recognize the optimization possibilities quite well and can ignore the <i>register</i> keyword. <br><br>  The developer must analyze the code, understand how data is used and how long it should exist.  Ask yourself: ‚ÄúShould I create a temporary variable?‚Äù, ‚ÄúShould I create a temporary array?‚Äù, ‚ÄúDo I need to store so many temporary variables?‚Äù.  In the process of improving performance, you need to collect a performance metric and focus on getting data closer to modules or code branches, which spend considerable time on code execution.  Popular programs for acquiring performance data include Intel VTune Amplifier XE, gprof, and Tau *. <br><br><h2>  <font color="#0071c5">Data Usage and Reuse</font> </h2><br>  An example of matrix multiplication is perfect for understanding this stage.  Multiplication of matrices A = A + B * C for three square matrices n x n can be represented by three simple nested for loops, as shown below. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n; i++) <span class="hljs-comment"><span class="hljs-comment">// line 136 for (j = 0; j&lt;n; j++) // line 137 for (k=0;k&lt;n; k++) // line 138 A[i][j] += B[i][k]* C[k][j] ; // line 139</span></span></code> </pre> <br>  The main problem with this order is that it contains the operation of matrix reduction (lines 138 and 139).  The left side of line 139 is a single value.  The compiler will partially unfold the loop in line 138 in order to fill the SIMD registers to the greatest extent and form 4 or 8 products from elements B and C, it is necessary to add these products into one value.  Adding 4 or 8 products to one position is a casting operation that does not use the performance of parallel computing and does not use all SIMD registers with the highest efficiency.  You can improve the performance of parallel processing by minimizing or completely eliminating cast operations.  If there is one value in the left part of the line inside the loop, this indicates a possible cast.  The data access path for one iteration of line 137 is shown below in fig.  2 (i, j = 2). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/58b/e24/61c/58be2461c41f4c489482881d467105e4.png"></div><br>  <font color="#999999"><i>Figure 2. Streamlining;</i></font>  <font color="#999999"><i>single value in matrix A</i></font> <br><br>  Sometimes coercion can be eliminated using reordering operations.  Consider the ordering in which two internal cycles are swapped.  The number of floating point operations remains the same.  But since the cast operation (summation of values ‚Äã‚Äãin the left part of the line) is excluded, the processor can use all executable SIMD blocks and registers.  At the same time productivity considerably increases. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;n; i++) <span class="hljs-comment"><span class="hljs-comment">// line 136 for (k = 0; k&lt;n; k++) // line 137new for (j=0;j&lt;n; j++) // line 138new a[i][j] += b[i][k]* c[k][j] ; // line 139</span></span></code> </pre><br>  After that there is an adjacent appeal to elements A and C. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/266/734/ec1/266734ec1f724b45856152090da7b247.png"></div><br>  <font color="#999999"><i>Figure 3. Updated order with contiguous access</i></font> <br><br>  The initial order ijk is a scalar multiplication method.  The scalar multiplication of two vectors is used to calculate the value of each element of the matrix A. The order ikj is the operation saxpy (A * X + Y single precision) or daxpy (A * X + Y double precision).  The product of one vector per constant is added to another vector.  Both the dot product and the operations A * X + Y are <a href="https://software.intel.com/en-us/node/468390%3Flanguage%3Dru">BLAS</a> procedures of <a href="https://software.intel.com/en-us/node/468390%3Flanguage%3Dru">level 1</a> .  For the order of ikj, no cast is required.  A subset of the row of the matrix C is multiplied by the scalar value of the matrix B and added to the subset of the row of the matrix A (the compiler will determine the size of the subsets depending on the size of SIMD registers used - SSE4, AVX or AVX512).  Memory access for one iteration of loop 137new is shown above in fig.  3 (again i, j = 2). <br><br>  The exception to the reduction in scalar multiplication is a significant increase in performance.  At the O2 optimization level, both the Intel compiler and gcc * create vectorized code using SIMD registers and executable blocks.  In addition, the Intel compiler automatically reverses the cycles j and k.  You can verify this in the optimization compiler report, which can be obtained using the <i>opt-report</i> compiler option ( <i>-qopt report</i> in Linux *).  The default optimization report is output to the file filename.optrpt.  In this case, the optimization report contains the following text fragments. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> at mm.c(<span class="hljs-number"><span class="hljs-number">136</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>) remark #<span class="hljs-number"><span class="hljs-number">25444</span></span>: Loopnest Interchanged: ( <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-comment"><span class="hljs-comment">--&gt; ( 1 3 2 )</span></span></code> </pre> <br>  The report also shows that the reordered cycle was vectorized. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> at mm.c(<span class="hljs-number"><span class="hljs-number">137</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>) remark #<span class="hljs-number"><span class="hljs-number">15301</span></span>: PERMUTED <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> WAS VECTORIZED <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span></code> </pre><br>  The gcc compiler (version 4.1.2-55) does not automatically reorder loops.  The developer should take care of changing the order. <br><br>  Additional performance gains are provided by locking loops.  This facilitates data reuse.  In the representation shown above (Fig. 3), for each iteration of the middle cycle, reference is made to two vectors of length n (and a scalar value), each element of these two vectors being used only once.  For large values ‚Äã‚Äãof n, it is likely that each element of the vector will be pushed out of the cache between each iteration of the average cycle.  If you lock loops for the purpose of data reuse, performance improves again. <br><br>  In the last version of the code, the cycles j and k are reordered, and a lock is also applied.  The code works on subsets of matrices or blocks of <i>blockSize</i> size.  In this simple example, <i>blockSize</i> is a multiple of n code. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i+=blockSize) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;n ; k+= blockSize) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span> ; j &lt; n; j+=blockSize) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (iInner = i; iInner&lt;i+blockSize; iInner++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (kInner = k ; kInner&lt;k+blockSize; kInner++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (jInner = j ; jInner&lt;j+blockSize ; jInner++) a[iInner,jInner] += b[iInner,kInner] * c[kInner, jInner]</code> </pre> <br>  In this model, accessing data from one iteration of loop j may look like this. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/589/ec9/ea6/589ec9ea620f465497c6d10e97644c20.png"></div><br>  <font color="#999999"><i>Figure 4. Block model representation</i></font> <br><br>  If the block size is correctly selected, it can be assumed that each block will remain in the cache (and even, maybe, in the SIMD registers) during the work of three internal cycles.  Each element of the matrices A, B, and C will be used a number of times equal to <i>blockSize</i> before being removed from SIMD registers or displaced from the cache.  At the same time, data reuse is increased by the number of times equal to <i>blockSize</i> .  When using matrices of small size, the use of blocks practically does not give a gain.  The larger the matrix size, the more significant the performance increase. <br><br>  The table below shows the ratio of performance measured on a system with different compilers.  Note that the Intel compiler automatically reverses the loops in lines 137 and 138. Therefore, the Intel compiler's performance is almost the same for orders ijk and ikj.  Because of this, the Intel compiler‚Äôs baseline performance is also much higher, so the resulting increase in speed over the baseline seems less. <br><table><tbody><tr><th width="100">  Order </th><th>  Matrix / block size </th><th>  Gcc * 4.1.2 -O2, increased speed / performance compared to baseline </th><th>  Intel 16.1 -O2 compiler, speed / performance improvement over baseline </th></tr><tr><td>  ijk </td><td>  1600 </td><td>  1 (basic level) </td><td>  12.32 </td></tr><tr><td>  ikj </td><td>  1600 </td><td>  6.25 </td><td>  12.33 </td></tr><tr><td>  Ikj block </td><td>  1600/8 </td><td>  6.44 </td><td>  8.44 </td></tr><tr><td>  ijk </td><td>  4,000 </td><td>  1 (basic level) </td><td>  6.39 </td></tr><tr><td>  ikj </td><td>  4,000 </td><td>  6.04 </td><td>  6.38 </td></tr><tr><td>  Ikj block </td><td>  4000/8 </td><td>  8.42 </td><td>  10.53 </td></tr></tbody></table>  <font color="#999999"><i>Table 1. Performance Ratio of gcc * and Intel Compilers</i></font> <br><br>  The sample code shown is simple, both compilers will create SIMD instructions.  This is an outdated gcc compiler, here it is used not to compare the performance of compilers, but to demonstrate the influence of the order of operations and cast, even when the data to be cast is processed in parallel.  Many cycles are more complex, the compiler will not be able to recognize the possibilities for parallelization.  Therefore, developers are advised to study the parts of the code for which the most time is spent executing, review the compiler's reports in order to understand whether the compiler has applied optimization or whether it should be applied independently.  Also note the importance of blocking data if the amount of data becomes too large.  For the smaller of the two matrices, performance does not improve.  For larger matrices, performance increases significantly.  Therefore, before applying blocking, developers should consider the relative size of data and cache.  When adding multiple nested loops and corresponding bounds, developers can achieve an increase in performance from 2 to 10 times compared to the original code.  This is a significant increase in productivity, achieved with quite a reasonable amount of effort. <br><br><h2>  <font color="#0071c5">Using optimized libraries</font> </h2><br>  As you know, there is no limit to perfection.  The block code still does not work at the highest speed: it can be accelerated using the <a href="http://www.netlib.org/blas/">BLAS</a> <a href="https://software.intel.com/en-us/node/429920%3Flanguage%3Dru">DGEMM</a> level 3 procedures from the optimized LAPACK libraries, such as the Intel Math Kernel Library (Intel MKL).  For conventional linear algebra and Fourier transforms, modern libraries such as the Intel Math Kernel Library provide even more efficient optimization than simple blocking and reordering.  Developers are advised to use such optimized libraries whenever possible. <br><br>  There are such libraries for matrix multiplication, although optimized libraries do not exist for all possible situations in which you can improve performance with blocking.  Matrix multiplication is a convenient example to illustrate the principle of optimization.  This principle is also suitable for finite difference templates. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/50c/a61/c08/50ca61c08fdb4e619d58e80d7d60a42c.png"></div><br>  <font color="#999999"><i>Figure 5. Two-dimensional representation of the block model</i></font> <br><br>  A simple nine-point pattern uses the highlighted blocks shown below to update the values ‚Äã‚Äãin the center block.  Nine values ‚Äã‚Äãare used to update one position.  When updating a neighboring element, six of these values ‚Äã‚Äãwill be used again.  If the code works in the order shown, then the behavior will be similar to that shown in the adjacent figure, 15 values ‚Äã‚Äãare used to update the three positions.  Further, this ratio is gradually approaching 1: 3. <br><br>  If you put the data in two-dimensional blocks, as shown in Fig.  5, then for updating six positions 20 values ‚Äã‚Äãare used, placed in registers in blocks of two;  while the ratio is close to 1: 2. <br><br>  I recommend that readers familiarize themselves with the finite difference technicians in the excellent article <a href="https://software.intel.com/en-us/articles/eight-optimizations-for-3-dimensional-finite-difference-3dfd-code-with-an-isotropic-iso">Eight methods for optimizing the three-dimensional finite-difference (3DFD) isotropic (ISO) code by</a> Cedric Andreolli (Cedric Andreolli).  This article describes not only blocking, but also other methods of memory optimization. <br><br><h2>  <font color="#0071c5">Conclusion</font> </h2><br>  Let's sum up.  This article provides three examples that developers can apply to their programs.  First, streamline operations to avoid parallel computations.  Second, find data reusability and apply a block structure to nested loops to support data reuse.  In some cases, this will double the performance.  Third, use optimized libraries whenever possible.  They are much faster than any code obtained by a regular developer using reordering. <br>  The full code can be downloaded <a href="https://github.com/drmackay/samplematrixcode">here</a> . <br><br>  In the second part I will talk about parallelizing the load on several cores, and not just on the SIMD registers.  In addition, we will discuss spurious sharing and arrays of structures. </div><p>Source: <a href="https://habr.com/ru/post/282738/">https://habr.com/ru/post/282738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282724/index.html">Yii 2.0.8</a></li>
<li><a href="../282728/index.html">Disconnection of analog satellite TV: 4 years later (part 1)</a></li>
<li><a href="../282732/index.html">My Location Companion - Photo messages and magnetic field control</a></li>
<li><a href="../282734/index.html">OpenStack: How not to ‚Äútread on the rake‚Äù of OpenSource business</a></li>
<li><a href="../282736/index.html">Development in own juice or as we understood that we are not doing what users need</a></li>
<li><a href="../282740/index.html">Windows performance analysis using OS features and PAL utility</a></li>
<li><a href="../282742/index.html">Hotel business: an easy target for hackers with attractive profits</a></li>
<li><a href="../282744/index.html">Microsoft improves Windows 10 kernel security mechanisms</a></li>
<li><a href="../282750/index.html">Analysis of English text with a cup of coffee "JavaSE8"</a></li>
<li><a href="../282752/index.html">Chewing Algorithm for Touchscreen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>