<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Randomized search trees</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I do not know about you, dear reader, but I have always been amazed at the contrast between the grace of the basic idea embedded in the concept of bin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Randomized search trees</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/storage2/a38/7ee/5c0/a387ee5c0b3066715256230d0aa9cfa1.png"><br>  I do not know about you, dear reader, but I have always been amazed at the contrast between the grace of the basic idea embedded in the concept of binary search trees and the complexity of implementing <i>balanced</i> binary search trees ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B0%25D1%2581%25D0%25BD%25D0%25BE-%25D1%2587%25D1%2591%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE" title="Red black tree">red-black trees</a> , <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%2592%25D0%259B-%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE" title="AVL-tree">AVL-trees</a> , <a href="http://habrahabr.ru/post/101818/" title="Cartesian wood: Part 1. Description, operations, applications">Cartesian trees</a> ).  Recently, turning over Sedgwick [ <a href="https://habr.com/ru/post/145388/">1</a> ] once again, I found a description of randomized search trees (the original work [ <a href="https://habr.com/ru/post/145388/">2</a> ] was also found) - so simple that it only takes a third of a page (insert nodes, another page delete nodes).  In addition, upon closer inspection, an additional bonus emerged in the form of a very beautiful implementation of the operation of removing nodes from the search tree.  Below you will find a description (with color pictures) of randomized search trees, implementation in C ++, as well as the results of a small author's study of the balance of the described trees. <br><a name="habracut"></a><br><h1>  Start little by little </h1><br>  Since I am going to describe the full implementation of the tree, I will have to start from the beginning (professionals can easily skip a couple of sections).  Each node of the binary search tree will contain a key key, which essentially controls all processes (we will have it intact), and a pair of left and right pointers to the left and right subtrees.  If any pointer is zero, then the corresponding tree is empty (i.e., simply absent).  In addition to this, we will need another size field to implement a randomized tree, which will store the size (in <s>parrots</s> tops) of the tree with the root in this node.  Nodes will be represented by structures: <br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> //      </span></span>{ int key; int size; node* <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>; node* <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>; node(int k) { key = k; <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; size = <span class="hljs-number"><span class="hljs-number">1</span></span>; } };</code> </pre> <br><img align="right" src="https://habrastorage.org/storage2/361/64a/a86/36164aa86adb86997a04077b05407f13.png">  The main property of the search tree is that any key in the left subtree is smaller than the root key, and in the right subtree it is larger than the root key (for clarity, we will assume that all keys are different).  This property (shown schematically in the figure on the right) allows us to very simply organize the search for a given key, moving from the root to the right or left depending on the value of the root key.  The recursive version of the search function (and we will consider only such) looks like this: <br><pre> <code class="hljs lua">node* <span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(node* p, int k) //   k   p { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !p ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; //       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k == p-&gt;key ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k &lt; p-&gt;key ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(p-&gt;left,k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(p-&gt;right,k); }</code> </pre><br>  Go to insert new keys in the tree.  In the classic version of the insert repeats the search with the difference that when we run into a null pointer, we create a new node and hang it to the place where we found a dead end.  At first, I did not want to paint this function, because in the randomized case it works a little differently, but changed my mind, because  I want to fix a couple of moments. <br><pre> <code class="hljs pgsql">node* <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(node* p, <span class="hljs-type"><span class="hljs-type">int</span></span> k) //       k   p { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !p ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> node(k); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( p-&gt;key&gt;k ) p-&gt;left = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(p-&gt;left,k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> p-&gt;right = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(p-&gt;right,k); fixsize(p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; }</code> </pre><br>  First, any function that modifies a given tree returns a pointer to a new root (whether it has changed or not), and then the caller itself decides where to hang the tree.  Secondly, because  we have to keep the size of the tree, then for any change of subtrees we need to adjust the size of the tree itself.  The following pair of functions will do this for us: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> getsize(node* p) //    size,     (t=<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !p ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p-&gt;size; } <span class="hljs-type"><span class="hljs-type">void</span></span> fixsize(node* p) //     { p-&gt;size = getsize(p-&gt;left)+getsize(p-&gt;right)+<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><img align="right" src="https://habrastorage.org/storage2/e61/ad5/9b2/e61ad59b25006d06f3337758f5a7d43c.png">  What is wrong with the insert function?  The problem is that this function does not guarantee the balance of the resulting tree, for example, if the keys are given in ascending order, the tree will degenerate into a single-linked list (see figure) with all the accompanying "buns", the main of which is the <i>linear</i> execution time <i>all</i> operations on such a tree (while for balanced trees this time is logarithmic).  There are various ways to avoid imbalance.  Conventionally, they can be divided into two classes, those that guarantee balance (red-black trees, AVL-trees), and those that provide it in a probabilistic sense (Cartesian trees) - the probability of obtaining an unsubstituted tree is negligible for large tree sizes.  I think it will not be a surprise if I say that randomized trees belong to the second class. <br><br><h1>  Insert in the root of the tree </h1><br>  A necessary component of randomization is the use of a special insert of a new key, as a result of which a new key appears at the root of the tree (a useful function in many ways, since access to recently inserted keys turns out to be very fast, hello to <a href="http://en.wikipedia.org/wiki/Self-organizing_list" title="Self-organizing list">self-organizing lists</a> ).  To implement the insert into the root, we need a rotation function that performs a local transformation of the tree. <br><br><img src="https://habrastorage.org/storage2/08e/55b/834/08e55b834b268b34eea7cb787094bd57.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Do not forget to adjust the size of the subtrees and return the root of the new tree: <pre> <code class="hljs erlang-repl">node* rotateright(node* p) //     p { node* q = p-&gt;left; if( !q ) return p; p-&gt;left = q-&gt;right; q-&gt;right = p; q-&gt;size = p-&gt;size; fixsize(p); return q; }</code> </pre><br><pre> <code class="hljs erlang-repl">node* rotateleft(node* q) //     q { node* p = q-&gt;right; if( !p ) return q; q-&gt;right = p-&gt;left; p-&gt;left = q; p-&gt;size = q-&gt;size; fixsize(q); return p; }</code> </pre><br>  Now actually insert into the root.  First, we recursively insert the new key into the root of the left or right subtree (depending on the result of the comparison with the root key) and perform a right (left) turn, which raises the node we need to the root of the tree. <br><br><img src="https://habrastorage.org/storage2/a3c/9eb/1dd/a3c9eb1ddc3353282db58529400b08a2.png"><br><br><pre> <code class="hljs pgsql">node* insertroot(node* p, <span class="hljs-type"><span class="hljs-type">int</span></span> k) //      k    p { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !p ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> node(k); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k&lt;p-&gt;key ) { p-&gt;left = insertroot(p-&gt;left,k); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotateright(p); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { p-&gt;right = insertroot(p-&gt;right,k); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotateleft(p); } }</code> </pre><br><br><h1>  Randomized insert </h1><br>  So we got to randomization.  At this moment we have two insertion functions - a simple one and a root, of which we now combine the randomized insert.  The meaning of all this lies in the following idea.  It is known that if you mix all the keys in advance and then build a tree out of them (the keys are inserted according to the standard scheme in the order obtained after mixing), then the tree will be well balanced (its height will be about 2log <sub>2</sub> n versus log <sub>2</sub> n for perfectly balanced tree).  Note that in this case any of the original keys can be with the same probability as the root.  What to do if we do not know in advance what keys we will have (for example, they are entered into the system when using the tree)?  In fact, everything is simple.  Since any key (including the one that we now have to insert into the tree) can turn out to be a root with probability 1 / (n + 1) (n is the size of the tree before insertion), then we perform with the specified probability an insert into the root, and with probability 1-1 / (n + 1) - recursive insertion into the right or left subtree depending on the key value in the root: <br><pre> <code class="hljs pgsql">node* <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(node* p, <span class="hljs-type"><span class="hljs-type">int</span></span> k) //       k   p { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !p ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> node(k); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( rand()%(p-&gt;size+<span class="hljs-number"><span class="hljs-number">1</span></span>)==<span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> insertroot(p,k); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( p-&gt;key&gt;k ) p-&gt;left = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(p-&gt;left,k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> p-&gt;right = <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(p-&gt;right,k); fixsize(p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; }</code> </pre><br>  That's the whole trick ... Let's see how it all works.  An example of building a tree of 500 nodes (the keys from 0 to 499 were received at the entrance in ascending order): <br><img src="https://habrastorage.org/storage2/d36/3d2/6cb/d363d26cb1fccf3b679415562617ccaf.png">  Not to say that the ideal of beauty, but the height is clearly small.  Let's complicate the task - we will build a tree, giving the input keys from 0 to 2 <sup>14</sup> -1 (the ideal height is 14), and measure the height in the construction process.  For reliability, we will do a thousand runs and average the result.  We obtain the following graph, in which our results are marked with markers, and the solid line from the theoretical estimate from [ <a href="https://habr.com/ru/post/145388/">3</a> ] is h = 4.3ln (n) -1.9ln (ln (n)) -4.  The most important thing that we see from the figure is that probability theory is power! <br><img src="https://habrastorage.org/storage2/52e/cb2/402/52ecb24027107f1c7fbf98f8867af247.png"><br>  It should be understood that the proposed graph shows the <i>average</i> height of the tree by a large number of calculations.  And how much height can differ in one particular calculation.  The above article has an answer to this question.  We will act on workers and peasants and build a histogram of the distribution of heights after the insertion of 4095 nodes. <br><img src="https://habrastorage.org/storage2/f48/17a/749/f4817a749b89cb2caed253b55e79ded4.png"><br>  In general, no crime is visible, the distribution tails are short - the maximum height obtained is 39, which is not much higher than the <s>hospital</s> average. <br><br><h1>  Deleting keys </h1><br>  So, we have a balanced (at least in some sense) tree.  True, while it does not support the removal of nodes.  This is what we will do now.  The removal option, which is prescribed in many textbooks and which is well (with pictures) described on <a href="http://habrahabr.ru/post/65617/" title="Data structures: binary trees. Part 1">Habr√©</a> , can and works quickly, but it looks very unrepresented (compared to the insert).  We will go the other way, approximately as it was shown in this wonderful <a href="http://habrahabr.ru/post/101818/" title="Cartesian wood: Part 1. Description, operations, applications">post</a> (in my opinion, this is the best description of Cartesian trees).  Before removing the nodes, learn how to connect the trees.  Let two search trees with roots p and q be given, and any key of the first tree is less than any key in the second tree.  It is required to combine these two trees into one.  As the root of a new tree, you can take either of the two roots, let it be p.  Then the left subtree p can be left as it is, and on the right p hang up the union of two trees - the right subtree p and the whole tree q (they satisfy all the conditions of the problem). <br><img src="https://habrastorage.org/storage2/fe5/05e/2a6/fe505e2a6d4696a751147d2bf063bf84.png"><br>  On the other hand, with the same success, we can make the root of the new tree node q.  In a randomized implementation, the choice between these alternatives is made randomly.  Let the size of the left tree be n, the right one - m.  Then p is chosen as the new root with probability n / (n + m), and q with probability m / (n + m). <br><pre> <code class="hljs perl">node* <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(node* p, node* <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>) //    { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !p ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !<span class="hljs-keyword"><span class="hljs-keyword">q</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>()%(p-&gt;size+<span class="hljs-keyword"><span class="hljs-keyword">q</span></span>-&gt;size) &lt; p-&gt;size ) { p-&gt;right = <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(p-&gt;right,<span class="hljs-keyword"><span class="hljs-keyword">q</span></span>); fixsize(p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>-&gt;left = <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(p,<span class="hljs-keyword"><span class="hljs-keyword">q</span></span>-&gt;left); fixsize(<span class="hljs-keyword"><span class="hljs-keyword">q</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>; } }</code> </pre><br><img align="right" src="https://habrastorage.org/storage2/0b5/c79/300/0b5c79300e3272d42b975f80679a3007.png">  Now everything is ready for removal.  We will delete by key - we look for the node with the given key (I remind you that we have all the keys are different) and remove this node from the tree.  The search stage is the same as in the search (oddly enough), but then we do it further - we merge the left and right subtrees of the found node, delete the node, return the root of the merged tree. <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">node</span></span>* remove(node* p, int k) //    p      k { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !p ) return p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( p-&gt;key==k ) { node* q = join(p-&gt;left,p-&gt;right); delete p; return q; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( k&lt;p-&gt;key ) p-&gt;left = remove(p-&gt;left,k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> p-&gt;right = remove(p-&gt;right,k); return p; }</code> </pre><br>  We verify that deletion does not disturb the balance of the tree.  To do this, we will build a tree with 2 <sup>15</sup> keys, then delete half (with values ‚Äã‚Äãfrom 0 to 2 <sup>14</sup> -1) and look at the distribution of heights ... <br><img src="https://habrastorage.org/storage2/f9b/440/bd1/f9b440bd1c6196b1085a9a3674f273a7.png"><br>  Virtually no difference, as required to "prove" ... <br><br><h1>  Instead of conclusion </h1><br>  The undoubted advantage of randomized binary search trees is the simplicity and beauty of their implementation.  However, as you know free cakes do not happen.  What are we paying in this case?  First, additional memory for storing subtree sizes.  One integer field per node.  With some dexterity, red-and-black trees can do without additional fields.  On the other hand, the size of the tree is not completely useless information, because it allows you to organize access to data by number (the task of sampling or search for ordinal statistics), which turns our tree, in fact, into an ordered array with the ability to insert and delete any elements.  Secondly, the operation time is logarithmic, but I suspect that the proportionality constant will be rather big - almost all operations are performed in two passes (and down and up), besides, insertion and deletion require random numbers.  There is good news - at the search stage everything should work very quickly.  Finally, the principal obstacle to using such trees in serious applications is that logarithmic time is not guaranteed; there is always a chance that the tree will turn out to be poorly balanced.  True, the probability of such an event already at ten thousand knots is so small that, perhaps, you can take a risk ... <br><br>  Thanks for attention! <br><br><h1>  Literature </h1><br><ol><li><a name="sedgevick"></a>  Robert Sedgwick, Algorithms in C ++, M .: Williams, 2011 <font color="grey"><i>- just a good book</i></font> </li><li><a name="martinez"></a>  Martinez, Conrado;  Roura, Salvador (1998), ACM (ACM Press) 45 (2): 288‚Äì323 <font color="grey"><i>- original article</i></font> </li><li><a name="reed"></a>  Reed, Bruce (2003), <a href="http://cgm.cs.mcgill.ca/~reedbook/papers/2003_R_1.pdf" title="cgm.cs.mcgill.ca/~reedbook/papers/2003_R_1.pdf">The</a> ACM 50 (3): 306‚Äì332 <font color="grey"><i>-</i></font> <a href="http://cgm.cs.mcgill.ca/~reedbook/papers/2003_R_1.pdf" title="cgm.cs.mcgill.ca/~reedbook/papers/2003_R_1.pdf">a binary tree search</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/145388/">https://habr.com/ru/post/145388/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../145381/index.html">Basics of relational algebra</a></li>
<li><a href="../145382/index.html">Acer M3-581TG-72636G52Mnkk Laptop Review</a></li>
<li><a href="../145383/index.html">Tables in accounting systems</a></li>
<li><a href="../145385/index.html">Forecasting purchases: hellish, but very useful math</a></li>
<li><a href="../145387/index.html">John Carmack makes a virtual reality helmet</a></li>
<li><a href="../145389/index.html">We work with a 1C web service from an application on Android</a></li>
<li><a href="../145390/index.html">Children's video review of the MSI Radeon HD 7950 video card</a></li>
<li><a href="../145392/index.html">Meet the updated Windows Azure cloud platform</a></li>
<li><a href="../145394/index.html">Efficient nanofilter for three kopecks</a></li>
<li><a href="../145395/index.html">2GIS knows where to go for lunch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>