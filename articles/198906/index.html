<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Network Render in a Blender</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="picture for those in the tank 
 A couple of years ago I was asked to write an educational program on the network renderer in a blender. 
 I got a litt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Network Render in a Blender</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/221/00b/23d/22100b23d27dd3c8059b0008b105a11a.jpg"></div><br><h6>  picture for those in the tank </h6><br>  A couple of years ago I was asked to write an educational program on the network renderer in a blender. <br>  I got a little carried away and got what I bring to your attention. <br>  The review was not published until the end on the website <a href="http://blender3d.org.ua/tutorial/%25D0%25A1%25D0%25B5%25D1%2582%25D0%25B5%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B4%25D0%25B5%25D1%2580.html">blender3d.org.ua</a> , although the <a href="http://blender3d.org.ua/forum/rendering/235.html">pdf</a> can be found there.  Please save, maybe someone will be interested. <br><a name="habracut"></a><br>  <b>Network Render in a Blender</b> <br><br>  This guide was written to demonstrate the capabilities of the blender in this. <br>  relatively new role for him. <br>  For many years now, such programs as 3Dstudio have been used over the network for collaboration or rendering, but in Blender this opportunity appeared relatively recently.  With the release of the short film Sintel, the authors <a href="http://youtu.be/fMJXiOF9MGM">demonstrated the render studio</a> at which they worked when making the film, and also <a href="http://www.youtube.com/watch%3Fv%3DfMJXiOF9MGM%26feature%3Dyoutu.be%26t%3D10m10s">complained</a> that for the network render they had to use third-party development instead of the built-in 2.5 Blender network render, since by that time it was unable to provide a studio with a stable and fast result. <br>  Let's see how things are now, and at the same time compare the internal network render of Blender <br>  with LuxBlend plug-in, which recently received OpenCL support. <br><br>  <b><u>Internal netrendering</u></b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      With the advent of Blender 2.5, the need to have at least some network render within the program caused the netrender code to be instantly included in it, written, like most plugins, on Python by Martin Poirier (Martin Poirier). <br>  The idea turned out to be quite good: to use the internal render of Blender, which was to guarantee the identity of the image, processed locally or remotely;  centralization of control on the master server;  fairly simple server management and quick, not complicated installation. <br>  However, the first tests showed that much remains to be done, and at the moment the plug-in, though supplied inside the distribution, needs to be activated manually. <br><br>  <b>Installation</b> <br><br>  Netrender in a blender is divided into three components: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4c/aa8/a3e/c4caa8a3e6730dda096d45db32cd9dfa.jpg"></div><br><br>  Client - <i>Sending a job to the master server</i> <br>  Master - <i>Getting work from customers</i> <br>  Slave - <i>A master</i> - <i>dependent server that processes render frames.</i> <br><br>  <b>Customer</b> <br><br>  This can be any machine with Blender installed;  when the scene is ready, the ip and port of the master that receives the requests are configured, the number of frames required for rendering is set, then the task is sent to the master, which distributes it among the other servers. <br><br>  The following options are present in the client interface: <br><br>  <u>Animation on network</u> - the entire work is sent as soon as the first frames are ready, they are transferred to the client in .exr format for display in the editor. <br><br>  <u>Send job</u> - sends all selected frames to the master server, after clicking this button, ‚ÄúJob send‚Äù should appear in the information window, it may take some time if your .blend and textures take up enough space.  It will take even longer if the master is outside the local network and the channel to it is limited. <br>  It may even seem that Blender is frozen, check the network traffic and make sure that the client has started transferring data over the network.  This option immediately releases Blender for the next task, since it does not wait for the result of the wizard. <br><br>  <u>Send current frame job</u> - Sends only the selected frame, but keep in mind that, as in other cases, you need to send all the information (.blend and textures), so it will take as much time as it does when sending all the work. .  The result is not waiting, instantly freeing the client. <br><br>  After the wizard accepts the work, the transfer of the entire file and textures to the free slave will begin, it follows that it is better to locate them in one local network, otherwise we may get a large expenditure of traffic and another point of potential timeout. <br>  What we are trying to achieve is, by pressing a button, to continue working without thinking about what kind of server will be engaged in rendering, as well as problems that may arise. <br><br>  From time to time, you can glance at the web-interface built into the wizard (you can access it by clicking on ‚ÄúOpen Master Monitor‚Äù or typing in the browser (http: // host: ip) and retrieving the completed frames. There is no slavery in the work of the slave, this is the Blender distribution, which is passed through the file parameters and frame numbers to render, and as soon as the task is ready, it will transfer the result in .exr format to the master, .log file and accept the next batch of frames. <br>  The master, on the other hand, is a much more complex code whose task, in addition to interacting with the client, is to distribute the work and its frames among the available slaves.  The balance of the load has not yet been polished, and it is difficult to predict who exactly will get the next frame, nevertheless, in general, he copes with his task, at least I did not have to see idle slaves in accessible work. <br><br>  <b>Pick up the result</b> <br><br>  When several frames are ready, we can take them from the master, here at the moment there are at least two details, which, in my opinion, are worth telling. <br>  Firstly, the blender works in the .exr format, in fact, this means that each finished frame will be saved in an open HDR photo format, which gives good post-processing capabilities, but is far from ideal in terms of size.  Thus, our photo taken on a single remote server can very easily take more time to load, process and transfer than if we rendered it locally. <br>  Say, our .blend file takes 1mb + 512kb for textures, it is 1.5mb only for ‚Äúlifting‚Äù the work for the master, the master gives these 1.5mb for the slave (it‚Äôs still not possible to use a larger amount for one frame), the slave renders the render for 10 minutes and gives the .exr file to the master, if FullHD-like resolution was set, then except for the case of the machine of the 90s or a very good client-master connection, we will get a lot more later than if we used a local render. <br><br>  On this note, let me make a small digression: the fact is that, first, the network render is most often used by studios on the local network, with a channel of at least 1 gb / s, which greatly changes the situation.  Secondly, in many well-established programs for editing three-dimensional images, it is possible to use several machines when processing a single frame, there is a banal division of a picture into parts equal to the number of servers, or other methods are used that reduce the time spent on rendering in proportion to the number of servers involved . <br>  Since this function is not yet available in the blender, obviously, advantageous results can be achieved only when animating scenes with a sufficient number of frames to compensate for delays in loading and receiving files.  In addition, you should not forget about the possibility to completely unload the client after transferring the material to the render, which can be very useful if it is necessary to continue working on another project. <br><br>  <b>Instruments</b> <br><br>  For minimal installation, one client computer and one master / slave are required, since both functions can be implemented by one computer with the master and slave servers running at the same time.  Render speed will directly depend on the speed of the slave machine. <br><br>  <b>pros</b> <br><ul><li>  Easy installation - you only need to activate the plug-in and settings, as it is done through the blender interface </li><li> Full unloading of the client immediately after returning work </li><li>  Scalability up to the number of servers equal to the number of frames </li><li>  Identical to local render - there is no need to customize something with an eye to work on the network </li><li>  Theoretical compatibility between all systems.  - You can easily change from windows to linux and send the work, while one of the Linux slaves has turned into a mac (by the way, this is the merit of the python on which blender plugins are written) </li><li>  Promising collective opportunities - theoretically, an unlimited number of clients can theoretically send work to one master, the master himself will distribute them among the available slaves </li><li>  Priority tasks - when receiving a small work, the master will give it to one of the slaves as soon as he finishes a chunk-size portion of frames, even if his turn is not empty </li><li>  We take only the shots we need as they are ready from any browser or blender. </li><li>  The ability to pick up only .jpg frames without loading the channel, leaving heavy .exr files on the server </li></ul><br><br>  <b>Minuses</b> <br><ul><li>  Some difficulties when working on the Internet - if the connection with the master is interrupted, you have to start the transfer again, removing the unsuccessful attempts. </li><li>  Arbitrary timeouts - (in recent versions there are noticeably fewer) </li><li>  There is no possibility of multiple slave machines working on one frame. </li><li>  Nuances with external files - (for example, textures) when working together on different operating systems.  There have been annoying errors when connecting Linux to Win and Mac. </li><li>  Some functions do not work yet - (from examples you can mark video instead of texture) </li><li>  Before the rendering, the slave will be idle for some time, doing preprocessing (identical to the usual renderer, this is a minus only when compared with deluxeder) </li><li>  When the master stops, all the slave servers instantly fall off and have to be lifted by hands, this is all the more strange when you consider that when lifting the slave it will humbly wait for the connection regardless of whether it finds the master right away or not </li><li>  Any change in the settings of the master or server slave entails the pre-setting of these in the blender and then copying the finished .blend files to each server </li><li>  If the master server process aborts, we will lose the last job;  it is necessary to complete the wizard correctly so that the render can continue from the same place or pick up the result without direct intervention in the file structure (all finished frames in the .exr format will most likely be in place) </li></ul><br>  <b><u>Lux-Render</u></b> <br><br>  Luxrender is of interest in this review only to compare its capabilities with the capabilities of the internal network render in a blender, and there are many advantages to its advantages and disadvantages. <br>  Starting with version 0.8, the suite <a href="http://www.luxrender.net/wiki/Luxrender_and_OpenCL">has the opportunity to</a> use the power of modern video cards to calculate the intersections of light through OpenCL. <br>  The network render in the suite is promoted under the slogan ‚ÄúCPU vs. GPU?  CPU + GPU + network render is better ‚Äù, in the future, the developers promise to expand the use of video cards in the renderer, for now you shouldn‚Äôt hope for a miracle, the video card is unlikely to load more than 30%, although you can already observe a certain performance increase now. <br>  Unlike the internal network render, the Suite can combine several servers to work on one frame, the master server is not provided, the client partially performs its functions.  The whole system is reduced to one client and several slave servers, as soon as after using the suites of the plug-in work gets on the slave, it calculates several samples.  The result will be transferred back to the client after a certain period of time, where it will intersect with the result of the local render, and at the output we will get a picture with more samples than if the slave had not participated in the process. <br>  Tools: One client and one server, while they work in pairs and theoretically provide linear performance gains. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/7ec/27a/0f17ec27a52613a645a5046a15584438.jpg"></div><br><br>  <b>pros</b> <br><ul><li>  Combining any number of slave machines to work on one frame </li><li>  A visual representation of the degree of completion of the overall work on the frame </li><li>  The ability to alternate the rendering of several frames for animation </li><li>  The ability to use the power of not only the CPU, but also the <a href="http://www.luxrender.net/en_GB/gpu_support">video card of</a> each slave </li><li>  If necessary, you can save the result and continue rendering later. </li></ul><br>  <b>Minuses</b> <br><ul><li>  The client cannot be unloaded, as soon as it is stopped, the deluxe server will clear the queue and go on waiting for a new client. </li><li>  The selfish system of collective work "who first got up - that and sneakers", two clients for one slave can not connect </li><li>  With a large number of servers, adding them to the list can be compared with the work of the hosts file, which is at least inconvenient </li><li>  If, without waiting for the work to finish, after pressing the quit button to close the client, a particularly loaded slave may fall off, it will be necessary to restart manually, otherwise it will continue to wait for the nonexistent client </li></ul><br>  <b>Installation</b> <br><br>  Taking into account the fact that the network render of the suite will be used in some cases, when it is necessary to get a picture with ray tracing, and in others the internal network render, we can supply both. <br><br>  <b>Installation of Luxrader</b> <br><br>  First we go <a href="http://www.luxrender.net/wiki/LuxBlend_2.5_installation_instructions">to the site</a> and download the tip.zip file, this is a version under development, if you have a blender version newer than 2.58, it‚Äôs better to use it rather than a stable build.  Next, unpack the archive into the plugins folder and launch the blender, activate the suite in the plugins menu.  We will need the suite itself, which can be taken <a href="http://www.luxrender.net/en_GB/download">here</a> , it seems to me that Archiver is not better suited for our purposes, but this is to the taste. <br>  Those who have already dealt with this renderer simply customize everything, not forgetting that OpenCL support is available only with the choice: ‚ÄúRender: Hybrid (CPU + GPU)‚Äù, ‚ÄúSurface integrator: Path‚Äù and in ‚ÄúAdvanced &gt; Light strategy: one ‚Äù, otherwise select options at your discretion and leave‚Äú Sampler: Traditional CPU ‚Äù.  Next, set the path to our render in ‚ÄúPath to LuXrender installation‚Äù, and we can assume that half the work has been done. <br>  The server installation is described in detail on the <a href="http://www.luxrender.net/wiki/Network_rendering">wiki pages</a> , the main thing is to open the corresponding port on the server for access from the outside, in principle this command is enough: <code>luxconsole -s -p 10001</code> The suite will listen on TCP port 10001 (-p) in server mode ( -s), and we do not need more. <br>  Returning to the client, we set up LuxRender networking by adding our server to the list, for example: hostname: 10001 or IP: port. <br>  When you press F12, the luxury window should appear and in the Network tab we will see our server.  There should be no connection errors in the Log tab. <br>  We check the server load, if we see the processors under 100%, then as they say ‚Äúwater went to the hut‚Äù and the master will begin to give samples after a period of time specified in the ‚ÄúUpload interval‚Äù blender options.  If the connection has not been established, it will be possible to find out about it from the logs, most likely the port on the wizard has not opened, we can check by running telnet on it and write something in the console, you should see the typed text on the server. <br><br>  In short, the log contains entries similar to: <br><br>  [192.168.2.3:10001] 00:00:36 - 6T: 3.67 S / p 78.79 kS / s 99% Eff 77.86 kC / s - Using CPU <br>  Server: port, time (during which the server does the work), number of cores / tricks, number of samples per pixel, number of samples per second (in thousands), percentage of frame efficiency (average value between the number of samples per second and efficiency), the latter means Is it used on the OpenCL server for rendering? <br><br>  Here is another example: <br><br>  [192.168.2.4:10001] 00:06:38 - 4T: 25.92 S / p 51.20 kS / s 99% Eff 50.51 kC / s - Using CPU <br>  Translate: <br>  After 6:38 minutes of rendering, the server 192.168.2.4 on port 10001 managed to get 22.92 samples per pixel at a speed of 51.20 thousand samples per second and 99% of its efficiency is estimated at 50.51 thousand contributions per second using only the central processor. <br><br>  <b>Installing an internal network render</b> <br><br>  Everything you need to work is part of the blender, activate the netrender plugin in the settings, in the appropriate section, select the netrender and proceed to setup. <br>  First, it is easier to configure the wizard, select the port, leave the servername empty so that you can also receive requests on new interfaces without having to configure everything again. <br>  The temporary folder in Linux is better to give a separate partition on the hard disk, the main thing is not to forget to create it, otherwise the server will not start.  We leave Broadcast turned on, if the master is on the local network, then the client will be able to find it himself, but to do this you will need to open another UDP port (8000).  I do not recommend Clear on exit, it is better to be able to resume work, and saving on free space is not our task. <br>  Further, users of graphics can safely click "Start service" and continue to configure the slave server. <br>  The rest save the .blend file with the name master.blend, this is the configuration for our environment, it will be useful to us if the server does not have a graphical interface and there is no possibility to configure it.  We give the finished file to the server, we also need the startup.blend file, the user profile is saved in it, without it, the blender simply does not understand what it needs to activate the network render plugin, copy it to the user‚Äôs directory: (.blender / blender version / config / startup.blend), then we can start the server itself from the blender folder: (./ blender -b master.blend -a) <br>  It just means to start the blender (./blender), read the file (-b) and render all frames (-a).  The last parameter is answered by the netrender himself, (-a) we write only for the start, and this does not mean that all frames will always be rendered. <br>  After this, a legend should appear that the server is waiting for work, check by going to <a href="http://xn--80az8a/">our</a> ip: our port is the web interface of the wizard, through it we will be able to manage the work and monitor their progress, also it will allow us to quickly pick up the finished .jpg files but more on that later. <br>  So, we start the blender, configure it to work as a Client in the network render settings, register the IP and port, or press the button with two arrows, if we have specified Broadcast on the wizard.  As soon as we connect, we can send the work, in the browser window we will see that it was assigned a number and that it is in the Queued state - the waiting mode, in which the render does not occur, since the master is not suitable for this purpose, and we‚Äôve not configured.  Well, let's correct this omission. <br><br>  <b>Slave tuning</b> <br><br>  In the graphical interface, everything is simple, choose Slave in the options of the non-tender and find the master.  The number of threads should be equal to the number of processor cores (owners of intel can experiment).  We leave Auto-detect except for the cases when it is necessary to do something other than the render behind the slave, since in this case we will get a full load of all cores.  Thumbnails are a separate topic, the fact is that if we have several slave machines, in the event of a crash it is more convenient to collect information from one place, and not to go to each server, it is better to leave this option off, Clear on exit in this case we can activate Since filling up the hard disk at every slave with duplicates is a dubious task. <br>  If you need to start a slave on a server without a graphical interface, simply save the .blend file and upload it to the server, the startup method is identical to the master, it's easier not to get confused to use the name, say slave.blend. <br><br>  <b>Trial run</b> <br><br>  After connecting to the master, our slave should take his job and start rendering, after the number of frames specified by the ‚Äúchunk-size‚Äù parameter in the client, he will give the finished part of the work to the master and you can look at the result via the web, or load it into the blender with the ‚Äúget frame ‚Äù.  There are many programs that allow you to download a list of files from the server, flashget under Windows or wget under linux, for the latter the command loads the entire list: <br> <code><a href="http://xn--b1afb6bcb/"></a> wget :/thumb_ _{ .. }.jpg</code> <br>  eg: <br> <code><a href="http://192.168.2.3/"></a> wget 192.168.2.3:10001/thumb_1_{1..20}.jpg</code> <br>  Via flashget: The right button on the icon&gt; Add new&gt; Add batch download&gt; http://192.168.2.3:10001/thumb_1_ (*) ‚Äã‚Äã.jpg, then below we set the condition for frame loading. <br><br>  <b>Additional settings</b> <br><br>  In case of insufficient memory on the slave server, by increasing the number of ‚Äúchunks‚Äù of the frame in ‚ÄúRender&gt; Performance&gt; Tiles‚Äù, you can achieve the release of part of the RAM by sacrificing increased idle time when loading the processor thread. <br>  If the geometry on the scene or the speed of the server does not allow to render in less than five minutes, the wizard and the slave servers will most likely be disconnected. <br>  To solve this problem, inside the file "blender-version-linux-glibc27-x86_64 / version / scripts / addons / netrender / master.py" we find the variable "self.slave_timeout" and set the value equal to the number of minutes that we expect to take the render " chink-size ‚Äúframes of each slave (we naturally focus on the weak link). <br>  If you need to see the general statistics of the work, you can use this script (only under * NIX): <br>  <a href="http://blenderartists.org/forum/showthread.php%3F233628-Netrender-AWK-statistics-script">blenderartists.org/forum/showthread.php?233628-Netrender-AWK-statistics-script</a> <br><br>  That's all, beautiful to all renders. <br><br>  <b>useful links</b> <br><br>  <a href="http://wiki.blender.org/index.php/Doc:2.6/Manual/Render/Performance/Netrender">Official documentation of the network render</a> <br>  <a href="http://wiki.blender.org/index.php/Dev:2.6/Source/Render/Cycles/Devices">Note on Cycles network render support</a> </div><p>Source: <a href="https://habr.com/ru/post/198906/">https://habr.com/ru/post/198906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198896/index.html">Usability boarding pass: how to save two lives a year</a></li>
<li><a href="../198898/index.html">Quran by searching for duplicates in Google Spreadsheet</a></li>
<li><a href="../198900/index.html">Robotics for children. Request for comments</a></li>
<li><a href="../198902/index.html">Repetitive types of people in startups on enthusiasm</a></li>
<li><a href="../198904/index.html">Part 2. We divide our "pod" into modules. Use someone else's "pod" to develop your</a></li>
<li><a href="../198910/index.html">Jug to every city</a></li>
<li><a href="../198912/index.html">Programming language and database Q: syntax does not matter in the enterprise</a></li>
<li><a href="../198914/index.html">Epilogue of the Opera</a></li>
<li><a href="../198916/index.html">We write numpy-module to accelerate math functions using SIMD instructions</a></li>
<li><a href="../198918/index.html">linch.me - add annotations to the image</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>