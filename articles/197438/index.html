<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Linux Kernel EFI Boot Stub or "Self Loader"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 After reading a recent article Booting Linux without a bootloader , I realized two things: many people are interested in the ‚Äúnovelty‚Äù,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Linux Kernel EFI Boot Stub or "Self Loader"</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/05f/fbd/07e/05ffbd07ef263e029c186751e3b89ac5.png" alt="UEFI Tux Logo" align="left"><h4>  Introduction </h4><br>  After reading a recent article <a href="http://habrahabr.ru/post/196926/">Booting Linux without a bootloader</a> , I realized two things: many people are interested in the ‚Äúnovelty‚Äù, dating back as far as 2011;  the author did not describe the most basic, without which, in fact, nothing will work in some cases.  There was <a href="http://habrahabr.ru/post/165575/">also</a> another article, but either it is already outdated, or there, again, a lot of superfluous and unsaid at the same time. <br><br>  Specifically, the main point was missed - the kernel <abbr title="Processor Type and Features -> EFI Runtime Service Support -> EFI Stub Support">build</abbr> option <abbr title="Processor Type and Features -> EFI Runtime Service Support -> EFI Stub Support">CONFIG_EFI_STUB</abbr> .  Since in the latest versions of U (lu / ku / edu / * etc *) buntu, this option is already on by default, the author has no suspicions. <br>  As far as I know, at the moment it is included in the distributions of the above versions and above: Arch Linux, Fedora 17, OpenSUSE 12.2 and Ubuntu 12.10.  I also mentioned in the comments that Debian with the 2.6 kernel can, but this is nothing more than a backport from the latest versions.  On these distributions rebuild does not need anything at all!  But on the other, CONFIG_EFI_STUB is most likely either completely absent, since the option is available only from kernel version 3.3.0 or higher, or is disabled by default.  Accordingly, everything described below is valid for the kernel compiled with the CONFIG_EFI_STUB option. <br><br><h4>  So, what is the Linux Kernel EFI Boot Stub? </h4><br><h5>  general information </h5><br>  And nothing like ... "exe-file"! <a name="habracut"></a>  Yes, yes, <a href="http://ru.wikipedia.org/wiki/Portable_Executable">PE / COFF</a> .  Well, or rather, just zakos under it with a few modifications to please the <a href="http://ru.wikipedia.org/wiki/Extensible_Firmware_Interface">UEFI</a> loader.  You can verify this by reading the first 2 bytes of the kernel: <br><pre><code class="bash hljs">$ od /boot/vmlinuz-linux --address-radix=x --<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>-bytes=2 -t x1c 0000000 4d 5a MZ 0000002</code> </pre> <br>  Familiar, is not it?  At least for those who at least once ‚Äúfor interest‚Äù opened an MS-DOS or Windows executable file in a notebook, hex editor or something more abruptly.  These are the initials of <a href="http://en.wikipedia.org/wiki/Mark_Zbikowski">Mark Zbikowski</a> , who, in fact, developed this file format in MS-DOS.  The signature of this stub still hangs as a rudiment in modern Windows executable files, devouring as many as 64 bytes for each file! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The DOS header falls on a legacy code, which is executed when the kernel is booted as a boot sector, and swears in the MS-DOS style when running PE files: ‚ÄúDirect floppy boot is not supported.  Use a boot loader program instead.  Remove disk and press any key to reboot ... ".  Therefore, the information from this header here is garbage, except, in fact, the 'MZ' signature and the offset address of the next header. <br><br>  Go ahead. <br>  The PE / COFF specification tells us that at offset 0x3c there is a 32-bit offset of the second header with the signature "PE \ 0 \ 0": <br><pre> <code class="bash hljs">$ od /boot/vmlinuz-linux --address-radix=x --<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>-bytes=4 --skip-bytes=0x3c -t x4 00003c 000000b8 000040</code> </pre><br>  so, the offset is 0xb8, which is true for the current stable-core x86_64 architecture, on x86 it will be 0xa8.  We read: <br><pre> <code class="bash hljs">$ od /boot/vmlinuz-linux --address-radix=x --<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>-bytes=4 --skip-bytes=0xb8 -t x1c 0000b8 50 45 00 00 PE \0 \0 0000bc</code> </pre><br>  And here is the signature of the second header!  As you might guess, this is an abbreviation for the Portable Executable phrase, from which the payload begins in executable files. <br><br>  Even the Windows bootloader spat on half the fields of this header, and UEFI doesn't need them at all, so some of them are statically spelled out, while the important ones are filled during the kernel build.  Many "unnecessary" fields, all timestamps, control sums, etc. simply remain zeros.  The dimensions, offsets, entry point, etc. are filled in mainly. Therefore, it is possible with a stretch to call this PE file completely valid.  However, the classic LordPE or PETools utilities are quite content with their signatures and tell everything they know about the file: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd9/7ba/f46/bd97baf469786eea5159754c5a0c75de.png" alt="PE optional header"></div><br><br><img src="https://habrastorage.org/getpro/habr/post_images/897/f17/611/897f17611adf49c446413ab4aa7af058.png" alt="image" align="left">  The main difference from "real" executable files in Windows is the Subsystem flag of the optional header, which is set in IMAGE_SUBSYSTEM_EFI_APPLICATION, and not in IMAGE_SUBSYSTEM_WINDOWS_GUI for graphical or IMAGE_SUBSYSTEM_WINDOWS_CUI for symbolic devices that are used for symbolic displays that are applied to all the same in-house snapshots. <br><br><h5>  Structure </h5><br>  In general, everything is just like in a regular PE file.  Currently, the stable version 3.11.4 of the Arch Linux kernel is from the repositories, it contains 3 sections: '.setup', '.reloc' and '.text'. <br><br><ul><li>  Section .setup, contains mostly legacy code for initialization in case of loading in compatibility mode.  When booting into UEFI mode, all switchings of processor modes, initial initializations are done by flashing. </li><li>  The .reloc section is required by the loader, so when building the kernel an empty stub is created ‚Äúso that it is‚Äù. </li><li>  The most interesting section of .code, in fact, contains the EntryPoint and the main code of the rest of the kernel.  After the EFI-application is found, the loader executes the load service LoadImage, thereby loading the entire image into memory.  The type of residence depends on the Subsystem: EFI_APPLICATION field will be unloaded when it runs.  EFI_DRIVER can be Unloadable and will be unloaded only in case of a critical error.  Next, control is passed to the entry point, usually this is the efi_main () function - an analog of main () in C. </li></ul><br>  In fact, I was a little cunning, at the beginning I called the kernel an exe-file.  In fact, this is a simple EFI application for yourself, which uses the format of PE32 +. <br><br><h4>  Primary requirements </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/8e2/6c9/d7a/8e26c9d7ae886e24b968aa3dfff32fd0.jpg" alt="image" align="left">  First of all, you need to activate the boot mode EFI-mode.  The item can be called as the vendor ponders, usually located in the Boot Options tab.  If you see something like Legacy Mode or CSM (Compatibility Support Mode), or just BOIS Mode, change it to something like: (U) EFI Mode, Enhanced Mode or Advanced Mode. <br><br>  If the motherboard has the ‚ÄúWindows 8 Ready!‚Äù Logo, then most likely, the EFI Boot Mode is already activated by default. <br><br>  In most cases, to boot the Linux kernel into EFI-mode, you must turn off the Secure Boot option. <br><br><h5>  Disk partitioning </h5><br>  Many sources indicate that <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25B8%25D1%2586%25D0%25B0_%25D1%2580%25D0%25B0%25D0%25B7%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25BE%25D0%25B2_GUID">GPT</a> disk layout is required, not the <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BB%25D0%25B0%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B7%25D0%25B0%25D0%25B3%25D1%2580%25D1%2583%25D0%25B7%25D0%25BE%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B7%25D0%25B0%25D0%25BF%25D0%25B8%25D1%2581%25D1%258C">MBR</a> , but this is not the case.  UEFI is quite able to MBR.  Another thing, for example, Windows forcibly forces to break a disk with a new method in order to boot into EFI mode and swears at the antiquity of the Master Boot Record.  And rightly so!  Having marked the disc ‚Äúmodernly‚Äù we will not lose anything, we will only win. <br>  First, there will be no problems with all Primary / Logical partitions there, ‚Äúdon't go there - go here‚Äù and other rudiments. <br>  Secondly, even though nowadays SolidState disks are being promoted massively, in which the volumes are not very surprised yet, the size of the usual ‚Äúturntables‚Äù of several terabytes is no longer surprising.  But under the MBR, you can partition the partition with a maximum of about 2TB.  GPT, well, it sees <i>a lot</i> , you can not even call the figure - relatively small disks of this size will not appear soon. <br>  Well, plus all sorts of bonuses, such as duplicating a GPT record at the beginning and end of a disk, integrity checksums, etc., add a desire without hesitation to mark up a disk under GPT. <br><br>  You can find a huge amount of articles on how to split a disk with the help of various utilities in GNU / Linux. <br><br><h5>  Separate section </h5><br><h6>  Partition type </h6><br>  After nn-tsat years of developing standards, the engineers did decide that hardcode was not good.  Now it doesn‚Äôt matter where our boot partition is located, the UEFI boot loader is very simple: it goes through all the partitions and disks and searches for one special one.  Its peculiarity lies in the fact that in the case of the MBR markup, it is of the type with the code 0xEF (as you can guess from EFI).  In the case of GPT markup, the <a href="http://ru.wikipedia.org/wiki/GUID">GUID</a> <i>partition is C12A7328-F81F-11D2-BA4B-00A0C93EC93B</i> . <br><br>  There is some implicitness here.  All markup utilities, such as parted, have the property of setting and displaying the ‚Äúboot‚Äù flag, which is applied to the partition.  So, in the case of the MBR, this possibility does exist, that is, there is a real byte, which indicates to the BIOS that the partition is ‚Äúbootable‚Äù.  This flag can be put on any partition whose MBR we want to feed to BIOS for loading.  But when we are dealing with GPT, there really is no flag!  By this flag, parted means just a GUID equal to the above.  That is, in fact GPT boot flag = GPT EFI Partition! <div class="spoiler">  <b class="spoiler_title">parted</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># parted /dev/sda -l : ATA ST3750330AS (scsi)  /dev/sda: 750GB   (./.): 512B/512B  : gpt Disk Flags:         1 1049kB 135MB 134MB fat32 EFI System  2 135MB 269MB 134MB ext2 Linux filesystem 3 269MB 8859MB 8590MB linux-swap(v1) Linux swap 4 8859MB 30,3GB 21,5GB ext4 Linux filesystem 5 30,3GB 46,4GB 16,1GB ext4 Linux filesystem 6 46,4GB 67,9GB 21,5GB ext4 Linux filesystem 7 67,9GB 750GB 682GB xfs Linux filesystem</span></span></code> </pre></div></div>  gdisk does not suffer from this: <br><div class="spoiler">  <b class="spoiler_title">gdisk</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># gdisk /dev/sda -l GPT fdisk (gdisk) version 0.8.7 Partition table scan: MBR: protective BSD: not present APM: not present GPT: present Found valid GPT with protective MBR; using GPT. Disk /dev/sda: 1465149168 sectors, 698.6 GiB Logical sector size: 512 bytes Disk identifier (GUID): 02D11900-D331-4114-A3D7-8493969EF533 Partition table holds up to 128 entries First usable sector is 34, last usable sector is 1465149134 Partitions will be aligned on 2048-sector boundaries Total free space is 2014 sectors (1007.0 KiB) Number Start (sector) End (sector) Size Code Name 1 2048 264191 128.0 MiB EF00 EFI System 2 264192 526335 128.0 MiB 8300 Linux filesystem 3 526336 17303551 8.0 GiB 8200 Linux swap 4 17303552 59246591 20.0 GiB 8300 Linux filesystem 5 59246592 90703871 15.0 GiB 8300 Linux filesystem 6 90703872 132646911 20.0 GiB 8300 Linux filesystem 7 132646912 1465149134 635.4 GiB 8300 Linux filesystem</span></span></code> </pre><br></div></div><br>  <i>Conclusion:</i> if our EFI-partition is on the MBR - set the type of the EFI Partition partition <i>and</i> boot flag.  If GPT is <i>either</i> an EFI Partition type <i>or</i> boot flag, as they are the same. <br><br>  There are all sorts of things, such as the GPT legacy boot flag, which is installed in the Protective MBR, and so on, but all of these are crutches that are used only in compatibility mode.  In GPT mode, UEFI Boot should be ignored. <br><br><h6>  File system </h6><br>  In different sources they write differently.  Someone says that FAT16 can be used, someone even recommends FAT12.  But, isn't it better to follow the advice of the official specification?  And she says that the system partition should be in FAT32.  For removable-media (USB HDD, USB Flash) - also FAT12 / FAT16 in addition to FAT32. <br>  About the size of the section says nothing.  However, due to the initial crutch and boot implementations of the boot loaders and firmwares, the people found out experimentally that in order to avoid various ‚Äúsurprises‚Äù, a size of <b><i>at least 520MB (546MB) is recommended</i></b> .  Here, as lucky, there may be no problems with the 32 MB partition. <br><br><h5>  Directory structure </h5><br>  After the loader has found its ‚Äúlabeled‚Äù partition and made sure that it supports the file system, it starts performing all actions with paths relative to the root of the partition.  In addition, all files in this section should be located in the <i>\ EFI \</i> directory, which, in turn, is the only one in the root of the section.  By agreement, each vendor is recommended to allocate a folder with a unique name and place it in \ EFI \, for example: <i>\ EFI \ redhat \</i> , <i>\ EFI \ microsoft \</i> , <i>\ EFI \ archlinux \</i> .  In the vendor directory are directly executable efi-applications.  One file per architecture is recommended.  Files must have the <i>.efi</i> extension. <br><br>  For removable devices, the <i>\ EFI \ BOOT \</i> directory is intended.  It also recommends no more than one file for each architecture.  In addition to this, the file should be called <i>boot {arch} .efi</i> .  For example, <i>\ EFI \ BOOT \ bootx64.efi</i> .  Available architectures: <i>ia32, x64, ia64, arm, aa64</i> . <br><br><h5>  NVRAM access </h5><br>  By default, if nothing is written in the UEFI non-volatile memory, <i>\ EFI \ BOOT \ bootx64.efi</i> will be loaded.  To write the path to the necessary application in <a href="http://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BD%25D0%25B5%25D1%2580%25D0%25B3%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C">NVRAM</a> , you can use the efibootmgr utility.  Let's try to display current records: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># efibootmgr -v</span></span></code> </pre><br>  Some distributions require the kernel option CONFIG_EFI_VARS to be enabled for this utility to work. <br><br><h4>  Getting started </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/5ea/f83/2ec5eaf834a57abdfb4e25f367543111.png" alt="image" align="left">  So, we have allocated FAT32 EFI System Partition (ESP) with the size of <abbr title="with margin, as recommended by EFI specialist Roderick Smith">550MiB</abbr> .  Or, we have a second Windows system and have already created it.  True, she creates it usually about 100MB in size, but personally I have never had any problems. <br>  The / boot already has a kernel with EFI boot STUB support. <br><div class="spoiler">  <b class="spoiler_title">Check</b> <div class="spoiler_text">  To check if the option was enabled when building the kernel, run: <br><pre> <code class="bash hljs">$ zgrep CONFIG_EFI_STUB /proc/config.gz</code> </pre>  or <br><pre> <code class="bash hljs">$ zgrep CONFIG_EFI_STUB /boot/config-`uname -r`</code> </pre><br>  <b>CONFIG_EFI_STUB = y</b> means that the option is active. <br></div></div><br>  Next we have a bunch of options for the development of events: <br><ul><li>  You can mount <i>ESP \ {vendor} \</i> to <i>/ boot</i> via <i>mount --bind</i> by first copying the contents. <div class="spoiler">  <b class="spoiler_title">Exceptions</b> <div class="spoiler_text">  This item is only suitable for distributions that do not contain symbolic links in the <i>/ boot</i> directory.  For example, on openSUSE it will not be possible to mount, since it contains several links there, including the kernel itself. </div></div></li><li>  As an option, when updating the kernel, each time copy it and ram-disk to <i>ESP \ {vendor} \</i> </li><li>  You can put the EFI driver to read the <i>/ boot</i> file system and boot directly only by adding the extension '.efi' to the kernel (or better hardlink). </li></ul><br>  Now you need to somehow add the boot point in NVRAM UEFI.  Here again, many options: <br><br>  If we are already loaded in EFI mode (efibootmgr -v does not swear) using GRUB2, rEFInd, etc., then everything is fine: <br><ul><li>  We use efibootmgr, which can transmit kernel parameters. </li><li>  If efibootmgr kicks, you can use the <a href="">UEFI Shell</a> , which, like our kernel, is an EFI application.  Through his bcfg command it is possible to edit download points. </li><li>  Maybe this option: efibootmgr swears at adding parameters, then the firmware does not support their recording (or just a curve, which is more likely).  In the last article in the comments mentioned the kernel parameter <i><abbr title="available from kernel version 3.9.0-rc2">efi_no_storage_paranoia</abbr></i> , which can help.  But you can use it only if you are sure that your firmware is fully implemented in accordance with the specification!  The developers warn that if the vendor added crutches and gag during implementation, there is a non-illusory chance to materialize the brick in place of the motherboard. </li><li>  You can also boot via UEFI Shell.  For it, <a href="http://software.intel.com/en-us/articles/efi-shells-and-scripting">a</a> <i>startup.nsh</i> <a href="http://software.intel.com/en-us/articles/efi-shells-and-scripting">script</a> is created, in which the kernel boot command with the desired command line is specified.  And Shell, in turn, is added as a download point. </li><li>  There is one more problem: adding an item is possible only for one path of the kernel, while the ram-disk is not visible.  Most articles recommend recompiling a kernel with a built-in initrd.  I don‚Äôt know for sure if this is a kernel problem or a boot loader.  But at the moment in 90% of cases everything is supported and there is no need to rebuild the kernel. <br><div class="spoiler">  <b class="spoiler_title">Probable cause of delusion</b> <div class="spoiler_text">  Recommendations for embedding a ramdisk into the kernel were most likely due to a massive misreading of the path to it.  In early implementations of the EFI Boot Stub, the kernel did not spit a mistake about the wrong path to the ram-disk, but silently refused to boot.  Apparently, therefore, everyone began to massively introduce it into the kernel, having decided that it is not supported.  Although support for the initrd parameter exists since the very appearance of the Boot Stub feature in the kernel. </div></div><br>  IMPORTANT: The path to the ram disk is transmitted <i>absolute</i> through <i>backslashes "\"</i> , and not straight lines!  For example, <i>initrd = \ EFI \ archlinux \ initramfs-linux.img.</i> <i><br></i> <div class="spoiler">  <b class="spoiler_title">Exceptions for anarchists</b> <div class="spoiler_text">  In fact, kernels of versions above 3.8.0-rc5 do not see the difference between the forward and reverse slash - any will work.  But since the appearance of the Boot Stub feature in version 3.2.0-rc5, the path, written through straight slashes, the kernel simply did not see and silently refused to boot without errors.  Swearing mistakes about this, it learned in version 3.4.0. </div></div><br></li></ul>  If we only found out about the EFI boot mode and want to switch to it, in order to add boot points, we need <i>to</i> be in this mode, and we are still in compatibility mode ... There are two main solutions: <br><ul><li>  Download the first available live-cd with EFI boot support.  And from it already use the efibootmgr command. </li><li>  Download UEFI Shell.  From it, you can both boot into EFI mode, simply by specifying the kernel and ram disk, or edit boot items. </li></ul><br><h4>  Dualboot without bootloader </h4><br>  If you have 2 systems installed at the same time, and still do not want to install a third-party bootloader, you can add both to the UEFI boot points and adjust the preferred boot order.  The Windows boot loader is usually located in <i>\ EFI \ Microsoft \ BOOT \ bootmgfw.efi</i> . <br><br><h4>  Total </h4><br>  If everything is done correctly, reboot, call the Boot Menu, select the item we added and look at the almost instantaneous download.  In the case of SSD, FastBoot, Readahead and Arch Linux - about 3-4 seconds.  The home server has been loaded for a year without any third-party downloaders using EFI Boot STUB. <br>  Of course, the speed gain here is minimal, but, as people who know like <a href="http://www.rodsbooks.com/">Roderick Smith</a> write, sometimes in the EFI Boot mode, there is a ‚Äúmore adequate‚Äù initialization of the equipment than in compatibility modes. <br><br><h4>  Conclusion </h4><br>  Due to the relative dampness of the UEFI firmwares and completely different implementations, I did not give examples of code.  In each case, there may be a problem.  I hope the description I have described will help to understand the general principle and apply it to my case. <br>  I also recommend flashing the latest version of UEFI from the site of the motherboard manufacturer. <br><br><h4>  Literature </h4><br>  <a href="http://www.uefi.org/specs/download">UEFI official specifications</a> <br>  <a href="http://www.rodsbooks.com/">Roderick W. Smith's Web Page</a> is the author of many utilities related to EFI, downloaders and disk partitioning. <br>  <a href="https://wiki.archlinux.org/index.php/UEFI_Bootloaders">ArchWiki: UEFI Bootloaders</a> - permanent and one of the best and complete wiki on the GNU / Linux one of the distributions. <br>  <a href="http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx">Official PE / COFF specification</a> </div><p>Source: <a href="https://habr.com/ru/post/197438/">https://habr.com/ru/post/197438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../197422/index.html">Convenient utilities for android</a></li>
<li><a href="../197424/index.html">Digging into the data as a degree of freedom</a></li>
<li><a href="../197428/index.html">IT Professional Principles</a></li>
<li><a href="../197434/index.html">Concepts P2P social networks and Diaspora</a></li>
<li><a href="../197436/index.html">Oracle OpenScript: automated functional testing system</a></li>
<li><a href="../197442/index.html">Replenishment of Yandex.Money: any account from any (almost) card</a></li>
<li><a href="../197444/index.html">How to discern a forest behind trees: creating a three-dimensional image of the world's forests</a></li>
<li><a href="../197448/index.html">Google Maps API: location map, animation and styling</a></li>
<li><a href="../197450/index.html">As I did W-Mouse - a gaming mouse with unique abilities.</a></li>
<li><a href="../197452/index.html">Who needs interns?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>