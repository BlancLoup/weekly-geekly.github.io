<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>You just can not edit data</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Of course, you are constantly editing something and are well able to do it. What about data in a mobile application when you need to place a large num...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>You just can not edit data</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ba/k1/fs/bak1fshvkzhwiqek_g8hdemio_k.jpeg"><br><br><p>  Of course, you are constantly editing something and are well able to do it.  What about data in a mobile application when you need to place a large number of elements on the screen?  Do not forget that you need to do this as carefully as possible for the user, the effectiveness of which directly depends on the convenience of input.  The task ceases to be trivial. </p><br><p>  After reading the article, you will learn how: </p><br><ul><li>  organize data structure so that it is convenient to edit </li><li>  provide "dynamism" to your UI </li><li>  determine whether something has changed </li><li>  keep a history of changes </li><li>  make multiplayer in 5 minutes </li></ul><br><p>  At the end you will find a finished prototype with source code, demonstrating the described approach. </p><a name="habracut"></a><br><p>  We at 2GIS strive for the most accurate and current data.  One of the tools that provides this advantage is, in the literal sense, ‚Äúby-feet‚Äù.  In the fields, our specialists verify the data on the map and directory, and also collect a lot of data about the organization. </p><br><p>  <strong>The situation is complicated by the following requirements:</strong> </p><br><ul><li>  You need to add photos to any attribute of the processed object; </li><li>  know where and when the user edited a specific attribute; </li><li>  be able to roll back changes if necessary; </li><li>  add new attributes without changing the application; </li><li>  collect only the necessary list of data for this task; </li><li>  search for firms by various criteria and do it quickly. </li></ul><br><p>  In addition, you need to provide for crowdsourcing scenarios and the possibility of multi-user work on the same device, since different specialists can use the same device. </p><br><h2 id="gotovim-udobnye-dannye">  Preparing "convenient" data </h2><br><p>  We need not only to show the data, but also to edit it.  Consequently, the read / write storage is indispensable.  SQLite is suitable for us - it works perfectly for Android and includes all the necessary functionality. </p><br><p>  To ensure convenient data expansion and uniform work with various objects, it was decided to use JSON for storage.  Moreover, we described any object, be it a house, or a company, simply as a set of ‚Äúfields‚Äù (or attributes), so that a typical object began to look like this: </p><br><pre><code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-string"><span class="hljs-string">"BrandName"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-string"><span class="hljs-string">"NameDescription"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span> } ] }</code> </pre> <br><p>  In the simplest case, the values ‚Äã‚Äãwe have are stored in the string: True / False, number, date, range of numbers and dates.  More complex data for ease of serialization / deserialization is stored full-fledged objects and it looks like this: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldDto</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@SerializedName</span></span>(<span class="hljs-string"><span class="hljs-string">"code"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String code; <span class="hljs-comment"><span class="hljs-comment">//   @SerializedName("value") private String value; //    @SerializedName("r_values") private List&lt;Long&gt; referenceValues; //       @SerializedName("change_info") private ChangeInfoDto changeInfo; //    (  ) // EntityState @SerializedName("state") public int State; //  ( , , , ) public List&lt;Long&gt; getReferenceValues() { return this.referenceValues; } public void setChangeInfo(ChangeInfoDto changeInfo) { this.changeInfo = changeInfo; } public ChangeInfoDto getChangeInfo() { return this.changeInfo; } @Override public boolean equals(Object o) { if (o == null) return false; if (o == this) return true; if (!(o instanceof FieldDto)) return false; FieldDto other = (FieldDto) o; return this.code.equals(other.code); } public boolean isEmpty() { return StringHelperKt.isNullOrEmpty(this.value) &amp;&amp; (this.referenceValues == null || this.referenceValues.isEmpty()); } public void setRemovedState() { State = EntityState.STATE_REMOVED; } }</span></span></code> </pre> <br><p>  The idea is as follows.  We have an attribute uniquely identified by its code.  It has some value that may or may not be present (isEmpty method).  In addition, we are able to compare the values ‚Äã‚Äãof two attributes (equals method). </p><br><p>  The complex attributes of the type of work time in our implementation are highlighted by separate properties.  There are few such attributes, so they will not strain with their constant appearance.  The main mass of attributes is placed in a simple line or in references to the r_values ‚Äã‚Äãdirectory.  In the example above, I just left them for simplicity. </p><br><p>  You probably paid attention to the ‚Äústate‚Äù and ‚Äúchange_info‚Äù attributes - we will need them to understand whether the value of the field has changed, where and when it was changed. </p><br><p>  This is quite enough to describe any of our essence: the house, the entrance to the house, the fence, sight, firm. </p><br><p>  The only thing we lack is descriptions of how we should show attribute codes to the user. </p><br><p>  This will help us another entity - configuration fields (attributes).  It must contain the name and type of the field so that we can create an appropriate control to edit its value. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldSetting</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TYPE_TEXT = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     public static final int TYPE_BOOL_SINGLE = 2; //    public static final int TYPE_BOOL_MULTY = 3; // True  False public static final int TYPE_BOOL_SIMPLE = 13; public static final int TYPE_INT = 4; public static String ATTRIBUTE_START_GROUP = "start_group"; public static String ATTRIBUTE_END_GROUP = "end_group"; private final long id; private final int type; private final String name; private final Long parentId; private final String parentName; private final String fieldCode; private final String referenceCode; public FieldSetting(long id, int type, String name, String parent_name, Long parentId, String fieldCode, String referenceCode) { this.id = id; this.type = type; this.name = name; this.parentName = parent_name; this.parentId = parentId; this.fieldCode = fieldCode; this.referenceCode = referenceCode; } public int getType() { return type; } public String getName() { return name; } public Long getParentId() { return parentId; } public String getParentName() { return parentName; } public String getFieldCode() { return fieldCode; } public String getReferenceCode() { return referenceCode; } public long getId() { return id; } }</span></span></code> </pre> <br><p>  Simplified, you can imagine it like this: </p><br><img src="https://habrastorage.org/webt/c1/co/2t/c1co2t07tzikidqcel9skqrxex4.png"><br><h2 id="organizuem-prostoe-hranilische">  Let's organize simple storage </h2><br><p>  Let us turn to the issue of storage in the database, because we do not just need to tamp the data into some kind of table, we also need to organize search, indexing and add links between objects. </p><br><p>  The decision to store data in JSON immediately simplifies our life from the point of view of the DBMS: there is no need to make tables for each entity, we actually work in terms of the ‚Äúdocument‚Äù.  But we still need some connections between the objects.  For example, to show a list of all organizations in a building. </p><br><p>  In the case of the 2GIS data structure, the parent-child connection is enough in 90%, so the easiest way is to place it directly in the object itself.  But in general, without a table of links can not do. </p><br><p>  The final structure of the tables will look like this: </p><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--    CREATE TABLE object_data ( id INTEGER NOT NULL, -- ID  type INTEGER NOT NULL, --   (,   ..) attributes TEXT, --   JSON  parent_id INTEGER, -- ID   (,   ) PRIMARY KEY ( id ) ); --    CREATE TABLE object_data_history ( id INTEGER NOT NULL, -- ID  version INTEGER NOT NULL, --   type INTEGER NOT NULL, --   attributes TEXT, --   JSON  parent_id INTEGER, -- ID   PRIMARY KEY ( id, version ) ); --   CREATE TABLE field_settings ( id INTEGER NOT NULL, -- ID  field_code TEXT, --   object_type INTEGER NOT NULL, --   (,   ..) type INTEGER NOT NULL, --   (, ,   ..) name TEXT, --   reference_code TEXT --   PRIMARY KEY ( id ) ); --   CREATE TABLE reference_items ( id INT NOT NULL, -- ID   ref_code TEXT NOT NULL, --   code INTEGER NOT NULL, --    name TEXT NOT NULL, --  sortpos INTEGER NOT NULL, --  PRIMARY KEY ( id ) ); --  CREATE TABLE relations ( parent_id INTEGER NOT NULL, -- ID  child_id INTEGER NOT NULL, -- ID  type INTEGER NOT NULL --   ); --   (  ) CREATE TABLE template_data ( id INTEGER NOT NULL, type INTEGER NOT NULL, name TEXT NOT NULL, json TEXT NOT NULL, PRIMARY KEY (id, type) ); --   CREATE VIRTUAL TABLE search_data USING fts5(content="", name)</span></span></code> </pre><br><p>  That's all.  In a simple case, this is sufficient for the implementation of the requirements declared at the beginning of the article. </p><br><p>  I draw your attention to the fact that JSON in object_data.attributes is stored as text.  To save space, which will take quite a lot, it is better to store it as a BLOB and compress while saving. </p><br><p>  An alternative simple option is to use a plugin for <a href="https://www.hwaci.com/sw/sqlite/zipvfs.html">Sqlite</a> , which allows you not only to compress, but also to encrypt data.  True, it is paid. </p><br><p>  The attentive reader must have noticed the object_data_history table.  It completely duplicates object_data, adding only the version of the object, and allows you to save the change history with the desired "depth".  If desired, it will be possible not only to display data on the screen without any significant modifications of logic, but also to easily ‚Äúroll back‚Äù the state of the object to the desired version.  In addition, the history will be useful for determining whether an object has changed. </p><br><h2 id="delaem-horoshiy-poisk">  Making a "good" search </h2><br><p>  Overboard we have left only the search.  And here again SQLite will help us, which provides at least a limited, but, nevertheless, less full text search ( <a href="https://sqlite.org/fts5.html">FTS</a> ).  The good old indexes, by the way, have not gone away anywhere and will also be useful. </p><br><p>  There is one nuance.  FTS is not included in the Android SQLite distribution.  In addition, the library has other useful extensions that you may need.  Therefore, you will have to either find a ready-made assembly with everything you need, or assemble yourself, which is not at all difficult.  To do this, read the <a href="">manual</a> and do everything in steps.  Further it will be necessary only to connect the received aar to your project and replace all links with android.database.sqlite.SQLiteDatabase with your org.sqlite.database.sqlite.SQLiteDatabase package. </p><br><p>  But back to the FTS.  Using content-less tables (see the table search_data) allows you to build a full-text index without duplicating data, and we can easily organize a search by company name, its contacts and rubrics.  Moreover, the index can be updated on the fly when editing data or adding new ones, so that everything at once becomes searchable.  The fire! </p><br><p>  If you need additional criteria for the search (for example, in our case, you need to be able to filter organizations tied to a specific entrance in the building), then you can create the appropriate table for a specific object type with the necessary indices.  It is clear that the data will be duplicated, but our main goal is the data editing mechanism; we are not experiencing much of a place. </p><br><p>  An example of filters that are used in our application looks like this: </p><br><img src="https://habrastorage.org/webt/su/bg/eq/subgeqzdqfux4kelil1yirtikfa.png" width="50%" height="50%"><br><br><p>  Thus, any view on which we will display data entry fields must contain a layout to which you can add children, for example: </p><br><pre> <code class="java hljs">&lt;?xml version=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span> encoding=<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>?&gt; &lt;LinearLayout xmlns:android=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:orientation=<span class="hljs-string"><span class="hljs-string">"vertical"</span></span> xmlns:app=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span></span>&gt; ... &lt;android.support.v4.widget.NestedScrollView android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:fillViewport=<span class="hljs-string"><span class="hljs-string">"true"</span></span> &gt; &lt;LinearLayout android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"wrap_content"</span></span> android:orientation=<span class="hljs-string"><span class="hljs-string">"vertical"</span></span> &gt; &lt;LinearLayout android:id=<span class="hljs-string"><span class="hljs-string">"@+id/fev_content"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"wrap_content"</span></span> android:minHeight=<span class="hljs-string"><span class="hljs-string">"20dp"</span></span> android:orientation=<span class="hljs-string"><span class="hljs-string">"vertical"</span></span>&gt; &lt;/LinearLayout&gt; ... &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;/LinearLayout&gt;</code> </pre> <br><p>  The implementation of the addition will look like this: </p><br><pre> <code class="java hljs">vContent = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainView.findViewById(R.id.fev_content); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addLayoutView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DynamicView view)</span></span></span><span class="hljs-function"> </span></span>{ vContent.addView((View) view.getView()); }</code> </pre> <br><p>  We introduce the abstraction DynamicView, which allows us to hide the implementation details of a specific control for editing some type of attribute: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicView</span></span></span><span class="hljs-class"> </span></span>{ val view: Any val fieldCode: <span class="hljs-function"><span class="hljs-function">String fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getViewGroup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: DymamicViewGroup? fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setViewGroup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewGroup: DymamicViewGroup)</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: FieldDto? fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: FieldDto)</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Boolean fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(templateItem: EditObjectTemplateDto.ItemDto)</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br><p>  And immediately we introduce the concept of a template and a template element, which we need just to support ‚Äúdynamism‚Äù.  We want to be able to change the UI right on the fly depending on some criteria.  To do this, use the description of the template in JSON: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"photos"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"start_group"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"group_name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"bold_caption"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"show_header"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"caption"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"c_name"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"NameDescription"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"OrganizationLegalForm"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"caption"</span></span>: <span class="hljs-string"><span class="hljs-string">". "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"LegalName"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"end_group"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"c_address_name"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"validator"</span></span>: <span class="hljs-string"><span class="hljs-string">"required"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"start_group"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"layout_orientation"</span></span>: <span class="hljs-string"><span class="hljs-string">"horizontal"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"ref_point"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"edit_control_type"</span></span>: <span class="hljs-number"><span class="hljs-number">18</span></span>, <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"Floor"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"end_group"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"AddressDescription"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"edit_control_type"</span></span>: <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"loc_verification"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"field_code"</span></span>: <span class="hljs-string"><span class="hljs-string">"end_group"</span></span> } ] }</code> </pre> <br><p>  The template determines the list and order of the attributes that we will edit on the screen.  If necessary, you can combine controls into groups using start_group / end_group, select bold_caption headers or hide them completely with show_header. </p><br><p>  There is another important tag - edit_control_type.  It defines the type of control with which the attribute will be edited.  For example, if we in one case want to see radio buttons, and in the other, use switch to edit Boolean attributes. </p><br><p>  In general, in the description of the template, you can enter any flexibility you need to support the necessary requirements, but its main purpose is visibility and order of attributes. </p><br><img src="https://habrastorage.org/webt/6x/ix/zl/6xixzlrc2y7lwwnophhtu5gtvaq.png"><br><h2 id="obedinyaem-vsyo-vmeste">  Putting it all together </h2><br><p>  The magic on the formation of the view will be placed in the presenter.  He will be engaged in creating controls for editing each attribute, placing them on the screen, mapping object data to these controls and saving changes to the database. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicViewPresenterBase</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TDto</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleDto</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TView</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicViewContainer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> lateinit <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> views: MutableList&lt;DynamicView&gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> lateinit <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> template: EditObjectTemplateDto internal lateinit <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> containerView: TView internal lateinit <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dto: TDto <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val removedFields = HashSet&lt;String&gt;() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dto: TDto, containerView: TView)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.containerView = containerView <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dto = dto val configuration = getFieldsConfiguration(fieldsConfigurationService) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.template = editTemplate <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.views = ArrayList(configuration.size) addDynamicViews(configuration) onInit(configuration) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDynamicViews</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(configuration: List&lt;FieldConfiguration&gt;)</span></span></span><span class="hljs-function"> </span></span>{ val groupStack = Stack&lt;DymamicViewGroup&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastViewGroup: DymamicViewGroup? = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> val processedFields = HashSet&lt;String&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (templateItem in <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.template.Items) { ... val config = getFieldConfiguration(configuration, templateItem.FieldCode) ?: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> processedFields.add(config.fieldCode) processField(lastViewGroup, templateItem, config) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lastViewGroup: DymamicViewGroup?, templateItem: EditObjectTemplateDto.ItemDto, config: FieldConfiguration)</span></span></span><span class="hljs-function"> </span></span>{ val view = getDynamicView(templateItem, config) views.add(view) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastViewGroup != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { lastViewGroup.addView(view) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.containerView.addLayoutView(view) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDynamicView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(templateItem: EditObjectTemplateDto.ItemDto, config: FieldConfiguration)</span></span></span><span class="hljs-function">: DynamicView </span></span>{ val view = fieldViewFactory.getView(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.containerView, config, templateItem) val field = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dto.getField(config.fieldCode) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { view.setValue(field) } view.setTemplate(templateItem) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOkClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initialDto: TDto? = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> val beforeSaveDtoCopy = dtoCopy <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dto.IsInAddingMode()) { initialDto = getInitialDto() } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: DataContextException) { onGetInitialDtoError(e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } val fields = getFieldFromView(initialDto) dto.setFields(fields, removedFields) dto.changeInfo = locationManager.<span class="hljs-function"><span class="hljs-function">changeInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillRemovedFields</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dto, initialDto)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">try</span></span></span><span class="hljs-function"> </span></span>{ val hasChanges = dto.IsInAddingMode() || initialDto != <span class="hljs-function"><span class="hljs-function">dto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hasChanges || beforeSaveDtoCopy != </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; beforeSaveDtoCopy != dto)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasChanges) { dto.changeInfo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } saveObject(dto, initialDto) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { undoChanges(dto, initialDto) } afterSaveObject() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: DataContextException) { onSaveError(e) } } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">undoChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dto.IsInAddingMode()) { val initialDto = getInitialDto() undoChanges(dto, initialDto) closeView() } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: DataContextException) { onGetInitialDtoError(e) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBackButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hasChanges = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">false</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value in views)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.fieldCode == FieldSetting.FIELD_START_GROUP) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value.hasChanges()) { hasChanges = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasChanges) { closeView() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } containerView.showCloseAlertDialog() } ... }</code> </pre> <br><p>  In the init method, we get the configuration by the getFieldsConfiguration method.  This is a list of the attributes available for this type of object.  Then we take an editing template that determines the appearance of the screen, and in the addDynamicViews method we create all controls and add them via addLayoutView to the parent layout. </p><br><p>  When saving changes to the onOkClick method, we refer to the object's initial state to determine if something has changed in the current state, and then to the table with the object_data_history history to determine if something has changed from its very first version. </p><br><p>  If the current state has not changed - do nothing. </p><br><p>  If you returned to the first version, we roll back the changes. </p><br><p>  If this is a new state, update object_data_history. </p><br><p>  If the user has clicked ‚Äúback‚Äù - using the same mechanism we can warn him about the need to save changes.  And all this is achieved by a simple test for equality of the attributes of the object. </p><br><h2 id="realizaciya-redaktirovaniya-strokovogo-atributa">  Implementing String Attribute Editing </h2><br><p>  Let's look at how the implementation of a control for editing a string attribute looks like.  We are required to implement DynamicView.  Let's take a look at the code: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">open class EditTextFactory internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(commonServices: UICommonServices)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewFactoryBase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(commonServices)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(container: DynamicViewContainer, configuration: FieldConfiguration)</span></span></span><span class="hljs-function">: DynamicView </span></span>{ val mainView = getMainView(inflater) val editText = mainView.findViewById&lt;EditText&gt;(R.id.det_main_text) ... val dynamicView = object : DynamicEditableViewBase(locationManager) { override val view: <span class="hljs-function"><span class="hljs-function">View </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= mainView override val currentValue: <span class="hljs-function"><span class="hljs-function">FieldDto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= FieldDto(configuration.fieldCode, editText.text.toString()) override val fieldCode: <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= configuration.<span class="hljs-function"><span class="hljs-function">fieldCode override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: FieldDto)</span></span></span><span class="hljs-function"> </span></span>{ initialValue = value editText.setText(value.value) } } editText.setOnFocusChangeListener { v, hasFocus -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasFocus) { dynamicView.rememberChangeLocation() } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dynamicView } }</code> </pre> <br><p>  Everything is pretty trivial.  We create an EditText, set the value in the setValue method, set the current value in the getCurrentValue method, and subscribe to the focus loss event to remember where and when the user changed it. </p><br><p>  In the base implementation, the setInitialValue method is intended to preserve the original value.  rememberChangeLocation records the date and place of the change.  And the setChangeInfo method does all the magic: compares the current attribute value with the original one, determines the status of the attribute change, and sets changeInfo. </p><br><p>  The rest of the controls are implemented in the same way, it makes no sense to consider them further.  An example of the design of some of them is presented below. </p><br><img src="https://habrastorage.org/webt/3-/y4/xn/3-y4xnw1ihq6l23tcharhdfbhq4.png" width="50%" height="50%">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  The only thing you want to pay attention to is in the photo.  According to the requirements, we need a mechanism by which we can bind any photo to the desired attribute. </p><br><p>  We used a simple solution - added tags to the pics.  Moreover, the set of tags is determined by the type of object, and the tags themselves may correspond to attributes, although not necessarily. </p><br><p>  On the screen, it looks like this: </p><br><img src="https://habrastorage.org/webt/bz/fx/zq/bzfxzqakkagbecyw2gwlcxzed9e.png" width="50%" height="50%"><br><p><br>  User takes a picture, indicates the necessary tags.  A specialist in the office will be able to add all the necessary data to the system.  You can go ahead and make automatic recognition of the necessary information in the picture, for example, to find the TIN or OGRN.  This is in our age of spacecraft is done elementary right on the device. </p><br><p>  The final structure of relationships is as follows: </p><br><img src="https://habrastorage.org/webt/q7/uv/h1/q7uvh13ada-t7ulfxnkmmja8ysm.jpeg"><br><p>  Editing templates can be stored as you like, we add them to the database and deliver them to the application from the server upon receipt of changes.  This allows you to change screens right on the fly, just enough to download new templates. </p><br><p>  You can further develop the implementation using the same mechanism for viewing information.  It is enough to make a template for editing a company and for viewing it.  There will be two templates and two screens, but both will be dynamically configured using the approach described above. </p><br><h2 id="mnogopolzovatelskiy-rezhim-za-pyat-minut">  Multiplayer mode in five minutes </h2><br><p>  Let's talk now about the multiplayer mode.  At the beginning of the article I promised to show how to make it in five minutes.  And here again the chip SQLite will help us.  See, from the point of view of data preparation, our reality looks like this: </p><br><img src="https://habrastorage.org/webt/hu/hm/6j/huhm6j1iiopoi5md2m7y1csazmg.jpeg"><br><br><p>  There is an export on the back, which collects data from all internal systems, cuts them into "regions" and unloads all the necessary region.sqlite - all attributes by geo-objects and by firms. </p><br><p>  "Regions" user downloads to his phone - this is common to all data.  If different people work with the same device, they use the same data from the ‚Äúregion‚Äù. </p><br><p>  The work they do to collect new organizations and update existing ones should be personalized: each user has his own tasks and his own results.  We fix this data in the user.sqlite database.  To make it convenient to retrieve them from the database and make joins with the region data, we use the command <br>  <a href="https://www.sqlite.org/lang_attach.html">ATTACH database</a> in SQLIte. </p><br><p>  There is no need to keep any connections with users within one base, it is enough to make your base for each user and attach a region.  If the user is in a different region, simply attach this region.  The rest works automatically. </p><br><p>  This simple team simply dramatically, almost to zero, reduces labor costs in the scenario of multi-user work. </p><br><h2 id="pro-dostavku-obnovleniy-s-servera">  About delivering updates from the server </h2><br><p>  Since all the data we have actually laid in one table in the simplest case, then we only need to add the version of the data to the base of the region.  We use back-end versioning on the backend, which greatly simplifies life. </p><br><p>  This means that we need only one number - the maximum version of the data at the time of unloading, which we save to the base of the region.  To get updates, just transfer this version and get all changes and deletions.  The API method here looks like this: </p><br><pre> <code class="hljs 1c">/api/regionchanges?region_id<span class="hljs-meta"><span class="hljs-meta">&amp;entity_type&amp;max_version</span></span></code> </pre> <br><p>  In general, receiving data from the server is indirectly related to the topic of the article.  I mentioned it only because you can use this mechanism if you want to deliver editing templates, not an application.  Those.  we, to change the editing screen, just go to the server and get fresh templates.  Pretty obvious and easy to implement. </p><br><p>  <strong>In conclusion, I</strong> would like to say that the relative simplicity of the solution lies in a simple data structure.  The correct organization of the data allowed to close a significant part of the requirements, and the finished technical solutions and patterns coped with the rest. </p><br><p>  Feel free to use: </p><br><ul><li>  storing attributes in JSON </li><li>  building a UI based on a template </li><li>  SQLite tokens (attach database, FTS and other extensions) </li></ul><br><p>   ,                      .   ,     ,     . </p><br><p>            <a href="https://github.com/viloboda/DynamicEditor/"></a> . </p></div><p>Source: <a href="https://habr.com/ru/post/366089/">https://habr.com/ru/post/366089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../366077/index.html">Virtual reality glasses "budget" (so far without a tracker)</a></li>
<li><a href="../366079/index.html">Ministry of Communications proposes to reform the law on copyright protection</a></li>
<li><a href="../366081/index.html">Hollywood producers against the arrangement of hobby holes in the UK</a></li>
<li><a href="../366085/index.html">Levitation of non-magnetic objects</a></li>
<li><a href="../366087/index.html">Ask Ethan # 22: the lack of birthday paradox</a></li>
<li><a href="../366091/index.html">Mass spectrometric leak detector PTI-10</a></li>
<li><a href="../366095/index.html">[Video] Journey from the Sun to Jupiter at the speed of light</a></li>
<li><a href="../366097/index.html">The startup intends to release a pocket ghost detector</a></li>
<li><a href="../366099/index.html">Engineers have created a robot that can sort clothes</a></li>
<li><a href="../366101/index.html">Pocket HiFi Hidizs AP100 player</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>