<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PHP performance: we plan, profile, optimize</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! Two years ago we wrote about how we switched to PHP 7.0 and saved a million dollars. On our load profile, the new version turned out to be t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PHP performance: we plan, profile, optimize</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/k_/fe/vv/k_fevvrhhn2aruuz19gpne_jypy.jpeg"><br><br>  Hi, Habr!  Two years ago we <a href="https://habr.com/company/badoo/blog/279047/">wrote</a> about how we switched to PHP 7.0 and saved a million dollars.  On our load profile, the new version turned out to be twice as efficient in terms of CPU usage: the load that we had previously served ~ 600 servers, after the transfer, we started to serve ~ 300.  As a result, for two years we had a reserve capacity. <br><br>  But Badoo is growing.  The number of active users is constantly increasing.  We are improving and developing our functionality, so that users spend in the application more and more time.  And this, in turn, is reflected in the number of requests, which in two years has increased 2-2.5 times. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We found ourselves in a situation where the double performance gain was leveled by more than twice the growth of requests, and we again began to approach the limits of our cluster.  In the PHP core, useful <a href="https://habr.com/company/badoo/blog/415359/">optimizations</a> are expected again (JIT, preloading), but they are planned only for PHP 7.4, and this version will be released not earlier than in a year.  Therefore, the trick with the transition now can not be repeated - you need to optimize the application code itself. <br><br>  Under the cut, I will tell you how we approach such tasks as using tools, and give examples of optimizations, ideas and approaches that we use and which helped us in due time. <br><a name="habracut"></a><br><h1>  Why optimize </h1><br>  The easiest and most obvious way to solve a performance problem is to add iron.  If your code runs on one server, then adding another one will double the performance of your cluster.  Translating these costs to the developer‚Äôs working time, we ask ourselves: can he get a two-fold increase in productivity during this time through optimizations?  Perhaps, yes, and, perhaps, no: it depends on how optimally the system is already working and how good the developer is.  On the other hand, the purchased server will remain in the ownership of the company, and the time spent will not be returned. <br><br>  It turns out that in small volumes the correct solution will often be the addition of iron. <br><br>  But take our situation.  Now, after the gain from the transition to PHP 7.0 was offset by the growth of activity and the number of users, we again have 600 servers serving requests to a PHP application.  In order to increase capacity by one and a half times, we need to add 300 servers. <br><br>  Take for the calculation of the average cost of the server - 4000 dollars.  300 * 4000 = 1,200,000 dollars - the cost of increasing capacity by half. <br><br>  That is, in our conditions, we can invest a significant amount of working time in optimizing the system, and it will still be more profitable than buying iron. <br><br><h1>  Capacity planning </h1><br>  Before you do something, it is important to understand whether there is a problem.  If it is not, then it is worth trying to predict when it may appear.  This process is called capacity planning. <br><br>  A concrete indicator of performance problems is response time.  After all, in fact, it does not matter if the CPU (or other resources) is 6% or 146% loaded: if the client receives the service of the required quality in a satisfactory time, then everything works well. <br><br>  The lack of focus on response time is that it usually begins to increase only when the problem has already appeared.  If it is not there yet, then it is difficult to predict its appearance.  In addition, the response time reflects the results of the influence of all factors (braking services, network, disks, etc.) and does not provide an understanding of the causes of problems. <br><br>  In our case, the bottleneck is usually the CPU, so when planning the size and performance of clusters, we primarily pay attention to the metrics associated with its use.  We collect CPU usage from all of our machines and build graphs with average value, median, 75th and 95th percentile: <br><br><img src="https://habrastorage.org/webt/pt/xs/dr/ptxsdr6jybv45cznqjykeqd11_g.png"><br>  <i>CPU load of cluster machines in percent: average, median, percentile</i> <br><br>  In our clusters, hundreds of machines that have been added there over the years.  They are different in configuration and performance (the cluster is not homogeneous).  Our balancer takes this into account ( <a href="https://habr.com/company/oleg-bunin/blog/310366/">article</a> and <a href="https://tech.badoo.com/ru/presentation/135/kak-my-sdelali-rovnuyu-balansirovku/">video</a> ) and loads the machines according to their capabilities.  In order to control this process, we also have a schedule of maximum and minimum loaded machines. <br><br><img src="https://habrastorage.org/webt/nf/we/f7/nfwef7cixau-uxenwsglrnvfzho.png"><br>  <i>Most and least loaded cluster machines</i> <br><br>  If you look at these graphs (or simply at the output of the top command) and see the CPU load at 50%, then you would think that we still have a margin to double the load.  But in fact, this is usually not the case.  And that's why. <br><br><h1>  Hyper-threading </h1><br>  Imagine one core without hypertreding.  Load it with one CPU-bound-thread.  We will see in the top download at 100%. <br><br>  Now we will enable hypertreaming on this core and load it in the same way.  In the top we will see already two logical cores, and the total load will be 50% (usually on one 0%, and on the other - 100%). <br><br><img src="https://habrastorage.org/webt/gr/zi/hw/grzihwfkj986zatrfrsrgg4-ykk.png"><br>  <i>CPU utilization: data top and what actually happens</i> <br><br>  As if the processor is only 50% loaded.  But there was no physically additional free core.  Hypertrending allows <i>in some cases</i> to perform more than one process on one physical core simultaneously.  But this is far from a doubling of performance in typical situations, although on the CPU usage graph this also looks like another half of the resources: from 50% to 100%. <br><br>  This means that after 50% of CPU usage, when hyper-trading is enabled, it will not grow in the same way as it grew before. <br><br>  I wrote the following code for demonstration (this is a kind of synthetic case, in reality the results will differ): <br><br><div class="spoiler">  <b class="spoiler_title">Script code</b> <div class="spoiler_text"><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $concurrency = $_SERVER[<span class="hljs-string"><span class="hljs-string">'argv'</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] ?? <span class="hljs-number"><span class="hljs-number">1</span></span>; $hashes = <span class="hljs-number"><span class="hljs-number">100000000</span></span>; $chunkSize = intval($hashes / $concurrency); $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $children = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $concurrency; $i++) {    $pid = pcntl_fork();    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> === $pid) {        $first = $i * $chunkSize;        $last = ($i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * $chunkSize - <span class="hljs-number"><span class="hljs-number">1</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($j = $first; $j &lt; $last; $j++) {            $dummy = md5($j);        }        printf(<span class="hljs-string"><span class="hljs-string">"[%d]: %d hashes in %0.4f sec\n"</span></span>, $i, $last - $first, microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) - $t1);        <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>;    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        $children[$pid] = <span class="hljs-number"><span class="hljs-number">1</span></span>;    } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count($children) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {    $pid = pcntl_waitpid(<span class="hljs-number"><span class="hljs-number">-1</span></span>, $status);    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($pid &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($children[$pid]);    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-string"><span class="hljs-string">"Got a error pid=$pid"</span></span>);    } }</code> </pre> <br><br></div></div><br>  I have two physical cores on my laptop.  Run this code with different input data to measure the performance of its work with a different number of parallel processes C. <br><br><div class="spoiler">  <b class="spoiler_title">Measurement results</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/n5/3z/ev/n53zevyyvda4w4u-2xkjryqlj9m.png"><br></div></div><br>  Build a schedule on the results of launches: <br><img src="https://habrastorage.org/webt/xg/iv/rn/xgivrnyyynb418fnr5muqfn0qba.png"><br>  <i>Script performance depending on the number of parallel processes</i> <br><br>  What you can pay attention to: <br><br><ul><li>  C = 1 and C = 2 are predictably the same for HT = on and HT = off, performance doubles when you add a physical core; <br></li></ul><br><ul><li>  on C = 3, advantages from HT become noticeable: for HT = on, we were able to get additional performance, moreover, for HT = off with C = 3 and further, it begins to decrease predictably slowly; <br></li></ul><br><ul><li>  at C = 4, we see all the benefits of HT;  we were able to squeeze out an additional 30% of performance, but in comparison with C = 2 at this time, CPU usage increased from 50% to 100%. <br></li></ul><br>  Total, seeing in the top 50% of the CPU load, when executing this script, we get 8.065 Mhash / sec, and at 100% - 10.511 Mhash / sec.  This means that at 50% of the top we get 8.065 / 10.511 ~ 77% of the maximum system performance, and in fact we have about 100% in stock - 77% = 23%, not 50%, as it might seem. <br><br>  This fact must be considered when planning. <br><br><img src="https://habrastorage.org/webt/ru/6g/00/ru6g002t0ziv1pkppgqfjber80o.png"><br>  <i>CPU utilization for demoscript: top data and what actually happens</i> <br><br><h1>  Traffic irregularity </h1><br>  In addition to hyper-trading, planning also complicates traffic irregularity depending on the time of day, day of the week, season and other frequency.  For us, for example, the peak is Sunday evening. <br><br><img src="https://habrastorage.org/webt/eh/ks/58/ehks58pfn7sjva3c869i7cwj7fy.png"><br>  <i>Requests per second peak Sunday evening</i> <br><br>  Not always the number of requests changes in the obvious way.  For example, users can somehow interact with other users: the activity of some can generate push / emails to others and thus involve them in the process.  To this are added promo campaigns that increase traffic and to which you also need to be ready. <br><br>  All this is also important to consider when planning: for example, to build a trend by peak days and keep in mind the possible nonlinearity of peak growth. <br><br><h1>  Profiling and measurement tools </h1><br>  Suppose we found out that there were performance problems, realized that it was not the databases / services / other that were to blame, and nevertheless decided to optimize the code.  To do this, first of all, we need a profiler or some tools that allow us to find bottlenecks and subsequently see the results of our optimizations. <br><br>  Unfortunately, for PHP today there is no good universal tool. <br><br><h2>  perf </h2><br>  <a href="https://en.wikipedia.org/wiki/Perf_(Linux)">perf</a> is a profiling tool built into the Linux kernel.  It is a <a href="https://en.wikipedia.org/wiki/Profiling_(computer_programming)">sampling</a> profiler that is launched by a separate process and therefore does not directly add an overhead to the program being profiled.  Indirectly added overhead evenly ‚Äúsmeared‚Äù, therefore, does not distort the measurement. <br><br>  With all its advantages, perf is able to work only with compiled code and with JIT and does not know how to work with code that runs ‚Äúunder a virtual machine‚Äù.  Therefore, profiling the PHP code itself will not work in it, but you can clearly see how PHP works inside, including various PHP extensions, and how much resources are spent on it. <br><br>  We, for example, with the help of perf, found several bottlenecks, including a place with compression, which I will discuss below. <br><br>  Example: <br><br> <code>perf record --call-graph dwarf,65528 -F 99 -p $(pgrep php-cgi | paste -sd "," -) -- sleep 20 <br> perf report</code> <br> <br>  (if the process and perf are executed under different users, then perf needs to be started from under sudo). <br><br><img src="https://habrastorage.org/webt/k9/vu/k6/k9vuk6sf37xhshipgvx2byw3xps.png"><br>  <i>Example output of perf report for PHP-FPM</i> <br><br><h2>  XHProf and XHProf aggregator </h2><br>  XHProf is an extension for PHP that puts timers around all function / method calls, and also contains tools for visualizing the results thus obtained.  Unlike perf, it allows you to operate with the terms of PHP-code (in this case, what happens in the extensions can not be seen). <br><br>  The disadvantages include two things: <br><br><ul><li>  all measurements are collected within a single request, therefore they do not provide information about the picture as a whole; <br></li><li>  The overhead projector is <a href="https://ruhighload.com/%25D0%259F%25D1%2580%25D0%25BE%25D1%2584%25D0%25B8%25D0%25BB%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5%2Bphp%2B%25D1%2581%2Bxhprof">not as big</a> as, for example, when using Xdebug, but it is there, and in some cases the results are distorted (the more often a function is called and the simpler it is, the stronger the distortion). <br></li></ul><br>  Here is an example illustrating the last point: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">child1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">child2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ child1(); child2(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; $i++) { parent1(); }</code> </pre> <br><img src="https://habrastorage.org/webt/iw/7m/y6/iw7my6irzq5xg7_soy7sfkqpj7m.png"><br>  <i>The output of XHProf for demoscript: parent1 is orders of magnitude larger than the sum of child1 and child2</i> <br><br>  It can be seen that parent1 () was performed about 500 times longer than child1 () + child2 (), although in reality these numbers should be approximately equal, as are main () and parent1 (). <br><br>  If the last drawback is difficult to fight, then to combat the first, we made an add-on for XHProf, which aggregates profiles of different requests and visualizes aggregated data. <br><br>  In addition to XHProf, there are many other less well-known profilers working along similar lines.  They have similar advantages and disadvantages. <br><br><h2>  Pinba </h2><br>  <a href="https://github.com/badoo/pinba2">Pinba</a> allows you to <a href="https://habr.com/company/badoo/blog/319934/">monitor performance</a> in the context of scripts (actions) and on pre-arranged timers.  All measurements in the context of scripts are made out of the box; for this, no additional actions are required.  For each script and timer, <a href="http://man7.org/linux/man-pages/man2/getrusage.2.html">getrusage</a> is <a href="http://man7.org/linux/man-pages/man2/getrusage.2.html">executed</a> , so we know exactly how much processor time was spent on a particular piece of code (as opposed to sampling profilers, where this time can be network, disk, and so on).  Pinba is great for storing historical data and getting pictures in general, as well as within specific types of requests. <br><br><img src="https://habrastorage.org/webt/od/x5/qr/odx5qryl0ufhceiuyjkytjhtm0c.png"><br>  <i>General rusage of all scripts, obtained from Pinba</i> <br><br>  The disadvantages include the fact that timers that profile specific parts of the code, rather than the entire script, must be set in the code in advance, as well as the presence of an overhead projector, which (as in XHProf) can distort the data. <br><br><h2>  phpspy </h2><br>  <a href="https://github.com/adsr/phpspy">phpspy</a> is a relatively new project (the first commit on GitHub was six months ago), which looks promising, so we are closely following it. <br><br>  From the user's point of view, phpspy is similar to perf: a parallel process is started, which periodically copies portions of the PHP process's memory, parses them and receives stack traces and other data from there.  This is done in a rather specific way.  In order to minimize overhead, phpspy does not stop the PHP process and copies the memory right during its work.  This leads to the fact that the profiler can get a non-consistent state, stack-traces can be broken.  But phpspy can detect this and discards such data. <br><br>  In the future, using this tool, it will be possible to collect both data on the picture as a whole and profiles of specific types of requests. <br><br><h2>  comparison table </h2><br>  To structure the differences between the tools, let's make a pivot table: <br><br><img src="https://habrastorage.org/webt/bg/1a/bt/bg1abtxk-f8i5q83qm5teok3lbs.png"><br>  <i>Comparison of the main features of profilers</i> <br>  <i><a href="http://www.brendangregg.com/flamegraphs.html">Flame graphs</a></i> <br><br><h1>  Optimizations and approaches </h1><br>  With these tools, we constantly monitor the performance and use of our resources.  When they are used unnecessarily or we are approaching the threshold (for the CPU, we empirically chose a value of 55% to have time left for growth), as I wrote above, optimization is one of the solutions to the problem. <br><br>  It is good if the optimization has already been done by someone else, as was the case with PHP 7.0, when this version turned out to be much more productive than the previous ones.  We generally try to use modern technologies and tools, including timely updates to the latest versions of PHP.  According to <a href="https://www.phoronix.com/scan.php%3Fpage%3Dnews_item%26px%3DPHP-7.2-Final-Benchmark">public</a> <a href="https://kinsta.com/blog/php-7-hhvm-benchmarks/">benchmarks</a> , PHP 7.2 is 5‚Äì12% faster than PHP 7.1.  But this transition, alas, gave us much less. <br><br>  For all the time we have implemented a huge number of optimizations.  Unfortunately, most of them are strongly connected with our business logic.  I will talk about those that may be relevant not only for us, or ideas and approaches from which you can use outside of our code. <br><br><h2>  Compress zlib =&gt; zstd </h2><br>  We use compression for large keys.  This allows us to spend three to four times less memory for storage at the expense of additional CPU costs for compression / decompression.  We used zlib for this (our extension for working with memcs is different from those that come with PHP, but the official one <a href="http://php.net/manual/en/memcache.requirements.php">also</a> <a href="http://php.net/manual/en/memcached.configuration.php">uses</a> zlib). <br><br>  In perf production was like this: <br><br> <code>+    4.03%     0.22% php-cgi  libz.so.1.2.11      [.] inflate <br> +    3.38%     0.00% php-cgi  libz.so.1.2.11      [.] deflate</code> <br> <br>  7-8% of the time was spent on compression / decompression. <br><br>  We decided to test different levels and compression algorithms.  It turned out that zstd works on our data almost ten times faster, losing in place by ~ 1.1 times.  A fairly simple change in the algorithm saved us ~ 7.5% of the CPU (this, let me remind you, on our volumes is equivalent to ~ 45 servers). <br><br>  It is important to understand that the ratio of the performance of different compression algorithms can vary greatly depending on the input data.  There are various <a href="https://quixdb.github.io/squash-benchmark/">comparisons</a> , but most precisely this can be assessed only by real examples. <br><br><h2>  IS_ARRAY_IMMUTABLE as a repository for infrequently changing data </h2><br>  Working with real-life tasks, one has to deal with such data that is needed often and at the same time rarely changes and has a limited size.  We have a lot of similar data, a good example is the configuration of <a href="https://habr.com/company/badoo/blog/278089/">split tests</a> .  We check whether the user is subject to the conditions of a particular test, and depending on this we show him experimental or regular functionality (this happens during almost every request).  In other projects, such an example can be configs and various reference books: countries, cities, languages, categories, brands, etc. <br><br>  Since such data is often requested, receiving it can create a noticeable additional load on both the application itself and the service in which this data is stored.  The last problem can be solved, for example, with the help of APCu, which uses the memory of the same machine as PHP-FPM as storage.  But even in this case: <br><br><ul><li>  there will be serialization / deserialization costs; <br></li><li>  need to somehow invalidate the data when changing; <br></li><li>  there is some overhead compared to just accessing a variable in PHP. <br></li></ul><br>  In PHP 7.0, <a href="https://phpinternals.net/docs/is_array_immutable">IS_ARRAY_IMMUTABLE</a> optimization <a href="https://phpinternals.net/docs/is_array_immutable">appeared</a> .  If you declare an array, all elements of which are known at the time of compilation, it will be processed and placed in the OPCache memory once, PHP-FPM workers will refer to this shared memory without spending its own before attempting the change.  It also follows from this that including such an array will take a constant time regardless of size (usually ~ 1 microsecond). <br><br>  For comparison: an example of the time to get an array of 10,000 elements via include and apcu_fetch: <br><br><pre> <code class="php hljs">$t0 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $a = <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'test-incl-1.php'</span></span>; $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"include (%d): %d microsec\n"</span></span>, count($a), ($t1-$t0) * <span class="hljs-number"><span class="hljs-number">1e6</span></span>); $t0 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); $a = apcu_fetch(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); $t1 = microtime(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"apcu_fetch (%d): %d microsec\n"</span></span>, count($a), ($t1-$t0) * <span class="hljs-number"><span class="hljs-number">1e6</span></span>); <span class="hljs-comment"><span class="hljs-comment">//include (10000): 1 microsec //apcu_fetch (10000): 792 microsec</span></span></code> </pre><br>  It is very easy to check whether this optimization has been applied, if you look at the generated opcodes: <br><br><pre> <code class="php hljs">$ cat immutable.php <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'key1'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val1'</span></span>, <span class="hljs-string"><span class="hljs-string">'key2'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val2'</span></span>, <span class="hljs-string"><span class="hljs-string">'key3'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val3'</span></span>, ]; $ cat mutable.php <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'key1'</span></span> =&gt; \SomeClass::CONST_1, <span class="hljs-string"><span class="hljs-string">'key2'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val2'</span></span>, <span class="hljs-string"><span class="hljs-string">'key3'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'val3'</span></span>, ]; $ php -d opcache.enable=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.enable_cli=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.opt_debug_level=<span class="hljs-number"><span class="hljs-number">0x20000</span></span> immutable.php $_main: ; (lines=<span class="hljs-number"><span class="hljs-number">1</span></span>, args=<span class="hljs-number"><span class="hljs-number">0</span></span>, vars=<span class="hljs-number"><span class="hljs-number">0</span></span>, tmps=<span class="hljs-number"><span class="hljs-number">0</span></span>) ; (after optimizer) ; /home/ubuntu/immutable.php:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> L0 (<span class="hljs-number"><span class="hljs-number">4</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(...) $ php -d opcache.enable_cli=<span class="hljs-number"><span class="hljs-number">1</span></span> -d opcache.opt_debug_level=<span class="hljs-number"><span class="hljs-number">0x20000</span></span> mutable.php $_main: ; (lines=<span class="hljs-number"><span class="hljs-number">5</span></span>, args=<span class="hljs-number"><span class="hljs-number">0</span></span>, vars=<span class="hljs-number"><span class="hljs-number">0</span></span>, tmps=<span class="hljs-number"><span class="hljs-number">2</span></span>) ; (after optimizer) ; /home/ubuntu/mutable.php:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> L0 (<span class="hljs-number"><span class="hljs-number">4</span></span>): T1 = FETCH_CLASS_CONSTANT string(<span class="hljs-string"><span class="hljs-string">"SomeClass"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"CONST_1"</span></span>) L1 (<span class="hljs-number"><span class="hljs-number">4</span></span>): T0 = INIT_ARRAY <span class="hljs-number"><span class="hljs-number">3</span></span> T1 string(<span class="hljs-string"><span class="hljs-string">"key1"</span></span>) L2 (<span class="hljs-number"><span class="hljs-number">5</span></span>): T0 = ADD_ARRAY_ELEMENT string(<span class="hljs-string"><span class="hljs-string">"val2"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"key2"</span></span>) L3 (<span class="hljs-number"><span class="hljs-number">6</span></span>): T0 = ADD_ARRAY_ELEMENT string(<span class="hljs-string"><span class="hljs-string">"val3"</span></span>) string(<span class="hljs-string"><span class="hljs-string">"key3"</span></span>) L4 (<span class="hljs-number"><span class="hljs-number">6</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> T0</code> </pre><br>  In the first case, it is clear that there is a single opcode in the file ‚Äî the return of the finished array.  In the second case, it is formed by element-by-element every time the file is executed. <br><br>  Thus, it is possible to generate structures in the form that does not require further conversion in runtime.  For example, instead of disassembling the class names by the ‚Äú_‚Äù and ‚Äú\‚Äù signs each time for an autoload, you can pre-generate the ‚ÄúClass =&gt; Path‚Äù correspondence map.  In this case, the conversion function will be reduced to a single reference to the hash table.  Composer does this optimization if you enable the <a href="">optimize-autoloader option</a> . <br><br>  For the invalidation of such data, you do not need to do anything specifically - PHP itself recompiles the file when it is modified in the same way as it is done with the usual code deployment.  The only drawback that you need to remember is that if the file is very large, then the first request after changing it will cause a recompilation, which can take considerable time. <br><br><h2>  Performance include / require </h2><br>  Unlike the example with a static array, the connection of files with declarations of classes and functions is not so fast.  Despite the availability of OPCache, the PHP engine must copy them into the process memory, recursively connecting dependencies, which may take hundreds of microseconds or even milliseconds per file. <br><br>  If you create a new empty project on <a href="https://symfony.com/download">Symfony 4.1</a> and put <a href="http://php.net/manual/en/function.get-included-files.php">get_included_files () in the</a> first line of the action, you can see that 310 files are already connected.  In a real project, this number can reach thousands per request.  It is worth paying attention to the following things. <br><br>  <b>Lack of autoloading functions</b> <br><br>  There is a <a href="https://wiki.php.net/rfc/function_autoloading">Function Autoloading RFC</a> , but no development has been seen for several years.  Therefore, if the dependency in Composer defines functions outside the class and these functions must be accessible to the user, this is done by <a href="">necessarily connecting the</a> file with these functions to each initialization of the autoloader. <br><br>  For example, removing one of the dependencies from composer.json, which declares many functions and is easily replaced by a hundred lines of code, we won a couple of percent of the CPU. <br><br>  <b>Autoloader is called more often than it might seem</b> <br><br>  To demonstrate the idea, create such a file with a class: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">D</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AC1 = \E::E1;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AC2 = \F::F1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $as3 = \G::G1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $as4 = \H::H1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a5 = \I::I1;   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a6 = \J::J1;   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\K $k = null)</span></span></span><span class="hljs-function"> </span></span>{}   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asf1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\L $l = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asf2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\M $m = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">af3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\N $n = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">af4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(\P $p = null)</span></span></span><span class="hljs-function"> :? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PR</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre> <br>  <b>Register autoloader:</b> <br><br><pre> <code class="php hljs">spl_autoload_register(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Including $name...\n"</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">"$name.php"</span></span>; });</code> </pre> <br>  <b>And we will make several options for using this class:</b> <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'A.php'</span></span> Including B... Including D... Including C... \A::AC1 Including A... Including B... Including D... Including C... Including E... <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A() Including A... Including B... Including D... Including C... Including E... Including F... Including G... Including H... Including I... Including J...</code> </pre><br>  You may notice that when we simply somehow connect the class, but do not create its instance, the parent, interfaces, and traits will be connected.  This is done recursively for all files that are connected as they are resolved. <br><br>  When creating an instance, a rezolv of all constants and fields is added to this, which leads to the connection of all the necessary files for this, which, in turn, will also cause a recursive connection of the traits, parents and interfaces of the newly connected classes. <br><br><img src="https://habrastorage.org/webt/8a/qq/2t/8aqq2tf_8j-mixi8p_ydoypo-yo.png"><br>  <i>Connection of related classes for instantiation process and other cases</i> <br><br>  There is no universal solution to this problem, you just need to keep it in mind and follow the links between the classes: one line can pull on the connection of hundreds of files. <br><br>  <b>OPCache settings</b> <br><br>  If you use the <a href="https://codeascraft.com/2013/07/01/atomic-deploys-at-etsy/">atomic deployment</a> method using the <a href="https://codeascraft.com/2013/07/01/atomic-deploys-at-etsy/">symlink change</a> proposed by Rasmus Lerdorf, the creator of PHP, then to <a href="https://grokbase.com/t/php/php-internals/133qt70p3k/continuous-integration-atomic-deploys-and-php-5-5">solve the</a> symlink sticking problem on the old version, you have to enable opcache.revalidate_path, as recommended in, for example, this <a href="https://habr.com/company/mailru/blog/310054/">article</a> about OPCache translated by Mail .Ru Group. <br><br>  The problem is that this option significantly (on average one and a half to two times) increases the time to include each file.  In total, this can consume a significant amount of resources (in our case, turning off this option yielded a gain of 7‚Äì9%). <br><br>  To disable it, you need to do two things: <br><br><ul><li>  <a href="https://serverfault.com/questions/848503/nginx-caching-symlinks">make the</a> web server rezolvit simlinki; <br></li><li>  stop connecting files inside a PHP script along paths that contain symlinks, or force them to be resolved via readlink () or realpath (). <br></li></ul><br>  If all files are connected by the Composer autoloader, the second item will be executed automatically after the first one is executed: omposer uses the constant __DIR__, which will be split correctly. <br><br>  OPCache has a few more options that can give a performance boost in exchange for flexibility.  Read more about this in the <a href="https://habr.com/company/mailru/blog/310054/">article</a> I mentioned above. <br><br>  Despite all these optimizations, include will not be free anyway.  To combat this, <a href="https://wiki.php.net/rfc/preload">preload</a> is planned for PHP 7.4. <br><br><h2>  APCu lock </h2><br>  Although we are not talking about databases and services here, various kinds of locks can also occur in the code, which increase the execution time of the script. <br><br>  As requests grew, we noticed a sharp slowdown in response at peak times.  After finding out the reasons, it turned out that, although APCu is the fastest way to get data (compared to Memcache, Redis and other external repositories), it can also work slowly with frequent overwriting of identical keys. <br><br><img src="https://habrastorage.org/webt/hs/05/gc/hs05gcwvqozrqews1ewwtsskdyo.png"><br>  <i>Requests per second and execution time: bursts at the peaks on October 16 and 17</i> <br><br>  When using APCu as a cache, this problem is not so urgent, because caching usually means rare writing and frequent reading.  But some tasks and algorithms (for example, <a href="https://martinfowler.com/bliki/CircuitBreaker.html">Circuit Breaker</a> ( <a href="https://github.com/upwork/phystrix">implementation in PHP</a> )) also imply frequent writing, which causes locks. <br><br>  There is no universal solution to this problem, but in the case of Circuit Breaker, it can be solved, for example, by putting it into a <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/circuit_breaking">separate service</a> delivered to machines with PHP. <br><br><h2>  Batch processing </h2><br>  Even if you do not take into account the include, usually still a significant part of the query execution time is spent on the initial initialization: the framework (for example, building a DI container and initializing all its dependencies, routing, executing all listeners), raising the session, User and so Further. <br><br>  If your backend is an internal API for something, then surely some requests on clients can be bundled together and sent as a single request.  In this case, initialization will be performed once for several requests. <br><br>      ,   ,    .    -  ,          .       . <br><br><h2>    </h2><br>    Badoo   ,     .    PHP-FPM,      CPU,   ,            ,    :        IO, CPU  . <br><br>      PHP-FPM    ‚Äî  ,          PHP. <br><br>         (CPU, IO),    . , ,       ,  ,    -     ,        .        ,     .   ,  ,      . <br><br><h1>  Conclusion </h1><br>        .                    PHP     . <br><br>  : <br><br><ul><li>       ; <br></li><li>     ; <br></li><li>  -  ,  :  ,    ; <br></li><li>   :       (, ,  ); <br></li><li>    :     ; <br></li><li>   , OPCache    PHP,  , ,   ; <br></li><li>    :       (, ,   PHP 7.2   ,   ); <br></li><li>    : ,        . <br></li></ul><br>       ? <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/430722/">https://habr.com/ru/post/430722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430710/index.html">What to do if Black Friday is tomorrow, and your servers are not ready</a></li>
<li><a href="../430712/index.html">NeurIPS: how to conquer the best ML conference</a></li>
<li><a href="../430714/index.html">VMware buys Heptio - what does this mean for Kubernetes</a></li>
<li><a href="../430718/index.html">What objects should use cloud video surveillance?</a></li>
<li><a href="../430720/index.html">Intel RealSense D435i: a small update and a small historical excursion</a></li>
<li><a href="../430724/index.html">Conference DEFCON 21. DNS can be dangerous for your health. Part 1</a></li>
<li><a href="../430728/index.html">Teach me to give feedback</a></li>
<li><a href="../430730/index.html">What do they do in the R & D department of ABBYY: NLP Advanced Research Group</a></li>
<li><a href="../430732/index.html">On the issue of division and TI</a></li>
<li><a href="../430734/index.html">Smart updates against smart contracts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>