<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Continuous Integration: The Case of Hudson</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We all understand that testing is an integral part of the software development life cycle. The more often we test our code, the faster we will be able...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Continuous Integration: The Case of Hudson</h1><div class="post__text post__text-html js-mediator-article">  We all understand that testing is an integral part of the software development life cycle.  The more often we test our code, the faster we will be able to detect an error that has crept into it during development, and the faster it will be fixed.  It should be understood that it is highly desirable to conduct testing in an environment as close as possible to the battle (OS, software, hardware, load) in order to be able to detect errors that do not appear on the development server, but may appear in combat.  Companioning the two theses above together we get a concept called Continuous Integration. <br><br>  The essence of CI is to continuously (for example, after each commit'a) build and test software developed in as close as possible to the combat environment in order to detect errors as soon as possible and notify the developers about them.  The very idea of ‚Äã‚ÄãCI belongs to Martin Fowler, who described it in detail in his <a href="http://www.martinfowler.com/articles/continuousIntegration.html">article</a> . <br><br>  To automate the process of continuous assembly, there are ready-made solutions ( <a href="http://hudson-ci.org/">Hudson</a> , <a href="http://cruisecontrol.sourceforge.net/">CruiseControl</a> ), the integration of one of which (Hudson) I will describe in this article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h2>  Task </h2><br>  And so, let's say we have two projects: a Java service (from its own database), and a PHP client (from its own database) for it.  Both projects are distributed as deb-packages.  It is necessary to configure the infrastructure for the continuous integration of these projects. <br><br><br><h2>  Implementation </h2><br>  In order to have an idea of ‚Äã‚Äãwhat we want to achieve in the end, let us start from the end: consider the scheme we want to implement: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a71/f41/ea9/a71f41ea9a7ea54f306311a7764a19cb.jpg"><br><br><ul><li>  programmer's work machine - writing code, </li><li>  SVN server - code storage, </li><li>  Staging server - installation and testing of collected projects, </li><li>  Selenium server - testing web-interface, </li><li>  Repo server - storage of collected packets, </li><li>  CI server - connection of all system nodes into a single whole. </li></ul><br>  The developer makes changes to the project on his machine and commit'it them to SVN.  On the SVN server, a post-commit hook is triggered, which initiates the build process of the corresponding project on the CI server.  The CI server updates the version of the package from SVN, compiles the project, runs unit tests, uploads the project to the staging server. <br><br>  For projects without a web interface, integration tests are run, for projects with a web interface, Selenium tests are run.  The CI server generates reports and, if necessary (in case of failure at any stage of the project assembly), sends an email notification to the user. <br><br>  Layout of project packages in the repository for combat servers is made by the developer manually during the release. <br><br><br><h3>  Hudson </h3><br>  The main and most interesting node in our system is the CI server.  In this case, it will be <a href="http://hudson-ci.org/">Hudson</a> as one of the most popular and common free solutions. <br>  First install it.  Hudson is available as a package, so installation is fairly simple.  In addition, Hudson stores all of its configuration in files ( <i>/ var / lib / hudson</i> ), which means it does not require integration with any database. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/125/6f2/8e6/1256f28e6d3e2504d13c512507e46c9b.jpg"><br><br>  The Hudson architecture is built on plugin-based architecture.  That is, in essence, Hudson‚Äôs job comes down to storing project / plug-in settings and building the project.  In turn, the project build consists of launching in a certain order the installed plug-ins included in the project settings. <br>  Plug-ins can be divided into several conditional groups that form the project assembly cycle, also referred to as the ‚Äúpipeline‚Äù (setting up project plug-ins is available through the ‚ÄúProject Settings‚Äù menu): <br><ul><li>  source code management (getting / updating the project code from the repository), </li><li>  assembly triggers (setting startup time for project assembly), </li><li>  build environment (setting up the project build environment: JVM version) </li><li>  assembly (main stage: launching plug-ins that implement the logic of assembly, integration and testing), </li><li>  post-assembly operations (generation / publication of reports, notification). </li></ul><br>  Unfortunately, Hudson only allows you to change the order in which the plugins in the assembly group are executed (the order in which the remaining plugins are executed within their group is determined based on the values ‚Äã‚Äãof the <i>@Execution</i> annotation <i>in</i> the plug-in code).  Therefore, in case you need to implement your build script, for which a set of standard plugins from the Assembly group is not enough, you can go three ways: <br><ol><li>  call any external executable script that implements this script (item "Execute Shell" from the menu "Add build step"), </li><li>  connect the plugin of the project assembly system (Phing, Ant, Maven) and indicate the necessary target, </li><li>  write your own plugin. </li></ol><br>  By default, Hudson comes with already installed plug-ins for working with SVN and Maven.  This could be quite enough if it were only for Java projects.  However, suppose that we also need to work with PHP projects.  In this case, it is more logical to use Phing for building the project, the plugin for which you need to install separately.  This is done by going to the section "Settings / Managing Plugins / Available Updates." <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cce/c03/0b8/ccec030b875bbc13f6abd89c223d958f.jpg"><br><br>  Please note that some plugins require running Hudson under Java 6. You can change the path to the JVM (exactly like other configuration options) in the <i>/ etc / default / hudson file</i> .  Otherwise, all configuration parameters relating directly to the work of Hudson can be edited via a browser in the web-interface. <br><br>  Regarding plug-in settings, it is also worth mentioning that the plug-in has both general settings ("Setup / System Configuration") and project settings ("Settings / Project Name / Set Up Project"). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7da/abb/aa0/7daabbaa017c44dcca4b93e25a803169.jpg"><br><br>  Now that all the necessary plugins have been installed, we can create a new project / task, specifying its name and settings for the corresponding plugins: the URL in the SVN repository and the command to build. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e2d/ac5/f8e/e2dac5f8e4561145b33921014b101ace.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/129/02f/afb/12902fafb66c32e7f2bcade99685e72d.jpg"><br><br>  Please note that you can assemble not according to any schedule or when polling the repository when there are changes in the project, but <a href="http://wiki.hudson-ci.org/display/HUDSON/Building%2Ba%2Bsoftware%2Bproject">by committing to SVN</a> .  Due to the fact that Hudson has a ‚ÄúRemote Access API‚Äù that allows, among other things, to <a href="http://wiki.hudson-ci.org/display/HUDSON/Building%2Ba%2Bsoftware%2Bproject">initiate a project build by making a GET request</a> , you can easily add an appropriate post-commit hook (for example, using <a href="http://svnbook.red-bean.com/nightly/ru/svn-book.html">svnlook</a> ) for your project. <br><br>  Consider the build phase: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/129/02f/afb/12902fafb66c32e7f2bcade99685e72d.jpg"><br><br>  At the moment, the package build includes retrieving data from the repository and fulfilling the goal of Phing (package build).  In principle, here you can add the launch of unit-tests and deploy project to the staging-server.  However, here it is worth paying attention to a few points. <br><br>  Firstly, the config for the application to work on the staging server may differ from the combat config.  In this case, the obvious solution is to store in the project a config for the staging server and replace it with the original project during the assembly (a separate goal for the assembly in the case of Phing or a <a href="http://maven.apache.org/guides/introduction/introduction-to-profiles.html">profile for Maven</a> ). <br><br>  Secondly, installing the package on the staging server using the <a href="http://wiki.hudson-ci.org/display/HUDSON/SCP%2Bplugin">SCP</a> and <a href="http://wiki.hudson-ci.org/display/HUDSON/SSH%2Bplugin">SSH</a> plugins (for the plugin to work, you must make sure that the PasswordAuthentication parameter in the sshd config is set to yes, and the staging server host is added to the known hosts) because the SSH plugin relates to the project assembly stage, and the SCP plugin to post-assembly operations.  Therefore, the problem of the deployment of the project to the staging server will have to be solved with the help of Phing or <a href="http://maven.apache.org/guides/mini/guide-building-for-different-environments.html">Maven</a> + <a href="http://maven.apache.org/plugins/maven-antrun-plugin/index.html">AntRun</a> . <br>  In order for our build script to perform actions on remote servers, it is necessary to generate ssh keys: leave the private key on the CI server, and scatter the public key on all servers that will interact: staging, repo, svn - adding them to the list known hosts (known_hosts).  In addition, in order for Hudson to be able to install the package on a remote server, it will be necessary to start a corresponding user (hudson) on the remote server and give it sudo. <br><br>  Thirdly, to successfully build java applications using Maven, you will need to define the Maven settings for the hudson user on the CI server (meaning the <i>~ / .m2 directory</i> ). <br><br>  The next step after installing the package on the staging server should be the launch of integration tests.  They can be run on the CI server itself, however, it is preferable to do this on the staging server.  In the first case, everything is quite simple: call the appropriate target Phing / Maven or configure the <a href="http://wiki.hudson-ci.org/display/HUDSON/Seleniumhq%2BPlugin">SeleniumHQ</a> plugin. <br>  However, the question remains open: what to do if you want to start the testing process on an external server - for example, contact the Selenium RC server?  The answer here is very simple: Selenium RC has an HTTP API to work with it, so the most trivial solution in this case is to write a small script in any language you like, which initiates the testing process and occasionally polls the remote server for completion of the test.  Further, this script is connected to the build script via the plugin "Execute Shell".  I also add that the success or failure of the script is determined by Hudson based on the return code of your script. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f1/1e6/512/2f11e651204dc925e7af162ed08d55a7.jpg"><br><br>  Having set up the build process, let's not forget about the most important part of the process - notifying the developer of the build results.  Hudson allows you to customize email notifications for both specific recipients and authors of commites whose changes caused a breakdown. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/669/f20/f78/669f20f7843d40ee93adb11a880cfd07.jpg"><br><br>  In addition, I recommend to anyone who will use Hudson for PHP projects to familiarize themselves <a href="http://wiki.hudson-ci.org/display/HUDSON/Hudson%2Band%2BPHP">with relevant articles from the Hudson Wiki</a> . <br><br><br><h3>  Staging server </h3><br><br><br><h4>  Package installation </h4><br>  And so, as mentioned above, in our infrastructure there should be a server configuration as close as possible to the combat one.  On this server, Hudson will install the latest project packages built on the trunk.  This will enable us to: <br><ol><li>  conduct integration testing in conditions as close to combat, </li><li>  will allow you to have a kind of platform for the demonstration of the latest functionality. </li></ol><br>  One of the main problems that will have to be solved when setting up this server is the ‚Äúsilent‚Äù installation of packages.  In order for our packages to be installed without unnecessary dialogs (that is, they could be installed using scripts or Hudson plugins), you need to reconfigure debconf ( <i>dpkg-reconfigure debconf</i> ), indicating to it the level of importance of the asked questions higher than those used in installation scripts for your deb-package. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/952/338/462/952338462168022a1072efcb4404a6b3.jpg"><br><br>  In addition, dependencies are possible between packages installed on a staging server.  For example, the project ‚Äúclient‚Äù depends on the project ‚Äúserver‚Äù.  In this case, we must clearly make sure that the installation of the necessary server package takes place on the staging server when installing the client package. <br><br>  At first glance, the obvious solution, taking into account the distribution of the project through deb-packages, <br>  <i>dpkg</i> will manage dependencies by adding the ‚Äúclient‚Äù package control file of the server package to the <i>dependencies</i> . <br>  In this case, we also have to allocate a separate debian repository, into which all the CI server packages will merge, and supplement the build script with the command to copy the package to the repository.  In addition, it will be necessary to organize the mechanism for auto-updating data in this repository when adding a new package, to organize access to the repository pool (for example, by raising the web server) and to add this repository to the sources-list on the staging server.  When auto-updating manually (by launching the package scanner after uploading the package to the repository) a new package can be installed via apt, in case the repository is updated according to the schedule, you have to invent tricks like <i>dpkg -i package;</i>  <i>apt-get -f install</i> .  Learn more about setting up your debian repository <a href="http://l10n-russian.alioth.debian.org/repository-howto.ru.html">here</a> . <br><br>  However, this approach has several disadvantages.  First, dependencies can only be installed on the same server.  Secondly, such an approach rather significantly complicates the entire system as a whole, which contradicts the <a href="http://kiss/">KISS</a> principle (well, or "PIT", if in Russian: D). <br><br>  In my opinion, the best solution here will be to use the repository only for interacting with the combat server.  In this case, the layout of packages in the repository should not be carried out automatically, but by the decision of the developer.  As for the staging server, it will install packages from the trunk of the main package and all its dependencies, which will significantly reduce the complexity of the CI system, while giving us the opportunity to have the latest current versions on the staging server <br>  packages. <br><br><br><h4>  Work with DB </h4><br>  Our packages can use a DB.  In this case, the database is also installed on the staging server, and the database structure / data is updated using the <a href="http://dbdeploy.com/">dbdeploy</a> utility. <br>  Integrate dbdeploy into a project in two ways: <br><ol><li>  each database is allocated a separate project in SVN and, as a result, in Hudson, with its own build script initiated by the SVN hook (the option makes sense when the database is used by several projects), </li><li>  The dbdeploy file structure becomes part of the main project, and the dbdeploy database version update script call occurs in the postinst script of the package. </li></ol><br><br>  Separately, in this case, the question arises about the changes in the database data during testing.  Clearly, when writing unit tests, we do not work with the database, but use <a href="http://en.wikipedia.org/wiki/Mock_object">mock objects</a> (for example, I like the <a href="http://mockito.org/">Mockito</a> ). <br>  However, what about integration tests that simply need to work in ‚Äúreal‚Äù conditions?  In the case of XUnit tests, we can perform each test as part of a transaction to the database.  In my opinion, this approach is more preferable, since taking into account the versioning of the database through dbdeploy, we always know what data we have in the database at the current moment and we can safely attach to them in our tests.  However, in the case of testing a web interface (for example, using Selenium), we are not able to run each test as part of a transaction. <br>  Therefore, in my opinion there are two options here: either before launching the testing of the web-interface, completely reinitialize the data into the database based on the available <br>  patches, or build tests so that they are not tied to any specific data from the database (for example, they created the data necessary for testing via the web-interface themselves) and, if possible, did not leave ‚Äúgarbage‚Äù behind them. <br><br><br><h3>  Selenium server </h3><br>  In the case when the application does not have a web interface, the integration test on the staging server, as I already wrote above, may well consist in running XUnit tests.  However, in the presence of a user interface, it is extremely convenient to conduct a full testing of the entire chain from HTML to DB using Selenuim. <br><br>  <a href="http://seleniumhq.org/">Selenium</a> is a powerful web-application testing system, which can be divided into two parts: <br><ul><li>  <a href="http://seleniumhq.org/docs/03_selenium_ide.html">Selenuim IDE</a> - a tool for developing and <a href="http://seleniumhq.org/docs/03_selenium_ide.html">running</a> test scripts in the browser (available as plugin firefox), </li><li>  <a href="http://seleniumhq.org/docs/05_selenium_rc.html">Selenium RC</a> is a distributed system from the Selenium server and its subordinate clients, where tests are run under different browsers. </li></ul><br>  For obvious reasons, we are interested in the second option.  Since the installation and configuration of Selenuim is a big topic, I don‚Äôt see any reason to touch it in this article: all the information is in the <a href="http://seleniumhq.org/docs/">documentation</a> . <br><br><br><h2>  Remarks </h2><br>  It should be noted that CI can also be performed manually, each time compiling and testing the code before commit.  However, automation of this process using the CI server is much more expedient.  In addition, it is important to understand that CI and nightly builds are not the same thing.  The latter allow detecting bugs, but with a great delay, while the goal of CI is to detect errors as soon as possible.  In my opinion, nightly builds can serve as a partial replacement for CI only in the case when building and testing a project is a process that takes a fairly large amount of time.  In addition, if the project has both unit and integration tests, you can split the project assembly into two parts: the first (with unit tests) is run every time you commit'e, the second with integration tests - once an hour / day. <br><br><br><h2>  Conclusion </h2><br>  The solution described above works and brings <a href="http://lurkmore.ru/%25D0%259F%25D0%25A0%25D0%259E%25D0%25A4%25D0%2598%25D0%25A2">profit</a> .  However, as we all know, the theory, unfortunately, far from always corresponds to practice.  The implementation of the CI system required solving a number of problems, not all of which were solved perfectly. <br><br>  The probability that someone will give you resources for a staging server that are comparable to the combat characteristics is extremely small - most likely it will be an average virtual machine power on a half-abandoned host machine, which fundamentally undermines one of the CI principles - testing in a similar environment .  This, in turn, entails the fact that integration tests may begin to take much longer than originally planned.  Therefore, in my case, ‚Äúcontinuity‚Äù had to be compromised and I started to run tests not according to SVN hooks, but according to the schedule. <br><br>  In general, if you have a certain development culture in your team (I mean the understanding that CI is not a panacea, but only a tool that, with proper handling skills, can improve the quality of their work), the introduction of CI is fully justified. <br><br>  Well, probably the most important thing: as practice has shown, the integration of the CI system is a team task.  To solve it will require the work of developers, testers and administrators. </div><p>Source: <a href="https://habr.com/ru/post/108928/">https://habr.com/ru/post/108928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../108920/index.html">Introduction to OCaml: Data Types and Mapping [3]</a></li>
<li><a href="../108921/index.html">The "mystery" of Vogue magazine</a></li>
<li><a href="../108923/index.html">NLP: spell check - an inside look (part 2)</a></li>
<li><a href="../108926/index.html">Practical advice for those who want to build a web community</a></li>
<li><a href="../108927/index.html">Kinect - advanced sensor for robots</a></li>
<li><a href="../108931/index.html">NAT on Cisco. Part 1</a></li>
<li><a href="../108932/index.html">Microsoft continues to support Creative Commons!</a></li>
<li><a href="../108934/index.html">Not another social network or how we decided to create our own social network (Part 2 - organizing the information space on news portals)</a></li>
<li><a href="../108936/index.html">Unusual laptop with two touch screens: Acer Iconia</a></li>
<li><a href="../108938/index.html">A group of enthusiasts has developed a technology for surfing the web using Kinect</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>