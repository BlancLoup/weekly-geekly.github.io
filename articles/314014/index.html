<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing JSON is a minefield</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JSON is the de facto standard when it comes to (de) serialization, network data exchange and mobile development. But how well are you familiar with JS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing JSON is a minefield</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/55a/70e/a58/55a70ea5864211ffb526350b07bcf847.jpg" alt="image"><br><br>  JSON is the de facto standard when it comes to (de) serialization, network data exchange and mobile development.  But how well are you familiar with JSON?  We all read specifications and write tests, test popular JSON libraries for our needs.  I will show you that JSON is an idealized format, not an ideal one, as many people consider it.  I have not found two libraries behaving the same way.  Moreover, I found that extreme cases and harmful payloads can lead to bugs, crashes and DoS, mainly because JSON libraries are based on specifications that evolve over time, which leaves many things poorly or not documented at all. <br><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  1. <a href="https://habr.com/ru/company/mailru/blog/314014/">JSON specifications</a> <br>  2. <a href="https://habr.com/ru/company/mailru/blog/314014/">Testing parsing</a> <br>  2.1.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Structure</a> <br>  2.2.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Numbers</a> <br>  2.3.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Arrays</a> <br>  2.4.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Objects</a> <br>  2.5.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Strings</a> <br>  2.6.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Dual RFC 7159 Values</a> <br>  3. <a href="https://habr.com/ru/company/mailru/blog/314014/">Testing architecture</a> <br>  4. <a href="https://habr.com/ru/company/mailru/blog/314014/">Test results</a> <br>  4.1.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Full results</a> <br>  4.2.  <a href="https://habr.com/ru/company/mailru/blog/314014/">C-parsers</a> <br>  4.3.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Objective-C parsers</a> <br>  4.4.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Apple (NS) JSONSerialization</a> <br>  4.5.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Freddy (Swift)</a> <br>  4.6.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Bash json.sh</a> <br>  4.7.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Other parsers</a> <br>  4.8.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Json checker</a> <br>  4.9.  <a href="https://habr.com/ru/company/mailru/blog/314014/">Regular expressions</a> <br>  5. <a href="https://habr.com/ru/company/mailru/blog/314014/">Content parsing</a> <br>  6. <a href="https://habr.com/ru/company/mailru/blog/314014/">STJSON</a> <br>  7. <a href="https://habr.com/ru/company/mailru/blog/314014/">Conclusion</a> <br>  8. <a href="https://habr.com/ru/company/mailru/blog/314014/">Application</a> </div></div><a name="habracut"></a><br><a name="1"></a><h1>  1. JSON specifications </h1><br>  JSON is the de facto standard for serialization of data transmission over HTTP, <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25B2%25D0%25B0_%25D1%2584%25D1%2580%25D0%25B0%25D0%25BD%25D0%25BA%25D0%25B0">lingua franca</a> for exchanging data between heterogeneous applications in both web and mobile development. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In 2001, <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25BE%25D0%25BA%25D1%2584%25D0%25BE%25D1%2580%25D0%25B4,_%25D0%2594%25D1%2583%25D0%25B3%25D0%25BB%25D0%25B0%25D1%2581">Douglas Crockford</a> developed such a short and simple JSON specification that it gave rise to business cards, on the back of which they printed the full JSON grammar. <br><br><img src="https://habrastorage.org/files/fd3/942/ae0/fd3942ae0a3a4d1f8472493fdf491121.png"><br><br>  Almost all Internet users and programmers use JSON, but only a few really agreed on how JSON should work.  The brevity of grammar leaves many aspects uncertain.  In addition, there are several specifications and their muddy interpretations. <br><br>  Crockford <a href="https://www.computer.org/csdl/mags/co/2012/04/mco2012040006.html">decided</a> not to version JSON: <br><br><blockquote>  Probably, my most courageous design decision was the refusal to assign JSON number versions, so there is no mechanism for making changes.  We are stuck with JSON: whatever its current form is, it‚Äôs just that. </blockquote><br><br>  In addition, JSON is defined in at least six different documents: <br><br><ol><li>  2002 - <a href="http://www.json.org/">json.org</a> and business cards. </li><li>  2006 - <a href="https://tools.ietf.org/html/rfc4627">IETF RFC 4627</a> , sets the application / json MIME environment type. </li><li>  2011 - <a href="http://www.ecma-international.org/ecma-262/5.1/">ECMAScript 262, section 15.12</a> . </li><li>  2013 - <a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm">ECMA 404</a> .  According to Tim Bray (RFC 7159 editor), <a href="https://www.tbray.org/ongoing/When/201x/2014/03/05/RFC7159-JSON">ECMA hurried with the release</a> because: <br><blockquote>  Someone told the ECMA working group that IETF was crazy and was going to rewrite JSON without regard for compatibility and breakdown of the entire Internet, and something urgently needed to be done with this terrible situation.  &lt;...&gt; This has nothing to do with complaints that affected the audit by the IETF. </blockquote></li><li>  2014 - <a href="https://tools.ietf.org/html/rfc7158">IETF RFC 7158</a> .  Creates a ‚ÄúStandard Tracks‚Äù specification instead of ‚ÄúInformational‚Äù;  allows to use scalars (nothing but arrays and objects) like 123 and true at the root level, like ECMA;  warns against using unsuccessful solutions like duplicate keys or broken Unicode strings, although it does not prohibit them explicitly. </li><li>  2014 - <a href="https://tools.ietf.org/html/rfc7159">IETF RFC 7159</a> .  Released to correct typos in RFC 7158, which was dated March 2013 instead of March 2014. </li></ol><br>  Despite its clarity, RFC 7159 contains several assumptions and leaves a lot of poorly lit moments. <br><br>  In particular, RFC 7159 <a href="https://tools.ietf.org/html/rfc7159">mentions</a> that the purpose of developing JSON was to create a ‚Äúsubset of JavaScript‚Äù, but in fact it is not.  For example, JSON allows unescaped end of line characters from Unicode <code>U+2028 LINE SEPARATOR</code> and <code>U+2029 PARAGRAPH SEPARATOR</code> .  But the JavaScript specification states that string values ‚Äã‚Äãcannot contain end-of-line characters ( <a href="http://www.ecma-international.org/ecma-262/5.1/">ECMA-262 - 7.8.4 String Literals</a> ), and generally these characters include <code>U+2028</code> and <code>U+2029</code> ( <a href="http://www.ecma-international.org/ecma-262/5.1/">7.3 Line Terminators</a> ).  The fact that these two characters can be used in JSON strings without escaping, and in JS they are not implied at all, suggests that JSON is <b>not a</b> subset of JavaScript, despite the stated development goals. <br><br>  Also, RFC 7159 does not clarify how a JSON parser should handle extreme numerical values ‚Äã‚Äã(extreme number values), distorted Unicode strings, identical objects, or recursion depth.  Some deadlock situations are clearly left without realizations, while others suffer from contradictory statements. <br><br>  To illustrate the inaccuracy of RFC 7159, I wrote a collection of test JSON files and documented how specific JSON parsers handle them.  Below you will see that it is not always easy to decide whether to parse this or that test file.  In my research, I found that all parsers behave differently, and this can lead to serious compatibility issues. <br><br><a name="2"></a><h1>  2. Testing parsing </h1><br>  Next, I will explain how to create test files to check the behavior of parsers, talk about some interesting tests and substantively, should parsers that meet RFC 7159 criteria accept or reject files ‚Äî or decide for themselves. <br><br>  File names begin with a letter that indicates the expected result: <br><br><ul><li>  <code>y</code> (yes) - successful parsing; </li><li>  <code>n</code> (no) - parsing error; </li><li>  <code>i</code> (implementation) - depends on the implementation. </li></ul><br>  Also from the files it will be clear which component of the parser has been tested. <br><br>  For example, <code>n_string_unescaped_tab.json</code> contains <code>["09"]</code> - this is an array with a string that includes the <code>TAB 0x09</code> character, which MUST be escaped (u-escaped) according to JSON specifications.  The file tests string parsing, so the name contains a <code>string</code> , not a <code>structure</code> , <code>array</code> or <code>object</code> .  According to RFC 7159, this is an invalid string value, so <code>n</code> appears in the file name. <br><br>  Notice that some parsers do not allow scalars at the top level ( <code>"test"</code> ), so I embedded strings in arrays ( <code>["test"]</code> ). <br><br>  More than 300 test files can be found in the <a href="https://github.com/nst/JSONTestSuite">JSONTestSuite</a> repository. <br><br>  Most of the files I did manually as I read the specifications, trying to pay attention to extreme situations and ambiguous points.  I also tried to use developments from other people's test suites found on the Internet (mostly <a href="https://code.google.com/archive/p/json-test-suite/">json-test-suite</a> and <a href="http://www.json.org/JSON_checker/">JSON Checker</a> ), but I found that most of them cover only basic situations. <br><br>  Finally, I generated JSON files using <a href="http://lcamtuf.coredump.cx/afl/">American Fuzzy Lop</a> fuzzing software.  Then I removed redundant tests that lead to the same result, and then reduced the number of remaining ones to get the smallest number of characters that produce results (see <a href="https://habr.com/ru/company/mailru/blog/314014/">section 3</a> ). <br><br><a name="21"></a><h3>  2.1.  Structure </h3><br>  <b>Scalars</b> - it is obvious that it is necessary to parse scalars like 123 or ‚Äúasd‚Äù.  In practice, many popular parsers still implement RFC 4627 and will not parse single values.  Thus, there are basic tests, for example: <br><br><pre> <code class="javascript hljs">y_structure_lonely_string.json <span class="hljs-string"><span class="hljs-string">"asd"</span></span></code> </pre><br>  <b>Trailing commas</b> , for example <code>[123,]</code> or <code>{"a":1,}</code> , are not part of the grammar, so such files should not pass tests, right?  But the fact is that RFC 7159 allows parsers to support "extensions" ( <a href="https://tools.ietf.org/html/rfc7159">section 9</a> ), although no explanation is given about them.  In practice, trailing commas are a common extension.  Since this is not part of the JSON grammar, parsers are <b>not required to</b> support them, so file names begin with n. <br><br><pre> <code class="javascript hljs">n_object_trailing_comma.json {<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,} n_object_several_trailing_commas.json {<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,,,,,}</code> </pre><br>  <b>Comments are</b> also not part of the grammar.  Crockford <a href="https://plus.google.com/%2BDouglasCrockfordEsq/posts/RK8qyGVaGSr">removed</a> them from earlier specifications.  But this is another common extension.  Some parsers allow the use of comments that close <code>[1]//xxx</code> or even embedded <code>[1,/*xxx*/2]</code> . <br><br><pre> <code class="html hljs xml">y_string_comments.json ["a/*b*/c/*d//e"] n_object_trailing_comment.json {"a":"b"}/**/ n_structure_object_with_comment.json {"a":/*comment*/"b"}</code> </pre><br>  <b>Unclosed structures</b> .  Tests cover all situations where there are open and not closed (or vice versa) structures, for example <code>[</code> or <code>[1,{,3]</code> .  Obviously, this is a mistake and the tests should not be passed. <br><br><pre> <code class="html hljs xml">n_structure_object_unclosed_no_value.json {"": n_structure_object_followed_by_closing_object.json {}}</code> </pre><br>  Nested structures.  Structures sometimes contain other structures, arrays - other arrays.  The first element can be an array, whose first element is also an array, and so on, like a doll <code>[[[[[]]]]]</code> .  RFC 7159 allows parsers to set limits on the maximum nesting depth ( <a href="https://tools.ietf.org/html/rfc7159">section 9</a> ). <br><br>  Several parsers do not limit the depth and at some point just fall.  For example, Xcode will crash if you open a .json file containing a thousand characters <code>[</code> .  This is probably because the selector of syntax elements JSON does not implement the depth limit. <br><br><pre> <code class="bash hljs">$ python -c <span class="hljs-string"><span class="hljs-string">"print('['*100000)"</span></span> &gt; ~/x.json $ ./Xcode ~/x.json Segmentation fault: 11</code> </pre><br>  <b>Spaces</b>  Grammar RFC 7159 allows using <code>0x20</code> (space), <code>0x09</code> (tabulation), <code>0x0A</code> (line feed) and <code>0x0D</code> (carriage return) as their quality.  Spaces are allowed before and after structural characters <code>[]{}:,</code> .  So <code>20[090A]0D</code> will pass the tests.  Conversely, the file will not pass the tests if we include all kinds of spaces that are not explicitly allowed, for example, input form <code>0x0C</code> or <code>[E281A0]</code> - UTF-8 designation for the word connector <code>U+2060 WORD JOINER</code> . <br><br><pre> <code class="html hljs xml">n_structure_whitespace_formfeed.json [0C] n_structure_whitespace_U+2060_word_joiner.json [E281A0] n_structure_no_data.json</code> </pre><br><a name="22"></a><h3>  2.2.  Numbers </h3><br>  <b>NaN and Infinity.</b>  Strings describing special numbers like <code>NaN</code> or <code>Infinity</code> are not part of the JSON grammar.  But some parsers accept them, regarding them as ‚Äúextensions‚Äù ( <a href="https://tools.ietf.org/html/rfc7159">section 9</a> ).  In the test files, the negative forms <code>-NaN</code> and <code>-Infinity</code> are also checked. <br><br><pre> <code class="html hljs xml">n_number_NaN.json [NaN] n_number_minus_infinity.json [-Infinity]</code> </pre><br>  <b>Hexadecimal numbers</b> - RFC 7159 does not allow their use.  Tests contain numbers like <code>0xFF</code> , and such files should not be parsed. <br><br><pre> <code class="javascript hljs">n_number_hex_2_digits.json [<span class="hljs-number"><span class="hljs-number">0x42</span></span>]</code> </pre><br>  <b>Range and accuracy</b> - and what about numbers from a huge number of numbers?  According to RFC 7159, ‚Äúthe JSON parser MUST accept all sorts of text that conforms to the JSON grammar‚Äù ( <a href="https://tools.ietf.org/html/rfc7159">Chapter 9</a> ).  But the same paragraph says: "The implementation may limit the range and accuracy of numbers."  So it is not clear to me whether the parsers can generate an error when they encounter values ‚Äã‚Äãlike <code>1e9999</code> or <code>0.0000000000000000000000000000001</code> . <br><br><pre> <code class="javascript hljs">y_number_very_big_negative_int.json [<span class="hljs-number"><span class="hljs-number">-237462374673276894279832</span></span>(...)</code> </pre><br>  <b>Exponential representations</b> ‚Äî parsing them can be a surprisingly difficult task (see the results chapter).  There are also valid ( <code>[0E0]</code> , <code>[0e+1]</code> ), and <code>[0E0]</code> valid variants ( <code>[1.0e+]</code> , <code>[0E]</code> and <code>[1eE2]</code> ). <br><br><pre> <code class="html hljs xml">n_number_0_capital_E+.json [0E+] n_number_.2e-3.json [.2e-3] y_number_double_huge_neg_exp.json [123.456e-789]</code> </pre><br><a name="23"></a><h3>  2.3.  Arrays </h3><br>  Most of the extreme situations associated with arrays are problems with opening / closing and restricting nesting.  They are discussed in section <a href="https://habr.com/ru/company/mailru/blog/314014/">2.1 (Structures)</a> .  Tests will pass <code>[[]</code> and <code>[[[]]]</code> , but will not pass <code>]</code> or <code>[[]]]</code> . <br><br><pre> <code class="html hljs xml">n_array_comma_and_number.json [,1] n_array_colon_instead_of_comma.json ["": 1] n_array_unclosed_with_new_lines.json [1,0A10A,1</code> </pre><br><a name="24"></a><h3>  2.4.  Objects </h3><br>  <b>Duplicate keys</b> .  <a href="https://tools.ietf.org/html/rfc7159">Section 4 of RFC 7159</a> states: ‚ÄúThere must be unique names within the object‚Äù.  This does not prevent parsing of objects in which one key appears several times <code>{"a":1,"a":2}</code> , but allows parsers to decide for themselves what to do in such cases.  Section 4 even mentions that ‚Äú[some] implementations report an error or failure while parsing an object‚Äù, without specifying whether the parsing failure corresponds to the RFC provisions, especially <a href="https://tools.ietf.org/html/rfc7159">this</a> : ‚ÄúThe JSON parser MUST accept all kinds of texts corresponding to the JSON grammar ". <br><br>  Variants of such special cases include the same key: the same value <code>{"a":1,"a":1}</code> , as well as keys or values ‚Äã‚Äãwhose sameness depends on how the strings are compared.  For example, the keys may be different in binary expression, but equivalent in accordance with the normalization of Inicode NFC: <code>{"C3A9:"NFC","65CC81":"NFD"}</code> , here both keys denote" √© ". Also included in the tests is <code>{"a":0,"a":-0}</code> . <br><br><pre> <code class="html hljs xml">y_object_empty_key.json {"":0} y_object_duplicated_key_and_value.json {"a":"b","a":"b"} n_object_double_colon.json {"x"::"b"} n_object_key_with_single_quotes.json {key: 'value'} n_object_missing_key.json {:"b"} n_object_non_string_key.json {1:1}</code> </pre><br><a name="25"></a><h3>  2.5.  Strings </h3><br>  <b>File encoding</b>  ‚ÄúJSON text MUST be UTF-8, UTF-16 or UTF-32 encoded.  The default is UTF-8 ‚Äù( <a href="https://tools.ietf.org/html/rfc7159">section 8.1</a> ). <br>  So for passing the tests one of the three encodings is needed.  Texts in UTF-16 and UTF-32 must also contain older and minor versions. <br><br>  Failure tests include ISO-Latin-1 encoded strings. <br><br><pre> <code class="html hljs xml">y_string_utf16.json FFFE[00"00E900"00]00 n_string_iso_latin_1.json ["E9"]</code> </pre><br>  <b>Byte Order Marker.</b>  Although <a href="https://tools.ietf.org/html/rfc7159">section 8.1</a> states: "Implementations MUST NOT add a byte sequence marker to the beginning of JSON text," then we see: "Implementations ... MAY ignore the presence of a marker, and not treat it as an error." <br><br>  Failure tests include only marks in UTF-8 encoding, without other content.  Tests whose implementation-dependent results include a UTF-8 BOM with a UTF-8 string, as well as a UTF-8 BOM with a UTF-16 string and a UTF-16 BOM with a UTF-8 string. <br><br><pre> <code class="html hljs xml">n_structure_UTF8_BOM_no_data.json EFBBBF n_structure_incomplete_UTF8_BOM.json EFBB{} i_structure_UTF-8_BOM_empty_object.json EFBBBF{}</code> </pre><br>  <b>Control characters</b> should be isolated and defined as <code>U+0000</code> as <code>U+001F</code> ( <a href="https://tools.ietf.org/html/rfc7159">section 7</a> ).  This does not include the 0x7F DEL character, which may be part of other control character definitions (see section 4.6, Bash JSON.sh).  Therefore, the tests must pass <code>["7F"]</code> . <br><br><pre> <code class="html hljs xml">n_string_unescaped_ctrl_char.json ["a\09a"] y_string_unescaped_char_delete.json ["7F"] n_string_escape_x.json ["\x00"]</code> </pre><br>  <b>Screening.</b>  ‚ÄúAll characters can be escaped‚Äù ( <a href="https://tools.ietf.org/html/rfc7159">Section 7</a> ), for example, \ uXXXX.  But some ‚Äî quotes, backslashes, and escape characters ‚Äî MUST be escaped.  The failures tests include shielded characters with no shielded values ‚Äã‚Äãor with values ‚Äã‚Äãwith incomplete shielding.  Examples: <code>["\"]</code> , <code>["\</code> , <code>[\</code> . <br><br><pre> <code class="html hljs xml">y_string_allowed_escapes.json ["\"\\/\b\f\n\r\t"] n_structure_bad_escape.json ["\</code> </pre><br>  The shielding symbol can be used to represent code points (codepoints) at a basic multilingual level (Basic Multilingual Plane, BMP) ( <code>\u005C</code> ).  Successful tests include a zero character ( <code>\u0000</code> zero), which can lead to problems in the C parsers. Failure tests include the capital U <code>\U005C</code> , non-hexadecimal shielded values <code>\u123Z</code> and values ‚Äã‚Äãwith incomplete shielding <code>\u123</code> . <br><br><pre> <code class="html hljs xml">y_string_backslash_and_u_escaped_zero.json ["\u0000"] n_string_invalid_unicode_escape.json ["\uqqqq"] n_string_incomplete_escaped_character.json ["\u00A"]</code> </pre><br>  <b>Non-Unicode escapes</b> <br><br>  Code points outside BMP are represented by shielded UTF-16 encodings: <code>+1D11E</code> becomes <code>\uD834\uDD1E</code> .  Successful tests include single substitutes, since they are valid from the point of view of JSON grammar.  <a href="https://www.rfc-editor.org/errata_search.php%3Frfc%3D7159%26eid%3D3984">A typo 3984</a> in RFC 7159 gave rise to the problem of grammatically correct shielded code points that are not Unicode characters ( <code>\uDEAD</code> ), or non-characters from <code>U+FDD0</code> to <code>U+10FFFE</code> . <br><br>  At the same time, the augmented Backus - Naur form (ABNF, <a href="https://en.wikipedia.org/wiki/Augmented_Backus%25E2%2580%2593Naur_form">Augmented Backus - Naur form</a> ) does not allow the use of non-Unicode code points (section 7) and requires Unicode compliance (section 1). <br><br>  The editors decided that the grammar should not be limited and that it was enough to warn users about the "unpredictability" ( <a href="https://tools.ietf.org/html/rfc7159">RFC 7159, section 8.2</a> ) of the behavior of the parsers.  In other words, parsers MUST parse u-screened non-characters, but the result is unpredictable.  In such cases, the file names begin with the prefix <code>i_</code> (depends on the implementation).  According to the Unicode standard, invalid code points must be replaced with the <code>U+FFFD REPLACEMENT CHARACTER</code> replacement character.  If you have already experienced the <a href="http://seriot.ch/resources/talks_papers/i_love_unicode_softshake.pdf">complexity of Unicode</a> , then you will not be surprised that the replacement is optional and can be done in different ways (see <a href="http://unicode.org/review/pr-121.html">Unicode PR # 121: Recommended Techniques for Replacement Characters</a> ).  Therefore, some parsers use replacement characters, while others leave a shielded form or generate a non-Unicode character (see <a href="https://habr.com/ru/company/mailru/blog/314014/">Section 5 - Parsing Content</a> ). <br><br><pre> <code class="html hljs xml">y_string_accepted_surrogate_pair.json ["\uD801\udc37"] n_string_incomplete_escaped_character.json ["\u00A"] i_string_incomplete_surrogates_escape_valid.json ["\uD800\uD800\n"] i_string_lone_second_surrogate.json ["\uDFAA"] i_string_1st_valid_surrogate_2nd_invalid.json ["\uD888\u1234"] i_string_inverted_surrogates_U+1D11E.json ["\uDd1e\uD834"]</code> </pre><br>  <b>Non Raw Unicode Characters</b> <br><br>  In the previous section, we discussed non-Unicode code points appearing in strings ( <code>\uDEAD</code> ).  These points are valid Unicode in u-shielded form, but are not decoded into Unicode characters. <br><br>  Parsers must also handle regular bytes that do not encode Unicode characters.  For example, in UTF-8 bytes, the FF is not a Unicode character.  Therefore, the string value containing FF is not a UTF-8 encoded string.  In this case, the parser should simply refuse to parse it, because ‚ÄúString value is a sequence of Unicode characters in the amount of zero or more‚Äù ( <a href="https://tools.ietf.org/html/rfc7159">RFC 7159, section 1</a> ) and ‚ÄúJSON text MUST be represented in Unicode‚Äù ( <a href="https://tools.ietf.org/html/rfc7159">RFC 7159 section 8.1</a> ). <br><br><pre> <code class="html hljs xml">y_string_utf8.json ["‚Ç¨?"] n_string_invalid_utf-8.json ["FF"] n_array_invalid_utf8.json [FF]</code> </pre><br>  <b>Ambiguities RFC 7159</b> <br><br>  In addition to the specific cases that we considered, it is almost impossible to determine whether the parser meets the requirements of RFC 7159, because of what was said in <a href="https://tools.ietf.org/html/rfc7159">section 9</a> : <br><br><blockquote>  The JSON parser MUST accept all texts corresponding to the JSON grammar.  The JSON parser MAY accept non-JSON forms or extensions. </blockquote><br><br>  While everything is clear.  All grammatically correct input data MUST be parsed, and the parsers can decide whether to accept other content. <br><br><blockquote>  Implementations may limit: <br><br><ul><li>  the size of the received text; </li><li>  maximum depth of nesting; </li><li>  range and accuracy of numbers; </li><li>  the length of the string values ‚Äã‚Äãand their character set. </li></ul></blockquote><br><br>  All these restrictions sound reasonable (with the possible exception of symbols), but contradict the word "MUST" from the previous quotation.  <a href="https://tools.ietf.org/html/rfc2119">RFC 2119</a> explains its meaning very clearly: <br><br><blockquote>  SHOULD.  This word, like ‚ÄúREQUIRED‚Äù or ‚ÄúFOLLOWS‚Äù, means a mandatory specification requirement. </blockquote><br><br>  RFC 7159 is restrictive, but does not specify minimum requirements.  Therefore, technically, a parser that cannot parse a string longer than three characters still meets the requirements of RFC 7159. <br><br>  In addition, section 9 of RFC 7159 requires parsers to clearly document restrictions and / or allow the use of custom configurations.  But these configurations can lead to compatibility issues, so it‚Äôs best to stay with minimum requirements. <br><br>  Such a lack of specifics against the allowable restrictions practically does not allow one to say for sure whether the RFC 7159 parser matches. After all, you can parse content that does not correspond to grammar (these are ‚Äúextensions‚Äù) and reject content that corresponds to grammar (these are ‚Äúlimitations‚Äù of the parser). <br><br><a name="3"></a><h1>  3. Testing architecture </h1><br>  I wanted to see how the parsers actually behave, regardless of how they should behave.  Therefore, I chose several JSON parsers and set everything up so that I could feed my test files to it. <br><br>  As a Cocoa developer, most parsers are written in Swift and Objective-C.  But there are quite arbitrarily chosen parsers in C, Python, Ruby, R, Lua, Perl, Bash and Rust.  Basically, I tried to cover a variety of age and popularity languages. <br><br>  Some parsers allow you to strengthen or weaken the severity of restrictions, customize Unicode support, or use specific extensions.  I wanted to always configure parsers to work as close as possible to the most rigorous interpretation of RFC 7159. <br><br>  The <code>run_tests.py</code> Python script <code>run_tests.py</code> each test file through each parser (or a single test if the file is passed as an argument).  Usually the parsers were wrappers and returned 0 if successful and 1 if parsing failed.  A separate status was provided for the fall of the parser, as well as a timeout of 5 seconds.  In fact, I turned JSON parsers into JSON validators. <br><br>  <code>run_tests.py</code> compared the return value for each test with the expected result, reflected in the prefix of the file name.  If they did not match or when the prefix was <code>i</code> (depends on the implementation), <code>run_tests.py</code> recorded in a log ( <code>results/logs.txt</code> ) a string of a certain format: <br><br><pre> <code class="bash hljs">Python 2.7.10 SHOULD_HAVE_FAILED n_number_infinity.json</code> </pre><br><img src="https://habrastorage.org/files/8d0/d07/925/8d0d079252ee4f3cafdb500c72b6adb8.png"><br><br>  Then <code>run_tests.py</code> read the log and generated HTML tables with the results ( <code>results/parsing.html</code> ). <br><br>  Each line contains the results for one of the files.  Parsers are presented in columns.  For different results, different cell fill colors are provided: <br><br><img src="https://habrastorage.org/files/2a9/0e8/a64/2a90e8a6419844199ac81a134de84298.png"><br><br>  Tests are sorted by results.  This makes it easier to find similar results and remove redundant ones. <br><br><img src="https://habrastorage.org/files/db3/b13/190/db3b131900c7458ba993d735c7a85d45.png"><br><br><a name="4"></a><h1>  4. Results and comments </h1><br><a name="41"></a><h3>  4.1.  Full results </h3><br>  Full test results can be found here: <a href="http://seriot.ch/json/parsing.html">seriot.ch/json/parsing.html</a> .  Tests are sorted by similarity of results.  In <code>run_tests.py</code> there is an option that allows you to display ‚Äúabbreviated results‚Äù (pruned results): when a test suite gives the same results, only the first test is saved.  The abbreviated file is available here: <a href="http://www.seriot.ch/json/parsing_pruned.html">www.seriot.ch/json/parsing_pruned.html</a> . <br><br>  Falling (red color) is the most serious problem, since parsing uncontrolled input data puts the entire process at risk.  The tests ‚Äúexpected successful execution‚Äù (brown color) are also very dangerous: uncontrolled input data can prevent you from sending the entire document.  The tests ‚Äúexpected to fail‚Äù (yellow color) are less dangerous.  They talk about "extensions" that cannot be parsed.  So everything will work until the parser is replaced by another one who cannot parse these ‚Äúextensions‚Äù. <br><br><img src="https://habrastorage.org/files/16d/94a/dc6/16d94adc60684329940dcd02adcd3e20.png"><br><br>  Then I will review and comment on the most remarkable results. <br><br><a name="42"></a><h3>  4.2.  C-parsers </h3><br>  I chose five C-parsers: <br><br><ul><li>  <a href="https://github.com/zserge/jsmn">github.com/zserge/jsmn</a> </li><li>  <a href="https://github.com/akheron/jansson">github.com/akheron/jansson</a> </li><li>  <a href="https://github.com/rustyrussell/ccan">github.com/rustyrussell/ccan</a> </li><li>  <a href="https://github.com/DaveGamble/cJSON">github.com/DaveGamble/cJSON</a> </li><li>  <a href="https://github.com/udp/json-parser">github.com/udp/json-parser</a> </li></ul><br>  Short comparative table: <br><br><img src="https://habrastorage.org/files/09b/dca/f67/09bdcaf676a14697b25767f6edbb6c18.png"><br><br>  More details can be found in the full results table. <br><br><a name="43"></a><h3>  4.3.  Objective-C parsers </h3><br>  I chose three Objective-C parsers that were very popular in the early days of iOS development, especially because Apple did not release NSJSONSerialization before iOS 5.  All three parsers were interesting to test, since they were used in the development of many applications. <br><br><ul><li>  <a href="https://github.com/johnezang/JSONKit">github.com/johnezang/JSONKit</a> </li><li>  <a href="https://github.com/TouchCode/TouchJSON">github.com/TouchCode/TouchJSON</a> </li><li>  <a href="https://github.com/stig/json-framework">github.com/stig/json-framework</a> aka SBJSON </li></ul><br>  Short comparative table: <br><br><img src="https://habrastorage.org/files/4b0/d9a/ced/4b0d9acedc0549868897dd61e46c7916.png"><br><br>  SBJSON survived after the appearance of the NSJSONSerialization, it is still supported, you can download it through CocoaPods.  Therefore, in <a href="https://github.com/stig/json-framework/issues/219">application # 219,</a> I recorded a crash when the parsley is not a UTF-8 line like [‚ÄúFF‚Äù]. <br><br><pre> <code class="bash hljs">*** Assertion failure <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> -[SBJson4Parser parserFound:isValue:], SBJson4Parser.m:150 *** Terminating app due to uncaught exception <span class="hljs-string"><span class="hljs-string">'NSInternalInconsistencyException'</span></span>, reason: <span class="hljs-string"><span class="hljs-string">'Invalid parameter not satisfying: obj'</span></span> *** First throw call stack: ( 0 CoreFoundation 0x00007fff95f4b4f2 __exceptionPreprocess + 178 1 libobjc.A.dylib 0x00007fff9783bf7e objc_exception_throw + 48 2 CoreFoundation 0x00007fff95f501ca +[NSException raise:format:arguments:] + 106 3 Foundation 0x00007fff9ce86856 -[NSAssertionHandler handleFailureInMethod:object:file:lineNumber:description:] + 198 4 test_SBJSON 0x00000001000067e5 -[SBJson4Parser parserFound:isValue:] + 309 5 test_SBJSON 0x00000001000073f3 -[SBJson4Parser parserFoundString:] + 67 6 test_SBJSON 0x0000000100004289 -[SBJson4StreamParser parse:] + 2377 7 test_SBJSON 0x0000000100007989 -[SBJson4Parser parse:] + 73 8 test_SBJSON 0x0000000100005d0d main + 221 9 libdyld.dylib 0x00007fff929ea5ad start + 1 ) libc++abi.dylib: terminating with uncaught exception of <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> NSException</code> </pre><br><a name="44"></a><h3>  4.4. Apple (NS)JSONSerialization </h3><br> <a href="https://developer.apple.com/reference/foundation/nsjsonserialization">developer.apple.com/reference/foundation/nsjsonserialization</a> <br><br> NSJSONSerialization   iOS 5,       JSON-  OS X  iOS.    Objective-C     Swift: <a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Foundation/NSJSONSerialization.swift">NSJSONSerialization.swift</a> .  Swift 3  NS <a href="https://github.com/apple/swift-corelibs-foundation/commit/b914527d4d560602afc90da29254e1f1571672dd"></a> . <br><br> <b>  </b> <br><br>  JSONSerialization   : <br><br><ul><li>     : <code>[123123e100000]</code> </li><li>    u-   : <code>["\ud800"]</code> </li></ul><br>  JSONSerialization   : <br><br><ul><li>    : <code>[1,]</code>  <code>{"a":0,}</code> </li></ul><br>     ,    ,     .         . <br><br> <b>  </b> <br><br>     JSON-,   JSON-.       ,   ,  JSONSerialization  <code>Double.nan</code> .   , <code>NaN</code>    JSON,  JSONSerialization    ,     . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = [Double.nan] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> JSONSerialization.data(withJSONObject: a, <span class="hljs-attr"><span class="hljs-attr">options</span></span>: []) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> e { } SIGABRT *** Terminating app due to uncaught exception <span class="hljs-string"><span class="hljs-string">'NSInvalidArgumentException'</span></span>, <span class="hljs-attr"><span class="hljs-attr">reason</span></span>: <span class="hljs-string"><span class="hljs-string">'Invalid number value (NaN) in JSON write'</span></span></code> </pre><br><a name="45"></a><h3>  4.5. Freddy (Swift) </h3><br> Freddy (https://github.com/bignerdranch/Freddy) ‚Äî   JSON-,   Swift 3.   ¬´¬ª,    GitHub-    Swift JSON-,      Apple JSONSerialization    JSON-  -. <br><br> Freddy  ,     Cocoa-     Swift    Swift-    JSON- (Array, Dictionary, Double, Int, String, Bool  Null). <br><br>  Freddy <a href="https://www.bignerdranch.com/blog/introducing-freddy-an-open-source-framework-for-parsing-json-in-swift">   2016-</a> ,     .    ,        <code>[1</code> ,  <code>{"a":</code> ,        " ".   <a href="https://github.com/bignerdranch/Freddy/issues/199"> #199</a> ,      ! <br><br>   ,  <code>"0e1"</code>   ,     <a href="https://github.com/bignerdranch/Freddy/issues/198"> #198</a> ,        . <br><br>       18  Freddy      <code>["</code> <code>\</code> .      <a href="https://github.com/bignerdranch/Freddy/issues/206"> #206</a> . <br><br>       Freddy: <br><br><img src="https://habrastorage.org/files/626/13d/e98/62613de98e0b46b4b8d670e1fe2dd0d0.png"><br><br><a name="46"></a><h3>  4.6. Bash JSON.sh </h3><br>   <a href="https://github.com/dominictarr/JSON.sh/">github.com/dominictarr/JSON.sh</a> ,   12  2016 . <br><br>   Bash-       , ,  RFC 7159,       .   Bash  JSON    ,    . <br><br>         <code>:cntlr:</code> .    <code>[\x00-\x1F\x7F]</code> .     JSON <code>0x7F DEL</code>         . <br><br><pre> <code class="html hljs xml"> 00 nul 01 soh 02 stx 03 etx 04 eot 05 enq 06 ack 07 bel 08 bs 09 ht 0a nl 0b vt 0c np 0d cr 0e so 0f si 10 dle 11 dc1 12 dc2 13 dc3 14 dc4 15 nak 16 syn 17 etb 18 can 19 em 1a sub 1b esc 1c fs 1d gs 1e rs 1f us 20 sp 21 ! 22 " 23 # 24 $ 25 % 26 &amp; 27 ' 28 ( 29 ) 2a * 2b + 2c , 2d ‚Äî 2e . 2f / 30 0 31 1 32 2 33 3 34 4 35 5 36 6 37 7 38 8 39 9 3a : 3b ; 3c <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">3d</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">3e</span></span></span><span class="hljs-tag"> &gt;</span></span> 3f ? 40 @ 41 A 42 B 43 C 44 D 45 E 46 F 47 G 48 H 49 I 4a J 4b K 4c L 4d M 4e N 4f O 50 P 51 Q 52 R 53 S 54 T 55 U 56 V 57 W 58 X 59 Y 5a Z 5b [ 5c \ 5d ] 5e ^ 5f _ 60 ` 61 a 62 b 63 c 64 d 65 e 66 f 67 g 68 h 69 i 6a j 6b k 6c l 6d m 6e n 6f o 70 p 71 q 72 r 73 s 74 t 75 u 76 v 77 w 78 x 79 y 7a z 7b { 7c | 7d } 7e ~ 7f del</code> </pre><br>   JSON.sh    <code>["7F"]</code> .  <a href="https://github.com/dominictarr/JSON.sh/issues/46"></a>  .  JSON.sh         10 000    [.     <a href="https://github.com/dominictarr/JSON.sh/issues/47"></a> . <br><br><pre> <code class="bash hljs">$ python -c <span class="hljs-string"><span class="hljs-string">"print('['*100000)"</span></span> | ./JSON.sh ./JSON.sh: line 206: 40694 Done tokenize 40695 Segmentation fault: 11 | parse</code> </pre><br><a name="47"></a><h3>  4.7.   </h3><br>  C / Objective-C  Swift,       .           <a href="http://seriot.ch/json/parsing.html">  </a> .   ,      ,     ,     . <br><br><img src="https://habrastorage.org/files/121/a04/0b2/121a040b2bec4f6f823b82140f2116d4.png"><br><br>    : <br><br><ul><li> Lua JSON 20160728.17 <a href="http://regex.info/blog/lua/json">regex.info/blog/lua/json</a> (     ) </li><li> Lua dkjson 2.5.1 <a href="https://github.com/LuaDist/dkjson">github.com/LuaDist/dkjson</a> </li><li> Go 1.7.1, json mobule <a href="https://golang.org/pkg/encoding/json/">golang.org/pkg/encoding/json</a> </li><li> Python 2.7.10, json module <a href="https://docs.python.org/2.7/library/json.html">docs.python.org/2.7/library/json.html</a> </li><li> JavaScript, macOS 10.12 </li><li> Perl JSON <a href="https://metacpan.org/pod/JSON">metacpan.org/pod/JSON</a> </li><li> Perl JSON::XS <a href="https://metacpan.org/pod/JSON">metacpan.org/pod/JSON</a> ::XS </li><li> PHP 5.6.24, macOS 10.12 </li><li> R rjson <a href="https://cran.r-project.org/web/packages/rjson/index.html">cran.r-project.org/web/packages/rjson/index.html</a> </li><li> R jsonlite <a href="https://github.com/jeroenooms/jsonlite">github.com/jeroenooms/jsonlite</a> </li><li> Rust json-rust <a href="https://github.com/maciejhirsz/json-rust">github.com/maciejhirsz/json-rust</a> </li><li> Rust rustc_serialize::json <a href="https://doc.rust-lang.org/rustc-serialize/rustc_serialize/json/">doc.rust-lang.org/rustc-serialize/rustc_serialize/json</a> </li></ul><br>       Java-,      ,     : <br><br><ul><li> Java Gson 2.7 <a href="https://github.com/google/gson">github.com/google/gson</a> </li><li> Java Jackson 2.8.4 <a href="https://github.com/FasterXML/jackson">github.com/FasterXML/jackson</a> </li><li> Java Simple JSON 1.1.1 <a href="https://code.google.com/archive/p/json-simple/">code.google.com/archive/p/json-simple</a> </li></ul><br> JSON- Python  <code>NaN</code>  <code>-Infinity</code>  .   ,   parse_constant  ,  ,   .     ,               . <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f_parse_constant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError o = json.loads(data, parse_constant=f_parse_constant)</code> </pre><br><a name="48"></a><h3>  4.8. JSON Checker </h3><br> JSON-  JSON-   .      JSON,    . <br><br>      ,        JSON.   ‚Äî  JSON-. <br><br>         JSON_Checker.     <a href="http://www.json.org/JSON_checker/">www.json.org/JSON_checker</a> ,        (): <br><br><blockquote> JSON_Checker ‚Äî  pushdown automaton ,       JSON-.               . JSON_Checker       JSON-. </blockquote><br><br>  JSON_Checker     ,    ,     JSON-      . <br><br>  , JSON_Checker  ,     . ,   <code>[1.]</code> , <code>[0.e1]</code> ,     JSON. <br><br>  , JSON_Checker  <code>[0e1]</code> ,   JSON-.    ,   -   <code>0e1</code>     . <br><br>   JSON_Checker   pushdown automaton    ,         ,        ,   . <br><br><img src="https://habrastorage.org/files/05c/26c/443/05c26c4438994d6088f2aa9ad4f383a1.png"><br><br> <b> 1:  0e1</b> .    <code>ZE</code> ,    <code>0</code> ,     <code>E1</code>    <code>e</code>  <code>E</code> .   ,    . <br><br> <b> 2:  [1.]</b> .   ,   <code>0.</code> ,    .   ,   <code>1.</code> ,  . <br><br> JSON_Checker      <code>FR</code> ,   .   ,      <code>FR</code>   <code>F0</code>  <code>frac0</code> .   <code>1.</code>    . <br><br><img src="https://habrastorage.org/files/e46/373/1c2/e463731c2416454a88287dc4d2275281.jpg"><br><br>    (Obj-C TouchJSON, PHP, R rjson, Rust json-rust, Bash JSON.sh, C jsmn  Lua dkjson)    <code>[1.]</code> .      JSON_Checker?          ,     json.org. <br><br><a name="49"></a><h3>  4.9.   </h3><br>          JSON? , ,  <a href="http://codegolf.stackexchange.com/questions/474/write-a-json-validator"></a>     .   ,       ,      . <br><br>    StackOverflow    <a href="http://stackoverflow.com/questions/2583472/regex-to-validate-json">   Ruby   JSON</a> : <br><br><pre> <code class="bash hljs">JSON_VALIDATOR_RE = /( <span class="hljs-comment"><span class="hljs-comment"># define subtypes and build up the json syntax, BNF-grammar-style # The {0} is a hack to simply define them as named groups here but not match on them yet # I added some atomic grouping to prevent catastrophic backtracking on invalid inputs (?&lt;number&gt; -?(?=[1-9]|0(?!\d))\d+(\.\d+)?([eE][+-]?\d+)?){0} (?&lt;boolean&gt; true | false | null ){0} (?&lt;string&gt; " (?&gt;[^"\\\\]* | \\\\ ["\\\\bfnrt\/] | \\\\ u [0-9a-f]{4} )* " ){0} (?&lt;array&gt; \[ (?&gt; \g&lt;json&gt; (?: , \g&lt;json&gt; )* )? \s* \] ){0} (?&lt;pair&gt; \s* \g&lt;string&gt; \s* : \g&lt;json&gt; ){0} (?&lt;object&gt; \{ (?&gt; \g&lt;pair&gt; (?: , \g&lt;pair&gt; )* )? \s* \} ){0} (?&lt;json&gt; \s* (?&gt; \g&lt;number&gt; | \g&lt;boolean&gt; | \g&lt;string&gt; | \g&lt;array&gt; | \g&lt;object&gt; ) \s* ){0} ) \A \g&lt;json&gt; \Z /uix</span></span></code> </pre><br>      JSON, : <br><br><ul><li> u-  ,  : <code>["\u002c"]</code> </li><li>  ,   : <code>["\\a"]</code> </li></ul><br>      (    JSON-): <br><br><ul><li> True   : <code>[True]</code> </li><li>   : <code>["09"]</code> </li></ul><br><a name="5"></a><h1> 5.   </h1><br>  <a href="https://tools.ietf.org/html/rfc7159">RFC 7159 ( 9)</a> : <br><br><blockquote> JSON-  JSON-   . </blockquote><br><br>        ,     JSON-,        . <br><br> ,     u-  Unicode- ( <code>"\uDEAD"</code> ),    ?    - ?  RFC 7159    . <br><br>       <code>0.00000000000000000000001</code>  <code>-0</code> ?   ,    ? RFC 7159          0  ‚Äì0.    ,      . <br><br>     ,    ( <code>{"a":1,"a":2}</code> )?      ( <code>{"a":1,"a":1}</code> )?       ?       Unicode-,  NFC?  RFC  . <br><br>            .  ‚Äî    (,     ,       JSON-  ). <br><br>  ,        .      ,      .     ,    .          (log statements) / . <br><br>           .       ¬´ <a href="http://seriot.ch/json/transform.html"> </a> ¬ª. <br><br> <b></b> <br><br><ul><li> <code>1.000000000000000005</code>        <code>1.0</code> ,  Rust 1.12.0 / json 0.10.2       <code>1.000000000000000005</code> </li><li> <code>1E-999</code>           (double) <code>0.0</code> ,  Freddy   <code>"1E-999"</code> . Swift Apple JSONSerializattion  Obj-C JSONKit     . </li><li> <code>10000000000000000999</code>        (Swift Apple JSONSerialization),  unsigned long long (Objective-C JSONKit)   (Swift Freddy).  ,  cJSON      ,          <code>10000000000000002048</code> (     ). </li></ul><br> <b></b> <br><br><ul><li>   { <code>"C3A9:"NFC"</code> , <code>"65CC81":"NFD"</code> }  NFC-  NFD-  "√©".     ,   Apple JSONSerialization  Freddy,         . </li><li> <code>{"a":1,"a":2}</code>    <code>{"a":2}</code> (Freddy, SBJSON, Go, Python, JavaScript, Ruby, Rust, Lua dksjon),     <code>{"a":1}</code> (Obj-C Apple NSJSONSerialization, Swift Apple JSONSerialization, Swift Freddy)  <code>{"a":1,"a":2}</code> (cJSON, R, Lua JSON). </li><li> <code>{"a":1,"a":1}</code>    <code>{"a":1}</code> ,   cJSON, R  Lua JSON  <code>{"a":1,"a":1}</code> . </li><li> <code>{"a":0,"a":-0}</code>    <code>{"a":0}</code> ,    <code>{"a":-0}</code> (Obj-C JSONKit, Go, JavaScript, Lua)   <code>{"a":0, "a":0}</code> (cJSON, R). </li></ul><br> <b></b> <br><br><ul><li> <code>["A\u0000B"]</code>  u-   <code>0x00 NUL</code> ,      C-.        (gracefully),  JSONKit  cJSON   . ,  Freddy   <code>["A"]</code> (     0x00). </li><li> <code>["\uD800"]</code>  u-  <code>U+D800</code> ,      UTF-16.    ,        JSON. Python      <code>["\uD800"]</code> . Go  JavaScript      " " <code>U+FFFD REPLACEMENT CHARACTER ["EFBFBD"]</code> , R rjson  Lua dkjson       UTF-8  <code>["EDA080"]</code> . R jsonlite  Lua JSON 20160728.17      <code>["?"]</code> . </li><li> <code>["EDA080"]</code>    <code>U+D800</code> ,      UTF-16,    .      UTF-8     (. <a href="https://habr.com/ru/company/mailru/blog/314014/"> 2.5.  ‚Äî   Unicode-</a> ).     ,  cJSON, R rjson  jsonlite, Lua JSON, Lua dkjson  Ruby,    <code>["EDA080"]</code> . Go  JavaScript  <code>["EFBFBDEFBFBDEFBFBD"]</code> ,     (   ). Python 2    Unicode-  <code>["\ud800"]</code> ,  Python 3   <code>UnicodeDecodeError</code> . </li><li> <code>["\uD800\uD800"]</code>     . R jsonlite  <code>["\U00010000"]</code> ,  Ruby- ‚Äî <code>["F0908080"]</code> . </li></ul><br><a name="6"></a><h1> 6. STJSON </h1><br> STJSON ‚Äî  JSON-,   Swift 3    600+ .   ,  ,         . <br><br> <a href="https://github.com/nst/STJSON">github.com/nst/STJSON</a> <br><br> STJSON API  : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = STJSONParser(data: data) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> o = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> p.parse() print(o) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> e { print(e) }</code> </pre><br> STJSON     : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = STJSON(data:data, <span class="hljs-attr"><span class="hljs-attr">maxParserDepth</span></span>:<span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-attr"><span class="hljs-attr">options</span></span>:[.useUnicodeReplacementCharacter])</code> </pre><br>       : <code>y_string_utf16.json</code> .   , ,      , STJSON    UTF-8 ,      , ,  ,      .  STJSON   ,          UTF-16  UTF-32. <br><br><a name="7"></a><h1> 7.  </h1><br> JSON ‚Äî     ,     .    , : <br><br><ul><li>          ( <a href="https://habr.com/ru/company/mailru/blog/314014/"> 1</a> ); </li><li>     , RFC-7159,    ( <a href="https://habr.com/ru/company/mailru/blog/314014/"> 2</a> ); </li><li>    30 ,     ,    ,      ( <a href="https://habr.com/ru/company/mailru/blog/314014/"> 4</a> ). </li></ul><br>   ,  ,  json_checker.c   json.org   JSON <code>[0e1]</code> ( <a href="https://habr.com/ru/company/mailru/blog/314014/"> 4.24</a> ),      ,  ,   .    (  )      ,    ,    ,      . <br><br>     JSON- ( <a href="https://habr.com/ru/company/mailru/blog/314014/"> 6</a> ),     JSON-    RFC 7159. ,      pull request'. <br><br>    : <br><br><ul><li>   <b>  </b> ,  ,     Apple-,  <a href="http://www.newtonsoft.com/json">Json.Net</a> . </li><li>  <b> JSON</b> .   ,  ,    ( <a href="https://habr.com/ru/company/mailru/blog/314014/"> 4</a> ).   ,       ( <a href="https://habr.com/ru/company/mailru/blog/314014/"> 5</a> ). ,  -     JSON       (. <a href="https://habr.com/ru/company/mailru/blog/314014/"> 4.2.1</a> ). </li><li>    ,  <b>JSON-</b>  JSON-   -. </li><li> <b> </b>     (.   <a href="http://seriot.ch/resources/talks_papers/20141106_asfws_unicode_hacks.pdf">Unicode Hacks</a> ). </li><li>      <b>  </b> ,  YAML, <a href="http://bsonspec.org/">BSON</a>  <a href="https://developers.google.com/protocol-buffers/">ProtoBuf</a> ,      JSON. Apple   Swift- <a href="https://github.com/apple/swift-protobuf-plugin">github.com/apple/swift-protobuf-plugin</a> . </li></ul><br>     ,  ¬´¬ª   HTML, CSS  JSON  ¬´¬ª   PHP  JavaScript   . ,   ,     ,      , -     ,     .       . <br><br><a name="8"></a><h1> 8.  </h1><br><ol><li>   <a href="http://seriot.ch/json/parsing.html">seriot.ch/json/parsing.html</a> ,    <a href="https://habr.com/ru/company/mailru/blog/314014/"> 4</a> . </li><li>   <a href="http://seriot.ch/json/transform.html">seriot.ch/json/transform.html</a> ,    <a href="https://habr.com/ru/company/mailru/blog/314014/"> 6</a> . </li><li>    JSON <a href="https://github.com/nst/JSONTestSuite">github.com/nst/JSONTestSuite</a> ,     . </li><li> STJSON <a href="https://github.com/nst/STJSON">github.com/nst/STJSON</a> ,  ,   Swift 3. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/314014/">https://habr.com/ru/post/314014/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314000/index.html">High availability cluster on postgresql 9.6 + repmgr + pgbouncer + haproxy + keepalived + control via telegram</a></li>
<li><a href="../314002/index.html">Hackers Shadow Brokers have published a new piece of data grouping Equation Group</a></li>
<li><a href="../314004/index.html">My Ragnarok</a></li>
<li><a href="../314008/index.html">Automation again: Python crawled to routers</a></li>
<li><a href="../314012/index.html">Backing up a standalone blog on Wordpress in the Google Drive cloud</a></li>
<li><a href="../314016/index.html">Search for the shortest paths in road networks: from theory to implementation</a></li>
<li><a href="../314018/index.html">We generate beautiful pictures for social networks</a></li>
<li><a href="../314020/index.html">We work with a budget institution. Part 4</a></li>
<li><a href="../314022/index.html">How to make virtual infrastructure more accessible</a></li>
<li><a href="../314024/index.html">Huawei Hosting Platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>