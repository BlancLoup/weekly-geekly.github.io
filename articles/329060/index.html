<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to organize a large React-application and make it scalable</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the best features of React is that it does not impose any restrictions on the file structure of the project. Therefore, on StackOverflow and si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to organize a large React-application and make it scalable</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/c33/228/563/c3322856334b481d878835887423faec.png"><br><br>  One of the best features of React is that it does not impose any restrictions on the file structure of the project.  Therefore, on StackOverflow and similar resources there are so many questions about how to structure React applications.  This is a very controversial topic.  There is no one right way.  We propose to understand this issue using the <a href="https://www.sitepoint.com/organize-large-react-application/">article by Jack Franklin</a> , in which he talks about the approach to structuring large React-applications.  Here you will learn what decisions you can make when building React-applications: about choosing tools, structuring files and splitting components into smaller parts. <br><a name="habracut"></a><br><h2>  Build and code validation tools </h2><br>  Webpack is a great tool for collecting projects.  Despite its complexity, the fact that the team did a great job on version 2 and the new documentation site greatly simplifies the matter.  As soon as you take a Webpack, with a clear concept in your head, you really have an incredibly powerful tool.  Babel can be used to compile the code, including transformations specific to React: for example, JSX and webpack-dev-server for local ‚Äúhosting‚Äù of the site.  Perhaps HMR will not give any great benefit, so it will suffice to use webpack-dev-server with its automatic page refresh. <br><br>  We will also use the syntax of ES2015 modules (which is transported by Babel) to import and export dependencies.  This syntax has been around for a long time, and although the Webpack supports CommonJS (import syntax in Node style), it‚Äôs better to use the latest and the best.  In addition, the Webpack can remove the dead code from the bundle using ES2015 modules, which, although not perfect, is a very convenient feature that will become more useful when the community moves to publishing code to npm in ES2015. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Configuring the resolution of Webpack modules </h2><br>  The only thing that can be frustrating when working with large projects with an embedded file structure is the definition of relative paths between files.  You will find that you have a lot of code that looks like this: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./foo'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> bar <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../../bar'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> baz <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../lib/baz'</span></span></code> </pre> <br>  When you create your application using a Webpack, you can specify the directory in which the Webpack should look for the file if it cannot find it.  This allows you to determine the base folder to which all imports belong.  For example, you can always put your code in the src directory.  And you can make the Webpack always look in this directory.  This is done in the same place where you inform the Webpack of any other file extensions you may be using, for example jsx: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// inside Webpack config object { resolve: { modules: ['node_modules', 'src'], extensions: ['.js', '.jsx'], } }</span></span></code> </pre> <br>  The default value for resolve.modules is <code>['node_modules']</code> , so you also need to add it, otherwise Webpack will not be able to import files installed using npm or yarn. <br><br>  After that, you can always import files relative to the src directory: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./foo'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> bar <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'app/bar'</span></span> <span class="hljs-comment"><span class="hljs-comment">// =&gt; src/app/bar import baz from 'an/example/import' // =&gt; src/an/example/import</span></span></code> </pre> <br>  Although it ties up your application code on a Webpack, this is probably a profitable compromise, because it makes it easier for you to execute the code and makes it easier to add imports. <br><br><h2>  Directory structure </h2><br>  There is no single correct directory structure for all React applications.  As with the rest of this article, you should change the structure to suit your preferences.  The following describes one of the examples of a well-functioning structure. <br><br><h3>  The code lives in src </h3><br>  To make it all organized, put all the application code in a directory called src.  It contains only the code that is reduced to the final bundle, and nothing else.  This is useful because you can tell Babel (or any other code processing tool) to simply look in one directory and make sure that it does not process any code that it does not need.  Other code, such as Webpack configuration files, is located in the appropriate directory.  For example, the top-level directory structure may contain: <br><br><pre> <code class="javascript hljs">- <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src</span></span></span><span class="hljs-function"> =&gt;</span></span> app code here - <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">webpack</span></span></span><span class="hljs-function"> =&gt;</span></span> webpack configs - <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scripts</span></span></span><span class="hljs-function"> =&gt;</span></span> any build scripts - <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tests</span></span></span><span class="hljs-function"> =&gt;</span></span> any test specific code (API mocks, etc)</code> </pre> <br>  Typically, the only files at the top level are index.html, package.json, and any dotfiles, such as .babelrc.  Some people prefer to include the Babel configuration in package.json, but in large projects with many dependencies, these files may become too large, so it‚Äôs advisable to use .eslintrc, .babelrc, etc. <br><br>  By <code>resolve.modules</code> application code in src, you can also use the <code>resolve.modules</code> setting mentioned above, which simplifies the import. <br><br><h2>  React components </h2><br>  Having defined the src directory, you need to decide how to structure the components.  If you put them all in one big folder, such as src / components, then in large projects it is very quickly cluttered. <br><br>  The general tendency is to have separate folders for ‚Äúsmart‚Äù and ‚Äúsilly‚Äù components (also known as container and presentation components), but this explicit division is not always useful.  And although you probably have components that can be classified as ‚Äúsmart‚Äù and ‚Äústupid‚Äù (see below), it is not necessary to create folders for each of these categories. <br><br>  We grouped components based on the areas of the application in which they are used, along with the core directory for common components that are used everywhere (buttons, headers and footers are components that are universal and reusable).  The remaining directories correspond to specific areas of the application.  For example, we have a directory called cart, which contains all the components associated with a shopping cart, and a directory called listings, which contains the code for lists of things that users can buy on the page. <br><br>  Grouping by catalogs also means that you can avoid unnecessary prefixes pointing to the application area in which components are used.  For example, if we have a component that displays the total cost of the user's cart, we can call it Total, not CartTotal, because it is imported from the cart directory: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Total <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'src/cart/total'</span></span> <span class="hljs-comment"><span class="hljs-comment">// vs import CartTotal from 'src/cart/cart-total'</span></span></code> </pre> <br>  This rule can sometimes be violated: sometimes an additional prefix can bring additional clarity, especially if you have 2-3 similarly named components.  But often this method avoids duplicate names. <br><br><h2>  Jsx extension instead of capital letters </h2><br>  Many people use capital letters in the names of files with React components to distinguish them from regular JavaScript files.  Thus, in the above import files will be called CartTotal.js, or Total.js.  But you can stick to lowercase letters with hyphens as separators, that is, use the .jsx file extension to distinguish React components: cart-total.jsx. <br><br>  This gives a slight additional advantage: you can easily search only your React files, limiting your search in .jsx files, and you can even apply specific Webpack plugins to them if necessary. <br><br>  Whichever file naming convention you choose, it is important to adhere to it.  Having a combination of several symbols in your application will quickly become a nightmare in which you have to somehow navigate. <br><br><h2>  Only one component per file </h2><br>  Following the previous rule, we adhere to the agreement that we should always have only one component in one file, and the component should always be the default export. <br><br>  Usually our React files look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { Component, PropTypes } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Total</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br>  In the case when we have to wrap a component in order to connect it, for example, to the Redux data store, the fully wrapped component becomes the default export: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { Component, PropTypes } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { connect } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Total</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> connect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {...})(Total)</code> </pre> <br>  Have you noticed that we are still exporting the original component?  This is really useful for testing when you can work with a ‚Äúsimple‚Äù component, and not configure Redux in your unit tests. <br><br>  When exporting a default component, it is easy to import a component and know how to get it, instead of looking for the exact name.  One of the drawbacks of this approach is that the importing user can invoke the component in any way.  Once again, we have an agreement for this: the import must be done by file name.  Therefore, if you import total.jsx, then the component should be named Total.  user-header.jsx becomes a UserHeader, and so on. <br><br><h2>  Smart and Stupid React Components </h2><br>  Above we mentioned the separation of components into ‚Äúsmart‚Äù and ‚Äústupid‚Äù.  And although we do not list them in separate directories, you can generally divide the application into these two types of components: <br><br><ul><li>  Smart components manipulate data, connect to Redux, and deal with user interaction. </li><li>  "Stupid" components only provide a set of properties for displaying some data on the screen. </li></ul><br>  ‚ÄúStupid‚Äù components make up the bulk of our application, and, if possible, you should always give them preference.  They are easier to work with, fewer problems, and easier to test. <br><br>  Even when we have to create ‚Äúsmart‚Äù components, we try to keep all the JavaScript logic in a separate file.  Ideally, components that manipulate data should pass this data to some JavaScript, which will actually do so.  Then the manipulation code can be tested separately from React, and you can do anything with it when testing the React component. <br><br><h2>  Avoid large render methods </h2><br>  One thing we strive for is to have many small React components, and not a smaller number of larger ones.  A good indicator that your component becomes too large is the size of the rendering function.  If it becomes cumbersome, or you need to break it up into several smaller functions, then it may be time to think about splitting the component. <br><br>  This is not a hard and fast rule;  You and your team should clearly understand what is considered a ‚Äúbig‚Äù component for you before increasing their number.  But the size of the component's <code>render</code> function is a good guide.  You can also use the number of props or items as another good indicator.  If a component accepts seven different props, this may be a sign that it is doing too much. <br><br><h2>  Always use the prop-type </h2><br>  React allows, using the prop-types package, to document the names and types of properties that you expect to be passed to the component.  Note that this is not the case in React 15.5, previously proptypes was part of the React module. <br><br>  When declaring the names and types of expected properties, and whether they are optional, you should feel confident in working with components, and spend less time debugging if you forgot the property name or assigned the wrong type to it.  This can be achieved using the ESLint-React PropTypes rule. <br><br>  It may seem that the time to add them will be wasted.  But if you do this, you will thank yourself for re-using the component that you wrote six months ago. <br><br><h2>  Redux </h2><br>  We use Redux to manage data in many of our applications, and structuring Redux applications is another very common question that has many different opinions. <br><br>  The winner for us is Ducks, which puts actions (actions), reducer and action creators for each part of your application in one file. <br><br>  Instead of having reducers.js and actions.js, each of which contains pieces of code to communicate with each other, the Ducks system claims that it makes sense to group related code into one file.  Suppose you have a Redux store with two top-level keys, <code>user</code> and <code>posts</code> .  Your folder structure will look like this: <br><br><pre> <code class="javascript hljs">ducks - index.js - user.js - posts.js</code> </pre> <br>  index.js will contain the code that creates the main reducer, possibly using <code>combineReducers</code> from Redux, and in user.js and posts.js you put all the code for them, which usually looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// user.js const LOG_IN = 'LOG_IN' export const logIn = name =&gt; ({ type: LOG_IN, name }) export default function reducer(state = {}, action) { .. }</span></span></code> </pre> <br>  This eliminates the need to import actions and action creators from different files and allows you to store nearby code for different parts of your repository. <br><br><h2>  Standalone JavaScript Modules </h2><br>  Although this article focused on React components, you can write a lot of code completely separate from React when creating a React application. <br><br>  It is recommended to do this each time you find a component with business logic that can be removed from a component.  A directory with the name lib or services usually works well - the specific name does not matter, but a directory full of ‚Äúnon-React components‚Äù is really what you need. <br><br>  These services sometimes export a group of functions, or an object of related functions.  For example, we have <code>services/local-storage</code> , which provides a small wrapper around the <code>window.localStorage</code> native API: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// services/local-storage.js const LocalStorage = { get() {}, set() {}, ... } export default LocalStorage</span></span></code> </pre> <br>  Keeping your logic separate from such components has some really great advantages: <br><br><ul><li>  You can test this code in isolation, without having to render any React components. </li><li>  In your React components, you can silence services to have the data you need for a specific test. </li></ul><br><h2>  Tests </h2><br>  The Facebook Jest framework is a great tool for testing.  It does a lot of tests very quickly and well, runs quickly in the view mode, quickly gives you feedback and out of the box provides some convenient features for React testing.  Consider how to structure tests. <br><br>  Someone will say that it is better to have a separate directory that contains all the tests for all tasks.  If you have src / app / foo.jsx, then there will also be tests / app / foo.test.jsx.  But in practice, when the application grows, it makes it difficult to find the necessary files.  And if you move files to src, you often forget to move them to test, and the structures lose synchronicity.  In addition, if you have a file in tests, in which you need to import a file from src, you will get a very long import.  Surely everyone faced: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../../src/app/foo'</span></span></code> </pre> <br>  It‚Äôs hard to work with and difficult to fix if you change the directory structure. <br><br>  But the placement of each test file along with the source file avoids all these problems.  To distinguish them, we add the suffix .spec to our tests, although others use .test or just -test, but they all live next to files with the source code with the same name: <br><br><pre> <code class="javascript hljs">- cart ‚Äî total.jsx ‚Äî total.spec.jsx - services ‚Äî local-storage.js ‚Äî local-storage.spec.js</code> </pre> <br>  As the directory structure changes, it is easy to move the correct test files.  Also immediately noticeable when the file has no tests.  You can quickly identify these problems and fix them. <br><br><h2>  findings </h2><br>  There are many ways to get things done, it can be said about React.  One of the best features of the framework is how it allows you to make the most decisions about tools, build tools, and directory structure.  We hope that this article has given you some ideas on how to structure your larger React applications. </div><p>Source: <a href="https://habr.com/ru/post/329060/">https://habr.com/ru/post/329060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329044/index.html">Not only WannaCry: EternalBlue exploits new attacks</a></li>
<li><a href="../329046/index.html">To prevent the carriage from turning into a pumpkin, or why we need test recoveries from backups</a></li>
<li><a href="../329048/index.html">Nadezhda Moroshkina: ‚ÄúYou are not picking a team for the signs of the zodiac?‚Äù</a></li>
<li><a href="../329050/index.html">You have the right to anonymity. Part 1. Introduction and world practice</a></li>
<li><a href="../329056/index.html">Selection of slides from Julia Evans</a></li>
<li><a href="../329062/index.html">Choosing a DBMS for storing time series</a></li>
<li><a href="../329064/index.html">How was Bell wrong (if the article gave the right example)</a></li>
<li><a href="../329066/index.html">Ubuntu + XRDP + x11RDP terminal server, with sound support, for surfing the Internet - a step by step guide</a></li>
<li><a href="../329068/index.html">Overview of the profession Data Scientist</a></li>
<li><a href="../329072/index.html">Lectures of the Technosphere. Infopoisk. Part 1 (Spring 2017)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>