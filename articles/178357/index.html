<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Validation of ASP.NET requests: from <? I [az! / \?] | & # To XSS Type-1 WAF</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúThe ability to validate queries in ASP.NET is designed to perform basic input control. It is not intended to make decisions regarding the security of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Validation of ASP.NET requests: from <? I [az! / \?] | & # To XSS Type-1 WAF</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  ‚ÄúThe ability to validate queries in ASP.NET is designed to perform basic input control.  It is not intended to make decisions regarding the security of the developed web applications.  Only the developers themselves can determine which content should process their code.  Microsoft recommends checking all input data from any source.  We strive to contribute to the development of secure applications by our customers, and the query validation functionality has been designed and implemented to help developers in this direction.  For more information about our design recommendations, read the MSDN article: <a href="http://msdn.microsoft.com/en-us/library/ff649487.aspx">msdn.microsoft.com/en-us/library/ff649487.aspx#pagguidelines0001_inputdatavalidation</a> . ‚Äù </blockquote><br>  Official status of the ASP.NET Request Validation under <a href="http://www.quotium.com/research/advisories/XSS-NetRequestValidation.php">the</a> Microsoft Security Response Center <br><br>  Despite the sudden response of MSRC to the recent report by Quotium Research Center on the discovery of another way to bypass the validation of requests in ASP.NET, it is worth noting that it is designed specifically for making decisions regarding the security of a web application.  This is supported by the name of the class that implements the main set of checks (System.Web.CrossSiteScriptingValidation) and its very essence, which is to prevent some subset of XSS Type-1 class attacks (reflected cross-site scripts), and the original <a href="http://www.asp.net/whitepapers/request-validation">article</a> from the web stack developers .  Another question is how effectively this functionality could be implemented and how to get a full-fledged web application firewall from the existing primitive regular filter protecting against any XSS Type-1 vectors? <br><a name="habracut"></a><br>  To answer this question, it is necessary to understand the implementation details of query validation in different versions of the .NET Framework, its limitations, known workarounds, and the possibilities of extending its functionality. <br><br><h4>  1. The Evolution of ASP.NET Query Validation </h4><br>  In all versions of ASP.NET (coinciding with versions of the .NET Framework), starting with v1.1 and ending with v4.5, request validation is reduced to searching for various elements of the HTTP request for occurrences of regular set chains, which describes the black list of dangerous values.  From the point of view of coding, it is performed by a recognizing automaton implemented for performance reasons manually, without the use of standard regular expressions.  The set of dangerous values ‚Äã‚Äãcontains elements of the HTML language, which can violate the integrity of the output document, if used in it without sufficient preprocessing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For the first time, the request validation mechanism was implemented in ASP.NET v1.1 and used a fairly wide black list.  The query processing was blocked if any parameters of the query string or form field values ‚Äã‚Äãmatched any of the regular expressions: <br><br><ul><li>  &lt;? i [az! /] </li><li>  (? i: script) \ s? \: </li><li>  (? i: on [az]) * \ s * = </li><li>  (? i: ex) pression \ ( </li></ul><br>  There is nothing surprising in the fact that developers preferred to completely disable this feature due to the large number of false positives.  Therefore, in ASP.NET v2.0, the set of dangerous values ‚Äã‚Äãwas greatly reduced and reached v4.5 in an unchanged form: <br><br><ul><li>  # &amp; </li><li>  &lt;? i [az! / \?] </li></ul><br>  At the stage of preparing ASP.NET v4.0, the developers also stated that the set (? I: script) \ s ?: will be returned to the list, but this did not happen either in v4.0 or v4.5. <br><br>  From version to version, not only the set of dangerous values ‚Äã‚Äãwas changed, but also the area of ‚Äã‚Äãvalidation and the possibilities for developers to control this process.  So, in v2.0, it became possible to disable the validation of requests for individual pages, and in v4.0 a new so-called mode was introduced.  deferred granular validation, in which each of the parameters is checked when accessing it from the code of the web application, and not at the stage of preliminary processing of the request.  Starting with v4.0, in addition to the parameters of the query string and form field values, the validation area also includes <br><br><ul><li>  values ‚Äã‚Äãof all elements from Request.Cookies; </li><li>  names of downloaded files from Request.Files; </li><li>  Request.RawUrl, Request.Path, and Request.PathInfo values </li></ul><br><h4>  2. Validation of requests in ASP.NET v4.x </h4><br>  In the latest versions of ASP.NET, as part of the validation of the request, a number of additional checks are also performed, which are performed at the earliest stages of its life cycle.  Their complete list is given in the table: <br><table><tbody><tr><th>  CHECK </th><th>  SETTINGS AND VALUES </th></tr><tr><td>  <nobr>Check Length Request.Path</nobr> </td><td>  The maxUrlLength attribute in the &lt;httpRuntime&gt; section.  It can be defined globally for the entire application, or for individual virtual paths or pages. <br><br>  Blocks the processing of an HTTP request containing a path longer than 260 characters.  This value can be increased to the limits defined in <a href="http://msdn.microsoft.com/en-us/library/ms689462.aspx">IIS</a> or <a href="http://support.microsoft.com/kb/820129">http.sys</a> . </td></tr><tr><td>  Checking the length of the Request.RawUrl fragment containing the query string </td><td>  The maxQueryStringLength attribute in the &lt;httpRuntime&gt; section.  It can be defined globally for the entire application, or for individual virtual paths or pages. <br><br>  Blocks the processing of an HTTP request containing a query string longer than 2048 characters.  This value can be increased to the limits, <a href="http://msdn.microsoft.com/en-us/library/ms689462.aspx">IIS</a> or <a href="http://support.microsoft.com/kb/820129">http.sys</a> . </td></tr><tr><td>  Scanning Request.Path for the presence of characters defined in ASP.NET as potentially dangerous </td><td>  The requestPathInvalidCharacters attribute in the &lt;httpRuntime&gt; section.  It can be defined globally for the entire application, or for individual virtual paths or pages. <br><br>  Blocks the processing of an HTTP request if the path in it contains any of the characters: <br><ul><li>  &lt;(XSS attack) </li><li>  &gt; (XSS attacks) </li><li>  * (attacks on the canonization of file names) </li><li>  % (URL decoder attacks) </li><li>  : (attacks on alternative NTFS data streams) </li><li>  &amp; (query string parser attacks) </li><li>  \ (attacks on canonization of file paths) </li><li>  ?  (attack on parser query string) </li></ul><br>  In the requestPathInvalidCharacters attribute, forbidden characters are enclosed in double quotes and are separated by commas. <br><br>  The sequence of path characters "\ .." is not included in this list due to the fact that IIS v6 + canonizes URIs automatically, correctly processing such sequences.  In practice, errors associated with the appearance of the forward slash characters in the path also do not occur, since  in the process of canonization, they are replaced by reverse ones. </td></tr><tr><td>  Finding the right managed configuration for each Request.Path </td><td>  The relaxedUrlToFileSystemMapping attribute in the &lt;httpRuntime&gt; section.  It can only be defined globally for the entire application. <br><br>  By default, this attribute is set to false, which tells ASP.NET to treat the component path in the URL as a valid file path that conforms to NTFS rules.  This restriction can be disabled by setting the attribute value to true. </td></tr><tr><td>  Checking Request.QueryString, Request.Form, Request.Files, Request.Cookies, Request.Path, Request.PathInfo, Request.RawUrl for potentially dangerous values </td><td>  The requestValidationMode attribute in the &lt;httpRuntime&gt; section.  It can be defined globally for the entire application, or for individual virtual paths or pages. <br><br>  Sets the mode in which requests for the web application will be validated.  A value of 4.0 (default) includes a deferred granular validation, which is performed with the direct access of the web application code to the elements from the validation area.  Setting this attribute to 2.0 returns the validation mode used in previous versions of ASP.NET. <br><br>  The requestValidationType attribute in the &lt;httpRuntime&gt; section.  It can only be defined globally for the entire application. <br><br>  Sets the type of the successor to the <a href="http://msdn.microsoft.com/en-us/library/system.web.util.requestvalidator.aspx">RequestValidator</a> class that implements the query validation functionality.  The default class is System.Web.Util.RequestValidator. </td></tr></tbody></table>  The last check is exactly that visible part of the iceberg, called request validation, and available to web application developers to extend its functionality. <br><br><h4>  3. Internal device validation requests </h4><br>  The source code of the IsValidRequestString method of the System.Web.Util.RequestValidator class, which is used by default for validating requests in ASP.NET v2.0 +, looks like this: <br><br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidRequestString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HttpContext context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, RequestValidationSource requestValidationSource, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> collectionKey, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> validationFailureIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (requestValidationSource == RequestValidationSource.Headers) { validationFailureIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !CrossSiteScriptingValidation.IsDangerousString(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> validationFailureIndex); }</code> </pre> <br>  It should be noted that before calling the IsValidRequestString method from the string passed in the value parameter, all occurrences of the zero byte are cut.  This behavior is implemented in the ValidateString method of the HttpRequest class and cannot be overridden by the developer. <br><br>  As can be seen from the source code, the basic functionality of request validation is implemented in the IsDangerousString method of the CrossSiteScriptingValidation class: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsDangerousString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> matchIndex</span></span></span><span class="hljs-function">)</span></span> { matchIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num2 = s.IndexOfAny(startingChars, startIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num2 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num2 == (s.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } matchIndex = num2; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = s[num2]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch != <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ch == <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>) &amp;&amp; ((IsAtoZ(s[num2 + <span class="hljs-number"><span class="hljs-number">1</span></span>]) || (s[num2 + <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'!'</span></span>)) || ((s[num2 + <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) || (s[num2 + <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'?'</span></span>)))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s[num2 + <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'#'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } startIndex = num2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre><br>  Obviously, this filter is an automaton that recognizes in the transmitted string the occurrence of chains of a regular set &lt;? I [az! / \?] | &amp; #.  In addition, the CrossSiteScriptingValidation class also defines two auxiliary methods that are not available for extending or modifying their functionality: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsDangerousUrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(s)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } s = s.Trim(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = s.Length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((((length &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; ((s[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'h'</span></span>) || (s[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'H'</span></span>))) &amp;&amp; ((s[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'t'</span></span>) || (s[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'T'</span></span>))) &amp;&amp; (((s[<span class="hljs-number"><span class="hljs-number">2</span></span>] == <span class="hljs-string"><span class="hljs-string">'t'</span></span>) || (s[<span class="hljs-number"><span class="hljs-number">2</span></span>] == <span class="hljs-string"><span class="hljs-string">'T'</span></span>)) &amp;&amp; ((s[<span class="hljs-number"><span class="hljs-number">3</span></span>] == <span class="hljs-string"><span class="hljs-string">'p'</span></span>) || (s[<span class="hljs-number"><span class="hljs-number">3</span></span>] == <span class="hljs-string"><span class="hljs-string">'P'</span></span>)))) &amp;&amp; ((s[<span class="hljs-number"><span class="hljs-number">4</span></span>] == <span class="hljs-string"><span class="hljs-string">':'</span></span>) || (((length &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) &amp;&amp; ((s[<span class="hljs-number"><span class="hljs-number">4</span></span>] == <span class="hljs-string"><span class="hljs-string">'s'</span></span>) || (s[<span class="hljs-number"><span class="hljs-number">4</span></span>] == <span class="hljs-string"><span class="hljs-string">'S'</span></span>))) &amp;&amp; (s[<span class="hljs-number"><span class="hljs-number">5</span></span>] == <span class="hljs-string"><span class="hljs-string">':'</span></span>)))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s.IndexOf(<span class="hljs-string"><span class="hljs-string">':'</span></span>) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidJavascriptId</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(id)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CodeGenerator.IsValidLanguageIndependentIdentifier(id); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  The first checks the URL and considers dangerous all values ‚Äã‚Äãthat do not satisfy the set ^ (? I: https? :) | [^:].  The second checks the value of the argument against the grammar rule for language identifiers: ^ (? I: [a-z _] [a-z0-9 _]) $.  Both methods were called from IsDangerousString as part of the validation of requests in ASP.NET v1.1.  In all other versions, they are used only in some ASP.NET WebForms controls as functional verification methods and do not raise a RequestValidException exception. <br><br><h4>  4. Disadvantages of the standard implementation and ways to circumvent it </h4><br>  Obviously, the standard implementation of the validation of requests has a number of drawbacks that make it really unsuitable for making decisions regarding the security of a web application. <br><br>  First, the reviewed checks can only protect against a limited subset of XSS Type-1 class attacks that require opening a tag to conduct them.  In the event that an attack of a reflected XSS is possible as a result of the implementation of the parameter values ‚Äã‚Äãinside the tag, attribute, or code of the client script, standard validation of requests will no longer be able to prevent it. <br><br>  Secondly, blacklist control, by itself, is not a sufficient measure to ensure security.  This is due to the presence of several well-known ways to bypass the standard query validation: <br><br><ul><li>  The limitation on &lt;? I [az! / \?] Can be bypassed using the percent sign between the opening angle bracket and the tag name (&lt;% img src = # onerror = alert (1) /&gt;).  In this case, the IE v9-HTML parser will consider this the correct tag definition.  In some cases, if the web application implements Unicode-canonization of request parameters, it is also possible to bypass using Unicode-wide values ‚Äã‚Äã(% uff1c img% 20src% 3D% 23% 20onerror% 3Dalert% 281% 29% 2f% uff1e). </li><li>  Restriction on (? I: script) \ s? \: And (? I: ex) pression \ (costs using white space characters inside the script and between the expression and the opening bracket (java% 09script: alert (1) and expression% 09 ( alert (1))). </li><li>  The restriction on # &amp; does not take into account the existence of named references to HTML entities that can also be used in a number of vectors (javascript% 26Tab;: alert (1)).  It should also be noted here that the standard implementation of the ASP.NET HTML decoder (HttpUtility.HtmlDecode) ‚Äúknows‚Äù only about the existence of 253 named references to HTML entities, while in the HTML standard there are significantly <a href="http://dev.w3.org/html5/html-author/charref">more of them</a> .  This allows multiple HTML entities to be forwarded to the output document, even if the web application performs HTML decoding of the parameter values ‚Äã‚Äãduring the preprocessing of input data. </li></ul><br>  But the main drawback of the standard implementation is the request processing stage, at which it is validated.  Even with the delayed mode enabled, without having information about the contents of an already generated response document, it is impossible to make correct assumptions about the danger of a particular parameter for a particular class of attacks.  For example, if a parameter containing HTML markup elements does not fall into the server‚Äôs response, it is rather strange to argue about its potential danger from the point of view of XSS Type-1.  This is about the same as stating the dangers of a ‚ÄúSELECT‚Äù value without having information about whether it ends up in the SQL query.  Following this logic, ASP.NET developers would also need to include in its request validation the search in its parameters for elements of SQL syntax, paths, XPath expressions and other character sequences that are typical for injections into any languages, and not limit yourself to only a small subset of attacks XSS specific type.  Of course, this approach generates a lot of false positives, which leads to both a complete shutdown of validation for the entire application, and the appearance of tools that allow you to do this without much effort (for example, <a href="http://nuget.org/packages/DisableRequestValidation/">nuget.org/packages/DisableRequestValidation</a> ). <br><br>  However, all these shortcomings can be eliminated by taking advantage of the opportunity discussed in the next section. <br><br><h4>  5. Extension of query validation functionality </h4><br>  Starting with ASP.NET v4.0, developers have the opportunity to extend the functionality of query validation, incl.  completely overriding the standard implementation.  In order to accomplish this, it is enough to create a descendant of the class System.Web.Util.RequestValidator by redefining the IsValidRequestString method in it.  This method is called when it is necessary to check the next query parameter and takes the following arguments: <br><br><ul><li>  HttpContext context - the context of the HTTP request, within which the check is performed; </li><li>  string value - the value to be checked; </li><li>  RequestValidationSource requestValidationSource - the source to which the value to be checked belongs; </li><li>  string collectionKey - the name of the checked value in the source; </li><li>  out int validationFailureIndex - output parameter containing an offset within value from which the dangerous symbol was detected or -1 otherwise; </li></ul><br>  For example, to eliminate the possibility of bypassing validation using the &lt;% character combination, you can implement the following extension: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Web; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Web.Util; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">RequestValidationExtension</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BypassRequestValidator</span></span> : <span class="hljs-title"><span class="hljs-title">RequestValidator</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BypassRequestValidator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidRequestString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HttpContext context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, RequestValidationSource requestValidationSource, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> collectionKey, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> validationFailureIndex</span></span></span><span class="hljs-function">)</span></span> { validationFailureIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>[i] == <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> &amp;&amp; (i &lt; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'%'</span></span>) { validationFailureIndex = i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.IsValidRequestString( context, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, requestValidationSource, collectionKey, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> validationFailureIndex); } } }</code> </pre><br>  After that, by setting the value of the requestValidationType = "RequestValidationExtension.BypassRequestValidator" attribute in the httpRuntime section of the web application configuration, get the web application protected from this validation method. <br><br><h4>  6. Improved validation of requests </h4><br>  Using the ability to expand the functionality of query validation, it is realistic to eliminate all existing problems of the current implementation and get a full-fledged XSS Type-1 WAF.  To do this, it is necessary to check the values ‚Äã‚Äãof the request parameters immediately before sending a response when it is already formed and its contents are known.  This is a necessary condition for a reliable assessment of the impact of request parameters on the integrity of the response.  However, the ASP.NET query validation architecture does not provide the ability to execute it within its own framework, which makes it necessary to split the whole procedure into three steps. <br><br>  The functionality of the first stage is implemented directly in the expansion of the standard query validation.  At this stage, each checked parameter is mapped to the set ^? I [A-Za-z0-9 _] + $ and, in the event that the mapping failed, the parameter is marked as to be tested later.  Thus, information is collected about all potentially dangerous request parameters for which validation was requested (that is, the parameters actually used in the web application when processing the request).  This provides full integration with the existing query validation architecture, and also eliminates the need to expose non-dangerous parameters to additional checks. <br><br>  The second stage is an ASP.NET output filter and implements observation of the stream to which all response fragments generated at different stages of the request life cycle are recorded.  The content of the entire response is also saved for processing in the third stage. <br><br>  The third stage, implemented as an HTTP module that processes the EndRequest event, evaluates the effect of all parameters collected in the first stage on the integrity of the response received in the second.  In case of detection of violation of the integrity of the response, the check is considered failed.  The evaluation of the effect of the integrity request parameters is based on a fuzzy search in the response of the so-called insertion points - places in which the response fragment approximately coincides with the value of any of the parameters.  The set of insertion points forms an insertion map, using which one can carry out a much more substantiated check for the presence of forbidden characters in the parameter values, and also reveal the nature of their influence on the integrity of the response. <br><br>  The last problem is solved using parsers of all languages ‚Äã‚Äãthat may occur in the response (HTML, JavaScript, CSS).  Comparison of parse trees obtained as a result of parsing various fragments of the answer with the data from the insert map gives full information about which of the nodes of one or another tree were embedded in the response with the value of one or another parameter. <br><br><div class="spoiler">  <b class="spoiler_title">Detailed description of the verification algorithm</b> <div class="spoiler_text"><ol><li>  If the output document contains zero bytes, then the check is failed. </li><li>  For each element of the parameter list P, a fuzzy search is performed with a threshold of 0.75 of all occurrences of its value in the text of the answer R. The boundaries of each found entry determine the insertion area.  A set of all insertion areas map inserts M. </li><li>  If M is empty, then the check is considered passed. </li><li>  For each element M, a check is performed to ensure that its value matches the regular set &lt;? I [az! / \?%].  If a match is found, the check is failed. </li><li>  The output text R is parsed by the HTML parser into the tree R '. </li><li>  If, as a result of the parsing, any errors occurred and their places of intersection with the elements of M, then the check failed. </li><li>  All subsequent steps are repeated for each node N of the tree R ', describing the HTML tag or comment. </li><li>  If the initial position N in R has intersections with elements of M, then the check is considered failed. </li><li>  If N describes an HTML tag, then for each of its attributes, the position of which in R has an intersection with the elements of M, the verification is carried out according to the algorithm described below. </li><li>  If N describes a tag, then for its value innerText (script code), the check is performed using the algorithm described below. </li><li>  If N describes a tag, then for its innerText value (style definition code), the algorithm is tested using the algorithm described below. </li><li>  A check is considered passed if it was not failed in the previous steps. </li></ol><br>  The algorithm for checking the attributes of HTML elements (accepts the value of the attribute A, the insertion map M and the response text R): <br><br><ol><li>  If the initial position A in R has an intersection with the elements of M, then the check is considered failed. </li><li>  If the position of the value of A in R does not intersect with the elements of M, then the check is considered to be passed. </li><li>  If the name A is contained in the list of event handler attributes, then its value is checked according to the algorithm described below. </li><li>  If the name A matches an element of the attribute type list of the reference type, then the following steps are taken: <br><ol><li>  If the value of A contains a substring "&amp; #" or a named reference to an HTML entity, then the check is considered failed. </li><li>  If the value of A does not contain ":", then the check is considered to be passed. </li><li>  The value of A is parsed by the URI parser into a U object. </li><li>  If errors occurred during parsing, the check is considered failed. </li><li>  If U does not describe an absolute path, then the check is considered failed. </li><li>  If U describes a path with a scheme that is on the list of dangerous, then the check is considered failed. </li></ol></li><li>  If the name A = "style", then its value is checked according to the algorithm described below. </li></ol><br>  Algorithm for checking client script code and event handler attribute values ‚Äã‚Äã(accepts a Vs value containing the code of the script being checked and the value Vm of the element of the set M with which the intersection was detected): <br><br><ol><li>  If the largest common substring of L from Vs and Vm is less than 7, then the check is considered to be passed. </li><li>  Vs value is parsed by the JavaScript parser in the Vs' tree </li><li>  If errors occurred during parsing, the check is considered failed. </li><li>  If the number of tokens in Vs 'is less than 5 or the number of nodes in Vs' is less than 2, then the check is considered to be passed. </li><li>  If the entire value of L is the value of one token Vt of the tree Vs', then the check is considered to be passed. </li><li>  The JavaScript decoded Vt value is subjected to a recursive check, as if it were the answer text, fully formed from the Vm parameter. </li></ol><br>  The algorithm for checking the style definition code is absolutely similar to the previous one, with the exception of using the CSS parser and other threshold values ‚Äã‚Äãfor the elements of the parse tree and the largest common substring. </div></div><br>  Proof-of-Concept implementation of the described algorithm <a href="https://github.com/kochetkov/Irv">is available on GitHub</a> .  At the time of preparation of the article there are no known ways to bypass this filter.  The tests performed showed no tangible impact on the performance of web applications in cases where the request does not contain dangerous values ‚Äã‚Äãand a 7-15% slowdown in the formation of a response otherwise.  Considering the fact that the Proof-of-Concept version uses third-party parsers that solve a much more general task than is required by the response validation algorithm, an optimal implementation of these components will allow to achieve performance sufficient for confident application of the solution in production environments. <br><br><h4>  7. Conclusions </h4><br>  The implementation of the query validation functional in current versions of ASP.NET is ineffective and does not solve the problem of protection against XSS Type-1 class attacks.  Nonetheless, its current architecture and expansion options allow itself to solve this problem using the response validation method described in this article. <br><br>  However, we should not forget that the most effective protection against such attacks are not third-party mounted solutions, but the correct implementation of processing input and output data by the developers themselves.  And using Irv or more complex products (such as <a href="http://www.modsecurity.org/projects/modsecurity/iis/">mod-security for IIS</a> or <a href="https://github.com/IndiansIncredible/.NetIDS">.NetIDS</a> ) does not save a developer from having to follow basic rules for developing secure code (for example, <a href="http://www.troyhunt.com/2011/12/free-ebook-owasp-top-10-for-net.html">www.troyhunt.com/2011/12/free-ebook-owasp-top -10-for-net.html</a> or <a href="https://wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines">wiki.mozilla.org/WebAppSec/Secure_Coding_Guidelines</a> ). </div><p>Source: <a href="https://habr.com/ru/post/178357/">https://habr.com/ru/post/178357/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../178347/index.html">Buddy Cup: the glass automatically adds to friends on Facebook everyone with whom you are clinking</a></li>
<li><a href="../17835/index.html">Salvation for a project manager or building an IMR</a></li>
<li><a href="../178351/index.html">Flash GAMM Moscow 2013: flash, social, mobile game development conference</a></li>
<li><a href="../178353/index.html">Innovations node-webkit version 0.5.1</a></li>
<li><a href="../178355/index.html">Five useful tips when making a commit message</a></li>
<li><a href="../178359/index.html">Using free tools to customize the "Unchangeable" components of Windows 8</a></li>
<li><a href="../17836/index.html">Red Hat has appointed a new CEO</a></li>
<li><a href="../178361/index.html">Marketing for IT pros - goat bayan?</a></li>
<li><a href="../178363/index.html">A two-week review of Google Glass: everything will depend on the price</a></li>
<li><a href="../178365/index.html">Proxying and autosharing in Tarantool / Box</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>