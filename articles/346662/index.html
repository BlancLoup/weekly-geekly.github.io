<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Autopilot on AT91SAM7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introduction 


 Radio-controlled airplanes I became interested in back in 2002, living in Prague. The first aircraft was with a wingspan of 1.2 m,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Autopilot on AT91SAM7</h1><div class="post__text post__text-html js-mediator-article"><h2 id="1---vstuplenie">  1. Introduction </h2><br><p>  Radio-controlled airplanes I became interested in back in 2002, living in Prague.  The first aircraft was with a wingspan of 1.2 m, engine 2-stroke engine.  Here is a <a href="https://youtu.be/qOchE59A5ss">fragment of the video of</a> those times.  Once in 2008, the ADXL202E accelerometer fell into my hands.  Having experience in developing devices on the controller of the MCS-51 family (this was the Rubidium frequency standard and data acquisition system), I decided to make an autopilot for the radio-controlled model Mentor.  First of all, I connected the accelerometer to the controller.  For simplicity, I chose a debug board with an AT91SAM7 controller, for the convenience and ease of working with it.  It should be noted that I decided not to learn anything about autopilots on the Internet, but to do everything on my own with a ‚Äú0‚Äù to make it more interesting. </p><br><img src="https://habrastorage.org/webt/nq/bw/qo/nqbwqoongm0fwzh42notsdww680.jpeg"><br><p>  So, by chance in 2008, I happened to fly on an airplane and be able to use a laptop on board and my scarf with an accelerometer.  Today, any owner <br>  tablet or smartphone can do this experiment on their own, because <br>  Accelerometers are available in almost all devices.  It was here that I made for myself the first "discovery" <a name="habracut"></a>  that the accelerometer can be used to stabilize the pitch (since the plane cannot pick up speed too fast or slow down), but it is not suitable for stabilizing the roll.  Since with proper rotation without sliding, lateral accelerations are compensated by the roll of the aircraft, and the accelerometer does not feel them.  I remember the movie <a href="https://yadi.sk/i/fNwFNTYJ3RR8Nx">Yolki-2</a> , where the roll of the aircraft was tracked by a glass of water, which will cause bewilderment to a real pilot.  Why then invent artificial horizon? <br>  So, in these articles I will describe what happened to me from 2008 to 2017, when I was engaged in this project in my free time.  In June 2012, the autopilot was actually tested 1 time.  Then still without GPS.  In 2017, several tests were performed with GPS.  One of the successful, in slow motion mode, but with no time to find your position on the GPS can be seen <a href="https://www.youtube.com/watch%3Fv%3D1JnekoKoK_g">here</a> .  Start is to turn off the remote.  The takeoff is fully automatic, then an attempt to seize control, when it became clear that the plane was not flying there.  It was found that GPS determined the coordinates of 1 km approximately from the present.  Another successful flight on the route <a href="https://www.youtube.com/watch%3Fv%3DVHIyx_ljnzI%26t%3D39s">10/17/2017</a> .  Shooting unsuccessful, but visible takeoff and landing.  Landing in the field due to low battery.  However, beautiful.  The entire flight is fully automatic.  Development began with the elaboration of the autopilot software model using Borland C ++ Builder and the XPlane 6 flight simulator. As a result, the program code was adapted for the controller with almost no changes.  Autopilot is focused on simple docking with standard radio control modules.  PPM (Pulse Position Modulation) was selected as the most suitable.  Not with all modern consoles even PPM can work today: it is required that the sequence of PPM pulses go sequentially and not start at the same time as in some modern consoles, such as FlySky FS-16.  Although the control solution from such consoles is also present in the software, but for today it has not been tested and needs to be debugged.  The system is tested on Robbie Futaba FC-16 and Art-Tech EFLY-100B consoles.  One of the drawbacks is the need to output the PPM signal directly from the interior of the receiver to a decoder - a pulse distributor for steering gears. </p><br><h2 id="2---programmno-apparatnaya-model">  2. Software and hardware model </h2><br><p>  The functional scheme of the autopilot is shown in Fig.1.  The heart of the autopilot is the LEVEL1 unit.  This module is a high-priority function and runs independently of other events every (15.625 ms tested version) 46.875 ms.  His task is to keep the aircraft in the correct flight position </p><br><img src="https://habrastorage.org/webt/tp/2q/w2/tp2qw2fxlzouets-k4wpzwi2ctk.png"><br><p>  Fig.  one <br>  The input to the module is the FSSi structure, which contains the parameters Roll (Roll), Pitch (Pitch), and Air Speed ‚Äã‚Äã(Air Speed).  The correct position is considered when there are no signals Ref Ref = 0 and pitch = 0. This module also controls the controller of the aircraft‚Äôs engine and maintains the speed received from the LEVEL2 unit in accordance with the flight task.  The Level2 module introduces a perturbation into the LEVEL1 module and thus forces it to retain not the zero roll and pitch values, but calculated in accordance with the flight task.  The speed parameter is directly transmitted from the flight task.  The output of the module is a data structure that contains the current position of the ailerons (ailerons), elevator (elevator), rudder or rudder (rudder) and throttle (throttle).  This structure in the program is named FSSo. The module has the name FltStSys (flight stabilization system).  It can be filed with the PWMC (Pulse Wide Modulation Controller) if autopilot mode is activated.  Otherwise, the PWMC is supplied with a structure filled with a timer in accordance with the measured values ‚Äã‚Äãreceived from the RF receiver.  This control mode is traditional for radio-controlled models. <br>  The Level2 module is slower, 1 time per second it forms control actions - it shifts zero points for the Level1 module.  Data transmitted in Level1 is marked with the word keep in the program.  Those.  this is what the Level1 module should hold.  This module performs all other functions: <br>  1) the implementation of the take-off mode. <br>  2) Hold height <br>  3) Course retention <br>  4) Calculation of the route and carrying the aircraft along the route specified on the SD card. <br>  5) Record flight parameters to the SD card once per second.  (Black box function) <br>  6) When connected to one of the COM ports of the bluetooth module, the output of telemetry information. <br>  The basic idea of ‚Äã‚Äãbuilding the autopilot LEVEL1 is to build a fully inertial aircraft piloting system that does not use external signals, such as photo sensors for sky and earth color temperature or, for example, NAVSTAR or GLONASS to keep the aircraft in normal flight position.  When the GPS signal disappears, the flight is performed on a magnetic compass.  The following sensors are used to meet these requirements: </p><br><ol><li>  Roll.  The value of the roll is calculated from the angular velocity of the turn of the aircraft and its linear velocity under the assumption that the turn occurs without sliding.  The analog signal from the GYRO angular velocity sensor is digitized by the ADC controller (ADC1) embedded in the controller and then the Calc module calculates the roll. </li><li>  Pitch  The pitch value of the pitch controller is obtained by measuring the pulse duration from the accelerometer sensor with a timer.  This is permissible to do, because as a rule, the aircraft do not usually have too rapid changes in speed (except for take-off mode). </li><li>  Altitude.  An absolute pressure sensor is used to measure altitude.  Data is obtained in the form of voltage, which is digitized by one of the channels of the ADC (ADC2) controller. </li><li>  Course.  To obtain the heading value, either the GPS module is used, or, if it is unavailable or at zero speed (before the start, the heading control), Honeywell's digital compass with Hall sensors.  Connecting to the controller via I2C interface. </li><li>  Speed.  Airspeed sensor on Pitot tube.  A relative pressure sensor is used.  The voltage from the sensor is measured by one of the ADC channels (ADC3) of the controller.  Also for some things, the speed value from the GPS module is used. </li><li>  GPS  GPS module is connected via com port.  Used to obtain route data and speed relative to the ground (GND speed). </li><li>  SD card.  It is not a sensor, but data on module settings (coefficients for formulas), route data are read from it.  Flight data is recorded once per second. </li></ol><br><h2 id="3---datchiki-i-moduli">  3. Sensors and modules </h2><br><h3 id="31-akselerometr">  3.1 Accelerometer </h3><br><p> The sensor is designed to measure linear acceleration.  The ADXL202E (Analog Devices) device is used as an accelerometer.  This is a two-axis accelerometer with an output in the form of pulses, the duration of which is proportional to the acceleration.  The pulse duration is measured by a timer.  Only one of the axes (X) is used to measure the inclination of the aircraft.  The Y axis can be used to calculate lateral acceleration and compensate it by trimming the rudder position.  Now it is not implemented.  This sensor shows the position of the "ball" in the corresponding sensor of angular velocity and slip of the aircraft (for example, I-18T, <a href="https://yadi.sk/i/zIBSGLRj3RRbjh">EUP-53</a> ).  When turning (pilots turn is understood to mean any change in the aircraft's course), the pilot, in order to reduce the slip, usually steers the pedals and keeps the ball in a central position.  The drift of the accelerometer when measuring the slope is shown in Fig.  2. As can be seen when placed in the refrigerator for 15 minutes, the drift was -5 degrees. </p><br><img src="https://habrastorage.org/webt/qg/fa/zf/qgfazfdfiuzfsdx8c26s_ixpxzm.png"><br><p>  Figure 2 </p><br><h3 id="32-giroskop">  3.2 Gyro </h3><br><p>  The key element of the panel of any aircraft is the artificial horizon device.  It is usually built on the basis of a mechanical gyroscope.  It shows the roll and pitch of the aircraft in instrument flight mode.  In this project, the MEV-50A semiconductor gyroscope is used to measure the aircraft roll.  However, unlike the classical gyroscope, semiconductor gyroscopes do not measure the absolute roll, but its derivative ‚Äî the angular velocity.  This is the main reason why you cannot use a semiconductor gyro to measure aircraft roll.  The drift of such a measurement system is not determined by anything at small angular velocities.  If, for example, in a VR (virtual reality) helmet in which the gyroscope is not made on the basis of a magnetic compass with Hall sensors, but on a semiconductor device, you try to turn your head very slowly, you will find that it doesn‚Äôt notice the turning of the head.  Therefore, I applied another way to calculate roll.  The gyroscope is installed to measure the speed of the turn œâ of the aircraft around a vertical axis.  Then the aircraft roll can be calculated using the formula Œò = arctan (V ^ 2 / Rg) = arctan (Vœâ / g).  See fig.3. </p><br><img src="https://habrastorage.org/webt/up/hp/qh/uphpqhhtbaedvjtdw0sgvlqtijy.png"><br><p>  Here R is the turning radius of the aircraft, g is the acceleration of gravity (9.8 m / s2), V is the speed relative to the ground (true air speed), œâ is the angular velocity, rad / s.  The true speed is given by GPS, or it must be calculated based on the course, speed and direction of the wind.  This project uses GPS speed.  To exclude multiplication by 0, the minimum speed for the calculation is limited below 10 km / h.  To the gyroscope installed in this way, there are very serious requirements for measurement accuracy.  So, the first gyro that was tested led to the loss of the aircraft.  A video of the flight can be viewed <a href="https://yadi.sk/i/dNrqV6Hu3Q4PyL">here</a> , the data of the <a href="https://yadi.sk/i/jtIcVnfZ3Q4PqM">"black box" are</a> also available.  The plane would be raised from the console to a height of about 150m and the autopilot was turned on.  However, as can be seen from the graphs, from the very beginning the gyroscope gave incorrect data - the Gyr in the picture - and, as soon as the autopilot was turned on for 97 seconds of flight, the plane entered the spin as expected.  Unfortunately, it was not possible to bring it out safely due to ergonomic errors: manual control was turned on from the console with the middle position of the toggle switch, which could not be found in time from the excitement :).  It was a gyroscope from a simple coaxial helicopter.  In general, it was clear to me from the very beginning that this would be so, since the temperature tests in the refrigerator showed a huge drift of this device.  Care in 15 minutes was about 15g / s, although the normal operating values ‚Äã‚Äãof this parameter usually do not exceed several degrees per second in the entire range of rolls (up to 30 grams).  And accuracy should be no worse than 0.1o / c. <br>  Look at the test <a href="https://yadi.sk/i/txcj08wH3Q4Se3">data</a> and <a href="https://yadi.sk/i/RCRuHjBn3Q4Qoa">the</a> measurement <a href="https://yadi.sk/i/RCRuHjBn3Q4Qoa">process</a> here.  A comparison of the characteristics of gyroscopes is presented in Fig. 5. It can be seen that, in general, a normal flight could not be expected from a noname gyroscope if its drift was over 15 minutes.  in the freezer was approximately 24 ¬∞ / s.  Now used gyro <a href="https://yadi.sk/i/wygm2Qlm3Q4QmA">MEV-50A</a> .  It is seen that its drift in 25 minutes is about 0.6 ¬∞ / s. </p><br><img src="https://habrastorage.org/webt/ps/nu/bf/psnubffle8hzovbk2zgcacvgiis.jpeg"><br><img src="https://habrastorage.org/webt/zk/wo/xb/zkwoxbvrfpc9hfvvbabaetcxtcw.jpeg"><br><p>  Pic.5 </p><br><h3 id="33-vysotomer">  3.3 Altimeter </h3><br><p>  An absolute pressure sensor is usually used as an altimeter.  The <a href="https://yadi.sk/i/yAfveoNW3RRsbe">MPXA4115A6U</a> sensor is used in this project.  The sensor outputs a voltage that is measured by the controller.  Before the flight it is necessary to warm up.  Warming up time reaches 10-15 minutes.  As the atmospheric pressure changes, the altimeter is automatically calibrated before each flight.  The sensor has a significant temperature drift.  Figure 6 shows the drift graph of the altimeter.  Since the speed sensor is also a pressure gauge, the drift is the same. </p><br><img src="https://habrastorage.org/webt/fy/ct/ka/fyctkanyrwklsdqpshyygfq0w_4.jpeg"><br><p>  Fig.  6 <br>  The most interesting test of the pressure sensor is undoubtedly a trip to the subway.  These black box trips are shown in Figure 7. About this schedule, we can say that the autopilot is turned on on the 12th floor, (about 36 m) Next, take the elevator, then I rode the bus, and then the subway.  The end point of my journey, when I got off the subway, was really on high ground. </p><br><img src="https://habrastorage.org/webt/th/od/vz/thodvzdosca7h-h2merneqv0feu.jpeg"><br><p>  Fig.7 </p><br><h3 id="34-datchik-vozdushnoy-skorosti">  3.4 Airspeed sensor. </h3><br><p>  Air velocity is usually measured using a Pitot tube.  In principle, these things are usually calculated.  But it is clear that if you blow the outside into the tube (without touching it with your lips), then the pressure in it will increase.  By measuring the pressure in the tube, you can estimate the speed of flight.  The tube is usually placed either on the wing or on the fuselage (if there is no pulling screw).  For correct measurement, it is necessary that the engine does not force air directly into the tube.  Being a pioneer in this matter, I used the <a href="https://yadi.sk/i/QiFpYQ9R3RRsjh">MPXV5004GP</a> relative pressure <a href="https://yadi.sk/i/QiFpYQ9R3RRsjh">sensor</a> .  As with the absolute pressure sensor, the output of this sensor is voltage; it is measured by the controller.  When launched, it is also calibrated.  But a coarse adjustment with a resistor is not required if the height cannot be zeroed, unlike the absolute pressure sensor.  The tube was taken from carbon fiber with a diameter of 3 mm.  See fig.  eight. </p><br><img src="https://habrastorage.org/webt/y5/q2/nn/y5q2nnvzloerc9nfa0arq4cjprg.jpeg"><br><p>  Fig.8 <br>  To calibrate the sensor, the handset was installed on the rearview mirror of the car, and a control run was made, the current speed was recorded on the recorder.  If you combine <a href="https://yadi.sk/d/KtLmTjeh3RRk68">audio</a> and <a href="https://yadi.sk/i/pUvo70yU3RRefw">log</a> you can calibrate the airspeed sensor.  So I "discovered" for myself that the speed is proportional to the square root of pressure.  V = k * ‚àöp In the following, the accuracy of the speed measurement was confirmed during test flights with GPS.  Temperature drift of the airspeed sensor can be seen in Fig.  6. Just made a scientific discovery.  During acceleration, the air is pumped out of the passenger compartment, the pressure drops, which corresponds to an increase in height?  Is it so?  Correlation with height cannot be accidental ... </p><br><h3 id="35-cifrovoy-kompas">  3.5 Digital compass </h3><br><p>  The digital compass allows you to determine the direction of flight in the absence of a signal or a GPS receiver.  Initially, the system was built as inertial.  The flight program was not recorded in the form of GPS coordinates, but was given the direction, speed and time of flight to the next point.  As a compass was used 2-axis compass <a href="https://yadi.sk/i/6prSRLB53QFCP8">HMC6352</a> .  If then the developer was smarter, he would certainly use the 3-axis compass.  But so far done.  The compass has an I2C interface.  This device can directly issue a course, or levels of magnetic field components.  To increase accuracy, it is sometimes necessary, or when changing the external magnetic environment, to calibrate it.  For calibration, it is necessary to hold the calibration button when turning on the power of the autopilot, after which the controller enters the calibration mode for 1 minute.  Calibration mode is indicated by a special flashing of the operation mode indicator (J9, BLUE-LED, 4 times per second).  At this time it is necessary to make several complete turns of the aircraft in the strictly horizontal position of the aircraft.  In order to be able to use the sensor, magnetic materials cannot be used for the autopilot body.  Unfortunately, the first experiments showed that the measurement accuracy is good only if the device is strictly horizontal.  On the plane, this requirement can not be fulfilled.  Moreover, the accuracy does not just fall, but it does not exist at all.  When tilted even at a small angle, a few degrees we get at the output all + -180 ¬∞.  Therefore, we had to refuse to receive the course directly from the compass, but to receive the values ‚Äã‚Äãof the components of the magnetic field, and calculate the course using compensation as much as possible.  In the absence of the third Z axis, we had to take the value of this component as a constant.  The result of the compass with and without compensation is shown in Fig.9.  HDGn - uncompensated compass, HDGc - compensated.  As can be seen from the graphs, compensation significantly improves the quality of course measurements, but of course there is no talk about accuracy in tenths of a degree.  Also, the work of the compass can be seen on the <a href="https://yadi.sk/i/KImdFYFO3QFsZB">flight data</a> without GPS 11.09.2012.  Here the flight took place in <a href="https://yadi.sk/i/YIn4D_DQ3QFsSX">Vokhonovo</a> .  It should be noted that in <a href="https://yadi.sk/d/9uoiGimD3QFrkr">flights in 2009</a> .  there was no compass compensation yet.  As you can see in the <a href="https://yadi.sk/i/KImdFYFO3QFsZB">figure, the</a> start really takes place with a course close to 120 degrees, and ends in a forest with a course of about 300 degrees.  As shown by late flights, the plane was rocking strongly (yes, yes! :)) due to poor attachment of the wing to the fuselage and a decrease in flight speed after the engine was turned off. </p><br><img src="https://habrastorage.org/webt/8m/vk/1f/8mvk1fskvpf-fck5koca6rugr3o.jpeg"><br><p>  Fig.  9. </p><br><h3 id="36-modul-gps">  3.6 GPS module </h3><br><p>  A GPS module with an integrated antenna is used.  This is a small veil, located outside the shielded autopilot box.  (See Fig.8).  Module documentation can be found in the GPS folder.  <a href="https://yadi.sk/d/9TGh5HUZ3RRrnx">Used</a> module <a href="https://yadi.sk/d/9TGh5HUZ3RRrnx">S3126</a> .  The GPS module is connected to the controller through one of the UART.  Communication with the module is standard protocol NMEA0183.  On test <a href="https://yadi.sk/i/II7XemOd3RN69G">2017_09_02</a> before the launch of the aircraft, the GPS did not work correctly, and the plane very beautifully flew in the wrong direction.  As it was possible to see from the data of the "black box" TRACK005.LOG GPS "thought" that it is a kilometer away from a given point.  This can be viewed in flight data from <a href="https://yadi.sk/i/jqglTmZl3RUdRo">2017_09_02</a> .  It should be noted that in this test I still could not control the distance to the next flight point while the console was turned on (i.e. the autopilot was turned off).  Therefore, the distance of 134 M in the log file did not indicate that the seat of the aircraft was determined correctly.  The distance to the next point was supposed to be about 100 m, the offset was about 0, and the course was 323. However, as you can see, real data appeared only at the time of take-off at 14:10:33.  And the course turned out to be 150, a distance of 1012M, an offset of 121M (deviation from the axis along which the aircraft should fly in accordance with the task).  After this test, a change was made to the program so that the route data was displayed in telemetry regardless of the mode.  It became possible to see before launch whether GPS works correctly.  This control is also reflected in <a href="https://yadi.sk/i/kcJjFyZm3QKFan">the launch map</a> .  Autopilot receives the following parameters from the GPS module: time, date (used when recording the log file), readiness, number of visible satellites, coordinates longitude, latitude and speed in knots.  GPS readiness is indicated by a green LED flashing when the information is recorded on the map, approximately 1 time per second.  It is important to understand that the GPS module can not as accurately as the coordinates determine the height, so the height is not used.  When you turn on the autopilot, immediately after warming up and calibrating the sensors, the controller calculates the route using the coordinates of the flight task.  This route is not recorded on the map, but is displayed via BT telemetry.  From these data, we can estimate the correctness of the flight data.  The program is not waiting for the initialization of GPS, but it is easy to change.  Here is the telemetry log output: <br>  GPILOT V2.17.0 24 / Jul / 2017 <br>  Waiting GPS ... <br>  GPS ready ... <br>  Init from MMC card..Hidden sectors = 57 <br>  G0,60.674983,29.173461,0,0,0,0,1 <br>  G1,60,675504,29.172667,30M, 50kM / h, 323D, 5s, 2.72M <br>  G2,60.676388,29.171305,30M, 50kM / h, 322D, 8s, 3,123M <br>  G3,60,675641,29.168697,30M, 50kM / h, 239D, 11s, 4,164M <br>  G4,60,672877,29.172249,30M, 50kM / h, 147D, 26s, 5,362M <br>  G5,60.673546,29.174448,30M, 50kM / h, 58D, 10s, 6.140M <br>  G6,60,674767,29.173783,20M, 30kM / h, 345D, 16s, 7.140M <br>  G7,60,675737,29.172313,20M, 0kM / h, 323D, 0s, 0.134M <br>  Compass calibrate skip ... <br>  Sensors calibrate ... <br>  Sensors calibrate complete ... </p><br><h3 id="37-modul-bluetooth">  3.7 Bluetooth Module </h3><br><p>  For the convenience of monitoring parameters before takeoff and debugging in general, the output through the UART was equipped with a bluetooth <a href="https://yadi.sk/i/hvPe5Akk3QKKY3">Parani-ESD1000 module</a> .  To communicate with other devices, a button is installed.  The most convenient application for Android devices turned out to be the <a href="https://yadi.sk/d/6-oJDpkK3QKKiM">Bluetooth Graphics</a> application.  Available in Google Play. </p><br><h3 id="38-sd---karta-httpsyadiskd0xih48zp3rrt3f">  3.8 <a href="https://yadi.sk/d/0XIH48Zp3RRt3F">SD card</a> </h3><br><p>  Like any self-respecting plane, my project has a black box on board, played by an SD card.  The card is connected via a slow SPI interface, for connecting it, I took the ready code from Rolf Freitag, for which I am grateful.  The code provides reading and writing blocks of 512 bytes (Sector).  Autopilot settings and flight route are recorded on the map.  When working on the card, data is written once per second that the programmer wishes to write.  When I started work on the autopilot, I had a 16 MB SD card at my disposal, so first I wrote <a href="https://yadi.sk/i/EJb6To4w3RRt5b">FAT12</a> , and only this summer I added FAT32.  To use it, you need to replace the file fat.c and fat.h in the project with fat32.c and fat32.h.  As the SD card deteriorates, as practice has shown, the number of hidden sectors may increase.  This is due to the deterioration of the SD card and the fact that the initial sectors are overwritten more often than others, especially in the FAT12 system.  In the FAT32 system, the table is placed in arbitrary places of the map as a fragmented file, therefore wear is slower.  Flight data is written to the log file of the type TRACKXXX.LOG automatically.  Data for recording is written to the card immediately, without buffering, once per second, and the file table is updated immediately so that you can have flight data up to the last second of the flight.  Thanks to GPS, each log file has the current date and time of creation.  The GPS module introduced a correction of +3 hours to correctly display the time zone of St. Petersburg. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/346662/">https://habr.com/ru/post/346662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346652/index.html">Parsing badoo php tasks and new test How to get an offer to London in February</a></li>
<li><a href="../346654/index.html">Game design: don't confuse the player</a></li>
<li><a href="../346656/index.html">What threatens blockchain networks: we consider attacks and methods of protection</a></li>
<li><a href="../346658/index.html">How to develop and produce IoT devices in Russia</a></li>
<li><a href="../346660/index.html">[Video] Reports from the iOS developer Red Hot Chili Apples</a></li>
<li><a href="../346666/index.html">ICO regulation. Estonia</a></li>
<li><a href="../346668/index.html">Networks and neighbors: methods of survival of machine learning in the ‚Äúwild‚Äù. Open Workshop AI @ MIPT</a></li>
<li><a href="../346670/index.html">Web components: review and use in production</a></li>
<li><a href="../346672/index.html">Single Sign-On, or Dancing Six</a></li>
<li><a href="../346676/index.html">Testing components with Puppeteer and Jest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>