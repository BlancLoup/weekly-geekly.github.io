<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Patterns in AngularJS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Short review 
 One of the best ways to learn something new is to see how things already familiar to us are used in it. This article does not intend to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Patterns in AngularJS</h1><div class="post__text post__text-html js-mediator-article"><h2>  Short review </h2><br>  One of the best ways to learn something new is to see how things already familiar to us are used in it.  This article does not intend to acquaint readers with the design or design patterns.  It offers a basic understanding of OOP concepts, design patterns, and architectural patterns.  The purpose of the article is to describe how various software designs and architectural patterns are used in AngularJS and the <a href="https://ru.wikipedia.org/wiki/Single_Page_Application">SPA</a> written on it. <br><br><h2>  Introduction </h2><br>  The article begins with an overview of the AngularJS framework.  The review explains the main components of AngularJS: directives, filters, controllers, services, scope.  The second section lists and describes the various structures and architectural patterns that are implemented inside the framework.  Templates are grouped by AngularJS components in which they are used.  If some templates are used in multiple components, this will be indicated. <br>  The last section includes several architectural patterns that are commonly used in SPAs built on AngularJS. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">AngularJS Short Review</b> <div class="spoiler_text"><h2>  AngularJS Short Review </h2><br>  AngularJS is a JavaScript web framework developed by Google.  He intends to provide a solid foundation for the development of <a href="https://ru.wikipedia.org/wiki/CRUD">CRUD</a> SPA.  SPA is loaded only once and does not require reloading the page when working with it.  This means that all application resources (data, templates, scripts, styles) must be loaded when the main page is loaded or on demand.  Since most CRUD applications have common characteristics and requirements, AngularJS intends to provide their optimal set of boxes.  Here are some important features of AngularJS: <br><ul><li>  two-way data binding (two-way data binding) </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BD%25D0%25B5%25D0%25B4%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">dependency injection, DI</a> ( <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BD%25D0%25B5%25D0%25B4%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">dependency injection</a> ) </li><li>  separation of concerns </li><li>  testability </li><li>  abstraction </li></ul><br>  The division of responsibility is achieved by dividing each AngularJS application into separate components, such as: <br><ul><li>  partials </li><li>  controllers </li><li>  directives </li><li>  services </li><li>  filters </li></ul><br>  These components can be grouped within different modules that help achieve a higher level of abstraction.  Each component includes a specific part of the application logic. <br><br><h2>  Partials </h2><br>  Partials is an HTML string.  They can contain AngularJS expressions inside elements or their attributes.  One of the advantages of AngularJS over other frameworks is that AngularJS templates are not in an intermediate format that needs to be converted to HTML (such as mustache.js) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the beginning, each SPA loads the Index.html file.  In the case of AngularJS, this file contains a set of standard (and not so) HTML attributes, elements and comments that customize and launch the application.  Each user action requires loading other partials (HTML strings or files with HTML chunks) or changing the state of an application, for example, through data binding provided by the framework. <br>  Example partials: <br><br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-app</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- Body tag augmented with ngController directive --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-controller</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MyController"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"foo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"bar"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- Button tag with ng-click directive, and string expression 'buttonText' wrapped in "{{ }}" markup --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"changeFoo()"</span></span></span><span class="hljs-tag">&gt;</span></span>{{buttonText}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"angular.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Together with the expressions AngularJS, partials determine what actions should be performed to interact with the user.  In the example above, the value of the ng-click attribute means that the changeFoo () method will be called from the current scope. <br><br><h2>  Controllers </h2><br>  Controllers in AngularJS are normal functions that allow you to handle user and application interaction (for example, mouse events, keyboards, etc.) by adding methods to the scope.  All external dependencies for controllers are provided using the DI mechanism in AngularJS.  Controllers are also responsible for the interaction of models with partials by adding data to scope.  This can be considered as a view model. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyController</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope</span></span></span><span class="hljs-function">) </span></span>{ $scope.buttonText = <span class="hljs-string"><span class="hljs-string">'Click me to change foo!'</span></span>; $scope.foo = <span class="hljs-number"><span class="hljs-number">42</span></span>; $scope.changeFoo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ $scope.foo += <span class="hljs-number"><span class="hljs-number">1</span></span>; alert(<span class="hljs-string"><span class="hljs-string">'Foo changed'</span></span>); }; }</code> </pre><br>  For example, if we connect the controller presented above to the previous section, the user will be able to interact with the application in several ways: <br><ol><li>  Change ‚Äúfoo‚Äù by entering data in the input field.  This will immediately reflect on the value of ‚Äúfoo‚Äù due to two-way data binding. </li><li>  Change the value of "foo" by clicking on a button called "Click me to change foo!" </li></ol><br>  All custom elements, attributes, comments, or classes may be AngularJS directives (if they are predefined). <br><br><h2>  Scope </h2><br>  The AngularJS scope is a JavaScript object that is available for partials.  Scope can include various properties - primitives, objects or methods.  All methods added to a scope can be invoked using AngularJS expressions within partials that are associated with this scope or directly invoke the method by any component that has a reference to scope.  With the help of the relevant directives, data is added to the scope, and can be associated with the view, so every change in the scope property will be reflected in the view and every change in the view will be displayed in the scope. <br><br>  Another important feature of scope in any AngularJS application is that they are linked through the prototype inheritance mechanism (with the exception of the isolated scope).  Thus, any child scope can use the methods of its parent, since these are properties of its direct or indirect prototype. <br><br>  The scope inheritance is shown in the following example: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-controller</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"BaseCtrl"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"child"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-controller</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ChildCtrl"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"parent-method"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"foo()"</span></span></span><span class="hljs-tag">&gt;</span></span>Parent method<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"bar()"</span></span></span><span class="hljs-tag">&gt;</span></span>Child method<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseCtrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope</span></span></span><span class="hljs-function">) </span></span>{ $scope.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Base foo'</span></span>); }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChildCtrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope</span></span></span><span class="hljs-function">) </span></span>{ $scope.bar = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Child bar'</span></span>); }; }</code> </pre><br>  The scope ChildCtrl is associated with the # child div, but since the scope ChildCtrl is nested in BaseCtrl, all methods from BaseCtrl are available in ChildCtrl, using prototype inheritance and therefore the foo method will be available when you click the button # parent-method. <br><br><h2>  Directives </h2><br>  Directives in AngularJS are where all DOM manipulations should be performed.  As a rule, if you have a DOM manipulation in the controller, then you need to create a new directive or refactor, which will eliminate the DOM manipulation in the controller.  In the simplest case, the directive has the name and the definition of the postLink function, which includes the directive logic.  In more complex cases, a directive may contain many properties, such as: <br><br><ul><li>  template </li><li>  compile function </li><li>  link function </li><li>  etc. </li></ul><br>  Directives can be used in partials, for example: <br><br><pre> <code class="javascript hljs">myModule.directive(<span class="hljs-string"><span class="hljs-string">'alertButton'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;button ng-transclude&gt;&lt;/button&gt;'</span></span>, <span class="hljs-attr"><span class="hljs-attr">scope</span></span>: { <span class="hljs-attr"><span class="hljs-attr">content</span></span>: <span class="hljs-string"><span class="hljs-string">'@'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">replace</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">restrict</span></span>: <span class="hljs-string"><span class="hljs-string">'E'</span></span>, <span class="hljs-attr"><span class="hljs-attr">transclude</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">link</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scope, el</span></span></span><span class="hljs-function">) </span></span>{ el.click(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(scope.content); }); } }; });</code> </pre><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">alert-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"42"</span></span></span><span class="hljs-tag">&gt;</span></span>Click me<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">alert-button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  In the example above, the &lt;alert-button&gt; &lt;/ alert-button&gt; tag will be replaced by the button element and when you click on the button, a warning appears with the text 42. <br><br><h2>  <b>Filters</b> </h2><br>  Filters in AngularJS are responsible for encapsulating the logic needed to format the data.  Filters are usually used inside partials, but also through DI they are available in controllers, directives, services, or other filters. <br>  Here is a simple example of a filter that converts a string to upper case: <br><br><pre> <code class="javascript hljs">myModule.filter(<span class="hljs-string"><span class="hljs-string">'uppercase'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (str || <span class="hljs-string"><span class="hljs-string">''</span></span>).toUpperCase(); }; });</code> </pre><br>  Inside partials, filters can be used using Unix pipelines syntax (Unix's piping): <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>{{ name | uppercase }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Inside the controller, the filter can be used as follows: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyCtrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uppercaseFilter</span></span></span><span class="hljs-function">) </span></span>{ $scope.name = uppercaseFilter(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//FOO }</span></span></code> </pre><br><h2>  Services </h2><br>  Any part of the logic that does not relate to the components described above should be placed in the service.  Usually, services encapsulate a specific area of ‚Äã‚Äãlogic, immutable logic, XHR, WebSockets, etc. When the controllers in the application become too thick, the duplicate code should be moved to the services. <br><br><pre> <code class="javascript hljs">myModule.service(<span class="hljs-string"><span class="hljs-string">'Developer'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-string"><span class="hljs-string">'Foo'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.motherLanguage = <span class="hljs-string"><span class="hljs-string">'JavaScript'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.live = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.code(); } }; });</code> </pre><br>  Services can be added to any component that supports DI (controllers, filters, directives, other services): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyCtrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">developer</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> developer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Developer(); developer.live(); }</code> </pre><br></div></div><br><h2>  AngularJS patterns </h2><br>  In the next two sections, we will look at how traditional design and architectural patterns are used in AngularJS components. <br><br>  In the last chapter, we will look at some architectural patterns that are often used in the development of SPA (and not only) on AngularJS. <br><br><h3>  Services </h3><br><h4>  Singleton </h4><br>  Singleton is a design pattern that restricts the creation of a class instance to a single object.  This is useful when you need to coordinate actions throughout the system.  The concept is suitable for systems that function more efficiently when there is only one object or when instances are limited to a certain number of objects. <br><br>  The UML diagram illustrates the singleton pattern: <br><br><img src="https://camo.githubusercontent.com/06b14e8ff8fdd03d2610480e39a433ab65ca0ee5/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f73696e676c65746f6e2e737667" alt="image"><br><br>  When any component needs a dependency, AngularJS resolves it using the following algorithm: <br><ul><li>  Takes the name of the dependency and does a search in the hash map, which is defined in the lexical closure.  (therefore it has a private scope) </li><li>  If a dependency is found AngularJS passes it as a component parameter </li><li>  If the dependency is not found: <br><ul><li>  AngularJS creates it by calling the factory method or its provider (i.e. $ get).  Please note that creating a dependency may require a recursive call using the same algorithm to determine all dependencies of this dependency.  This process can lead to cyclical dependency. </li><li>  AngularJS caches it inside the hash card mentioned above. </li><li>  AngularJS passes it as a parameter to the component for which it is listed. </li></ul></li></ul><br>  Better take a look at the AngularJS source code that implements getService: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getService</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">serviceName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.hasOwnProperty(serviceName)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache[serviceName] === INSTANTIATING) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> $injectorMinErr(<span class="hljs-string"><span class="hljs-string">'cdep'</span></span>, <span class="hljs-string"><span class="hljs-string">'Circular dependency found: {0}'</span></span>, path.join(<span class="hljs-string"><span class="hljs-string">' &lt;- '</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache[serviceName]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { path.unshift(serviceName); cache[serviceName] = INSTANTIATING; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache[serviceName] = factory(serviceName); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache[serviceName] === INSTANTIATING) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> cache[serviceName]; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { path.shift(); } } }</code> </pre><br>  Imagine that each service is a singleton, because a service is created only once.  Cache can be viewed as a singleton manager.  Also this implementation is slightly different from the one represented in the UML diagram, because instead of creating a static private link to a singleton inside its constructor, we save the link inside the singleton manager. <br><br>  Thus, service is actually singleton, but not implemented through the singleton pattern, thereby providing some advantages over the standard implementation: <br><br><ul><li>  improves code testability </li><li>  You can control the creation of singleton objects (In this case, the <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D0%25B2%25D0%25B5%25D1%2580%25D1%2581%25D0%25B8%25D1%258F_%25D1%2583%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">IoC</a> container controls the creation of objects using lazy calls.) </li></ul><br><br>  For a more detailed discussion of this topic, you can read Misko Hevery's <a href="http://googletesting.blogspot.ru/2008/05/tott-using-dependancy-injection-to.html">article</a> on the Google Testing blog. <br><br><h4>  Factory Method </h4><br>  Factory Method (Factory Method is also known as Virtual Constructor) is a generic design pattern that provides an interface for subclasses to create instances of a particular class.  At the time of creation, successors can determine which class to create.  In other words, the Factory delegates the creation of objects to the heirs of the parent class.  This allows you to use in the program code not specific classes, but to manipulate abstract objects at a higher level. <br><br><img src="https://camo.githubusercontent.com/2a6dbeb07113cc74e88320ece7f0abadcbeecef6/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f666163746f72792d6d6574686f642e737667" alt="image"><br><br>  Let's look at the following snippet: <br><br><pre> <code class="javascript hljs">myModule.config(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$provide</span></span></span><span class="hljs-function">) </span></span>{ $provide.provider(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> baz = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Factory method $get: function (bar) { var baz = bar.baz(); return { baz: baz }; } }; }); });</span></span></code> </pre><br>  Here, the config callback function is used to define the new ‚Äúprovider‚Äù.  ‚ÄúProvider‚Äù is an object with a $ get method.  Since there are no interfaces in JavaScript and the language uses ‚Äúduck‚Äù typing, we agreed to call the factory method in the ‚Äúprovider‚Äù $ get. <br><br>  Each service, filter, directive, and controller have a provider (that is, an object that has a $ get factory method), it is responsible for creating component instances. <br><br>  We can dig a little deeper into the implementation of AngularJS: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//... createInternalInjector(instanceCache, function(servicename) { var provider = providerInjector.get(servicename + providerSuffix); return instanceInjector.invoke(provider.$get, provider, undefined, servicename); }, strictDi)); //... function invoke(fn, self, locals, serviceName){ if (typeof locals === 'string') { serviceName = locals; locals = null; } var args = [], $inject = annotate(fn, strictDi, serviceName), length, i, key; for(i = 0, length = $inject.length; i &lt; length; i++) { key = $inject[i]; if (typeof key !== 'string') { throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key); } args.push(locals &amp;&amp; locals.hasOwnProperty(key) ? locals[key] : getService(key)); } if (!fn.$inject) { // this means that we must be an array. fn = fn[length]; } return fn.apply(self, args); }</span></span></code> </pre><br>  In the example, you can see how the $ get method is actually used: <br><br><pre> <code class="javascript hljs">instanceInjector.invoke(provider.$get, provider, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, servicename)</code> </pre><br>  In the fragment above, the invoke method is called and the first argument is the factory method ($ get) of the service.  Inside the invoke method, the annotate function is called, to which the factory method is also passed as the first argument.  The annotate function resolves all dependencies through the DI AngularJS mechanism (discussed above).  After resolving all dependencies, the factory method is called: <br><br><pre> <code class="javascript hljs">fn.apply(self, args).</code> </pre><br>  If we reason in terms of the UML diagram described above, then we can call Creator, which through the factory method will call ‚ÄúConcreteCreator‚Äù which will create ‚ÄúProduct‚Äù. <br><br>  In this case, we get some advantages using the factory method pattern because it uses indirect instantiation.  Thus, the framework affects the layouts / templates for creating new components, because: <br><ul><li>  This is the most appropriate moment to create a component. </li><li>  allow all component dependencies </li><li>  control the number of allowed instances of the component (for service and filter one, but many for the controller) </li></ul><br><br><h4>  Decorator </h4><br>  Decorator (Decorator) - a structural design pattern designed to dynamically add additional behavior to an object.  The Decorator pattern provides a flexible alternative to creating subclasses to extend functionality. <br><br><img src="https://camo.githubusercontent.com/f4fb6e60d06463dfd0817ea1b9e3e2976694828f/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f6465636f7261746f722e737667" alt="image"><br><br>  AngularJS out of the box provides opportunities for expanding and / or enhancing the functionality of existing service 's.  Using the decorator or $ provide method you can create a wrapper for any service already defined by you or from a third-party library: <br><br><pre> <code class="javascript hljs">myModule.controller(<span class="hljs-string"><span class="hljs-string">'MainCtrl'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo</span></span></span><span class="hljs-function">) </span></span>{ foo.bar(); }); myModule.factory(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">bar</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I\'m bar'</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I\'m baz'</span></span>); } }; }); myModule.config(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$provide</span></span></span><span class="hljs-function">) </span></span>{ $provide.decorator(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$delegate</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> barBackup = $delegate.bar; $delegate.bar = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Decorated'</span></span>); barBackup.apply($delegate, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $delegate; }); });</code> </pre><br>  The above example defines a new service named ‚Äúfoo‚Äù.  In the callback function ‚Äúconfig‚Äù, the method $ provide.decorator is called and the name of the service that we want to decorate is passed to it as the first argument, the function is passed as the second argument, and it actually implements the decorator.  $ delegate stores a link to the original service foo.  We decorate the service by redefining its bar method.  In fact, decorating is just an extension of bar, by turning on another console.log state - console.log ('Decorated') and then calling the original bar method in the appropriate context. <br><br>  Using the template is especially useful when we need to change the functionality of the service created by third parties.  In cases where numerous decorators are needed (for example, when measuring the performance of methods, authorization, registration, etc.), a lot of duplicated code and violation of the <a href="https://ru.wikipedia.org/wiki/Don%25E2%2580%2599t_repeat_yourself">DRY</a> principle can be obtained.  In such cases, it is advisable to use <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">aspect-oriented</a> programming.  The AngularJS AOP framework can be found at <a href="https://github.com/mgechev/angular-aop">github.com/mgechev/angular-aop.</a> <br><br><h4>  Facade </h4><br>  The Facade pattern (facade) is a structural design pattern that allows you to hide the complexity of the system by reducing all possible external calls to a single object, delegating them to the corresponding system objects. <br>  Facade can: <br><ol><li>  Make it easier to use libraries, understanding and testing, as the facade has more suitable methods for performing common tasks. </li><li>  Make the library more readable for the same reason. </li><li>  Reduce the dependence of internal libraries on external code, since most of the code uses facade, this allows the system to be developed more flexibly </li><li>  Wrap a poorly designed collection of APIs, one well designed (according to the needs of the task) </li></ol><br><br><img src="https://camo.githubusercontent.com/97668c776b2552cb08fe9ad587230091f1b52717/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f6661636164652e737667" alt="image"><br><br>  AngularJS has several facades.  Every time you want to provide a high-level API for some functionality, you practically create a facade. <br><br>  For example, let's see how we can create an XMLHttpRequest POST request: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> http = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(), url = <span class="hljs-string"><span class="hljs-string">'/example/new'</span></span>, params = <span class="hljs-built_in"><span class="hljs-built_in">encodeURIComponent</span></span>(data); http.open(<span class="hljs-string"><span class="hljs-string">"POST"</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); http.setRequestHeader(<span class="hljs-string"><span class="hljs-string">"Content-type"</span></span>, <span class="hljs-string"><span class="hljs-string">"application/x-www-form-urlencoded"</span></span>); http.setRequestHeader(<span class="hljs-string"><span class="hljs-string">"Content-length"</span></span>, params.length); http.setRequestHeader(<span class="hljs-string"><span class="hljs-string">"Connection"</span></span>, <span class="hljs-string"><span class="hljs-string">"close"</span></span>); http.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(http.readyState == <span class="hljs-number"><span class="hljs-number">4</span></span> &amp;&amp; http.status == <span class="hljs-number"><span class="hljs-number">200</span></span>) { alert(http.responseText); } } http.send(params);</code> </pre><br>  If we want to send data using the AngularJS $ http service, we can: <br><pre> <code class="javascript hljs">$http({ <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/example/new'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: data }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ alert(response); });</code> </pre><br>  or even: <br><pre> <code class="javascript hljs">$http.post(<span class="hljs-string"><span class="hljs-string">'/someUrl'</span></span>, data).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ alert(response); });</code> </pre><br>  The second option is a pre-configured version that creates an HTTP POST request. <br>  The third option is a high-level abstraction created using the $ resource service and built on top of the $ http service.  We will once again consider this service in the Active Record and Proxy sections. <br><br><h4>  Proxy </h4><br>  Proxy (Deputy) is a structural design pattern that provides an object that controls access to another object, intercepting all calls (performs the function of a container).  Proxy can interact with anything: a network connection, a large object in memory, a file or other resources that are expensive or impossible to copy. <br><br><img src="https://camo.githubusercontent.com/4e6890d6c354b36cb9f94b5dca08eb54be60802e/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f70726f78792e737667" alt="image"><br><br>  We can distinguish three types of proxies: <br><ul><li>  Virtual proxy </li><li>  Remote proxy </li><li>  Protection proxy </li></ul><br>  In this section, we will look at the Virtual Proxy implemented in AngularJS. <br>  In the snippet below, we call the get method of the $ resource object named User: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> User = $resource(<span class="hljs-string"><span class="hljs-string">'/users/:id'</span></span>), user = User.get({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user); <span class="hljs-comment"><span class="hljs-comment">//{}</span></span></code> </pre><br>  console.log will display an empty object.  Since the AJAX request is executed asynchronously after calling User.get, we will not have user data during the call to console.log.  Immediately after calling User.get, a GET request is executed, it returns an empty object and stores a link to it.  We can imagine this object as a virtual proxy, it will be filled with data as soon as the client receives a response from the server. <br><br>  How does it work in AngularJS?  Let's look at the following snippet: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainCtrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope, $resource</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> User = $resource(<span class="hljs-string"><span class="hljs-string">'/users/:id'</span></span>), $scope.user = User.get({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }); }</code> </pre><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-bind</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user.name"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  After executing the code snippet shown above, the user property of the $ scope object will be an empty object ({}), which means that user.name will be undefined and will not be displayed.  After the server returns a response for a GET request, AngularJS fills this object with data received from the server.  During the next $ digest cycle, AngularJS will detect changes in $ scope.user and this will update the view. <br><br><h4>  Active record </h4><br>  Active Record is an object that stores data and behavior.  Usually, most of the data in this object is permanent, the responsibility of the Active Record object is to take care of communicating with the database to create, update, search, and delete data.  It can delegate this responsibility to lower level objects, but a call to an Active Record object or its static methods will lead to interaction with the database. <br><br><img src="https://camo.githubusercontent.com/24c0015d2ae09b5e0ca7d065ebb6a738744e0951/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f6163746976652d7265636f72642e737667" alt="image"><br><br>  AngularJS defines service $ resource.  In the current version of AngularJS (1.2+), it is distributed as a separate module and is not included in the kernel. <br>  According to the $ resource documentation: <br>  $ resource is a factory for creating $ resource objects that allow you to interact with RESTful data sources on the server side.  The $ resource object has methods that provide high-level behavior, without the need to interact with the $ http low-level service. <br><br>  This shows how $ resource can be used: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> User = $resource(<span class="hljs-string"><span class="hljs-string">'/users/:id'</span></span>), user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span> : <span class="hljs-number"><span class="hljs-number">42</span></span> }); user.$save();</code> </pre><br>  Calling $ resource creates a constructor for instances of our model.  Each of the model instances will have methods that can be used for different CRUD operations. <br><br>  Thus, we can use the constructor function and its static methods: <br><br><pre> <code class="javascript hljs">User.get({ <span class="hljs-attr"><span class="hljs-attr">userid</span></span>: userid });</code> </pre><br>  The code above will immediately return an empty object and save a link to it.  After the answer is received and analyzed, AngularJS will fill the object with the received data (see proxy). <br>  You can find more detailed documentation on the "magic" of $ resource and AngularJS. <br>  So Martin Fowler states that: <br>  An Active Record object must take care of communication with the database in order to create ... <br>  $ resource does not implement the full Active Record template, as it interacts with a RESTful service instead of a database.  Anyway, we can consider it as ‚ÄúActive Record for interacting with RESTful‚Äù. <br><br><h4>  Intercepting Filters </h4><br>  Creates a chain of filters to perform simple pre / post request processing tasks. <br><br><img src="https://camo.githubusercontent.com/e231d42515eb7513596745d3dd5a20ced7154fa1/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f696e74657263657074696e672d66696c746572732e737667" alt="image"><br><br>  In some cases, you will need to do some kind of pre / post HTTP request processing.  In this case, Intercepting Filters are designed for the pre / post processing of HTTP requests / responses, for logging, security, or any other task that needs the body or header of the request.  Typically, the Intercepting Filters pattern includes a chain of filters, each of which processes data in a specific order.  The output of each filter is the input to the next. <br><br>  In AngularJS we have an idea about Intercepting Filters in $ httpProvider.  $ httpProvider has an interceptors property (interceptors), it includes a list of objects.  Each object has properties: request, response, requestError, responseError. <br><br>  The requestError is called if an error occurred in the previous interceptor or was rejected; accordingly, the responseError is called when the previous response interceptor raised an exception. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Below is a basic example of how you can add interceptors using an object literal: </font></font><br><br><pre> <code class="javascript hljs">$httpProvider.interceptors.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$q, dependency1, dependency2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'request'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">config</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// same as above }, 'response': function(response) { // same as above } }; });</span></span></code> </pre><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Directives </font></font></h3><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Composite </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The composite pattern (linker) is a structural design pattern. </font><font style="vertical-align: inherit;">The composite template describes how to group objects so that they can be accessed, as well as to a single object. </font><font style="vertical-align: inherit;">The purpose of composite is to compose objects in a tree structure, to represent the hierarchy from the particular to the whole. </font></font><br><br><img src="https://camo.githubusercontent.com/2a139189766d4182e35babc96578007b834b84cc/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f636f6d706f736974652e737667" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to the Gang of Four, MVC is nothing more than a combination:</font></font><br><ul><li>  Strategy </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Composite </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Observer </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They claim that the presentation is a composition of components. </font><font style="vertical-align: inherit;">AngularJS has a similar situation. </font><font style="vertical-align: inherit;">Representations are formed by a composition of directives and DOM elements on which these directives are built. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at the following example:</font></font><br><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!doctype html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">zippy</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">title</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Zippy"</span></span></span><span class="hljs-tag">&gt;</span></span> Zippy! <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">zippy</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs">myModule.directive(<span class="hljs-string"><span class="hljs-string">'zippy'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">restrict</span></span>: <span class="hljs-string"><span class="hljs-string">'E'</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;div&gt;&lt;div class="header"&gt;&lt;/div&gt;&lt;div class="content" ng-transclude&gt;&lt;/div&gt;&lt;/div&gt;'</span></span>, <span class="hljs-attr"><span class="hljs-attr">link</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scope, el</span></span></span><span class="hljs-function">) </span></span>{ el.find(<span class="hljs-string"><span class="hljs-string">'.header'</span></span>).click(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ el.find(<span class="hljs-string"><span class="hljs-string">'.content'</span></span>).toggle(); }); } } });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This example creates a directive that is a component of the user interface. </font><font style="vertical-align: inherit;">The created component (with the name ‚Äúzippy‚Äù) has a title and content. </font><font style="vertical-align: inherit;">Clicking on its title switches the visibility of its contents. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the first example, we can see that the DOM tree is a composition of elements. </font><font style="vertical-align: inherit;">The root component is html, immediately followed by the nested elements head, body, and so on ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the second example, we see that the property of the template directive contains markup with the directive ng-transclude. </font><font style="vertical-align: inherit;">This means that there can be another ng-transclude directive inside the ‚Äúzippy‚Äù directive, that is, a composition of directives. </font><font style="vertical-align: inherit;">Theoretically, we can do infinite nesting of components until we reach the end node.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpreter </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpreter (interpreter) is a behavioral design pattern that specifies how to define expressions in a language. </font><font style="vertical-align: inherit;">The basic idea is to classify each character (terminal or non-terminal) in a specialized programming language. </font><font style="vertical-align: inherit;">The syntax tree (an example of a composition template) of expressions is used to analyze (interpret) an expression. </font></font><br><br><img src="https://camo.githubusercontent.com/f79fac725536ec9f4b77da701415386d9a94d56d/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f696e7465727072657465722e737667" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using $ parse, AngularJS provides its own DSL interpreter implementation (Domain Specific Language). </font><font style="vertical-align: inherit;">Using DSL simplifies and modifies javascript. </font><font style="vertical-align: inherit;">The main difference between AngularJS and JavaScript expressions is that AngularJS expressions:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> may include filters with UNIX similar syntax </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exclude no exceptions </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> have no state flow control (exceptions, cycles, conditions can also use a ternary operator) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> run in the resulting context (current $ scope context) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inside $ parse, two main components are defined: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       var Lexer; //       var Parser;</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When an expression is received, it is broken into lexemes and cached (due to performance issues). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terminal expressions in AngularJS DSL are defined as follows:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> OPERATORS = { <span class="hljs-comment"><span class="hljs-comment">/* jshint bitwise : false */</span></span> <span class="hljs-string"><span class="hljs-string">'null'</span></span>:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>;}, <span class="hljs-string"><span class="hljs-string">'true'</span></span>:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;}, <span class="hljs-string"><span class="hljs-string">'false'</span></span>:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;}, <span class="hljs-attr"><span class="hljs-attr">undefined</span></span>:noop, <span class="hljs-string"><span class="hljs-string">'+'</span></span>:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">self, locals, a,b</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }, '*':function(self, locals, a,b){return a(self, locals)*b(self, locals);}, '/':function(self, locals, a,b){return a(self, locals)/b(self, locals);}, '%':function(self, locals, a,b){return a(self, locals)%b(self, locals);}, '^':function(self, locals, a,b){return a(self, locals)^b(self, locals);}, '=':noop, '===':function(self, locals, a, b){return a(self, locals)===b(self, locals);}, '!==':function(self, locals, a, b){return a(self, locals)!==b(self, locals);}, '==':function(self, locals, a,b){return a(self, locals)==b(self, locals);}, '!=':function(self, locals, a,b){return a(self, locals)!=b(self, locals);}, '&lt;':function(self, locals, a,b){return a(self, locals)&lt;b(self, locals);}, '&gt;':function(self, locals, a,b){return a(self, locals)&gt;b(self, locals);}, '&lt;=':function(self, locals, a,b){return a(self, locals)&lt;=b(self, locals);}, '&gt;=':function(self, locals, a,b){return a(self, locals)&gt;=b(self, locals);}, '&amp;&amp;':function(self, locals, a,b){return a(self, locals)&amp;&amp;b(self, locals);}, '||':function(self, locals, a,b){return a(self, locals)||b(self, locals);}, '&amp;':function(self, locals, a,b){return a(self, locals)&amp;b(self, locals);}, '|':function(self, locals, a,b){return b(self, locals)(self, locals, a(self, locals));}, '!':function(self, locals, a){return !a(self, locals);} };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each function associated with each terminal symbol can be represented as an implementation of the Abstract Abstract interface (abstract expressions). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The client interprets the resulting expression in a specific context - a certain $ scope. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A few simple AngularJS expressions:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// toUpperCase filter is applied to the result of the expression // (foo) ? bar : baz (foo) ? bar : baz | toUpperCase</span></span></code> </pre><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Template View </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Converts data to HTML by embedding markers in an HTML page. </font></font><br><br><img src="https://camo.githubusercontent.com/3eae6b8521b589af56aa52646235af86c01656e5/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f74656d706c6174652d766965772e737667" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamically displaying a page is not such an easy task. This is due to the large number of string concatenation, manipulations and problems. The easiest way to build a dynamic page is to write your markup and include several expressions in it that will be processed in a specific context, as a result the entire template will be converted to the final format. In our case, this format will be HTML (or even DOM). This is exactly what template engines do ‚Äî they get the DSL, process it in the appropriate context, and then convert it to the final format.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Templates are very often used on the back-end. </font><font style="vertical-align: inherit;">For example, you can embed PHP code inside HTML and create dynamic pages, or you can use Smarty or eRuby in Ruby to embed Ruby code into static pages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are many templating engines in JavaScript, such as mustache.js, handlebars, etc. </font><font style="vertical-align: inherit;">Most of them work with a string-like pattern. </font><font style="vertical-align: inherit;">The template can be stored in various ways:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> static file to be received by AJAX </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> built-in script inside your view </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> line inside your javascript code </font></font></li></ul><br>  For example: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"template/mustache"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Names</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {{#names}} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{{name}}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {{/names}} </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The template engine turns a string into DOM elements by combining it with the resulting context. </font><font style="vertical-align: inherit;">Thus, all embedded expressions are parsed and replaced with their values. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, if we process the template shown above in the context of the object: {names: ['foo', 'bar', 'baz']} then we get:</font></font><br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span>Names<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span>foo<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span>bar<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span>baz<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, templates in AngularJS are plain HTML. </font><font style="vertical-align: inherit;">They are not in an intermediate format, like most templates. </font><font style="vertical-align: inherit;">What does the AngularJS compiler do to bypass the DOM tree and find already known directives (elements, attributes, classes or even comments)? </font><font style="vertical-align: inherit;">When AngularJS finds any of these directives it calls the logic associated with it, it may include defining various expressions in the context of the current $ scope.</font></font><br><br>  For example: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-repeat</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name in names"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span>{{name}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the context of scope: </font></font><br><br><pre> <code class="javascript hljs">$scope.names = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>];</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You will get the same result as above. </font><font style="vertical-align: inherit;">The main difference is that the template is not located inside the script tag, here it is just HTML.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Scope </font></font></h3><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Observer </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The observer pattern (observer) is a behavioral design pattern, in which an object is called a subject, stores a list of its dependencies, called observers, and notifies them of any state changes, usually by calling one of their methods. </font><font style="vertical-align: inherit;">Mainly used to implement distributed event processing systems. </font></font><br><br><img src="https://camo.githubusercontent.com/d5aa2458b9f7112b6549f6edc898292f91e25523/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f6f627365727665722e737667" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In AngularJS applications, there are two main ways to interact between scope.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, call the methods of the parent scope from the child scope. This is possible because the child scope inherits the prototype of its parent, as mentioned above (see Scope). This allows one-way interaction from the child to the parent. Sometimes it is necessary to call the child scope method or notify it about the occurrence of an event in the parent scope. AngularJS provides a built-in viewer template that allows you to do this. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second possible use of the observer pattern is when several scope are subscribed to events, but the scope in which it occurs does not know anything about it. This reduces the scope of connectivity, they should not know anything about the other scope.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each scope in AngularJS has public $ on, $ emit and $ broadcast methods. </font><font style="vertical-align: inherit;">The $ on method takes the event name and callback function as arguments. </font><font style="vertical-align: inherit;">This function can be represented as an observer - an object that implements the observer interface (In JavaScript, all functions are first class, therefore we can provide only the implementation of the notification method).</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleCtrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope</span></span></span><span class="hljs-function">) </span></span>{ $scope.$on(<span class="hljs-string"><span class="hljs-string">'event-name'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//body }); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the current scope subscribes to the event-name event. </font><font style="vertical-align: inherit;">When it occurs in any of the parent or child scope, the handler will be called. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The $ emit and $ broadcast methods are used to trigger events, respectively, up and down the inheritance chain.</font></font> For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleCtrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope</span></span></span><span class="hljs-function">) </span></span>{ $scope.$emit(<span class="hljs-string"><span class="hljs-string">'event-name'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> }); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the example above, scope generates an event-name event up for all scope. </font><font style="vertical-align: inherit;">This means that every parent scope that is subscribed to the event name will be notified and its handler will be called. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same thing happens when the $ broadcast method is called. </font><font style="vertical-align: inherit;">The only difference is that the event will be passed down - for all child scope. </font><font style="vertical-align: inherit;">Each scope can subscribe to any event with multiple callback functions (i.e., it can associate several observers with this event). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the JavaScript community, this template is better known as publish / subscribe.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chain of Responsibilities </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chain of Responsibilities is a behavioral design pattern that consists of a command object and a sequence of processing objects (handlers). Each handler contains logic that determines the type of command it can process. Then the command goes to the next handler in the chain. The template also contains a mechanism for adding new handlers to the end of this chain. </font></font><br><br><img src="https://camo.githubusercontent.com/1b4fba5e4c03afb785f2454ec3c6cd2929b65f7e/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f636861696e2d6f662d726573706f6e736962696c69746965732e737667" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As shown above, scope forms a hierarchy known as the scope chain. Some of these scope are isolated, which means that they do not inherit the prototypes of their parent scope, but are associated with it through its $ parent property.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After calling $ emit or $ broadcast, an event occurs that starts moving (up or down depending on the method called) along the scope chain, it can be represented as an event bus or, more precisely, as a chain of duties. </font><font style="vertical-align: inherit;">Each subsequent scope may:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Handle the event and pass it to the next scope in the chain </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Process the event and stop its distribution. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Skip the event to the next scope in the chain, without processing it </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stop event distribution without processing it </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the example below, ChildCtrl generates an event that propagates up the scope chain. </font><font style="vertical-align: inherit;">Here, each parent scope (ParentCtrl and MainCtrl) must process the event by writing to the console: ‚Äúfoo received‚Äù. </font><font style="vertical-align: inherit;">If any of the scope should be the final recipient, it can call the stopPropagation method in the event object.</font></font><br><br><pre> <code class="javascript hljs">myModule.controller(<span class="hljs-string"><span class="hljs-string">'MainCtrl'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope</span></span></span><span class="hljs-function">) </span></span>{ $scope.$on(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo received'</span></span>); }); }); myModule.controller(<span class="hljs-string"><span class="hljs-string">'ParentCtrl'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope</span></span></span><span class="hljs-function">) </span></span>{ $scope.$on(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo received'</span></span>); }); }); myModule.controller(<span class="hljs-string"><span class="hljs-string">'ChildCtrl'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope</span></span></span><span class="hljs-function">) </span></span>{ $scope.$emit(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>); });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The handlers in the UML diagram shown above are different scope added to the controller. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Command </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Command is a behavioral design pattern in which an object is used to encapsulate all the necessary information and call a method over time. </font><font style="vertical-align: inherit;">This information includes the name of the method, the object to which the method belongs, and the values ‚Äã‚Äãof the method parameters. </font></font><br><br><img src="https://camo.githubusercontent.com/59589669fe58f551ab8d912ea0391641daba667b/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f636f6d6d616e642e737667" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In AngularJS, the Command pattern allows you to describe the implementation of data binding. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When we want to link our model with a view, we can use the ng-bind directive (for one-way data binding) and the ng-model (for two-way data binding). </font><font style="vertical-align: inherit;">For example, if we want each model change to be displayed in the view:</font></font><br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-bind</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"foo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now every time we change the value of foo, the text inside the span tag will also be changed. </font><font style="vertical-align: inherit;">You can also use more complex expressions:</font></font><br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-bind</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"foo + ' ' + bar | uppercase"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the example above, the value of the span tag is the sum of the foo and bar values ‚Äã‚Äãin uppercase. </font><font style="vertical-align: inherit;">What happens inside? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In each scope there is a $ watch method. </font><font style="vertical-align: inherit;">When the AngularJS compiler finds the ng-bind directive, it creates a new observer for the expression foo + '' + bar | </font><font style="vertical-align: inherit;">uppercase, ($ scope. $ watch ("foo + '' + bar | uppercase", function () {/ * body * /});). </font><font style="vertical-align: inherit;">The callback function will be called every time the value of the expression changes. </font><font style="vertical-align: inherit;">In this case, the callback function will update the value of the span tag. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here are the first few lines of the $ watch implementation:</font></font><br><br><pre> <code class="javascript hljs">$watch: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">watchExp, listener, objectEquality</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, get = compileToFn(watchExp, <span class="hljs-string"><span class="hljs-string">'watch'</span></span>), array = scope.$$watchers, watcher = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span>: listener, <span class="hljs-attr"><span class="hljs-attr">last</span></span>: initWatchVal, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: get, <span class="hljs-attr"><span class="hljs-attr">exp</span></span>: watchExp, <span class="hljs-attr"><span class="hljs-attr">eq</span></span>: !!objectEquality }; <span class="hljs-comment"><span class="hljs-comment">//...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can see watcher as Command. </font><font style="vertical-align: inherit;">The Command expression will be evaluated in each $ digest cycle. </font><font style="vertical-align: inherit;">As soon as AngularJS detects a change in expression, it will call the listener function. </font><font style="vertical-align: inherit;">Watcher includes all the necessary information for monitoring and delegating the execution of the command to the listener (the actual recipient). </font><font style="vertical-align: inherit;">We can represent the $ scope as the Client and the $ digest loop as Invoker commands.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Controllers </font></font></h3><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Page controller </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An object that processes requests for a specific page or action on a site. Martin Fowler. </font></font><br><br><img src="https://camo.githubusercontent.com/a459a7055792ffbba88f8be4467825fd406550f8/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f706167652d636f6e74726f6c6c65722e737667" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to 4 controllers per page: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The page controller template allows data input from the received page, performing the requested actions for the model and determines the correct presentation for the resulting page. The separation of control logic from the rest of the view code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to the large amount of duplicate code on the pages (for example, footers, headers, code that takes care of the user's session), controllers can form a hierarchy. AngularJS has controllers that are limited in scope. They do not accept user requests, since it is the responsibility of $ route or $ state, and the ng-view / ui-view directives are responsible for the display.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just like in page controllers, AngularJS controllers are responsible for user interaction, providing updated models. These models after adding to the scope are not protected from viewing, all methods included in the view eventually become user actions (scope methods). Another similarity between page controllers and AngularJS controllers is the hierarchy that they form. This corresponds to the scope hierarchy of visibility. Thus, by simple actions we can isolate the base controllers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AngularJS controllers are very similar to ASP.NET WebForms, since their responsibilities are almost the same. Here is an example of a hierarchy between several controllers:</font></font><br><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!doctype html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-controller</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MainCtrl"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-controller</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ChildCtrl"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>{{user.name}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"click()"</span></span></span><span class="hljs-tag">&gt;</span></span>Click<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainCtrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope, $location, User</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!User.isAuthenticated()) { $location.path(<span class="hljs-string"><span class="hljs-string">'/unauthenticated'</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChildCtrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope, User</span></span></span><span class="hljs-function">) </span></span>{ $scope.click = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'You clicked me!'</span></span>); }; $scope.user = User.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This example illustrates the easiest way to reuse logic with the base controller, but in any case, it is not recommended to put the authorization logic in controllers in ‚Äúproduction‚Äù applications. </font><font style="vertical-align: inherit;">Access to different routes can be defined at a higher level of abstraction. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChildCtr is responsible for displaying the model in a view and handling actions, such as clicking a button called ‚ÄúClick‚Äù.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Others </font></font></h3><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Module Pattern </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, this is not a design pattern from the "gang of four" and not even one of the "Patterns of Enterprise Application Architecture". This is a traditional JavaScript design pattern, the purpose of which is to provide encapsulation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the template module, you can get data privacy based on functional and lexical scope. Each module can have zero and more private methods that are hidden in the local scope. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function returns an object that provides a public API for this module:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Page = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTitle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.title = t; title = t; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTitle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> title; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">setTitle</span></span>: setTitle, <span class="hljs-attr"><span class="hljs-attr">getTitle</span></span>: getTitle }; }());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the example above, IIFE (Immediately-Invoked Function Expression is an expression of an immediately called function) that returns an object after the call, with two methods (setTitle and getTitle). </font><font style="vertical-align: inherit;">The returned object is assigned to the Page variable. </font><font style="vertical-align: inherit;">In this case, the user of the Page object does not have direct access to the title variable, which is defined within the local IIFE scope. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Template module is very useful when defining service in AngularJS. </font><font style="vertical-align: inherit;">Using this template, we can achieve (and actually achieve) privacy:</font></font><br><br><pre> <code class="javascript hljs">app.factory(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">privateMember</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//body... } function publicMember() { //body... privateMember(); //body } return { publicMember: publicMember }; });</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After we add foo to any other component, we will not be able to use private methods, only public ones. </font><font style="vertical-align: inherit;">This solution is quite powerful, especially when we create libraries for reuse.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Data mapper </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Data Mapper template is a data access layer that performs bidirectional data transfer between a persistent data store (often a relational database) and in-memory data. The purpose of this template is to store in memory the representation of persistent data, independently from each other and from oneself. </font></font><br><br><img src="https://camo.githubusercontent.com/7cc6cef0e7bc01da6d24a48fab0427ca0a357934/68747470733a2f2f7261776769742e636f6d2f6d6765636865762f616e67756c61726a732d696e2d7061747465726e732f6d61737465722f696d616765732f646174612d6d61707065722e737667" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As already mentioned, the Data Mapper is used for bidirectional data transfer between the persistent data store and the in-memory data. Typically, an AngularJS application interacts with a server API that is written in any server language (Ruby, PHP, Java, JavaScript, etc.). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we have a RESTful API, service $ resource will help us interact with the server in Active Record in a similar style. Although some applications do not return data from the server in the most appropriate format that we want to use on the front-end.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For example, let's assume we have an application in which each user has: </font></font><br><ul><li>  name </li><li>  address </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> list of friends </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And our API which has the following methods: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GET / user /: id - returns the name and address of the received user </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GET / friends /: id - returns the list of friends of this user. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One solution is to use two different services, one for the first method and the other for the second. </font><font style="vertical-align: inherit;">Perhaps a more appropriate solution would be to use one service, which is called User, it loads the user's friends when we request User:</font></font><br><br><pre> <code class="javascript hljs">app.factory(<span class="hljs-string"><span class="hljs-string">'User'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$q</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, address, friends</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.address = address; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.friends = friends; } User.get = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">params</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = $http.get(<span class="hljs-string"><span class="hljs-string">'/user/'</span></span> + params.id), friends = $http.get(<span class="hljs-string"><span class="hljs-string">'/friends/'</span></span> + params.id); $q.all([user, friends]).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, friends</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(user.name, user.address, friends); }); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User; });</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we created a pseudo Data Mapper that adapts to our API in accordance with the requirements of the SPA. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can use User as follows:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainCtrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope, User</span></span></span><span class="hljs-function">) </span></span>{ User.get({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ $scope.user = data; }); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the corresponding pattern: </font></font><br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> Name: {{user.name}} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> Address: {{user.address}} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> Friends with ids: <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-repeat</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"friend in user.friends"</span></span></span><span class="hljs-tag">&gt;</span></span>{{friend}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><h3>  Links </h3><br><ol><li> <a href="https://en.wikipedia.org/wiki"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The design patterns are wikipedia.</font></font></li><li> <a href="https://docs.angularjs.org/">AngularJS' documentation</a> </li><li> <a href="">AngularJS' git repository</a> </li><li> <a href="http://msdn.microsoft.com/en-us/library/ff649595.aspx">Page Controller</a> </li><li> <a href="http://martinfowler.com/books/eaa.html">Patterns of Enterprise Application Architecture (P of EAA)</a> </li><li> <a href="http://googletesting.blogspot.com/2008/05/tott-using-dependancy-injection-to.html">Using Dependancy Injection to Avoid Singletons</a> </li><li> <a href="https://stackoverflow.com/questions/13512949/why-would-one-use-the-publish-subscribe-pattern-in-js-jquery">Why would one use the Publish/Subscribe pattern (in JS/jQuery)?</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/250149/">https://habr.com/ru/post/250149/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250129/index.html">Use SVG (Part One)</a></li>
<li><a href="../250135/index.html">Thoughts</a></li>
<li><a href="../250137/index.html">Creating a view with an animated property change</a></li>
<li><a href="../250141/index.html">Installing Redmine on Windows 7 as a service, with sqlite3 database</a></li>
<li><a href="../250145/index.html">Stages of birth of new functionality in the software product</a></li>
<li><a href="../250153/index.html">Continuous integration with unity</a></li>
<li><a href="../250155/index.html">Documenting programs</a></li>
<li><a href="../250157/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ34 (February 2 - 8, 2015)</a></li>
<li><a href="../250159/index.html">Deploying Windows Server 2012 R2 to Dell servers in BARE-METAL mode. Part 1</a></li>
<li><a href="../250161/index.html">2 FortiGate Multi-Threat Security Systems curriculum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>