<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Everything you wanted to know about processing requests, but were shy to ask</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is a network service? This is a program that accepts incoming requests over the network and processes them, possibly returning answers. 


 There...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Everything you wanted to know about processing requests, but were shy to ask</h1><div class="post__text post__text-html js-mediator-article"><p>  What is a network service?  This is a program that accepts incoming requests over the network and processes them, possibly returning answers. </p><br><p>  There are many aspects in which network services differ from each other.  In this article I will focus on how to handle incoming requests. </p><br><p>  Choosing how to process requests has far-reaching implications.  How to make a chat service that can handle 100,000 simultaneous connections?  What approach to choose to extract data from a stream of weakly structured files?  Wrong choice will lead to waste of time and effort. </p><br><p>  The article discusses such approaches as a process / thread pool, event-oriented processing, half sync / half async pattern, and many others.  Numerous examples are given, pros and cons of approaches, their features and areas of application are considered. </p><a name="habracut"></a><br><h2 id="vvedenie">  Introduction </h2><br><p>  Subject ways of processing requests is not new, see, for example: <a href="https://habr.com/post/108294/%25C3%2590%25C2%25B1">one</a> , <a href="https://habr.com/post/337528/">two</a> .  However, most articles consider it only partially.  This article is designed to fill in the blanks and provide a consistent statement of the question. </p><br><p>  The following approaches will be considered: </p><br><ul><li>  sequential processing </li><li>  request process </li><li>  thread per request </li><li>  process / thread pool </li><li>  event-oriented processing (reactor pattern) </li><li>  half sync / half async pattern </li><li>  pipelining </li></ul><br><p>  It should be noted that the service processing requests is not necessarily a network service.  This may be a service that receives new tasks from the database or task queue.  This article refers to network services, but you need to understand that the approaches under consideration have a wider scope. </p><br><h3 id="tldr">  TL; DR </h3><br><p>  At the end of the article is a list with a brief description of each of the approaches. </p><br><h2 id="posledovatelnaya-obrabotka">  Sequential processing </h2><br><p>  An application consists of a single thread in a single process.  All requests are processed only sequentially.  There is no parallelism.  If several requests come to the service at the same time, one of them is processed, the rest are in the queue. </p><br><p>  The advantage of this approach is the ease of implementation.  There are no locks and competition for resources.  The obvious disadvantage is the inability to scale with a large number of clients. </p><br><h2 id="process-na-zapros">  Request process </h2><br><p>  An application consists of a main process that accepts incoming requests and workflows.  For each new request, the main process creates a workflow that processes the request.  Scaling by the number of requests is simple: each request gets its own process. </p><br><p>  There is nothing complicated about this architecture either, but it has <del>  Problems </del>  <strong>restrictions</strong> : </p><br><ul><li>  The process consumes a lot of resources. <br>  Try creating 10,000 simultaneous connections to a PostgreSQL RDBMS and look at the result. </li><li>  Processes do not have shared memory (default).  If you need access to shared data or shared cache, you will have to save spiced memory (call linux mmap, munmap) or use external storage (memcahed, redis) </li></ul><br><p>  These problems are not stop.  Below will be shown how they cost in PostgeSQL RDBMS. </p><br><p>  <strong>Advantages of</strong> this architecture: </p><br><ul><li>  The fall of one of the processes will not affect the rest.  For example, the error of processing a rare case will not drop the entire application, only the processed request will suffer. </li><li>  Differentiation of access rights at the operating system level.  Since the process is the essence of the OS, its standard mechanisms can be used to differentiate access rights to the OS resources. </li><li>  You can change the running process on the fly.  For example, if a separate script is used to process a request, then to replace the processing algorithm, it suffices to change the script.  An example will be discussed below. </li><li>  Multi-core machines are effectively used. </li></ul><br><p>  <strong>Examples:</strong> </p><br><ul><li>  PostgreSQL RDBMS creates a new process for each new connection.  Shared memory is used to work with general data.  The problem of high resource consumption processes in PostgreSQL can be solved in different ways.  If there are few customers (a dedicated stand for analysts), then there is no such problem.  If there is a single application that accesses the database, you can create a pool of database connections at the application level.  If there are many applications, pgbouncer can be used. </li><li>  sshd listens to incoming requests on port 22 and forks at every connection.  Each ssh connection is a fork of the sshd daemon, which accepts and executes user commands sequentially.  Thanks to this architecture, the resources of the OS itself are used to differentiate access rights. </li><li>  An example from own practice.  There is a stream of unstructured files from which to get metadata.  The main process of the service distributes files by handler processes.  Each process handler is a script that takes a file path as a parameter.  File processing takes place in a separate process, therefore, due to a processing error, the entire service does not fall.  To update the processing algorithm, it is enough to change the processing scripts without stopping the service. </li></ul><br><p>  In general, it must be said that this approach has its advantages, which determine its scope, but the scalability is very limited. </p><br><h2 id="potok-na-zapros">  Flow per request </h2><br><p>  This approach is very similar to the previous one.  The difference is that instead of processes threads are used.  This allows you to use shared memory out of the box.  However, other advantages of the previous approach cannot be used, while resource consumption will also be high. </p><br><p>  <strong>Pros:</strong> </p><br><ul><li>  Shared memory "out of the box" </li><li>  Ease of implementation </li><li>  Efficient use of multi-core CPUs </li></ul><br><p>  <strong>Minuses:</strong> </p><br><ul><li>  The thread consumes a lot of resources.  On unix-like operating systems, the thread consumes almost as many resources as the process </li></ul><br><p>  MySQL can be used as an example.  But it should be noted that MySQL uses a mixed approach, so this example will be discussed in the next section. </p><br><h2 id="pul-processovpotokov">  Process / thread pool </h2><br><p>  Flows (processes) create expensive and long.  In order not to waste resources, you can use the same thread repeatedly.  By limiting additionally the maximum number of threads, we get a pool of threads (processes).  Now the main thread accepts incoming requests and puts them in a queue.  Workflows take requests from the queue and process.  This approach can be perceived as a natural scaling of sequential processing of requests: each worker thread can process threads only sequentially, combining them into a pool allows processing requests in parallel.  If each stream can handle 1000 rps, then 5 threads will handle a load close to 5000 rps (assuming minimal competition for shared resources). </p><br><p>  The pool can be created in advance at the start of the service or be formed gradually.  Using a thread pool is more common, because  allows you to use shared memory. </p><br><p>  The size of the thread pool does not have to be limited.  The service can use free threads from the pool, and if there are none, create a new thread.  After the request has been processed, the thread joins the pool and waits for the next request.  This option is a combination of a query approach and a pool of threads.  Below is an example. </p><br><p>  <strong>Pros:</strong> </p><br><ul><li>  use of many CPU cores </li><li>  reducing the costs of creating a thread / process </li></ul><br><p>  <strong>Minuses:</strong> </p><br><ul><li>  Limited scalability by the number of simultaneous clients.  Using a pool allows us to reuse the same thread multiply without additional resource costs, but it does not solve the fundamental problem of the large amount of resources consumed by a thread / process.  Create a chat service that can handle 100,000 simultaneous connections using this approach will not work. </li><li>  Scalability is limited by shared resources, for example, if threads use shared memory, adjusting access to it using semaphores / mutexes.  This is a limitation of all approaches that use shared resources. </li></ul><br><p>  <strong>Examples:</strong> </p><br><ol><li>  Python application running with uWSGI and nginx.  The main uWSGI process receives incoming requests from nginx and distributes them between interpreter Python processes that process requests.  The application can be written on any uWSGI-compatible framework - Django, Flask, etc. </li><li>  MySQL uses a thread pool: each new connection is processed by one of the free threads from the pool.  If there are no free threads, then MySQL creates a new thread.  The size of the pool of free threads and the maximum number of threads (connections) are limited by the settings. </li></ol><br><p>  Perhaps this is one of the most common approaches to building network services, if not the most common.  It allows you to scale well, reaching large rps.  The main limitation of the approach is the number of simultaneously processed network connections.  In fact, this approach works well only if the requests are short or there are few customers. </p><br><h2 id="sobytiyno-orientirovannaya-obrabotka-reactor-pattern">  Event-oriented processing (reactor pattern) </h2><br><p> Two paradigms - synchronous and asynchronous - the eternal rivals of each other.  So far, it has only been about synchronous approaches, but it would be wrong to ignore the asynchronous approach.  Event-oriented or reactive request processing is an approach in which each IO operation is performed asynchronously, and at the end of the operation the handler is called.  As a rule, the processing of each request consists of a set of asynchronous calls followed by the execution of handlers.  At any given moment, a single-threaded application executes the code of only one handler, but the execution of handlers of various requests alternates with each other, which allows processing multiple parallel requests simultaneously (pseudo-parallelly). </p><br><p>  A full consideration of this approach is beyond the scope of this article.  For a deeper insight, we can recommend <a href="http://design-pattern.ru/patterns/reactor.html">Reactor (Reactor)</a> . <a href="https://habr.com/company/Voximplant/blog/303780/">What is the secret of NodeJS speed?</a>  , <a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/">Inside NGINX</a> .  Here we confine ourselves to considering the pros and cons of this approach. </p><br><p>  <strong>Pros:</strong> </p><br><ul><li>  Effective scaling for rps and number of simultaneous connections.  A reactive service can simultaneously process a large number of connections (tens of thousands) if most connections wait for I / O to complete. </li></ul><br><p>  <strong>Minuses:</strong> </p><br><ul><li>  The complexity of the development.  Programming in the asynchronous style is more complicated than in the synchronous one.  The query processing logic is more complex, and debugging is also more complicated than in synchronous code. </li><li>  Errors leading to blocking the entire service.  If the language or runtime is not designed initially for asynchronous processing, then a single synchronous operation can block the entire service, negating the scaling options. </li><li>  Difficult to scale by the CPU cores.  This approach assumes the presence of a single thread in a single process, so you cannot use multiple CPU cores at the same time.  It should be noted that there are ways to get around this limitation. </li><li>  Corollary to the preceding paragraph: this approach does not scale well for requests demanding on the CPU.  The number of rps for this approach is inversely proportional to the number of CPU operations required to process each request.  Requirements to the CPU queries nullify the benefits of this approach. </li></ul><br><p>  <strong>Examples:</strong> </p><br><ol><li>  Node.js uses the out-of-box reactor pattern.  For details, see What is the secret of NodeJS speed? </li><li>  nginx: worker processes (worker process) nginx'a use the reactor pattern for parallel processing of requests.  See Inside NGINX for more details. </li><li>  A C / C ++ program that directly uses the OS facilities (epoll on linux, IOCP on windows, kqueue on FreeBSD), or uses a framework (libev, libevent, libuv, etc.). </li></ol><br><h2 id="half-synchalf-async">  Half sync / half async </h2><br><p>  The title is taken from <a href="https://www.amazon.com/Pattern-Oriented-Software-Architecture-Concurrent-Networked/dp/0471606952">POSA: Patterns for Concurrent and Networked Objects</a> .  In the original, this pattern is interpreted very broadly, but for the purposes of this article I will understand this pattern somewhat already.  Half sync / half async is a query processing approach that uses a lightweight control flow (green flow) for each request.  A program consists of one or more operating system level threads, but the program execution system supports green threads that the OS does not see and cannot control. </p><br><p>  A few <strong>examples</strong> to make the review more specific: </p><br><ol><li>  Service in the language of Go.  The Go language supports many lightweight execution threads - gorutin.  The program uses one or more OS threads, but the programmer operates with gortines, which are transparently distributed among OS threads to enable multi-core CPUs. </li><li>  Python service with gevent library.  The gevent library allows a programmer to use green streams at the library level.  The whole program is executed in a single OS thread. </li></ol><br><p>  In essence, this approach is designed to combine the high performance of the asynchronous approach with the simplicity of programming synchronous code. </p><br><p>  When using this approach, despite the illusion of synchrony, the program will work asynchronously: the program execution system will control the event loop, and each "synchronous" operation will actually be asynchronous.  When such an operation is called, the execution system will invoke an asynchronous operation using the OS tools and register the handler to complete the operation.  When the asynchronous operation is completed, the execution system will call a previously registered handler, which will continue the execution of the program at the call point of the "synchronous" operation. </p><br><p>  As a result, the half sync / half async approach contains both some advantages and some disadvantages of the asynchronous approach.  The size of the article does not allow to consider this approach in all details.  For those interested, I advise you to read the chapter of the same name in the <a href="https://www.amazon.com/Pattern-Oriented-Software-Architecture-Concurrent-Networked/dp/0471606952">POSA</a> book <a href="https://www.amazon.com/Pattern-Oriented-Software-Architecture-Concurrent-Networked/dp/0471606952">: Patterns for Concurrent and Networked Objects</a> . </p><br><p>  As such, the half sync / half async approach introduces a new green flow entity - a lightweight control flow at the level of the program or library system.  What to do with green streams - the choice of the programmer.  It can use a pool of green streams, can create a new green stream for each new request.  The difference compared to OS threads / processes is that green threads are much cheaper: they consume much less RAM and are created much faster.  This allows you to create a huge number of green streams, for example, hundreds of thousands in the Go language.  Such a huge amount makes justified the use of the "green flow on request" approach. </p><br><p>  <strong>Pros:</strong> </p><br><ul><li>  It scales well by rps and number of simultaneous connections. </li><li>  The code is easier to write and debug compared to the asynchronous approach. </li></ul><br><p>  <strong>Minuses:</strong> </p><br><ul><li>  Since the execution of operations is actually asynchronous, programming errors are possible when a single synchronous operation blocks the entire process.  This is especially felt in languages ‚Äã‚Äãwhere this approach is implemented by means of the library, for example Python. </li><li>  The opacity of the program.  When using threads or OS processes, the program execution algorithm is clear: each thread / process performs operations in the sequence in which they are written in code.  When using the half sync / half async approach, operations that are written in code sequentially can interchange in unpredictable ways with operations processing parallel requests. </li><li>  Unsuitability for real-time systems.  Asynchronous processing of requests greatly complicates the provision of guarantees for the processing time of each individual request.  This is a consequence of the previous paragraph. </li></ul><br><p>  Depending on the implementation, this approach scales well with the CPU cores (Golang) or does not scale at all (Python). <br>  This approach, as well as asynchronous, allows you to handle a large number of simultaneous connections.  But it is easier to program a service using this approach, since  The code is written in the synchronous style. </p><br><h2 id="konveyernaya-obrabotka">  Conveyor processing </h2><br><p>  As the name suggests, in this approach, requests are processed down the pipeline.  The processing process consists of several threads of the OS, arranged in a chain.  Each thread is a link in a chain; it performs a certain subset of the operations necessary to process a request.  Each request sequentially passes through all the links in the chain, and different links process different requests at each moment in time. </p><br><p>  <strong>Pros:</strong> </p><br><ul><li>  This approach scales well with rps.  The more links in the chain, the more requests are processed per second. </li><li>  Using multiple threads allows you to scale well across the CPU cores. </li></ul><br><p>  <strong>Minuses:</strong> </p><br><ul><li>  Not for all categories of requests fit this approach.  For example, it will be difficult and inconvenient to organize long polling with this approach. </li><li>  The complexity of implementation and debugging.  Breaking the sequential processing into stages so that performance is high may not be easy.  Debugging a program in which each request is alternately processed in several threads running in parallel is more difficult than sequential processing. </li></ul><br><p>  <strong>Examples:</strong> </p><br><ol><li>  An interesting example of pipelining was described in the highload report 2018 The <a href="https://www.highload.ru/moscow/2018/abstracts/4219">Evolution of the Architecture of the Moscow Exchange Trading and Clearing System</a> </li></ol><br><p>  Conveyor processing is widely used, but most often the links are separate components in independent processes that exchange messages, for example, through a message queue or database. </p><br><h2 id="rezyume">  Summary </h2><br><p>  A brief summary of the approaches considered: </p><br><ul><li>  Synchronous processing. <br>  A simple approach, but very limited in scalability, both in terms of rps and the number of simultaneous connections.  Does not allow multiple CPU cores at the same time. </li><li>  New process for each request. <br>  The high costs of creating processes.  The approach does not allow to scale effectively by the number of simultaneous connections, it has difficulties when using shared memory.  It is suitable for long-running queries with a small number of simultaneous connections.  It has properties that are useful for some applications (increased reliability, access control at the OS level). </li><li>  New thread for each request. <br>  The problems are the same as in the previous approach, but it makes it easy to use shared memory.  It has a similar scope to the previous approach, but it lacks some of its useful properties. </li><li>  Pull processes / threads. <br>  Compared to the two previous approaches, it avoids the costs of creating processes / threads.  The most commonly used approach for building network services.  It scales well by rps and number of cores used.  Good for handling a large number of short requests.  Badly scaled by the number of simultaneous connections. </li><li>  Event-oriented processing (reactor pattern). <br>  It scales well with rps and the number of simultaneous connections.  It is more difficult to use because of the asynchronous programming style, it can be difficult to catch floating errors.  Scaling by the number of used CPU cores is difficult </li><li>  Half sync / half async. <br>  It scales well with rps and the number of simultaneous connections.  Depending on the implementation, it scales well with the CPU cores (Golang) or does not scale at all (Python).  Spends much less resources on request than the approach process (flow) on request.  It is programmed in a synchronous style in contrast to the pattern of the reactor, however, the same floating errors are possible as in the pattern of the reactor. </li><li>  Conveyor processing. <br>  Allows you to achieve high performance, but difficult to implement approach.  Not suitable for all types of requests (for example, long polling will be difficult to do). </li></ul><br><p>  The list above is not exhaustive, but it contains basic approaches to processing requests. </p><br><p>  I appeal to the reader: what approaches do you use?  What are the pros and cons, features of their work you learned from your own experience? </p><br><h3 id="ssylki">  Links </h3><br><ol><li>  Related articles: <br><ul><li>  <a href="https://habr.com/post/108294/%25C3%2590%25C2%25B1">Once again about the architecture of network demons</a> </li><li>  <a href="https://habr.com/post/337528/">Parallelism versus multithreading versus asynchronous programming: an explanation</a> </li></ul></li><li>  Event-oriented approach: <br><ul><li>  <a href="http://design-pattern.ru/patterns/reactor.html">Reactor (Reactor)</a> </li><li>  <a href="https://habr.com/company/Voximplant/blog/303780/">What is the secret of speed NodeJS?</a> </li><li>  <a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/">Inside nginx</a> </li></ul></li><li>  Comparing approaches based on streams and events: <br><ul><li>  <a href="https://habr.com/post/267721/">Apache vs Nginx: a practical look</a> </li><li>  <a href="https://habr.com/post/150788/">Differences between asynchronous and multi-threaded architecture using the example of Node.js and PHP</a> </li></ul></li><li>  Half sync / half async: <br><ul><li>  <a href="https://java-design-patterns.com/patterns/half-sync-half-async/">Half-Sync / Half-Async (Java Design Patterns)</a> </li><li>  <a href="https://www.amazon.com/Pattern-Oriented-Software-Architecture-Concurrent-Networked/dp/0471606952">POSA: Patterns for Concurrent and Networked Objects</a> </li></ul></li><li>  Green streams: <br><ul><li>  <a href="https://ru.wikipedia.org/wiki/Green_threads">Green threads (Wikipedia)</a> </li><li>  <a href="http://wiki.c2.com/%3FGreenVsNativeThreads">Green Vs Native Threads</a> </li></ul></li><li>  Conveyor processing: <br><ul><li>  <a href="https://www.highload.ru/moscow/2018/abstracts/4219">The evolution of the architecture of the Moscow Exchange Trading and Clearing System</a> </li></ul></li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/432630/">https://habr.com/ru/post/432630/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432620/index.html">MIT course "Computer Systems Security". Lecture 20: "Mobile Phone Security", part 3</a></li>
<li><a href="../432622/index.html">Need more different Blur's</a></li>
<li><a href="../432624/index.html">We study Adversarial Tactics, Techniques & Common Knowledge (ATT @ CK). Enterprise Tactics. Part 5</a></li>
<li><a href="../432626/index.html">Methods of interaction with the system: from punched tapes to neural interfaces</a></li>
<li><a href="../432628/index.html">@Pythonetc November 2018 Compilation</a></li>
<li><a href="../432632/index.html">The story of Lenny, the beloved Internet troll phone spammers</a></li>
<li><a href="../432634/index.html">An overview of five HTTP libraries for web development</a></li>
<li><a href="../432636/index.html">React Training Course, Part 1: Course Overview, React, ReactDOM, and JSX Reasons for Popularity</a></li>
<li><a href="../432638/index.html">What's new in Upsource 2018.2</a></li>
<li><a href="../432640/index.html">Release Rust 1.31 and Rust 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>