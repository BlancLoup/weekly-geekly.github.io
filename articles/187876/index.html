<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[NES] Writing level editor for Prince of Persia. Chapter one. Acquaintance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chapter One , Chapter Two , Chapter Three , Chapter Four , Chapter Five , Epilogue 

 Disclaimer 
 In childhood, like many born in the 80s, I had the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[NES] Writing level editor for Prince of Persia. Chapter one. Acquaintance</h1><div class="post__text post__text-html js-mediator-article">  <b>Chapter One</b> , <a href="http://habrahabr.ru/post/191880/">Chapter Two</a> , <a href="http://habrahabr.ru/post/192028/">Chapter Three</a> , <a href="http://habrahabr.ru/post/192546/">Chapter Four</a> , <a href="http://habrahabr.ru/post/192832/">Chapter Five</a> , <a href="http://habrahabr.ru/post/193406/">Epilogue</a> <br><br><h5>  Disclaimer </h5><br>  In childhood, like many born in the 80s, I had the prefix Dendy.  A clone of the Japanese FamiCom, presented to us by the good Chinese, and distributed by the notorious Steepler, painted the childhood of many from the generation of the 80s in bright colors.  Time after time, passing my favorite games far and wide, finding all possible secrets (and, often, without books with loud headlines in the spirit of ‚ÄúSecrets and Passages of 100,500 +1 games‚Äù, the value of which tends to zero), I wanted to play them more and more, but with new levels, new secrets and new features. <br><br>  Some games provided a built-in level editor (for example, Battle City, Fire'n'Ice aka Solomon's Key 2), but most of them, of course, did not provide such an opportunity.  I wanted to play (naturally!) In the new Super Mario Bros (oh, how I loved and hated the Chinese who released the 99 ... 9 in 1 cartridge, which had levels A-1, B-1, ... Z-1, which is impossible had to go through, or which were duplicates of the original levels, but with modified textures), Duck Tales 1, 2, and many others. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      With the advent of the computer and the possibility of emulating games on it, the light at the end of the tunnel of my dream dawned on me, and hope began to sneak in me.  Various editors of games started appearing in which it is enough to specify a ROM file and you can not only see the whole game with all its secrets and pitfalls, but also add something of your own. <br><br>  Meanwhile, the editors for some games were almost on the first links in Google, while others were hidden away or somewhere far away (but they were still), or were completely absent.  Having found editors for most of my favorite games, I could not find an editor for a Persian prince.  Yes, there are editors for the DOS version, there are for SNES, but my native, NES version, was deprived of such a treasure. <br><br>  The various kinds of resources on NES and its emulation were not very willing to give in to my understanding and I remained somewhere at the level of noob. <br><br>  And, once, at an hour of unprecedentedly hot sunset, in Moscow, I pulled the belt, opened the HEX-editor and the emulator with a debugger, and began to study the mysterious for me set of bytes contained in the ROM. <br><br>  I began ... However, before I begin to tell further, I warned: <br>  <b>It is not recommended to climb under the cat professionals.</b>  <b>There are considered the "zhivoderskie" beginner methods!</b>  <b>Your nervous system may be irreversibly disrupted!</b>  <b>I warned.</b> <br><br><a name="habracut"></a><br><h5>  Understand the essence </h5><br>  Looking at the set of bytes in the HEX-editor and the set of instructions of the 6502 processor unknown to me at that time, I was sad.  This whole picture did not clarify anything.  But, eyes are afraid, and hands do.  We begin to study what is. <br><br><h6>  NES header </h6><br>  This is the first thing that lies on the surface.  Let's start with it. <br>  The header is 16 bytes in size, where, in addition to the signature, there is technical information about the ROM file.  The ROM file itself is a collection of data and technical information in a single file.  Let's look inside the title. <br> <code>4E 45 53 1A 08 00 21 00 00 00 00 00 00 00 00 00</code> <br>  4 bytes: Signature NES-&gt;; <br>  1 byte: The number of 16 kB PRG-ROM banks; <br>  1 byte: Number of 8 kB CHR-ROM banks; <br>  2 bytes: Flags; <br>  1 byte: Number of 8 kB PRG-R <b>A</b> M banks; <br>  2 bytes: Flags; <br>  The remaining tail is zeros. <br><br>  The flags store specific information about working with video memory, the presence of a ‚Äúbattery‚Äù in the original piece of hardware, mapper and other technical information of little interest (I will not describe it, because in this particular case it was not needed). <br><br>  From the header, we find out that we have Mapper # 2 (the byte with the mapper number is made up of the halves of the sixth and seventh bytes) and 8 16 kB of PRG-ROM banks.  Everything else is missing. <br><br>  It follows from the documentation that the PRG-ROM banks are the actual code + arbitrary data that will be used directly by the CPU.  CHR-ROM banks are data for a video subsystem (PPU).  The CPU cannot directly access them. <br>  How do we get the image if we do not have a single CHR-ROM?  Very simple: in PRG, we store data that is copied all the time into PPU memory.  Uncomfortable?  Yes.  But we have, in a sense, more power over this data. <br><br>  Next, we find out that Mapper # 2 actually implies several different mappers, identical in functionality but differentiated by structure: UNROM and UOROM, combined by name in UxROM.  The difference is only in the number of PRG-ROM banks: in the first 8 banks, in the second - 16. For any of them, the last bank is fixed at the end of the RAM ($ C000- $ FFFF), and the remaining 7 (or 15 for the second case) can be switched into the memory area of ‚Äã‚Äã$ 8000- $ BFFF. <br>  This is all technical information which, at the moment, does not tell us anything sensible. <br><br><h5>  Stocking up on canned food </h5><br>  So, we can split the ROM file into 9 components: Header and 8 banks.  There is no sense to edit the title, because  information for the emulator program is stored there, and we don‚Äôt know how to edit banks.  First, the banks do not have any strict structure (as, for example, in PE-format, where the code and resources lie in their sections) and the data can be mixed chaotically with the code.  Maybe we are not lucky at all and the data for building levels are formed by executable code. <br><br>  But, for now let's estimate the options, how could we get what we need from whole pieces of binary porridge: <br><ol><li>  The most difficult, but also the most universal: sequential reverse code debugger.  Using this method, we will definitely get to what we need, on the way getting bonuses in the form of additional information about how the code is constructed.  The disadvantages are obvious: we will spend a lot of time on the reverse, but this is still half the trouble, because we still don‚Äôt know anything, which means we will spend 90% of the time learning the assembler and various programming tricks on it.  Those.  Efficiency will be about 10%.  Few; </li><li>  The study of RAM, and then debugging at the breakpoints of the memory access (consider below).  This method is already better.  We have relatively few memory for study: out of 64 kB of available memory, half of us go to banks from a ROM file, half of this half is either reserved or used by IO ports.  And finally, the remaining half still beats in half.  One half is the IO ports for PPU (there are not many of them, but they mirror all of this half), and the second is divided into four parts of 2 KB.  The first part is the actual RAM used by the code, and the remaining three are the mirrors of the first part.  Thus, we have 2 kB of memory left to study, which we can easily study with money.  The efficiency of the method is higher, because  we will have before our eyes live data that we can change right at the time of execution and immediately look at the result; </li><li>  Study read data.  At the time of going to another level or going to another room, we study the data that was read from the ROM file.  As we remember, in Prince of Persia, each level is divided into rooms between which it runs; </li><li>  ‚ÄúArtisan‚Äù method - ‚ÄúBrutfors‚Äù: changing one byte one by one, screenshot of the result, and why study a bunch of screenshots. </li></ol><br><br>  We stock up on the necessary amount of material and proceed to study it.  We will study in the reverse order: from simple to study (just look at the screenshots) to complex (we study the debugger listings). <br><br>  Armed with tools: <br><ul><li>  Favorite yap for writing helper utilities.  Maybe whatever.  I used C ++ as part of VS2010; </li><li>  Emulator with debugger.  I used versions from different branches of the FCEUX emulator.  FCEUX and FCEUXDSP.  The first has a simple, clumsy debugger that can do very simple things.  The second one has very powerful tools for debugging and studying memory, but unfortunately it often fell, so in simple cases I resorted to the first one; </li><li>  Any hex editor.  I used WinHEX, which allows, without saving the file, to launch it for execution (we edit any byte and press Ctrl + E). </li><li>  For reference, you can use IDAPro with the NES bootloader.  You can use the loader from cah4e3.  But do not expect miracles from her.  banks in the process of changing dynamically change, and the correct code will be only from the last bank. <br></li></ul><br>  Before starting, let's take a look at what UxROM is: <br>  Generally speaking, a mapper is an algorithm from the point of view of an emulator, and from an iron point of view is a controller that handles bank switching in memory. <br>  First: Why does he do it? <br>  Second: How does he do it? <br><br>  The first question is simple: the RAM, which the processor can address, is only 64 kB, and not only the code and data, but also the I / O ports, as well as a bunch of other things (like nonvolatile memory, where intermediate results of some games).  Found a simple solution: as the code is executed, not all the data in memory is required for operation, so they can be simply deleted, and in their place put more important data at a given time.  Next to the ROM-memory on the cartridge they put a controller, which, on command, displays the desired piece in the address memory.  Depending on the complexity of the game, these controllers differed in their fillings.  The Chinese picked it up on time and came up with a lot of different (adequate and not-so) mappers.  Because of this, we have a large number of multiplays. <br><br>  In the second question we will consider only the work of the mapper UxROM, since the rest are not interesting to us now.  Mapper takes the last pot (# 07 or # 0F), puts it at $ C000- $ FFFF and no longer touches.  All other banks are switched on as needed after the recording (in general) at any address from the bank $ C000- $ FFFF space (# 00- # 06 or # 00- # 0E).  But this is done correctly as follows: at the address $ FFF0 + N, N is recorded, where N is the bank number, and as a result, we see the contents of the desired bank at the addresses $ 8000- $ BFFF. <br><br><h6>  We chop the bank with an ax.  Method number 4. </h6><br>  For this, a small utility was written that changed one byte (simple increment: Byte ++), saved it in a separate file, then started the resulting ROM in the emulator, executed the screenshot and closed the emulator. <br>  It would be reasonable to reduce the number of screenshots, because  to study over 130.000 screenshots even quickly would be difficult. <br><br>  Since we only have PRG-ROM banks, some of them probably also have tiles that are not interesting for us.  We will try to exclude them. <br>  We take any tile editor, open a ROM file in it.  I used <b>Tile Layer Pro</b> - it's quite an ancient program, but it knows its work.  It looks <a href="">something like this</a> (in the screenshot, the tiles from the Final Fantasy game).  The status bar of the program window indicates the offset of each tile.  We can scroll through the data window to the point where the tiles obviously end and the garbage data starts in terms of graphics.  Scrolling through, we find out that the first two banks are graphics.  We miss them and 6 banks remain.  Already "only" 96 kB.  Difficult, but still easier. <br><br>  Well.  How can we find the data we need in this way?  Very simple: skimming through the screenshots, we will see that in some of them, we consistently change the blocks in the rooms.  The room consists of 10x3 blocks, respectively, in 30 screenshots in a row, we must (but are not required to!) Adjacent blocks will be changed to some other blocks: for example, a ‚Äúconcrete‚Äù block may change to a column or something else. <br><br>  We start the brute-force utility somewhere aside, and we will start the study of the data read from the ROM. <br><br><h6>  We cut the cover of the can with a cleaver.  Method number 3. </h6><br>  This method is similar to the previous one, but we significantly reduce the amount of data to be studied.  How? <br>  In FCEUXDSP there is a tool that saves read data to a neighboring file.  Between pressing the Start and Pause buttons, the read data is placed in the file exactly in the place where it is stored in the original.  Thus, we can open the data commit dialog, click Start, run from one room to another in the game, click Pause, and, like in the previous paragraph, examine the recorded data.  This data will be significantly less.  In fact, the code itself will show us something to pay attention to.  And going through a hundred or two bytes of labor will not be even manually. <br><br>  With this, I suggest to pause, go to the kitchen, make coffee and open the documentation for instructions on the processor 6502. <br>  Before you use the method number 2, it would not hurt to get acquainted with the enemy. <br><br><h6>  We assemble a microscope to examine the contents.  The devil is not so terrible as he is painted. </h6><br>  The processor 6502 has only <a href="http://dendy.migera.ru/nes/g11.html">56 documented instructions</a> , so a cup of coffee is enough to at least briefly familiarize yourself with them. <br>  Since it will be difficult to figure out the code right away, I have come up with a simple C-like language for learning, into which the assembly sheet can be easily translated. <br><br>  First, let's highlight a few points from the documentation: <br><ol><li>  Addressing can be direct register &lt;-&gt; memory (IMM): LDA $ 00;  STA $ 00; </li><li>  Direct with participation of index registers: register &lt;-&gt; memory + INDEX: LDA $ 0000, X;  STA $ 0000, Y; </li><li>  Indirect with participation of index registers: register &lt;-&gt; pointer + INDEX: LDA ($ 00), X;  STA ($ 00), Y; </li></ol><br>  In indirect addressing, the processor extracts a 16-bit pointer from two cells (within the first page of $ 00- $ FF memory), adds the value of the index register to it, and then works with the cell at the address thus obtained. <br><br>  From here we make the following pseudo code conventions: <br><ul><li>  Variables are denoted as $ XXXX (where XXXX is its address); </li><li>  We denote direct addressing as #XXXX [Y] (where XXXX is the address from which we are addressing).  Analog: * ((char *) (XXXX + Y)) = A; </li><li>  We denote indirect addressing as $ XXXX [Y] (a complete analogy with arrays in C); </li><li>  All procedures we have the same form: char sub_XXXX () {}.  Since the NES does not have any agreements on the transfer of arguments, we will not have any arguments.  Any data, as a rule, is transmitted either through registers or through variables. </li><li>  Registers have original names (A, X, Y). </li><li>  Eight-bit numbers will be written as #XX in HEX </li></ul><br>  Take the simple bank switch code: <br><pre> <code class="hljs mel">$F2D3:<span class="hljs-number"><span class="hljs-number">84</span></span> <span class="hljs-number"><span class="hljs-number">41</span></span> STY $0041 = #$00 $F2D5:A8 TAY $F2D6:<span class="hljs-number"><span class="hljs-number">8</span></span>D D1 <span class="hljs-number"><span class="hljs-number">06</span></span> STA $06D1 = #$06 $F2D9:<span class="hljs-number"><span class="hljs-number">99</span></span> F0 FF STA $FFF0,Y @ $FFF0 = #$00 $F2DC:A4 <span class="hljs-number"><span class="hljs-number">41</span></span> LDY $0041 = #$00 $F2DE:<span class="hljs-number"><span class="hljs-number">60</span></span> RTS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</code> </pre><br>  Let's try to translate line by line: <br><pre> <code class="hljs smalltalk">char switch_bank() //       <span class="hljs-type"><span class="hljs-type">A</span></span> { <span class="hljs-string"><span class="hljs-string">$0</span></span>041 = <span class="hljs-type"><span class="hljs-type">Y</span></span>; //  <span class="hljs-type"><span class="hljs-type">Y</span></span> <span class="hljs-type"><span class="hljs-type">Y</span></span> = <span class="hljs-type"><span class="hljs-type">A</span></span>; <span class="hljs-string"><span class="hljs-string">$0</span></span>6D1 = <span class="hljs-type"><span class="hljs-type">A</span></span>; //     <span class="hljs-symbol"><span class="hljs-symbol">#FFF0</span></span>[<span class="hljs-type"><span class="hljs-type">Y</span></span>] = <span class="hljs-type"><span class="hljs-type">A</span></span>; //       <span class="hljs-string"><span class="hljs-string">$F</span></span>FF0+<span class="hljs-type"><span class="hljs-type">N</span></span>  <span class="hljs-type"><span class="hljs-type">N</span></span> ( <span class="hljs-type"><span class="hljs-type">N</span></span> -   ) <span class="hljs-type"><span class="hljs-type">Y</span></span> = <span class="hljs-string"><span class="hljs-string">$0</span></span>041; //   <span class="hljs-type"><span class="hljs-type">Y</span></span> return <span class="hljs-type"><span class="hljs-type">A</span></span>; }</code> </pre><br><br>  Now let's take the code more complicated: <br><br><pre> <code class="hljs mel">;;         PPU $F302:<span class="hljs-number"><span class="hljs-number">20</span></span> D3 F2 JSR $F2D3 $F305:<span class="hljs-number"><span class="hljs-number">8</span></span>E <span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> STX $2006 = #$41 $F308:A9 <span class="hljs-number"><span class="hljs-number">00</span></span> LDA #$00 $F30A:<span class="hljs-number"><span class="hljs-number">8</span></span>D <span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> STA $2006 = #$41 $F30D:A2 <span class="hljs-number"><span class="hljs-number">10</span></span> LDX #$10 $F30F:A0 <span class="hljs-number"><span class="hljs-number">00</span></span> LDY #$00 $F311:B1 <span class="hljs-number"><span class="hljs-number">17</span></span> LDA ($17),Y @ $020E = #$03 $F313:<span class="hljs-number"><span class="hljs-number">8</span></span>D <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> STA $2007 = #$00 $F316:C8 INY $F317:D0 F8 BNE $F311 $F319:E6 <span class="hljs-number"><span class="hljs-number">18</span></span> INC $0018 = #$02 $F31B:CA DEX $F31C:D0 F1 BNE $F30F $F31E:<span class="hljs-number"><span class="hljs-number">4</span></span>C <span class="hljs-number"><span class="hljs-number">10</span></span> D0 JMP $D010 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</code> </pre><br><br>  The first stage of translation: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">char</span></span> sub_F302() { sub_F2D3(); // switch bank. Bank counter <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> A register // <span class="hljs-meta"><span class="hljs-meta">$2006</span></span> ‚Äì PPU Address register // <span class="hljs-meta"><span class="hljs-meta">$2007</span></span> ‚Äì PPU data <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> //  <span class="hljs-meta"><span class="hljs-meta">$2006</span></span>     // ( ,  ) // <span class="hljs-number"><span class="hljs-number">2007</span></span>       //  PPU.     PPU //    <span class="hljs-number"><span class="hljs-number">1.</span></span> <span class="hljs-meta"><span class="hljs-meta">$2006</span></span> = X; //    <span class="hljs-meta"><span class="hljs-meta">$2006</span></span> = #<span class="hljs-number"><span class="hljs-number">00</span></span> //    X = #<span class="hljs-number"><span class="hljs-number">10</span></span>; label_F30F: Y = #<span class="hljs-number"><span class="hljs-number">00</span></span>; label_F311: //   <span class="hljs-meta"><span class="hljs-meta">$0017</span></span>:<span class="hljs-meta"><span class="hljs-meta">$0018</span></span>   // ,  ,     PPU <span class="hljs-meta"><span class="hljs-meta">$2007</span></span> = <span class="hljs-meta"><span class="hljs-meta">$0017</span></span>[Y]; Y++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Y != #<span class="hljs-number"><span class="hljs-number">00</span></span> ) goto label_F311; <span class="hljs-meta"><span class="hljs-meta">$0018</span></span>++; X<span class="hljs-comment"><span class="hljs-comment">--; if ( X != #00 ) goto label_F30F; return sub_F2D3(#05); //  5-  }</span></span></code> </pre><br><br>  And the last stage of the translation: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteDataIntoPPU</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Bank, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PPULine</span></span></span><span class="hljs-function">)</span></span> { switch_bank(Bank); <span class="hljs-comment"><span class="hljs-comment">// switch bank. PPUADDRESS = PPULine; //    PPUADDRESS = #00; //    for(X = #10; X &gt; 0; X--) { for(Y = #00; Y &lt;= #FF; Y++) { PPUDATA = $Tiles[Y]; } $Tiles += #100; //     } return switch_bank5(); }</span></span></code> </pre><br>  In two simple steps, we rewrote a hard-to-read (for a beginner) assembly listing in clear code.  I did not consider the procedure switch_bank5, there is a banal code for assigning register A to the number # 05, and then calling the bank switching procedure sub_F2D3.  For the development of automatism in translating the code into a readable two or three procedures I have had, then everything becomes much easier.  After I had accumulated about a dozen 5-7 kB of text files, it was simply not necessary to translate the code - everything began to happen by itself in the head. <br><br><h5>  Go to the bouquet and candy period </h5><br>  In the second chapter we will get acquainted with the last two ways and more deeply penetrate the mysterious world of NES.  I want to say that in the end we will be able to find the desired data by combining the first three methods.  The fourth we will reject behind obvious minuses. <br><br>  Assuming the appearance of the questions ‚ÄúWhy did I describe it?‚Äù I will answer right away: when researching any subject, all the methods that <b>can</b> give a result are good.  In our case, this method can be useful as the study of the black box by poking it with needles without getting into the jungle of code: some point will give its result.  This method has obvious advantages of brutfors.  One way or another, we stumble upon something. </div><p>Source: <a href="https://habr.com/ru/post/187876/">https://habr.com/ru/post/187876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../187864/index.html">Scientists are developing a snare robot for firefighters</a></li>
<li><a href="../187866/index.html">How intelligence works (a single algorithm for discernment and generalization)</a></li>
<li><a href="../187868/index.html">IE11 preview for Windows 7, updates for modern.ie, 25% discount for Parallels for Mac</a></li>
<li><a href="../187870/index.html">Google chromecast</a></li>
<li><a href="../187874/index.html">Congratulations on the Day of the system administrator!</a></li>
<li><a href="../187878/index.html">B1 Basis Band: watch-bioregistrar. Gamification of a healthy lifestyle (first review in Russian)</a></li>
<li><a href="../187880/index.html">KINS - new crimeware toolkit</a></li>
<li><a href="../187882/index.html">Algorithm for building cover sets</a></li>
<li><a href="../187886/index.html">Computer vision helps to search for lost dogs.</a></li>
<li><a href="../187888/index.html">Developing a single game - a rewarding experience, some money and a lot of mistakes, P1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>