<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Assembly Architecture Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! My name is Marco Kevac, I'm a Badoo system programmer on the Platform team, and I really love Go. If you add up these two things, then you w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Assembly Architecture Go</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f4a/50e/d6d/f4a50ed6d13e445eaf3d9c55293e7999.jpg" alt="image" align="left">  Hi, Habr!  My name is Marco Kevac, I'm a Badoo system programmer on the <a href="https://habrahabr.ru/company/badoo/blog/317442/">Platform</a> team, and I really love Go.  If you add up these two things, then you will understand how much I love the assembler in Go. <br><br>  More recently, we talked about Habr√© about what conferences we attended.  One of them was <a href="https://gophercon.com/">GopherCon 2016</a> , where almost everyone <a href="https://www.youtube.com/watch%3Fv%3DKINIAgRpkDA">remembered the report of</a> Rob <a href="https://en.wikipedia.org/wiki/Rob_Pike">‚ÄúThe Commander‚Äù</a> Pike about the Go-shny assembler.  I present to you a translation of his report, in the form of an article.  I tried to give in the text as much as possible links to relevant articles on Wikipedia. <br clear="left"><a name="habracut"></a><br><h2>  Assembler?  This is something as ancient as a mammoth! </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/088/e0f/e48/088e0fe48d6fdcadab8802311b06c973.png"><br>  <i><font color="#99999">Rob Pike speaks at GopherCon 2016</font></i> <br><br>  Thank!  This is the most enthusiastic reaction to <a href="https://en.wikipedia.org/wiki/Assembly_language">the assembly language</a> report for many years.  You may ask: why do we even talk about assembly language?  The reason is, but about it later.  You may also ask what interest assembly language may be.  Let's go back to <a href="https://en.wikipedia.org/wiki/Unix_time">1970</a> and take a look at the IBM manual: "The most important thing to understand is the following assembly language feature: it allows the programmer to use all the functions of the <a href="https://en.wikipedia.org/wiki/IBM_System/360">System / 360</a> computer as if he programmed at the System / 360 machine code level." 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In many ways, these words are outdated, but the basic idea is still true: assembler is a way to interact with a computer at its most basic level.  In fact, assembly language is needed even today.  There was a time when only a assembler was available to the programmer. <br><br>  Then came the so-called high-level languages, for example, <a href="https://en.wikipedia.org/wiki/Fortran">Fortran</a> and <a href="https://en.wikipedia.org/wiki/COBOL">Cobol</a> , which slowly but surely supplanted the assembler.  For some time, even the <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C</a> language was considered a high level compared to the assembler.  But the need for an assembler persists today - because of the level of access to the computer that it provides. <br><br>  The assembler is required for the initial loading of the environment, for the work of the <a href="https://en.wikipedia.org/wiki/Call_stack">stacks</a> , for switching the <a href="https://en.wikipedia.org/wiki/Context_switch">context</a> .  In Go, by the way, switching between the gorutins is also <a href="">implemented</a> in assembler.  There is still a performance issue: sometimes you can manually write code that works more efficiently than the result of the compiler.  For example, a substantial part of the <a href="https://github.com/golang/go/tree/0bae74e8c9b5fab3baf61bde0169f4aa5e287bdc/src/math/big">math / big</a> package of the standard Go library is written in assembler, because the basic procedures of this library are much more efficient if you bypass the compiler and implement something better than he would have done.  Sometimes an assembler is needed to work with new and unusual device functions or with features not available for higher-level languages ‚Äã‚Äã‚Äî for example, new cryptographic <a href="https://en.wikipedia.org/wiki/AES_instruction_set">instructions of</a> modern processors. <br><br>  But for me the most important thing in assembly language is that in its terms many people think about computer.  Assembly language gives an idea of ‚Äã‚Äãthe instruction sets, the principles of the computer.  Even if you do not program in assembly language - and I hope that there are no such things here - you should have an idea about assembly language, just to understand how a computer works.  However, I will not pay too much attention to the assembly language itself, and this is in line with the idea of ‚Äã‚Äãmy report. <br><br><h2>  Many different and good assemblers </h2><br>  Many of you are not very familiar with assembly language.  Therefore, I will give a number of examples, trying to adhere to the chronological order. <br><br>  <i>IBM System / 360</i> <br><br><pre><code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">1</span></span>        PRINT NOGEN <span class="hljs-number"><span class="hljs-number">2</span></span> STOCK1 <span class="hljs-keyword"><span class="hljs-keyword">START</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>  BALR  <span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>        <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> *,<span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>        MVC   NEWOH,OLDOH <span class="hljs-number"><span class="hljs-number">6</span></span>        AP    NEWOH,RECPT <span class="hljs-number"><span class="hljs-number">7</span></span>        AP    NEWOH,ISSUE <span class="hljs-number"><span class="hljs-number">8</span></span>        EOJ <span class="hljs-number"><span class="hljs-number">11</span></span> OLDOH DC    PL4<span class="hljs-string"><span class="hljs-string">'9'</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> RECPT DC    PL4<span class="hljs-string"><span class="hljs-string">'4'</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> ISSUE DC    PL4<span class="hljs-string"><span class="hljs-string">'6'</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> NEWOH DS    PL4 <span class="hljs-number"><span class="hljs-number">15</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span></code> </pre> <br>  This is an IBM System / 360 assembler.  It was about this computer was a quote at the beginning.  Do not pay attention to the meaning, just take a look. <br><br>  And this is to show the <i>big picture</i> . <br><br>  <a href="https://en.wikipedia.org/wiki/Apollo_Guidance_Computer"><i>Apollo 11 Guidance Computer</i></a> <br><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> ENTER A JOB REQUEST REQUIRING <span class="hljs-keyword"><span class="hljs-keyword">NO</span></span> VAC AREA:         COUNT     <span class="hljs-number"><span class="hljs-number">02</span></span>/EXEC              NOVAC     INHINT         AD        FAKEPRET     # LOC(MPAC +<span class="hljs-number"><span class="hljs-number">6</span></span>) - LOC(QPRET)         TS        NEWPRIO      # PRIORITY <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NEW</span></span> JOB + NOVAC C(FIXLOC)         EXTEND         <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span>     Q            # Q WILL BE UNDISTURBED THROUGHOUT.         DCA       <span class="hljs-number"><span class="hljs-number">0</span></span>            # <span class="hljs-number"><span class="hljs-number">2</span></span>CADR <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> JOB ENTERED.         DXCH      NEWLOC         CAF       EXECBANK         XCH       FBANK         TS        EXECTEM1         TCF       NOVAC2       # ENTER EXECUTIVE BANK.</code> </pre> <br>  This is the assembler code for the Apollo 11 ship's onboard computer.  All of his programs were written entirely in assembler.  The assembler helped us get to the moon. <br><br>  <a href="https://en.wikipedia.org/wiki/PDP-10"><i>PDP-10</i></a> <br><br><pre> <code class="hljs pgsql">TITLE   COUNT A=<span class="hljs-number"><span class="hljs-number">1</span></span>                             ;Define a <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> an accumulator. <span class="hljs-keyword"><span class="hljs-keyword">START</span></span>:  MOVSI A,<span class="hljs-number"><span class="hljs-number">-100</span></span>            ;initialize <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> counter.                               ;A contains <span class="hljs-number"><span class="hljs-number">-100</span></span>,,<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>:   HRRZM A,<span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(A)        ;Use right half <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.       AOBJN A,<span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>            ;<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">both</span></span> halves (<span class="hljs-number"><span class="hljs-number">-77</span></span>,,<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-76</span></span>,,<span class="hljs-number"><span class="hljs-number">2</span></span> etc.)                               ;Jump <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> still negative.       .<span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span>                  ;Halt program. <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>:  BLOCK <span class="hljs-number"><span class="hljs-number">100</span></span>               ;Assemble space <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> fill up. <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">START</span></span>                       ;<span class="hljs-keyword"><span class="hljs-keyword">End</span></span> the assembly.</code> </pre> <br>  This is an assembler for the PDP-10, and it is commented on in detail when compared with other examples. <br><br>  <a href="https://en.wikipedia.org/wiki/PDP-11"><i>PDP-11</i></a> <br><br><pre> <code class="hljs perl">/ a3 -- pdp-<span class="hljs-number"><span class="hljs-number">11</span></span> assembler pass <span class="hljs-number"><span class="hljs-number">1</span></span> assem:       jsr     pc,readop       jsr     pc,checkeos       br      ealoop       tst     ifflg       beq     <span class="hljs-number"><span class="hljs-number">3</span></span>f       cmp     r4,$20<span class="hljs-number"><span class="hljs-number">0</span></span>       blos    assem       cmpb    (r4),$21   /<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>       bne     <span class="hljs-number"><span class="hljs-number">2</span></span>f       inc     ifflg <span class="hljs-number"><span class="hljs-number">2</span></span>:       cmpb    (r4),$22   /endif       bne     assem       dec     ifflg       br      assem</code> </pre> <br>  This is a fragment for the PDP-11.  Moreover, it is a piece of code for an assembler in Unix v6 - which, of course, is written in assembler.  Language C was used later. <br><br>  <a href="https://en.wikipedia.org/wiki/Motorola_68000"><i>Motorola 68000</i></a> <br><br><pre> <code class="hljs pgsql">strtolower      <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>               link    a6,#<span class="hljs-number"><span class="hljs-number">0</span></span>           ;<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> up stack frame               movea   <span class="hljs-number"><span class="hljs-number">8</span></span>(a6),a0        ;A0 = src, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> stack               movea   <span class="hljs-number"><span class="hljs-number">12</span></span>(a6),a1       ;A1 = dst, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> stack <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>            <span class="hljs-keyword"><span class="hljs-keyword">move</span></span>.b  (a0)+,d0        ;<span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> D0 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (src)               cmpi    #<span class="hljs-string"><span class="hljs-string">'A'</span></span>,d0         ;<span class="hljs-keyword"><span class="hljs-keyword">If</span></span> D0 &lt; <span class="hljs-string"><span class="hljs-string">'A'</span></span>,               blo     <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>            ;skip               cmpi    #<span class="hljs-string"><span class="hljs-string">'Z'</span></span>,d0         ;<span class="hljs-keyword"><span class="hljs-keyword">If</span></span> D0 &gt; <span class="hljs-string"><span class="hljs-string">'Z'</span></span>,               bhi     <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>            ;skip               addi    #<span class="hljs-string"><span class="hljs-string">'a'</span></span>-<span class="hljs-string"><span class="hljs-string">'A'</span></span>,d0     ;D0 = lowercase(D0) <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>            <span class="hljs-keyword"><span class="hljs-keyword">move</span></span>.b  d0,(a1)+        ;Store D0 <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> (dst)               bne     <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>            ;Repeat <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> D0 &lt;&gt; NUL               unlk    a6              ;Restore stack frame               rts                     ;<span class="hljs-keyword"><span class="hljs-keyword">Return</span></span>               <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  <a href="https://en.wikipedia.org/wiki/Cray-1"><i>Cray-1</i></a> <br><br><pre> <code class="hljs pgsql">ident <span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>        V6        <span class="hljs-number"><span class="hljs-number">0</span></span>               ; initialize S        A4        S0              ; initialize *x        A5        S1              ; initialize *y        A3        S2              ; initialize i <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>     S0        A3        JSZ       <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>            ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> S0 == <span class="hljs-number"><span class="hljs-number">0</span></span> goto <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>        VL        A3              ; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> vector length        V11       ,A4,<span class="hljs-number"><span class="hljs-number">1</span></span>           ; <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> x[i], stride <span class="hljs-number"><span class="hljs-number">1</span></span>        V12       ,A5,<span class="hljs-number"><span class="hljs-number">1</span></span>           ; <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> y[i], stride <span class="hljs-number"><span class="hljs-number">1</span></span>        V13       V11 *F V12      ; <span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> x[i] * y[i]        V6        V6 +F V13       ; partial sum        A14       VL              ; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> vector length <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> this iteration        A4        A4 + A14        ; *x = *x + VL        A5        A5 + A14        ; *y = *y + VL        A3        A3 - A14        ; i = i - VL        J        <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span></code> </pre> <br>  This is an assembler for the Motorola 68000, and this is for the Cray-1.  I like this example; it is from Robert Griesemer‚Äôs dissertation.  Reminds how it all began. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d4/474/ba8/5d4474ba8ef74ac8c8a340573d8d7a3a.png"><br>  <i><font color="#99999">Robert Grisemeer speaking at GopherCon 2015</font></i> <br><br>  You may notice that all these are different languages, but in some ways they are similar: they have a common, very clear, structure. <br><br>  <i>Instructions</i> <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">subroutine</span></span> header label:   instruction operand...    ; <span class="hljs-attribute"><span class="hljs-attribute">comment</span></span>   ...</code> </pre> <br>  <i>Operands</i> <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">literal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constant</span></span> address <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> indirection (<span class="hljs-keyword"><span class="hljs-keyword">register</span></span> as address) ...</code> </pre> <br>  Programs in assembly language are usually written in a column: on the left ‚Äî labels, then instructions, operands, and finally, on the right ‚Äî comments.  Operands are usually registers, constants, or memory addresses, but syntactically for different architectures they are quite similar.  There are exceptions.  The Cray example stands out against the general background: the addition command is written as a + symbol, as in an arithmetic expression.  But the meaning is the same everywhere: this is the addition command, and this is the registers.  That is, all this is in reality the same thing. <br><br>  In other words, even a long time ago, even in my times, the processors were about the same as now.  There are counterexamples, but most of the processors (and certainly all the processors on which Go works), in fact, remained the same, if not to pay attention to details.  If you do not go into details, you can come to an interesting conclusion: for all these computers, you can make a general grammar.  To understand this fact, it took about 30 years. <br><br><h2>  Ken's ingenious idea </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/ced/28f/063/ced28f063ce9d0b09ecbf6eb36ab1df9.png"><br>  <i><font color="#99999">From left to right: Robert Griseseer, Rob Pike, Ken Thompson</font></i> <br><br>  Around the mid-1980s, Ken Thompson and I began to think about the development, which later became <a href="https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs">Plan 9</a> .  Ken wrote a new C compiler, which formed the basis of the C compiler in the Go tools and was used until recently.  It was on a computer with a symmetric multiprocessor architecture of the company Sequent, which used the processors <a href="https://en.wikipedia.org/wiki/NS320xx">National 32000</a> .  In my opinion, this was the first 32-bit microprocessor, available commercially in the form of an integrated circuit.  But Ken did one interesting thing - some did not understand it then, but then it turned out to be very important.  This is generally a feature of Ken. <br><br>  The compiler did not generate machine instructions - it gave out something like pseudo-code.  And then the second program (in fact, the <a href="https://en.wikipedia.org/wiki/Linker_(computing)">linker</a> ) accepted the result of the compiler and converted these pseudoinstructions into real instructions. <br><br>  Instructions like <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">MOVW</span></span>    <span class="hljs-variable"><span class="hljs-variable">$0</span></span>, var</code> </pre> <br>  could become just <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">XORW</span></span>    <span class="hljs-type"><span class="hljs-type">R1</span></span>, <span class="hljs-type"><span class="hljs-type">R1</span></span> <span class="hljs-type"><span class="hljs-type">STORE</span></span>   <span class="hljs-type"><span class="hljs-type">R1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span></code> </pre> <br>  I will give an abstract example.  There is, for example, the MOVW instruction, which places a zero in a variable.  The code issued by the linker, which will be executed on the computer, may consist, for example, of XORW instructions, for which both operands are given the same register (that is, it resets the register value), and STORE, which places the value of this register in the variable .  Do not worry about the details: the point here is that the instructions that the computer performs may not quite correspond to what we are entering into the assembler. <br><br>  This process of drawing up real instructions based on pseudoinstructions we call the choice of instructions.  A great example of pseudoinstructions is the return instruction from a function that Ken called RET.  It has been called that for 30 years, but its implementation depends on the computer on which it runs.  In the manuals for some computers it is called RET, but in others it can be a switch to the address that is contained in the register, or a redirect to the address in a special register, or something completely different. <br><br>  Therefore, an assembler can be considered a way of recording the pseudoinstructions that the compiler generates.  In the Plan 9 world, unlike most other architectures, the compiler does not start the assembler ‚Äî the data is transferred directly to the linker. <br><br><img src="https://habrastorage.org/files/db9/9b1/928/db99b1928f554b429f7a0f5a0a27d965.png"><br><br>  As a result, the process looks something like this.  The top line roughly corresponds to traditional architectures.  In my opinion, GCC works the same today.  This is a compiler, it takes high-level code and converts it into assembly language code.  The assembler generates real instructions, and the linker links the individual parts, creating a binary.  The bottom two lines show the situation in Plan 9. Here the assembler, in fact, was divided in half: one half remained in the compiler, and the second became part of the linker.  The arrows crossing the red line are flows of pseudoinstructions in binary representation.  The assembler in Plan 9 serves one purpose: it provides you with the ability to write textual instructions that translate into pseudoinstructions that the linker processes. <br><br><h2>  Assembler go </h2><br>  This situation persisted for many generations.  And the Plan 9 assemblers corresponded to it: they were separate C programs with <a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a> grammar, their own for each architecture.  They formed a kind of set or package, but they were separate, independently written programs.  They had a common code, but not quite ... In general, everything was difficult.  And then Go started appearing ... when it was ... in 2007 we started ... Go compilers were added to this heap of programs with funny names - 8g and 6g.  And they used the same model.  They correspond to the middle line in the diagram.  And the way this division was implemented gave many advantages for the Go internal device, but today I don‚Äôt have time to tell about it in detail. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/232/a31/3fe/232a313fe95a2758588480f685e04a9e.png"><br>  <i><font color="#99999">Russ Cox speaks at GopherCon 2015</font></i> <br><br>  In Go 1.3, we wanted to get rid of all the C code and implement everything exclusively on Go.  It would take time.  But in the release of Go 1.3, we launched this process.  It all started with the fact that Russ ( <a href="https://swtch.com/~rsc/">Russ Cox</a> ) took a large piece of linker and separated it.  This is how the liblink library appeared, and most of it was occupied by the so-called instruction selection algorithm.  Now this library is called <a href="https://github.com/golang/go/tree/master/src/cmd/internal/obj">obj</a> , but then it was called liblink.  The compiler used this liblink library to convert pseudoinstructions into these instructions.  There were several arguments in favor of such a decision. <br><br>  The most important of these is speeding up the build process.  Even in spite of the fact that the compiler is now doing more work - now he chooses instructions, whereas the linker used to do this.  Thanks to this device, he does this only once for each library.  Previously, if you needed to package the fmt package, for example, the choice of instructions for <a href="">Printf</a> would be performed again each time.  Obviously this is stupid.  Now we do it once, and the linker doesn't have to do it.  As a result, the compiler runs slower, but the build generally speeds up.  The assembler can be arranged in the same way and can use the obj library. <br><br>  The most important feature of this stage was that nothing had changed for the user: the input language remained the same, the output remained the same, it is all the same binary file, only the details are different.  Here is the general scheme of the old architecture, I have already shown it: a compiler, an assembler, a linker.  In the Plan 9 world, the linker is controlled by a compiler or an assembler. <br><br>  <b>Old architecture:</b> <br><br><img src="https://habrastorage.org/files/e93/5b7/3a5/e935b73a5b78410c86a0ce26dd5a6510.png"><br><br>  <b>New architecture:</b> <br><br><img src="https://habrastorage.org/files/60c/6bc/e59/60c6bce59ed840ad81837f6eb637e731.png"><br><br>  In version 1.3, we switched to such a device.  As you can see, now we have a much more traditional linker: it receives real instructions, because the obj library, which performs the selection of instructions, has ceased to be part of the linker and has become the last stage of the compiler and assembler.  That is, now the assembler and the compiler are more consistent with the old scheme, if you include the assembler in the process. <br><br>  This new assembler Go is a weird thing.  Nothing like this just exists.  What is he doing?  It converts textual descriptions of pseudoinstructions into real instructions for the linker.  In 1.5 we made a big step - we got rid of C. For this we did a lot of preparatory work in 1.3 and 1.4, and now this problem is finally solved.  Russ wrote a translator that converted the old Go source code for compilers (and, by the way, linkers) written in C into Go programs. <br><br>  The old liblink library was built into the library set, which together we call obj.  As a result, there is a thing called obj, this is a portable part, and subdirectories with machine-dependent parts that store information about the features of each architecture.  Several papers are devoted to this work: this is an interesting story in itself.  Two years ago, Russ spoke at <a href="https://gophercon.com/">GopherCon</a> with a report, but it is already quite outdated.  In fact, we did not do what he said then.  And then at GopherFest 2015 I presented a more general, but more accurate overview of the changes in version 1.5. <br><br><pre> <code class="hljs go">GOOS=darwin GOARCH=arm <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool compile prog.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span></code> </pre> <br>  So here.  Previously, compilers were called 6g, 8g and other strange names.  Now this is one program called compile.  You run the compile tool and set it up by setting the values ‚Äã‚Äãof the standard GOOS environment variables (pronounced "goose" as "goose") and GOARCH (pronounced "gorch", like "drunken lustful guy in a bar") - that is how they are officially pronounced.  We did the same for the linker.  There is a link tool, you set the values ‚Äã‚Äãof GOOS and GOARCH - and you can compile your program.  You may ask yourself: ‚ÄúHow can a single compiler support all of these architectures?  We know that cross-platform compilation is very, very difficult. ‚Äù  Not really.  You just need to prepare everything in advance.  Note the following: here there is only one input language - Go.  From the point of view of the compiler, the result of the work is also the same - pseudoinstructions in binary form, which are transferred to the library obj.  That is, we only need to set up the obj library by setting the values ‚Äã‚Äãof the variables at the time the tool is launched.  Soon you will learn how to do it. <br><br>  As for the assembler, we performed machine translation of assemblers from C to Go, but this is not an ideal solution, I did not like it.  I offered to write on Go from scratch the only program that would replace them all - asm.  The setup would again be done exclusively through GOOS and GOARCH.  You may notice that assembly language and Go are not the same thing.  Each processor has its own set of instructions, its own set of registers, it is not a single output language.  What to do with it?  But in fact, they are essentially the same.  See it. <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> add <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b }</code> </pre> <br>  Here is an example of a simple program that adds two integers and returns the sum.  I will not show the pseudoinstructions issued by the compiler if you use the -S flag to view the assembler code.  I also removed a lot of unnecessary - if you use this method, you will also see a lot of unnecessary, but at this stage the compiler produces exactly such pseudoinstructions. <br><br>  <i>32-bit x86 (386)</i> <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">TEXT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(SB), <span class="hljs-meta"><span class="hljs-meta">$0</span></span><span class="hljs-number"><span class="hljs-number">-12</span></span>   MOVL    a+<span class="hljs-number"><span class="hljs-number">4</span></span>(FP), BX   ADDL    b+<span class="hljs-number"><span class="hljs-number">8</span></span>(FP), BX   MOVL    BX, <span class="hljs-number"><span class="hljs-number">12</span></span>(FP)   RET</code> </pre><br>  <i>64-bit x86 (amd64)</i> <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">TEXT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(SB), <span class="hljs-meta"><span class="hljs-meta">$0</span></span><span class="hljs-number"><span class="hljs-number">-24</span></span>   MOVQ    b+<span class="hljs-number"><span class="hljs-number">16</span></span>(FP), AX   MOVQ    a+<span class="hljs-number"><span class="hljs-number">8</span></span>(FP), CX   ADDQ    CX, AX   MOVQ    AX, <span class="hljs-number"><span class="hljs-number">24</span></span>(FP)   RET</code> </pre><br>  <i>32-bit arm</i> <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">TEXT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(SB), $<span class="hljs-number"><span class="hljs-number">-4</span></span><span class="hljs-number"><span class="hljs-number">-12</span></span>   MOVW    a(FP), R0   MOVW    b+<span class="hljs-number"><span class="hljs-number">4</span></span>(FP), R1   <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span>     R1, R0   MOVW    R0, <span class="hljs-number"><span class="hljs-number">8</span></span>(FP)   RET</code> </pre><br>  <i>64-bit arm (arm64)</i> <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">TEXT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(SB), $<span class="hljs-number"><span class="hljs-number">-8</span></span><span class="hljs-number"><span class="hljs-number">-24</span></span>   MOVD    a(FP), R0   MOVD    b+<span class="hljs-number"><span class="hljs-number">8</span></span>(FP), R1   <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span>     R1, R0   MOVD    R0, <span class="hljs-number"><span class="hljs-number">16</span></span>(FP)   RET</code> </pre><br>  <i>S390 (s390x)</i> <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">TEXT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(SB), <span class="hljs-meta"><span class="hljs-meta">$0</span></span><span class="hljs-number"><span class="hljs-number">-24</span></span>   MOVD    a(FP), R1   MOVD    b+<span class="hljs-number"><span class="hljs-number">8</span></span>(FP), R2   <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span>     R2, R1, R1   MOVD    R1, <span class="hljs-number"><span class="hljs-number">16</span></span>(FP)   RET</code> </pre> <br>  Here is an option for a 32-bit architecture.  Do not think about the details - just look at the <i>whole picture</i> .  Here is the result for the x86 64-bit architecture, it is also called <a href="https://en.wikipedia.org/wiki/X86-64">AMD64</a> , for the 32-bit <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM architecture</a> , for the 64-bit ARM architecture, and here for the IBM System / 390 architecture;  for us they are new, but for everyone else, clearly not. <br><br>  <i>64-bit MIPS (mips64)</i> <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">TEXT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(SB), $<span class="hljs-number"><span class="hljs-number">-8</span></span><span class="hljs-number"><span class="hljs-number">-24</span></span>   MOVV    a(FP), R1   MOVV    b+<span class="hljs-number"><span class="hljs-number">8</span></span>(FP), R2   ADDVU   R2, R1   MOVV    R1, <span class="hljs-number"><span class="hljs-number">16</span></span>(FP)   RET</code> </pre><br>  <i>64-bit Power (ppc64le)</i> <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">TEXT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(SB), <span class="hljs-meta"><span class="hljs-meta">$0</span></span><span class="hljs-number"><span class="hljs-number">-24</span></span>   MOVD    a(FP), R2   MOVD    b+<span class="hljs-number"><span class="hljs-number">8</span></span>(FP), R3   <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span>     R3, R2   MOVD    R2, <span class="hljs-number"><span class="hljs-number">16</span></span>(FP)   RET</code> </pre> <br>  Here is the code for the 64-bit <a href="https://en.wikipedia.org/wiki/MIPS_Technologies">MIPS architecture</a> , here is the 64-bit <a href="https://en.wikipedia.org/wiki/Power_Architecture">POWER</a> architecture.  You may notice that they are similar.  The reason is that they are essentially the same language.  Partly because they are so arranged: in fact, we have used the National 32000 assembler for 30 years, changing only the iron on which it was used.  But also because some of them are really identical.  These are just instructions, registers, operands, constant values, labels ‚Äî all the same.  The only important difference is that the instructions and registers have different names.  Offsets also sometimes differ, but it depends on the size of the machine word. <br><br>  It all comes down to National 32000 assembler, which Ken wrote.  This is the National 32000 assembly language, as Ken describes it, adapted for the modern PowerPC.  Thus, we have everything we need - a common input language, the obj library in the backend - and we can write in assembler.  With this approach, a problem arises: if you take the leadership of a National or PowerPC and look at assembly language, it turns out that it looks wrong.  It has a different syntax, sometimes other instruction names, because at some level these are actually pseudoinstructions.  In fact, it does not matter. <br><br>  For an uninitiated person, the appearance of the Go assembler ‚Äî all those capital letters and strange things ‚Äî can seriously confuse.  But since we have a common assembly language for all these computers, we can get a remarkable result, which will be discussed below.  Therefore, we believe that this is a justified compromise and it is not very difficult to achieve it.  It is necessary to learn how to program on 68000 and Ken assembly language - and you can automatically write programs for PowerPC.  What's the difference? <br><br>  How does this work?  Assembler version 1.5, I think is an ideal assembler.  Give him any computer - and he broadcasts an assembler for him.  This is a new program written entirely on Go.  It has common lexical and syntactic analyzers that simply accept your input code, everything you give it, and convert the instructions into data structures that describe the instructions in binary form, and then transfer the result to the new library obj, which contains information about specific platforms . <br><br>  Most of the code that underlies the assembler is fully portable, it contains nothing, no interesting information about the architectures, but there is a table with information about the names of the registers.  There are still a few things that are related to the operation of the operands, but there it is quite simple.  And all this is configured when you start the program in accordance with the value of the variable GOARCH.  GOOS is used in very, very rare cases in which we will not go deep - the main characteristics are determined by GOARCH.  There is also an internal package for the assembler, which is called arch, it creates these tables on the fly, dynamically retrieving them from the obj library.  And here is a fragment of this code. <br><br><pre> <code class="hljs lisp">import (   <span class="hljs-string"><span class="hljs-string">"cmd/internal/obj"</span></span>   <span class="hljs-string"><span class="hljs-string">"cmd/internal/obj/x86"</span></span> ) func archX86(<span class="hljs-name"><span class="hljs-name">linkArch</span></span> *obj.LinkArch) *Arch {   register <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> make(<span class="hljs-name"><span class="hljs-name">map</span></span>[string]int16)   // Create maps for easy lookup of instruction names etc.   for i, s <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> range x86.Register {       register[s] = int16(<span class="hljs-name"><span class="hljs-name">i</span></span> + x86.REG_AL)   }   instructions <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> make(<span class="hljs-name"><span class="hljs-name">map</span></span>[string]obj.As)   for i, s <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> range obj.Anames {       instructions[s] = x86.As(<span class="hljs-name"><span class="hljs-name">i</span></span>)   }   return <span class="hljs-symbol"><span class="hljs-symbol">&amp;Arch</span></span>{       Instructions:   instructions,       Register:       register,       ...   } }</code> </pre> <br>  It is a bit simplified, but the essence conveys.  This is an arch, internal assembler package.  This is the procedure that configures the entire assembler for the x86 architecture.  This code is used in both 32- and 64-bit architecture, they are identical from this point of view.  And then we just start the loop ... A loop that goes through the register names from the obj library defined in the x86 package for the obj procedures.  And we just set up a map that matches the names of the registers and the binary code according to the data from obj.  And then do the same for instructions. <br><br>  These codes are not actually instruction codes; you will not find them in the manual.  This is literally an alphabetical list of all things - I repeat that these are just pseudoinstructions, and not real commands.  But now we know all the names of all the registers and all the instructions.  And the description of the architecture, which we will return, contains only these two maps.  Here are the names of the instructions that you know, here are the names of the registers that you know, and a few more things that I did not mention, but everything is pretty simple.  This is all the necessary information to convert the assembly language into instructions for these computers.   ,     ,    .    1,   ,  ,     .  It is quite simple. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">ADDW</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">AX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">BX</span></span> &amp;<span class="hljs-selector-tag"><span class="hljs-selector-tag">obj</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Prog</span></span>{   <span class="hljs-attribute"><span class="hljs-attribute">As</span></span>: arch.Instructions[<span class="hljs-string"><span class="hljs-string">"ADDW"</span></span>],   From: obj.Addr{Reg: arch.Register[<span class="hljs-string"><span class="hljs-string">"AX"</span></span>]},   <span class="hljs-selector-tag"><span class="hljs-selector-tag">To</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">obj</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Addr</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">Reg</span></span>: arch.Register[<span class="hljs-string"><span class="hljs-string">"BX"</span></span>]},   ... }</code> </pre> <br>  .   ¬´ ¬ª (ADDW)   386,            .   : ADDW AX, BX.  ,      . ,   , ‚Äî     ,      ,    ADDW   .        A ‚Äî  ,    .     ,  .    ‚Äî   AX,   BX.   ,   ,   :    ,    ,         obj.   ,     . ,   , ‚Äî  .         . <br><br>     , ,      .      .    , , ,     ‚Ä¶        ,         ,    ,      .  It's not a problem. <br>    ,       obj.    :  ,   ,    obj,      ,   ,   obj ,        .    ,   obj  ,   .   . <br><br> , , ,  ,       .    . ,     ,     ,     ‚Ä¶      obj  ,   ,             .       ,       ,   ,     .      .   ,      ,     . ,  -,  .  A/B- ‚Äî     .    . <br><br>      386,  ‚Äì  AMD64.       ,     .   ,     PowerPC,           ‚Äì    .   ,   ,       ,                   .           ,        obj,       . <br><br> -,   .  ,          Go,         Yacc.     ,  .        .    Go,      ,  .    ,    ,      ,   .  ,     .      ,       .               .     .          .     . <br><br>  , ,  ,    ,       ,         open-source-.      Git    ,     ,  ,   ,     ,    .  It's great. -,      .   ,    open-source-   . <br><br>   ,    ,  , ,   obj    .    ?       .   ,   , ‚Ä¶  ‚Äî     ,     pprof,     ‚Äî -,  , ,   ,   ,     .    ,      PDF      ,     .     ,    , ‚Äî      ?       .        ,    .        .   ,   . <br><br>   ‚Äî  ,      .          .     .     .  ,       ,    .   ,         PDF     ,     ‚Äì     .    . <br>  ,     ,     ,   ,     . <br><br><h2>  Conclusion </h2><br>     .      ,   ,    .        ,      .           ,         ,              .       ,          ,     .       ,       .   ‚Äî ,   .   ‚Äî ,     ‚Äî        .  ,    ,       ,      . <br><br>     Go.  Thank. </div><p>Source: <a href="https://habr.com/ru/post/317864/">https://habr.com/ru/post/317864/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317852/index.html">How to congratulate customers happy New Year?</a></li>
<li><a href="../317854/index.html">Activity modeling and mythological consciousness</a></li>
<li><a href="../317856/index.html">Cosmos Calling: Need a specialist mathematician in the field of numerical solution of stochastic differential equations</a></li>
<li><a href="../317858/index.html">Use oEmbed to add a phone to the habrapost</a></li>
<li><a href="../317860/index.html">Cooking ORM, without departing from the plate</a></li>
<li><a href="../317866/index.html">How to keep logs of data changes by users in the database, storing them in another database</a></li>
<li><a href="../317868/index.html">The digest of interesting materials for the mobile # 184 developer (December 12-18)</a></li>
<li><a href="../317870/index.html">CRM pumped for sales</a></li>
<li><a href="../317872/index.html">Does your code speak Russian?</a></li>
<li><a href="../317874/index.html">Storage System for Billions of Records with Key Access</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>