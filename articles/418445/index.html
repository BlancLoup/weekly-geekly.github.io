<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Django Channels - the answer to the modern web</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the world of Django, the addition of Django Channels is gaining popularity. This library should bring asynchronous network programming to Django th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Django Channels - the answer to the modern web</h1><div class="post__text post__text-html js-mediator-article">  In the world of Django, the addition of Django Channels is gaining popularity.  This library should bring asynchronous network programming to Django that we have been waiting for.  <strong>Artyom Malyshev</strong> at Moscow Python Conf 2017 explained how the first version of the library does it (now the author has already written down channels2), why does it do it and whether it does at all. <br><br>  First of all, Zen Python says that any solution should be the only one.  Therefore, <strong>in Python, at least three</strong> .  Network asynchronous frameworks already exist in large numbers: <br><br><ul><li>  Twisted; <br></li><li>  Eventlet; <br></li><li>  Gevent; <br></li><li>  Tornado; <br></li><li>  Asyncio. <br></li></ul><br>  It would seem, why write another library and whether it is necessary at all. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/ij0PiSlYBu0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong><em>About speaker:</em></strong> Artyom Malyshev is an independent Python developer.  Engaged in the development of distributed systems, speaks at conferences on Python.  Artyom can be found on the nickname @ PROOFIT404 on Github and on social networks. <br><a name="habracut"></a><br>  <strong>Django is synchronous by definition</strong> .  If we are talking about ORM, then synchronously refer to the database during attribute access, when we write, for example, post.author.username, it does not cost anything. <br><br>  In addition, Django is a WSGI framework. <br><br><h2>  WSGI <br></h2><br>  WSGI is a synchronous interface for working with web servers. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(environ, callback)</span></span></span><span class="hljs-function"> :</span></span> status, headers = <span class="hljs-string"><span class="hljs-string">'200 OK'</span></span>, [] callback (status, headers) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'Hello world!\n'</span></span>]</code> </pre> <br>  Its main feature is that we have a function that takes an argument and immediately returns a value.  This is all that a web server can expect from us.  <strong>No asynchronous and does not smell</strong> . <br><br>  This was done a long time ago, back in 2003, when the web was simple, users read all kinds of news on the Internet, went to guest books.  It was enough just to accept the request and process it.  Give an answer and forget that this user was at all. <br><img src="https://habrastorage.org/webt/-a/3e/ly/-a3elynsjri1d0qbc73yl256qbo.jpeg"><br><br>  But, for a moment, now is not 2003, so users want much more from us. <br><img src="https://habrastorage.org/webt/-j/fp/nz/-jfpnzpcfn0w2hpbvmcejswxnaw.jpeg"><br>  They want a rich web application, live content, they want the application to work great on the desktop, on the laptop, on other tops, on the clock.  Most importantly, <strong>users do not want to press F5</strong> , because, for example, there is no such button on tablets. <br><br><img src="https://habrastorage.org/webt/bq/gi/ql/bqgiql6zzob87g74yngfmwvkehs.jpeg"><br><br>  Web browsers, of course, meet us - they add new protocols and new features.  If you and I were developing only the frontend, then we would simply take the browser as a platform and use its core features, since it is ready to provide them to us. <br><br>  <strong>But, for backend programmers, everything has changed a lot</strong> .  Web sockets, HTTP2, and the like are a huge pain in terms of architecture, because they are long-lived connections with their own states that need to be processed. <br><img src="https://habrastorage.org/webt/g1/pn/gi/g1pngi6z8op3aesfec2rtiodv4q.jpeg"><br><br>  This is the problem that Django Channels for Django is trying to solve.  This library is designed to give you the ability to handle connections, leaving the Django Core, to which we are accustomed, absolutely unchanged. <br><br>  This was done by a wonderful man, <a href="https://github.com/andrewgodwin"><strong>Andrew Godwin</strong></a> , who has a terrible English accent that speaks very quickly.  You should know him for things like the long-forgotten Django South and Django Migrations, which came to us from version 1.7.  Since he repaired the migration for Django, he has been busy repairing web sockets and HTTP2. <br><br>  How did he do it?  Once upon a time, the following image went on the Internet: empty squares, arrows, the inscription ‚ÄúGood architecture‚Äù - you enter your favorite technologies into these small squares, you get a site that scales well. <br><br><img src="https://habrastorage.org/webt/r1/rz/z9/r1rzz99ck74ggy5uy8vnn7kebks.jpeg"><br><br>  Andrew Godwin wrote a server on these squares that stands in the front and accepts any requests, be they asynchronous, synchronous, e-mail, whatever.  Between them is the so-called Channel Layer, which stores received messages in a format that is accessible to a pool of synchronous workers.  As soon as an asynchronous connection sent us something, we record it in the Channel Layer, and then the synchronous worker can take it from there and process it in the same way as any Django View or anything else, synchronously.  As soon as the synchronous code sent the response back to the Channel Layer, the asynchronous server will send it, stream it, do everything it needs.  Thus, an abstraction is made. <br><br>  This implies several implementations, and in production it is proposed to use <strong>Twisted, as an asynchronous server</strong> that implements the frontend for Django, and <strong>Redis</strong> , which will be the very channel of communication between synchronous Django and asynchronous Twisted. <br><br><blockquote>  The good news is that in order to use Django Channels, you don‚Äôt need to know either Twisted or Redis at all - these are all the implementation details.  Your DevOps will know this, or you will meet when you repair production at three o'clock in the morning. </blockquote><br><h2>  ASGI </h2><br>  Abstraction is a protocol called ASGI.  This is a standard interface that lies between any network interface, server, be it a synchronous or asynchronous protocol, and your application.  Its main concept is the channel. <br><br><h3>  Channel </h3><br>  A channel is an ordered first-in-first-out queue of messages that have a lifetime.  These messages can be delivered zero or one time, and can only be received by one Consumer. <br><br><h3>  Consumers </h3><br>  In Consumer, you are just writing your code. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_message</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function"> :</span></span> message.reply_channel.send ( { <span class="hljs-string"><span class="hljs-string">'text'</span></span>: message.content [<span class="hljs-string"><span class="hljs-string">'text'</span></span>], } )</code> </pre><br>  A function that accepts a message may send several answers, or may not send the answer at all.  Very similar to view, the only difference is that there is no return function, thus we can talk about how many answers we return from the function. <br><br>  We add this function to routing, for example, we hang it to receive a message on a web socket. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.routing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myapp.consumers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ws_message channel_routing = [ route (<span class="hljs-string"><span class="hljs-string">'websocket.receive'</span></span> ws_message), }</code> </pre><br>  We register it in Django settings, as well as register the database. <br><br><pre> <code class="python hljs">CHANNEL_LAYERS = { <span class="hljs-string"><span class="hljs-string">'default'</span></span>: { <span class="hljs-string"><span class="hljs-string">'BACKEND'</span></span>: <span class="hljs-string"><span class="hljs-string">'asgiref.inmemory'</span></span>, <span class="hljs-string"><span class="hljs-string">'ROUTING'</span></span>: <span class="hljs-string"><span class="hljs-string">'myproject.routing'</span></span>, }, }</code> </pre><br>  There can be several Channel Layers in a project, just as there can be several databases.  This thing is very similar to db router, if someone used it. <br><br>  Next, we define our ASGI application.  It synchronizes how Twisted starts and how synchronized workers are started ‚Äî they all need this application. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.asgi <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> get_channel_layer os.environ.setdefault( <span class="hljs-string"><span class="hljs-string">'DJANGO_SETTINGS_MODULE'</span></span>, <span class="hljs-string"><span class="hljs-string">'myproject.settings'</span></span>, ) channel_layer = get_channel_layer()</code> </pre><br>  After that, the code is deployed: we launch gunicorn, standardly send an HTTP request, synchronously, with the view, as we are used to.  We start the asynchronous server, which will stand in front of our synchronous Django, and the workers who will process the messages. <br><br><pre> <code class="python hljs">$ gunicorn myproject.wsgi $ daphne myproject.asgi:channel_layer $ django-admin runworker</code> </pre><br><h3>  Reply channel </h3><br>  As we have seen, message has such a thing as the Reply channel.  Why do you need it? <br><br>  hannel unidirectional, respectively WebSocket receive, WebSocket connect, WebSocket disconnect is a common channel to the system for input messages.  And the Reply channel is a channel that is strictly tied to the user's connection.  Accordingly, message has an input and output channel.  This pair allows you to identify from whom you received this message. <br><img src="https://habrastorage.org/webt/rp/_k/wm/rp_kwmeuccjs2bunsar-hoei9au.jpeg"><br><br><h3>  Groups </h3><br>  A group is a set of channels.  If we send a message to a group, it is automatically sent to all channels of this group.  This is convenient because nobody likes to write for loops.  Plus, the implementation of groups is usually done using the native functions of the Channel layer, so it works faster than just sending messages one by one. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Group <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_connect</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> Group (<span class="hljs-string"><span class="hljs-string">'chat'</span></span>).add (message.reply_channel) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_disconnect</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> Group (<span class="hljs-string"><span class="hljs-string">'chat'</span></span>).discard(message.reply_channel) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_message</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> Group (<span class="hljs-string"><span class="hljs-string">'chat'</span></span>). Send ({ <span class="hljs-string"><span class="hljs-string">'text'</span></span>: message.content [<span class="hljs-string"><span class="hljs-string">'text'</span></span>], })</code> </pre><br>  Groups are also added to routing. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.routing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> myapp.consumers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * channel_routing = [ route (<span class="hljs-string"><span class="hljs-string">'websocket.connect'</span></span> , ws_connect), route (<span class="hljs-string"><span class="hljs-string">'websocket.disconnect'</span></span> , ws_disconnect), route (<span class="hljs-string"><span class="hljs-string">'websocket.receive'</span></span> , ws_message), ]</code> </pre><br>  And as soon as the channel is added to the group, reply will go to all users who have connected to our site, and not just the echo-answer to ourselves. <br><br><h3>  Generic consumers </h3><br>  What I love Django for is declarative.  Similarly, there are declarative Consumers. <br><br>  Base Consumer is basic, it can only map the channel that you have defined to your own method and call it. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.generic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BaseConsumer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComsumer</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseConsumer)</span></span></span><span class="hljs-class"> :</span></span> method_mapping = { <span class="hljs-string"><span class="hljs-string">'channel.name.here'</span></span>: <span class="hljs-string"><span class="hljs-string">'method_name'</span></span>, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method_name</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, message, **kwargs)</span></span></span><span class="hljs-function"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  There are a large number of predefined consumers with deliberately augmented behavior, such as WebSocket Consumer, which determines in advance that it will handle WebSocket connect, WebSocket receive, WebSocket disconnect.  You can immediately specify which groups to add the reply channel to, and as soon as you use self.send it will understand, send it to a group or to a single user. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.generic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WebsocketConsumer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyConsumer</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(WebsocketConsumer)</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_groups</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'chat'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, message)</span></span></span><span class="hljs-function"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text=None, bytes=None)</span></span></span><span class="hljs-function"> :</span></span> self.send (text=text, bytes=bytes)</code> </pre><br>  There is also a version of WebSocket Consumer with JSON, that is, not text, not bytes, but already parsed JSON will come to receive - this is convenient. <br><br>  It is added to routing in the same way via route_class.  In route_class, myapp is taken, which is determined from the consumer, from there all channels are taken and all channels specified in myapp are routed.  Write in such a way less. <br><br><h2>  Routing </h2><br>  Let's talk in detail about routing and what it provides us. <br><br>  First, these are filters. <br><br><pre> <code class="python hljs">// app.js S = new WebSocket (<span class="hljs-string"><span class="hljs-string">'ws://localhost:8000/chat/'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># routing.py route('websocket.connect', ws_connect, path=r'^/chat/$')</span></span></code> </pre><br>  This may be the path that came to us from the URI of the web socket connection, or the http request method.  This can be any message field from a channel, for example, for an e-mail: text, body, carbon copy, whatever.  The number of keyword arguments for a route is arbitrary. <br><br>  Routing allows you to do nested routes.  If several consumers are determined by some common characteristics, it is convenient to group them and add everyone to the route at once. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route, include blog_routes = [ route ( <span class="hljs-string"><span class="hljs-string">'websocket.connect'</span></span>, blog, path = <span class="hljs-string"><span class="hljs-string">r'^/stream/'</span></span>) , ] routing = [ include (blog_routes, path= <span class="hljs-string"><span class="hljs-string">r'^/blog'</span></span> ), ]</code> </pre><br><h2>  Multiplexing </h2><br>  If we open several web sockets, each has a different URI, and we can hang several handlers on them.  But let's be honest, open a few connections just to make something beautiful on the back end, unlike an engineering approach. <br><br>  Therefore, it is possible to call several handlers via a single web socket.  We define such a WebsocketDemultiplexer, which operates with the notion of stream within a single web socket.  Through this stream, it will redirect your message to another channel. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WebsocketDemultiplexer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demultiplexer</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(WebsocketDemultiplexer)</span></span></span><span class="hljs-class"> :</span></span> mapping = { <span class="hljs-string"><span class="hljs-string">'intval'</span></span>: <span class="hljs-string"><span class="hljs-string">'binding.intval'</span></span>, }</code> </pre><br>  The routing multiplexer is added in the same way as in any other declarative consumer route_class. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> route_class, route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> .consumers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Demultiplexer, ws_message channel_routing = [ route_class (Demultiplexer, path=<span class="hljs-string"><span class="hljs-string">'^/binding/'</span></span>) , route (<span class="hljs-string"><span class="hljs-string">'binding.intval'</span></span>, ws_message ) , ]</code> </pre><br>  The stream argument is added to the message so that the multiplexer can figure out where to put the given message.  The payload argument contains everything that goes to the channel after the multiplexer processes it. <br><br>  It is very important to note that in the Channel Layer, the message will fall <strong>twice</strong> : before the multiplexer and after the multiplexer.  Thus, as soon as you start using a multiplexer, you automatically add latency to your queries. <br><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"stream"</span></span> : <span class="hljs-string"><span class="hljs-string">"intval"</span></span>, <span class="hljs-string"><span class="hljs-string">"payload"</span></span> : { ‚Ä¶ } }</code> </pre><br><h2>  Sessions </h2><br>  Each channel has its own sessions.  This is a very handy thing, for example, to keep state between calls to handlers.  You can group them by the reply channel, since this is an identifier that belongs to the user.  The session is stored in the same engine, which stores the usual http session.  For obvious reasons, the signed cookie is not supported, they are simply not in the web socket. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.sessions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> channel_session @channel_session <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function"> :</span></span> room=message.content [<span class="hljs-string"><span class="hljs-string">'path'</span></span>] message.channel_session [<span class="hljs-string"><span class="hljs-string">'room'</span></span>] = room Croup (<span class="hljs-string"><span class="hljs-string">'chat-%s'</span></span> % room).add ( message.reply_channel )</code> </pre><br>  During the connection, you can get http session and use it in your consumer.  As part of the negotiation process, setting up a web socket connection is sent to the user's cookies.  Accordingly, therefore, you can get a user session, get a user object that you used to use in Django before, just as if you were working with a view. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.sessions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> http_session_user @http_session_user <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ws_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function"> :</span></span> message.http_session [<span class="hljs-string"><span class="hljs-string">'room'</span></span>] = room <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> message.user.username : ‚Ä¶</code> </pre><br><h2>  Message order </h2><br>  Channels allows you to solve a very important problem.  If we establish a connection with a web socket and immediately send it, then this leads to the fact that two events ‚Äî WebSocket connect and WebSocket receive ‚Äî are very close in time.  It is very likely that consumer for these web sockets will run in parallel.  Debugging it will be very fun. <br><br>  Django channels allows you to enter two types of lock: <br><br><ol><li>  <strong>Easy</strong> <strong>lock</strong> .  With the help of the session mechanism, we guarantee that until the consumer receives the message, we will not process any message on the web sockets.  After the connection is established, the order is arbitrary, perhaps parallel execution. </li><li>  <strong>Hard</strong> <strong>lock</strong> - only one consumer of a specific user is executed at a time.  This is an overhead of synchronization, since the slow session engine is used.  Nevertheless, there is such an opportunity. </li></ol><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> channels.generic <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WebsocketConsumer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyConsumer</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(WebsocketConsumer)</span></span></span><span class="hljs-class"> :</span></span> http_user = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> slight_ordering = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> strict_ordering = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_groups</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, **kwargs)</span></span></span><span class="hljs-function"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'chat'</span></span>]</code> </pre><br>  In order to write this, there are the same decorators that we saw earlier in the http session, channel session.  In declarative consumer you can just write attributes, as soon as you write them, it will automatically apply to all methods of this consumer. <br><br><h2>  Data binding </h2><br>  In due time Meteor became famous for Data binding. <br><br>  Open two browsers, go to the same page, and in one of them click on the scroll bar.  At the same time, in the second browser, on this page, the scroll bar changes its value.  That's cool. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntegerValueBinding</span></span></span><span class="hljs-class"> </span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(WebsocketBinding)</span></span></span><span class="hljs-class"> :</span></span> model = IntegerValue stream = intval<span class="hljs-string"><span class="hljs-string">' fields= ['</span></span>name<span class="hljs-string"><span class="hljs-string">', '</span></span>value<span class="hljs-string"><span class="hljs-string">'] def group_names (self, instance, action ) : return ['</span></span>intval-updates<span class="hljs-string"><span class="hljs-string">'] def has_permission (self, user, action, pk) : return True</span></span></code> </pre><br>  Django can now do the same. <br><br>  This is implemented using hooks provided by <strong>Django Signals</strong> .  If binding is defined for a model, all connections that are in a group for this instance model will be notified of each event.  They created a model, changed the model, deleted it - it will all be in the alert.  The notification occurs on the specified fields: the value of this field has changed - a payload is formed, sent via a web socket.  It's comfortable. <br><br>  It is important to understand that if in our example we constantly click the scroll bar, then messages will always go on and the model will be saved.  This will work up to a certain load, then everything will rest on the base. <br><br><h2>  Redis layer </h2><br>  Let's talk a little more about how the most popular Channel Layer for production - Redis. <br><br>  It is arranged well: <br><br><ul><li>  works with synchronous connections at the level of workers; </li><li>  very friendly to Twisted, does not slow down, where it is particularly necessary, that is, on your front-line server; </li><li>  MSGPACK is used to serialize messages within Redis, which allows you to reduce the footprint on each message; </li><li>  you can distribute the load across multiple instances of Redis; it will automatically be shaded by using a consistent hash algorithm.  Thus, the single point of failure disappears. </li></ul><br>  The channel is simply a list of id from Redis.  By id is the value of a particular message.  This is done so that you can control the life of each message and channel separately.  In principle, this is logical. <br><br><pre> <code class="python hljs">&gt;&gt; SET <span class="hljs-string"><span class="hljs-string">"b6dc0dfce"</span></span> <span class="hljs-string"><span class="hljs-string">" \x81\xa4text\xachello"</span></span> &gt;&gt; RPUSH <span class="hljs-string"><span class="hljs-string">"websocket.send!sGOpfny"</span></span> <span class="hljs-string"><span class="hljs-string">"b6dc0dfce"</span></span> &gt;&gt; EXPIRE <span class="hljs-string"><span class="hljs-string">"b6dc0dfce"</span></span> <span class="hljs-string"><span class="hljs-string">"60"</span></span> &gt;&gt; EXPIRE <span class="hljs-string"><span class="hljs-string">"websocket.send!sGOpfny"</span></span> <span class="hljs-string"><span class="hljs-string">"61"</span></span></code> </pre><br>  Groups are implemented by sorted sets.  Distribution to groups is performed inside the Lua-script - it is very fast. <br><br><pre> <code class="python hljs">&gt;&gt; type group:chat zset &gt;&gt; ZRANGE group:chat <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> WITHSCORES <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"websocket.send!sGOpfny"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"1476199781.8159261"</span></span></code> </pre><br><h2>  Problems </h2><br>  Let's see what problems this approach has. <br><br><h3>  Callback hell </h3><br>  The first problem is the newly invented callback hell.  It is very important to understand that most of the problems with the channels that you encounter will be in style: arguments came to the consumer that he did not expect.  Where they came from, who put them in Redis is all a dubious task to investigate.  Debugging of distributed systems in general for the strong in spirit.  AsyncIO solves this problem. <br><br><h3>  Celery </h3><br>  On the Internet, they write that Django Channels is a replacement for Celery. <br><img src="https://habrastorage.org/webt/x9/be/j8/x9bej8oul6vevk2r8e12q9-i_ia.jpeg"><br>  I have bad news for you - no, it is not. <br><br>  In channels: <br><br><ul><li>  no retry, you can not delay the execution of handler; <br></li><li>  No canvas - just callback.  Celery provides the groups, the chain, my favorite chord, which, after parallel execution of the groups, causes another callback with synchronization.  None of this is in the channels; </li><li>  there is no job for the arrival time of messages, some systems without this are simply impossible to design. </li></ul><br><blockquote>  I see the future as official support for using channels and celery together, with minimal cost, with minimal effort.  But Django Channels is not a Celery replacement. <br></blockquote><br><h2>  Django for modern web </h2><br>  Django Channels is the Django for the modern web.  This is the same Django that we all used to use: synchronous, declarative, with a large number of batteries.  Django Channels is just one battery plus.  You should always understand where to use it and whether to do it.  If the Django project is not needed, then the Channels are not needed there.  They are only useful in projects where Django is justified. <br><br><blockquote>  <strong><a href="https://conf.python.ru/">Moscow Python Conf ++</a></strong> <br><br>  A professional conference for Python developers comes to a new level - <strong>on October 22 and 23,</strong> 2018 we will gather 600 best Python programmers in Russia, present the most interesting reports and, of course, create an environment for networking in the best traditions of the Moscow Python community with the support of the Ontico team. <br><br>  We invite experts to make a presentation.  The program committee is already up and running until September 7th. <br><br>  For participants, an online brainstorming program is conducted.  In this <a href="https://docs.google.com/document/d/1gMGasJQ2hHOHXa3mWlF74cFMUwJtGG8CX8_PdZez090/edit">document,</a> you can make the missing topics or just the speakers, whose performances are interesting to you.  The document will be updated, in fact, you will be able to follow the program formation all the time. <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/418445/">https://habr.com/ru/post/418445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418433/index.html">August 4th. Peter. First cycle quest for programmers</a></li>
<li><a href="../418435/index.html">"Yandex" again indexed documents Google Docs</a></li>
<li><a href="../418439/index.html">The Basics of Progressive Web Applications</a></li>
<li><a href="../418441/index.html">Basics of privilege escalation in Windows</a></li>
<li><a href="../418443/index.html">GObject: encapsulation, instantiation, introspection</a></li>
<li><a href="../418447/index.html">Why Moscow Python Conf is now ++</a></li>
<li><a href="../418449/index.html">Binary modules for Python</a></li>
<li><a href="../418451/index.html">3D printing lessons. Effective support and changing the height of the layers in practice from the company 3Dtool</a></li>
<li><a href="../418453/index.html">GRAVITY observations further confirm the general theory of relativity.</a></li>
<li><a href="../418455/index.html">Open webinar "Specialist" at the helm ": first experience and mistakes"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>