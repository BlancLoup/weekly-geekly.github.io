<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to keep logs of data changes by users in the database, storing them in another database</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dear readers. This is the second article in the database cycle. I decided to make some table of contents on the planned articles of this cycle: 



1....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to keep logs of data changes by users in the database, storing them in another database</h1><div class="post__text post__text-html js-mediator-article">  Dear readers.  This is the second article in the database cycle.  I decided to make some table of contents on the planned articles of this cycle: <br><br><ol><li>  <a href="https://habrahabr.ru/post/317680/">How to make a different time zone in different databases on the same server.</a> </li><li>  <i>How to keep logs of data changes by users in the database, storing them in another database, so that the main database is not clogged with garbage and does not grow.</i> </li><li>  <a href="https://habrahabr.ru/post/319418/">How to create your file system based on blob fields in the database.</a>  <a href="https://habrahabr.ru/post/319418/">Why is it convenient?</a>  <a href="https://habrahabr.ru/post/319418/">Issues of file storage efficiency: how to get the maximum speed and at the same time the minimum space occupied.</a> </li></ol><br>  I was surprised by the number of comments on the first article, so I immediately want to note that I do not pretend to the only correct way of implementation.  I am sure that creative people will find many more ways to accomplish this task.  But implementing it in due time, I did not find a single article describing such a functional, and I had to do this task from scratch, although in my opinion it is relevant.  The implementation, which I will describe, is completely working and is used by me in practice. <br><br>  I also welcome <u>constructive</u> criticism.  Sometimes people write interesting things and you can look at the problem from an angle that you didn‚Äôt intend to and somehow improve your mechanisms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, let's begin. <br><br>  Firebird database 3. <br><br>  The wording of the task is as follows: <b>it is necessary to write detailed logs of data changes by users in the database (insert, update, delete), but at the same time write them in another database on another server.</b>  <b>This is necessary so that the size of the main database does not grow by leaps and bounds, it was convenient to backup, restore it so that it works quickly, does not accumulate debris, and does not contain unnecessary and rare information.</b> <br><a name="habracut"></a><br>  This mechanism was developed for a cloud-based enterprise automation platform ( <a href="https://erp-platforma.com/%3Fi%3D2">https://erp-platforma.com</a> ), but for the first time I encountered this problem while working in the billing department, in a telecom company.  There was a billing database (let's call it the Primary Database), with which all the systems worked, and a database for the clients ‚Äôpersonal account (let's call it DB LK), which also had to contain most of the data from the main database.  This was done because it was once dumb for everyone that the ‚Äúoutside‚Äù LC looks into the company's main database, for there is little ... <br><br>  In order for the data from the main database to go to the database database (and in some cases, the database replication mechanism was implemented from the database database server to the primary database), the insert, update and delete triggers were made, which wrote all the changes to an ‚Äúintermediate‚Äù table, with a certain periodicity, the external script unloaded new records from this table into the textbooks, these textbooks were thrown onto the server from the DB LK and were executed there in that database.  Everything seems to be quite good, BUT, the base has grown by leaps and bounds, reaching in a few months GIANT sizes due to this table, where all the logs merged.  The obsolete data remained in it, and not immediately removed from it, because deletion is a long process and contributes to the accumulation of garbage and just the database will work more slowly with time.  So decided the developers.  As a result, it came to the point that every 3 months, you had to delete this data, and to do a backup-restore of the database, because the place on the server just ended.  Backup-restore of such volumes and on such a server is almost a day for all the work.  This is every 3 months stop on the day of the entire company.  And it had to do.  Help desk made notes at this time on a piece of paper ... <br><br>  Developing my cloud platform, in view of experience, I was already aware of this issue and decided to make a system for recording detailed logs devoid of these flaws.  Especially considering the volumes, what can be on one server is not one database, but 1000, and doing this thousand backup restore is unreal. <br><br>  First I want to describe the general concept. <br><br>  To structure record keeping, they are conducted in a batch manner. <br>  There are two tables, a table with information on the package and a table with the data of this package.  Let's call them LOG_PACKET and LOG <br><br>  LOG_PACKET <br><br><ol><li>  Unique identificator </li><li>  Record date </li><li>  Written by (user id) </li><li>  Symptom processing (0 or 1) </li><li>  Record type (ins, up, del) </li><li>  Table number (name of the table from which we write logs) </li><li>  Data table number </li><li>  Package Record ID </li><li>  The number of processing attempts </li><li>  Last processing date </li></ol><br>  LOG <br><br><ol><li>  Unique identificator </li><li>  Blob field for OLD data </li><li>  Blob field for data NEW </li><li>  Package Record ID </li><li>  Table field number (table field name) </li></ol><br>  In a trigger when data is changed, an entry must be filled in the LOG_PACKET with information about what this record and data (before and after the change) in the LOG table <br><br>  Then, an external script, launched with a certain periodicity, finds unprocessed records in LOG_PACKET, and makes a copy of them to the log database on another server, using their identifiers, finds all their records in the LOG table and also makes a copy. <br><br>  Next, we need to get rid of garbage in the main database.  Delete data from LOG - slow down the database and save trash.  There is a faster and better DROP TABLE procedure. <br><br>  <i><b>PS:</b> Why DROP is preferable DELETE I will not describe in detail.</i>  <i>Everything is very well described in <a href="http://www.ibase.ru/delmany/">this article</a></i> . <br><br>  Therefore, the following solution applies. <br><br>  LOG tables are 3 pieces.  LOG_1 - on the first day, data is written here, LOG_2 - on the next day, data is written here, etc.  alternation occurs, one day in LOG_1 second day in LOG_2.  When data is written to LOG_2 and all packets referring to LOG_1 are processed, DROP LOG_1 and CREATE TABLE LOG_1 occur.  Thus, at the moment all records are deleted and the table becomes clean.  The next day, similarly with LOG_2. <br><br>  But not so simple.  Since  Links to LOG_1 and LOG_2 are registered in the triggers of all logged tables - they will not be able to be deleted.  For this you need to use a trick.  Make them VIEW.  And register the addition of data in the triggers through this VIEW. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> V_LOG_1( <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.id, p.blob_old, p.blob_new, p.packet, p.num_pole <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> LOG_1 p;</code> </pre> <br>  But even so, deleting a table with a trigger does not work because VIEW in a trigger will refer to it. <br><br>  To do this, you need to make a table LOG_3, which will be a copy of the LOG_1 and LOG_2 structure.  We replace in VIEW LOG_1 with LOG_3 and vaul, you can delete and re-create the table LOG_1.  After that we change in VIEW back LOG_3 to LOG_1 - and everything works on. <br><br>  This operation can be carried out without problems, in the table LOG_1 at this moment is guaranteed there will be no recording, because  On this day, recording is made in LOG_2.  Such a cleaning operation always happens with a table on which there is no record on this day.  The next day, the same operation will occur with the LOG_2 table. <br><br>  Also, this operation should occur only if all the data in the LOG_PACKET on this table is processed.  If they are not processed, then you cannot touch the table, because it will be data loss.  You must first understand why the data is not processed, for example, a script may hang which transfers them to the database with logs.  If a cleaning operation has been canceled on a given day, then the next attempt will be performed every other day, etc. <br><br>  The concept we have disassembled, now we will analyze the optimal scheme of work. <br><br>  First, you need to enter a table with information about which table we are writing today.  This should be a table with a single record (in this case, data retrieval is a fast operation), no indexes.  It should contain the day number, the date of the update, and whether logging is allowed at all (the administrator should be able to disable logging altogether to save space, if he does not need them at all) <br><br>  for example <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> LOG_INFO ( ZAPIS <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">DATA</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>, ID_TABLE <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span> );</code> </pre> <br>  In all the triggers of the logged tables, it is first checked whether the entry is allowed. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.zapis <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> LOG_INFO p <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>: zapis;</code> </pre> <br>  If it is enabled, then it is checked in which table to write data <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">first</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> p.data=<span class="hljs-keyword"><span class="hljs-keyword">current_date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> p.id_table <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> p.id_table=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> p.id_table=<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> p.data=<span class="hljs-keyword"><span class="hljs-keyword">current_date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> LOG_INFO p <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>: log_info, log_info_check;</code> </pre> <br>  <i><b>PS:</b> for skeptics, first 1 is needed in order to eliminate the possibility of trigger flushing if more than one record appears in the LOG_INFO table suddenly.</i>  <i>In this case, there will be an error in writing data to all logged tables (usually an error of multiple rows).</i>  <i>And first 1 we are guaranteed to exclude this option.</i> <br><br>  With this request we: <br><br>  1) We check if the date coincides with the current one, if yes, then write to the current table, if not, then change the table to another one (there was a day transition to the next one); <br>  2) Put a sign that this table should be updated to another one when the day passes. <br><br>  The next step is if we need an update when we go over the day, update <br><br><pre> <code class="sql hljs">if (log_info_check=-1) then <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> LOG_INFO <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ID_TABLE = :log_info, <span class="hljs-keyword"><span class="hljs-keyword">DATA</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">current_date</span></span>;</code> </pre> <br>  Those.  The first entry on the next day updates the data, what to write in the following table.  And then resources are no longer being spent on this. <br><br>  Next, write the data in LOG_PACKET and get its ID <br><br><pre> <code class="sql hljs">if (inserting) then TYPE_=1; if (updating) then TYPE_=2; if (deleting) then TYPE_=3; if (TYPE_ in (1,2)) then <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> LOG_PACKET (TYPE_, TABLE_, NUM_TABLE, AVTOR, ID_ZAPISI) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (:TYPE_, <span class="hljs-number"><span class="hljs-number">15</span></span>, :log_info, new.avtor, new.id) <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>: id_packet; else <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> LOG_PACKET (TYPE_, TABLE_, NUM_TABLE, AVTOR, ID_ZAPISI) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (:TYPE_, <span class="hljs-number"><span class="hljs-number">15</span></span>, :log_info, old.avtor, old.id) <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>: id_packet;</code> </pre> <br>  Further, depending on the received table number, the data should be written in V_LOG_1 or V_LOG_2. <br><br>  For example, the entry might look like this: <br><br><pre> <code class="sql hljs">if (log_info=1) then <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TYPE_=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, new.n_687, :id_packet, <span class="hljs-number"><span class="hljs-number">687</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, new.n_688, :id_packet, <span class="hljs-number"><span class="hljs-number">688</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, new.n_689, :id_packet, <span class="hljs-number"><span class="hljs-number">689</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, new.n_690, :id_packet, <span class="hljs-number"><span class="hljs-number">690</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, new.n_691, :id_packet, <span class="hljs-number"><span class="hljs-number">691</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TYPE_=<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new.n_687&lt;&gt;old.n_687) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (old.n_687, new.n_687, :id_packet, <span class="hljs-number"><span class="hljs-number">687</span></span>); if (new.n_688&lt;&gt;old.n_688) then <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (old.n_688, new.n_688, :id_packet, <span class="hljs-number"><span class="hljs-number">688</span></span>); if (new.n_689&lt;&gt;old.n_689) then <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (old.n_689, new.n_689, :id_packet, <span class="hljs-number"><span class="hljs-number">689</span></span>); if (new.n_690&lt;&gt;old.n_690) then <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (old.n_690, new.n_690, :id_packet, <span class="hljs-number"><span class="hljs-number">690</span></span>); if (new.n_691&lt;&gt;old.n_691) then <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (old.n_691, new.n_691, :id_packet, <span class="hljs-number"><span class="hljs-number">691</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TYPE_=<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (old.n_687, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, :id_packet, <span class="hljs-number"><span class="hljs-number">687</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (old.n_688, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, :id_packet, <span class="hljs-number"><span class="hljs-number">688</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (old.n_689, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, :id_packet, <span class="hljs-number"><span class="hljs-number">689</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (old.n_690, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, :id_packet, <span class="hljs-number"><span class="hljs-number">690</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> V_LOG_1 (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (old.n_691, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, :id_packet, <span class="hljs-number"><span class="hljs-number">691</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  <i><b>PS:</b> I have simplified my life a little by the fact that I have my own built-in programming language in the system and all the tables and fields I have come with numbers, not text.</i>  <i>Also thanks to this, such triggers are created absolutely automatically when a new table appears or are re-created when its fields change.</i>  <i>Those.</i>  <i>it is enough for the user to click the button ‚ÄúTurn on logs‚Äù in the interface in the table editor and everything will happen automatically to him.</i>  <i>Everything will be more complicated for readers, if this database is simple, then such a trigger will have to be created manually and the data types in NUM_POLE and NUM_TABLE should be textual, i.e.</i>  <i>There it is necessary to write down the names of tables and fields.</i>  <i>Or enter a kind of table, where the tables and fields will be assigned numbers and take data from it.</i> <br><br>  Next, you need to create a table with the flag, whether the record occurred.  So we will save system resources, for making a query on a table with one field is much faster than going through LOG_PACKET in search of whether there are flags of new records. <br><br>  For example: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> LOG_PACKET_FLAG (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>);</code> </pre> <br>  And put on the LOG_PACET table in the trigger when adding a new package entry <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> LOG_PACKET_FLAG <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  When you run the script for transferring data to the database of logs, you need to check whether there are new entries (if they are not there, do nothing more). <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">first</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> p.id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> LOG_PACKET_FLAG p</code> </pre> <br>  This will work much faster than, for example: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> LOG_PACKET p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.check_=<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  At the end of the transfer of records, it is necessary to check whether there are new records while we were transferring those that were and do: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> LOG_PACKET_FLAG <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  In general, save the resources of your systems. <br><br>  Next, consider the process of transferring the records. <br><br>  First, we receive all new LOG_PACKET records from our main database, and in the loop we do INSERT of this data into the logging database. <br><br>  After creating a packet record in the logging database, we need to transfer the data of this packet from the LOG_1 (2) tables. <br><br>  Extracting data from blob fields and adding them to another place is a certain crap and dances with a tambourine.  After many experiments, I came to the conclusion that the easiest and most efficient way is to simply run a query from a script in which a query will be sent to the database (in general, to drag the blob of a field by a direct query from the logging database to the main database. <br><br>  The procedure of packet data, which should be pulled by the script, after adding the package. <br><br><pre> <code class="sql hljs">reate or <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> BLOB_INS ( SELECT_ <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">250</span></span>), BASE_ <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), USER_ <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">50</span></span>), PASS_ <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">50</span></span>), PACKET <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span> BLOB_OLD <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span> SUB_TYPE <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SEGMENT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SIZE</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span> BLOB_NEW <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span> SUB_TYPE <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SEGMENT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SIZE</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span> PACKET <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span> NUM_POLE <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATEMENT</span></span> (:select_) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> :base_ <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USER</span></span> :user_ <span class="hljs-keyword"><span class="hljs-keyword">PASSWORD</span></span> :pass_ <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> :BLOB_OLD,:BLOB_NEW,:NUM_POLE <span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOG</span></span> (BLOB_OLD, BLOB_NEW, PACKET, NUM_POLE) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (:BLOB_OLD,:BLOB_NEW, :pacet, :NUM_POLE); <span class="hljs-keyword"><span class="hljs-keyword">End</span></span></code> </pre> <br>  : select should be supplied approximately of this type from the script: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.blob_old, p.blob_new, p.num_pole <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> log_<span class="hljs-string"><span class="hljs-string">'.&lt; &gt;.'</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.packet=<span class="hljs-string"><span class="hljs-string">'.&lt; &gt;</span></span></code> </pre> <br>  After successful processing of the package, it is necessary to set the flag in the main database that this package is processed. <br><br>  In case of errors of adding data to the package, I update the data on the number of attempts, after 5 attempts a flag is set that the data was processed with an error and the program stops trying to process it.  If you do not make this mechanism, then you can go into an infinite loop in the event of some kind of error and the program will cease to perform its functions.  You can deal with erroneous packages later, but the program should continue to work. <br><br>  Just a small message: make a separate virtual machine for the logging database.  You can allocate this machine less cores and memory.  You can also allocate a worse disk system to it, there is no need to keep logs on the SSD, for example, as the main bases with which the main work is carried out. <br><br>  There is no increased demand for speed, because  This is a pending operation.  It does not matter to us that the logs are recorded in a minute or 1.5 minutes, the main thing is that they will be recorded.  Users access this data very rarely, only in case of any problems, and it's okay if the page with logs will load for 200 ms longer. <br><br>  In general, with this you will simply save resources; it is better to allocate these resources to loaded machines. </div><p>Source: <a href="https://habr.com/ru/post/317866/">https://habr.com/ru/post/317866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317854/index.html">Activity modeling and mythological consciousness</a></li>
<li><a href="../317856/index.html">Cosmos Calling: Need a specialist mathematician in the field of numerical solution of stochastic differential equations</a></li>
<li><a href="../317858/index.html">Use oEmbed to add a phone to the habrapost</a></li>
<li><a href="../317860/index.html">Cooking ORM, without departing from the plate</a></li>
<li><a href="../317864/index.html">Assembly Architecture Go</a></li>
<li><a href="../317868/index.html">The digest of interesting materials for the mobile # 184 developer (December 12-18)</a></li>
<li><a href="../317870/index.html">CRM pumped for sales</a></li>
<li><a href="../317872/index.html">Does your code speak Russian?</a></li>
<li><a href="../317874/index.html">Storage System for Billions of Records with Key Access</a></li>
<li><a href="../317876/index.html">FPGA Debug Board - Frankenstein. Sounds and music</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>