<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization of LIKE expression when using Sqlite in iOS application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I was faced with the task of optimizing a query to Sqlite in my iOS application. 
 The task was as follows. There was a list of documents (P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization of LIKE expression when using Sqlite in iOS application</h1><div class="post__text post__text-html js-mediator-article">  Recently, I was faced with the task of optimizing a query to Sqlite in my iOS application. <br>  The task was as follows.  There was a list of documents (PDF files), a dictionary (a list of words), and a link between documents and words from a dictionary (the entry of words into a document).  It was necessary to implement a search and display a list of documents in which there is an entered word. <br><br>  The structure of the base was as follows: <br><a name="habracut"></a><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">document</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, root_id <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Varchar</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), active Tinyint ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> IDX_documentId <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">document</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> IDX_documentName <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">document</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dictionary ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, word <span class="hljs-built_in"><span class="hljs-built_in">Varchar</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> IDX_dictionaryId <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dictionary (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> IDX_dictionaryWord <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dictionary (word <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> document_index ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> AUTOINCREMENT <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, document_id <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, word_id <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>(document_id) <span class="hljs-keyword"><span class="hljs-keyword">REFERENCES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">document</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>(word_id) <span class="hljs-keyword"><span class="hljs-keyword">REFERENCES</span></span> dictionary(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> IDX_documentIndexId <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> document_index (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> IDX_documentIndexDocId <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> document_index (document_id); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> IDX_documentIndexWordId <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> document_index (word_id);</code> </pre> <br>  A query to retrieve all documents in selected sections that have the specified word: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> document.id, document.name <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">document</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> document_index <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> document_index.document_id=document.id <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> dictionary <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> dictionary.id=document_index.word_id <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> dictionary.word <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> @pQuery <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> document.active = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> document.root_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (@pRoot1, @pRoot2, @pRoot3, @pRoot4, @pRoot5, @pRoot6, @pRoot7) <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">First</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">Count</span></span></code> </pre><br>  With the size of dicrionary ~ = 400K, document ~ = 1K and document_index ~ = 500K entries, the query ran for about 30 seconds on my iPad 2, which was unacceptable for my application. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the process of finding a solution to speed up the execution of the query, I found out that in Sqlite3, when using the LIKE expression, the index is not taken into account, which was not at all good, considering my number of entries.  I couldn‚Äôt refuse to use LIKE and replace it with a comparison operation with equality, since  I needed to search by substring.  Then I came across this <a href="http://joshua.perina.com/africa/gambia/fajara/post/converting-to-sqlite-and-like-query-optimization">article</a> , it was proposed to replace the expression LIKE with the operation&gt; = and &lt;+ characters yaz (zzz if the word is in English) in the second expression. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> dictionary.word LIKE '%' <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> dictionary.word &gt;= '' AND dictionary.word &lt; ''</code> </pre><br><br>  With this optimization, the index is taken into account when searching, and all the words starting with 'abakan' are found.  The execution time is only 0.5 seconds!  Of course there are limitations, it is impossible to implement a search for a substring from the beginning of the string, i.e.  I found words starting with any characters and ending in 'abakan', but in my particular case it was not necessary. </div><p>Source: <a href="https://habr.com/ru/post/165663/">https://habr.com/ru/post/165663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../165647/index.html">Sharing service of screenshots and code</a></li>
<li><a href="../165649/index.html">Javascript: from beginning to end</a></li>
<li><a href="../165657/index.html">The new Samsung refrigerator offers recipes based on its contents.</a></li>
<li><a href="../165659/index.html">Procrastination New tasks. Part 2</a></li>
<li><a href="../165661/index.html">Quipu is an esoteric programming language based on the Incas nodular script</a></li>
<li><a href="../165667/index.html">Little Brave Arkanoid (Part 1 - IwGl)</a></li>
<li><a href="../165669/index.html">Simulate dark-eye adaptation in 3D, or HDR for dummies</a></li>
<li><a href="../165671/index.html">Mass publication of online journal articles in memory of Aaron Schwarz</a></li>
<li><a href="../165675/index.html">Results 24pullrequests</a></li>
<li><a href="../165677/index.html">ViBe - background subtraction algorithm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>