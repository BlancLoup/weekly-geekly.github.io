<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pattern matching, changes and movements in Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the main goals of the Rust project is secure system programming. This area usually implies an imperative paradigm, which means the presence of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pattern matching, changes and movements in Rust</h1><div class="post__text post__text-html js-mediator-article"><p>  One of the main goals of the Rust project is secure system programming.  This area usually implies an imperative paradigm, which means the presence of side effects, the need to think about the shared state, etc.  In order to ensure security under such conditions, the programs and data types on Rust must be structured in such a way that they can be statically checked.  The elements and limitations of the Rust language together make it easier to write programs that pass these checks and thus provide security.  For example, the concept <em>of data ownership is</em> deeply integrated into Rust. </p><br><br><p> The <code>match</code> expression is a special construct in which these features and limitations are combined in an interesting way.  <code>match</code> expression takes an input value, classifies it, and then passes execution to the code that processes the corresponding data class. </p><br><br><p>  In this article we will look at how <code>match</code> works in Rust.  Here are the main elements that <code>match</code> and its complement, <code>enum</code> , combine into one: </p><br><ul><li>  Structural pattern matching: option analysis and usability are much better than using <code>switch</code> in C or Java. </li><li>  Exhaustive analysis: <code>match</code> ensures that no options are omitted. </li><li>  <code>match</code> supports both imperative and functional styles: you can continue to use the <code>break</code> statement, assignment, and so on, and you absolutely do not need to relearn the style based on expressions; </li><li>  <code>match</code> can both ‚Äúborrow‚Äù and ‚Äúmove‚Äù: Rust encourages the programmer to think about owning and borrowing data.  The <code>match</code> expression is designed including the possibility of only <em>borrowing a</em> part of the structure instead of <em>moving it</em> .  This is necessary in order not to transfer ownership of any data earlier than necessary. </li></ul><br><p>  We will look at each of these points separately below, but first we need to lay the foundation for further discussion - how does a <code>match</code> look and work? </p><br><a name="habracut"></a><br><h2>  <code>match</code> basics </h2><br><p>  The <code>match</code> expression in Rust looks like this: </p>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> INPUT_EXPRESSION { PATTERNS_1 =&gt; RESULT_EXPRESSION_1, PATTERNS_2 =&gt; RESULT_EXPRESSION_2, ... PATTERNS_n =&gt; RESULT_EXPRESSION_n }</code> </pre><br><p>  where each of the <code>PATTERNS_i</code> contains at least one <em>sample</em> ( <em>pattern</em> , <em>pattern</em> - pattern).  The sample describes a subset of all possible values ‚Äã‚Äãinto which the expression <code>INPUT_EXPRESSION</code> can be calculated.  The <code>PATTERN =&gt; RESULT_EXPRESSION</code> is called a ‚Äúbranch‚Äù, or simply ‚Äúbranch‚Äù (‚Äúarm‚Äù). </p><br><br><p>  Patterns can correspond to simple values, such as numbers or symbols;  they may also correspond to special character data defined by the user with the help of <code>enum</code> . </p><br><br><p>  The code below generates a guess (bad) in the number guessing game based on the previous answer: </p><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Answer</span></span></span></span> { Higher, Lower, Bingo, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suggest_guess</span></span></span></span>(prior_guess: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, answer: Answer) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> answer { Answer::Higher =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"maybe try {} next"</span></span>, prior_guess + <span class="hljs-number"><span class="hljs-number">10</span></span>), Answer::Lower =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"maybe try {} next"</span></span>, prior_guess - <span class="hljs-number"><span class="hljs-number">1</span></span>), Answer::Bingo =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"we won with {}!"</span></span>, prior_guess), } } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">demo_suggest_guess</span></span></span></span>() { suggest_guess(<span class="hljs-number"><span class="hljs-number">10</span></span>, Answer::Higher); suggest_guess(<span class="hljs-number"><span class="hljs-number">20</span></span>, Answer::Lower); suggest_guess(<span class="hljs-number"><span class="hljs-number">19</span></span>, Answer::Bingo); }</code> </pre><br><p>  (Almost all the code in this article is directly executed - you can copy pieces of code into the <code>demo.rs</code> file, compile it with the argument - <code>--test</code> , run the resulting executable file, and observe the test results.) </p><br><br><p>  Patterns can also be matched with <a href="http://en.wikipedia.org/wiki/Record_%2528computer_science%2529">structured data</a> (i.e., tuples, slices, user-defined data types).  In such templates, parts of the input piece of data are usually bound to individual local variables, which can then be used to calculate the result. </p><br><br><p>  The special pattern <code>_</code> matches any value and is often used for the default branch;  special pattern <code>..</code> summarizes <code>_</code> behavior for mapping to a <em>sequence of</em> values ‚Äã‚Äãor key-value pairs. </p><br><br><p>  In addition, several templates can be used in one branch, combining them through a vertical line.  In this case, this branch will be executed if the data is suitable for any of the combined templates. </p><br><br><p>  All of the above can be seen in the updated version of the strategy for generating answers in the "guessing": </p><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GuessState</span></span></span></span> { guess: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, answer: Answer, low: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, high: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suggest_guess_smarter</span></span></span></span>(s: GuessState) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> s { <span class="hljs-comment"><span class="hljs-comment">//      `answer`,  `Bingo`, //        `p`. GuessState { answer: Answer::Bingo, guess: p, .. } =&gt; { // ~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~ ~~ // | | | | // | | |    // | | | // | |    `guess` // | |    `p` // | | // | ,   `answer`  `Bingo` // | //   `s`   `GuessState` println!("we won with {}!", p); } //   ,      //     . //        (l..h), : // -    ,     , //        `l`,    //    ---  `h`; // -    ,     , //     `h`   ,  `l` --- //      . GuessState { answer: Answer::Higher, low: _, guess: l, high: h } | GuessState { answer: Answer::Lower, low: l, guess: h, high: _ } =&gt; { // ~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~ ~~~~~~ ~~~~~~~~ ~~~~~~~ // | | | | | // | | | |   // | | | |  // | | | |  `high`, // | | | |    // | | | |  // | | | | // | | |   `guess` // | | |    `l` // | | |  `h`,   // | | |   // | | | // | |     `low`, // | |     // | | // | ,   `answer`  // | `Higher`  `Lower`,   // |   // | //   `s`   `GuessState` let mid = l + ((h - l) / 2); println!("lets try {} next", mid); } } } #[test] fn demo_guess_state() { suggest_guess_smarter(GuessState { guess: 20, answer: Answer::Lower, low: 10, high: 1000 }); }</span></span></code> </pre><br><p>  The ability to simultaneously check enumeration options <em>and simultaneously</em> link the substructures of the input data with variables allows you to write powerful, clear and simple code that focuses the attention of its reader on data important to a particular branch. </p><br><br><p>  In a nutshell, this is how <code>match</code> works. </p><br><br><p>  So how exactly does this design interact with the concept of ownership and security in general? </p><br><br><h2>  Exhaustive analysis of options </h2><br><blockquote><p>  I usually start by excluding everything that is impossible.  What remains must be true, however incredible it may seem. </p><br><p>  Sherlock Holmes </p><br></blockquote><br><p>  One of the convenient approaches to solving a complex problem is to break it down into its component parts and analyze each separately.  In order for this method to work, the partitioning must be <em>exhaustive</em> : the parts you selected should cover all possible scenarios. </p><br><br><p>  Using <code>enum</code> and <code>match</code> in Rust can help with this, because <code>match</code> provides an exhaustive analysis of options: every possible input value must be covered with a pattern in at least one <code>match</code> branch.  This helps to catch errors in the program logic and ensures that the result of the <code>match</code> expression is clearly defined. </p><br><br><p>  Therefore, for example, the following code is rejected by the compiler: </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suggest_guess_broken</span></span></span></span>(prior_guess: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, answer: Answer) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next_guess = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> answer { Answer::Higher =&gt; prior_guess + <span class="hljs-number"><span class="hljs-number">10</span></span>, Answer::Lower =&gt; prior_guess - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// ERROR: non-exhaustive patterns: `Bingo` not covered }; println!("maybe try {} next", next_guess); }</span></span></code> </pre><br><p>  Many other languages ‚Äã‚Äãprovide some sort of pattern matching (for example, ML and various implementations of <code>match</code> on macros in Scheme), but not all of them have this limitation. </p><br><br><p>  In Rust, this restriction is present for three reasons: </p><br><br><ul><li>  First, as noted above, splitting a problem into parts gives a general solution only if this partition covers all possible scenarios.  Check for completeness makes logical errors obvious. </li><li>  Secondly, the fullness check helps with refactoring.  During the development process, I often add new variations to individual definitions of <code>enum</code> 's.  Checking for completeness helps to find all those <code>match</code> expressions where I used variants from the previous version of the <code>enum</code> type. </li><li>  Thirdly, since <code>match</code> is an expression, the completeness check ensures that all its branches are <em>either</em> computed into a value of one type <em>or</em> transfer control to some other part of the program. </li></ul><br><h3>  Exit <code>match</code> </h3><br><p>  The following code is a revised version of the <code>suggest_guess_broken</code> function, which is shown above;  it directly demonstrates the transfer of control to another part of the program: </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suggest_guess_fixed</span></span></span></span>(prior_guess: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, answer: Answer) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next_guess = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> answer { Answer::Higher =&gt; prior_guess + <span class="hljs-number"><span class="hljs-number">10</span></span>, Answer::Lower =&gt; prior_guess - <span class="hljs-number"><span class="hljs-number">1</span></span>, Answer::Bingo =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"we won with {}!"</span></span>, prior_guess); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"maybe try {} next"</span></span>, next_guess); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">demo_guess_fixed</span></span></span></span>() { suggest_guess_fixed(<span class="hljs-number"><span class="hljs-number">10</span></span>, Answer::Higher); suggest_guess_fixed(<span class="hljs-number"><span class="hljs-number">20</span></span>, Answer::Lower); suggest_guess_fixed(<span class="hljs-number"><span class="hljs-number">19</span></span>, Answer::Bingo); }</code> </pre><br><p>  The <code>suggest_guess_fixed</code> function shows that <code>match</code> can process some of the variants and immediately exit the function, and in the remaining variants calculate the corresponding values ‚Äã‚Äãand pass them further into the function body. </p><br><br><p>  We can use similar constructions in <code>match</code> without fear of losing one of the options, because in <code>match</code> their analysis is exhaustive. </p><br><br><h2>  Algebraic data types and structural invariants </h2><br><p>  <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">Algebraic data types</a> concisely and accurately describe data classes and allow you to encode a variety of structural invariants.  Rust uses the <code>struct</code> and <code>enum</code> definitions for this. </p><br><br><p>  <code>enum</code> -type allows you to define mutually exclusive classes of values.  The examples above use enumerations to create simple character labels, but in Rust, enumerations are also used for much more complex data classes. </p><br><br><p>  For example, a binary tree is either a leaf or an internal node with links to two child trees.  Here is one way to represent a binary tree of integers: </p><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryTree</span></span></span></span> { Leaf(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Node(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;BinaryTree&gt;, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;BinaryTree&gt;) }</code> </pre><br><p>  (The <code>Box&lt;V&gt;</code> means ‚Äúowning‚Äù a link to an instance of a <code>V</code> type placed on the heap. If you own <code>Box&lt;V&gt;</code> , then you also own the <code>V</code> that it contains, and therefore you can change it, create it links, etc. When you have finished working with <code>Box</code> , and it is out of scope, the resources associated with placing <code>V</code> on the heap are automatically released.) </p><br><br><p>  The above definition of <code>enum</code> ensures that if you have a value of type <code>BinaryTree</code> , it will always match one of the specified options.  You will never get <code>BinaryTree::Node</code> without a left descendant.  No need to check for <code>null</code> . </p><br><br><p>  It‚Äôs still <em>necessary to</em> check whether this <code>BinaryTree</code> value is a <code>Leaf</code> or <code>Node</code> option, but the compiler statically guarantees that these checks will be made: you cannot accidentally read a <code>Leaf</code> value as if it were a <code>Node</code> , and vice versa. </p><br><br><p>  Here is a function that adds all the numbers in the tree using <code>match</code> : </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tree_weight_v1</span></span></span></span>(t: BinaryTree) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> t { BinaryTree::Leaf(payload) =&gt; payload, BinaryTree::Node(left, payload, right) =&gt; { tree_weight_v1(*left) + payload + tree_weight_v1(*right) } } } <span class="hljs-comment"><span class="hljs-comment">///  ,   : /// /// +----(4)---+ /// | | /// +-(2)-+ [5] /// | | /// [1] [3] /// fn sample_tree() -&gt; BinaryTree { let l1 = Box::new(BinaryTree::Leaf(1)); let l3 = Box::new(BinaryTree::Leaf(3)); let n2 = Box::new(BinaryTree::Node(l1, 2, l3)); let l5 = Box::new(BinaryTree::Leaf(5)); BinaryTree::Node(n2, 4, l5) } #[test] fn tree_demo_1() { let tree = sample_tree(); assert_eq!(tree_weight_v1(tree), (1 + 2 + 3) + 4 + 5); }</span></span></code> </pre><br><p>  Algebraic data types establish structural invariants that are strictly supported by the language.  (The system of modules and privacy offers more ample opportunities for defining invariants, but we will not deviate from the topic.) </p><br><br><h2>  Expression and Operator Orientation </h2><br><p>  Unlike many other languages ‚Äã‚Äãthat provide pattern matching, Rust supports both expression-based and operator-based styles. </p><br><br><p>  Many functional languages ‚Äã‚Äãin which there is pattern matching encourage code writing using expressions, which focuses on the values ‚Äã‚Äãreturned by a combination of expressions, and the use of side effects is not recommended.  In imperative languages, everything is exactly the opposite - they assume a comprehensive use of operators, i.e.  sequences of commands executed only for their side effects. </p><br><br><p>  Rust perfectly supports both styles. </p><br><br><p>  Consider a function that converts a non-negative integer into a string, representing it as a numeral (‚Äú1st‚Äù, ‚Äú2nd‚Äù, ‚Äú3rd‚Äù, ...).  The following code uses range patterns for simplicity, but it is written in a style similar to using <code>switch</code> in imperative languages ‚Äã‚Äãlike C (or C ++, or Java, etc.), when the branches of <code>match</code> are executed only for their side effects: </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num_to_ordinal</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suffix; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (x % <span class="hljs-number"><span class="hljs-number">10</span></span>, x % <span class="hljs-number"><span class="hljs-number">100</span></span>) { (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) | (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>...<span class="hljs-number"><span class="hljs-number">91</span></span>) =&gt; { suffix = <span class="hljs-string"><span class="hljs-string">"st"</span></span>; } (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) | (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>...<span class="hljs-number"><span class="hljs-number">92</span></span>) =&gt; { suffix = <span class="hljs-string"><span class="hljs-string">"nd"</span></span>; } (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) | (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>...<span class="hljs-number"><span class="hljs-number">93</span></span>) =&gt; { suffix = <span class="hljs-string"><span class="hljs-string">"rd"</span></span>; } _ =&gt; { suffix = <span class="hljs-string"><span class="hljs-string">"th"</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}{}"</span></span>, x, suffix); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_num_to_ordinal</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(num_to_ordinal( <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-string"><span class="hljs-string">"0th"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(num_to_ordinal( <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">"1st"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(num_to_ordinal( <span class="hljs-number"><span class="hljs-number">12</span></span>), <span class="hljs-string"><span class="hljs-string">"12th"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(num_to_ordinal( <span class="hljs-number"><span class="hljs-number">22</span></span>), <span class="hljs-string"><span class="hljs-string">"22nd"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(num_to_ordinal( <span class="hljs-number"><span class="hljs-number">43</span></span>), <span class="hljs-string"><span class="hljs-string">"43rd"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(num_to_ordinal( <span class="hljs-number"><span class="hljs-number">67</span></span>), <span class="hljs-string"><span class="hljs-string">"67th"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(num_to_ordinal(<span class="hljs-number"><span class="hljs-number">1901</span></span>), <span class="hljs-string"><span class="hljs-string">"1901st"</span></span>); }</code> </pre><br><p>  This program will compile, which is great because static analysis ensures at the same time that: </p><br><br><ul><li>  <code>suffix</code> always initialized before we call <code>format!</code>  at the end of the function, and </li><li>  the value of the variable <code>suffix</code> assigned <em>only once</em> during the execution of the function (if this were not the case, the compiler would force us to mark the <code>suffix</code> as a variable variable). </li></ul><br><p>  It is clear that this program can be written in a style based on expressions, for example, like this: </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num_to_ordinal_expr</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}{}"</span></span>, x, <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (x % <span class="hljs-number"><span class="hljs-number">10</span></span>, x % <span class="hljs-number"><span class="hljs-number">100</span></span>) { (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) | (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>...<span class="hljs-number"><span class="hljs-number">91</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"st"</span></span>, (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) | (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>...<span class="hljs-number"><span class="hljs-number">92</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"nd"</span></span>, (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) | (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>...<span class="hljs-number"><span class="hljs-number">93</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"rd"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"th"</span></span> }) }</code> </pre><br><p>  Sometimes this style helps to write a very clear and precise code, but sometimes vice versa, and then it is better to use operators with side effects (the ability to return a value from a function from one <code>match</code> branch to the <code>suggest_guess_fixed</code> function defined earlier, just shows this). </p><br><br><p>  For both styles have their own applications.  The most important thing is that switching to the operator style does not force you to sacrifice other Rust features, such as ensuring that the value of a non- <code>mut</code> variable can be assigned only once. </p><br><br><p>  An important case where this is important is the initialization of a state and its subsequent borrowing, which occurs <em>only in some</em> branches of the execution flow: </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sometimes_initialize</span></span></span></span>(input: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> string: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     let borrowed: &amp;str; //    match input { 0...100 =&gt; { //    ... string = format!("input prints as {}", input); // ...      borrowed = &amp;string[6..]; } _ =&gt; { //      borrowed = "expected between 0 and 100"; } } println!("borrowed: {}", borrowed); //     ,   : // println!("string: {}", string); // ... : error: use of possibly uninitialized variable: `string` } #[test] fn demo_sometimes_initialize() { sometimes_initialize(23); //    `string` sometimes_initialize(123); //   -  }</span></span></code> </pre><br><p>  The interesting thing here is that the code after <code>match</code> cannot directly access the <code>string</code> , because the compiler requires that the variable be initialized on all the paths of the program execution before it is accessed.  At the same time, we <em>can</em> (with the help of <code>borrowed</code> ) access the data that is contained within the <code>string</code> , because the link to them is recorded in the <code>borrowed</code> in the first branch, and we made the <code>borrowed</code> initialized on all the execution paths leading to <code>println!</code>  which <code>borrowed</code> and uses. </p><br><br><p>  (The compiler ensures that no <code>string</code> borrowings can live longer than <code>string</code> , and in the generated code, at the end of the scope, the <code>string</code> value is automatically deployed if it was actually created.) </p><br><br><p>  In short, to ensure correctness, the Rust language ensures that data is always initialized before it is used, but its developers have tried to avoid the need for artificial writing patterns when they are needed solely to ‚Äúcoax‚Äù the static analyzer (for example, requiring the <code>string</code> be initialized with empty data or using style based on expressions). </p><br><br><h2>  Pattern matching without moving </h2><br><p>  Matching a pattern with a value can <em>borrow a</em> substructure without taking ownership.  This is important when applying pattern matching to links (i.e., to values ‚Äã‚Äãof type <code>&amp;T</code> ). </p><br><br><p>  The section "Algebraic data types" above shows the type of binary tree and the program that calculates the sum of all numbers in the tree instance. </p><br><br><p>  That version of <code>tree_weight</code> has a significant drawback: it takes a tree by value.  As soon as you pass the tree to <code>tree_weight_v1</code> , this tree <em>disappears</em> (i.e., is deployed). </p><br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tree_demo_v1_fails</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tree = sample_tree(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(tree_weight_v1(tree), (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>) + <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      ... // assert_eq!(tree_weight_v1(tree), (1 + 2 + 3) + 4 + 5); // ...   : error: use of moved value: `tree` }</span></span></code> </pre><br><p>  This behavior occurs, however, <em>not because of the</em> use of <code>match</code> , but rather because of the choice of the function signature: </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tree_weight_v1</span></span></span></span>(t: BinaryTree) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-comment"><span class="hljs-comment">// ^~~~~~~~~~  ,    //   `t`</span></span></code> </pre><br><p>  In fact, <code>match</code> in Rust works fine where <em>there is no need to</em> obtain ownership.  In particular, the input to <code>match</code> is the <em><a href="https://doc.rust-lang.org/reference.html">L-value</a> expression</em> , that is, the result of the input expression must be a value that is in a certain <em>area of ‚Äã‚Äãmemory</em> .  <code>match</code> evaluates this expression and then checks the data in the corresponding memory area. </p><br><br><p>  (If the input expression is a variable name, dereference of a link or field, then the L-value will correspond to the memory area that contains this variable or field or where the link points. If the input expression is a function call or another operation that creates temporary anonymous value, then this value will be formally stored in the temporary memory area, and it will be processed by the <code>match</code> .) </p><br><br><p>  Therefore, if we want to make such a variant of <code>tree_weight</code> , which simply borrows a tree, and does not take it away at all, then we should use the appropriate opportunity of the expression <code>match</code> . </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tree_weight_v2</span></span></span></span>(t: &amp;BinaryTree) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ^~~~~~~~~~~ `&amp;` ,   **  match *t { BinaryTree::Leaf(payload) =&gt; payload, BinaryTree::Node(ref left, payload, ref right) =&gt; { tree_weight_v2(left) + payload + tree_weight_v2(right) } } } #[test] fn tree_demo_2() { let tree = sample_tree(); assert_eq!(tree_weight_v2(&amp;tree), (1 + 2 + 3) + 4 + 5); }</span></span></code> </pre><br><p>  The <code>tree_weight_v2</code> function <code>tree_weight_v2</code> very similar to <code>tree_weight_v1</code> .  The differences are as follows: firstly, it takes a reference ( <code>&amp;</code> type), secondly, we added deference <code>*t</code> , and thirdly, importantly, we use <code>ref</code> patterns for <code>left</code> and <code>right</code> in the case of <code>Node</code> . </p><br><br><p>  The dereferencing of the <code>*t</code> reference, being interpreted as an L-value expression, simply gets the address in memory where the <code>BinaryTree</code> is located (because <code>t: &amp;BinaryTree</code> is just a <em>reference</em> to this data).  Here <code>*t</code> neither creates a copy of the tree, nor moves it to a new place in memory because <code>match</code> treats it as L-value. </p><br><br><p>  And the most important part of how the L-value expressions work, the <code>ref</code> patterns. </p><br><br><p>   ,   <em>- <code>ref</code></em> -: </p><br><br><ul><li>    <code>T</code>   ,     <code>i</code> ,     <em></em>  <code>i</code> .    ,  <code>i</code>   <code>T</code> (,  , " <code>i: T</code> "). </li></ul><br><p>    <code>T</code> ,      (    " <code>T</code>  [] <code>Copy</code> "),         <code>i</code>    (,       <code>T</code>    ). </p><br><br><p>   , -ref- ,   <code>i</code>  <em> </em>   <code>T</code> . </p><br><br><p>    <code>payload</code>  <code>tree_weight_v2</code>   <code>i32</code> ,    <code>i32</code>  <code>Copy</code> ,     <code>payload</code>   . </p><br><br><p>    ,   <code>ref</code> -: </p><br><br><ul><li>  L-value-  <code>T</code>    <code>ref i</code> ,       <em></em>     .  ,    <code>ref i</code>   <code>T</code> ,  <code>i</code>  <em></em>    <code>T</code> (,  , <code>i: &amp;T</code> ). </li></ul><br><p>    <code>Node</code>  <code>tree_weight_v2</code>  <code>left</code>      <code>Box</code> ( ),  <code>right</code> , ,   . </p><br><br><p>          <code>tree_weight_v2</code> ,     . </p><br><br><p> , <code>ref mut</code> - ( <code>ref mut i</code> )     <em> </em>   : <code>i: &amp;mut T</code> .        ,        .  , ,   <code>match</code> ,           . </p><br><br><p>     <code>ref mut</code> ,        : </p><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tree_grow</span></span></span></span>(t: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> BinaryTree) { <span class="hljs-comment"><span class="hljs-comment">// ^~~~~~~~~~~~~~~ `&amp;mut`:      match *t { BinaryTree::Leaf(ref mut payload) =&gt; *payload += 1, BinaryTree::Node(ref mut left, ref mut payload, ref mut right) =&gt; { tree_grow(left); *payload += 1; tree_grow(right); } } } #[test] fn tree_demo_3() { let mut tree = sample_tree(); tree_grow(&amp;mut tree); assert_eq!(tree_weight_v2(&amp;tree), (2 + 3 + 4) + 5 + 6); }</span></span></code> </pre><br><p> ,     <code>ref mut</code> -   <code>payload</code> .   <code>ref</code>  ,  <code>payload</code>     ,    ,       <em>  </em> .      . </p><br><br><p>   ,         <code>left</code>  <code>right</code>   <code>Node</code> .  ,             ,       <code>&amp;mut</code> -. </p><br><br><h2>  Conclusion </h2><br><p>  Rust        ‚Äî ,      , ‚Äî        Rust      .  <code>enum</code>  <code>match</code>          ,    ,    . </p><br><br><p>     ,        , : </p><br><br><ul><li>   <code>Higher</code>  <code>Answer::Higher</code>  , </li><li>     , </li><li>     <code>ident @ pattern</code> , </li><li>       <code>{ let id = expr; ... }</code>  <code>match expr { id =&gt; { ... } }</code> , </li></ul><br><p>   <a href="https://doc.rust-lang.org/"></a>       (  <code>#rust</code>  IRC  <a href="http://users.rust-lang.org/"> </a> ). </p><br><br><p> (   ,     ,  Aaron Turon, Niko Matsakis,   <code>Mutabah</code> , <code>proc</code> , <code>libfud</code> , <code>asQuirrel</code>  <code>annodomini</code>  <code>#rust</code> .) </p></div><p>Source: <a href="https://habr.com/ru/post/256941/">https://habr.com/ru/post/256941/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256931/index.html">Internet of Things on ESP8266</a></li>
<li><a href="../256933/index.html">Big Data Week Moscow 2015: presentations of speakers</a></li>
<li><a href="../256935/index.html">Retailers gradually go to the "clouds"</a></li>
<li><a href="../256937/index.html">PHDays V: how to make your Shodan, resist ROP shellcodes and automate reverse engineering</a></li>
<li><a href="../256939/index.html">IBM introduced the hybrid chip: silicon photonics in action</a></li>
<li><a href="../256943/index.html">Rake on building a hybrid cloud with Azure</a></li>
<li><a href="../256945/index.html">FlyElephant is a creative laboratory for scientists and engineers. Part 1. The history of creation</a></li>
<li><a href="../256947/index.html">SwipeRefreshLayout: not spherical and not in vacuum</a></li>
<li><a href="../256951/index.html">Unity3d: Experiments with the Social Interface</a></li>
<li><a href="../256955/index.html">Microsoft Research for young scientists - communication and the opportunity to discuss their work with leading scientists from Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>