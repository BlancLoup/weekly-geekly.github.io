<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Direct3D vs OpenGL: history of opposition</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To this day, on the Internet you can find discussions about which graphical API is better: Direct3D or OpenGL? Despite their religious nature, such ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Direct3D vs OpenGL: history of opposition</h1><div class="post__text post__text-html js-mediator-article">  To this day, on the Internet you can find discussions about which graphical API is better: Direct3D or OpenGL?  Despite their religious nature, such verbal battles bring useful results in the form of quite good historical reviews of the development of hardware-accelerated graphics. <br><br><img src="https://habrastorage.org/files/f78/9d2/a4c/f789d2a4cdde4ca399d39c74950faad8.png" alt="image"><br><br>  The goal of this post is to translate one of these <a href="http://programmers.stackexchange.com/a/88055/136804">excursions into history</a> written by Jason L. McKesson in response to the question "Why do game developers prefer Windows?"  This text hardly answers the question posed, but it describes the development and confrontation of the two most popular graphic APIs in a very colorful and rather detailed manner, so I translated the author's markup in translation.  The text was written in mid-2011 and covers a period of time that begins shortly before the appearance of Direct3D and until the time of writing.  The author of the original text is an experienced game developer, an active <a href="http://stackoverflow.com/users/734069/nicol-bolas">participant in</a> StackOverflow, and the creator of an extensive <a href="http://alfonse.bitbucket.org/oldtut/">textbook</a> on modern 3D graphics programming.  So let's give the floor to Jason. <br><a name="habracut"></a><br><h4>  Foreword </h4><br>  Before we begin, I would like to say that I know more about OpenGL than about Direct3D.  In my life I did not write a single line of code on D3D, but I wrote OpenGL tutorials.  But what I want to talk about is not a matter of prejudice, but a story. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  The birth of conflict </h4><br>  One day, somewhere in the early 90s, Microsoft looked around.  They saw that <a href="http://en.wikipedia.org/wiki/Snes">SNES</a> and <a href="http://en.wikipedia.org/wiki/Sega_Genesis">Sega Genesis</a> is very cool, you can play a lot of action games and all that.  And they saw dos.  The developers wrote dosov games like console games: close to hardware.  However, unlike consoles, where the developer knew what kind of hardware the user would have, dos developers were forced to write under a variety of configurations.  And it is much more difficult than it seems. <br><br>  But Microsoft had a bigger problem: Windows.  You see, Windows wanted to fully own the hardware, unlike DOS, which allowed developers to do anything.  Possession of iron is necessary for interaction between applications.  But this interaction is exactly what game developers <i>hate</i> because it consumes precious resources that they could use for all sorts of cool things. <br><br>  To promote the development of games on Windows, Microsoft needed a homogeneous API that would be low-level, work on Windows without any performance loss, and be <i>compatible with various hardware</i> .  Unified API for graphics, sound and input devices. <br><br>  This is how DirectX was born. <br><br>  3D accelerators appeared a few months later.  And Microsoft got into trouble.  The fact is that DirectDraw, the graphic component of DirectX, worked only with 2D graphics: it allocated graphics memory and did fast bit operations between different memory sectors. <br><br>  Therefore, Microsoft bought some third-party software and turned it into Direct3D version 3. <i>Absolutely</i> everyone scolded him.  And it was for that: reading the code on D3D v3 looked like a decoding of the writing of a vanished ancient civilization. <br><br>  The old man John Carmack at Id Software looked at this disgrace, said "Fuck it ...", and decided to write using another API: OpenGL. <br><br>  However, the other side of this confusing story was that Microsoft worked with SGI to work with OpenGL for Windows.  The idea was to attract developers of typical GL-applications for workstations: CAD, modeling systems and similar things.  The games were the last thing they thought.  This mainly concerned Windows NT, but Microsoft decided to add OpenGL to Windows 95. <br><br>  To lure the developers of software for workstations on Windows, Microsoft decided to bribe them with access to new-fashioned 3D accelerators.  They implemented a protocol for client drivers to be installed: the graphics card could replace the Microsoft software OpenGL with its hardware implementation.  The code automatically used hardware OpenGL, if one was available. <br><br>  However, in those days, consumer video cards did not have OpenGL support.  This did not stop Carmack from porting Quake to OpenGL on an SGI workstation.  In the GLQuake readme, you can read the following: <br><blockquote>  In theory, glquake will run on any OpenGL implementation that supports the expansion of texture objects.  But until you run it on a very powerful hardware, which accelerates everything you need, it will work inexcusably slowly.  If the game needs to work through any software emulations, its performance will most likely not exceed one frame per second. <br><br>  Currently (March 1997), the only fully opengl-compatible piece of hardware capable of pulling glquake at an acceptable level is the VERY expensive intergraph realizm video card.  3dlabs significantly increased its performance, but with existing drivers it is still not suitable for the game.  Some of the drivers from 3dlabs for glint and permedia boards are also NT cracks when exiting full-screen mode, so I do not recommend running glquake on 3dlabs hardware. <br><br>  3dfx provides opengl32.dll, which implements everything you need for glquake, but this is not a complete opengl implementation.  Other opengl applications will probably not work with it, so consider it mainly as a ‚Äúdriver for glquake‚Äù. </blockquote><br>  This was the birth of miniGL drivers.  Ultimately, they evolved into full-fledged OpenGL implementations as soon as the iron was powerful enough to support this functionality in hardware.  nVidia was the first to offer the full implementation of OpenGL.  Other vendors are still slow, which was one of the reasons why developers were switching to Direct3D, supported by a wider range of equipment.  In the end, there were only nVidia and ATI (which is now AMD), and both had good OpenGL implementations. <br><br><h4>  Dawn opengl </h4><br>  So, the participants are defined: Direct3D vs. OpenGL.  This is truly an amazing story, considering how bad D3D v3 was. <br><br>  The OpenGL Architecture Board (Architectural Review Board, ARB) is the organization responsible for maintaining and developing OpenGL.  They release many extensions, contain a repository with extensions, and create new versions of the API.  ARB is a committee consisting of a large number of players in the computer graphics industry and some OS manufacturers.  Apple and Microsoft at different times were also members of ARB. <br><br>  3Dfx takes the stage with his Voodoo2.  This is the first video card that allows you to do multitexturing, which was not previously provided in OpenGL.  While 3Dfx was strongly opposed to OpenGL, nVidia, the next multitexturing chip maker (TNT1), was crazy about OpenGL.  Then ARB released the GL_ARB_multitexture extension, which provided access to multiple textures. <br><br>  Meanwhile, Direct3D v5 appears.  Now D3D really became an <i>API</i> , and not some kind of nonsense.  What is the problem?  In the absence of multitexturing. <br><br>  Oops. <br><br>  But this did not cause such inconvenience, which could have been delivered, because almost no one used multiple texturing.  Multitexturing almost does not harm performance, and in many cases the difference is not noticeable against the background of multi-pass.  And of course, game developers are very fond of their games working confidently on the old hardware, which did not have support for multiple textures, so many games were released without it. <br><br>  D3D breathed a sigh of relief. <br><br>  Time passed, and nVidia rolled out the GeForce 256 (not to be confused with the very first GeForce GT-250), ending the struggle in the graphics card market for the next two years.  The main competitive advantage of this board was the ability to transform vertices and lighting (transformation &amp; lighting, T &amp; L) hardware.  But that's not all: nVidia loved OpenGL so much that their T &amp; L engine was actually OpenGL.  Almost literally!  As I understand it, some of their registers received the input <i>directly the</i> numerical values ‚Äã‚Äãof variables of type GLenum. <br><br>  Direct3D v6 comes out.  Finally, multiple texturing came up ... but without hardware T &amp; L.  OpenGL <i>has always</i> had a T &amp; L pipeline, although prior to the GeForce 256 it was implemented programmatically.  Therefore, for nVidia, it turned out to be quite easy to convert the software implementation into a hardware solution.  In the D3D, the hardware T &amp; L appeared only to the seventh version. <br><br><h4>  The dawn of the era of shaders, OpenGL in the dark </h4><br>  Then came the GeForce 3. At the same time, many interesting things happened. <br><br>  Microsoft decided that they were no longer going to be late.  Therefore, instead of looking at what nVidia will do and copying their developments already post factum, Microsoft made an amazing decision: go and talk.  And they fell in love with each other, and they had a joint small console. <br><br>  Noisy divorce occurred later, but this is a completely different story. <br><br>  For the PC market, this meant that GeForce 3 came out simultaneously with D3D v8, and it is not difficult to see how GeForce 3 influenced D3D v8 shaders.  Shader Model 1.0 pixel shaders were <i>very</i> sharpened for nVidia hardware.  Not a single attempt was made to do anything to abstract from nVidia hardware.  Shader Model 1.0 has become what GeForce 3 is intended for. <br><br>  When ATI broke into the performance race of video cards with its Radeon 8500, one problem appeared.  The Radeon 8500 pixel pipeline turned out to be more powerful than the nVidia.  Therefore, Microsoft released Shader Model 1.1, which basically was what the 8500 was intended for. <br><br>  It sounds like a D3D defeat, but success and failure are relative concepts.  In fact, an <i>epic</i> failure awaited OpenGL. <br><br>  Nvidia was very fond of OpenGL, so after the release of GeForce 3, they released a whole pack of extensions for OpenGL.  <i>Proprietary</i> extensions that only worked on nVidia.  Naturally, when the 8500 board appeared, she could not use any of them. <br><br>  So, on D3D 8 you could at least run SM 1.0 shaders.  Of course, in order to use all the coolness of 8500, we had to write new shaders, but at least the code <i>worked</i> . <br><br>  To get <i>any</i> shaders on the Radeon 8500 in OpenGL, ATI had to develop several extensions for OpenGL.  <i>Proprietary</i> extensions that worked only on ATI.  As a result, so that the developers could declare that they had attached shaders to their engine, they had to write a separate code for nVidia and a separate code for ATI. <br><br>  You might ask, ‚ÄúWhere was the ARB committee that should keep OpenGL afloat?‚Äù  And they were where many of the committees ended up: they were sitting and stupid. <br><br>  Notice that I mentioned ARB_multitexture above because this extension is deeply involved in the whole situation.  An outside observer thought that ARB wanted to avoid the idea of ‚Äã‚Äãshaders at all.  They decided that if they put enough configurability into a fixed pipeline, then it would be equal in its capabilities to a programmable shader pipeline. <br><br>  ARB released extensions one by one.  Each extension with the words ‚Äútexture_env‚Äù in the title was an attempt to patch up this aging design.  Look at the list of extensions: <i>eight of</i> these extensions have been released, and many of them have been translated into the main OpenGL functionality. <br><br>  At that time, Microsoft was part of ARB, and left it only for the D3D 9 release, so Microsoft may have sabotaged OpenGL in some way.  Personally, I doubt this theory for two reasons.  First, they would have to enlist the support of other members of the Committee, because each participant has only one vote.  Secondly, and more importantly, the committee did not need the help of Microsoft to bungle everything, evidence of which we will see later. <br><br>  As a result, ARB, most likely under the pressure of ATI and nVidia (both are active participants), finally woke up and introduced assembler shaders into the standard. <br><br>  Want even more stupid story? <br><br>  Hardware T &amp; L.  This is what OpenGL was <i>originally</i> .  To get the best possible hardware T &amp; L performance, you need to store vertex data on the GPU.  Still, the GPU is the main consumer of the vertex data. <br><br>  In D3D v7, Microsoft introduced the concept of vertex buffers that allocate chunks of memory to the GPU and place the vertex data there. <br><br>  Want to know when equivalent functionality appeared in OpenGL?  Yes, nVidia, as the biggest fan of OpenGL, released its extension for storing arrays of vertices on the GPU even at the time of the release of GeForce 256. But when did ARB introduce such functionality? <br><br>  <i>Two years later.</i>  This was <i>after</i> she approved vertex and fragment (pixel in terms of D3D) shaders.  ARB spent so much time developing a cross-platform solution for storing vertex data in GPU memory.  And this is what is <i>necessary</i> for the hardware T &amp; L to reach maximum performance. <br><br><h4>  One language to kill them all </h4><br>  So, OpenGL has been broken for some time.  There were no cross-platform shaders and hardware-independent storage of vertices in the GPU, while D3D users enjoyed both.  Could it get any worse? <br><br>  You can say it could.  Meet: <a href="http://en.wikipedia.org/wiki/3D_Labs">3D Labs</a> . <br><br>  You ask: who are they?  They are a dead company that I consider to be the true killer of OpenGL.  Of course, the Committee‚Äôs general failure made OpenGL vulnerable, while it had to tear D3D to shreds.  But in my opinion, 3D Labs is probably the only reason for the current OpenGL position in the market.  What did they do for it? <br><br>  They developed a shader language for OpenGL. <br><br>  3D Labs was a dying company.  Their costly GPUs have been driven out of the market by the ever-increasing pressure of nVidia.  And unlike nVidia, 3D Labs has not been introduced to the consumer market;  a nVidia win would mean death for 3D Labs. <br><br>  What eventually happened. <br><br>  In an effort to be afloat in a world that did not need their products, 3D Labs showed up at the Game Developer Conference with a presentation of what they called ‚ÄúOpenGL 2.0‚Äù.  It was the OpenGL API rewritten from scratch.  And it made sense, because in those days the OpenGL API was full of junk (which, however, remains there to this day).  Look at least at how esoterically made loading and binding textures. <br><br>  Part of their sentence was shader language.  Yes, precisely he.  However, unlike the available cross-platform extensions, their shader language was ‚Äúhigh level‚Äù (C is a high level for shader language). <br><br>  At the same time, Microsoft worked on its own shader language.  Which they, including all their collective imagination, called ... High Level Shader Language (HLSL).  But their approach to language was fundamentally different. <br><br>  The biggest problem with language from 3D Labs was that it was embedded.  Microsoft completely determined its own language.  They released a compiler that generated assembler code for SM 2.0 shaders (or higher), which, in turn, could be fed to D3D.  At the time of D3D v9, HLSL never touched D3D directly.  He was a good, but not necessary abstraction.  The developer has always had the opportunity to take compiler exhaust and tweak it for maximum performance. <br><br>  There was <i>nothing like</i> that in the language from 3D Labs.  You give the driver a C-like language, and it creates a shader.  That's all.  No assembler shader, nothing to feed anything else.  Only an OpenGL object representing the shader. <br><br>  For OpenGL users, this meant that they became subject to the whims of the OpenGL developers, who only learned how to compile assembler-like languages.  In the compilers of the newborn language of OpenGL shaders (GLSL) bugs raged.  Worse yet, if you managed to force the shader to compile correctly on various platforms (which in itself was a great achievement), then it was still subject to <i>optimizers of</i> those times that were not as optimal as they could be. <br><br>  This was a big, but not the only disadvantage of GLSL.  Not the only one. <br><br>  In D3D, as in the old OpenGL assembler languages, it was possible to mix vertex and fragment shaders in every possible way.  You could use any vertex shader with any compatible fragment shader, if they interacted through the same interface.  Moreover, even some incompatibility was allowed: for example, the vertex shader could supply a value to the output that was not used by the fragment shader. <br><br>  There was nothing like that in GLSL.  The summit and fragment shader fused together, forming something called 3D Labs company "software object".  Therefore, to share several vertex and fragment shaders in various combinations, it was necessary to create several program objects.  This caused the second largest problem. <br><br>  3D Labs thought they were the smartest.  They took C / C ++ as the basis for the GLSL compilation model.  This is when you take one c-file and compile it into an object file, and then take several object files and compose them into a program.  This is how GLSL is compiled: first you compile a vertex or fragment shader into a shader object, then put these objects into a program object and put them together to finally form a program. <br><br>  In theory, this allowed for such cool things to appear as ‚Äúlibrary‚Äù shaders, which contain the code called by the main shader.  In practice, this led to shaders being compiled <i>twice</i> : once at the compilation stage and a second time at the linking stage.  In particular, the compiler from nVidia was famous for it.  It did not generate any intermediate object code;  He first compiled, discarded the result and re-compiled it at the layout stage. <br><br>  Thus, in order to attach a vertex shader to two different fragment shaders, we had to compile a lot more than in D3D.  Especially considering the fact that the whole compilation is done <i>offline</i> , and not before the direct execution of the program. <br><br>  GLSL had other problems.  Perhaps it would be wrong to put all the blame on 3D Labs, because in the end ARB approved the shaders language and included it into OpenGL (but nothing more from the 3DLabs offerings).  However, the original idea was all the same for 3D Labs. <br><br>  And now the saddest thing: 3D Labs were <i>right</i> (mostly).  GLSL is not a vector language as HLSL was at that time.  This happened because the 3D Labs iron was scalar (like modern iron from nVidia), and they were completely right in choosing the direction that many equipment manufacturers later followed. <br><br>  They were right with the choice of a compilation model for a ‚Äúhigh-level‚Äù language.  Even D3D eventually came to this. <br><br>  The problem is that 3D Labs were right at the wrong <i>time</i> .  And in trying to get into the future prematurely, in trying to be ready for the future, they set aside the present.  It looks like the T &amp; L functionality in OpenGL, which has always been there.  Except that the OpenGL T &amp; L pipeline was <i>useful</i> even before the T &amp; L hardware, and GLSL was a burden before the rest of the world caught up with it. <br><br>  GLSL is a good language <i>now</i> .  But what happened at that time?  He was terrible.  And OpenGL suffered from that. <br><br><h4>  On the way to the apotheosis </h4><br>  I support the view that 3D Labs struck OpenGL with a fatal blow, but the last nail on the coffin was scored by ARB itself. <br><br>  You may have heard this story.  In the days of OpenGL 2.1, OpenGL had big problems.  He was carrying a <i>huge</i> load of compatibility.  The API was no longer easy to use.  One thing could be done in five different ways and it is not clear which one is faster.  It was possible to ‚Äúlearn‚Äù OpenGL using simple tutorials, but you didn‚Äôt learn about OpenGL, which gives you real graphical power and performance. <br><br>  ARB decided to make another attempt to invent OpenGL.  It was like OpenGL 2.0 from 3D Labs, but better because ARB was behind this attempt.  They called it "Longs Peak." <br><br>  What is so bad about spending a little time improving the API?  The bad thing is that Microsoft is in a rather shaky position.  It was the transition time to Vista. <br><br>  In Vista, Microsoft decided to make long-awaited changes to graphics drivers.  They made drivers turn to the OS for graphics memory virtualization and more. <br><br>  One can argue for a long time about the merits of such an approach, and whether it was even possible at all, but the fact remains: Microsoft made D3D 10 only for Vista and higher.  Even on the <i>supporting</i> D3D hardware it was impossible to launch the D3D application without Vista. <br><br>  You may remember that Vista ... let's say, did not work very well.  So, we had a leisurely OS, a new API that worked only on this OS, and a new generation of hardware that <i>needed</i> this API and OS to do more than just outperform the previous generation in performance. <br><br>  However, developers <i>could</i> use the functionality of the D3D level 10 through OpenGL.  That is, they could if ARB were not busy working on Long Peaks. <br><br>  ARB spent a good one and a half or two years working on improving the API.  By the time OpenGL 3.0 was released, the transition to Vista was over, Windows 7 was on the way, and game developers no longer cared about the functionality of the D3D 10 level. In the end, the hardware for the D3D 10 worked fine with the applications on D3D 9. With the increase in porting from PC to consoles (or with the transition of PC developers to the console market), developers needed D3D 10 less and less. <br><br>  If developers had access to this functionality even on Windows XP, the development of OpenGL could receive a vivifying charge of vivacity.  But the ARB missed this opportunity.  Do you want to know what is the worst? <br><br>  ARB <i>could not</i> invent API from scratch despite spending two precious years trying to do it.  Therefore, they returned the status quo, adding only a mechanism for declaring the functionality obsolete. <br><br>  As a result, ARB not only missed the <i>key</i> opportunities, but also did not perform the work that led them to this omission.  It was epic fail across the board. <br><br>  Such is the story of the opposition of OpenGL and Direct3D.  The history of missed opportunities, the greatest folly, deliberate recklessness and banal absurdities. </div><p>Source: <a href="https://habr.com/ru/post/397309/">https://habr.com/ru/post/397309/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../397299/index.html">Tasty Chicken</a></li>
<li><a href="../397301/index.html">The highlight of the program: Lenovo YOGA Book at IFA 2016</a></li>
<li><a href="../397303/index.html">Expansion of the front of bacteria in the arena with antibiotics: a spectacular experiment at Harvard Medical School</a></li>
<li><a href="../397305/index.html">As a Japanese farmer using deep learning and TensorFlow cucumbers sorted</a></li>
<li><a href="../397307/index.html">Lecture "Subtle complexities of space technology"</a></li>
<li><a href="../397311/index.html">The existence of cryovolcanoes in Ceres is confirmed</a></li>
<li><a href="../397313/index.html">Just add water. Small additive H‚ÇÇO increases the power of the engine and saves fuel</a></li>
<li><a href="../397315/index.html">Automatic staircase lighting</a></li>
<li><a href="../397317/index.html">Factory Refurbished: we buy electronics cheaply, and with a guarantee</a></li>
<li><a href="../397319/index.html">IoT Link: LoRa vs. UNB. Part 2: Business</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>