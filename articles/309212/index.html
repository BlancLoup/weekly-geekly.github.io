<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Frontend: Development and Support (+ vote)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's imagine that you were transferred to a new project. Or you changed the job and only heard about the project. Here you sit at the workplace, the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Frontend: Development and Support (+ vote)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/5aa/22d/c4b/5aa22dc4be98413daa274d1ec794a94d.jpg"><br><br>  Let's imagine that you were transferred to a new project.  Or you changed the job and only heard about the project.  Here you sit at the workplace, the manager comes to you, shakes hands and ... right off immediately opens the project page, pokes a finger at the monitor and asks to insert a "informer about the upcoming event X".  On this you part ... What to do?  Where to begin?  How to create an "informer"?  Where to find the right template?  And a sea of ‚Äã‚Äãother issues. <br><br>  Under the cut there will be a story, how we try to organize these processes, what tools we create for the preparation of SPA.  In addition, we will talk about the technical details of the implementation of Live Coding / Hot Reload and a bit about VirtualDom and React with Angular. <br><a name="habracut"></a><br>  Let's get started  So, you are left alone with the project, the team told me where to find the repository, and then read README.md, that's all. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  README.md </h1><br>  This is the starting point when immersed in the project, it meets you with basic information: <br><br><ul><li>  <b>Installation</b> - all steps are described here, how to start a project so that even the ‚Äúdesigner‚Äù can do it; </li><li>  <b>Launch</b> - examples of basic commands for launching a project; </li><li>  <b>Startup options</b> - a list of all possible parameters and their description; </li><li>  <b>"First steps"</b> - in fact, this is the right section: <br><ul><li>  quick search for UI-block - description of the tool for the preparation of the application; </li><li>  "What?  Where?  When? ‚Äù- a brief description of the project structure; </li><li>  creating a UI block ‚Äî minimal information on how to create a UI block; </li><li>  ‚ÄúApplication logic, or where to look for event handling?‚Äù; </li></ul></li><li>  Examples / screencasts - an experimental section with examples. </li></ul><br><div class="spoiler">  <b class="spoiler_title">An example of what this looks like in the gitlab interface</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/c24/b82/dde/c24b82dde118450b8bdf120a44e1056f.png"><br><img src="https://habrastorage.org/files/30a/f2b/40c/30af2b40cd564035bbdf253dd961f21b.png"><br></div></div><br>  Everything about everything will take about five minutes.  The most important thing that you learn from the README: to solve the problem you need: <br><br><ol><li>  Install NodeJS / npm. </li><li>  Clone the project repository. </li><li> Run <code>npm install</code> and <code>npm start</code> . </li><li>  Open the project in the browser and click on the "dropper" in the lower right corner.  ;] </li></ol><br>  But let's order. <br><br><h1>  Installation </h1><br>  We have been using package development for a long time, so many parts (grunt and gulp tasks, utilities, UI components, etc.) are developed as separate npm or jam packages.  This approach makes it possible to reuse the code between projects as much as possible, provides versioning (by semver) and, in addition, allows you to build the infrastructure for each package just for the task.  And most importantly, no legacy, the package is independent and, who knows, it can eventually turn into a good opensource. <br><br>  In addition, do not forget to use npm-hooks, for example <code>postinstall</code> .  We use it to install such git-hooks as: <br><br><ul><li>  pre-commit - coding style check (eslint); </li><li>  pre-push - run tests; </li><li>  post-merge - run <code>npm install</code> and <code>jam install</code> . </li></ul><br>  The last hook may seem strange, but when you work with a bunch of packages that are dynamically updated, without it in any way.  Having typed <code>git pull</code> , the developer should get the current version of the project, which can be achieved only by forcing <code>npm install</code> . <br><br>  If the project depends on npm or another third-party package manager, take care of the local registry, so as not to depend on the outside world and its problems (left-pad, Roskomnadzor, etc.). <br><br><h1>  Launch </h1><br>  <code>npm start</code> is all you need to know, and it doesn't matter what is under your hood: gulp, grunt, webpack ... I already wrote above that in README.md there is a description of launch parameters: the application reads README.md at start, parses the list of options and their descriptions and if you use an unknown or undocumented option, it gives an error.  This is the simple way to solve the problem of documentation: no description - no option. <br><br>  Startup example: <br><br><pre> <code class="bash hljs">npm start -- --xhr --auth=oauth --build &gt; project-name@0.1.0 start /git/project-name/ &gt; node ./ <span class="hljs-string"><span class="hljs-string">"--xhr"</span></span> <span class="hljs-string"><span class="hljs-string">"--auth=oauth"</span></span> <span class="hljs-string"><span class="hljs-string">"--build"</span></span> - : master (Sun Aug 29 2016 10:28:06 GMT+0300 (MSK)) -   - xhr: <span class="hljs-literal"><span class="hljs-literal">true</span></span> (   `XMLHttpRequest`) - auth: oauth (  `proxy`, `oauth`, `account`) - build: <span class="hljs-literal"><span class="hljs-literal">true</span></span> ( ) -   -    3000 -  : localhost:3000</code> </pre><br><h1>  The first steps </h1><br>  Let's return to the task.  So, README.md is read, the project is installed and running, go to the item ‚Äúquick block search, or‚Äú pipette ‚Äù- our everything‚Äù. <br><br>  Pipette is a tool for analyzing the structure of components and their parameters.  To use it, open the browser, click on the ‚Äúpipette‚Äù and select the place where ‚Äúthe manager pointed with his finger‚Äù. <br><br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text">  <b>Pipette</b> <br><img src="https://habrastorage.org/files/f7f/bf2/06c/f7fbf206c52f420294818ec1ec307aad.png" alt="image"><br><br>  <b>Inspector</b> <br><img src="https://habrastorage.org/files/600/32a/809/60032a809f7340f494ed4f29ab83de3e.png" alt="image"><br></div></div><br>  A inspector panel appeared below, which shows the structure of the blocks under the cursor.  Finding the right, click on it.  Now we can look at the whole chain of nested blocks, and also find out in which file and line they are called. <br><br>  Now click on the file name, and ... the IDE opens, and the cursor is positioned on the desired line.  There is an ‚Äúeye‚Äù next to it. If you click on it, the GUI / viewer opens with the selected block. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/LunurGTypDo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  All the main entry points found, now proceed to the addition of "informer." <br><br><h3>  Creating a UI block </h3><br>  There are two ways to create a block (both are described in the readme): <br><br><ul><li>  through the console; </li><li>  using the GUI. </li></ul><br>  The console tool is needed when it is not possible to use the GUI, in all other cases it is more convenient and clearer to resort to the GUI. <br><br><h3>  GUI </h3><br>  This is a web interface for viewing, and most importantly, developing UI-blocks of the project.  What he can do: <br><br><ul><li>  view a list of all blocks; </li><li>  simple search by name and keywords; </li><li>  output of all use cases for a specific unit; </li><li>  creating a new block; </li><li>  rename block. </li></ul><br><img src="https://habrastorage.org/files/213/016/efa/213016efaf92445daf873a8511089201.png" alt="image"><br><br>  First of all, you need to find out if there are any such informers in the project.  Using the search, we find a similar block, again use the ‚Äúpipette‚Äù to study its structure and press ‚Äú+‚Äù, enter the name of the new block, click ‚ÄúOK‚Äù, after which the GUI opens the preview of the created block.  Again, use the eyedropper and open the IDE to edit the css / template / js. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wvcshQlX4vY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  So what happened?  After clicking the ‚ÄúOK‚Äù button, the GUI creates a folder with a typical block, which in our architecture consists of at least four files: <br><br><ul><li>  block-name <b>.html</b> - block template <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><br></li><li>  block-name <b>.scss</b> - styles <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.block-name</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: red; }</code> </pre><br><br></li><li>  block-name <b>.js</b> - behavior description <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> feast <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'feast'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> template <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'feast-tpl!./block-name'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> styleSheet <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'feast-css!./block-name'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * @class UIBlockName * @extends feast.Block */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> feast.Block.extend({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'block-name'</span></span>, template, styleSheet });</code> </pre><br><br></li><li>  block-name <b>.spec.js</b> - the specification on the basis of which use cases are built <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { <span class="hljs-string"><span class="hljs-string">'base'</span></span>: { <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: {} } };</code> </pre><br><br></li></ul><br>  When editing any of these files, all changes are applied without reloading the page.  This is not just fashionable fun, but a huge time saver.  Blocks can have logic, and Hot Reload allows you not to lose the current state, which happens when F5 / cmd + r.  Even when editing a template, the connected blocks are automatically updated.  In other words, the GUI program a little for you.  ;] <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uXPepZrJs4s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  So, almost without knowing anything about the project, you can add a new block.  You do not need to read kilometers of documentation to accomplish a normal task.  But this does not mean that ‚Äúkilometers‚Äù are not needed: even as they are needed - to deepen the knowledge and life of the project without its main maintainers.  For example, for working with API and business logic, we have an internal JSSDK, the documentation of which is generated based on JSDoc3. <br><br><h3>  Mini-total </h3><br>  It is necessary to study the documentation and code base of the project correctly, but already at the stage of thorough immersion, at first it is enough to describe the scenarios for performing typical tasks.  Such instructions should be easy and intuitive.  Automate everything that can be automated.  As you can see, in our case it is not just the creation of a block: automation begins with the installation of the project, hooks, updating packages, etc. Entering the project should be easy and fun;] <br><br><h1>  Technical part </h1><br>  I'll start a little from afar.  In early 2012, we created our own Fest template engine.  He converted XML to a js function that can be used on the client and server.  The function took an object of parameters and produced a string: the classic js template engine.  Only, unlike the counterparts, the function at that time was super-optimized, we could run it on a pure V8, having achieved the performance of the C-template engine, which we used before. <br><br><pre> <code class="hljs erlang-repl">[XML -&gt; JSFUNC -&gt; STRING -&gt; DOM]</code> </pre> <br>  During this time, on the basis of Fest, we have developed an internal library of blocks, which is used on several projects at once (Mail, Cloud, etc.).  That is, buttons, inputs, forms, lists, etc. are common.  Actually, these were the first steps in structuring the layout and components. <br><br>  Time passed, and the question ‚ÄúHow do we live on?‚Äù Got sharper, because Fest returns only a string, you can update the state in two ways: either ‚Äúredraw everything‚Äù or ‚Äúinfluence the DOM from JS‚Äù. <br><br>  Of course, you have to use both approaches: somewhere it is easier and faster to redraw everything, somewhere you need to change only one css-class.  In general, when working with a template engine that produces a string, there are pros / cons, and this is by no means performance, as many now think.  There are several main problems: <br><br><ul><li>  Redraw everything - re-initialization of events, re-getting references to the necessary DOM-fragments, ‚Äúflashing‚Äù images, etc. </li><li>  Point impact - blurs and duplicates logic, complicating development. </li></ul><br>  Therefore, we began to move on, but with the possibility of minimal rewriting of ready-made components. <br><br>  There were many experiments.  We tried to introduce data-binding, very similar to Angulyarovsky, but, unlike him, Fest still issued a string, and data-binding was superimposed after insertion into the DOM.  This allowed to maintain the original speed and work through the V8.  Alas, on the big lists we still have the same problems with the ala- $ digest as that of the angulyar, even though our implementation was a bit faster (as part of our tasks). <br><br>  Over time, React entered the market and gave us VirtualDom.  After benchmarking, I was a little bit disheartened: the basic ‚Äúlist of letters‚Äù was about three times slower than ours (and this is a shortened implementation).  In addition, we wanted not to rewrite our code, but only to replace the principle of updating the template.  But a blessing in disguise: React gave impetus to the entire js-community, and soon, as mushrooms, alternative implementations of vdom began to grow: <a href="https://github.com/google/incremental-dom">Incremental DOM</a> , <a href="https://github.com/patrick-steele-idem/morphdom">morphdom</a> , <a href="https://github.com/dekujs/deku/">Deku</a> , <a href="http://lhorie.github.io/mithril/">mithril</a> , <a href="https://github.com/Bobris/Bobril">Bobril,</a> and many others. <br><br>  The matter remained for the small: to carry out benchmarks on our tasks, choose the suitable one and write transpiler for our templates. <br><br><pre> <code class="hljs erlang-repl">[XHTML -&gt; JSFUNC -&gt; VDOM? -&gt; DOM]</code> </pre> <br>  But the main goal was to get the most comfortable development of blocks, namely: <br><br><ul><li>  Interface to create, view and test blocks. </li><li>  Live coding (CSS / HTML / JS). </li><li>  Automation of creating / editing blocks. </li><li>  Component inspection tools. </li><li>  Visualization of connections between components. </li></ul><br>  In addition, we already had a GUI / web interface to the current library of blocks, it only remained to unify the idea, so that each project could deploy a GUI for itself without much pain. <br><br><h1>  Development </h1><br><h3>  Live coding </h3><br>  I think I‚Äôm not mistaken if I say: everyone knows what Webpack and BrowserSync are.  Much has been written about them, so I will not focus on them, but I will show an alternative way: what to do when boxed solutions do not suit you.  Just do not think that I urge you to reinvent the wheel: by no means, this is simply a lower-level version, which many people forget about and spend a lot of time on screwing the same Webpack. <br><br>  If so, then <b>node-watch + socket.io</b> is all you need.  Two ready-made tools that you can easily integrate into your project. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watch = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'node-watch'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> socket = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'socket.io'</span></span>); cosnt PORT = <span class="hljs-number"><span class="hljs-number">1234</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = http.createServer(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) =&gt;</span></span> { res.writeHead(<span class="hljs-number"><span class="hljs-number">200</span></span>, {<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'html/text'</span></span>}); res.end(); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> io = socket(app); app.listen(PORT, () =&gt; { watch(<span class="hljs-string"><span class="hljs-string">'path/to'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">recursive</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, (file) =&gt; { fs.readFile(file, (err, content) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ext = file.split(<span class="hljs-string"><span class="hljs-string">'.'</span></span>).pop(); io.emit(<span class="hljs-string"><span class="hljs-string">`file-changed:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ext}</span></span></span><span class="hljs-string">`</span></span>, {file, content}); }); }); });</code> </pre><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äù//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.5/socket.io‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">const</span></span></span><span class="actionscript"> io = io(location.protocol + </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'//'</span></span></span><span class="actionscript"> + location.host) socket.on(</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'file-changed:html, function (data) { // data.file, data.content }); </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  That's it, now you can receive changes on the client. <br><br>  In reality, our situation looks something like this, the main difference from the above listing is the preprocessing of JS and CSS when returning to the client.  Yes exactly;  unlike Webpack, we do not use gangs in the dev environment, files are converted on demand. <br><br><h3>  Hot update blocks </h3><br>  To breathe new life into the fest, it was necessary to choose a library for working with vdom and write a transpiler for xhtml / xml, take into account the problems of implementation and solve them. <br><br>  What problems?  For example, in order to add a new functionality (construction / tag processing), it was necessary to make changes to the library and raise the version.  In addition, templates could be compiled only on the server. <br><br>  So it was Feast.  ;] <br><br>  It also converts xml / xhtml to JSFUNC, but this function does not return a string, but JSON, which is later transferred to citojs (this is a very fast and simple library for working with vdom), and citojs is already building or updating vdom. <br><br>  In addition, now the compilation of templates takes place directly on the client, so the templates are given "as is" and on the client are converted first to AST, and then, according to the transformation rules, to JSFUNC. <br><br><div class="spoiler">  <b class="spoiler_title">For example, here are the rules for converting the tag `fn: for`</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// &lt;fn:for data="attrs.items" as="key" value="item"&gt;...&lt;/fn:for&gt; 'fn:for': { scope: true, required: ['data'], expressions: ['data'], prepare: (node, {as, key, data}) =&gt; ({ as: attrs.as || '$value', key: attrs.key || '$index', data }), toCode: () =&gt; ['EACH($data, @@.children, function (&amp;as, &amp;key) {', '});']); }</span></span></code> </pre></div></div><br>  This allowed solving several problems at once: <br><br><ul><li>  no longer need a server to compile; </li><li>  even the size of the excess html is smaller than the compiled JS; </li><li>  transformation rules can be supplemented on the fly; </li><li>  maximum meta information. </li></ul><br>  Therefore, when a new html is received on the client, it is re-translated to the JS function and the re-render of all blocks created based on this template is called: <br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'file-changed:html'</span></span>, (data) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> updatedFile = data.file; feast.Block.all.some(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Block</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedFile === Block.prototype.template.file) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = feast.parse(data.content, updatedFile); Block.setTemplate(template); Block.getInstances().forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">block</span></span></span><span class="hljs-function"> =&gt;</span></span> block.render()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }); });</code> </pre><br>  For CSS, about the same logic, the main change was the introduction of CSS modularity, to say goodbye to main.css once and for all and deliver css along with the component code, as well as to protect selectors from intersection and obfuscation. <br><br><h3>  CSS Modules </h3><br>  No matter how loud this may sound, the process itself is fairly simple and was already known ( <a href="https://github.com/google/closure-stylesheets">for example</a> ), but is not very common due to the lack of convenient tools.  Everything changed with the advent of postcss and webpack.  Before turning to our implementation, let's take a look at how this works for others, for example, React and Angular2. <br><br><h3>  React + webpack </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> styles <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./button.css'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{styles.btn}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{styles.icon}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Icon</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.props.icon}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{styles.text}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{this.props.value}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">; } }</span></span></code> </pre><br><h3>  React + webpack + react-css-modules </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CSSModules <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-css-modules'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> styles <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./button.css'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">styleName</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">'btn'</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">styleName</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">'icon'</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Icon</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.props.icon}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">styleName</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">'text'</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{this.props.value}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">; } } export default CSSModules(Button, styles); @CSSModules(styles) export default class Button extends React.Component { // ... }</span></span></code> </pre><br><h3>  Angular2 </h3><br>  Unlike React, Angulyar supports the similarity of modularity out of the box.  By default, it adds specificity to all selectors as a unique attribute, but if you set a certain ‚Äúflag‚Äù, it will use shadow dom. <br><br><pre> <code class="javascript hljs">@Component({ <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: <span class="hljs-string"><span class="hljs-string">`my-app`</span></span>, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">`&lt;div class="app"&gt;{{text}}&lt;/div&gt;`</span></span>, <span class="hljs-attr"><span class="hljs-attr">styles</span></span>: [<span class="hljs-string"><span class="hljs-string">`.app { ... }`</span></span>] <span class="hljs-comment"><span class="hljs-comment">// .app[_ngcontent-mjn-1] { } }); export class App { // ‚Ä¶ }</span></span></code> </pre><br>  Our option is something in between, it is not necessary to specially prepare a template for it, just load the css and add it to the block description: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> feast <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'feast'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> template <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'feast-tpl!./button.html'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> styleSheet <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'feast-css!./button.css'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> feast.Block.extend({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'button'</span></span>, template, styleSheet, });</code> </pre><br>  In addition, there is still an experimental branch not just with the replacement of classes, but with full inline styles.  This can be useful for working on weak devices (TVs, etc.). <br><br>  Actually, the branch itself looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> file = <span class="hljs-string"><span class="hljs-string">"path/to/file.css"</span></span>; fetch(file) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> res.text()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cssText</span></span></span><span class="hljs-function"> =&gt;</span></span> toCSSModule(file, cssText)) .then(updateCSSModuleAndRerenderBlocks) ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toModule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file, cssText</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> exports = {}; cssText = cssText.replace(R_CSS_SELECTOR, (_, name) =&gt; { exports[name] = simpleHash(url + name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'.'</span></span> + exports[name]; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {file, cssText, exports}; }</code> </pre><br>  As you can see, absolutely no magic, everything is very trite: we get css as text, we find all the selectors, with the help of a simple algorithm, we consider hash and save to the object of export [the original name] =&gt; [new]. <br><br>  Well, the most interesting: JS, what's wrong with him? <br><br><h3>  JS / Hot Reload </h3><br>  Consider an example.  Suppose we have a class <code>Foo</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; } log() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Foo: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.value}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Foo); } }</code> </pre><br>  Further somewhere in the code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-number"><span class="hljs-number">123</span></span>); foo.log(); <span class="hljs-comment"><span class="hljs-comment">// "Foo: 123", true</span></span></code> </pre><br>  After that we decide to update the implementation on <code>NewFoo</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewFoo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; } log() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`NewFoo: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.value}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> NewFoo); } });</code> </pre><br>  Yes, so that the already created copies continue to work correctly. <br><br><pre> <code class="javascript hljs">foo.log(); <span class="hljs-comment"><span class="hljs-comment">// "NewFoo: 123", true foo instanceof Foo; // true</span></span></code> </pre><br>  To do this trick, you do not need preprocessing, pure enough JS: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OldClass, NewClass</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newProto = NewClass.prototype; OldClass.prototype.__proto__ = newProto; <span class="hljs-comment"><span class="hljs-comment">//    Object.keys(NewClass).forEach(name =&gt; { OldClass[name] = NewClass[name]; }); //    Object.getOwnPropertyNames(newProto).forEach(name =&gt; { OldClass.prototype[name] = newProto[name]; }); }</span></span></code> </pre><br>  Yes, that's the whole function, ten lines - and the JS Hot Reload is ready.  Nearly.  I deliberately did not overload this function, but showed only the essence.  In an amicable way, you need to still mark the old methods, which are no longer present, as unrequited. <br><br>  But there is a problem:] <br><br><pre> <code class="javascript hljs">replaceClass(Foo, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewFoo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>}); foo.constructor === Foo; <span class="hljs-comment"><span class="hljs-comment">// false (!!!)</span></span></code> </pre><br>  It can be solved in several ways: <br><br><ol><li>  Still using Webpack, it wraps the creation of a class in a special wrapper that returns and updates the class being created. </li><li>  Use binding to create classes, for example <code>createClass('MyClassName', {...});</code>  . </li><li>  You can also turn to Proxy, but you also need preprocessing here. </li></ol><br>  As a result, our scheme looks like this: <br><br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'file-changed:js'</span></span>, (data) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> updatedFile = data.file; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>(<span class="hljs-string"><span class="hljs-string">'define'</span></span>, data.content)(hotDefine); });</code> </pre><br>  <code>hotDefine</code> deals with all the magic: instead of the requested object (for example, feast) returns not the original, but the special <code>FeastHotUpdater</code> , which updates the implementation. <br><br><h3>  Code Analysis Tools </h3><br>  As I showed in the example, at the moment the main tool that allows you to inspect elements directly from the browser is the ‚Äúpipette‚Äù.  One of the nice features is opening the desired file in the IDE.  To do this, use the wonderful library of Roman Dvornov <a href="https://github.com/lahmatiy/open-in-editor">lahmatiy / open-in-editor</a> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> openInEditor = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'open-in-editor'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> editor = openInEditor.configure( {<span class="hljs-attr"><span class="hljs-attr">editor</span></span>: <span class="hljs-string"><span class="hljs-string">'phpstorm'</span></span>}, (err) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'Something went wrong: '</span></span> + err) ); editor.open(<span class="hljs-string"><span class="hljs-string">'path/to/file.js:3:10'</span></span>) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'[open-in-editor] Ooops:'</span></span>, err); });</code> </pre><br>  Roman also has a similar <a href="https://github.com/lahmatiy/component-inspector">component for inspection of React and Backbone</a> , which can do much more than mine, and it looks superbly.  ;] <br><div class="spoiler">  <b class="spoiler_title">Work example of component-inspector from Roman</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/12e/4d6/144/12e4d6144293691ef3ac601df9977612.gif" alt="image"></div></div><br>  Those who are well acquainted with React, Ember, Angular, Backbone, are well aware of such solutions as React Developer Tools, Ember Inspect, Batarand, Backbone Debugger, etc. These are all <a href="https://developer.chrome.com/devtools/docs/extensions-gallery">extensions to DevTools</a> for dissecting the situation. <br><br>  At first, I had exactly extensions in my plans, since the Chrome API has to do with it + there are examples, and all the extensions listed above are on github, so you can always see the implementation. <br><br>  But alas, you can not put the extension to the user, and we very often have to study the problems on the machines not only colleagues.  Therefore, while I focused on the tools through which you can get maximum information in the browser without reloading it.  This is where the charm of compiling templates on the client is revealed: you don‚Äôt need two assemblies (combat and dev), the assembly is always one, when debugging, you always get all the possible meta-information about the component. <br><br><h1>  What else? </h1><br><h3>  Logging </h3><br>  Bugs are always - it does not matter;  trouble, if you can not understand what happened before.  Therefore, we pay much attention to logging.  The ideal situation, if at any time you can open the console in battle and understand what happened after your actions. <br><br><img src="https://habrastorage.org/files/3ca/d9d/a82/3cad9da823a44c27bbeb797edd5d3296.png" alt="image"><br><br><h3>  Code coverage </h3><br>  For the most part, this is just an experiment, but it is quite possible to use it to check the quality of manual tests.  We take istanbul, run the code through it and roll it out onto test machines, then once every N seconds we drop the coverage into the log.  This is the simple way to see how well your scripts are written for testers, whether they cover the functionality. <br><br><div class="spoiler">  <b class="spoiler_title">Display example</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/14a/dee/9dc/14adee9dc5a247ab87bbfd107717b9c2.png" alt="image"><br><img src="https://habrastorage.org/files/3ca/c20/96f/3cac2096f1464c2da2fa3524caa11244.png" alt="image"><br></div></div><br><h3>  Application structure analysis </h3><br>  The farther, the more the application grows, branches, and once its structure becomes incomprehensible.  That was the first attempt;] <br><br><div class="spoiler">  <b class="spoiler_title">The first attempt to visualize the structure of the application</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d79/928/111/d79928111abe4496a9352eec511f8fe2.png" alt="image"><br></div></div><br>  I think the idea is clear: this tree is not just nesting of blocks, but also the conditions of cycles.        (,     ). <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><img src="https://habrastorage.org/files/fec/805/366/fec805366faf4729bd624ba625630980.png" alt="image"><br><img src="https://habrastorage.org/files/282/8f7/833/2828f7833c3e41deaee415ae602589af.png" alt="image"><br></div></div><br>      ,      ,     ;  ,     .      ‚Äî             (,   ,     ). <br><br><h3>  Timeline </h3><br>   ,   ,   , ‚Äî  DevTools Timeline.      ,    (, ,    . .).    ,       ,    .   timeline        (     ). <br><br><div class="spoiler"> <b class="spoiler_title">    dev-</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/0f4/0c5/026/0f40c50265b442b1bf7bb23f02a26757.png" alt="image"><br><img src="https://habrastorage.org/files/4df/50f/31c/4df50f31cd694db3bdefb1422c0810f8.png" alt="image"><br></div></div><br><h1>  Conclusion </h1><br>  ,    ,      ,  ,      , ‚Äì     .  ,     ¬´¬ª.      ,   bash-     .  ,    ,    ,   .   ,   ,    .   ,  React, Vue, Ember, Angular, ‚Äì   Live Coding,   Dev Tools   . ,  React      <a href="https://github.com/kadirahq/react-storybook">react-storybook</a> . <br><br> PS    . </div><p>Source: <a href="https://habr.com/ru/post/309212/">https://habr.com/ru/post/309212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309194/index.html">The game of digital wallets: the era of the Cold War between the West and the East</a></li>
<li><a href="../309196/index.html">Discussion of analytics tools for working with big data in St. Petersburg on September 14</a></li>
<li><a href="../309200/index.html">Android: a retractable bottom screen</a></li>
<li><a href="../309208/index.html">Chimeras of office telephony: talking about FMC</a></li>
<li><a href="../309210/index.html">Interpolation of closed curves</a></li>
<li><a href="../309214/index.html">Magic build project on WordPress using package managers and a file</a></li>
<li><a href="../309216/index.html">Huawei KunLun server - our testing</a></li>
<li><a href="../309218/index.html">STM32 USB Mass Storage Bootloader</a></li>
<li><a href="../309220/index.html">Blind programmer and forged chains</a></li>
<li><a href="../309222/index.html">How to build a simple Java program using Maven</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>