<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>High-performance code on the .NET platform</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello dear readers! 

 Not so long ago we started working on the book " Writing High-Performance .NET code ", which has not yet been translated into R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>High-performance code on the .NET platform</h1><div class="post__text post__text-html js-mediator-article">  Hello dear readers! <br><br>  Not so long ago we started working on the book " <a href="http://www.amazon.com/Writing-High-Performance-NET-Code-Watson/dp/0990583430/">Writing High-Performance .NET code</a> ", which has not yet been translated into Russian, although it will soon be a year. <br><br><img src="https://habrastorage.org/files/bd1/075/b17/bd1075b17eee4bdda8a14fa11325b5c9.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, we were not surprised that such a book was already being taken away for quotations, but it turned out that the respected author Ben Watson had even posted <a href="http://www.codeproject.com/Articles/812678/Performance-Considerations-of-Class-Design-and-Gen">an</a> entire <a href="http://www.codeproject.com/Articles/812678/Performance-Considerations-of-Class-Design-and-Gen">article</a> on the Codeproject website based on one of the chapters.  Unfortunately, the volume of this material is too large for habro-publication, however, we decided to still translate the first part of the article, so that you can evaluate the material of the book.  We invite you to read and to participate in the survey.  In addition, if it is still advisable to translate the second part - write in the comments, we will try to take into account your wishes. <br><a name="habracut"></a><br><br>  <b>Context</b> <br><br>  This article is based on Chapter 5 of my Writing High-Performance .NET Code book. <br><br>  <b>Introduction</b> <br><br>  The article describes the general principles of writing code and type design.  On the .NET platform, there are opportunities to implement various scenarios, and if some of them at best do not affect the performance in any way, there are those that seriously spoil it.  Certain scenarios are neither good nor bad, but just what they are.  We have to find the most appropriate solution for each situation. <br><br>  If I tried to formulate a general principle underlying this article, it would be this: <br><br>  <i><b>Deep performance optimization often violates software abstractions.</b></i> <br><br>  This means that when trying to achieve extremely high performance, we must understand the implementation details at all levels and, possibly, try to play on these intricacies.  Many of these details are described in this article. <br><br>  <b>Comparing classes and structures</b> <br><br>  Instances of a class are always allocated on the heap, and access to these instances is done by dereferencing a pointer.  Transmitting them is cheap, because we are talking only about a copy of the pointer (4 or 8 bytes).  However, the object also has some fixed costs: 8 bytes for 32-bit processes and 16 bytes for 64-bit processes.  These costs include a pointer to the method table plus a synchronization block field.  If you create a borderless object and view it in the debugger, then it turns out that in fact its size is not 8, but 12 bytes.  In the case of 64-bit processes, the object will be 24 bytes in size.  The fact is that the minimum size depends on the alignment of memory blocks.  Fortunately, these ‚Äúextra‚Äù 4 bytes will be used by the field. <br><br>  A <i>struct</i> does not incur any costs, and the size of the memory it uses is the sum of the sizes of all its fields.  If a <i>struct is</i> declared as a local variable in a method, then the <i>struct</i> is allocated on the stack.  If the <i>struct is</i> declared as part of a class, then the memory of the <i>struct</i> will be part of the memory fragment occupied by this class (and, therefore, on the heap).  If you pass a <i>struct to a</i> method, it will be copied byte by byte sequentially.  Since it is not on the heap, the allocation of the structure never initiates garbage collection. <br><br>  Consequently, there is a need to compromise.  You can meet various recommendations about the maximum size of the structure, but I would not be tied to a specific number.  As a rule, it is better to keep the size of a <i>struct</i> very small, especially if this structure is passed back and forth, but structures can also be passed by reference, so its size may not be a significant problem.  The only way to confidently determine whether such a technique would be useful is to look closely at the usage pattern and perform the profiling yourself. <br><br>  In some situations, the effectiveness may be very different.  Let the value of costs on a single object and it seems scanty, but try to consider an array of objects, and then compare it with an array of structures.  Suppose the data structure contains 16 bytes of data, the array length is 1,000,000, and we are working in a 32-bit system. <br><br>  For an array of objects, the total space consumption is: <br><br>  12 bytes of array costs + <br>  (pointer size 4 bytes √ó 1,000,000) + <br>  ((cost 8 bytes + 16 data bytes) √ó 1,000,000) <br>  = 28 MB <br><br>  For an array of structures we get a fundamentally different result: <br><br>  12 bytes of array costs + <br>  (16 bytes of data √ó 1,000,000) <br>  = 16 MB <br><br>  In the case of a 64-bit process, an array of objects takes up more than 40 MB, while an array of <i>struct</i> requires only 16 MB. <br><br>  As you can see, in a <i>struct</i> array, a similar amount of data takes up less memory than in an array of objects.  Together with the costs associated with the use of objects, you also get more intensive garbage collection, which is explained by the higher memory load. <br><br>  In addition to the use of space, there is also the issue of processor efficiency.  The processor has several levels of caching.  Those that are closest to the processor are very small, but they work extremely fast and are optimized for sequential access. <br><br>  The <i>struct</i> array contains multiple values, sequentially arranged in memory.  Accessing an element in a struct array is very simple.  Once the correct entry is found, we already have the correct value.  Thus, there can be a huge difference in access speed when searching a large array.  If the value is already in the processor cache, then it can be accessed an order of magnitude faster than if it is located in RAM. <br><br>  To access an object array element, you need to access the array's memory, and then dereference a pointer to this element, which can be located anywhere on the heap.  The search of object arrays is associated with dereferencing an additional pointer, ‚Äúhopping‚Äù along the heap, and relatively frequent emptying of the processor cache, which potentially leads to wasting more needed data. <br><br>  The absence of such costs, both at the processor level and in memory, is in many cases the main reason for preferring structures.  If used wisely, this technique can give a significant performance gain, as the memory locality improves. <br><br>  Since structures are always copied by value, you can inadvertently get into a more interesting position.  For example, the following code is written with errors and will not compile: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Point { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;Point&gt; points = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Point&gt;(); points.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point() { x = <span class="hljs-number"><span class="hljs-number">1</span></span>, y = <span class="hljs-number"><span class="hljs-number">2</span></span> }); points[<span class="hljs-number"><span class="hljs-number">0</span></span>].x = <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br><br>  The problem occurs in the last line that tries to change an existing <i>Point</i> in the list.  This is not possible, because calling <i>points [0</i> ] returns a copy of the original value, which is not stored anywhere else.  The correct way to change the <i>point is</i> : <br><br><pre> <code class="cs hljs">Point p = points[<span class="hljs-number"><span class="hljs-number">0</span></span>]; px = <span class="hljs-number"><span class="hljs-number">3</span></span>; points[<span class="hljs-number"><span class="hljs-number">0</span></span>] = p;</code> </pre><br><br>  However, it may be advisable to implement an even more stringent policy: to make structures immutable.  After creating the structure, such a structure will not be able to get a new value.  In this case, the situation described above becomes impossible in principle, all work with structures is simplified. <br><br>  It was mentioned above that the structures should be compact, so as not to spend a lot of time copying them, but sometimes you have to use large structures.  Consider an object in which a lot of details about a commercial process are tracked - for example, a lot of time stamps are put. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Order</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime ReceivedTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime AcknowledgeTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime ProcessBeginTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime WarehouseReceiveTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime WarehouseRunnerReceiveTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime WarehouseRunnerCompletionTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime PackingBeginTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime PackingEndTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime LabelPrintTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime CarrierNotifyTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime ProcessEndTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime EmailSentToCustomerTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime CarrerPickupTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-comment"><span class="hljs-comment">//    ... }</span></span></code> </pre><br><br>  To simplify the code, it would be nice to separate each of these labels into its own substructure, which will still be available through the code of the Order class as follows: <br><br><pre> <code class="cs hljs">Order order = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Order(); Order.Times.ReceivedTime = DateTime.UtcNow;</code> </pre><br><br>  All these substructures can be taken out in a separate class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OrderTimes</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime ReceivedTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime AcknowledgeTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime ProcessBeginTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime WarehouseReceiveTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime WarehouseRunnerReceiveTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime WarehouseRunnerCompletionTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime PackingBeginTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime PackingEndTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime LabelPrintTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime CarrierNotifyTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime ProcessEndTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime EmailSentToCustomerTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime CarrerPickupTime {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Order</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OrderTimes Times; }</code> </pre><br><br>  However, this additionally results in 12 or 24 bytes of costs for each <i>Order</i> object. <br><br>  If you need to transfer the entire <i>OrderTimes</i> object to different methods, then perhaps these costs are justified, but why not just pass a reference to the whole <i>Order</i> object?  If you have thousands of <i>Order</i> objects processed at the same time, this will lead to a significant increase in garbage collection.  In addition, additional dereferencing operations will be remembered. <br><br>  Try to make <i>OrderTimes a</i> better structure.  <i>Accessing</i> individual properties of the <i>OrderTimes</i> structure through the property of the <i>Order</i> object (for example, <i>order.Times.ReceivedTime</i> ) does not result in copying the structure (in .NET this probable script is specifically optimized).  Thus, the <i>OrderTimes</i> structure is essentially included in the memory section allocated for the <i>Order</i> class, as if there is no substructure here.  The code itself also becomes neater. <br><br>  Such a technique does not violate the principle of immutable structures, but the whole focus here is as follows: we treat the fields of the OrderTimes structure exactly as if they were fields of the Order object.  If you do not need to pass the OrderTimes structure as a whole entity, then the proposed mechanism is purely organizational. <br><br>  <b>Overriding Equals and GetHashCode methods for structures</b> <br><br>  When working with structures, it is extremely important to override the <i>Equals</i> and <i>GetHashCode</i> methods.  If you do not do this, you will get their default versions, which are not conducive to high performance.  To assess how bad it is, open the intermediate language viewer and take a look at the code for the <i>ValueType.Equals</i> method.  It is associated with reflection on all fields of the structure.  However, this is an optimization for binary compatible types.  A binary type (blittable) is a type that has the same memory representation in both managed and unmanaged code.  These include only primitive numeric types (for example, <i>Int32</i> , <i>UInt64</i> , but not <i>Decimal</i> , which is not primitive) and <i>IntPtr / UIntPtr</i> .  If a structure consists only of binary compatible types, then the Equals implementation can actually perform a byte-by-by-by-minute comparison of memory across the entire structure.  Just avoid such uncertainty and implement your own <i>Equals</i> method. <br><br>  If you simply redefine <i>Equals (object other)</i> , then you still get an unjustifiably poor performance, since this method is associated with casting and packing of value types.  Instead, implement <i>Equals (T other)</i> , where T is the type of your structure.  The IEquatable interface is designed for this, and all structures must implement it.  The compiler always gives preference to a more strictly typed version, if possible.  Consider an example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Vector : IEquatable&lt;Vector&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Magnitude { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.GetType() != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetType()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Equals((Vector)obj); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.X == other.X &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Y == other.Y &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Z == other.Z &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Magnitude == other.Magnitude; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X ^ Y ^ Z ^ Magnitude; } }</code> </pre><br><br>  If the type implements the IEquatable interface, then the generalized .NET collections will detect it and use it for more efficient searching and sorting. <br><br>  You may also decide to use the == and! = Operators with the types of your values ‚Äã‚Äãand force them to call the <i>existing Equals (T)</i> method <i>.</i> <br><br>  Even if you never compare structures or put them in a collection, I still recommend implementing these methods.  You will never guess how they will be used in the future, and it will take just a few minutes to write the methods and a few bytes of the intermediate language, which will never even require dynamic compilation. <br><br>  Overriding the <i>Equals</i> and <i>GetHashCode</i> methods of classes is not so important, because in this case they only calculate equality, based on the object reference.  If you think that your code will have enough of a standard implementation of these methods - do not change it. <br><br>  <b>Virtual methods and sealed classes</b> <br><br>  Do not make the methods virtual by default "just in case."  However, if virtual methods are required for a consistent design of your programs, then perhaps do not overdo them with their removal. <br><br>  If the methods are made virtual, this prevents certain optimizations from the dynamic compiler, in particular, it hinders the embedding of methods.  Methods can only be built in if the compiler is 100% aware of which method will be called.  Marking a method as virtual, we lose this certainty, although there are other factors that may force us to abandon such optimization. <br><br>  Virtualized classes are conceptually close to sealed classes, for example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> {}</code> </pre><br><br>  A class marked sealed declares that no other class can inherit from it. <br><br>  Theoretically, a dynamic compiler can use this information and be more actively involved in embedding, but this is not happening at the present time.  However, by default, classes should be declared sealed and non-default methods should be declared virtual if this is not necessary.  In this case, your code will be adapted to any actual optimizations of the dynamic compiler, as well as to those that are possible in the future. <br><br>  If you are writing a class library that is supposed to be used in a variety of situations, especially outside your organization, you should proceed more carefully.  In this case, the presence of a virtual API may be more important than bare performance ‚Äî so that your library is convenient for reuse and tuning.  But if the code is written for internal corporate needs and often changes, try to provide better performance. <br><br>  <b>Interface scheduling</b> <br><br>  When you call a method for the first time through an interface, .NET needs to determine which type and method to make the call to.  First, a call is made to the stub, which finds the method called when working with an object that implements this interface.  After this happens several times, the CLR ‚Äúlearns‚Äù that the same particular type is called all the time, and this indirect call through the stub is reduced to a stub consisting of just a few assembly instructions calling the desired method.  Such a group of instructions is called a ‚Äúmonomorphic stub‚Äù because it knows how to call a method for only one type.  This is ideal in situations where the place of the call always calls interface methods on the same type. <br><br>  A monomorphic stub also allows you to detect if something goes wrong.  If at some point the place of the call begins to use a method of another type, the CLR will eventually replace the stub with another monomorphic stub for a new type. <br><br>  If the situation is even more complicated, several types are involved in it, and it is less predictable (for example, there is an interface type array, but there are several specific types in this array), then the stub will turn into polymorphic and will use a hash table that allows you to choose which method cause  Table search is fast, but still not as much as when working with a monomorphic stub.  In addition, the size of such a hash table is strictly limited, and if you have too many types, you may have to roll back to the generalized type search code from the very beginning.  This operation can be very costly. <br><br>  If such a problem arises, it can be solved in one of two ways: <br><br><ol><li>  1. Avoid calling these objects through a common interface. </li><li>  2. Select a common base interface and replace it with an <i>abstract</i> base class. </li></ol><br><br>  This problem is not common, but it can happen if you have a huge hierarchy of types, they all implement a common interface, and you call methods through this common interface.  It can be noted that the processor works at the place where these methods are called so actively that it cannot be explained only by the work that the methods themselves do. <br><br>  <b>History</b> When designing a large system, we knew in advance that we might have thousands of different types, and all of them would come from a general type.  In a couple of places we should have a need to contact them from the base type.  Since our team had a person who understood the interface dispatch when solving problems of this magnitude, we decided to use the base class abstract, rather than the root interface. <br><br>  A good article on interface scheduling is in the Vans Morrison blog. <br><br>  <b>Avoid packing</b> <br><br>  Packaging is the process of wrapping a meaningful type, such as a primitive or structure, into an object on a heap.  In this form, this type can be passed to methods that require a reference to an object.  Unpacking is retrieving the original value. <br><br>  The processor time required for selecting, copying and casting an object is spent on packaging.  More importantly, however, garbage collection is activated on the heap.  If you carelessly treat the package, then the program may have a lot of allocation operations, and all of them will put additional strain on the garbage collector. <br>  Explicit packaging occurs whenever similar operations are performed: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> o = x;</code> </pre><br><br>  The intermediate language here looks like this: <br><br><pre> <code class="cs hljs">IL_0001: ldc.i4.s <span class="hljs-number"><span class="hljs-number">32</span></span> IL_0003: stloc<span class="hljs-number"><span class="hljs-number">.0</span></span> IL_0004: ldloc<span class="hljs-number"><span class="hljs-number">.0</span></span> IL_0005: box [mscorlib]System.Int32 IL_000a: stloc<span class="hljs-number"><span class="hljs-number">.1</span></span></code> </pre><br><br>  This means that it‚Äôs relatively easy to find most packaging sources in your code: just use ILDASM to convert your entire IL into text and search. <br><br>  A very common situation in which irregular packaging is possible is the use of an API that takes an <i>object</i> or <i>object []</i> as a parameter.  The most trivial of them are <i>String.Format</i> or traditional collections in which only references to objects are stored, and work with which must be completely avoided for one reason or another. <br><br>  In addition, packaging can occur when the structure is assigned to an interface, for example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">INameable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Foo : INameable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestBoxing</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Foo foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo() { Name = <span class="hljs-string"><span class="hljs-string">"Bar"</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ! INameable nameable = foo; ... }</span></span></code> </pre><br><br>  If you decide to test this code - note that if in fact you are not using a packaged variable, the compiler will simply remove the packing instruction in order of optimization, since it will not be used.  As soon as you call the method or use the value in some other way, the packing instruction will be in place. <br><br>  One more thing that happens when packing and that needs to be considered is the result of the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> boxedVal = val; val = <span class="hljs-number"><span class="hljs-number">14</span></span>;</code> </pre><br><br>  What will be the value of <i>boxedVal</i> after this? <br><br>  When packing, the value is copied, and there is no connection between the original and the copy.  For example, the value of <i>val</i> may change to 14, but <i>boxedVal will</i> retain the original value of 13. <br><br>  Sometimes packaging can be traced in the processor profile, but many packaging calls are simply embedded, and there is no reliable way to find them.  With excessive packaging, you will see in the processor profile only mass memory allocation with <i>new</i> . <br><br>  If you have to actively package structures, and you come to the conclusion that you cannot do without it, then you probably should just turn the structure into a class, which may turn out to be even cheaper. <br><br>  Finally, note: the transfer of a meaningful type by reference is not packaging.  Look at IL and make sure that no packaging takes place.  A valid type address is sent to the method. <br><br>  <b>Comparison for and foreach</b> <br><br>  Use the MeasureIt program to evaluate the difference between enumerating collections in <i>for</i> and <i>foreach</i> loops.  Working with standard <i>for</i> loops runs much faster in almost all cases.  However, if you try to conduct your own simple test, then, depending on the scenario, you may find that both cycles have approximately equal performance.  Indeed, in many situations, .NET converts simple foreach statements into standard for loops. <br><br>  Consider the <i>ForEachVsFor</i> project, which has the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.Length; i++) { arr[i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arr) { sum += val; } sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; arrEnum = arr; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arrEnum) { sum += val; }</code> </pre><br><br>  After collecting it, try decompiling this code with the IL reflection tool.  You will see that the first <i>foreach</i> is actually compiled as a <i>for</i> loop.  The intermediate language will be: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   (head: IL_0034) IL_0024: ldloc.s CS$6$0000 IL_0026: ldloc.s CS$7$0001 IL_0028: ldelem.i4 IL_0029: stloc.3 IL_002a: ldloc.2 IL_002b: ldloc.3 IL_002c: add IL_002d: stloc.2 IL_002e: ldloc.s CS$7$0001 IL_0030: ldc.i4.1 IL_0031: add IL_0032: stloc.s CS$7$0001 IL_0034: ldloc.s CS$7$0001 IL_0036: ldloc.s CS$6$0000 IL_0038: ldlen IL_0039: conv.i4 IL_003a: blt.s IL_0024 //  </span></span></code> </pre><br><br>  There are a lot of save, load, add and one branch operations - everything is quite simple. <br><br>  However, once we cast the array to IEnumerable and perform the same operation, the work is much more expensive: <br><br><pre> <code class="cs hljs">IL_0043: callvirt instance <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> [<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Collections</span></span>.<span class="hljs-title"><span class="hljs-title">Generic</span></span>.<span class="hljs-title"><span class="hljs-title">IEnumerator</span></span>`1&lt;!0&gt; <span class="hljs-title"><span class="hljs-title">class</span></span> [<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Collections</span></span>.<span class="hljs-title"><span class="hljs-title">Generic</span></span>.<span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>`1&lt;<span class="hljs-title"><span class="hljs-title">int32</span></span>&gt;::<span class="hljs-title"><span class="hljs-title">GetEnumerator</span></span>() <span class="hljs-title"><span class="hljs-title">IL_0048</span></span>: <span class="hljs-title"><span class="hljs-title">stloc</span></span>.<span class="hljs-title"><span class="hljs-title">s</span></span> <span class="hljs-title"><span class="hljs-title">CS</span></span>$5$0002 .<span class="hljs-title"><span class="hljs-title">try</span></span> { IL_004a: br.s IL_005a <span class="hljs-comment"><span class="hljs-comment">//   (head: IL_005a) IL_004c: ldloc.s CS$5$0002 IL_004e: callvirt instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1&lt;int32&gt;::get_Current() IL_0053: stloc.s val IL_0055: ldloc.2 IL_0056: ldloc.s val IL_0058: add IL_0059: stloc.2 IL_005a: ldloc.s CS$5$0002 IL_005c: callvirt instance bool [mscorlib]System.Collections.IEnumerator::MoveNext() IL_0061: brtrue.s IL_004c //   IL_0063: leave.s IL_0071 } //   .try finally { IL_0065: ldloc.s CS$5$0002 IL_0067: brfalse.s IL_0070 IL_0069: ldloc.s CS$5$0002 IL_006b: callvirt instance void [mscorlib]System.IDisposable::Dispose() IL_0070: endfinally } //  </span></span></code> </pre><br><br>  We have 4 virtual method calls, a try-finally block and (not shown here) memory allocation for a local enumerator variable that tracks the state of the enumeration.  Such an operation is much more expensive than a regular for loop: it uses more CPU time and more memory! <br><br>  Keep in mind that the basic data structure here is still an array, which means that you can use the <i>for</i> loop ‚Äî but we obfuscate it, bringing the type to the <i>IEnumerable</i> interface.  Here it is important to take into account the fact already mentioned at the beginning of the article: deep optimization of performance often goes against code abstractions.  So, <i>foreach</i> is a loop abstraction, <i>IEnumerable</i> is a collection abstraction.  Together they give this behavior, which excludes simple optimization using a <i>for</i> loop, sorting through an array. <br><br>  Cast <br><br>  In principle, casting should be avoided whenever possible.  Bringing often indicates poor-quality class design, but sometimes it is actually required.  So, we have to resort to casting when converting signed numbers to unsigned ones, for example, when we work with various third-party APIs.  Bringing objects should occur much less frequently. <br><br>  Bringing objects is never without cost, but the cost of such an operation can differ dramatically depending on the relationship between the objects.  Bringing an ancestor to the desired descendant is much more expensive than performing the inverse operation, and the cost of such an operation is higher, the larger the hierarchy.  Coercion to the interface is more expensive than casting to a specific type. <br><br>  Absolutely unacceptable wrong cast.  If it happens, you will get an <i>InvalidCastException</i> exception, the cost of which will be orders of magnitude <i>greater</i> than the "price" of the cast operation. <br><br>  See the <i>CastingPerf</i> project in the source code for this book, where the number of conversions of various types is noted. <br><br>  When I ran a test run on my computer, I got the following result: <br><br><pre> <code class="cs hljs">JIT (ignore): <span class="hljs-number"><span class="hljs-number">1.00</span></span>x No cast: <span class="hljs-number"><span class="hljs-number">1.00</span></span><span class="hljs-function"><span class="hljs-function">x Up </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gen</span></span></span><span class="hljs-function">): 1.00x Up </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gens</span></span></span><span class="hljs-function">): 1.00x Up </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gens</span></span></span><span class="hljs-function">): 1.00x Down </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gen</span></span></span><span class="hljs-function">): 1.25x Down </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gens</span></span></span><span class="hljs-function">): 1.37x Down </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gens</span></span></span><span class="hljs-function">): 1.37x Interface: 2.73x Invalid Cast: 14934.51x </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">success</span></span></span><span class="hljs-function">): 1.01x </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">failure</span></span></span><span class="hljs-function">): 2.60x </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">success</span></span></span><span class="hljs-function">): 2.00x </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">failure</span></span></span><span class="hljs-function">): 1.98x</span></span></code> </pre><br><br>  The 'is' operator is a cast, testing the result and returning a boolean value. <br><br>  The 'as' operator resembles the standard cast, but returns null if the cast does not work.  As can be seen from the above results, this operation is much faster than issuing an exception. <br>  Never use such a pattern where two casts are made: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Foo) { Foo f = (Foo)a; }</code> </pre><br><br>     'as'   ,     : <br><br><pre> <code class="cs hljs">Foo f = a <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Foo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ... }</code> </pre><br><br>       ,      . <br><br> <b></b> :        ,   <i>MemoryStream.Length</i>  <i>long</i> .  API,   ,      (   <i>MemoryStream.GetBuffer</i> ),   ,      int.  ,      <i>long</i> .       . </div><p>Source: <a href="https://habr.com/ru/post/260623/">https://habr.com/ru/post/260623/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260613/index.html">Electronics for the most beginners</a></li>
<li><a href="../260615/index.html">Editing Spatial Data in Leaflet</a></li>
<li><a href="../260617/index.html">Home server from scratch</a></li>
<li><a href="../260619/index.html">Google hunting season is open</a></li>
<li><a href="../260621/index.html">Multiple / Class Table Inheritance in Rails</a></li>
<li><a href="../260629/index.html">Digest news of the gaming industry</a></li>
<li><a href="../260631/index.html">We pump HP t5325 thin client</a></li>
<li><a href="../260633/index.html">What to tell at the training on service h. 1</a></li>
<li><a href="../260635/index.html">Matlab features for developing and testing mechanistic trading systems</a></li>
<li><a href="../260637/index.html">Retrospective development of Crash Bandicoot, or how the developers packed the whole game in 2MB RAM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>