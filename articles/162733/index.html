<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write a game in the style of tower defense</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tower Defense Genre is one of the most popular genres of games on iOS. The reason for this is a fun pastime, flavored with the construction of towers ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write a game in the style of tower defense</h1><div class="post__text post__text-html js-mediator-article">  Tower Defense Genre is one of the most popular genres of games on iOS.  The reason for this is a fun pastime, flavored with the construction of towers to create the last point of defense against hordes of monsters who are trying to break through this very defense. <br>  I present to your attention the translation of an article written by Pablo Ruiz, and found by me on the site <a href="http://www.raywenderlich.com/">raywenderlich.com</a> . <br>  This tutorial will show you how to create a tower defense game from scratch using Cocos2D. <br>  In the process, you will learn the following: <br><ul><li>  How to create waves of enemies and adjust the time of their appearance. </li><li>  How to make these enemies move at given points (waypoints). </li><li>  How to build towers on designated areas on the map. </li><li>  How to make towers shoot at enemies. </li><li>  How to visualize waypoints and attack radii of towers. </li></ul><br>  At the end of the lesson, you will have your own framework for creating games of this type, which you can expand by adding new types of enemies, towers and maps. <br>  To understand this lesson, you need a basic understanding of Cocos2D.  If you are a beginner, you can take a look at the easier lessons on <a href="http://www.raywenderlich.com/tutorials">Ray's website</a> . <br><a name="habracut"></a><br><h5>  View from the Ivory Tower </h5><br>  If you are not familiar with the genre, Tower Defense is a strategic game where a player buys and positions armed towers at strategic points to stop waves of enemies who are trying to reach the base and destroy it. <br>  Each subsequent wave of enemies is usually stronger than the previous one; this is achieved by increasing the resistance to your weapon and the ability to move faster.  The game ends when you have withstood all the waves of the enemies (Victory!), Or if the enemies got to the base and destroyed it (Loss!). <br>  Here is a screenshot of the game that we‚Äôll finish writing at the end of the lesson: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb1/f55/f16/cb1f55f16ffdc1395b7823fe192fce0b.png" alt="image"><br><br>  As you can see in the picture, enemies appear from the top left of the screen and follow the green route to the player‚Äôs base. <br>  Along the road are many platforms where the player can install a tower.  A player can buy exactly as many towers as gold reserves allow.  The attack radii of the towers are shown in the white circle, if the enemies are inside this circle, the tower will shoot at them until it is destroyed, or the enemies will not go beyond the attack radius. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Resource Preparation </h5><br>  A <a href="">starter project</a> has already been prepared for you, containing an empty Cocos2D template and most of the resources that we will use during the lesson. <br>  The start project contains the basic Cocos2D 1.1 template, which provides a working application containing HelloWorldLayer and a line in the middle of the screen.  We will not use HelloWorldLayer, because we will create our own interface, and yet this class is provided so that you are sure that everything works at this stage. <br>  Open the project in Xcode, compile and run it.  The text ‚ÄúHello World‚Äù has been removed from the project, so you just have to get a black screen and not get errors during the launch process. <br>  Take a look at the project structure.  Inside the TowerDefense folder you will find: <br><ul><li>  All classes used in the game </li><li>  Cocos2D Library Folder </li><li>  Resource folder with the necessary graphics and sounds </li></ul><br>  Now you can start customizing the map and create towers! <br><br><h5>  Installation of towers </h5><br>  First, add a background image to the scene.  Open the <b>HelloWorldLayer.m</b> class and add the following lines of code inside the ‚Äúif‚Äù clause in the init method: <br><br><pre><code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 -  self.isTouchEnabled = YES; CGSize wins = [CCDirector sharedDirector].winSize; // 2 -   CCSprite * background = [CCSprite spriteWithFile:@"Bg.png"]; [self addChild:background]; [background setPosition:ccp(wins.width/2,wins.height/2)];</span></span></code> </pre> <br>  The first line in section # 1 allows the layer to accept touch events.  The rest of the code in section # 2 adds a background sprite to our scene. <br>  The background image helps to see where the player can put the tower.  Now you need to set several points on the screen, touching which the player can build towers. <br>  To preserve the meaning of our actions, all points will be located in the ".plist" file, in which they can be easily changed.  <b>TowerPosition.plist</b> is located in the Resources folder and already contains several positions for building towers inside. <br>  Consider this file, you will find an array of dictionaries that contain only two keys: "x" and "y".  Each dictionary represents the position of the tower according to its coordinates on the screen.  Now you need to register this file and install the bases for the towers on the map. <br>  Open <b>HelloWorldLayer.h</b> and add the following variable (inside the curly braces after the <a href="https://habrahabr.ru/users/interface/" class="user_link">interface</a> line): <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> * towerBases;</code> </pre><br>  Make the following changes to <b>HelloWorldLayer.m</b> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//    "init" -(void)loadTowerPositions { NSString* plistPath = [[NSBundle mainBundle] pathForResource:@"TowersPosition" ofType:@"plist"]; NSArray * towerPositions = [NSArray arrayWithContentsOfFile:plistPath]; towerBases = [[NSMutableArray alloc] initWithCapacity:10]; for(NSDictionary * towerPos in towerPositions) { CCSprite * towerBase = [CCSprite spriteWithFile:@"open_spot.png"]; [self addChild:towerBase]; [towerBase setPosition:ccp([[towerPos objectForKey:@"x"] intValue],[[towerPos objectForKey:@"y"] intValue])]; [towerBases addObject:towerBase]; } } // init,      #2 // 3 -    [self loadTowerPositions]; // dealloc,     (  super) [towerBases release];</span></span></code> </pre></div></div><br>  Compile and run the application, you will see the squares on the sides of the road, they will serve as the base for the installation of towers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0b/6dc/107/d0b6dc107901f567f2703b3b161108ed.png" alt="image"><br><br>  Now these bases are ready, let's build some towers! <br>  First, open <b>HelloWorldLayer.h</b> and add the following line after closing the curly braces: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">retain</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> *towers;</code> </pre><br>  Synthesize the turret variable in <b>HelloWorldLayer.m</b> below the @implementation line: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@synthesize</span></span> towers;</code> </pre><br>  Then, create a new class that will represent the towers.  Add a new file from the iOS \ Cocoa Touch \ Objective-C template.  Name the class <b>Tower</b> , and make it a subclass of <b>CCNode</b> . <br>  Replace the contents of <b>Tower.h with the</b> following: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cocos2d.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"HelloWorldLayer.h"</span></span></span><span class="hljs-meta"> #define kTOWER_COST 300 @class HelloWorldLayer, Enemy; @interface Tower: CCNode { int attackRange; int damage; float fireRate; } @property (nonatomic,assign) HelloWorldLayer *theGame; @property (nonatomic,assign) CCSprite *mySprite; +(id)nodeWithTheGame:(HelloWorldLayer*)_game location:(CGPoint)location; -(id)initWithTheGame:(HelloWorldLayer *)_game location:(CGPoint)location; @end</span></span></code> </pre></div></div><br>  Then replace the contents of <b>Tower.m with</b> this: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Tower.h"</span></span></span><span class="hljs-meta"> @implementation Tower @synthesize mySprite,theGame; +(id) nodeWithTheGame:(HelloWorldLayer*)_game location:(CGPoint)location { return [[[self alloc] initWithTheGame:_game location:location] autorelease]; } -(id) initWithTheGame:(HelloWorldLayer *)_game location:(CGPoint)location { if( (self=[super init])) { theGame = _game; attackRange = 70; damage = 10; fireRate = 1; mySprite = [CCSprite spriteWithFile:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"tower.png"</span></span></span><span class="hljs-meta">]; [self addChild:mySprite]; [mySprite setPosition:location]; [theGame addChild:self]; [self scheduleUpdate]; } return self; } -(void)update:(ccTime)dt { } -(void)draw { glColor4f(255, 255, 255, 255); ccDrawCircle(mySprite.position, attackRange, 360, 30, false); [super draw]; } -(void)dealloc { [super dealloc]; } @end</span></span></code> </pre></div></div><br>  The class of towers contains several variables: the sprite is a visual representation of the tower, a link to the parent layer for easy access and three variables: <br><ul><li>  attackRange: determines the distance from which towers can attack enemies </li><li>  damage: determines how much damage the tower deals to enemies </li><li>  fireRate: determines how long the towers need to reload </li></ul><br>  With these three variables, you can create a huge variety of types of towers with different types of attacks.  And finally, the code contains a method for drawing the attack radius of the tower for ease of testing. <br>  It is time to allow the player to add towers! <br>  Open <b>HelloWorldLayer.m</b> and make the following changes: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  : #import "Tower.h" //dealloc: [towers release]; //  dealloc   : -(BOOL)canBuyTower { return YES; } - (void)ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { for( UITouch *touch in touches ) { CGPoint location = [touch locationInView: [touch view]]; location = [[CCDirector sharedDirector] convertToGL: location]; for(CCSprite * tb in towerBases) { if([self canBuyTower] &amp;&amp; CGRectContainsPoint([tb boundingBox],location) &amp;&amp; !tb.userData) { //    . Tower * tower = [Tower nodeWithTheGame:self location:tb.position]; [towers addObject:tower]; tb.userData = tower; } } } }</span></span></code> </pre></div></div><br>  <b>ccTouchesBegan</b> : captures the touch screen.  The code then iterates through the towerBases array and checks to see if any of the tower bases contains a touch point. <br>  But before the towers can be made, you have to check two things: <br><ol><li>  Can a player allow such pleasure?  The canBuyTower method will check if the user has enough gold to buy a tower.  Although, at the moment, the player has all the gold of Fort Knox and the method will always return YES. </li><li>  Does the player break the construction rules?  If tb.UserData is set, then the tower is already at that place and you cannot build a new one. </li></ol><br>  If all conditions are met, a new tower is created, installed on the base and added to the array of towers. <br>  Compile and run the game.  Touch any base and you will see that a tower is added with a white circle around it, showing the range of its attack. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/abf/e3e/846/abfe3e8467d6cfb3db0b1458d22267cb.png" alt="image"><br>  But why all this weapons without the "bad guys", let's call them to the party! <br><br><h5>  Game Policy: Enemies, Waves and Waypoints </h5><br>  Before creating enemies, let's pave the way for them.  Enemies will follow the route from the waypoints, which are essentially points connected to each other and determine the path of the enemies in your world.  Enemies will appear on the first waypoint, search for the next one in the list, move towards it, and repeat this until they reach the last ‚Äî your base!  If this happens, you will suffer damage. <br>  Create a list of waypoints by creating a new file from the iOS \ Cocoa Touch \ Objective-C class template.  Name the class <b>Waypoint</b> and make it a subclass of <b>CCNode</b> . <br>  Replace the contents of <b>Waypoint.h with the</b> following: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cocos2d.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"HelloWorldLayer.h"</span></span></span><span class="hljs-meta"> @interface Waypoint: CCNode { HelloWorldLayer *theGame; } @property (nonatomic,readwrite) CGPoint myPosition; @property (nonatomic,assign) Waypoint *nextWaypoint; +(id)nodeWithTheGame:(HelloWorldLayer*)_game location:(CGPoint)location; -(id)initWithTheGame:(HelloWorldLayer *)_game location:(CGPoint)location; @end</span></span></code> </pre></div></div><br>  Next, replace the contents of <b>Waypoint.m</b> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Waypoint.h"</span></span></span><span class="hljs-meta"> @implementation Waypoint @synthesize myPosition, nextWaypoint; +(id)nodeWithTheGame:(HelloWorldLayer*)_game location:(CGPoint)location { return [[[self alloc] initWithTheGame:_game location:location] autorelease]; } -(id)initWithTheGame:(HelloWorldLayer *)_game location:(CGPoint)location { if( (self=[super init])) { theGame = _game; [self setPosition:CGPointZero]; myPosition = location; [theGame addChild:self]; } return self; } -(void)draw { glColor4f(0, 255, 0, 255); ccDrawCircle(myPosition, 6, 360, 30, false); ccDrawCircle(myPosition, 2, 360, 30, false); if(nextWaypoint) ccDrawLine(myPosition, nextWaypoint.myPosition); [super draw]; } -(void)dealloc { [super dealloc]; } @end</span></span></code> </pre></div></div><br>  First, the code creates a waypoint object, referring to the HelloWorldLayer object and defining a CGPoint, which is the waypoint position. <br>  Each waypoint contains a link to the next one, this creates a linked list of waypoints.  Each waypoint ‚Äúknows‚Äù the next one in the list. In this way, you can lead your enemies to their final goal by moving along the waypoint chain. <br>  At the end, the drawing method shows us where the waypoints are and draws a connection line between them, for testing purposes. <br>  Create a list of waypoints.  Open <b>HelloWorldLayer.h</b> and add the following variable: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">retain</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> *waypoints;</code> </pre><br>  Add the following code to <b>HelloWorldLayer.m</b> : <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//   : #import "Waypoint.h" //  synthesise @synthesize waypoints; //    init -(void)addWaypoints { waypoints = [[NSMutableArray alloc] init]; Waypoint * waypoint1 = [Waypoint nodeWithTheGame:self location:ccp(420,35)]; [waypoints addObject:waypoint1]; Waypoint * waypoint2 = [Waypoint nodeWithTheGame:self location:ccp(35,35)]; [waypoints addObject:waypoint2]; waypoint2.nextWaypoint =waypoint1; Waypoint * waypoint3 = [Waypoint nodeWithTheGame:self location:ccp(35,130)]; [waypoints addObject:waypoint3]; waypoint3.nextWaypoint =waypoint2; Waypoint * waypoint4 = [Waypoint nodeWithTheGame:self location:ccp(445,130)]; [waypoints addObject:waypoint4]; waypoint4.nextWaypoint =waypoint3; Waypoint * waypoint5 = [Waypoint nodeWithTheGame:self location:ccp(445,220)]; [waypoints addObject:waypoint5]; waypoint5.nextWaypoint =waypoint4; Waypoint * waypoint6 = [Waypoint nodeWithTheGame:self location:ccp(-40,220)]; [waypoints addObject:waypoint6]; waypoint6.nextWaypoint =waypoint5; } //    init: // 4 - Add waypoints [self addWaypoints]; // dealloc [waypoints release];</span></span></code> </pre></div></div><br>  Compile and run the game: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/da3/f92/418/da3f92418415da20b0f9b0026f9a7db2.png" alt="image"><br><br>  There are six waypoints on the map, the enemies will follow this path.  Before you let your friends lose the game, you need to add a few helper methods. <br>  First, add a description of the methods to the header file so that other classes can use these methods without warning from the compiler. <br>  Open <b>HelloWorldLayer.h</b> and add the following method descriptions before the " <a href="https://habrahabr.ru/users/end/" class="user_link">end</a> " line: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">-(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)circle:(<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>)circlePoint withRadius:(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)radius collisionWithCircle:(<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>)circlePointTwo collisionCircleRadius:(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)radiusTwo; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ccFillPoly(<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> *poli, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> points, <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> closePolygon);</code> </pre><br>  Next, open <b>HelloWorldLayer.m</b> and add the following lines to the end of the file (before the <a href="https://habrahabr.ru/users/end/" class="user_link">end</a> ): <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ccFillPoly( <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> *poli, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> points, <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> closePolygon ) { <span class="hljs-comment"><span class="hljs-comment">//   GL: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY //  : GL_VERTEX_ARRAY, //  : GL_TEXTURE_2D, GL_TEXTURE_COORD_ARRAY, GL_COLOR_ARRAY glDisable(GL_TEXTURE_2D); glDisableClientState(GL_TEXTURE_COORD_ARRAY); glDisableClientState(GL_COLOR_ARRAY); glVertexPointer(2, GL_FLOAT, 0, poli); if( closePolygon ) glDrawArrays(GL_TRIANGLE_FAN, 0, points); else glDrawArrays(GL_LINE_STRIP, 0, points); // restore default state glEnableClientState(GL_COLOR_ARRAY); glEnableClientState(GL_TEXTURE_COORD_ARRAY); glEnable(GL_TEXTURE_2D); } -(BOOL)circle:(CGPoint) circlePoint withRadius:(float) radius collisionWithCircle:(CGPoint) circlePointTwo collisionCircleRadius:(float) radiusTwo { float xdif = circlePoint.x - circlePointTwo.x; float ydif = circlePoint.y - circlePointTwo.y; float distance = sqrt(xdif*xdif+ydif*ydif); if(distance &lt;= radius+radiusTwo) return YES; return NO; }</span></span></code> </pre></div></div><br>  The collisionWithCircle method will help us figure out when two circles collide or intersect.  This will help to understand whether the enemy has reached a waypoint, as well as to identify the enemies within the attack radius of the tower. <br>  The ccFillPoly method draws filled polygons using OpenGL.  In Cocos2d, you can only draw unfilled polygons.  The ccFillPoly method will be used to draw stripes of enemies' health. <br>  It's time to release the enemies. <br>  Open <b>HelloWorldLayer.h</b> and add the following code: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//    int wave; CCLabelBMFont *ui_wave_lbl; //    property @property (nonatomic,retain) NSMutableArray *enemies;</span></span></code> </pre><br>  Make the following changes to <b>HelloWorldLayer.m</b> : <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// Synthesize enemies @synthesize enemies; //  dealloc [enemies release];</span></span></code> </pre></div></div><br>  It's time to create a class that will contain all the information about the enemies and control their movement around the screen.  Create a new iOS \ Cocoa Touch \ Objective-C file.  Name the class <b>Enemy</b> and make it a subclass of <b>CCNode</b> . <br>  Replace the contents of <b>Enemy.h</b> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cocos2d.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"HelloWorldLayer.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameConfig.h"</span></span></span><span class="hljs-meta"> @class HelloWorldLayer, Waypoint, Tower; @interface Enemy: CCNode { CGPoint myPosition; int maxHp; int currentHp; float walkingSpeed; Waypoint *destinationWaypoint; BOOL active; } @property (nonatomic,assign) HelloWorldLayer *theGame; @property (nonatomic,assign) CCSprite *mySprite; +(id)nodeWithTheGame:(HelloWorldLayer*)_game; -(id)initWithTheGame:(HelloWorldLayer *)_game; -(void)doActivate; -(void)getRemoved; @end</span></span></code> </pre></div></div><br>  Now the contents of <b>Enemy.m</b> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Enemy.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Tower.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Waypoint.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SimpleAudioEngine.h"</span></span></span><span class="hljs-meta"> #define HEALTH_BAR_WIDTH 20 #define HEALTH_BAR_ORIGIN -10 @implementation Enemy @synthesize mySprite, theGame; +(id)nodeWithTheGame:(HelloWorldLayer*)_game { return [[[self alloc] initWithTheGame:_game] autorelease]; } -(id)initWithTheGame:(HelloWorldLayer *)_game { if ((self=[super init])) { theGame = _game; maxHp = 40; currentHp = maxHp; active = NO; walkingSpeed = 0.5; mySprite = [CCSprite spriteWithFile:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"enemy.png"</span></span></span><span class="hljs-meta">]; [self addChild:mySprite]; Waypoint * waypoint = (Waypoint *)[theGame.waypoints objectAtIndex:([theGame.waypoints count]-1)]; destinationWaypoint = waypoint.nextWaypoint; CGPoint pos = waypoint.myPosition; myPosition = pos; [mySprite setPosition:pos]; [theGame addChild:self]; [self scheduleUpdate]; } return self; } -(void)doActivate { active = YES; } -(void)update:(ccTime)dt { if(!active)return; if([theGame circle:myPosition withRadius:1 collisionWithCircle:destinationWaypoint.myPosition collisionCircleRadius:1]) { if(destinationWaypoint.nextWaypoint) { destinationWaypoint = destinationWaypoint.nextWaypoint; }else { //  .    [theGame getHpDamage]; [self getRemoved]; } } CGPoint targetPoint = destinationWaypoint.myPosition; float movementSpeed = walkingSpeed; CGPoint normalized = ccpNormalize(ccp(targetPoint.x-myPosition.x,targetPoint.y-myPosition.y)); mySprite.rotation = CC_RADIANS_TO_DEGREES(atan2(normalized.y,-normalized.x)); myPosition = ccp(myPosition.x+normalized.x * movementSpeed,myPosition.y+normalized.y * movementSpeed); [mySprite setPosition:myPosition]; } -(void)getRemoved { [self.parent removeChild:self cleanup:YES]; [theGame.enemies removeObject:self]; //              [theGame enemyGotKilled]; } -(void)draw { glColor4f(255, 0, 0, 255); CGPoint healthBarBack[] = {ccp(mySprite.position.x -10,mySprite.position.y+16),ccp(mySprite.position.x+10,mySprite.position.y+16),ccp(mySprite.position.x+10,mySprite.position.y+14),ccp(mySprite.position.x-10,mySprite.position.y+14)}; ccFillPoly(healthBarBack, 4, YES); glColor4f(0, 255, 0, 255); CGPoint healthBar[] = {ccp(mySprite.position.x + HEALTH_BAR_ORIGIN,mySprite.position.y+16),ccp(mySprite.position.x+HEALTH_BAR_ORIGIN+(float)(currentHp * HEALTH_BAR_WIDTH) / maxHp,mySprite.position.y+16),ccp(mySprite.position.x+HEALTH_BAR_ORIGIN+(float)(currentHp * HEALTH_BAR_WIDTH) / maxHp,mySprite.position.y+14),ccp(mySprite.position.x+HEALTH_BAR_ORIGIN,mySprite.position.y+14)}; ccFillPoly(healthBar, 4, YES); } -(void)dealloc { [super dealloc]; } @end</span></span></code> </pre></div></div><br>  This is an impressive piece of code, but it is easy to understand.  An enemy is created first when HelloWorldLayer refers to it.  Inside the init method are several important variables: <br><ul><li>  maxHP: determines how many blows the enemy can withstand. </li><li>  walkingSpeed: determines how fast the enemy is moving </li><li>  mySprite: stores the visual representation of the enemy (sprite) </li><li>  destinationWaypoint: stores the link to the next waypoint </li></ul><br>  The update method is called every frame, first we check if the enemy has reached the next waypoint using the collisionWithCircle method we described earlier.  If this happens, we send it to the next one and so on until it reaches the last waypoint, then we inflict damage to the player. <br>  Movement of the sprite along a straight line from one waypoint to another, according to the speed of movement, is achieved by the following algorithm: <br><ul><li>  The vector running from the current position to the target is calculated, it is assigned the value 1, for convenience of work (normalized variable). </li><li>  The normalized vector is multiplied by the speed of movement, to calculate the number of paths to overcome in a given frame.  He is assigned the current position for the next one. </li></ul><br>  Finally, the render method creates a health bar above the sprite.  Initially, he draws a red background, then covers it with green, according to the current HP number of the enemy. <br>  The class of enemies is ready, you can show them on the screen! <br>  Open <b>HelloWorldLayer.h</b> and add the following method description: <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)enemyGotKilled;</code> </pre><br>  Switch to <b>HelloWorldLayer.m</b> and describe the method: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// : #import "Enemy.h" //  init: -(BOOL)loadWave { NSString* plistPath = [[NSBundle mainBundle] pathForResource:@"Waves" ofType:@"plist"]; NSArray * waveData = [NSArray arrayWithContentsOfFile:plistPath]; if(wave &gt;= [waveData count]) { return NO; } NSArray * currentWaveData =[NSArray arrayWithArray:[waveData objectAtIndex:wave]]; for(NSDictionary * enemyData in currentWaveData) { Enemy * enemy = [Enemy nodeWithTheGame:self]; [enemies addObject:enemy]; [enemy schedule:@selector(doActivate) interval:[[enemyData objectForKey:@"spawnTime"]floatValue]]; } wave++; [ui_wave_lbl setString:[NSString stringWithFormat:@"WAVE: %d",wave]]; return YES; } -(void)enemyGotKilled { if ([enemies count]&lt;=0) //If there are no more enemies. { if(![self loadWave]) { NSLog(@"You win!"); [[CCDirector sharedDirector] replaceScene:[CCTransitionSplitCols transitionWithDuration:1 scene:[HelloWorldLayer scene]]]; } } } //   init: // 5 -   enemies = [[NSMutableArray alloc] init]; [self loadWave]; // 6 -      ui_wave_lbl = [CCLabelBMFont labelWithString:[NSString stringWithFormat:@"WAVE: %d",wave] fntFile:@"font_red_14.fnt"]; [self addChild:ui_wave_lbl z:10]; [ui_wave_lbl setPosition:ccp(400,wins.height-12)]; [ui_wave_lbl setAnchorPoint:ccp(0,0.5)];</span></span></code> </pre></div></div><br>  Everything written above is worthy of an explanation.  The most important part is the LoadWave method;  it reads data from the <b>Waves.plist</b> . <br>  Take a look at the <b>Waves.plist</b> and you will notice that it contains 3 arrays.  Each of them represents a wave, which is a group of enemies appearing together.  The first array contains six dictionaries.  Each dictionary represents an enemy.  In this lesson, the dictionary stores only the time of appearance of the enemy, but may contain the type of enemy, his abilities, health, etc. <br>  The loadWave method checks whether the next wave should appear, creates corresponding enemies based on the information about the wave, and lists their appearance time accordingly. <br>  The enemyGotKilled method checks the number of enemies on the screen, if they are not there, calls the next wave.  Later the same method will be used to verify the player‚Äôs victory. <br>  Compile and run the game now.  Enemies are moving to your base! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/923/c8b/cb5/923c8bcb528d2c83c4d8442ab02f265d.png" alt="image"><br><br><h5>  Attack of the towers </h5><br>  Towers in place?  Check it out.  Enemies moving?  Check back!  It's time to overwhelm these insolent. <br>  Each tower checks if there is an enemy within its range.  If so, the tower begins to shoot at him, until one of two things happens: the enemy will go beyond the reach, or the enemy will be destroyed.  Then the tower will begin to search for a new victim. <br>  Let's start to protect the base! <br>  Open <b>Tower.h</b> and make the following changes: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//    BOOL attacking; Enemy *chosenEnemy; //    -(void)targetKilled;</span></span></code> </pre><br>  Now in <b>Tower.m</b> : <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//   Enemy  #import "Enemy.h" //     init: -(void)attackEnemy { [self schedule:@selector(shootWeapon) interval:fireRate]; } -(void)chosenEnemyForAttack:(Enemy *)enemy { chosenEnemy = nil; chosenEnemy = enemy; [self attackEnemy]; [enemy getAttacked:self]; } -(void)shootWeapon { CCSprite * bullet = [CCSprite spriteWithFile:@"bullet.png"]; [theGame addChild:bullet]; [bullet setPosition:mySprite.position]; [bullet runAction:[CCSequence actions:[CCMoveTo actionWithDuration:0.1 position:chosenEnemy.mySprite.position],[CCCallFunc actionWithTarget:self selector:@selector(damageEnemy)],[CCCallFuncN actionWithTarget:self selector:@selector(removeBullet:)], nil]]; } -(void)removeBullet:(CCSprite *)bullet { [bullet.parent removeChild:bullet cleanup:YES]; } -(void)damageEnemy { [chosenEnemy getDamaged:damage]; } -(void)targetKilled { if(chosenEnemy) chosenEnemy =nil; [self unschedule:@selector(shootWeapon)]; } -(void)lostSightOfEnemy { [chosenEnemy gotLostSight:self]; if(chosenEnemy) chosenEnemy =nil; [self unschedule:@selector(shootWeapon)]; }</span></span></code> </pre></div></div><br>  Finally, replace the empty update method with: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)update:(ccTime)dt { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chosenEnemy){ <span class="hljs-comment"><span class="hljs-comment">//       CGPoint normalized = ccpNormalize(ccp(chosenEnemy.mySprite.position.x-mySprite.position.x,chosenEnemy.mySprite.position.y-mySprite.position.y)); mySprite.rotation = CC_RADIANS_TO_DEGREES(atan2(normalized.y,-normalized.x))+90; if(![theGame circle:mySprite.position withRadius:attackRange collisionWithCircle:chosenEnemy.mySprite.position collisionCircleRadius:1]) { [self lostSightOfEnemy]; } } else { for(Enemy * enemy in theGame.enemies) { if([theGame circle:mySprite.position withRadius:attackRange collisionWithCircle:enemy.mySprite.position collisionCircleRadius:1]) { [self chosenEnemyForAttack:enemy]; break; } } } }</span></span></code> </pre></div></div><br>  The code is a lot of it.  Plus, you probably noticed an increasing number of warnings from the compiler as you add code.  First, let's deal with the warnings, adding a few missing bits. <br>  Open <b>Enemy.h</b> and make the following changes: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  NSMutableArray *attackedBy; //    -(void)getAttacked:(Tower *)attacker; -(void)gotLostSight:(Tower *)attacker; -(void)getDamaged:(int)damage;</span></span></code> </pre></div></div><br>  Now in <b>Enemy.m</b> : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="nginx hljs">//     initWithTheGame: (  "if") <span class="hljs-attribute"><span class="hljs-attribute">attackedBy</span></span> = [[NSMutableArray alloc] initWithCapacity:<span class="hljs-number"><span class="hljs-number">5</span></span>]; //   getRemoved: -(void)<span class="hljs-section"><span class="hljs-section">getRemoved</span></span> { for(<span class="hljs-attribute"><span class="hljs-attribute">Tower</span></span> * attacker in attackedBy) { [<span class="hljs-attribute"><span class="hljs-attribute">attacker</span></span> targetKilled]; } [self.<span class="hljs-attribute"><span class="hljs-attribute">parent</span></span> removeChild:self cleanup:YES]; [theGame.<span class="hljs-attribute"><span class="hljs-attribute">enemies</span></span> removeObject:self]; // ,       ,      [<span class="hljs-attribute"><span class="hljs-attribute">theGame</span></span> enemyGotKilled]; } //       -(void)getAttacked:(<span class="hljs-attribute"><span class="hljs-attribute">Tower</span></span> *)attacker { [<span class="hljs-attribute"><span class="hljs-attribute">attackedBy</span></span> addObject:attacker]; } -(void)gotLostSight:(<span class="hljs-attribute"><span class="hljs-attribute">Tower</span></span> *)attacker { [<span class="hljs-attribute"><span class="hljs-attribute">attackedBy</span></span> removeObject:attacker]; } -(void)getDamaged:(int)<span class="hljs-section"><span class="hljs-section">damage</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">currentHp</span></span> -=damage; if(<span class="hljs-attribute"><span class="hljs-attribute">currentHp</span></span> &lt;=<span class="hljs-number"><span class="hljs-number">0</span></span>) { [<span class="hljs-attribute"><span class="hljs-attribute">self</span></span> getRemoved]; } }</code> </pre></div></div><br>  The most important part in the code is the update method in the Tower class.  The tower will constantly check for the presence of the enemy within the radius of attack.  If there is one, the tower turns to it and starts shooting. <br>  As soon as the enemy is marked as a target, the method sets the shooting schedule of the tower according to its rate of fire.  Each enemy contains a list of towers firing at him, if the enemy dies, they will all be notified of this fact and stop shooting. <br>  Compile and run your application.  Arrange several towers on the map.  You will see how the towers start firing at enemies passing inside their radius, as the stripes of their health change until they die. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/603/698/a11/603698a11b40523235396cb63f1d5471.png" alt="image"><br><br>  It remains to add a few details to get the finished version of tower defense.  It would be nice to add sound effects, teach the base to take damage from enemies and limit the amount of player's gold. <br><br><h5>  Final touches </h5><br>  Let's start with the display of the number of lives left to the player, and what will happen when they run out! <br>  Open <b>HelloWorldLayer.h</b> and add the following variables: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> playerHp; CCLabelBMFont *ui_hp_lbl; <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> gameEnded;</code> </pre><br> playerHp     ,  CCLabelBMFont  ,    . gameEnded ,   !     : <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)getHpDamage; -(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)doGameOver;</code> </pre><br>   <b>HelloWorldLayer.m</b>    : <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//    init: // 7 -   playerHp = 5; ui_hp_lbl = [CCLabelBMFont labelWithString:[NSString stringWithFormat:@"HP: %d",playerHp] fntFile:@"font_red_14.fnt"]; [self addChild:ui_hp_lbl z:10]; [ui_hp_lbl setPosition:ccp(35,wins.height-12)]; //      : -(void)getHpDamage { playerHp--; [ui_hp_lbl setString:[NSString stringWithFormat:@"HP: %d",playerHp]]; if (playerHp &lt;=0) { [self doGameOver]; } } -(void)doGameOver { if (!gameEnded) { gameEnded = YES; [[CCDirector sharedDirector] replaceScene:[CCTransitionRotoZoom transitionWithDuration:1 scene:[HelloWorldLayer scene]]]; } }</span></span></code> </pre></div></div><br>   ,     ,    ,     .  ,  ! <br>  getHpDamage ,    .       <b>update</b>   <b>Enemy.m</b> . <br>    .      .   ,     ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/153/14d/cdf/15314dcdf7f5f5df3934d6d017bf94f0.png" alt="image"><br><br>    ! <br>     ‚Äúzero-sum‚Äù,          .      ,    . <br>  <b>HelloWorldLayer.h</b>    : <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> playerGold; CCLabelBMFont *ui_gold_lbl;</code> </pre><br>    ,     (playerGold)     (ui_gold_lbl).     : <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)awardGold:(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)gold;</code> </pre><br>   <b>HelloWorldLayer.m</b>   : <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//   init: -(void)awardGold:(int)gold { playerGold += gold; [ui_gold_lbl setString:[NSString stringWithFormat:@"GOLD: %d",playerGold]]; } //   init: // 8 -  playerGold = 1000; ui_gold_lbl = [CCLabelBMFont labelWithString:[NSString stringWithFormat:@"GOLD: %d",playerGold] fntFile:@"font_red_14.fnt"]; [self addChild:ui_gold_lbl z:10]; [ui_gold_lbl setPosition:ccp(135,wins.height-12)]; [ui_gold_lbl setAnchorPoint:ccp(0,0.5)]; //  canBuyTower: -(BOOL)canBuyTower { if (playerGold - kTOWER_COST &gt;=0) return YES; return NO; } //  ccTouchesBegan,      "if",    ,     : playerGold -= kTOWER_COST; [ui_gold_lbl setString:[NSString stringWithFormat:@"GOLD: %d",playerGold]];</span></span></code> </pre></div></div><br>    ,     ,    .  ,  ,       .       . <br>      <b>getDamaged:</b> (  ‚Äúif‚Äù)  <b>Enemy.m</b> : <br><br><pre> <code class="objectivec hljs">[theGame awardGold:<span class="hljs-number"><span class="hljs-number">200</span></span>];</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start the game and you will see that you can build exactly as many towers as gold reserves allow. </font><font style="vertical-align: inherit;">For killing enemies, gold is added. </font><font style="vertical-align: inherit;">A delightful system, is it not? </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b4/73a/e0f/3b473ae0f52a6e9c5142f16a77cf742a.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally add some music! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HelloWorldLayer.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  : #import "SimpleAudioEngine.h" //   init: (  'if') [[SimpleAudioEngine sharedEngine] playBackgroundMusic:@"8bitDungeonLevel.mp3" loop:YES]; //  ccTouchesBegan,     Tower: [[SimpleAudioEngine sharedEngine] playEffect:@"tower_place.wav"]; //  getHpDamage [[SimpleAudioEngine sharedEngine] playEffect:@"life_lose.wav"];</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enemy.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// : #import "SimpleAudioEngine.h" //   getDamaged: [[SimpleAudioEngine sharedEngine] playEffect:@"laser_shoot.wav"];</span></span></code> </pre></div></div><br>  Everything!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You are done! </font><font style="vertical-align: inherit;">Run the game, how do you get retro sounds ?! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sample project with everything we did above: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TowerDefenseFinished.zip</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/162733/">https://habr.com/ru/post/162733/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../162723/index.html">As I did the budget amplifier on the TDA2050 for old speakers</a></li>
<li><a href="../162725/index.html">Constructing fractal shapes in Matlab</a></li>
<li><a href="../162727/index.html">Logic - weekly selection of gaming and IT industry news ‚Ññ5</a></li>
<li><a href="../162729/index.html">Systematics of prokaryotes - distant relatives</a></li>
<li><a href="../162731/index.html">Developers Studyapps raised $ 200,000 on Napartner startups</a></li>
<li><a href="../162735/index.html">gps.conf for everyone, or how to speed up GPS on Android</a></li>
<li><a href="../162737/index.html">Stellaris LaunchPad Short Review</a></li>
<li><a href="../162739/index.html">Analysis of statistics in free-to-play games: analytics tools</a></li>
<li><a href="../162741/index.html">We launch console Java applications on Android</a></li>
<li><a href="../162743/index.html">TVs. Part 1. Types of TVs, lights and technology, practical differences</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>