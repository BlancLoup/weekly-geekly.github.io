<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scala type classes (with a little overview of the cats library)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When the word "polymorphism" immediately recall object-oriented programming, in which polymorphism is one of the pillars ( Polymorphism for beginners ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scala type classes (with a little overview of the cats library)</h1><div class="post__text post__text-html js-mediator-article"><p>  When the word "polymorphism" immediately recall object-oriented programming, in which polymorphism is one of the pillars ( <a href="https://habrahabr.ru/post/37576/">Polymorphism for beginners</a> ).  (And, apparently, more important than the other pillars.) It turns out that you can achieve a similar effect in a different way, which in some cases is more preferable.  For example, using classes of types, you can assign new features to already existing types that cannot change the ancestor, or, using a data type with incompatible classes, "solve" the problem of multiple inheritance. </p><a name="habracut"></a><br><p>  On Habr√© there are already several publications that give an idea of ‚Äã‚Äãthe type classes: </p><br><ol><li>  <a href="https://habrahabr.ru/users/IvanGolovach/">@IvanGolovach</a> Developing ‚Üí <a href="https://habrahabr.ru/company/golovachcourses/blog/266905/">"FP on Scala: What is a functor?"</a>  - 2015. <br>  Here types of classes are affected when considering functors.  During the review, several examples of type classes are given. </li><li>  Mikhail Potanin <a href="https://habrahabr.ru/users/potan/">@potan</a> Development ‚Üí <a href="https://habrahabr.ru/post/205482/">"Type Classes in C ++"</a> - 2013. <br>  This publication implements type classes in C ++.  Apparently, it is assumed that the reader is to some extent already familiar with type classes, so not much is said about the type classes themselves. </li><li>  <a href="https://habrahabr.ru/users/VoidEx/">@VoidEx</a> Development ‚Üí <a href="https://habrahabr.ru/post/51046/">"Classes of types, monads"</a> - 2009. <br>  Classes of types in Haskell are described (with examples of C ++ implementation). </li><li>  <a href="https://habrahabr.ru/users/IvanP/">@IvanP</a> Development ‚Üí <a href="https://habrahabr.ru/post/166353/">"Polymorphia and classes in Haskell"</a> - 2013. <br>  Parametric and ad-hoc polymorphism, type classes and several standard classes are described.  All description is made for Haskell. </li><li> update: <a href="https://habrahabr.ru/users/vuspenskiy/">@vuspenskiy</a> Development ‚Üí <a href="https://habrahabr.ru/company/tcsbank/blog/147759/">Type classes in Scala</a> - 2012. <br>  A brief description of how to use type classes through implicits is exemplified by the <code>Comparator[T]</code> . </li></ol><br><p>  In this post I would like to reflect the view on the classes of types as one of the everyday tools of programmers.  Moreover, if Haskell doesn‚Äôt do without them at all, then in Scala you can <del>  perfectly </del>  tolerably live, not knowing about their existence.  However, upon closer inspection, it turns out that such a tool is very useful when writing reusable programs.  In addition, there are a number of universal libraries that are based on this tool, and to use them, you also need to understand the types of classes. </p><br><h3 id="neizmenyaemye-tipy-dannyh">  Immutable data types </h3><br><p>  In functional programming, immutable data types have gained wide popularity.  Since the data cannot arbitrarily change, there is no reason to hide them, and instead of hiding the data, now open types are used, where the data is public.  (Thus, among the three pillars of OOP ‚Äî polymorphism, inheritance, and encapsulation ‚Äî one is somewhat pushed aside.) <br>  Freely available data allows the use of external processing algorithms.  There is no need to bind algorithms to the object itself and to overcome artificial barriers between objects if the processing algorithm uses several objects of different types. </p><br><p>  It turns out that a significant part of the set of data structures can be modeled using only two mechanisms ( <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25B5%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%2582%25D0%25B8%25D0%25BF_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585">Algebraic data types</a> ).  First, the creation of records or tuples ("type-product").  Secondly, the creation of alternative implementations of the same parent type - enum, interface inheritance, sealed trait - "type-sum". </p><br><p>  <em>Example:</em> </p><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// -   : sealed trait Form object Form { // - String X String case class Form1(number: String, title: String) extends Form // - UUID X String X Int case class Form2(id: UUID, documentation: String, count: Int) extends Form // == Unit (    ) case object BadForm extends Form }</span></span></code> </pre> <br><p>  As you can see, such algebraic data types do not imply data hiding, and the presence of any built-in methods.  All data is directly accessible, and we can process these types of external algorithms, for example, such: </p><br><ul><li>  generate an HTML representation for the user </li><li>  perform validation by business rules </li><li>  serialize / deserialize </li><li>  calculate some metrics </li><li>  ... </li></ul><br><p>  All these types of processing are implemented separately and do not have to know anything about each other.  In such algorithms, pattern-matching is the main way of processing different subtypes with access to real data.  Using pattern-matching, we simultaneously check which particular subtype an object is, and extract the values ‚Äã‚Äãof the fields of interest. </p><br><p>  Placing algorithms outside specific types has the following advantages: </p><br><ol><li>  The logic of the algorithm is not spread over each subtype, but is localized in a separate module. </li><li>  The logic of one processing method is not intermingled with other processing methods within each data class.  Simplified support for different algorithms by different developers. </li><li>  There is no need to add a dependency on the DBMS library to the module in which the data model is declared. </li><li>  Easily add new processing methods to existing data types.  They are added "orthogonally" in independent modules. </li></ol><br><h3 id="klassy-tipov">  Type Classes </h3><br><p>  Suppose we implemented some algorithm outside our data types.  If this algorithm directly uses our types, then we will not be able to reuse it for other similar data.  This, on the one hand, is not bad, since such an algorithm is easier to write, but, on the other hand, its generality is limited.  This means, in general, that the algorithm will be used less frequently, and, apparently, it will be worse tested (with the same total economic costs), or the cost of support will be higher. </p><br><p>  Therefore, I would like to have mechanisms that allow us to generalize our algorithm to other data types (existing and prospective).  This will allow using the same algorithm in many cases and will recoup the costs of its development and testing. </p><br><p>  OOP proposes to allocate a common interface for "similar" data and implement the algorithm in terms of this common interface.  In concrete classes that inherit this interface, we just need to implement these common methods.  Thus, we obtain to some extent a polymorphic algorithm.  However, these operations included in the interface of "similar" data, we need to implement in the data itself. </p><br><p>  Type classes represent the next step in isolating code that plays different roles in a program.  The operations we want to perform on the data are moved to a separate class that is not an ancestor of the data.  An instance of this class for this data type is passed to the algorithm along with the data. </p><br><p>  <em>Example:</em> <br>  Suppose that in the algorithm of interest to us we use data comparison in order.  Such a comparison can be represented by a function. </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](a: <span class="hljs-type"><span class="hljs-type">T</span></span>, b: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span></code> </pre> <br><p>  Put this function in the class of the <code>Ordering</code> type: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ordering</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">T</span></span>, b: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre> <br><p>  Now let our universal algorithm do the sorting.  It must accept the type of data it works with: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](list: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]</code> </pre> <br><p>  since elements are compared within the algorithm, an algorithm must be passed to the algorithm for our type <code>T</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>: <span class="hljs-type"><span class="hljs-type">Ordering</span></span>](list: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]</code> </pre> <br><p>  either, which is the same: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](list: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>])(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> o: <span class="hljs-type"><span class="hljs-type">Ordering</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]</code> </pre> <br><p>  The algorithm, if it is necessary to invoke the <code>compare</code> operation, should obtain an instance of the type class using <code>implicitly[Ordering[T]].compare(a,b)</code> . </p><br><p>  We only need to provide an instance of the type class for our data type: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FormOrdering</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ordering</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Form</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">Form</span></span>, b: <span class="hljs-type"><span class="hljs-type">Form</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = (a,b) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-type"><span class="hljs-type">Form1</span></span>(numberA, titleA), <span class="hljs-type"><span class="hljs-type">Form1</span></span>(numberB, titleB)) =&gt; numberA - numberB <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-type"><span class="hljs-type">BadForm</span></span>, <span class="hljs-type"><span class="hljs-type">BadForm</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><p>  Thus, we achieve a common algorithm without cluttering our data with pieces of code related to a specific algorithm. </p><br><h4 id="dopolnitelnoe-udobstvo">  Extra convenience </h4><br><p>  How to make methods accessible directly to the type itself?  For example, we would like to compare the objects inside the algorithm using the method <code>a compare b</code> , without explicitly calling a method of the type class. <br>  To do this, use the usual Scala pimp-my-library mechanism: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderingOps</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ordering</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">a:</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span></span><span class="hljs-class">)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span></span>(b:<span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = implicitly[<span class="hljs-type"><span class="hljs-type">Ordering</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]].compare(a,b) }</code> </pre> <br><p>  Thus, for all types for which there is an instance of <code>Ordering</code> , a new "method" will appear. <br>  If such a desire arises every time, then you can use the library <a href="https://github.com/mpilquist/simulacrum">simulacrum</a> , which creates such an auxiliary method with all the necessary strapping using macros: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> simulacrum.typeclass <span class="hljs-meta"><span class="hljs-meta">@typeclass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ordering</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">]</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">T</span></span>, b: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre> <br><h4 id="primer-klass-tipa-dlya-perepisyvaniya-derevev-simvolnoe-reshenie-uravneniy-optimizaciya-programm">  Example: Type class for rewriting trees (symbolic equation solving, program optimization) </h4><br><p>  Consider an example of a type class for a custom data structure.  One of the mechanisms used to optimize programs is to rewrite AST with preserving semantics.  In this case, all nodes of the tree are traversed (in depth or in width), and for each node, a matching pattern is searched (pattern matching) and in the case of pattern matching, the node is rewritten according to the appropriate rule. </p><br><p>  For different tasks (equations, programs), the types that make up the AST tree are different, the matching / optimization patterns are also different.  However, the traversal algorithm is the same. </p><br><p>  This algorithm is a contender for abstraction using type classes.  To an arbitrary type of tree, we must add some operations used in the tree traversal algorithm. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> simulacrum.typeclass <span class="hljs-meta"><span class="hljs-meta">@typeclass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RewritableTree</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">children</span></span></span></span>(node: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceChildren</span></span></span></span>(node: <span class="hljs-type"><span class="hljs-type">T</span></span>, newChildren: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">proper rewriting algorithm</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RewritableTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rewrite</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>: <span class="hljs-type"><span class="hljs-type">RewritableTree</span></span>](f: <span class="hljs-type"><span class="hljs-type">PartialFunction</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = t =&gt; { rewrite0(f)(t).getOrElse(t) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rewrite0</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>: <span class="hljs-type"><span class="hljs-type">RewritableTree</span></span>](f: <span class="hljs-type"><span class="hljs-type">PartialFunction</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>])(t: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">RewritableTree</span></span>.ops._ <span class="hljs-comment"><span class="hljs-comment">//  "",  simulacrum' val rt = implicitly[RewritableTree[T]] -        "" val children = t.children // rt.children(t) var changed = false //   ,   ,   ,        val updatedChildren = children.map{child =&gt; val res = rewrite0(f)(child) changed = changed || res.isDefined res.getOrElse(child) } //       //def rewriteList(lst: List[T], result: mutable.ListBuffer[T], changed: Boolean): (List[T], Boolean) = lst match { // case Nil =&gt; (result.toList, changed) // case head :: tail =&gt; // val res = rewrite0(f)(head) // rewriteList(tail, result.append(res.getOrElse(head)), changed || res.isDefined) //} //val (updatedChildren, changed) = rewriteList(t.children, mutable.ListBuffer(), false) val updatedTree = if(changed) t.replaceChildren(updatedChildren) else t var changed2 = true val updatedTree2 = f.applyOrElse(t1, (_:T) =&gt;{changed2 = false; updatedTree}) if(changed || changed2) Some(updatedTree2) else None } }</span></span></code> </pre> <br><p>  Using the same type class, you can implement the <code>collect</code> method that collects any values ‚Äã‚Äãas you traverse the tree. </p></div></div><br><h4 id="induktivnoe-opredelenie-klassov-tipov-dlya-proizvodnyh-tipov">  Inductive definition of type classes for derived types </h4><br><p>  Suppose we have already implemented a class of type <code>Ordering[T]</code> for our type <code>T</code>  And we would like to sort the <code>Option[T]</code> list.  Can we use the already implemented type class and simply add the missing functionality? </p><br><p>  This can be done if we provide an implementation of a type class on the fly, constructing an implementation of the existing type classes. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optionOrdering</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>:<span class="hljs-type"><span class="hljs-type">Ordering</span></span>]: <span class="hljs-type"><span class="hljs-type">Ordering</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Ordering</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>], b: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">Int</span></span> = (a, b) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-type"><span class="hljs-type">Some</span></span>(c), <span class="hljs-type"><span class="hljs-type">Some</span></span>(d)) =&gt; implicitly[<span class="hljs-type"><span class="hljs-type">Ordering</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]].compare(c,d) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-type"><span class="hljs-type">None</span></span>, <span class="hljs-type"><span class="hljs-type">None</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (_, <span class="hljs-type"><span class="hljs-type">None</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-type"><span class="hljs-type">None</span></span>, _) =&gt; <span class="hljs-number"><span class="hljs-number">-1</span></span> } }</code> </pre> <br><p>  Such an implementation is automatically inserted into the sorting algorithm for any types for which there is an instance of the class of the type <code>Ordering[T]</code> . </p><br><p>  Similarly, you can construct type classes for any generic types, such as, <code>List[T]</code> , <code>Tuple2[A,B]</code> , ... </p><br><h3 id="standartnye-klassy-tipov-cats">  Standard classes of types (cats) </h3><br><p>  The operations that are declared inside the type classes can be anything.  For our algorithm, we can draw an abstraction boundary arbitrarily enough, for example, put the entire algorithm in a type class, or vice versa, put data access methods directly in a type class.  Both of these boundary options are not optimal in terms of reuse.  Therefore, it is worthwhile to place the minimum number of operations into types classes that are easy to implement for other types, and our algorithm can be expressed through these operations. </p><br><p>  As soon as we begin to look at algorithms and access to data from this point of view, we are more likely to come to some frequently used type classes. </p><br><p>  The Scala standard library has several type classes: <code>Ordering[T]</code> , <code>Equiv[T]</code> , <code>Numeric[T]</code> , <code>Integral[T]</code> , ... </p><br><p>  The typelevel / cats library (as well as the scalaz library) has declared several additional classes for simple types with frequently used operations ( <a href="http://typelevel.org/cats/typeclasses.html">http://typelevel.org/cats/typeslasses.html</a> ): </p><br><ol><li>  <em>A semigroup</em> ( <code>Semigroup</code> ) is a single operation <code>combine</code> . </li><li>  <em>A monoid</em> - a semigroup with an empty ("zero") element - <code>empty</code> . </li></ol><br><p>  For example, for numbers, the operation <code>combine</code> can be defined as the sum of numbers; in this case, the zero element is the usual zero.  We get an additive monoid.  You can also use a multiplicative monoid if you take multiplication as a <code>combine</code> operation, and <code>empty</code> as a unit.  The list of numbers can also be viewed as a monoid.  In the role of the operation <code>combine</code> will be gluing lists, and the zero element is an empty list. </p><br><p>  <em>Example:</em> <br>  You can use a monoid to implement accumulation.  Create a state with an initial value of <code>empty</code> from the monoid.  Further, when data is received at the input, we can <code>combine</code> with those that are already in a state.  For example, we can take the type <code>Int</code> with the operation "sum".  In this case, the sum of the incoming data will be accumulated in one value.  Or take a monoid for <code>List[T]</code> .  In this case, all data will be available in this list (there should be lists at the entrance, or each number should be wrapped in a list).  In both cases, the accumulation algorithm is identical - call the <code>combine</code> method for existing data and new data.  And the algorithm does not depend on the specific type with which it works. </p><br><p>  Also, if we know about some type that it is a monoid (i.e., there is an instance of the monoid class for this type), then we can use <code>foldLeft</code> , a convolution for the collection of these elements (we do not need to re-implement it). </p><br><h3 id="tipy-vysshih-poryadkov">  Types of higher orders </h3><br><p>  In addition to simple base types, type classes can be used to work with types that themselves have parameters.  (Thus, a type class requires support for higher order types in the language.) Higher order types are characterized by a kind of "type type": </p><br><ul><li>  a simple type has kind <code>*</code> (for example, <code>Int</code> , <code>String</code> ); </li><li>  a type that takes one argument - <code>* -&gt; *</code> (for example, <code>List[T]</code> , <code>Option[T]</code> , <code>Future[T]</code> ); </li><li>  A type that takes two arguments - <code>* -&gt; * -&gt; *</code> (for example, the <code>Function1[A,B]</code> function <code>Function1[A,B]</code> ).  (Please note that the function itself contains one arrow <code>A =&gt; B</code> , and at the type level <code>A =&gt; B =&gt; (A=&gt;B)</code> two arrows (the third arrow is already inside the type itself).) </li></ul><br><p>  In the cats library, in addition to the type classes that work with base types, there are type classes that are used when working with type constructors.  In particular, for types <code>* -&gt; *</code> : </p><br><ol><li><p>  <em>A functor</em> is a type class that contains one operation - <code>map</code> .  An operation accepts an object, for example, of the <code>List[Int]</code> and applies the specified function to each element.  For <code>List</code> and <code>Option</code> , this operation, generally speaking, is already implemented in the data type itself, and one could not create a type class.  However, if we want to implement universal algorithms using the <code>map</code> operation, then such a type class is necessary. </p><br></li><li>  <em>A monad</em> is a functor containing a <code>flatMap</code> operation, or <code>bind</code> , or <code>&gt;&gt;=</code> (and also <code>flatten</code> , <code>map</code> , <code>pure</code> ).  This type of class seems to be the most famous.  Its advantage is due to the fact that <code>flatMap</code> ( <code>bind</code> ) is a fairly universal way to glue successive calculations.  On the operation <code>flatMap</code> even based "sugar" in Scala - for-comprehension. </li></ol><br><p>  <em>Example:</em> </p><br><ul><li>  Processing lists  Collect all children for a collection of objects - <code>val allChildren = objects.flatMap(_.children)</code> </li><li>  Handling missing values: <code>val street = personOpt.flatMap(_.addressOpt).flatMap(_.streetOpt)</code> </li><li>  Delayed execution of requests.  Let the result of some query from the database can be represented by the <code>DataTable[T]</code> .  Using <code>flatMap</code> we can define a subquery that retrieves data from the results of this query.  Such a query can be glued to the original query <em>without performing the first query and not working with the collection of results</em> .  We can compile the glued query in SQL and send it to the database for execution on the DBMS side.  This approach is implemented, for example, in the Slick library. </li></ul><br><p>  For types <code>* -&gt; * -&gt; *</code> in the cats library there is also a type class: </p><br><ol><li>  <em>Category</em> - operation <code>compose</code> + "zero" element - <code>identity</code> .  The type for which a category type class is defined is called an Arrow.  Arrows are like functions.  In particular, for normal functions, the <code>compose</code> operation corresponds to the <code>andThen</code> method, and the <code>identity</code> operation corresponds to the <code>identity</code> function. </li></ol><br><p>  Examples of categories: </p><br><ol><li>  Normal functions. </li><li>  Model functions (in model language). </li><li>  Lenses (properties of objects separated from classes) (see the <a href="https://github.com/julien-truffaut/Monocle">monocle</a> library). </li><li>  Directed graph in Functional Reactive Programming (for example, <a href="https://github.com/Primetalk/SynapseGrid">SynapseGrid</a> ). </li></ol><br><p>  <em>Example:</em> <br>  For categories, the key feature is <code>compose</code> .  Those.  if our algorithm can be expressed in terms of compose, then we can apply this algorithm for any categories. </p><br><p>  Let us simulate a chain of data transformations using our own DSL.  Suppose that each transformation can be represented by some type of <code>Transform[A,B]</code> . </p><br><div class="spoiler">  <b class="spoiler_title">phantom types</b> <div class="spoiler_text"><p>  <code>A</code> and <code>B</code> are not necessarily types from our data model.  This may be the so-called <em>phantom types</em> .  Using phantom types allows you to define your own rules for allowed combinations of transformations that will be checked by the compiler.  Those.  we cannot use the <code>compose</code> method for incompatible conversions. </p></div></div><br><p>  After the user has described his task using this DSL, we can convert our conditional transformations into real actions with data, which are already represented by ordinary functions on real types.  The conversion of one category (model functions) into another category (real functions) is called <a href="https://ru.wikipedia.org/wiki/%25D0%2595%25D1%2581%25D1%2582%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">"natural conversion"</a> . </p><br><h4 id="zakony-dlya-klassov-tipov">  Laws for type classes </h4><br><p>  The type classes implemented in the cats library model concepts of category theory.  Therefore, the methods of these classes of types must satisfy certain properties (which are described in theory).  For example, for a monoid: </p><br><ol><li>  <code>a combine empty = a = empty combine a</code> - the definition of an empty element </li><li>  <code>(a combine b) combine c = a combine (b combine c)</code> - <code>combine</code> operation associativity </li></ol><br><p>  All properties that are required by category theory for a type class are implemented as "laws" - sets of "properties" of the <a href="https://scalacheck.org/">ScalaCheck</a> library.  And it is possible for any instance of a type class to check whether this instance meets the requirements for this type class.  Many algorithms rely on these properties, so when you implement type classes for your data, you should check these laws in unit tests. </p><br><p>  Once we have verified that our type class implementations satisfy the existing laws, we can be pretty sure that our program is correct, using algorithms from libraries based on these properties of type classes. </p><br><h4 id="preimuschestva-klassov-tipov">  Type Class Benefits </h4><br><p>  Compared to regular interfaces that need to be implemented in descendants, type classes have the following advantages: </p><br><ul><li>  You can implement a class for an inaccessible type </li><li>  You can declare operations that work with zero instances of this type.  In particular, the method is <code>empty: T</code> , or the method <code>parse: String =&gt; T</code> ; </li><li>  You can inductively define an instance of a composite type if there are instances for the base types.  For example, for <code>Option[T]</code> or for <code>A \/ B</code> </li></ul><br><p>  These benefits can be used independently in any program.  It is enough to take a different look at the structure of your code. </p><br><p>  The cats library (as well as the scalaz library) has a well-organized and tested set of type classes (from category theory), which are used in many algorithms and libraries.          , ,                   . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/318960/">https://habr.com/ru/post/318960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318948/index.html">Finding GDI Object Leaks: How to Drive a Mastodon</a></li>
<li><a href="../318950/index.html">NativeScript, what kind of beast and what is it for?</a></li>
<li><a href="../318952/index.html">Let's Encrypt and nginx: configuration in Debian and Ubuntu</a></li>
<li><a href="../318954/index.html">Processing preprocessor directives in Objective-C</a></li>
<li><a href="../318958/index.html">json-api-normalizer: an easy way to make friends with Redux and the JSON API</a></li>
<li><a href="../318962/index.html">About string formatting in modern C ++</a></li>
<li><a href="../318964/index.html">Towers of Hanoi - a theoretical solution without recursion</a></li>
<li><a href="../318966/index.html">Features of the development of mobile MMO RTS. Part 2</a></li>
<li><a href="../318968/index.html">Security in IoT: Security Architecture</a></li>
<li><a href="../318970/index.html">Neural network optimization methods</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>