<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Choosing a location for the server and software, testing market inefficiencies: how to actually create trading robots</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Financial Hacker, the author of the blog, told about how the process of developing high-frequency strategies for trading on the stock exchange is orga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Choosing a location for the server and software, testing market inefficiencies: how to actually create trading robots</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habr.com/company/iticapital/blog/358928/"><img src="https://habrastorage.org/webt/vr/q5/er/vrq5er9ixolem23wihvyalfzmme.png"></a> <br><br>  Financial Hacker, the author of the blog, told about how the process of developing high-frequency strategies for trading on the stock exchange is organized, from the importance of analyzing possible delays to data acquisition and testing (all with sample code).  For example, using the strategy of arbitrage trading on US exchanges.  We have prepared an adapted translation of this material. <a name="habracut"></a><br><br><h2>  Introduction </h2><br>  Compared to machine learning or signal processing algorithms used in traditional trading strategies, high-frequency trading systems (HFTs) can be surprisingly simple.  They do not need to try to predict the future price of shares - they already know it.  More precisely, they know the current price a little earlier than the other, slower market participants. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The advantage of HFT in obtaining market data and the execution of their applications before most of the participants.  The total profitability of the system depends on its speed of delay, the time between the receipt of the quotation and the execution of the order in the trading core of the exchange.  Delay (latency) - the most relevant factor in assessing the HFT-system.  It can be optimized in two ways: minimizing the physical distance to the exchange, and increasing the speed of the system itself.  And the first is much more important than the second. <br><br><h2>  Location </h2><br>  Ideally, the HFT server should be located directly on the exchange.  And most of the marketplaces in the world are happy to sell server places in their data centers - the closer to the hub of the main network of the exchange, the better is the place.  Electric signals in a shielded wire are transmitted at a speed of 0.7 - 0.9 of the speed of light (300 km / ms).  Reducing the distance to a signal source by one meter results in as many as 8 nanoseconds of advantage per roundtrip (from the time of sending an application to receiving information about its performance).  How many trading opportunities can you miss in 8 nanoseconds?  No one knows, but people are willing to pay for every nanosecond saved. <br><br>  Unfortunately (or, fortunately, from the point of view of economy, the placement in the data centers of the exchanges costs a lot of money), the HFT system analyzed in this article cannot be placed on the colocation in the data center of the marketplace for several reasons.  At the same time, in order to trade, it needs to receive data from the NYSE exchanges in New York and CME (Chicago) at the same time. <br><br>  High-speed cables are stretched between these two cities, and there is also a microwave network.  In theory, the ideal location for a system with similar requirements is the town of Warren, Ohio.  It is located exactly midway between New York and Chicago.  It is not known if there is a hub for high-speed merchants, but the distance of 357 miles to both exchanges results in approximately 4 ms delay of the round trip. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/39d/e3d/012/39de3d012ac18d11e346eac2363a4fdf.jpg" alt="image"><br><br>  <i>Warren, Ohio - Mecca HFT Traders (Image: Jack Pearce / Wikipedia Commons)</i> <br><br>  Without a doubt, the server in this wonderful town will be much cheaper than the server in the rack on the stock exchange in New York.  The idea for a startup: buy a couple of garages in Warren, connect to a high-speed cable between New York and Chicago and earn money by renting the server racks! <br><br><h2>  Soft </h2><br>  When you have already invested money in choosing the optimal location and communication channels for the HFT system, you will definitely want to receive software that will correspond to the required speed.  Commercial trading platforms are usually not fast enough, moreover, their code is always closed, it is not known exactly what and how it works in them.  Therefore, HFT-systems are almost never based on existing platforms, but are written from scratch.  Not in R or Python, but in any of the "fast" languages.  This list includes: <br><br><ul><li>  <b>C or C ++</b> is a great combination of high level and high speed.  C is easy to read, while it is almost as fast and efficient as machine languages. </li><li>  <b>Pentium Assembler</b> - write your algorithm using machine instructions and it will overtake even systems developed on C.  From the drawbacks of this approach: it will not be easy to maintain such code, all programmers know how hard it is to read programs in assembler written by someone else. </li><li>  <b>CUDA, HLSL or GPU assembler</b> - if the algorithm actively uses vector or matrix operations, then running it on a video card can be a great idea. </li><li>  <b>VHDL</b> - if any software will be too slow, and the success of the transaction for a particular algorithm will depend on nanoseconds, then the ‚Äúultimate solution‚Äù here will be the coding of the system directly in the hardware.  In VHDL, arithmetic units, digital filters and sequencers of FPGA chips can be defined with a clock frequency of up to several hundred megahertz.  Such chips can be directly connected to the network interface. </li></ul><br>  With the exception of VHDL, all of the above should be familiar to many specialists (especially developers of computer games in 3D).  But the standard language for high-frequency strategy can be called C / C ++.  In this material it is used. <br><br><h2>  Algorithm </h2><br>  Many HFT systems ‚Äúhunt‚Äù competitor traders using ‚Äúovertaking methods‚Äù.  They notice your application, and then buy the same asset at the same price a couple of microseconds earlier than you and sell it to you a little more expensive, earning on it.  On some exchanges, such trade is prohibited to create equal conditions for all participants, other sites may allow it, hoping to earn more on commissions.  In the example from this article, such mechanisms will not be used; instead, an arbitration strategy will be described.  Suppose our servers are located in Warren and we have a high-speed channel to Chicago and New York. <br><br>  Arbitrage will occur between ES and SPY financial instruments.  ES is a Chicago-traded S &amp; P500 futures contract.  SPY is a New York-based ETF that is also linked to the S &amp; P500 index.  One point of ES equals 10 cents of SPY, so the price of ES is about ten times higher than SPY.  Since both assets are based on the same index, a high correlation of their prices can be expected.  There are publications, the authors of which <a href="http://jaredbernsteinblog.com/trading-in-milliseconds-when-correlations-break-down/">prove</a> that this correlation will ‚Äúbreak‚Äù in small time intervals.  Any short-term price difference in an ES-SPY pair that exceeds the bid-ask spread creates opportunities for arbitration.  The algorithm from the example will work according to the following strategy: <br><br><ul><li>  Determine the difference SPY-ES. </li><li>  Determine its deviation from the mean. </li><li>  If the deviation exceeds the bid-ask spread and exceeds a certain threshold value, then positions are opened in ES and SPY in opposite directions. </li><li>  If the deviation reverses its direction and exceeds the predetermined (slightly smaller) threshold, the positions are closed. </li></ul><br>  The algorithm is written in C. If you have never seen the code of HFT algorithms before, it may seem a bit strange: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> THRESHOLD 0.4 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Entry/Exit threshold //  HFT  //  0     //  1      ES,   SPY //  2      SPY,   ES //     -1 int tradeHFT(double AskSPY,double BidSPY,double AskES,double BidES) { double SpreadSPY = AskSPY-BidSPY, SpreadES = AskES-BidES; double Arbitrage = 0.5*(AskSPY+BidSPY-AskES-BidES); static double ArbMean = Arbitrage; ArbMean = 0.999*ArbMean + 0.001*Arbitrage; static double Deviation = 0; Deviation = 0.75*Deviation + 0.25*(Arbitrage - ArbMean); static int Position = 0; if(Position == 0) { if(Deviation &gt; SpreadSPY+THRESHOLD) return Position = 1; if(-Deviation &gt; SpreadES+THRESHOLD) return Position = 2; } else { if(Position == 1 &amp;&amp; -Deviation &gt; SpreadES+THRESHOLD/2) return Position = 0; if(Position == 2 &amp;&amp; Deviation &gt; SpreadSPY+THRESHOLD/2) return Position = 0; } return -1; }</span></span></span></span></code> </pre> <br>  The traderHFT function is called from a certain framework (it is not considered in the article), which receives quotes and sends orders.  The current best prices for buying and selling by ES and SPY from the top of the order book are used as parameters (it is assumed that the price of SPY is multiplied by ten so that both assets are on the same scale).  The function returns a code that tells the framework to open or close positions, or do nothing.  The variable Arbitrage represents the average price difference between SPY and ES.  Its average (ArbMean) is filtered by a slow exponential moving average, and Deviation from the average is also filtered by a fast moving average to prevent reactions to quotes outside the desired range.  The variable Position denotes the machine state, which can take the value of long, short and nothing.  The threshold for entering or exiting a position is set at 40 cents.  This is the only adjustable system parameter.  If the strategy were intended for real trading, it would also be necessary to optimize the threshold value using several months of data on ES and SPY. <br><br>  Such a minimalist system is not difficult to translate into assembler, or even programmed in an FPGA chip.  However, this is not necessary: ‚Äã‚Äãeven if you use the compiler of the Zorro framework compiler (developed by the author of the article), the tradeHFT function is executed in just 750 nanoseconds.  If you use a more advanced compiler like Microsoft VC ++, this value can be reduced to 650 nanoseconds.  Since the time between two ES quotes is 10 microseconds or more, the speed C is quite sufficient. <br><br>  In the course of our HFT experiment, two questions are required.  First, is there really a difference in the prices of the two instruments sufficient to extract arbitrage profit?  Secondly, at what maximum delay will the system still work? <br><br><h2>  Data </h2><br>  For backtesting HFT-system data, which can usually be obtained from brokers for free, will not work.  It is necessary to fork out for the purchase of data on the order book in the necessary resolution or BBO (Best Bid and Offer) data, with the time stamps of the exchange included.  Without information about the time at which the quotation was received at the stock exchange, it is impossible to determine the maximum delay. <br><br>  Some companies record all the quotes coming from the exchanges, and then sell this data.  Each of them has its own data format, so for the beginning they will have to lead to a common format.  This example uses the following target data format: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class"> // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">single</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tick</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> time; <span class="hljs-comment"><span class="hljs-comment">// time stamp, OLE DATE format float fVal; // positive = ask price, negative = bid price } T1;</span></span></code> </pre> <br>  One of the companies that monitor the situation on the CME exchange provides data in CSV format with many additional fields, most of which are not needed for the problem to be solved.  All quotes per day are stored in a single CSV file.  Below is a script for extracting ES data from it for December 2016 and converting it into datas of T1 quotes: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">////////////////////////////////////////////////////// // Convert price history from Nanotick BBO to .t1 ////////////////////////////////////////////////////// #define STARTDAY 20161004 #define ENDDAY 20161014 string InName = "History\\CME.%08d-%08d.E.BBO-C.310.ES.csv"; // name of a day file string OutName = "History\\ES_201610.t1"; string Code = "ESZ"; // December contract symbol string Format = "2,,%Y%m%d,%H:%M:%S,,,s,,,s,i,,"; // Nanotick csv format void main() { int N,Row,Record,Records; for(N = STARTDAY; N &lt;= ENDDAY; N++) { string FileName = strf(InName,N,N+1); if(!file_date(FileName)) continue; Records = dataParse(1,Format,FileName); // read BBO data printf("\n%d rows read",Records); dataNew(2,Records,2); // create T1 dataset for(Record = 0,Row = 0; Record &lt; Records; Record++) { if(!strstr(Code,dataStr(1,Record,1))) continue; // select only records with correct symbol T1* t1 = dataStr(2,Row,0); // store record in T1 format float Price = 0.01 * dataInt(1,Record,3); // price in cents if(Price &lt; 1000) continue; // no valid price string AskBid = dataStr(1,Record,2); if(AskBid[0] == 'B') // negative price for Bid Price = -Price; t1-&gt;fVal = Price; t1-&gt;time = dataVar(1,Record,0) + 1./24.; // add 1 hour Chicago-NY time difference Row++; } printf(", %d stored",Row); dataAppend(3,2,0,Row); // append dataset if(!wait(0)) return; } dataSave(3,OutName); // store complete dataset }</span></span></code> </pre><br>  The script first parses the CSV into an intermediate binary dataset, which is then converted into the target format T1.  Since time stamps are stamped in Chicago time, you need to add one more hour to convert them during New York. <br><br>  The company tracking the New York Stock Exchange delivers the data in a highly compressed specially NxCore Tape format, it needs to be converted to the second T1 list using a special plug-in: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">////////////////////////////////////////////////////// // Convert price history from Nanex .nx2 to .t1 ////////////////////////////////////////////////////// #define STARTDAY 20161004 #define ENDDAY 20161014 #define BUFFER 10000 string InName = "History\\%8d.GS.nx2"; // name of a single day tape string OutName = "History\\SPY_201610.t1"; string Code = "eSPY"; int Row,Rows; typedef struct QUOTE { char Name[24]; var Time,Price,Size; } QUOTE; int callback(QUOTE *Quote) { if(!strstr(Quote-&gt;Name,Code)) return 1; T1* t1 = dataStr(1,Row,0); // store record in T1 format t1-&gt;time = Quote-&gt;Time; t1-&gt;fVal = Quote-&gt;Price; Row++; Rows++; if(Row &gt;= BUFFER) { // dataset full? Row = 0; dataAppend(2,1); // append to dataset 2 } return 1; } void main() { dataNew(1,BUFFER,2); // create a small dataset login(1); // open the NxCore plugin int N; for(N = STARTDAY; N &lt;= ENDDAY; N++) { string FileName = strf(InName,N); if(!file_date(FileName)) continue; printf("\n%s..",FileName); Row = Rows = 0; // initialize global variables brokerCommand(SET_HISTORY,FileName); // parse the tape dataAppend(2,1,0,Row); // append the rest to dataset 2 printf("\n%d rows stored",Rows); if(!wait(0)) return; // abort when [Stop] was hit } dataSave(2,OutName); // store complete dataset }</span></span></code> </pre><br>  The Callback function is called by any quote in the source file, but most of the data is not needed, so only SPY (‚ÄúeSPY‚Äù) quotes are filtered out. <br><br><h2>  Proof of market inefficiency </h2><br>  Having obtained data from two sources, we can now compare ES and SPY prices in high resolution.  Here is a typical ten-second sample of price curves: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ce/317/e57/5ce317e5742888292d1308deb0f692c1.png" alt="image"><br><br>  <i>SPY (black) vs.</i>  <i>ES (red), October 5, 2017, 10:01:25 - 10: 01.35</i> <br><br>  The resolution here is one millisecond.  ES drawn in dollar units, SPY - in tenths.  Charts prices are ‚Äúask‚Äù prices (asking price).  It seems that prices are strongly correlated even at such a small interval.  ES is a little behind. <br><br>  The opportunity for arbitration arises at the site in the center - at about 10:01:30, ES responded to the changes a little slower, but stronger.  The reason could be some kind of event like a sharp jump in prices of one of the stocks included in the S &amp; P 500 index. For several milliseconds, the difference between ES-SPY exceeded the bid-ask spread of two assets (usually it is 25 cents for ES and 1-4 cents for SPY ).  Ideally, you could sell ES and buy SPY.  Thus, we have confirmed the theory of the existence of market inefficiency, which opens up opportunities for earnings. <br><br>  Script for drawing graphs in high resolution: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ES_HISTORY </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ES_201610.t1"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPY_HISTORY </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SPY_201610.t1"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMEFORMAT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%Y%m%d %H:%M:%S"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FACTOR 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OFFSET 3.575 void main() { var StartTime = wdatef(TIMEFORMAT,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"20161005 10:01:25"</span></span></span><span class="hljs-meta">), EndTime = wdatef(TIMEFORMAT,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"20161005 10:01:35"</span></span></span><span class="hljs-meta">); MaxBars = 10000; BarPeriod = 0.001/60.; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 1 ms plot resolution Outlier = 1.002; // filter out 0.2% outliers assetList("HFT.csv"); dataLoad(1,ES_HISTORY,2); dataLoad(2,SPY_HISTORY,2); int RowES=0, RowSPY=0; while(Bar &lt; MaxBars) { var TimeES = dataVar(1,RowES,0), PriceES = dataVar(1,RowES,1), TimeSPY = dataVar(2,RowSPY,0), PriceSPY = dataVar(2,RowSPY,1); if(TimeES &lt; TimeSPY) RowES++; else RowSPY++; if(min(TimeES,TimeSPY) &lt; StartTime) continue; if(max(TimeES,TimeSPY) &gt; EndTime) break; if(TimeES &lt; TimeSPY) { asset("ES"); priceQuote(TimeES,PriceES); } else { asset("SPY"); priceQuote(TimeSPY,PriceSPY); } asset("ES"); if(AssetBar &gt; 0) plot("ES",AskPrice+OFFSET,LINE,RED); asset("SPY"); if(AssetBar &gt; 0) plot("SPY",FACTOR*AskPrice,LINE,BLACK); } }</span></span></span></span></code> </pre> <br>  First, the script reads two files with historical data that we created earlier, and then parses them line by line. <br><br><h2>  System testing </h2><br>  To backtest the resulting HFT system, you need to slightly modify the script, and call the tradeHFT function in a loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LATENCY 4.0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// milliseconds function main() { var StartTime = wdatef(TIMEFORMAT,"20161005 09:30:00"), EndTime = wdatef(TIMEFORMAT,"20161005 15:30:00"); MaxBars = 200000; BarPeriod = 0.1/60.; // 100 ms bars Outlier = 1.002; assetList("HFT.csv"); dataLoad(1,ES_HISTORY,2); dataLoad(2,SPY_HISTORY,2); int RowES=0, RowSPY=0; EntryDelay = LATENCY/1000.; Hedge = 2; Fill = 8; // HFT fill mode; Slippage = 0; Lots = 100; while(Bar &lt; MaxBars) { var TimeES = dataVar(1,RowES,0), PriceES = dataVar(1,RowES,1), TimeSPY = dataVar(2,RowSPY,0), PriceSPY = dataVar(2,RowSPY,1); if(TimeES &lt; TimeSPY) RowES++; else RowSPY++; if(min(TimeES,TimeSPY) &lt; StartTime) continue; if(max(TimeES,TimeSPY) &gt; EndTime) break; if(TimeES &lt; TimeSPY) { asset("ES"); priceQuote(TimeES,PriceES); } else { asset("SPY"); priceQuote(TimeSPY,FACTOR*PriceSPY); } asset("ES"); if(!AssetBar) continue; var AskES = AskPrice, BidES = AskPrice-Spread; asset("SPY"); if(!AssetBar) continue; var AskSPY = AskPrice, BidSPY = AskPrice-Spread; int Order = tradeHFT(AskSPY,BidSPY,AskES,BidES); switch(Order) { case 1: asset("ES"); enterLong(); asset("SPY"); enterShort(); break; case 2: asset("ES"); enterShort(); asset("SPY"); enterLong(); break; case 0: asset("ES"); exitLong(); exitShort(); asset("SPY"); exitLong(); exitShort(); break; } } printf("\nProfit %.2f at NY Time %s", Equity,strdate(TIMEFORMAT,dataVar(1,RowES,0))); }</span></span></span></span></code> </pre><br>  The script starts backtesting for one trading day from 9:30 am to 3:30 pm New York.  In essence, the HFT function is simply called with ES and SPY prices, and then the code is executed to switch states.  It opens positions on one hundred units of each asset (2 contracts for ES and 1000 for SPY).  The delay is set using the variable EntryDelay.  In HFT mode (Fill = 8), the transaction is at the last price after the delay time.  This allows the simulation to be closer to real conditions. <br><br>  The table below shows the profit from the simulation with different values ‚Äã‚Äãof delay: <br><table><tbody><tr><th>  Delay </th><th>  0.5 ms </th><th>  4.0 ms </th><th>  6.0 ms </th><th>  10 ms </th></tr><tr><td>  Profit / day </td><td>  + $ 793 </td><td>  + $ 273 </td><td>  + $ 205 </td><td>  - $ 15 </td></tr></tbody></table><br>  As you can see, the arbitration strategy of ES-SPY can earn $ 800 a day - with an unrealistically small delay of 500 microseconds.  Unfortunately, with 700 miles between the NYSE and the CME, you will need a time machine (or some kind of quantum teleportation tool) to achieve this result.  The server in Warren, Ohio, with a delay of 4 ms will bring about $ 300 per day.  If the server is a bit away from the high-speed channel between New York and Chicago, the profit will be $ 200.  If the infrastructure for trade is even further - say, in Nashville - then nothing will be earned. <br><br>  Even $ 300 per day will result in an annual income of $ 75,000. But to achieve this result, in addition to hardware and software, a lot of money is also needed.  The SPY contract costs $ 250, 100 units for trading will result in 100 * $ 2500 + 100 * 10 * $ 250 = half a million dollars in trading volume.  So the annual return on investment will not exceed 15%.  The results, however, can be improved by adding more pairs of financial instruments for arbitration. <br><br><h2>  findings </h2><br><ul><li>  If the system responds quickly enough, it can even earn by very primitive methods, such as arbitrage between highly correlated financial instruments on different exchanges. </li><li>  The physical location of the server is very important in the HFT. </li><li>  ES-SPY arbitration cannot be conducted from anywhere.  You will have to compete with those who are already engaged in this, and very likely from Warren in Ohio. </li></ul><br><h2>  Other materials on finance and stock market from <a href="https://iticapital.ru/">ITI Capital</a> : </h2><br><ul><li>  <a href="https://iticapital.ru/research-education/research/">Analytics and market reviews</a> </li><li>  <a href="https://habr.com/company/iticapital/blog/238839/">Back to the Future: Testing a Trading Robot with Historical Data</a> </li><li>  Event-oriented Python backtesting step by step ( <a href="https://habr.com/company/iticapital/blog/263097/">Part 1</a> , <a href="https://habr.com/company/iticapital/blog/264141/">Part 2</a> , <a href="https://habr.com/company/iticapital/blog/266623/">Part 3</a> , <a href="https://habr.com/company/iticapital/blog/268929/">Part 4</a> , <a href="https://habr.com/company/iticapital/blog/270215/">Part 5</a> ) </li></ul></div><p>Source: <a href="https://habr.com/ru/post/358928/">https://habr.com/ru/post/358928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358916/index.html">Localization based on ScriptableObject for Unity3D</a></li>
<li><a href="../358918/index.html">Issue # 22: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../358920/index.html">CRM integration with Outlook in the free version of 3CX</a></li>
<li><a href="../358924/index.html">3D character stylization: model, texture, details</a></li>
<li><a href="../358926/index.html">Defect management style</a></li>
<li><a href="../358930/index.html">The most difficult program</a></li>
<li><a href="../358932/index.html">Out of IPv4 - the RIPE recorder gave the last block</a></li>
<li><a href="../358934/index.html">The patented dream of programmers 80-90</a></li>
<li><a href="../358936/index.html">[Translation] Handling errors and transactions in SQL Server. Part 1. Error handling - quick start</a></li>
<li><a href="../358938/index.html">40 stupid CRM questions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>