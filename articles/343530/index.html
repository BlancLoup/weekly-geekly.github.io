<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development for Sailfish OS: Using Sensors (Part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! This article is the second part of a large article on the use of sensor devices running Sailfish OS. The first part is available here . 

 Tilt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development for Sailfish OS: Using Sensors (Part 2)</h1><div class="post__text post__text-html js-mediator-article">  Hello!  This article is the second part of a large article on the use of sensor devices running Sailfish OS.  The first part is available <a href="https://habrahabr.ru/post/338044/">here</a> . <br><a name="habracut"></a><br><h2>  Tilt angle sensor </h2><br>  The tilt angle sensor, as the name implies, determines the tilt angle of the device.  The situation with tilt measurement components is similar to light sensors: there is one more ‚Äúsmart‚Äù component - the <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-rotationsensor.html">RotationSensor</a></i> , and its less advanced companion - the <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-orientationsensor.html">OrientationSensor</a></i> . <br><br>  <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-rotationreading.html">RotationReading</a></i> provides information about the exact angle of inclination relative to three coordinate axes: property x contains information about how far the longitudinal axis of the smartphone deviates from the horizontal position, property y contains the same information, but for the transverse axis, and z - about the rotation relative to the screen center .  More clearly it can be traced in the image: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/hv/wq/nghvwqb1lvmsbc-suaosfg5xhmy.jpeg"></div><br>  You can watch these values ‚Äã‚Äãin the improvised table on the device screen: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs pgsql">RotationSensor { id: rotationSensor active: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">Column</span></span> { Label { <span class="hljs-type"><span class="hljs-type">text</span></span>: "x: " + rotationSensor.reading.x } Label { <span class="hljs-type"><span class="hljs-type">text</span></span>: "y: " + rotationSensor.reading.y } Label { <span class="hljs-type"><span class="hljs-type">text</span></span>: "z: " + rotationSensor.reading.z } }</code> </pre> <br>  The definition of the z values ‚Äã‚Äãis not always available.  To determine the availability of this value, you need to check the <i>hasZ</i> property of the <i>RotationReading</i> component. <br><br>  <i>OrientationSensor</i> , as a less functional component, allows you to answer the important question: "What is the edge of a smartphone pointing up?".  Accordingly, it can take six values, each of which corresponds to a face.  Plus one additional value indicating the inability to determine the position.  These values ‚Äã‚Äãcan be found in the following list: <br><br><ul><li>  <i>OrientationReading.Undefined</i> ‚Äî Cannot determine the location of the device, </li><li>  <i>OrientationReading.TopUp</i> - the top face is pointing up, </li><li>  <i>OrientationReading.TopDown</i> - bottom edge pointing up (upside down) </li><li>  <i>OrientationReading.LeftUp</i> - the left side faces up, </li><li>  <i>OrientationReading.RightUp</i> - right edge pointing up, </li><li>  <i>OrientationReading.FaceUp</i> - the device is located with the screen up, </li><li>  <i>OrientationReading.FaceDown</i> - the device is located with the screen down. </li></ul><br>  <i>OrientationSensor</i> can be used, for example, in order to maintain the orientation of the image when the position of the device itself changes: <br><br><pre> <code class="hljs php">OrientationSensor { id: orientationSensor active: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } Image { anchors.centerIn: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> source: <span class="hljs-string"><span class="hljs-string">"http://social.fruct.org/content/img/fruct.png"</span></span> transform: Rotation { angle: rotationAngle() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotationAngle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (orientationSensor.reading.orientation) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OrientationReading.TopUp: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OrientationReading.RightUp: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">90</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OrientationReading.TopDown: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">180</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OrientationReading.LeftUp: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">270</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>  In the example above, the logo will be drawn to the top of the face of the smartphone: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gm/ig/q3/gmigq3_11nfgsch4hlnn1lzb_gy.png"></div><br><h2>  Magnetometer </h2><br>  The magnetometer is represented by a QML-type <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-magnetometer.html">Magnetometer</a></i> , it provides information about the magnetic field strength around the device in X, Y, and Z axes. Values ‚Äã‚Äãare provided in tesla. <br><br>  The magnetometer can react both to the intensity of any magnetic fields around the device, and to the intensity of only the geomagnetic field.  This behavior is governed by the <i>returnGeoValues</i> property, which can accept either <i>true</i> or <i>false</i> .  Initially, it is <i>false</i> and responds to any magnetic fields nearby.  The difference between these two modes is that when <i>returnGeoValues ‚Äã‚Äãis on, the</i> sensor will try to eliminate the influence of extraneous magnetic fields coming from sources of the magnetic field, such as conductors, magnets and electronic devices, and focus on the Earth‚Äôs natural magnetic field.  Of course, completely eliminate the influence of extraneous magnetic fields will not succeed, so that the sensor readings will still change when new sources appear. <br><br>  The <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-magnetometerreading.html">MagnetometerReading</a></i> object has, in addition to the already familiar <i>x</i> , <i>y</i> , and <i>z</i> properties, which contain axial strength, also the <i>calibrationLevel</i> property ‚Äî the level of accuracy in measuring the geomagnetic field intensity.  This parameter takes values ‚Äã‚Äãfrom 0 to 1 in accordance with the sensor calibration level and changes its value only when <i>returnGeoValues</i> contains <i>true</i> .  The property reflects how strongly close magnetic fields affect the measurement of the geomagnetic field.  With a large impact, the value will decrease to zero.  To return the accuracy of the measurements, it is necessary to calibrate the sensor.  Usually this is done by rotating the device in an arc of the number 8 or simply swinging it in different directions in space.  With a low accuracy rate, the sensor values ‚Äã‚Äãwill be very different from the actual ones.  This is especially true when using a magnetometer as a compass. <br><br><h2>  Compass </h2><br>  The <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-compass.html">Compass</a></i> component acts as an electronic compass.  His reading property contains a <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-compass.html">CompassReading</a></i> object, which provides information about the azimuth of the device ‚Äî the angle between the north magnetic pole and the device axis X in the direction of the clockwise direction.  This information, like the readings of a magnetometer, is based on data from the geomagnetic field.  In this regard, the compass is also susceptible to various interferences and also requires calibration. <br><br>  <i>CompassReading</i> has two properties: <br><br><ul><li>  <i>azimuth</i> : <i>qreal</i> is the horizontal angle between the north magnetic pole of the Earth and the direction to which the top edge of the smartphone is pointing, </li><li>  <i>calibrationLevel</i> : <i>qreal</i> - the accuracy of the sensor readings, is completely analogous to the <i>calibrationLevel</i> property of the <i>MagnetometerReading</i> type. </li></ul><br><h2>  Filtering sensor readings </h2><br>  The readings of some sensors may change many times per second.  Using the standard Qt notification mechanism using signals and slots significantly slows down the process of obtaining values ‚Äã‚Äãand reduces the accuracy of measurements in general.  An alternative to using signals to obtain sensor values ‚Äã‚Äãis the <i><a href="http://doc.qt.io/qt-5/qsensorfilter.html">QSensorFilter</a></i> class.  This class is an interface that implements a callback function, which is called when new readings are received by a signed sensor class.  A remarkable feature of this function is the ability to change the sensor measurements coming into it, thereby transforming the final value of the <i>reading</i> property.  And together with the ability to hang several filters on one sensor, all conversions over the values ‚Äã‚Äãcan be carried out by means of filters with the output of the desired results. <br><br>  Similar to other parent classes from Qt Sensors API, <i>QSensorFilter</i> has only a universal set of methods: <br><br><ul><li>  <i>public bool filter (QSensorReading * reading)</i> is the same callback function that is called when receiving measurements from the sensor.  It can be pre-processed values.  If this function returns <i>true</i> , then the readings are transmitted either to the next filter, if it exists, or a signal is emitted to change the value of the <i>reading</i> property.  When <i>false is</i> returned, processing of the current sensor reading is terminated. </li><li>  <i>protected void setSensor (QSensor * sensor)</i> - allows you to specify the sensor class to which the filter is attached, from the filter itself. </li></ul><br>  Methods that are specific to a particular type of sensor are already implemented in heir classes.  As with objects of type <i>Reading</i> , each sensor has its own filter.  For example, an accelerometer, with which the <i>QAccelerometer</i> class <i>corresponds</i> , has a <i><a href="http://doc.qt.io/qt-5/qaccelerometerfilter.html">QAccelerometerFilter</a></i> filter, and its <i>filter</i> method takes the following form: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QAccelerometerReading *reading)</span></span></span></span></code> </pre> <br>  Unlike the method of its parent, as a parameter it receives an object with accelerometer measurements.  The same applies to other types of filters. <br><br>  Filters are managed using class-sensor methods.  To do this, <i>QSensors has</i> a number of functions that allow them to manage a set of handlers: <br><br><ul><li>  <i>void addFilter (QSensorFilter * filter)</i> - adds the specified filter to the end of the list.  In this case, one filter may be included in the list several times. </li><li>  <i>void removeFilter (QSensorFilter * filter)</i> - removes from the list the first found entry of the specified filter. </li><li>  <i>QList &lt;QSensorFilter *&gt; filters () const</i> - a list of pointers to all filters the sensor is subscribed to.  The call to handler functions occurs in ascending order of their position in the list. </li></ul><br>  Unlike other Qt Sensors API classes, filters initially do not have an interface for working with them from QML code.  In addition, methods for controlling the filter bank of a particular sensor also cannot be used directly from QML. <br><br>  As an example of using a filter, you can consider the implementation of the accelerometer modes <i>QAccelerometer :: User</i> and <i>QAccelerometer :: Gravity</i> .  This filter can be useful on those devices that do not support accelerometer modes other than <i>Combined</i> .  For this, you also need to attract the rotation sensor - the <i>RotationSensor</i> . <br><br>  Before proceeding with the implementation, you need to insert a couple of clarifying words about the accelerometer operation modes: acceleration caused by gravity and acceleration caused by the device‚Äôs movement by the user the sensor cannot physically distinguish, most devices use systems from several sensors and information available on acceleration of free fall to calculate the effects of gravity only.  And after this information is used to calculate the acceleration caused by the user.  We will use this approach to implement <i>Gravity</i> and <i>User</i> modes. <br><br>  First of all, you need to have a class that performs filtering, which will be inherited from <i>QAccelerometerFilter</i> .  In it we will immediately set the value of G - the acceleration of gravity. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> G 9.80665 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QtSensors&gt; #include &lt;math.h&gt; class AccelerationModeFilter : public QAccelerometerFilter { public: AccelerationModeFilter(); bool filter(QAccelerometerReading *reading); void setAccelerationMode(QAccelerometer::AccelerationMode accelerationMode); QAccelerometer::AccelerationMode getAccelerationMode(); private: QRotationSensor rotationSensor; QAccelerometer::AccelerationMode accelerationMode; };</span></span></span></span></code> </pre><br>  In the class, you need to have two types of properties: <i>QRotationSensor</i> - rotation sensor, we will use it to determine the position of the device in space;  <i>QAccelerometer :: AccelerationMode</i> - measurement mode of the accelerometers value, in accordance with this value the required method of calculating the values ‚Äã‚Äãwill be selected. <br>  When calculating the projections of the acceleration on the coordinate axes, it will be necessary to often resort to trigonometric operations like taking sine and cosine.  For this, the standard library C <i>math.h</i> and its methods <i>sin ()</i> and <i>cos ()</i> will be used.  These methods take angle values ‚Äã‚Äãin radians, while the sensor provides values ‚Äã‚Äãin degrees.  Therefore, we get a small method that will convert the angle values ‚Äã‚Äãfrom degrees to radians: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">qreal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toRadian</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(qreal degree)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> degree * M_PI / <span class="hljs-number"><span class="hljs-number">180</span></span>; }</code> </pre><br>  The mode of calculating the acceleration will be set in the class constructor, in the same place we initialize and activate the tilt sensor: <br><br><pre> <code class="cpp hljs">AccelerationModeFilter::AccelerationModeFilter() : rotationSensor() { rotationSensor.setActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre><br>  The most important part is to override the <i>filter (QAccelerometerReading * reading)</i> method, in which the calculations will be performed: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AccelerationModeFilter::filter(QAccelerometerReading* reading) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (accelerationMode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> QAccelerometer::Gravity: reading-&gt;setX(G * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(toRadian(rotationSensor.reading()-&gt;y()))); reading-&gt;setY(- G * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(toRadian(rotationSensor.reading()-&gt;x()))); reading-&gt;setZ(- zAxisAcceleration(rotationSensor.reading()-&gt;x(), rotationSensor.reading()-&gt;y())); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> QAccelerometer::User: reading-&gt;setX(reading-&gt;x() - G * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(toRadian(rotationSensor.reading()-&gt;y()))); reading-&gt;setY(reading-&gt;y() + G * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(toRadian(rotationSensor.reading()-&gt;x()))); reading-&gt;setZ(reading-&gt;z() + zAxisAcceleration(rotationSensor.reading()-&gt;x(), rotationSensor.reading()-&gt;y())); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AccelerationModeFilter::setAccelerationMode(QAccelerometer::AccelerationMode accelerationMode) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;accelerationMode = accelerationMode; } QAccelerometer::AccelerationMode AccelerationModeFilter::getAccelerationMode() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accelerationMode; }</code> </pre><br>  In the <i>switch statement, we</i> select blocks, each of which will be responsible for its mode of measuring acceleration; there are two such modes: <i>Gravity</i> and <i>User</i> ;  <i>Combined</i> can be skipped, since the values ‚Äã‚Äãinitially go in this mode.  In the <i>switch statement</i> blocks, the acceleration values ‚Äã‚Äãfor each of the axes are recalculated - the values ‚Äã‚Äãare written to the properties of the passed argument <i>reading</i> .  To calculate the acceleration along the X and Y axes, it is enough to simply multiply the gravitational acceleration by the sine of the angle between the smartphone and the corresponding axis of the coordinate plane, and to calculate the acceleration along the Z axis, you will need to apply a transformation matrix.  We implement this in a separate method: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">qreal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zAxisAcceleration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(qreal xDegree, qreal yDegree)</span></span></span><span class="hljs-function"> </span></span>{ qreal xRadian = toRadian(xDegree); qreal yRadian = toRadian(yDegree); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> zCoordinates[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, G}; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> rotationValues[<span class="hljs-number"><span class="hljs-number">9</span></span>] = { -<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(xRadian), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(xRadian), <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(yRadian) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(xRadian), <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(yRadian), -<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(yRadian) * <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(yRadian), -<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(yRadian) * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(xRadian), <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(yRadian), <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(yRadian) * <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(xRadian) }; QGenericMatrix&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; zVector(zCoordinates); QGenericMatrix&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; rotationMatrix(rotationValues); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (rotationMatrix * zVector)(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  Since we do not have a geometry lesson, I think there is no need to explain why the matrix looks that way, but those interested can always turn to <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2586%25D0%25B0_%25D0%25BF%25D0%25BE%25D0%25B2%25D0%25BE%25D1%2580%25D0%25BE%25D1%2582%25D0%25B0">Wikipedia</a> . <br><br>  For the <i>Gravity</i> mode, the calculated acceleration values ‚Äã‚Äãalong the axes are simply written into the corresponding properties of the <i>reading</i> object, since in this case the acceleration values ‚Äã‚Äãdepend only on the position of the device.  To determine the values ‚Äã‚Äãin <i>User</i> mode, the absolute values ‚Äã‚Äãof the obtained calculations must be subtracted from the accelerometer readings - this way we exclude the effect of gravity on the sensor measurements. <br><br>  On this implementation of the filter is over, connect it to the desired accelerometer and use two new modes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QtSensors&gt; #include "accelerometerfilterexample.h" class AccelerometerWithFilter : public QAccelerometer { Q_OBJECT public: AccelerometerWithFilter() : filter() { setActive(true); addFilter(&amp;filter); connect(this, &amp;AccelerometerWithFilter::accelerationModeChanged, [=](AccelerationMode accelerationMode) {this-&gt;filter.setAccelerationMode(accelerationMode);}); } private: AccelerationModeFilter filter; };</span></span></span></span></code> </pre><br><h2>  Conclusion </h2><br>  This and the <a href="https://habrahabr.ru/post/338044/">previous</a> article review the basic sensors available on the Sailfish OS operating system.  And although these examples are very basic, they should acquaint the reader with the capabilities of the Qt Sensors API and show the potential in using the plugin when developing applications. <br><br>  Technical issues can also be discussed on <a href="https://telegram.me/joinchat/CXsImAqrzbAnSZXtAaf-0g">the Sailfish OS Russian-speaking community channel in a Telegram</a> or <a href="https://vk.com/merproject">VKontakte group</a> . <br><br>  Posted by: Maxim Kosterin </div><p>Source: <a href="https://habr.com/ru/post/343530/">https://habr.com/ru/post/343530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343516/index.html">Developers on the dirtiest software tricks in games</a></li>
<li><a href="../343518/index.html">How we rewrote the Yandex.Pogoda architecture and made a global forecast on maps</a></li>
<li><a href="../343522/index.html">Setting up a WEB system - testing based on headless chromium-browser, chromedriver, nightwatch and node.js on Ubuntu</a></li>
<li><a href="../343524/index.html">Network JTAG programmer for Altera Quartus Prime from Raspberry Pi3</a></li>
<li><a href="../343526/index.html">Two geometric tasks that came across at the interview, and where they live</a></li>
<li><a href="../343532/index.html">Mikrotik: Download speed limit for certain IP addresses</a></li>
<li><a href="../343534/index.html">Analysis of the quest Digital Security ICO</a></li>
<li><a href="../343536/index.html">Unnatural diagnostics</a></li>
<li><a href="../343538/index.html">Serverless tensorflow on AWS Lambda</a></li>
<li><a href="../343540/index.html">Google Taxes have been changed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>