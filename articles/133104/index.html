<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tanchiki on node.js - optimization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Thanks to everyone who tried to play for the first time . It is a pity that I disappointed so many people with the terrible game brakes. But I could n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tanchiki on node.js - optimization</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/storage1/ef88cbc8/ab6319a0/d92853e5/2defded0.png">  Thanks to everyone who tried to play for the <a href="http://habrahabr.ru/blogs/gdev/132362/">first time</a> .  It is a pity that I disappointed so many people with the terrible game brakes.  But I could not guess to their reason, if not you.  Now the server is optimized in order, but the number of simultaneous games is increased to just five.  This is insignificant, but the point is not server performance, but the fact that in the worst evening hours the speed of my Internet will not allow it anymore.  Zamanuhi for the sake of the opportunity to choose the level before the start of the game.  And also in response to the <a href="http://habrahabr.ru/blogs/gdev/132362/">‚Äúoffensive‚Äù comment</a> , it became possible to play 2 to 2. So - a <a href="http://bc.vtkd.ru/">demo</a> , <a href="http://bc.rj12.ru/">an alternative server</a> , <a href="http://awesome-domain.ru/">another server</a> .  Now it remains to hope that I did not hurry much, and the server will not fail.  Under the cut, I'll tell you what nonsense I did in the first version. <br><a name="habracut"></a><br><h4>  Profiling </h4><br>  So, to start optimizing something, you need to find the bottlenecks.  In the case of node.js, I did the following: run the game with the key --prof <br><br><pre><code class="bash hljs">node --prof src/server</code> </pre> <br>  Upon completion of the script, the v8.log file will appear in the current folder.  To turn it into something digestible, I used the linux-tick-processor utility from the v8 sources.  I didn‚Äôt go into the details of the linux-tick-processor, but to get it myself and make it work, I had to run several commands: <br><br><pre> <code class="bash hljs">svn co http://v8.googlecode.com/svn/branches/bleeding_edge/ v8 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> v8 svn co http://gyp.googlecode.com/svn/trunk build/gyp make native</code> </pre> <br>  After make native, the out folder with binaries used by the linux-tick-processor will appear in the current folder.  To process v8.log, in the v8 folder, execute: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="bash hljs">tools/linux-tick-processor /full/path/to/v8.log &gt; /full/path/to/v8.out</code> </pre> <br>  In the resulting v8.out see the results.  The info about profiling is taken <a href="http://code.google.com/p/v8/wiki/V8Profiler">from here</a> .  If I do it too hard and someone knows a better way, I will be glad to know. <br><br><h4>  We imitate the load </h4><br>  The second time to tempt fate and bring down the hopes of hundreds of habra people to play tanchiki I did not want.  And I decided to simulate the load on the server on my own.  <a href="http://seleniumhq.org/">Selenium</a> , or rather Selenium Server, is quite suitable for this.  If someone is not familiar, Selenium Server is a java application that can launch almost any browser and execute various commands: click on links, click buttons, check for the presence or absence of certain text on a page, and much more.  Also implemented clients for many programming languages. <br>  For my purposes, I wrote a <a href="http://code.google.com/p/battle-city-js/source/browse/selenium/test.php">small php-script</a> that opens the page, logs in, starts the game and waits 30 seconds.  By running this script to run in multiple consoles: <br><br><pre> <code class="bash hljs">phpunit --repeat=10 test.php</code> </pre> <br>  we get a good way to imitate the load. <br><br><h4>  Optimization 1 - circuit </h4><br>  We start node with the profiler, we process a log, and we watch v8.out.  In the file v8.out, the functions are sorted by descending execution time.  The first in the log is the function Array.forEach: <br><br><pre> <code class="bash hljs">ticks total nonlib name 1514 2.3% 14.9% LazyCompile: *forEach native array.js:1019</code> </pre> <br>  Then I did not immediately understand what was happening.  I decided that this was due to the fact that in some places I use the construction: <br><br><pre> <code class="javascript hljs">someArray.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">)</span></span>{ ... }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre> <br>  With each function call with such a code, a closing function will be created.  But in most places I do not use the possibility of closure, so painlessly rewrote such code to the following: <br><br><pre> <code class="javascript hljs">Class.prototype.handler = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) </span></span>{ ... } Class.prototype.func = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ someArray.forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handler, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Such code should be executed faster, but as it turned out later, this was not the case. <br><br><h4>  Optimization 2 - intersection search </h4><br>  We start the profiler, run the selenium tests and look further: <br><br><pre> <code class="bash hljs"> ticks total nonlib name 31043 3.8% 16.5% LazyCompile: MapArrayed.intersects src/utils/map_arrayed.js:45 26763 3.3% 14.3% Stub: CEntryStub 22800 2.8% 12.1% LazyCompile: *forEach native array.js:1019 16323 2.0% 8.7% LazyCompile: IN native runtime.js:353 13800 1.7% 7.4% Stub: KeyedLoadElementStub 6911 0.9% 3.7% LazyCompile: *MapArrayed.forEach src/utils/map_arrayed.js:59</code> </pre> <br>  Well, not surprising.  Finding intersections takes too much time, you need to rewrite the map.  I described three methods in the <a href="http://habrahabr.ru/blogs/gdev/132362/">last article</a> : a three-dimensional array with indices-coordinates, a list of rectangles and a tree of nested rectangles.  Having played with the tree, I came to the conclusion that with 1000 objects on the map there is no big performance gain.  The idea of ‚Äã‚Äãa three-dimensional array with coordinate indices I don‚Äôt like in principle.  I stopped at the following method: at the base of it there are also objects defined by rectangles, but in order not to run over all map objects each time, the objects are grouped into small cells.  That is, we get the same three-dimensional array, but with a different meaning.  The first two dimensions are the cell indices, in fact they are the same coordinates, only with a rough approximation.  The third dimension is a list of rectangle objects intersecting with a given cell.  The differences from <a href="http://habrahabr.ru/blogs/gdev/132362/">the Oblitus proposal are</a> that this method does not impose any restrictions on the minimum displacement step for objects and the grain size of such an array can be painlessly varied at its discretion.  It is possible that this is still not the best option. <br><br><h4>  Optimization 3 - forEach </h4><br>  Again, look at the results of profiling.  It turns out a strange picture, if I played only one game, then we have: <br><br><pre> <code class="bash hljs"> ticks total nonlib name 51 0.1% 11.6% LazyCompile: *Loggable.log battlecity/src/server/loggable.js:32 12 0.0% 2.7% LazyCompile: MapTiled.intersects battlecity/src/utils/map_tiled.js:106 8 0.0% 1.8% Stub: CEntryStub 6 0.0% 1.4% LazyCompile: *forEach native array.js:1019 4 0.0% 0.9% Stub: StringAddStub 4 0.0% 0.9% Stub: ArgumentsAccessStub_NewNonStrictFast</code> </pre> <br>  If I run selenium and the server has lost a few dozen games: <br><br><pre> <code class="bash hljs"> ticks total nonlib name 4108 2.0% 16.1% LazyCompile: *forEach native array.js:1019 3626 1.8% 14.3% Stub: CEntryStub 2176 1.1% 8.6% LazyCompile: *MapTiled.forEach battlecity/src/utils/map_tiled.js:139 2048 1.0% 8.0% LazyCompile: IN native runtime.js:353 1755 0.9% 6.9% Stub: KeyedLoadElementStub {1} 1475 0.7% 5.8% LazyCompile: *Loggable.log battlecity/src/server/loggable.js:32 337 0.2% 1.3% LazyCompile: MapTiled.intersects battlecity/src/utils/map_tiled.js:106 336 0.2% 1.3% Stub: ToBooleanStub_Bool</code> </pre> <br>  A strange thing, over time forEach () is eating more and more time.  I will say that each object on the map has its own unique id, and this id is global, that is, it only increases with time.  But the number of objects on the map does not change from pariah to pariah.  This is not a very good technique, you can make the object id local for each playing field, so that id does not increase indefinitely, but in javascript arrays are not stored in C ++.  In javascript, this should be something like a hash table, so why is it more and more forEach time?  At this point I had a long time hitting my head against the wall, until I thought of conducting such an experiment: <br><br><pre> <code class="javascript hljs">a=[<span class="hljs-number"><span class="hljs-number">1</span></span>]; a[<span class="hljs-number"><span class="hljs-number">1000000</span></span>]=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">'qwe'</span></span>); a.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">)</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i);}) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">'qwe'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">'asd'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a[i]); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">'asd'</span></span>);</code> </pre> <br>  As a result, we get disappointing results. <br><br>  FF: <br><pre> <code class="bash hljs">qwe: 163ms asd: 2ms</code> </pre> <br>  Chrome: <br><pre> <code class="bash hljs">qwe: 254ms asd: 1ms</code> </pre> <br>  well, Opera for the big picture: <br><pre> <code class="bash hljs">qwe: 0ms (188¬µsec) asd: 0ms (87¬µsec)</code> </pre> <br>  As we see in Opera, forEach () and for (var i in ...) do not fundamentally differ in execution time, but Chrome and Firefox upset me very much, that‚Äôs why the server (and the client) started to slow down a lot in a few games.  There is nothing to do, rewriting forEach () to for (var i in ...).  And, oh, a miracle!  Brakes, which I blamed on memory leaks, disappear! <br><br>  We leave node for a couple of hours by running ‚Äúphpunit --repeat = 100 test.php‚Äù in several consoles and see: <br><br><pre> <code class="bash hljs"> ticks total nonlib name 746 0.2% 16.1% LazyCompile: *Loggable.log battlecity/src/server/loggable.js:28 128 0.0% 2.8% LazyCompile: *Game._stepItem battlecity/src/core/game.js:77 101 0.0% 2.2% LazyCompile: MapTiled.intersects battlecity/src/utils/map_tiled.js:102 61 0.0% 1.3% Stub: CEntryStub 52 0.0% 1.1% Function: EventEmitter.emit events.js:38 50 0.0% 1.1% Stub: SubStringStub 46 0.0% 1.0% LazyCompile: *MapTiled.add battlecity/src/utils/map_tiled.js:24 45 0.0% 1.0% LazyCompile: FILTER_KEY native runtime.js:398</code> </pre> <br>  Finally, the results of the profiling appear things about which I assumed, and not unclear where they came from forEach (). <br><br><h4>  Optimization 4 - traffic </h4><br>  Then I decided to retreat a little from the profiler.  The fact is that in searching for the previous optimization, I counted the traffic between the client and the server.  It turned out in the midst of the game the client can go up to 30kb / c.  Obviously, for such a game as tanchiki - this is an exorbitant figure.  But there are several reasons for this.  First, when changing only one property, the object is sent to the client entirely.  Secondly, the objects are sent to JSON, which also significantly increases the size of the transmitted data.  Initially, objects were sent like this: <br><pre> <code class="javascript hljs">Bullet.prototype.serialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'Bullet'</span></span>, <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id, <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y, <span class="hljs-attr"><span class="hljs-attr">z</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z, <span class="hljs-attr"><span class="hljs-attr">speedX</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.speedX, <span class="hljs-attr"><span class="hljs-attr">speedY</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.speedY, <span class="hljs-attr"><span class="hljs-attr">finalX</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.finalX, <span class="hljs-attr"><span class="hljs-attr">finalY</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.finalY }; };</code> </pre> <br>  which led to the transfer of the string {"type": "Bullet", "id": 777, "x": 123, "y": 456, "z": 1, "speedX": 2, "speedY": 0, ‚ÄúFinalX‚Äù: 123, ‚ÄúfinalY‚Äù: 456} about 100 bytes long.  With a little thought, I remade the serialization of the objects so that the array was not an object, but an array: <br><pre> <code class="javascript hljs">Bullet.prototype.serialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ battleCityTypesSerialize[<span class="hljs-string"><span class="hljs-string">'Bullet'</span></span>], <span class="hljs-comment"><span class="hljs-comment">// 0 this.id, // 1 this.x, // 2 this.y, // 3 this.speedX, // 4 this.speedY, // 5 this.finalX, // 6 todo remove this.finalY // 7 todo remove ]; };</span></span></code> </pre> <br>  as a result, we get about 25 bytes [0.777,123,456,2,0,123,456].  Traffic dropped to about 7-8kb / s at the height of the game.  It can be reduced several times, passing only changed properties and passing only control commands, but I left this alteration for the future. <br><br><h4>  Optimization 5 - synchronization with the client </h4><br>  The synchronization algorithm from the <a href="http://habrahabr.ru/blogs/gdev/132362/">previous article</a> was unsuccessful.  The only reason for this choice, rather than the instant distribution of changes to all customers who are interested in them, was that a newly connected customer can receive all changes in the past in the same way as the current data.  Also, during the implementation of this method, I came up with the idea of ‚Äã‚Äãgrouping objects in a collection, and looking for updates not to the objects themselves, but to collections of objects.  Such collections include ‚Äúall users‚Äù, ‚Äúmessages in the general chat‚Äù, ‚Äúlist of games‚Äù, ‚Äúusers in the current game‚Äù, ‚Äúmessages in the current game‚Äù and ‚Äúobjects on the map of the current game‚Äù. <br>  A new method of synchronization is the immediate distribution of changes to User objects, where they accumulate.  And the User object still sends data to the browser with packets every 50ms.  The question remains when and how to synchronize the original data?  I decided to add the User 2 object to the object: watchCollection () and unwathCollection () and at the time of connecting to the group of objects, User sends all the objects to the client as newly created: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @param collection * @param syncKey ,          */</span></span> ServerUser.prototype.watchCollection = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">collection, syncKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unwatchCollection(syncKey); <span class="hljs-comment"><span class="hljs-comment">//      this.updateCollector[syncKey] = []; var user = this; var cb = function(item, type) { user.onCollectionUpdate(syncKey, item, type); }; //    collection.on('update', cb); //  callback,     ,     this.collections[syncKey] = {'callback': cb, 'collection': collection}; //     ,    collection.traversal(function(item){ this.onCollectionUpdate(syncKey, item, 'add'); }, this); }; ServerUser.prototype.unwatchCollection = function(syncKey) { if (this.collections[syncKey]) { //   this.collections[syncKey].collection.removeListener('update', this.collections[syncKey].callback); //  ,        this.clientMessage('clearCollection', syncKey); delete this.collections[syncKey]; delete this.updateCollector[syncKey]; } };</span></span></code> </pre> <br>  Thus, immediately after the user is authorized on the server, the User object is connected to three groups of objects (collections): <br><pre> <code class="javascript hljs">user.watchCollection(registry.users, <span class="hljs-string"><span class="hljs-string">'users'</span></span>); user.watchCollection(registry.premades, <span class="hljs-string"><span class="hljs-string">'premades'</span></span>); user.watchCollection(registry.messages, <span class="hljs-string"><span class="hljs-string">'messages'</span></span>);</code> </pre> <br>  And during the entry into the game and exit from the game, the user respectively connects and disconnects from other collections of interest: <br><pre> <code class="javascript hljs">Premade.prototype.join = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, clanId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... user.watchCollection(this.users, 'premade.users'); user.watchCollection(this.messages, 'premade.messages'); // ... }; Premade.prototype.unjoin = function(user) { // ... user.unwatchCollection('premade.users'); user.unwatchCollection('premade.messages'); user.unwatchCollection('f'); user.unwatchCollection('game.botStack'); // ... }; Premade.prototype.startGame = function() { // ... this.users.traversal(function(user){ // ... user.watchCollection(this.game.field, 'f'); user.watchCollection(user.clan.enemiesClan.botStack, 'game.botStack'); // ... }, this); // ... }</span></span></code> </pre><br>  It is a pity that simple and correct thoughts do not immediately come to mind. <br>  As a result, we have: <br><pre> <code class="bash hljs"> ticks total nonlib name 2074 0.5% 9.9% LazyCompile: *Game._stepItem battlecity/src/core/game.js:29 751 0.2% 3.6% LazyCompile: MapTiled.intersects battlecity/src/utils/map_tiled.js:102 489 0.1% 2.3% LazyCompile: MapTiled.traversal battlecity/src/utils/map_tiled.js:132 376 0.1% 1.8% LazyCompile: FILTER_KEY native runtime.js:398</code> </pre> <br>  Judging by the fact that Game._stepItem came out on top, and began to run 9.9% of the time, not 2.8%, as before, we consider the remake successful.  At this point, the server is loaded at about 50% with 10 simultaneous games.  I did not dare to put 20 games at the same time in the demo, due to the fact that in the worst evening hours, the speed of my Internet drops to 200kByte / s and lower. <br><br><h4>  Optimization 6 - bypass game objects </h4><br>  Initially, I did not think about it, and for each object on the field in the loop I called the _stepItem () function: <br><pre> <code class="javascript hljs">Game.prototype._stepItem = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// tanks and Base processing within Clan.step if (item.step &amp;&amp; !(item instanceof Tank) &amp;&amp; !(item instanceof Base)) { // todo item.step(); } }; Game.prototype.step = function() { this.field.traversal(this._stepItem, this); this.premade.clans[0].step(); this.premade.clans[1].step(); };</span></span></code> </pre><br><br>  This function is called for all pieces of the wall, and also checks the prototype of each object.  To get rid of this disgrace, I started an array of stepableItems, which changes when adding and removing objects from the map.  And you no longer need to do complex checks in the frequently called function: <br><pre> <code class="javascript hljs">Game = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Game</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">level, premade</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... this.stepableItems = []; this.field.on('add', this.onAddObject.bind(this)); this.field.on('remove', this.onRemoveObject.bind(this)); // ... }; Game.prototype.onAddObject = function(object) { if (object.step &amp;&amp; !(object instanceof Tank) &amp;&amp; !(object instanceof Base)) { this.stepableItems[object.id] = object; } }; Game.prototype.onRemoveObject = function(object) { delete this.stepableItems[object.id]; }; Game.prototype.step = function() { for (var i in this.stepableItems) { this.stepableItems[i].step(); } // ... };</span></span></code> </pre><br><br>  As a result, I returned again to the intersection of objects, but at a completely different level: <br><pre> <code class="bash hljs">ticks total nonlib name 129 0.0% 2.4% LazyCompile: MapTiled.intersects battlecity/src/utils/map_tiled.js:102 66 0.0% 1.2% Stub: SubStringStub 54 0.0% 1.0% Stub: CEntryStub 47 0.0% 0.9% Function: EventEmitter.emit events.js:38 39 0.0% 0.7% LazyCompile: MapTiled.add battlecity/src/utils/map_tiled.js:24 30 0.0% 0.6% Function: Socket._writeOut net.js:389</code> </pre><br><br>  Now 5 games simultaneously occupy 15-16% of CPU time.  That is, my old server should pull about 30 games in one stream. <br><br><h4>  Bug with inheritance </h4><br>  I had to contend with one bug, the reasons for which deserve attention.  When inheriting, I forgot to call the parent "constructor": <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.property = []; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Child</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Parent.apply(this, argiments); -  }; Child.prototype = new Parent(); Child.prototype.constructor = Child;</span></span></code> </pre> <br>  As a result, the property array was only in prototype, and not in this.  That is, shared between all instances of Child, which did not cause any run-time errors, but led to a hard-to-find bug.  All the same, with javascript it costs nothing to shoot yourself a leg. <br><br><h4>  Future plans </h4><br>  The first thing I plan to do is reduce traffic, and I think I will start with an idea floating in the air - transferring only control commands to the client, such as ‚Äústart‚Äù, ‚Äústop‚Äù, etc.  I thought there might be problems with desync.  But it seems to me that they are easy to solve, if you send coordinates for synchronization with each control command. <br>  You also need to optimize the client, but I have no specific ideas yet.  More precisely, I have not yet profiled the client, and I don‚Äôt know what it‚Äôs slowing down there.  In general, this project is interesting to me not for the sake of the game itself, but as a subject for any ideas.  For example, in order to read books on the PLO or some articles, I had at hand a code to which I could apply the knowledge gained.  So I will be glad to advice that you can read. <br><br>  <a href="http://habrahabr.ru/blogs/gdev/132362/">First part</a> </div><p>Source: <a href="https://habr.com/ru/post/133104/">https://habr.com/ru/post/133104/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133097/index.html">Processing XML configurations of Citrix XenServer 5.6 Free directly</a></li>
<li><a href="../133098/index.html">Bynet is back again</a></li>
<li><a href="../133099/index.html">Video review of Android applications and games - kedDroid</a></li>
<li><a href="../133102/index.html">Hail Direct Connect, Hail!</a></li>
<li><a href="../133103/index.html">Today! Live Broadcast Lecture</a></li>
<li><a href="../133107/index.html">Openflow for dummies</a></li>
<li><a href="../133108/index.html">On one problem of running Backup and Restore when using OpenSource code from CodeGuru site</a></li>
<li><a href="../133111/index.html">Search for volunteer guides</a></li>
<li><a href="../133115/index.html">Adobe will release Flash for Android 4.0 Ice Cream Sandwich by the end of the year.</a></li>
<li><a href="../133116/index.html">DYN also against SOPA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>