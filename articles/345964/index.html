<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On the question of the principles of asynchronous solutions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We offer you a great New Year reading for programmers :) The article by Alexander Chistyakov ( alexclear ), which he wrote inspired by the theses of t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On the question of the principles of asynchronous solutions</h1><div class="post__text post__text-html js-mediator-article">  We offer you a great New Year reading for programmers :) The article by <strong><nobr>Alexander Chistyakov</nobr></strong> ( <a href="https://habrahabr.ru/users/alexclear/" class="user_link">alexclear</a> ), which he wrote inspired by the theses of the <strong><nobr>Mons Anderson</nobr></strong> report ( <a href="https://habrahabr.ru/users/codesign/" class="user_link">codesign</a> ) on HighLoad ++ 2017. <br><br><img src="https://habrastorage.org/webt/wa/l9/lt/wal9ltnuhseada6i2ffv-uwwqnu.jpeg" alt="Alexander Chistyakov"><br><br>  Let's talk about the principles of asynchronous solutions and consider the classification <a href="http://www.highload.ru/2017/abstracts/3027.html">proposed by</a> <nobr>Mons Anderson</nobr> .  We may be able to offer our own <strong>classification</strong> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In order to classify existing solutions, we first invent the coordinate axes.  From the point of view of the development engineer, the ‚Äú <strong>synchronous</strong> ‚Äù and ‚Äú <strong>asynchronous</strong> ‚Äù paradigms are based on abstractions that differ in both complexity of application and ‚Äúefficiency‚Äù (we still have to determine what ‚Äúefficiency‚Äù is). <br><br>  Carefully, under the cut <strong>hard hardcore</strong> ! <a name="habracut"></a><br><br>  As for the complexity of the application, it is believed that synchronous programming is simpler than asynchronous.  First, using the synchronous paradigm does not disturb the order of instructions in the algorithm.  Secondly, it is easier to control the scope of variables. <br><br><h2>  Asynchronous paradigm </h2><br>  In order to understand what tasks the asynchronous paradigm solves, consider the work of the program at a low level. <br><br><h3>  OS Scheduler </h3><br>  From the point of view of the operating system, the program's algorithm utilizes computer resources, the main ones being the processor (CPU) and memory.  The operating system scheduler is responsible for assigning the process to one of the processor cores. <br><br>  When changing a process on the processor core, it is necessary to perform a context switch, saving all the current processor registers to memory and recovering the processor registers from the memory corresponding to the process or thread destined for execution.  This operation takes about 200 processor cycles for modern processors (which is quite expensive). <br><br>  I / O operations are performed using the DMA mechanism, while the CPU is not involved in the process.  Despite the fact that in Linux, I / O processes are formally accounted as assigned to the CPU, in fact, such processes do not occupy the processor and end up in the uninterruptible sleep (D-state) state.  At the time of implementation of I / O by one process, the scheduler assigns another process to the processor. <br><br>  From the point of view of the OS scheduler, OS threads (at least in Linux) are just processes - each of them has its own independent context, blocking I / O operations from one of the threads does not affect the work of other threads. <br><br>  Thus, the removal of the OS thread from the execution on the processor can occur in two cases: <br><ol><li>  the time slot allotted for execution has ended; </li><li>  The thread performed a synchronous I / O operation (one that must wait for its completion). </li></ol><br><br><h3>  Java </h3><br>  The classical (as in modern Java) model of synchronous parallel processing is focused on using operating system threads as runtime (virtual machine) language.  Strictly speaking, runtime and virtual machine are different concepts, but for us it is not important. <br><br>  If our program serves client connections, then <strong>each client will require a separate operating system thread to maintain the connection</strong> .  In this case, the number of context switches between operating system threads will be proportional to the number of client connections (see ‚Äúefficiency‚Äù above). <br><blockquote>  Suppose we need to serve 10,000 client connections ‚Äî we have to generate 10,000 operating system threads, which is <strong>technically possible.</strong> </blockquote><br><h3>  Perl </h3><br>  Such a multithreading model, as in Java, does not work in most modern language interpreters (Python, Ruby (threads in Ruby are not operating system threads at all)) because of GIL.  Standard threading in Perl is implemented according to the same principles as in Java - the Perl stream is the OS thread, but each thread is executed by its own interpreter (see "efficiency" again - this is much less efficient than threads in Java). <br><blockquote>  Suppose we need to serve the same 10,000 connections ‚Äî now we have to generate 10,000 separate copies of the Perl interpreter, which <strong>is technically impossible.</strong> </blockquote><br><h3>  N: 1 </h3><br>  In order to optimize context switches for mass I / O for a large number of connected clients, instead of OS threads, emulation of the cooperative multitasking mechanism is used directly at the runtime level or programming language interpreter. <br><br>  In this case, the ‚Äúthreads‚Äù exist only within the interpreter process and the OS scheduler knows nothing about them.  Therefore, the interpreter itself must do the switching between such threads, and it does this in two cases: the thread explicitly executes the yield command or a similar, transferring control to another thread, or the thread performs an I / O operation.  Such a multithreading model is called ‚ÄúN: 1‚Äù - <strong>several threads of the OS kernel correspond to several threads of the interpreter level</strong> . <br><br>  However, if the I / O operation is synchronous, the OS-level flow will fall into the D-state and will be removed from the execution on the processor until the end of the I / O operation.  This will lead to the fact that all N threads running in this OS thread will be blocked until the end of the I / O operation in one of them (see "efficiency"). <br><br><h3>  Callbacks </h3><br>  Fortunately, the core has an asynchronous (with some reservations) I / O mechanism, using which the calling OS-level thread does not wait for the end of the I / O operation, but continues execution.  At the same time, at the end of the I / O operation, the callback registered by the user will be called. <br><br>  To use asynchronous I / O, it is sufficient to put the socket in asynchronous mode using the <strong>fcntl (2)</strong> system call. <br><blockquote>  Imagine that we need to serve 10,000 connections ‚Äî to do this, we need to execute the read command on 10,000 open sockets. </blockquote><br>  In order to increase efficiency, a mechanism was invented that allows to combine open file descriptors into a common data structure in the kernel and to perform asynchronous I / O operations on a group of sockets.  Initially, the <strong>select (2)</strong> system call was such a mechanism.  The problem with the select call is that when an event occurs, it is necessary to cycle through all registered file descriptors in order to determine which of them caused the event ‚Äî the algorithmic complexity of such enumeration is proportional to the number of open file descriptors. <br><br>  In order to guarantee the constant algorithmic complexity of finding the right sockets, the mechanisms <strong>kqueue</strong> (FreeBSD) and <strong>epoll (7)</strong> (Linux) were implemented. <br><br>  When using epoll, the OS execution thread is busy registering / deleting open file descriptors and preparing asynchronous I / O calls, as well as processing triggered callbacks.  If your program does not use yield, then it becomes critical to prevent CPU-intensive calculations between I / O operations, as this will disrupt the fair distribution of processor resources between threads of the interpreter level (or runtime). <br><br><h3>  Golang and Node.JS </h3><br>  We have just described the mechanism of the Golang language runtime.  The only difference is that the multithreading mechanism in Golang is not N: 1, but N: M, where M is the number of processor cores.  The rantaym Golang can automatically switch <strong>gorutiny</strong> not only at the time of I / O, but also at the time of calling other functions (while the infinite loop utilizes 100% of the processor time in the corresponding OS thread and will never be stopped by runtime). <br><br>  The <strong>Node.JS</strong> interpreter <strong>is</strong> also built around the <strong>epoll</strong> (more precisely, around the code from nginx), only it uses <strong>the N: 1 model</strong> and then the single core does not scale. <br><br>  In some cases, a scheduler similar to the Golang runtime scheduler is implemented as a library or transpiler (for example, <a href="http://search.cpan.org/dist/Coro/">Coro</a> in Perl or <strong>async / await</strong> in JS using Babel), which allows the use of corutines in languages ‚Äã‚Äãthat lack their support at the interpreter level. <br><br><h3>  Attempt to classify </h3><br>  Based on the above, I would suggest the following classification of multi-threaded schemes: <br><ol><li>  Classical implementation of runtime threads through OS threads; </li><li>  Implementation of corutin of the form N: 1 or N: M; </li><li>  Low-level work with asynchronous I / O by manually registering callbacks and writing the appropriate noodles (do not forget to create a hashmap for contexts somewhere). </li></ol><br><div class="spoiler">  <b class="spoiler_title">Mons classification around HTTP requests processing</b> <div class="spoiler_text">  Now to the <a href="http://www.highload.ru/2017/abstracts/3027.html">classification of Mons</a> .  As I understand it, it is built around the task of processing HTTP requests and uses the classical terminology of the Apache web server. <br><br>  Apparently, a <strong>single process server</strong> is just a synchronously working server that can process only one request at a time. <br><br>  <strong>The forking server</strong> is a server that generates a separate process for each request being processed (see ‚Äúefficiency‚Äù, in Linux, fork (2) uses the CoW mechanism, and that would be even worse). <br><br>  <strong>The preforking server</strong> is a classic of the Apache world, the creation of workflows in advance in a given quantity, the processing is still synchronous. <br><br>  About the fact that callbacks are worse than coroutine, we spoke above to feel the difference on ourselves, write the code first with callbacks, and then with corutines, or just study the source code of nginx.  Why do people want to make code on callbacks more than once in their lives, I do not know, it would be better to register in the section for mountaineering or parachuting. <br><br>  What is an <strong>async prefork</strong> is apparently the implementation of <strong>the N: M mechanism</strong> when M worker processes are running. <br><br>  I don‚Äôt know what an <strong>async + worker is</strong> because the worker differs from the prefork in the Apache world, as far as I remember, in that the worker flows workflows instead of workflows (from the point of view of the OS there is no difference, there is a difference from the point of view of shared state , and mutable shared state - this is the reason why you are depressed first, and then fired). <br><br>  What is <strong>multithreaded async</strong> ?  According to my (she is not mine, I myself, lazy and sinful, did not invent anything) the classification is again <strong>N: M</strong> , I don‚Äôt know why there are three names for the same thing. <br></div></div><br><h4>  We have not defined what ‚Äúefficiency‚Äù is.  Not needed. </h4><br>  PS: By the way, the report was not heard then (the report was not ready, although we wanted it very much), but we hope to hear it at the <a href="http://junior.highload.ru/">HighLoad ++ Junior</a> this spring.  Where we continue our discussion :) </div><p>Source: <a href="https://habr.com/ru/post/345964/">https://habr.com/ru/post/345964/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345954/index.html">Simplify the work with RecyclerView</a></li>
<li><a href="../345956/index.html">History 3 places Russian AI Cup 2017</a></li>
<li><a href="../345958/index.html">How I wrote the game in 6 days</a></li>
<li><a href="../345960/index.html">ICA (state machine) for teapots on the example of the class "button" in the arduino</a></li>
<li><a href="../345962/index.html">Coding with the withdrawal of information. Part 2, Mathematical</a></li>
<li><a href="../345968/index.html">System for collecting, analyzing, notifying and visualizing logs on syslog-ng, elasticsearch, kibana, grafana, elasticalert</a></li>
<li><a href="../345972/index.html">TAU for the smallest: an example of the implementation of the PID controller in Unity3D</a></li>
<li><a href="../345974/index.html">Akumuli - time series database</a></li>
<li><a href="../345976/index.html">Docker is dead</a></li>
<li><a href="../345978/index.html">What are the images of the future we draw the largest IT companies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>