<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Explaining the inexplicable. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In preparation for the PG Day'16 conference, we continue to acquaint you with interesting aspects of PostgreSQL. And today we offer you a translation ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Explaining the inexplicable. Part 3</h1><div class="post__text post__text-html js-mediator-article">  <i>In preparation for the PG Day'16 conference, we continue to acquaint you with interesting aspects of PostgreSQL.</i>  <i>And today we offer you a translation of the third article in the explain series</i> <br><br>  In <a href="https://habrahabr.ru/post/275851/">previous</a> <a href="https://habrahabr.ru/post/276973/">posts in</a> this series, I wrote about how to interpret a single line in the explain analysis output, its structure, and also described the basic data retrieval operations (nodes of the explain tree). <br><br>  Today we will move to more complex operations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/76d/be5/f83/76dbe5f831394c13905b724f1f8b64ce.jpg"><br><a name="habracut"></a><br><h4>  <font color="#adadad">Function scan</font> </h4><br>  Example: <br><br><pre><code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_Series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>) i; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------------------------------------- Function Scan on generate_series i (cost=0.00..10.00 rows=1000 width=4) (actual time=0.012..0.013 rows=10 loops=1) Total runtime: 0.034 ms (2 rows)</span></span></code> </pre> <br>  By and large, it is so simple that there is no special need to explain something.  But since this operation will be used in the following examples, I will still write a little about it. <br><br>  Function Scan is a very simple node.  It runs a function that returns a recordset (recordset), that's all.  It will not run functions like ‚Äúlower ()", but only those that potentially return multiple rows or columns. When the function returns, the rows will be transferred to the node that is at a level above the Function Scan in the plan tree, or to the client if Function Scan is the root node. <br><br>  The only additional logic that may arise here is the ability to filter the resulting lines, like this: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_Series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>) i <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------------- Function Scan on generate_series i (cost=0.00..12.50 rows=333 width=4) (actual time=0.012..0.014 rows=2 loops=1) Filter: (i &lt; 3) Rows Removed by Filter: 8 Total runtime: 0.030 ms (4 rows)</span></span></code> </pre><br><h4>  <font color="#adadad">Sort</font> </h4><br>  I think it's pretty simple to understand - sort takes the selected records and returns them sorted in a certain way. <br><br>  Example: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> relname; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------------------------------- Sort (cost=22.88..23.61 rows=292 width=203) (actual time=0.230..0.253 rows=295 loops=1) Sort Key: relname Sort Method: quicksort Memory: 103kB -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=203) (actual time=0.007..0.048 rows=295 loops=1) Total runtime: 0.326 ms (5 rows)</span></span></code> </pre><br>  Although it is simple, there is an interesting logic inside.  To begin with, if the memory required for sorting is greater than the value of <a href="http://www.depesz.com/2011/07/03/understanding-postgresql-conf-work_mem/">work_mem</a> , then the switch to disk sorting will occur: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> random() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">14000</span></span>) i <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> x; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------------------------ Sort (cost=62.33..64.83 rows=1000 width=0) (actual time=16.713..18.090 rows=14000 loops=1) Sort Key: (random()) Sort Method: quicksort Memory: 998kB -&gt; Function Scan on generate_series i (cost=0.00..12.50 rows=1000 width=0) (actual time=2.036..4.533 rows=14000 loops=1) Total runtime: 18.942 ms (5 rows) $ explain analyze select random() as x from generate_series(1,15000) i order by x; QUERY PLAN ------------------------------------------------------------------------------------------------------------------------------ Sort (cost=62.33..64.83 rows=1000 width=0) (actual time=27.052..28.780 rows=15000 loops=1) Sort Key: (random()) Sort Method: external merge Disk: 264kB -&gt; Function Scan on generate_series i (cost=0.00..12.50 rows=1000 width=0) (actual time=2.171..4.894 rows=15000 loops=1) Total runtime: 29.767 ms (5 rows)</span></span></code> </pre><br>  Notice the Sort Method change in the example above. <br><br>  In such cases, Postgres uses temporary files that are stored in the $ PGDATA / base / pgsql_tmp / directory.  Of course, they will be removed as soon as they are no longer necessary. <br><br>  Another additional property is that Sort can change its method of operation if it is called by the Limit operation, like this: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------------------------------------- Limit (cost=15.77..15.78 rows=5 width=203) (actual time=0.119..0.120 rows=5 loops=1) -&gt; Sort (cost=15.77..16.50 rows=292 width=203) (actual time=0.118..0.118 rows=5 loops=1) Sort Key: relfilenode Sort Method: top-N heapsort Memory: 26kB -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=203) (actual time=0.005..0.047 rows=295 loops=1) Total runtime: 0.161 ms (6 rows)</span></span></code> </pre><br>  Usually, to sort the selected data set, you need to process it entirely.  But Postgres knows that if you need only a small number of rows, it does not need to sort the entire data set, it is enough to get only the first values. <br><br>  In the Big O notation, the total sort has O (m * log (m)) complexity, but Top-N has O (m * log (n)) complexity, where m is the number of rows in the table, and n is the number of returned rows.  It is important to know that this sorting method also uses much less memory (after all, it does not need to collect the entire data set from sorted lines, a couple of lines is enough), so it is less likely to use a slow disk for temporary files. <br><br><h4>  <font color="#adadad">Limit</font> </h4><br>  I have used limit repeatedly because it is very simple, but still let's discuss it in detail.  The limit operation starts its sub-operation and returns only the first N lines from the one that the sub-operation returned.  Usually after this, it stops the sub-operation, but in some cases (for example, a call to the pl / PgSQL function), the sub-operation has already completed its work by the time it returns the first line. <br><br>  A simple example: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------------------------- Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=203) (actual time=0.008..0.047 rows=295 loops=1) Total runtime: 0.096 ms (2 rows) $ explain analyze select * from pg_class limit 2; QUERY PLAN ------------------------------------------------------------------------------------------------------------- Limit (cost=0.00..0.07 rows=2 width=203) (actual time=0.009..0.010 rows=2 loops=1) -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=203) (actual time=0.008..0.009 rows=2 loops=1) Total runtime: 0.045 ms (3 rows)</span></span></code> </pre><br>  As you can see, the use of the limit in the second case led to the fact that the nested Seq Scan operation completed its work immediately after finding two lines. <br><br><h4>  <font color="#adadad">Hashagregate</font> </h4><br>  This operation is mainly used in cases when you use GROUP BY and some aggregates, like sum (), avg (), min (), max () and others. <br><br>  Example: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relkind, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_Class <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> relkind; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------- HashAggregate (cost=12.38..12.42 rows=4 width=1) (actual time=0.223..0.224 rows=5 loops=1) -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=1) (actual time=0.008..0.053 rows=295 loops=1) Total runtime: 0.273 ms (3 rows)</span></span></code> </pre><br>  HashAggregate does the following: for each line it receives, it finds a GROUP BY ‚Äúkey‚Äù (in this case, relkind).  Then in the hash (associative array, dictionary) puts the selected row in the basket indicated by the given key. <br><br>  After all rows have been processed, it scans the hash and returns one row for each key value, making relevant calculations as necessary (sum, min, avg, and so on). <br><br>  It is important to understand that HashAggregate must scan all rows before it can return at least one. <br><br>  If you understand this, then you probably see a potential problem: what to do in a situation where you have millions of lines?  The hash will be too large to fit in memory.  And here we will use <a href="http://www.depesz.com/2011/07/03/understanding-postgresql-conf-work_mem/">work_mem again</a> .  If the generated hash is too large, it will merge onto the disk (again in $ PGDATA / base / pgsql_tmp). <br><br>  This means that if there are both HashAggregate and Sort in the plan, we can use up to 2 * work_mem.  Such a plan is easy to obtain: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relkind, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_Class <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> relkind <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> relkind; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------------- Sort (cost=12.46..12.47 rows=4 width=1) (actual time=0.260..0.261 rows=5 loops=1) Sort Key: relkind Sort Method: quicksort Memory: 25kB -&gt; HashAggregate (cost=12.38..12.42 rows=4 width=1) (actual time=0.221..0.222 rows=5 loops=1) -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=1) (actual time=0.006..0.044 rows=295 loops=1) Total runtime: 0.312 ms (6 rows)</span></span></code> </pre><br>  In reality, a single query can use work_mem many times, since work_mem is a restriction for an operation.  Therefore, if the request uses 1000 HashAggregates and Sorts (and other operations that use work_mem), the total memory consumption can be very high. <br><br><h4>  <font color="#adadad">Hash Join / Hash</font> </h4><br>  Since we have just discussed HashAggregate, it will be logical to go to Hash Join. <br><br>  This operation, unlike the previous one, has <i>two</i> suboperations.  One of them is always ‚ÄúHash", and the second is something else. <br><br>  As the name implies, Hash Join is used to merge two sets of records.  For example, like here: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class c <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> pg_namespace n <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.relnamespace = n.oid; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------------------------------------------------- Hash Join (cost=1.14..16.07 rows=292 width=316) (actual time=0.036..0.343 rows=295 loops=1) Hash Cond: (c.relnamespace = n.oid) -&gt; Seq Scan on pg_class c (cost=0.00..10.92 rows=292 width=203) (actual time=0.007..0.044 rows=295 loops=1) -&gt; Hash (cost=1.06..1.06 rows=6 width=117) (actual time=0.012..0.012 rows=6 loops=1) Buckets: 1024 Batches: 1 Memory Usage: 1kB -&gt; Seq Scan on pg_namespace n (cost=0.00..1.06 rows=6 width=117) (actual time=0.004..0.005 rows=6 loops=1) Total runtime: 0.462 ms (7 rows)</span></span></code> </pre><br>  This works as follows: first, Hash Join calls ‚ÄúHash", which in turn calls something else (in our case, Seq Scan by pg_namespace). Then Hash creates a hash / in memory (or on a disk, depending on the size) associative array / dictionary with strings from the source, hashed using what is used to merge the data (in our case, this is the OID column in pg_namespace). <br><br>  Of course, you may have many rows for the join join (not in this case, since I join with the primary key, but in general it‚Äôs likely that you will have multiple rows for one hash key). <br><br>  In Perl notation, the output of Hash will be something like this: <br><br><pre> <code class="perl hljs">{ <span class="hljs-string"><span class="hljs-string">'123'</span></span> =&gt; [ { data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row with OID = <span class="hljs-number"><span class="hljs-number">123</span></span> }, ], <span class="hljs-string"><span class="hljs-string">'256'</span></span> =&gt; [ { data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row with OID = <span class="hljs-number"><span class="hljs-number">256</span></span> }, ], ... }</code> </pre><br>  Then Hash Join starts the second sub-operation (Seq Scan by pg_class in our case) and, for each line from it, does the following: <br><ol><li>  Checks if the join key (pg_class.relnamespace in this case) is in the hash returned by the Hash operation. </li><li>  If not, this string from the sub-operation is ignored (will not be returned). </li><li>  If the key exists, Hash Join takes the lines from the hash and, based on this line, on the one hand, and all the lines of the hash, on the other hand, generates the output of the lines. </li></ol><br>  It is important to note that both sides of the join are executed only once (in our case, both are seq scan), but first, the one that was caused by the Hash operation must return all the rows that were stored in the hash, and the second is processed line by line, and some lines will be skipped if they do not exist in the first-party hash (I hope this sentence is understandable, despite the abundance of hashes). <br><br>  Since both subscans can be any type of operation, they can be filters, index scans, or what you can imagine. <br><br>  The last thing worth mentioning in connection with Hash Join / Hash is that Hash operation, just like Sort and HashAggregate, will use memory up to work_mem. <br><br><h4>  <font color="#adadad">Hash Join / Hash</font> </h4><br>  Since we are talking about associations, it is worth discussing the Nested Loop.  Example: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class c <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> pg_attribute a <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.oid = a.attrelid <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.relname <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ( <span class="hljs-string"><span class="hljs-string">'pg_class'</span></span>, <span class="hljs-string"><span class="hljs-string">'pg_namespace'</span></span> ); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------------------------------------------------------------------------------------- Nested Loop (cost=0.28..52.32 rows=16 width=203) (actual time=0.057..0.134 rows=46 loops=1) -&gt; Seq Scan on pg_class c (cost=0.00..11.65 rows=2 width=4) (actual time=0.043..0.080 rows=2 loops=1) Filter: (relname = ANY ('{pg_class,pg_namespace}'::name[])) Rows Removed by Filter: 291 -&gt; Index Scan using pg_attribute_relid_attnum_index on pg_attribute a (cost=0.28..20.25 rows=8 width=203) (actual time=0.007..0.015 rows=23 loops=2) Index Cond: (attrelid = c.oid) Total runtime: 0.182 ms</span></span></code> </pre><br>  This is a very interesting plan, because it can perform selected operations repeatedly. <br><br>  Like Hash Join, Nested Loop has two ‚Äúdescendants‚Äù.  First, it starts ‚ÄúSeq Scan" (in our example, first it starts the first node), and then, for each returned row (only 2 lines in our example), it starts the second operation (Index Scan on pg_attribute in our case). <br><br>  You may have noticed that Index Scan in actual meta-information is ‚Äúloops = 2". This means that this operation was run twice, and other values ‚Äã‚Äã(lines, time) are average values ‚Äã‚Äãfor all launches. <br><br>  Let's look at the next plan from <a href="http://explain.depesz.com/s/gsg">explain.depesz.com</a> .  Note that the actual execution time for all index scan operations for categories is from 0.002 to 0.003ms.  But the total time spent on this node is 78.852ms, because this index scan was performed more than 26k times. <br><br>  So the processing is as follows: <br><ol><li>  Nested Loop launches the first side of the merge once.  Let's call it ‚ÄúA". </li><li>  For each line from ‚ÄúA", the second operation is started (let's call it ‚ÄúB"). </li><li>  If ‚ÄúB" did not return any rows, the data from "A" is ignored. </li><li>  If ‚ÄúB" returned rows, for each row returned, the Nested Loop returns a new row based on the current rows from A and B. </li></ol><br><h4>  <font color="#adadad">Merge join</font> </h4><br>  Another method to merge data is called Merge Join.  It is used if the datasets to be merged are sorted (or can be sorted at low cost) using the join key. <br><br>  I do not have a ready-made visual example, so I will create it artificially with the help of subqueries that sort the data before merging: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_attribute a <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> attrelid) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.oid = a.attrelid; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------------------------------------------------------------------------------------------------- Merge Join (cost=23.16..268.01 rows=2273 width=410) (actual time=0.658..3.779 rows=2274 loops=1) Merge Cond: (pg_class.oid = a.attrelid) -&gt; Sort (cost=22.88..23.61 rows=292 width=207) (actual time=0.624..0.655 rows=293 loops=1) Sort Key: pg_class.oid Sort Method: quicksort Memory: 102kB -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=207) (actual time=0.011..0.211 rows=293 loops=1) -&gt; Materialize (cost=0.28..212.34 rows=2273 width=203) (actual time=0.028..1.264 rows=2274 loops=1) -&gt; Index Scan using pg_attribute_relid_attnum_index on pg_attribute a (cost=0.28..183.92 rows=2273 width=203) (actual time=0.015..0.752 rows=2274 loops=1) Total runtime: 4.009 ms (9 rows)</span></span></code> </pre><br>  Merge Join, like other unions, runs two suboperations (Sort and Materialize in this case).  Since both of them return the data in sorted order and the sorting order is the same as in the merge operation, Pg can scan both data sets returned by the suboperations and at the same time just check if the identifiers match. <br><br>  The procedure is as follows: <br><ul><li>  if the right column to be merged is the same as the left to be merged column: <br><ul><li>  return a new merged string based on the current lines to the right and left; </li><li>  take the next line to the right (or to the left, if there are no more lines to the right); </li><li>  go back to step 1; </li></ul></li><li>  if the column to be merged on the right is ‚Äúless‚Äù than the column to be merged on the left: <br><ul><li>  we take the next line on the right (if there are no more lines, we finish processing); </li><li>  go back to step 1; </li></ul></li><li>  if the mergeable column on the right is ‚Äúlarger‚Äù than the merging column on the left: <br><ul><li>  we take the next line on the left (if there are no more lines, we finish processing); </li><li>  go back to step 1. </li></ul></li></ul><br>  This is a very cool way to combine datasets, but it works only for sorted sources.  Based on the current database <a href="http://explain.depesz.com/">explain.depesz.com</a> , there is: <br><ul><li>  44,721 plans containing the operation ‚ÄúNested Loop"; </li><li>  34,305 plans with ‚ÄúHash Join"; </li><li>  just 8,889 plans using ‚ÄúMerge Join". </li></ul><br><h4>  <font color="#adadad">Hash Join / Nested Loop / Merge Join Modifiers</font> </h4><br>  In all the examples above, I demonstrated that the Join operation returns a string only when it receives rows from both sides of the join. <br><br>  But this is not always the case.  We can have left, right, and full (LEFT / RIGHT / FULL OUTER JOIN) external unions, as well as so-called anti-joins. <br><br>  In the case of left / right joins, the names of operations change to: <br><ul><li>  Hash Left Join, </li><li>  Hash Right Join, </li><li>  Merge Left Join, </li><li>  Merge right join </li><li>  Nested Loop Left Join. </li></ul><br>  Nested Loop Right Join does not exist, because Nested Loop always starts on the left and takes the left side as the basis for the loop.  Therefore, a union using a RIGHT JOIN that will work with the Nested Loop is internally transformed into a LEFT JOIN so that the Nested Loop operation can work. <br><br>  In all these cases, the logic is simple: we have two sides of the union - left and right.  And when a side is mentioned in a join, it returns a new string, even if there are no matching rows on the <i>other side</i> . <br><br>  This happens with queries like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ...</code> </pre><br>  (or right join). <br><br>  All other information for Hash Join / Merge Join and Nested Loop is the same; there is only a small change in the logic of when line output is generated. <br><br>  There is also a version called Full Join with the following operation names: <br><ul><li>  Hash Full Join, </li><li>  Merge Full Join. </li></ul><br>  In this case, the union generates a new output line, regardless of whether there is no data on any of the parties (as long as there is data on at least one side).  This happens in the case of: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">full</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> b ...</code> </pre><br>  All processing is the same as in the previous examples. <br><br>  In addition, there are so-called Anti Join'y.  The names of their operations are as follows: <br><ul><li>  Hash Anti Join, </li><li>  Merge anti join </li><li>  Nested Loop Anti Join. </li></ul><br>  In these cases, the Join returns a string <i>only</i> if the right side does not find a single string.  This is useful when you do something like ‚ÄúWHERE not exists ()" or ‚Äúleft join ... where right_table.column is null". <br><br>  As in this example: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class c <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_attribute a <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.attrelid = c.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a.attnum = <span class="hljs-number"><span class="hljs-number">10</span></span>); QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------------------------------------------------------------------------------------- Hash Anti Join (cost=62.27..78.66 rows=250 width=203) (actual time=0.145..0.448 rows=251 loops=1) Hash Cond: (c.oid = a.attrelid) -&gt; Seq Scan on pg_class c (cost=0.00..10.92 rows=292 width=207) (actual time=0.009..0.195 rows=293 loops=1) -&gt; Hash (cost=61.75..61.75 rows=42 width=4) (actual time=0.123..0.123 rows=42 loops=1) Buckets: 1024 Batches: 1 Memory Usage: 2kB -&gt; Index Only Scan using pg_attribute_relid_attnum_index on pg_attribute a (cost=0.28..61.75 rows=42 width=4) (actual time=0.021..0.109 rows=42 loops=1) Index Cond: (attnum = 10) Heap Fetches: 0 Total runtime: 0.521 ms (9 rows)</span></span></code> </pre><br>  Here Pg executed the right side (Index Scan by pg_attribute), hashed it, and then executed the left side (Seq Scan by pg_class), returning only those lines where there were no Hash entries for the given pg_class.oid. <br><br><h4>  <font color="#adadad">Materialize</font> </h4><br>  This operation has already been demonstrated in the example for Merge Join, but it can be useful in other cases. <br><br>  Psql has a lot of internal commands.  One of them is \ dTS, which lists all system data types.  Internally, \ dTS runs this query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> n.nspname <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-string"><span class="hljs-string">"Schema"</span></span>, pg_catalog.format_type(t.oid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"Name"</span></span>, pg_catalog.obj_description(t.oid, <span class="hljs-string"><span class="hljs-string">'pg_type'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-string"><span class="hljs-string">"Description"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_catalog.pg_type t <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_catalog.pg_namespace n <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> n.oid = t.typnamespace <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (t.typrelid = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.relkind = <span class="hljs-string"><span class="hljs-string">'c'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_catalog.pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = t.typrelid)) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_catalog.pg_type el <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> el.oid = t.typelem <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> el.typarray = t.oid) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_catalog.pg_type_is_visible(t.oid) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  His plan is: <br><br><pre> <code class="sql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------------------------------------------------------------------------------------- Sort (cost=2783.00..2783.16 rows=65 width=68) (actual time=3.883..3.888 rows=87 loops=1) Sort Key: n.nspname, (format_type(t.oid, NULL::integer)) Sort Method: quicksort Memory: 39kB -&gt; Nested Loop Left Join (cost=16.32..2781.04 rows=65 width=68) (actual time=0.601..3.657 rows=87 loops=1) Join Filter: (n.oid = t.typnamespace) Rows Removed by Join Filter: 435 -&gt; Hash Anti Join (cost=16.32..2757.70 rows=65 width=8) (actual time=0.264..0.981 rows=87 loops=1) Hash Cond: ((t.typelem = el.oid) AND (t.oid = el.typarray)) -&gt; Seq Scan on pg_type t (cost=0.00..2740.26 rows=81 width=12) (actual time=0.012..0.662 rows=157 loops=1) Filter: (pg_type_is_visible(oid) AND ((typrelid = 0::oid) OR (SubPlan 1))) Rows Removed by Filter: 185 SubPlan 1 -&gt; Index Scan using pg_class_oid_index on pg_class c (cost=0.15..8.17 rows=1 width=1) (actual time=0.002..0.002 rows=1 loops=98) Index Cond: (oid = t.typrelid) -&gt; Hash (cost=11.33..11.33 rows=333 width=8) (actual time=0.241..0.241 rows=342 loops=1) Buckets: 1024 Batches: 1 Memory Usage: 14kB -&gt; Seq Scan on pg_type el (cost=0.00..11.33 rows=333 width=8) (actual time=0.002..0.130 rows=342 loops=1) -&gt; Materialize (cost=0.00..1.09 rows=6 width=68) (actual time=0.000..0.001 rows=6 loops=87) -&gt; Seq Scan on pg_namespace n (cost=0.00..1.06 rows=6 width=68) (actual time=0.002..0.003 rows=6 loops=1) Total runtime: 3.959 ms</span></span></code> </pre><br>  For viewing convenience, I also uploaded this plan to <a href="http://explain.depesz.com/s/za6">explain.depesz.com</a> . <br><br>  Note that operation # 9 is Materialize.  Why? <br><br>  Materialize is called by Nested Loop Left Join - operation # 2.  We know that Nested Loop causes the selected operation to be executed multiple times, in this case 87 times. <br><br>  The right side of the union is Seq Scan by pg_namespace.  So, theoretically, Postgres should perform a sequential scan on pg_namespace 87 times.  If we consider that a single sequential scan of this table takes 0.003ms, we can expect that the total time will be ~ 0.25ms. <br><br>  But Postgres is smarter.  He understands that it will be less expensive to scan the table once and build in memory an image of all its rows.  Then next time you will not need to scan the table, check the visibility information, parse the data pages.  He just takes the data from the memory. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to this, the total time for everything (one-time reading of the table, preparing the image of the data in memory and scanning this image 87 times) was 0.087ms. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can say, ‚ÄúOK, but why did the merge join use materialize before, did he just perform one scan?‚Äù Let's remember the plan:</font></font><br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_attribute a <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> attrelid) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.oid = a.attrelid; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------------------------------------------------------------------------------------------------- Merge Join (cost=23.16..268.01 rows=2273 width=410) (actual time=0.658..3.779 rows=2274 loops=1) Merge Cond: (pg_class.oid = a.attrelid) -&gt; Sort (cost=22.88..23.61 rows=292 width=207) (actual time=0.624..0.655 rows=293 loops=1) Sort Key: pg_class.oid Sort Method: quicksort Memory: 102kB -&gt; Seq Scan on pg_class (cost=0.00..10.92 rows=292 width=207) (actual time=0.011..0.211 rows=293 loops=1) -&gt; Materialize (cost=0.28..212.34 rows=2273 width=203) (actual time=0.028..1.264 rows=2274 loops=1) -&gt; Index Scan using pg_attribute_relid_attnum_index on pg_attribute a (cost=0.28..183.92 rows=2273 width=203) (actual time=0.015..0.752 rows=2274 loops=1) Total runtime: 4.009 ms (9 rows)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, it was launched only once. The problem is that the data source for Merge Join must meet several criteria. Some of them are obvious (data should be sorted), while others are less obvious because they are more technical (data should be viewed back and forth). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because of these not too obvious criteria, Postgres sometimes has to apply Materialize to the data coming from the source (in our case from the Index Scan) so that he has all the necessary capabilities when it comes to using them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In short, Materialize obtains data from the underlying operation and places it in memory (or partly in memory) so that it can be used more quickly, or adds additional properties to it that the previous operation does not provide.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's all for today. </font><font style="vertical-align: inherit;">I thought I would finish on this, but there are still many operations that should be described, so there will be at least two more posts in this series (the remaining operations and statistical information).</font></font></div><p>Source: <a href="https://habr.com/ru/post/279255/">https://habr.com/ru/post/279255/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279245/index.html">Intelligent active noise canceling server cabinet</a></li>
<li><a href="../279247/index.html">BDRA - Modern Architecture for Big Data Analytics</a></li>
<li><a href="../279249/index.html">Text tutorial on React.js and Redux in Russian</a></li>
<li><a href="../279251/index.html">A pear is hanging ... from Poe-Out, 16 GigabitEthernet. Or new all-weather routers and switches Ubiquiti</a></li>
<li><a href="../279253/index.html">Ether through the prism Or new Rocket AC AirPrism</a></li>
<li><a href="../279257/index.html">Yandex is killing a business, or be careful with the #main block</a></li>
<li><a href="../279261/index.html">No one wants to use your product.</a></li>
<li><a href="../279263/index.html">Welcome to Android Devs Meetup March 17</a></li>
<li><a href="../279267/index.html">Android client for rutracker: bypass the blocking using Google Compression proxy</a></li>
<li><a href="../279269/index.html">Custom floating point format on FPGA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>