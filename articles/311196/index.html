<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Battle of droids and jedi on cellular automaton</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Films where huge armies converge with each other on the battlefield in an epic battle usually cause a storm of emotions in people. Scenes of Star Wars...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Battle of droids and jedi on cellular automaton</h1><div class="post__text post__text-html js-mediator-article"><p>  Films where huge armies converge with each other on the battlefield in an epic battle usually cause a storm of emotions in people.  Scenes of Star Wars battles with masterful lightsaber Jedi and hordes of battle droids are no exception. </p><br><p>  But sometimes it is interesting to look at the process of the battle as if from a bird's eye view and see the whole course of events.  For this you can use various virtual simulation tools.  This post provides an example of simulating a battle between Federation battle droids and the Jedi Order using such a simple discrete model as a cellular automaton. </p><br><img src="https://habrastorage.org/files/2ee/fb6/e94/2eefb6e948144051971528d585f972c7.jpg"><br><p><a name="habracut"></a><br></p><br><h3>  Cellular Automata </h3><br><p>  Imagine that the whole world is a grid divided into squares, called <b>cells</b> .  Each of these cells can be in different states of a given set.  The state of the cell is affected by the state of the neighboring cells, which are usually determined through <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BA%25D1%2580%25D0%25B5%25D1%2581%25D1%2582%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_%25D0%259C%25D1%2583%25D1%2580%25D0%25B0">the Mur neighborhood of about 1</a> .  A vivid example of such a model is the <a href="http://www.bitstorm.org/gameoflife/">game "Life"</a> , invented by the mathematician John Conway in the 1970s.  Its rules are very simple: </p><br><ol><li>  Each cell can be either "alive" or "dead." </li><li>  The dead cell, next to which there are exactly 3 living ones, becomes alive on the next turn. </li><li>  If there are 2 or 3 living cells next to a living cell, then it continues to live on the next turn. </li><li>  If there are fewer than 2 or more than 3 living cells next to a living cell, then it dies. </li></ol><br><div style="text-align:center;"><img src="http://www.math.cornell.edu/~lipa/mec/banner.png" alt="image"></div><br><p>  It is because of the simplicity of the description of the rules of such models, we will use the cellular automaton to simulate an epic battle. </p><br><h3>  We invent our automatic </h3><br><p>  In total, there will be 4 cell types in our cellular automaton - a field (green), a droid (beige), a Jedi (blue), a blaster (red).  Now we come up with the rules.  We need the drones to bunch up and shoot the blasters to the Jedi, and the Jedi, in turn, attack these thick heaps of droids.  For ease of modeling, we will add a new opportunity for the cells - to move.  In fact, the movement of a cell in a cellular automaton can be defined as the transition of one of the cells to a state of transition, and the transition itself can be transferred to the zero state (in our case this field). </p><br><p>  What you need to implement to create a battle simulator: </p><br><ol><li>  Droids get off in groups </li><li>  The droid shoots the nearest Jedi in range. </li><li>  Jedi attacks the nearest squad </li></ol><br><h3>  Finding Droid Groups </h3><br><p>  If the droids are represented as vertices of the graph, and the neighboring droids are connected vertices, then the droid groups are the connected components of such a graph.  We can easily get them at the end of each step with the help of depth search (DFS): </p><br><pre><code class="javascript hljs">components = [] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(field.grid.length) colors.fill(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 0 is white, 1 is gray, 2 is black for (var i = 0; i &lt; field.grid.length; i++) if (field.grid[i].color == 1) if (colors[i] == 0) { var center = dfs(colors, i) components.push({ x: Math.round(center.x / center.k), y: Math.round(center.y / center.k) }) droidsAmount += center.k }</span></span></code> </pre> <br><p>  The function of determining the connected component itself is recursive: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dfs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">colors, v</span></span></span><span class="hljs-function">) </span></span>{ colors[v] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = field.grid[v].x, y = field.grid[v].y, k = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; field.grid[v].n.length; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field.grid[field.grid[v].n[i]].color == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; colors[field.grid[v].n[i]] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newPos = dfs(colors, field.grid[v].n[i]) x += newPos.x y += newPos.y k += newPos.k } colors[v] = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: x, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: y, <span class="hljs-attr"><span class="hljs-attr">k</span></span>: k } }</code> </pre> <br><p>  The k property corresponds to the number of droids in the group and is required to calculate the center of the group (arithmetic average of the x- and y-coordinates of each droid).  Each droid refers to its neighbors, whose coordinates are transferred to the first recursion call, which, in turn, will return the sums of all droid coordinates, as well as their number. </p><br><h3>  Going to a goal </h3><br><p>  All participants in the battle have goals ‚Äî the cells they aim at: the Jedi are in the center of the nearest droid group, the droids are on their allies, and the projectile is in a cell with the coordinates of the Jedi at the time the shot was fired. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveToTarget</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n, me, priority, ban</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newX = me.x, newY = me.y <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> deltaX = me.tx - me.sx, deltaY = me.ty - me.sy <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = deltaY / deltaX <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((deltaX == <span class="hljs-number"><span class="hljs-number">0</span></span>) || (deltaY == <span class="hljs-number"><span class="hljs-number">0</span></span>)) { newX = me.x + (deltaX == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : deltaX / <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(deltaX)) newY = me.y + (deltaY == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : deltaY / <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(deltaY)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(scope) &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { newY = me.y + deltaY / <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(deltaY) newX = me.sx + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round((newY - me.sy) / (scope)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { newX = me.x + deltaX / <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(deltaX) newY = me.sy + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round((newX - me.sx) * (scope)) } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!set(n, { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: newX, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: newY }).length) { me.color = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newCell = set(n, { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: newX, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: newY })[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ban) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newCell[key] == ban[key]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: newX, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: newY, <span class="hljs-attr"><span class="hljs-attr">instead</span></span>: { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">priority</span></span>: priority } }</code> </pre> <br><p>  Consider how this works.  The distance between the target and the initial position of the object along the X axis is denoted by deltaX, along the Y axis - by deltaY.  It is clear that if the initial x-coordinate of the object is more important than the coordinate of the target, then deltaX will be negative.  The same goes for deltaY. </p><br><p>  Denote the ratio of deltaY to deltaX as scope (slope).  If the slope is greater than one, then at each step the object is shifted by one along the Y axis, and sometimes along the X axis. Then newY = me.y + deltaY / Math.abs (deltaY), where the division by the absolute value allows to get one with the correct familiar  Since movement can be defined as <br>  x = y / scope, then newX = me.sx + Math.round ((newY - me.sy) / (scope)).  We do the same for cases with scope &lt;1. </p><br><p>  There are cases when the object and the target are in the same column or the same row.  Then division by zero may occur.  For such cases, a check is made (deltaX == 0) ||  (deltaY == 0).  If this is true, then we simply check the difference of coordinates using the ternary operator, and, if its value is nonzero, we add one with the correct sign. </p><br><p>  The ban parameter contains properties that are not allowed for the cell to which the object passes.  For example, a droid should not run into other robots.  Therefore, for the droid, ban = {color: 1} (1 is the droid color index).  If the cell to which the object wants to go, will have at least one property that has an equal value with the ban property of the same name, there will be no movement. </p><br><p>  If the object tries to get on a non-existent cell (move beyond the field boundary), then it disappears from the map. </p><br><p>  But if everything went well, then the function will return newX and newY as new coordinates. </p><br><h3>  Droid algorithm </h3><br><p>  The droid makes shots in the direction of the nearest Jedi.  The radius of visibility of the droid is given by the coefficient k2.  The droid chooses the nearest Jedi, a shot in which would not hurt the droids that are within a radius of length 5. </p><br><p>  The k2 coefficient is the detection distance of a Jedi droid. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5f2/54c/4a6/5f254c4a664948a0a7641769d56f05ff.png"></div><br><h3>  Jedi Algorithm </h3><br><p>  To calculate the optimal direction of the Jedi strike, let us set a weight in accordance with each surrounding cell, which will be calculated as follows: </p><br><p>  Jedi surrounds 8 cells (in case the Jedi is in the corner or near the field boundary - 3 or 5 cells).  The weight is calculated separately for each of these cells and depends on the states of the remaining cells around the Jedi.  We represent the weight as a polynomial of the form 5 <em>a1 + 4</em> b1 + 4 <em>b2 + 3</em> c1 + 3 <em>c2 + 2</em> d1 + 2 <em>d2 + 1</em> e, where each variable is equal to one if the corresponding cell is occupied by the droid, otherwise it is zero.  The farther the cell is from being processed, the smaller the coefficient with its corresponding monomial. </p><br><p>  An example of the cell weight calculation can be seen in the figure: </p><br><img src="https://habrastorage.org/files/971/4b9/120/9714b91204eb48a699bcacf71ce770d6.jpg"><br><p>  Cell weight in a specific situation: </p><br><img src="https://habrastorage.org/files/d49/690/e6e/d49690e6edab490081565597f9b39818.jpg"><br><p>  In this case, the Jedi has three optimal options for movement.  One of them will be selected randomly. </p><br><p>  It remains to help the Jedi to detect clusters of droids.  If we represent droids as graph vertices that are connected in the case of droid neighbors, then after each step, we will be able to find all the connected components of this graph using depth search (DFS), write the coordinates of their centers and the number of droids in the component into the array.  In the next step, the Jedi are looking for the troops that are closest to him and immediately rush towards them. </p><br><p>  The coefficient k1 is the maximum number of shells that a Jedi can dodge.  By default, k1 = 4. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/568/0cd/7e1/5680cd7e16454adeb8bd2760f65523aa.png"></div><br><h3>  Flight projectile </h3><br><p>  Infinitely projectile can not fly, so that after 32 steps, it disappears: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processBullet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n, me</span></span></span><span class="hljs-function">) </span></span>{ me.age++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (me.age &gt; <span class="hljs-number"><span class="hljs-number">32</span></span>) me.color = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><p>  Movement of it is extremely simple - the usual call to the function direction to the goal: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveBullet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n, me</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moveToTarget(n, me, <span class="hljs-number"><span class="hljs-number">1</span></span>, {}) }</code> </pre> <br><h3>  Unpleasant chips </h3><br><p>  What can we say - the program, formally performing a strictly specified algorithm, can sometimes surprise us with strange results. </p><br><p>  The most noticeable is the "effect of the dead Jedi."  Jedi are dead and heap. </p><br><p><img src="https://habrastorage.org/files/76f/bba/40a/76fbba40a0aa44788c79770f98f55fad.png" width="350"><img src="https://habrastorage.org/files/bee/5a3/94f/bee5a394f7fa4366b8bc618419f7b8b7.png" width="350"></p><br><p>  Why?  The answer is simple: one of the Jedi has reached the goal and is trying to get out of the crowd, but the other Jedi prevent him from doing so.  They, in turn, try to squeeze in to the goal, but since she is busy and the Jedi who are there cannot leave it, this situation arises. </p><br><h3>  Simulate the battle </h3><br><p>  You can play with the simulation <a href="http://cell-machine.com/StarWars/">right in the browser</a> .  Select the cell type and start drawing it around the screen until you get the desired location.  Click on "Start" and enjoy the battle.  If the battle is over or just bored you, you can start at "Stop", after which the graphs will be generated.  The first will show the number of droids at certain points in time, the second - the same statistics for the Jedi. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OW4aaWM814Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  "You can play with the simulation on <a href="http://cell-machine.com/StarWars/">here</a> </p><br><p>  To create charts used library <a href="http://www.chartjs.org/">Chart.js</a> .  What can graphics say? </p><br><ul><li>  The number of droids until a certain point remained the same.  At that step, when the number of droids began to decline, the first encounter between the Jedi and the droids occurred. <br><br></li><li>  The most frequent cases of death of the Jedi.  Was the fighter hit by a projectile before penetrating the enemy, or fell in the midst of the battle, surrounded by a numerically superior enemy?  All this can be found by comparing on two graphs the moment of his death. <br><br></li><li>  The overall picture of the battle.  Did it go smoothly, or were there ‚Äúrespites‚Äù and ‚Äúclimaxes‚Äù?  Let's see if there are sharp jumps in the graph and get an answer to the question! </li></ul><br><h3>  Conclusion </h3><br><p>  Source code with comments <a href="https://github.com/CellMachine/StarWars">is available on GitHub</a> .  To start, download the repository and open index.html in your browser. </p><br><p>  It turned out, in my opinion, an amusing sight.  Charts allow you to collect information about the course of battles with various initial configurations.  I wonder how would the graphics of real historical battles look like?  Of course, this post discusses the fictional universe, but the real historical battles took place according to the same rules: the soldiers were knocked down in groups, attacked each other and, of course, suffered casualties. </p><br><p>  However, one simulation should not be limited - there is an even more interesting task, namely, finding the best algorithm of actions for each participant in the battle.  And here the game theory will help the researcher.  But that's another story ... </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/311196/">https://habr.com/ru/post/311196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311186/index.html">Challenging chronic diseases in an era of hyper-connectivity</a></li>
<li><a href="../311188/index.html">FSTEC: firewall requirements</a></li>
<li><a href="../311190/index.html">Innopolis University will help prepare IT professionals for free</a></li>
<li><a href="../311192/index.html">The Game of Java: Java Conference in Kiev, October 14-15, 2016</a></li>
<li><a href="../311194/index.html">10 career mistakes I regret</a></li>
<li><a href="../311198/index.html">learnopengl. Lesson 1.2 - Creating a window</a></li>
<li><a href="../311200/index.html">Format preserving encryption or how to correctly encrypt credit card numbers</a></li>
<li><a href="../311202/index.html">The best vacancies at My Circle for the week, September 12-18</a></li>
<li><a href="../311204/index.html">Mobile user behavior scenarios have pushed Google AdWords to introduce end-to-end remarketing</a></li>
<li><a href="../311206/index.html">Launching a payment aggregator or e-wallet: features of Russian legislation and success secrets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>