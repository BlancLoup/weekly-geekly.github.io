<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Libraries for converting PDF document to image</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúThe Print Screen key does an excellent job with the task. What could be simpler than saving the document as an image? ‚Äù- you ask. For a long time I w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Libraries for converting PDF document to image</h1><div class="post__text post__text-html js-mediator-article">  ‚ÄúThe Print Screen key does an excellent job with the task.  What could be simpler than saving the document as an image? ‚Äù- you ask.  For a long time I worked on the tasks of saving reports and forms in PDF format.  But even with simple multipage tables of numbers, not all PDF generators coped equally well. <br><br>  Not so long ago, I came across a project whose customer wanted to convert his marketing masterpieces saved in PDF into one of the graphic formats, such as PNG.  After much persuasion and counter-argument, the project budget allowed to buy an inexpensive .NET component. <br><br>  It remained to choose the most suitable for the requirements of the customer and, if possible, with a good English-speaking, English writing support service (not from the Indian Subcontinent): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h5>  Requirements for PDF converters </h5><br>  The main attention was paid to such features of converters as: <br><ul><li>  The simplicity of the API, including for setting up fonts (in addition to embedded fonts, it should be possible to add the missing system font or a link to it) </li><li>  Ability to export to TIFF, PNG, JPEG, BMP formats </li><li>  Support for transparent images inside a PDF document </li><li>  Color mask support </li><li>  Asian font support </li><li>  Annotations must be converted with the document (the ability to disable this option) </li><li>  Different blending modes </li><li>  Various tiling patterns </li><li>  Different color spaces RGB, CMYK, Gray, DeviceN </li><li>  Transparent groups for documents created using Adobe Illustrator </li></ul><br><br>  After several queries, the search engine issued a group of suitable .NET components: <br><table><tbody><tr><td>  ABCpdf </td><td>  6.1.1.5 </td></tr><tr><td>  Adobe Acrobat (Interop.Acrobat) </td><td>  Adobe Acrobat 10.0 Type Library </td></tr><tr><td>  Apitron.PDF.Rasterizer </td><td>  3.0.1.0 </td></tr><tr><td>  O2S.Components.PDFRender4NET </td><td>  4.5.1.0 </td></tr><tr><td>  PDFLibNET </td><td></td></tr><tr><td>  PDFSharp </td><td>  1.31.1789.0 </td></tr><tr><td>  SautinSoft.PdfFocus </td><td>  2.2.2.2 </td></tr><tr><td>  TallComponents.PDF.Rasterizer </td><td>  3.0.91.0 </td></tr></tbody></table><br><br><h5>  The beginning of the test </h5><br>  For testing purposes, a single-page PDF file was chosen 3BigPreview.pdf (taken from the official Adobe site).  It includes a large number of graphic elements, demonstrating the ability of the component to render PDF graphic objects and their properties. <br><br><h5>  ABCPDF </h5><br>  It was not immediately possible to launch an example for this library on a 64-bit machine, only by changing the platform from AnyCPU to x86, the result was obtained.  The problem arose with setting the correct resolution of the picture.  A picture of the correct size of 612 x 792 pixels was obtained only by clearly setting the resolution of the resulting image to 72 dots per inch, which is strange, since other components expose 96dpi (for Win7).  The correct display of hieroglyphs <a href="http://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages">Kinsoku Shori</a> pleased.  Some letters look brighter than others, which suggests an impartial use of anti-aliasing.  The result is good for those who do not care that not 100% managed code is used, but we go further. <br>  A piece of code for ABCpdf: <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertPDFToImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pdfInputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageOutputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageName, ImageFormat imageFormat</span></span></span><span class="hljs-function">)</span></span> { FileStream fs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(pdfInputPath, FileMode.Open); Doc document = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Doc(); document.Read(fs); document.Rendering.DotsPerInch = <span class="hljs-number"><span class="hljs-number">72</span></span>; document.Rendering.DrawAnnotations = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; document.Rendering.AntiAliasImages = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; document.Rect.String = document.CropBox.String; document.Rendering.Save(Path.ChangeExtension(Path.Combine(imageOutputPath ,imageName), imageFormat.ToString())); }</code> </pre> <br>  Result: <img src="https://habrastorage.org/storage2/335/82c/c3d/33582cc3d6e54b2fd11fccc9eef71abd.jpeg"><br><br><h5>  Adobe Acrobat 10.0 Type Library </h5><br>  It is easy to understand that the native Adobe library can not be no favorites.  But calls to com objects are not exactly what we wanted, especially since you need an installed Pro version of the product. <br>  A piece of code for Adobe: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertPDFToImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pdfInputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageOutputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageName, ImageFormat imageFormat</span></span></span><span class="hljs-function">)</span></span> { CAcroPDDoc pdfDoc = (CAcroPDDoc) Interaction.CreateObject(<span class="hljs-string"><span class="hljs-string">"AcroExch.PDDoc"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); pdfDoc.Open(pdfInputPath); CAcroPDPage pdfPage = (CAcroPDPage) pdfDoc.AcquirePage(<span class="hljs-number"><span class="hljs-number">0</span></span>); CAcroPoint pdfPoint = (CAcroPoint) pdfPage.GetSize(); CAcroRect pdfRect = (CAcroRect) Interaction.CreateObject(<span class="hljs-string"><span class="hljs-string">"AcroExch.Rect"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); pdfRect.Left = pdfRect.Top = <span class="hljs-number"><span class="hljs-number">0</span></span>; pdfRect.right = pdfPoint.x; pdfRect.bottom = pdfPoint.y; pdfPage.CopyToClipboard(pdfRect, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>); IDataObject clipboardData = Clipboard.GetDataObject(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clipboardData.GetDataPresent(DataFormats.Bitmap)) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(Bitmap pdfBitmap = (Bitmap) clipboardData.GetData(DataFormats.Bitmap)) { pdfBitmap.Save(Path.ChangeExtension(Path.Combine(imageOutputPath, imageName), imageFormat.ToString()), imageFormat); } } pdfDoc.Close(); Marshal.ReleaseComObject(pdfPage); Marshal.ReleaseComObject(pdfRect); Marshal.ReleaseComObject(pdfDoc); Marshal.ReleaseComObject(pdfPoint); }</code> </pre><br>  Result: <img src="https://habrastorage.org/storage2/a58/091/9f7/a580919f7279925a5690f4604960616e.jpeg"><br><br><h5>  Apitron.PDF.Rasterizer for .NET </h5><br>  The component coped well with the test.  Convenient API, it is possible to customize fonts and disable drawing annotations.  The image looks clear.  All elements of the original PDF document are drawn.  I noticed that when converting the document all eight cores of the working machine were involved, most likely it would be convenient for those who want to increase application performance by increasing the RAM and the number of processors of the working system. <br>  Apitron code snippet: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertPDFToImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pdfInputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageOutputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageName, ImageFormat imageFormat</span></span></span><span class="hljs-function">)</span></span> { FileStream fs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(pdfInputPath, FileMode.Open); Document doc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Apitron.PDF.Rasterizer.Document(fs); RenderingSettings option = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RenderingSettings(); option.DrawAnotations = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; doc.Pages[<span class="hljs-number"><span class="hljs-number">0</span></span>].Render((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) doc.Pages[<span class="hljs-number"><span class="hljs-number">0</span></span>].Width, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) doc.Pages[<span class="hljs-number"><span class="hljs-number">0</span></span>].Height, option).Save(Path.ChangeExtension(Path.Combine(imageOutputPath, imageName), imageFormat.ToString()), imageFormat); }</code> </pre><br>  Result: <img src="https://habrastorage.org/storage2/ab8/a83/0aa/ab8a830aab38935b585f7cf218f2effa.jpeg"><br><br><h5>  O2S.Components.PDFRender4NET </h5><br>  The Romanian component satisfactorily coped with the test.  Not all elements of the document are saved correctly.  As can be seen from the resulting file, all elements of the specification are supported.  There are obvious problems with drawing text. <br>  A piece of code for O2S: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertPDFToImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pdfInputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageOutputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageName, ImageFormat imageFormat</span></span></span><span class="hljs-function">)</span></span> { PDFFile pdfFile = O2S.Components.PDFRender4NET.PDFFile.Open(pdfInputPath); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (Bitmap pageImage = pdfFile.GetPageImage(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>)) { pageImage.Save(Path.ChangeExtension(Path.Combine(imageOutputPath, imageName), imageFormat.ToString()), imageFormat); } }</code> </pre><br>  Result: <img src="https://habrastorage.org/storage2/60e/915/5a7/60e9155a7e7be61363360f1d5c672387.jpeg"><br><br><h5>  xPDF Wrapper Library (PDFLibNET) </h5><br>  The test case generation failed.  The image looks blurry, the text is not readable.  When converting the test file received errors. <br>  Piece of code for PDFLibNET: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertPDFToImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pdfInputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageOutputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageName, ImageFormat imageFormat</span></span></span><span class="hljs-function">)</span></span> { PDFWrapper pdfWrapper = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PDFWrapper(); pdfWrapper.LoadPDF(pdfInputPath); pdfWrapper.ExportJpg(Path.ChangeExtension(Path.Combine(imageOutputPath, imageName), imageFormat.ToString()), <span class="hljs-number"><span class="hljs-number">10</span></span>); pdfWrapper.Dispose(); }</code> </pre><br>  Result: <img src="https://habrastorage.org/storage2/400/6db/225/4006db22582a495935473695f784a484.jpeg"><br><br><h5>  PDFSharp (GhostScript and other wrappers) </h5><br>  PDFSharp, like other wrappers of the well-known GhostScript tool (for example, gouda, GhostscriptSharp), works specifically and is not always predictable.  Having spent several hours of time it turned out to make only the extraction of pictures, the entire document could not be saved as an image.  I would mark it as a good idea for a new article. <br>  You can also note here, everyone's favorite, iTextSharp.  A handy tool, but not for our task. <br><br><h5>  PdfFocus by SautinSoft </h5><br>  In my review I also got a domestic component.  But, unfortunately, with the tests he failed. <br>  On the test file, he issued an NRE error.  But on other files, he showed himself well. <br>  (To the author: ‚ÄúMaxim, I‚Äôm sure that you have great software and this little thing will be quickly corrected.‚Äù) <br>  A piece of code for SautinSoft: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertPDFToImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pdfInputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageOutputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageName, ImageFormat imageFormat</span></span></span><span class="hljs-function">)</span></span> { PdfFocus pdfFocus = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PdfFocus(); pdfFocus.OpenPdf(pdfInputPath); pdfFocus.ImageOptions.Dpi = <span class="hljs-number"><span class="hljs-number">96</span></span>; pdfFocus.ImageOptions.ImageFormat = imageFormat; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (Image bitmap = pdfFocus.ToDrawingImage(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { bitmap.Save(Path.ChangeExtension(Path.Combine(imageOutputPath, imageName), imageFormat.ToString()), imageFormat); } pdfFocus.ClosePdf(); }</code> </pre><br><br><h5>  TallCompnents.PDF.Rasterizer </h5><br>  The Dutch component coped well with the test.  The complexity of a specific API was offset by basic knowledge of Graphics.  Visible small problems with drawing text. <br>  A piece of code for CallCamponents: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertPDFToImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pdfInputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageOutputPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> imageName, ImageFormat imageFormat</span></span></span><span class="hljs-function">)</span></span> { FileStream fs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(pdfInputPath, FileMode.Open); Document document = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Document(fs); Page page = document.Pages[<span class="hljs-number"><span class="hljs-number">0</span></span>]; RenderSettings renderSettings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RenderSettings(); renderSettings.GdiSettings.WorkAroundImageTransparencyPrintSize = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (Bitmap bitmap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) page.Width, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) page.Height)) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (Graphics graphics = Graphics.FromImage(bitmap)) { graphics.SmoothingMode = SmoothingMode.AntiAlias; graphics.CompositingQuality = CompositingQuality.HighQuality; graphics.Clear(Color.White); page.Draw(graphics, renderSettings); } bitmap.Save(Path.ChangeExtension(Path.Combine(imageOutputPath, imageName), imageFormat.ToString()), imageFormat); } }</code> </pre><br>  Result: <img src="https://habrastorage.org/storage2/e5b/cde/926/e5bcde9265b4cbeacded5bff7c9907e3.jpeg"><br><br><h5>  Total </h5><br>  Saving PDF documents to a BMP, JPEG, TIFF image is not a trivial task, as it may seem at first glance.  You can find a lot of software utilities, libraries and commercial services and their shareware versions, but in a small startup you cannot do without reliable components of third-party developers.  After analyzing the results, re-reading the documentation, code samples and prices on the sites, I chose a component for my project.  In terms of performance, all libraries are at the same level, possibly due to the specifics of reading a PDF document into one stream.  When choosing, I did not consider the possibility of using products on mobile devices, since not all components, due to GDI + limitations, will be able to work correctly for the Android platform or are compatible with Mono.Xamarin. <br></div><p>Source: <a href="https://habr.com/ru/post/182800/">https://habr.com/ru/post/182800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182790/index.html">How in Ukraine to accept payments on PayPal in general (and when selling on eBay in particular)</a></li>
<li><a href="../182792/index.html">Replacing a system call handler</a></li>
<li><a href="../182794/index.html">LG Electronics TVs and DLNA protocol</a></li>
<li><a href="../182798/index.html">We are friends with Cisco IP Phone CP-7925G (WiFi), Cisco IP Conference Station CP-7937G, CP-3905G and Unified IP Phone CP-7965 with Asterisk</a></li>
<li><a href="../1828/index.html">"Enforta" went to the capital</a></li>
<li><a href="../182802/index.html">Past and Future of JavaScript Compilation</a></li>
<li><a href="../182804/index.html">How to quickly and cheaply do user segmentation and A / B testing for an iOS application</a></li>
<li><a href="../182806/index.html">Qualimetric approach to rating startups</a></li>
<li><a href="../182808/index.html">WWDC: The official broadcast will be available on Apple.com and Apple TV</a></li>
<li><a href="../18281/index.html">Wii, first problems and impressions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>