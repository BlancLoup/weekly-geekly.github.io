<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Store 300 million objects in the CLR process</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stumbling Block - GC 
 All managed languages ‚Äã‚Äãsuch as Java or C # have one major drawback - unconditional automatic memory management. It would seem ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Store 300 million objects in the CLR process</h1><div class="post__text post__text-html js-mediator-article"><h1>  Stumbling Block - GC </h1><br>  All managed languages ‚Äã‚Äãsuch as Java or C # have one major drawback - unconditional automatic memory management.  It would seem that this is the advantage of managed languages.  Remember how we floundered with dandling-pointers, not understanding where the precious 10KB per hour was flowing, forcing our favorite server to restart once a day?  Of course, Java and C # (and others like them) at first glance solve the situation in 99% of cases. <br><br>  That's the way it is, only here there is one problem: how to deal with a large number of objects, because in the same .Net there is no magic.  The CLR should scan a huge set of objects and their reciprocal links.  This problem is partially solved by introducing generations.  Based on the fact that most objects do not live long, we release them faster and therefore do not have to go through all the objects of the hip each time. <br><br>  But the problem is still there in cases where the objects must live long.  For example, cache.  It must contain millions of objects.  Especially, given the increasing volumes of RAM on a typical modern server.  It turns out that the cache can potentially store hundreds of millions of business objects (for example, Person with a dozen fields) on a machine with 64GB of memory. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, in practice, this can not be done.  As soon as we add the first 10 million objects and they ‚Äúbecome obsolete‚Äù from the first generation to the second, the next full GC-scan ‚Äúhalts‚Äù the process for 8-12 seconds, and this pause is inevitable, i.e.  we are already in background server GC mode and this is only the ‚Äústop-the-world‚Äù time.  This leads to the fact that the server aplica simply ‚Äúdies‚Äù for 10 seconds.  Moreover, to predict the moment of "clinical death" is almost impossible. <br>  What to do?  Do not store a lot of objects for a long time? <br><br><h1>  What for </h1><br>  But I NEED to store a lot of objects for a long time in a specific task.  For example, I keep a network of 200 million streets and their interconnections.  After downloading from a flat file, my application should calculate the probability coefficients.  It takes time.  Therefore, I do this immediately as data is loaded from disk into memory.  After that, I need to have an object graph, which is already precalculated and ready ‚Äúfor work and defense‚Äù.  In short, I need to store about 48GB of data resident for several weeks while responding to hundreds of requests per second. <br><br>  Here is another task.  Caching social data, which accumulate hundreds of millions in 2-3 weeks, and you need to serve tens of thousands of read requests per second. <br><a name="habracut"></a><br><h1>  how </h1><br>  So we decided to make our memory manager and called it ‚ÄúPile‚Äù (heap).  For not to bypass the ‚Äúcrippling‚Äù managed memory model.  Unmanaged memory does not save anything.  Access to it takes time to check, which ‚Äúkill‚Äù the speed and complicate the entire design.  Neither .Net nor Java knows how to work in ‚Äúnormal‚Äù mode with chunks of memory that are not on the heap. <br><br>  What have we done?  Our memory manager is absolutely 100% managed code.  We dynamically allocate byte arrays, which we call segments.  Inside the segment we have a pointer ‚Äî a regular int.  And here we get PilePointer: <br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Represents a pointer to the pile object (object stored in a pile). </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The reference may be local or distributed in which case the NodeID is&gt;=0. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Distributed pointers are very useful for organizing piles of objects distributed among many servers, for example </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> for "Big Memory" implementations or large neural networks where nodes may inter-connect between servers. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The CLR reference to the IPile is not a part of this struct for performance and practicality reasons, as </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> it is highly unlikely that there are going to be more than one instance of a pile in a process, however </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> should more than 1 pile be allocated than this pointer would need to be wrapped in some other structure along </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> with source IPile reference </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public struct PilePointer : IEquatable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PilePointer&gt;</span></span></span><span class="hljs-comment"> { </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Distributed Node ID. The local pile sets this to -1 rendering this pointer as !DistributedValid </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public readonly int NodeID; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Segment # within pile </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public readonly int Segment; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Address within the segment </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public readonly int Address; ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶ }</span></span></code> </pre> <br>  Pay attention to NodeID, about it below.  Get PilePointer as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyBusinessType(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pilePointer = Pile.Put(obj); ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// -   ,    var originalObj = Pile.Get(pilePointer);</span></span></code> </pre><br>  We will get a copy of the original object, which we loaded into Pile using Put (), or PileAccessViolation, if the pointer is incorrect. <br><br><pre> <code class="cs hljs">Pile.Delete(pilePointer)</code> </pre><br>  allows you to free up a piece of memory, respectively, an attempt to read this memory again will cause PileAccessViolation. <br><br>  Question: how it is done and what we store in byte [], because we can not store CLR objects with real points, then they confuse the GC.  We just need the opposite - to store something in our format, removing the managed references.  Thus, we will be able to store data, and the GC will not know that these are objects, well, and will not visit them.  This can be done through serialization.  Of course, it is not the built-in .Net serializers that are meant (such as BinaryFormatter), but our relatives in the NFX. <br><br>  PilePointer.NodeID allows you to ‚Äúsmear‚Äù data across distributed ‚Äúheaps‚Äù, as it identifies a node in a distributed pile cohort. <br><br>  And now the main question.  Why is all this necessary if serialization is used ‚Äúunder the hood‚Äù and is it slow? <br><br><h1>  Speed </h1><br>  Actually it works like this: an object &lt;300 bytes, immersed in a byte [] with the help of NFX Slim serialization, takes on average 10-25% less space than the native CLR object in memory.  For large objects, this difference tends to zero.  Why is this so?  The fact is that NFX.Serialization.Slim.SlimSerializer uses UTF8 for strings and the variable length integer encoding + does not need 12+ bytes of the CLR header.  As a result, the speed of the serializer becomes a stumbling block.  SlimSerializer ‚Äúholds‚Äù phenomenal speed.  On a single Intel I7 Sandy Bridge core with a 3GHz frequency, we turn 440 thousand PilePointer'es into an object per second.  Each object in this test has 20 fields filled and occupies 208 bytes of memory.  Inserting objects into Pile with one core 405 thousand per second.  Such speed is achieved due to the dynamic compilation of expression trees for each object being serialized into the pile segment.  On average, the SlimSerializer works 5 times faster than the BinaryFormatter, although for many simple types this factor reaches 10. From the point of view of the space, the SlimSerializer packs data into 1/4 - 1/10 of what BinaryFormatter does.  And most importantly.  SlimSerializer DOES NOT DEMAND a special markup of fields in the objects with which we work.  Those.  you can store anything, except delegates. <br><br>  The multithreaded data insertion test stably holds over 1 million transactions per second on CoreI7 3GHz. <br>  Well, now the most important thing.  Allocating 300.000.000 objects in our process a full GC takes less than 30 milliseconds <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/IUBF2Ncvbbs%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhji3GZfh4PXpsW6M84Ae_NwJ0cOVw" frameborder="0" allowfullscreen=""></iframe><br><br><h1>  Results </h1><br>  NFX.ApplicationModel.Pile technology avoids unpredictable delays caused by the GC garbage collector, keeping hundreds of millions of objects resident in memory for a long time (week), providing access speeds faster than the ‚Äúout-of-process‚Äù solution (such as MemCache, Redis et al. <br><br>  Pile is based on a dedicated memory manager that allocates large byte [] and allocates memory for the application.  The object immersed in Pile is identified by the structure PilePointer, ktr.  occupies 12 bytes, which contributes to the creation of efficient object graphs, where objects are mutually referenced. <br><br>  Get the code: <br><br>  <a href="https://github.com/aumcode/nfx">NFX GitHub</a> </div><p>Source: <a href="https://habr.com/ru/post/257091/">https://habr.com/ru/post/257091/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257077/index.html">Contests HackQuest and Hash Runner: warm up the brains before PHDays</a></li>
<li><a href="../257079/index.html">Checking FreeCAD source code and its ‚Äúbad‚Äù dependencies</a></li>
<li><a href="../257083/index.html">BUILD 2015 news: Visual Studio Code, Visual Studio 2015 RC, Team Foundation Server 2015 RC, Visual Studio 2013 Update 5</a></li>
<li><a href="../257087/index.html">Search, find and do not blow off</a></li>
<li><a href="../257089/index.html">How to build a scalable infrastructure on Storage Spaces</a></li>
<li><a href="../257093/index.html">SourceTalk (source code discussion service): release</a></li>
<li><a href="../257095/index.html">Happy birthday google</a></li>
<li><a href="../257097/index.html">7 things that every designer should know about the design of accessible sites</a></li>
<li><a href="../257101/index.html">Cyclomatic complexity: CSS logic</a></li>
<li><a href="../257105/index.html">Deploying Oracle Database 12c DBMS on Windows Server to InfoboxCloud Cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>