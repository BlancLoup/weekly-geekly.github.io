<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Review of neural network evolution methods</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The choice of topology and adjustment of the weights of artificial neural network (ANN) connections are one of the most important steps when using neu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Review of neural network evolution methods</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/geektimes/post_images/fa3/add/a5f/fa3adda5f275e94b4247c03c81d188ee.jpg" align="left"><br><br>  The choice of topology and adjustment of the weights of artificial neural network (ANN) connections are one of the most important steps when using neural network technologies to solve practical problems.  The quality (adequacy) of the obtained neural network model, control system, etc. directly depends on these stages. <br><br>  The construction of an artificial neural network by the traditional method is performed, in fact, by trial and error.  The researcher sets the number of layers, neurons, as well as the structure of connections between them (presence / absence of recurrent connections), and then looks at what happened - the network is trained using some method, and then tested on a test sample.  If the results of the work meet the specified criteria, the task of building the INS is considered completed successfully;  otherwise, the process is repeated with different values ‚Äã‚Äãof the original parameters. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Naturally, the rapid development of the theory and practice of using genetic algorithms made researchers (laziness - the engine of progress) look for ways to apply them to the task of finding the optimal structure of an ANN (evolution of neural networks or neuroevolution), especially since, so to speak, proof-of-concept there was, or, more precisely, in the head - nature clearly demonstrated the solvability of a similar problem on the example of the evolution of the nervous system with the subsequent formation and development of the brain. <br><br><a name="habracut"></a><br>  <b>UPD:</b> Thanks for the karma :) Moved to Artificial Intelligence. <br>  <b>UPD2: Redid</b> end links <br><br>  First a couple of words about authorship.  Most of the descriptive text is taken from the article by Anton Konushin [1].  Additionally, the materials listed at the end of the article were used (the relevant references are provided during the presentation), as well as the results of my own research. <br><br>  Next, I will proceed from the assumption that the reader is familiar with the concepts of ANNs and genetic algorithms, and omit their description.  Those who want to know - yes, google or refer to the list of sources at the end of the article.  So let's go. <br><br><h2>  Coding Schemes </h2><br>  As most researchers note, the central point of any method for the evolution of neural networks is the choice of a genetic representation (i.e., a coding scheme and appropriate decoding).  The choice of representation determines the class of networks that can be built using this method.  In addition, the effectiveness of the method in all parameters depends on them. <br><br><blockquote>  The general properties of genetic representations, by which one can evaluate and compare various methods, have been distinguished by many authors.  Balakrishnan and Honavan [2] suggest using the following set of properties: completeness, isolation, compactness, scalability, multiplicity, ontogenetic adaptability, modularity, redundancy complexity. <br>  In this article I will not dwell on this list in more detail.  A brief description of these properties can be found in [1], and a more detailed - in [2] <br></blockquote><br><br>  At present, there are usually two large classes of encoding methods: direct encoding and indirect encoding. <br><br><blockquote>  The use of the terms ‚Äúparametric‚Äù and ‚Äúindirect‚Äù coding to refer to this class of methods is also found in the Russian-language literature.  Personally, such a translation seems to me not very good, so here and further I will use the term ‚Äúindirect‚Äù <br></blockquote><br><br>  <b>Direct coding</b> operates on chromosomes representing a linear representation of the ANN, in which all neurons, ANN weights and connections are explicitly indicated.  Thus, it is always possible to build a one-to-one correspondence between the structural elements of the ANN (neurons, connections, weights, etc.), i.e.  phenotype, and the corresponding parts of the chromosome, i.e.  genotype. <br><br>  This way of presenting the neural network is the most simple and intuitive, and also allows you to apply to the chromosomes already existing apparatus of genetic search (for example, crossing-over and mutation operators).  Among the most obvious drawbacks of such a coding scheme, the ‚Äúswelling‚Äù of the genotype with increasing number of neurons and ANN connections can be noted and, as a result, low efficiency due to a significant increase in search space. <br><blockquote>  For the sake of fairness, it is worth saying that techniques have been proposed for direct coding, the purpose of which is to alleviate the drawbacks described above (for example, NEAT ‚Äî described below) <br></blockquote><br><br>  <b>Indirect coding</b> (some sources also use the term weak - weak, meaning loosely coupled) professes a more ‚Äúbiological‚Äù principle - the genotype does not encode the phenotype itself, but the rules for constructing it (conditionally speaking, a certain program).  When decoding a genotype, these rules are applied in a certain sequence (often, recursively and, often, the applicability of the rules depends on the current context), as a result of which the neural network is built. <br><br>  When using indirect coding methods, the genetic representation (and, accordingly, the search space for genetic algorithms) is more compact, and the genotype itself allows for the coding of modular structures, which, under certain conditions, gives advantages in the adaptability of the results obtained.  Instead, we get the practical impossibility to trace the changes in the genotype that led to the given changes in the phenotype, as well as many difficulties with the selection of genetic operators, convergence and performance. <br><br>  Historically, direct coding has been investigated earlier and deeper, but a number of drawbacks of this approach (see, for example, [4]) force researchers to look more closely at indirect coding methods.  However, inherently indirect methods are very difficult to analyze.  For example, the same mutation of the rule located at the beginning of the ‚Äúprogram‚Äù has a tremendous effect, and applied to the ‚Äúterminal‚Äù rules does not have any effect at all, and as a result the genetic search has a strong tendency to premature convergence.  The selection of crossover operators is also not a trivial task, since  The use of standard binary operators, as a rule, leads to the frequent appearance of non-viable solutions. <br><br>  From the good news it can be noted that the work in the field of developing indirect coding techniques is now in full swing, and there is room for maneuver and new discoveries - so readers eager for scientific glory have a chance to try themselves in this area. <br><br><h2>  Direct encoding </h2><br><br><h3>  Miller, Todd and Hedge </h3><br>  In 1989, Miller proposed to encode the structure of a neural network using an adjacency matrix (similar to an adjacency matrix for graphs).  He used it to write only multilayer neural networks without feedback.  Each possible direct connection of neuron i and non-input neuron j corresponds to an element of the matrix with coordinates (i, j).  If the value of this element is 1, there is a connection;  if 0 - no connection.  For the displacement of each neuron a separate column is allocated.  Thus, a neural network of N neurons corresponds to a matrix of dimensionality N * (N + 1). <br><br>  The genome of a neural network using the direct encoding method is compiled by concatenating the binary rows of the neural network adjacency matrix. <br><br>  When decoding the resulting genome back into the neural network, all feedbacks (which can be recorded in the adjacency matrix) are ignored.  That is why only neural networks without feedback were recorded in this form.  All neurons to which no connection leads, or from which no connection exits, are deleted. <br><br>  Such a representation is poorly scaled because  the length of the resulting genome is proportional to the square of the number of neurons in the network.  Therefore, it can be effectively used only for building sufficiently small neural networks. <br><br>  This representation can also be used to build other classes of neural networks, for example, with feedback.  To do this, you only need to make changes in the process of decoding the genotype. <br><br>  The analysis of this direct encoding method is a non-trivial task.  There are two main questions: <br><br><ul><li>  What is the probability that the network will be "dead", i.e.  are the inputs and outputs of the network not connected at all? </li><li>  The coding of the same network structure can be performed in a variety of ways.  How to find out exactly how many of these methods exist, and how does this affect adaptation in the process of genetic search? </li></ul><br>  To answer both of these questions, it is necessary to solve complex combinatorial problems, and, as far as is known, research in this area has not been carried out [5]. <br><br><h3>  Stanley, Miikkulainen </h3><br>  One of the most potentially successful attempts to get rid of the disadvantages of direct coding while preserving all its advantages is the method proposed in 2002 called NEAT - Neural Evolution through Augmenting Topologies [6]. <br><br>  In their studies, the authors identified a number of key problems inherent in direct coding in particular, and neuroevolution in general.  These problems are: <br><ul><li>  Competing Conventions - the same phenotype (topologically) ANN can be differently represented in the genotype even within the same coding method.  For example - in the course of evolution between the two previously created genes (for example, A and B) the C gene was inserted, which (as is often the case with mutations) at the initial stage does not carry any useful information.  As a result, we have an individual with two genes (A, B) and an individual with three genes (A, C, B).  When crossing these two individuals, the crossover operator will be applied to the genes in the corresponding positions (ie, A &lt;-&gt; A, C &lt;-&gt; B), which is not very good, because  we begin to cross pig (C) with oranges (B). <br></li><li>  Unprotected innovations ‚Äî with neuroevolution, innovations (i.e., changes in the structure of the Ann) are made by adding or removing neurons and / or groups of neurons.  And often, the addition of a new structure in the ANN leads to a decrease in the value of its fitness function.  For example, adding a new neuron introduces non-linearity in a linear process, which leads to a decrease in the value of the fitness function until the weight of the added neuron is optimized. <br></li><li>  Initial size and topological innovations ‚Äî in many neuroevolution techniques, the initial population is a collection of random topologies.  In addition to having to spend some time sifting out initially non-viable networks (for example, those that have no input connected to any output), such populations tend to converge prematurely to solutions that are not optimal great).  This is due to the fact that the initially generated random topology already has a set of links that are extremely reluctant to be reduced during the genetic search.  As experiments have shown, the most effective is the search with a consistent increase in the size of the neural network - in this case, the search space is greatly narrowed.  One way to solve this problem is to introduce a penalty function, which reduces the value of the fitness function depending on the size of the network.  However, it remains to solve the problem of the optimal form of this function, as well as the selection of the optimal values ‚Äã‚Äãof its coefficients. <br></li></ul><br>  The solution proposed by the authors is based on the biological concept of homologous genes (alleles), as well as on the existence of a synapsis process in nature - alignment of homologous genes before the crossover. <br><br><blockquote>  Alleles (from the Greek. Allƒìl≈çn - each other, mutually), hereditary advances ( <a href="http://slovari.yandex.ru/dict/bse/article/00017/41900.htm">genes</a> ) located in the same areas of homologous (paired) chromosomes and determine the direction of development of the same trait. <br></blockquote><br><br>  The method assumes that two genes (in two different individuals) are homologous, if they arose as a result of the same mutation in the past.  In other words, for each <b>structural</b> mutation (gene addition), a new gene is assigned a unique number (innovation number), which then does not change in the process of evolution. <br><br>  The use of historical markers (historical markings) is the basis for solving all three of the problems described above, due to: <br><ol><li>  Crossover runs only between homologous genes <br></li><li>  Protection of innovation through the introduction of "niche" - individuals with similar topological structures are eliminated, thus leaving room for "beginners". <br></li><li>  Minimization of dimensions due to consistent growth from the minimum size <br></li></ol><br>  A more detailed and complete description of the methodology, as well as its comparison with other methods, is given in [6]. <br><br><h2>  Indirect coding <br></h2><br><br><h3>  Kitano <br></h3><br>  In real biological organisms, the genotype is not a true complete drawing of the whole individual.  It contains information about proteins, i.e.  about the elements that are used both as building blocks from which an organism is created, and as mechanisms with a built-in program for building other elements of the organism.  This process of development is called ontogenesis, and it was he who inspired researchers to move to the fractal descriptions of neural networks.  The genotype does not record the description of the structure of the neural network, but the program and the rules for constructing this structure. <br><br>  The most famous approach to the implementation of this idea is based on Lindemeir Systems, or L-systems.  This formalism was originally a grammatical approach to modeling plant morphogenesis.  The grammar of the L-system consists of a set of rules used to generate a string describing the structure.  The process of applying the rules is called string-rewriting.  Rule rewriting rules are consistently applied to the initial character S, until we get a line only from terminal characters. <br><br>  In 1990, Kitano developed a graph generation grammar (Graph Generation Grammar -GGG).  All rules are: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/312/bd7/05c/312bd705c9b64e3252d6ed2823a60aeb.gif"><br><br>  The alphabet of this grammar contains three types of characters: non-terminal N = {A, B,:, Z}, pre-terminal P = {a, b,:, p} and terminal T = {0,1}.  A grammar consists of two parts: a variable and a constant.  The variable part is recorded in the genome and consists of a sequence of descriptions of the rules of grammar.  All characters from the left part of the rules must be non-terminal, and from the right part - from the set N? P.  The constant part of the grammar contains 16 rules for each pre-terminal character on the left, and 2 * 2 matrices from {0,1} on the right.  Grammar rules are also set for terminal symbols.  Zero expands into a 2 * 2 matrix of zeros, and one - into the matrix and ones. <br><br>  When working with such representations of genomes, situations may occur when the variable part does not specify rules for a non-terminal symbol, which, however, was used on the right-hand side of one of the described rules.  Such characters are declared &lt;dead&gt;, and are rewritten in the same way as zeros. <br><br>  The decoding process consists of sequential application of rules from the genome to the initial symbol S. The number of applications of the rules is specified at the beginning.  The resulting matrix is ‚Äã‚Äãinterpreted as follows: if the element (i, i) = 1 on the diagonal, then it corresponds to a neuron.  All elements (i, j) denote the connection of neuron i with neuron j, if they both exist.  All feedbacks are deleted. <br><br><h3>  Nolfi, Parisi </h3><br>  Nolfi and Parisi offered to encode neurons with their coordinates in two-dimensional space.  Each pair of coordinates in the genotype corresponds to one neuron.  But links are not specified exactly in the genotype, but &lt;grown&gt; in the decoding process.  The outermost neurons on the left are considered input, and the extreme ones on the right are output. <br><br>  At the beginning of the decoding process, all neurons are placed on the plane at the points specified by their coordinates.  Then they are indexed.  The index of hidden neurons is determined by their x coordinate.  If the two x-derived coordinates of the two neurons coincide, the neuron that was read from the genome later receives a larger number (it is encoded further than the other).  The indices of all input and output neurons are calculated differently.  Each neuron in the genotype also corresponds to the parameter type.  For input neurons, the index is I = type mod N (input), and for output neurons it is calculated using the formula j = N - N (output) + type mod N (output).  Where N (input) is the number of inputs to the neural network, N (output) is the number of outputs from the neural network.  Obviously, some input and output neurons will have the same index.  Therefore, when decoding, N (input) input and N (output) output real neurons are added to the neural network, to which the inputs and outputs of the network are connected.  Each such additional neuron is associated with all neurons with the corresponding index. <br><br>  After decoding all the neurons and placing them in space, a connection tree begins to be built from each neuron.  It is usually calculated as a fractal, but the specific method of its calculation is not important.  The length of the segments of the branches of the tree, and the angle between the branches is set when describing each neuron in the genome.  The connection between neurons is established if one of the branches of the graph approaches the other neuron less than the pre-set threshold value. <br><br>  Initially, the training of networks recorded in this way was not carried out separately; they evolved along with weights, which were also recorded in the genome.  But such a view can be used only to build the network structure, and weights can be calculated using standard algorithms. <br><br><h3>  Canglossi, Parisi and Nolfi </h3><br>  On the one hand, this method is a development of the previous one, and on the other hand, it uses a fractal generating process similar to a grammatical representation. <br><br>  This approach was developed by Kangelosi, Parisi and Nolfi.  Instead of encoding each neuron directly, they write a set of rules for the separation and displacement of neurons.  Therefore, the method is named Generating cell space GCS. <br><br>  The process of ontogenesis begins with a single cell - a special type of &lt;egg&gt;.  This cell is then divided (&lt;rewritten&gt;) into two daughter cells, and the separation parameters are specified in the rule.  Each of the progeny cells can be placed in one of the 8 adjacent cells.  The process is repeated a specified number of times, after which all the cells constructed are &lt;mature&gt; and turn into neurons.  They are divided into input, output and hidden by the same principle as in the previous method. <br><br><h3>  Kangelossi and Elman <br></h3><br>  This method is a more biological development of the previous one.  He uses the so-called.  genetic regulation network (GRN) to control the network building process.  Their GRN consists of 26 regulatory elements (genes), built by analogy with biological operons.  Each operon is divided into two parts - regulatory (regulatory) and expressive (expression).  The regulatory part consists of two regions: an inductor and an inhibitor.  The expressive part also consists of two regions: the regulatory and structural.  If the regulatory region of a gene coincides with the inducer of another gene, the latter is expressed (ie, the commands specified in its structural part are executed).  Expression occurs if it was not prohibited by an inhibitor of another gene.  The amount of the gene expressed (‚Äúthe amount of chemical elements produced‚Äù) depends on the inducer part of the regulatory element. <br><br><h3>  O'Neill and Brabazon <br></h3><br>  The method proposed by the authors is based on the formal grammar method.  However, the formal grammar used to construct a sequence of commands, in turn, is described by some meta-grammar. <br>  For example, the following universal or meta-grammar allows you to generate an arbitrary 8-bit sequence: <br><br><pre> &lt;g&gt; :: =
 "&lt;bitstring&gt; :: =" &lt;reps&gt;
 "&lt;bbk4&gt; :: =" &lt;bbk4t&gt;
 "&lt;bbk2&gt; :: =" &lt;bbk2t&gt;<font></font>
<font></font>
 "&lt;bbk1&gt; :: =" &lt;bbk1t&gt;
 "&lt;bit&gt; :: =" &lt;val&gt;
 &lt;bbk4t&gt; :: = &lt;bit&gt; &lt;bit&gt; &lt;bit&gt; &lt;bit&gt;<font></font>
<font></font>
 &lt;bbk2t&gt; :: = &lt;bit&gt; &lt;bit&gt;
 &lt;bbk1t&gt; :: = &lt;bit&gt;
 &lt;reps&gt; :: = &lt;rept&gt;
 |  &lt;rept&gt; "|"  &lt;reps&gt;<font></font>
<font></font>
 &lt;rept&gt; :: = "&lt;bbk4&gt; &lt;bbk4&gt;"
 |  "&lt;bbk2&gt; &lt;bbk2&gt; &lt;bbk2&gt; &lt;bbk2&gt;"
 |  "&lt;bbk1&gt; &lt;bbk1&gt; &lt;bbk1&gt; &lt;bbk1&gt; &lt;bbk1&gt; &lt;bbk1&gt; &lt;bbk1&gt; &lt;bbk1&gt;"<font></font>
<font></font>
 &lt;bit&gt; :: = "&lt;bit&gt;"
 |  one
 |  0
 &lt;val&gt; :: = &lt;valt&gt;
 |  &lt;valt&gt; "|"  &lt;val&gt;<font></font>
<font></font>
 &lt;valt&gt; :: = 1 |  0
</pre><br><br>  For grammar translation, an input bit string is used that indicates a sequence of rule numbers selected in cases where the non-terminal contains more than one output method. <br><br>  For example, the meta grammar described above may produce the following grammar: <br><br><pre> &lt;bitstring&gt; :: = &lt;bit&gt; 11 &lt;bit&gt; 00 &lt;bit&gt; &lt;bit&gt;<font></font>
<font></font>
 |  &lt;bbk2&gt; &lt;bbk2&gt; &lt;bbk2&gt; &lt;bbk2&gt;
 |  11011101
 |  &lt;bbk4&gt; &lt;bbk4&gt;
 |  &lt;bbk4&gt; &lt;bbk4&gt;
 &lt;bbk4&gt; :: = &lt;bit&gt; 11 &lt;bit&gt;<font></font>
<font></font>
 &lt;bbk2&gt; :: = 11
 &lt;bbk1&gt; :: = 1
 &lt;bit&gt; :: = 1 |  0 |  0 |  one
</pre><br><br>  Thus, an individual's genotype consists of two binary strings - one is designed to generate grammar based on meta-grammar, and the other is to generate, in fact, the ANN based on the resulting grammar. <br><br>  For a more detailed description of the method, see [7], [8] <br><br><h3>  Other methods </h3><br>  There are many other methods of neuroevolution (some of which are in [5]).  here I will give only brief descriptions of each of them: <br><ul><li>  Boers and Kuiper - use context-sensitive L-systems <br></li><li>  Dilaert and Beer (Dellaert and Beer) - an approach similar to Kangelossi and Elman, but using random boolean neural networks (random boolean networks) <br></li><li>  Harp, Samad and Guha (Harp, Samad, and Guha) - Poson direct coding of structure <br></li><li>  Gruau - using a grammatical tree to specify instructions for cell division (somewhat similar to Kangelossi, Paris and Nolfi) <br></li><li>  Vaario (Vaario) - cell growth is given by L-systems <br></li></ul><br><br><h2>  Comparison of different approaches to neuroevolution <br></h2><br>  Unfortunately, to unequivocally say which of the above approaches is the most optimal, is currently quite difficult.  This is due to the fact that the unambiguous criterion of the "universal assessment" has not been worked out.  As a rule, both the authors and third-party researchers evaluate the effectiveness on the basis of certain test problems within certain problem areas, and at the same time interpret the results very differently.  Moreover, in almost all the comparative papers I have met, reservations are made about the fact that the results obtained may change when the test conditions change, and that additional research is needed (which I also make a reservation). <br><br>  For reference purposes only, I present brief results of comparisons made in [5] (a number of algorithms are compared with each other) and in [6] (the NEAT method is compared with some other methods). <br><br>  The following methods were compared in [5]. <br><ul><li>  Miller (direct encoding) <br></li><li>  Kitano (coding on L-systems) <br></li><li>  Nolfi (cell space) <br></li><li>  Kangelosi (generating cell space) <br></li></ul><br>  For comparison, a number of artificial and life problems were used on which the comparison was made. <br>  Detailed results are given in [5], but in general it can be noted that: <br><ul><li>  Kitano Evolved Nets Produce Better Results <br></li><li>  Miller's nets are not much worse than Kitano <br></li><li>  Networks built by the Nolfi method are noticeably worse than Kitano and Miller <br></li><li>  Networks built by the Kangelossi method are even worse than Nolfe. <br></li></ul><br>  However, it is noted that the best networks built using two ‚Äúbad‚Äù methods (Nolfi and Kangelossi) demonstrate a significantly greater potential for learning when they are trained several times with different random weights. <br><br>  In [6], NEAT is compared with some other techniques (evolutionary programming [7], conventional neuroevolution [8], Sane [9], and ESP [10]).  The results of the comparison on one of the tasks (balancing with two poles ‚Äî see details in [11]) are listed in the table. <br><br><table width="280"><tbody><tr><td width="64">  Method <br><br></td><td width="77">  Evaluations <br></td><td width="81">  Generations <br></td><td width="58">  No.  Nets <br></td></tr><tr><td>  Ev.  Programming 307,200 150 2048 <br></td><td>  307,200 <br></td><td>  150 <br></td><td>  2048 <br></td></tr><tr><td>  Conventional NE <br><br></td><td>  80,000 <br></td><td>  800 <br></td><td>  100 <br></td></tr><tr><td>  SANE <br></td><td>  12,600 <br></td><td>  63 <br></td><td>  200 <br></td></tr><tr><td>  Esp <br><br></td><td>  3,800 <br></td><td>  nineteen <br></td><td>  200 <br></td></tr><tr><td>  NEAT <br></td><td>  3,600 <br></td><td>  24 <br></td><td>  150 <br></td></tr></tbody></table><br>  As you can see, NEAT behaves much better than most of the compared methods (not surprising, given that the data were published by the authors of the methodology), however, again, these data need to be checked in other problem areas. <br><br><h2>  Instead of conclusion [3] </h2><br>  The combined use of evolutionary algorithms and ANNs allows solving the tasks of tuning and learning of the ANN both individually and simultaneously.  One of the advantages of such a synthesized approach is in many respects a unified approach to solving various problems of classification, approximation, control, and modeling.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using a qualitative assessment of the functioning of the ANN allows you to apply neuroevolutionary algorithms to solve the problems of studying the adaptive behavior of intelligent agents, searching for game strategies, and signal processing. Despite the fact that the number of problems and open questions concerning the development and application of NE algorithms (coding methods, genetic operators, analysis methods, etc.) is large, it is often enough to successfully solve a problem using the NE algorithm to adequately understand the problem and the NE approach, evidence What is a large number of interesting and successful work in this direction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] - </font></font><a href="http://cgm.computergraphics.ru/content/view/25"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evolutionary neural network models with an unspecified number of connections</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] - Properties of genetic representations of neural architectures (1995, Karthik Balakrishnan, Vasant Honavar) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] - An evolutionary approach to setting up and training artificial neural networks (2006, Tsoi Yu.R., Spitsyn VG) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4 ] - Evolving Neural Networks (2009, Risto Miikkulainen and Kenneth O. Stanley) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[5] - Evolutionary Design of Neural Networks (1998, Marko A. Gronroos) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[6] - Evolving Neural Networks through Augmenting Topologies (2002, KO Stanley and R Miikkulainen) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[7] - Evolving neural control systems (1995, Saravanan, N. and Fogel, DB) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[8] - Evolving neural network control systems for unstable systems (1991, Wieland, A.) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[9] - </font></font><a href="http://satirist.org/learn-game/methods/ga/sane.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SANE</font></font></a> <br> [10] ‚Äî Learning robust nonlinear control with neuroevolution (2002, Gomez, F. and Miikkulainen, R.) <br> [11] ‚Äî <a href="http://anji.sourceforge.net/polebalance.htm">Pole Balance Tutorial</a> </div><p>Source: <a href="https://habr.com/ru/post/84015/">https://habr.com/ru/post/84015/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../84009/index.html">Creating Timeline in WPF</a></li>
<li><a href="../84010/index.html">Enabling log output in script / console</a></li>
<li><a href="../84011/index.html">Click PLAY 2 game - where is this damn button?</a></li>
<li><a href="../84012/index.html">3D cinema everywhere</a></li>
<li><a href="../84014/index.html">Skype Video Cards</a></li>
<li><a href="../84016/index.html">Overview of microblogging services. Part 1</a></li>
<li><a href="../84019/index.html">Results of the All-Russian census of freelancers</a></li>
<li><a href="../84020/index.html">Zeroing karma</a></li>
<li><a href="../84024/index.html">HD broadcast is launched to all of Russia from the satellite</a></li>
<li><a href="../84025/index.html">Karmagraf, WTF?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>