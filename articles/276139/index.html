<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The simplest 3D game on libGDX for Android with 200 lines of code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I teach Samsung IT programming for schoolchildren at the IT school Samsung. The training program covers a wide variety of topics. Among others there i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The simplest 3D game on libGDX for Android with 200 lines of code</h1><div class="post__text post__text-html js-mediator-article">  I teach Samsung IT programming for schoolchildren at the IT school Samsung.  The training program covers a wide variety of topics.  Among others there is one lesson introducing students to the basics of 3D graphics for Android.  The standard study material of this lesson seemed to me very useless for several reasons: <br><ol><li>  Naked OpenGL is used, and since in practice ready-made engines are most often used in programming games, this is of little use to schoolchildren in the context of their own projects.  Someone may argue that to see a clean OpenGL in the business is useful for understanding the basics, but here comes the 2nd flaw. </li><li>  The lesson is very incomprehensible.  A typical schoolchild, even if versed in programming, does not have a sufficient base to understand much of what is described in the lesson (for example, many of the matrices will pass only in the university). </li><li>  At the end of the lesson we come to the result - drawing 3 triangles using OpenGL.  This is so far from the real 3D-game that it can easily discourage interest from the student. </li></ol><br>  Therefore, I decided to prepare my lesson describing the basics of using libGDX for Android, and since I am still preparing this material, at the same time place it here - on a habr.  In this tutorial we will make a simplest 3D game for Android, a screenshot of which you can see in the introduction to the article.  So, interested, welcome under cat. <br> <a href="https://habrahabr.ru/post/276139/"><img src="https://habrastorage.org/files/c92/f84/67a/c92f8467a60b4e4db6cae53e163d78b5.png"></a> <br><a name="habracut"></a><br>  Why libGDX?  First, the code should be in Java, because we teach students exactly Java programming.  This narrows the choice.  Secondly, libGDX was very easy to learn.  In my conditions, this is a great advantage that outweighs the other disadvantages. <br><br>  The idea of ‚Äã‚Äãthe game is very simple: you are a fighter co-pilot responsible for weapons systems.  You need to have time to shoot with laser weapons when the engine of the enemy ship is in the crosshairs, while your first pilot tries not to let yourself off the tail.  That is, in fact, the gameplay is described by the phrase ‚Äúclick on time‚Äù. <br><br>  In the course of this lesson, we only need Android Studio 1.5 (the version may be different, here I brought the one with which I did it all exactly). <br>  First, we need to download the project creation wizard from libGDX, which greatly simplifies the task of initial setup of the project (you can download it from the link in the <a href="https://github.com/libgdx/libgdx/wiki/Project-Setup-Gradle">instruction on the libGDX project wiki</a> ).  Here's what settings I got there: <br><img src="https://habrastorage.org/files/95a/2cb/36f/95a2cb36f47c4822b3a4ca032dc6e5b1.png"><br>  We import the resulting project in Android Studio and begin the actual work with the code.  The main code of the game is in the file MyGdxGame.java (if you called this class just like me).  Remove the template code and start writing your own: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyGdxGame</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PerspectiveCamera cam; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] startPos = {<span class="hljs-number"><span class="hljs-number">150f</span></span>, -<span class="hljs-number"><span class="hljs-number">9f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>}; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ cam = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PerspectiveCamera(<span class="hljs-number"><span class="hljs-number">67</span></span>, Gdx.graphics.getWidth(), Gdx.graphics.getHeight()); cam.position.set(startPos[<span class="hljs-number"><span class="hljs-number">0</span></span>], startPos[<span class="hljs-number"><span class="hljs-number">1</span></span>], startPos[<span class="hljs-number"><span class="hljs-number">2</span></span>]); cam.lookAt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); cam.near = <span class="hljs-number"><span class="hljs-number">1f</span></span>; cam.far = <span class="hljs-number"><span class="hljs-number">300f</span></span>; cam.update(); } }</code> </pre> <br>  Here we create a new camera with a viewing angle of 67 degrees (which is quite often used value) and set the aspect ratio to the width and height of the screen.  Then we set the camera position to a point (150, -9, 0) and indicate that it will look at the center of coordinates (since this is where we plan to place the pyramid around which the gameplay will be built).  Finally, we call the service update () method so that all our changes are applied to the camera. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now you can portray something that we will look at.  Of course, we could use some kind of 3D model, but now, in order to simplify the lesson, we will draw only a simple pyramid: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyGdxGame</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationAdapter</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Model model; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ModelInstance instance; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... ModelBuilder modelBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModelBuilder(); model = modelBuilder.createCone(<span class="hljs-number"><span class="hljs-number">20f</span></span>, <span class="hljs-number"><span class="hljs-number">120f</span></span>, <span class="hljs-number"><span class="hljs-number">20f</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Material(ColorAttribute.createDiffuse(Color.GREEN)), VertexAttributes.Usage.Position | VertexAttributes.Usage.Normal); instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModelInstance(model); instance.transform.setToRotation(Vector3.Z, <span class="hljs-number"><span class="hljs-number">120</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ model.dispose(); } }</code> </pre><br>  Here we create an instance of ModelBuilder, which is intended for creating models in code.  Then we create a simple cone model with dimensions of 20x120x20 and the number of faces 3 (which ultimately gives a pyramid) and ask it the material of green color.  When we create a model, you need to set at least Usage.Position.  Usage.Normal adds normals to the model, so the lighting can work properly. <br><br>  The model contains everything you need to draw and manage your own resources.  However, it does not contain information on where to draw.  So we need to create ModelInstance.  It contains information about the location, rotation parameters and scale for drawing the model.  The default is drawn to (0, 0, 0) so we simply create a ModelInstance, which will be drawn to (0, 0, 0).  But besides, we still call the transform.setToRotation () method to rotate our pyramid by 120 degrees along the Z axis (this is how it can be better seen from the position of the camera). <br><br>  The model needs to be released after use, so we add some code to our Dispose () method. <br><br>  Now let's draw our model instance: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyGdxGame</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationAdapter</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ModelBatch modelBatch; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ modelBatch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModelBatch(); ... } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Gdx.gl.glViewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Gdx.graphics.getWidth(), Gdx.graphics.getHeight()); Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT | GL20.GL_DEPTH_BUFFER_BIT); modelBatch.begin(cam); modelBatch.render(instance); modelBatch.end(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ model.dispose(); modelBatch.dispose(); } }</code> </pre><br><br>  Here we add to the create ModelBatch method, which is responsible for drawing and initializing the model.  In the render method, we clear the screen, call modelBatch.begin (cam), draw our ModelInstance, and then call modelBatch.end () to complete the rendering process.  Finally, we need to free modelBatch to make sure that all the resources (for example, the shaders it uses) are properly freed. <br><br><img src="https://habrastorage.org/files/e9e/c91/981/e9ec91981dec4e21a4985f0a35fa7b8d.png"><br><br>  It looks pretty good, but a bit of lighting could improve the situation, so let's add it: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyGdxGame</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationAdapter</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Environment environment; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ environment = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Environment(); environment.set(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColorAttribute(ColorAttribute.AmbientLight, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>)); environment.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DirectionalLight().set(<span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>, <span class="hljs-number"><span class="hljs-number">20f</span></span>)); ... } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... modelBatch.begin(cam); modelBatch.render(instance, environment); modelBatch.end(); } }</code> </pre><br><br>  Here we add an instance of Environment.  We create it and set the ambient (diffuse) light (0.4, 0.4, 0.4) (note that the transparency value is ignored).  Then we create a DirectionalLight (directional light) with a color (0.8, 0.8, 0.8) and a direction (10, 10, 20).  I assume that you are already familiar with the sources of illumination in general, although everything is quite obvious here.  Finally, during rendering, we transfer the created environment to the model handler. <br><br><img src="https://habrastorage.org/files/5ed/e45/b1a/5ede45b1a2f44fa59456062a94611a26.png"><br><br>  Since we are still writing the game, it would not hurt to add a little dynamics to the static picture.  Let's make the camera move a little with each drawing.  Here it is appropriate to say about the life cycle of a libGDX application.  At the start, the create () method is called, in which it is appropriate to place all initialization.  Then, the render () method is called N times per second, where N is your FPS.  This method draws the current frame.  Therefore, in order to add dynamics to the application, we just need to somehow change the parameters of our game objects in render (). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyGdxGame</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationAdapter</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bound = <span class="hljs-number"><span class="hljs-number">45f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] pos = {startPos[<span class="hljs-number"><span class="hljs-number">0</span></span>], startPos[<span class="hljs-number"><span class="hljs-number">1</span></span>], startPos[<span class="hljs-number"><span class="hljs-number">2</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] Vpos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSpeed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> speed * Math.signum((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) Math.random() - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * Math.max((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) Math.random(), <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// initialize speed for (int i = 0; i &lt; 3; i++){ Vpos[i] = getSpeed(); } } @Override public void render() { ... for (int i = 0; i &lt; 3; i++) { pos[i] += Vpos[i]; if (pos[i] &lt;= startPos[i] - bound) { pos[i] = startPos[i] - bound; Vpos[i] = getSpeed(); } if (pos[i] &gt;= startPos[i] + bound) { pos[i] = startPos[i] + bound; Vpos[i] = getSpeed(); } } cam.position.set(pos[0], pos[1], pos[2]); cam.update(); modelBatch.begin(cam); modelBatch.render(instance, environment); modelBatch.end(); } }</span></span></code> </pre><br><br>  Here we create the illusion that our pyramid is moving, although in reality the camera is moving, through which we look at it.  At the beginning of the game, in the create () method, the increment value of Vpos [i] is randomly selected for each coordinate (velocity).  At each scene redrawing in the render () method, the value of the change step is added to the coordinates.  If we go beyond the established boundaries of change of coordinates, then we return the coordinates to these boundaries and generate new speeds so that the camera starts moving in the other direction.  cam.position.set () itself sets the camera to new coordinates calculated according to the law described above, and cam.update () completes the process of changing camera parameters. <br><br>  It can be noted that on different devices the speed of the pyramid will be different due to the difference in FPS and, accordingly, the number of render () calls per second.  For good here would add the dependence of the increment of coordinates on the time between frames, then the speed would be the same everywhere.  But we will not do this in order not to complicate the project. <br><br><img src="https://habrastorage.org/files/193/458/4b2/1934584b29ac49ff83c33d5b0915ae28.gif"><br><br>  Now let's make a game HUD: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyGdxGame</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationAdapter</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Label label; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Label crosshair; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> BitmapFont font; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Stage stage; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> startTime; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> hits; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... instance.transform.setToRotation(Vector3.Z, <span class="hljs-number"><span class="hljs-number">90</span></span>).translate(-<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); font = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BitmapFont(); label = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label.LabelStyle(font, Color.WHITE)); crosshair = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label(<span class="hljs-string"><span class="hljs-string">"+"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Label.LabelStyle(font, Color.RED)); crosshair.setPosition(Gdx.graphics.getWidth() / <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">3</span></span>, Gdx.graphics.getHeight() / <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">9</span></span>); stage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stage(); stage.addActor(label); stage.addActor(crosshair); startTime = System.currentTimeMillis(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... StringBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); builder.append(<span class="hljs-string"><span class="hljs-string">" FPS: "</span></span>).append(Gdx.graphics.getFramesPerSecond()); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> time = System.currentTimeMillis() - startTime; builder.append(<span class="hljs-string"><span class="hljs-string">"| Game time: "</span></span>).append(time); builder.append(<span class="hljs-string"><span class="hljs-string">"| Hits: "</span></span>).append(hits); builder.append(<span class="hljs-string"><span class="hljs-string">"| Rating: "</span></span>).append((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) hits/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) time); label.setText(builder); stage.draw(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> </span></span>{ stage.getViewport().update(width, height, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } }</code> </pre><br><br>  Please note that the rotation and shift parameters (translate (x, y, z) method) of the pyramid are changed so that it is located in the center of the screen and is directed to the same place where our camera is looking.  That is, at the start of the game we are with the enemy on the same course and we look to him directly into the engines. <br><br>  Here we create 2 text labels.  The label label is designed to display in-game information (FPS, game time and hit statistics).  The crosshair label is drawn in red and contains only one character - "+".  This shows the player the middle of the screen - his sight.  For each of them in the constructor new Label (&lt;TEXT&gt;, new Label.LabelStyle (font, &lt;COLOR&gt;)) a style is defined that includes the font and the color of the label.  Labels are passed to the Stage object using the addActor () method, and, accordingly, are drawn automatically when the Stage is drawn. <br><br>  In addition, for the crosshair label, the setPosition () method sets the position ‚Äî the middle of the screen.  Here we use screen sizes (Gdx.graphics.getWidth (), ... getHeight ()) to calculate where to put our plus sign so that it is in the middle.  There is also a small dirty hack: setPosition () sets the coordinates of the lower left corner of the label.  So that the plus center is in the center of the screen, I subtract the obtained constants 3 and 9 empirically (that is, at random) from the resulting value. Do not use this approach in full-fledged games.  Just a plus sign in the middle of the screen is not serious.  If you need a crosshair, you can use <a href="https://libgdx.badlogicgames.com/nightlies/docs/api/com/badlogic/gdx/graphics/g2d/Sprite.html">sprites</a> . <br><br>  With each drawing we create the text via StringBuilder, where we put everything that we want to display at the bottom of the screen: FPS, time in the game, number of hits and rating.  The setText () method allows you to set the label text, which we do in render () time after time. <br><br><img src="https://habrastorage.org/files/0b5/244/260/0b52442604fc46f5b0b749991e5fa71b.png"><br><br>  True shoot, we can not yet.  It's time to fix this flaw. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyGdxGame</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zone = <span class="hljs-number"><span class="hljs-number">12f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isUnder = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> underFire; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... Gdx.input.setInputProcessor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputMultiplexer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.abs(pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] - startPos[<span class="hljs-number"><span class="hljs-number">1</span></span>]) &lt; zone &amp;&amp; Math.abs(pos[<span class="hljs-number"><span class="hljs-number">2</span></span>] - startPos[<span class="hljs-number"><span class="hljs-number">2</span></span>]) &lt; zone) { isUnder = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; crosshair.setColor(Color.RED); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isUnder = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; crosshair.setColor(Color.LIME); underFire = <span class="hljs-number"><span class="hljs-number">0</span></span>; } ... } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">touchDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> screenX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> screenY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pointer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> button)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUnder) { underFire = System.currentTimeMillis(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hits /= <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">touchUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> screenX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> screenY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pointer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> button)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUnder &amp;&amp; underFire != <span class="hljs-number"><span class="hljs-number">0</span></span>) { hits += System.currentTimeMillis() - underFire; underFire = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hits /= <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre><br><br>  Notice that the description of the MyGdxGame class has now changed.  Here we inherit from InputAdapter and implement the ApplicationListener interface.  This structure will allow us to keep our code unchanged, but to supplement it with the ability to handle user input.  The create () method adds a string that registers our class as an input handler.  We simply have to implement the pause () and resume () methods, since the InputAdapter has it abstract. <br><br>  The whole hit math is in render ().  We check whether the coordinates of the camera are in that zone so that our opponent is in the center of the screen on the same course as us (are the Y and Z coordinates within the start ¬± zone).  If we are on the same course, it means you can shoot: set isUnder = true and make the sight more bright red.  Again, this simplicity of hit determination is a trick based on the <s>stupidity of</s> simplicity, a certain conventionality of the gameplay.  In general, libGDX has the <a href="https://xoppa.github.io/blog/interacting-with-3d-objects/">means to determine which 3D models are in the touch area in the general case</a> . <br><br>  Touch handling methods are called touchDown and touchUp (finger removed from the screen).  These methods take touch coordinates, but we will not use them here.  In fact, it is enough for us to determine whether the camera is now in that position to look at the pyramid directly.  If this is the case (the user pressed on time), then in touchDown we start counting the time how much the laser was frying the hostile pyramid.  If not, then reduce the user's points by dividing in two (penalty for a slip).  When the user releases his finger, check if he has released him too late.  If you let go late, then we are fined, if on time (the laser was still frying the target), then we add points. <br><br><h2>  Addition: model of a fighter instead of a pyramid </h2><br>  In general, the game is ready, but I want it to look somehow decently, and the pyramid is pretty boring.  So, as an optional addition to the lesson, you can still implement a normal 3D model of the aircraft instead of a pyramid.  Take <a href="http://www.turbosquid.com/FullPreview/Index.cfm/ID/588767">this model</a> and try to insert it into our game. <br><br>  The model is delivered in 4 formats of different 3D editors.  However, libGDX uses its binary model format, into which they need to be converted in order to be used in the game.  For this, a special utility is <a href="https://github.com/libgdx/fbx-conv">provided</a> - <a href="https://github.com/libgdx/fbx-conv">fbx-conv</a> .  Download the collected binaries and unpack it in any folder.  There is a version for Windows, Linux and MacOS.  The Windows version will start without much fuss, and for Linux and MacOS you must first run the command <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LD_LIBRARY_PATH=/folder/<span class="hljs-built_in"><span class="hljs-built_in">where</span></span>/fbx-conv/extracted/</code> </pre><br>  Thus, we tell the utility where to find its shared library libfbxsdk.so, which it requires to work.  Run the utility: <br><pre> <code class="bash hljs">./fbx-conv-lin64 -f space_frigate_6/space_frigate_6.3DS</code> </pre><br>  Of course, you need to specify your path to the model and use the binary for your OS.  As a result, you get a file <code>space_frigate_6.g3db</code> , which must be placed in the <code>android/assets</code> project folder (folder with application resources for the Android platform). <br><div class="spoiler">  <b class="spoiler_title">On the difficulties of converting models for libGDX for those who want to use other models</b> <div class="spoiler_text">  In general, the libGDX + fbx-conv bundle is very problematic.  I tried about a dozen free spacecraft models from <a href="http://tf3dm.com/">http://tf3dm.com/</a> and <a href="http://www.turbosquid.com/">http://www.turbosquid.com/</a> before I managed to find this one that worked.  Difficulties are very different.  Sometimes the model in the game is obtained without textures, sometimes it loads normally, but it is simply not displayed, and sometimes (this is most often) when the model is loaded, the game drops out with OutOfMemoryError.  I, of course, understand that this is a mobile platform.  But games in the Play Market show much more complicated graphics and memory for them to do.  Even the model that I eventually used caused problems.  From obj it wasn‚Äôt normally converted, but from 3ds it turned out.  In light of this, we can say that for the time being, libGDX with model support is tight.  You can use this engine for simple games, if you carefully select models or make them yourself with an eye to compatibility with libGDX.  Or use more advanced engines such as <a href="http://jmonkeyengine.org/">jMonkeyEngine</a> . <br></div></div><br><br>  And now let's connect it in the game: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyGdxGame</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AssetManager assets; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> loading; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... assets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AssetManager(); assets.load(<span class="hljs-string"><span class="hljs-string">"space_frigate_6.g3db"</span></span>, Model.class); loading = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loading) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (assets.update()) { model = assets.get(<span class="hljs-string"><span class="hljs-string">"space_frigate_6.g3db"</span></span>, Model.class); instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModelInstance(model); loading = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ... } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ model.dispose(); modelBatch.dispose(); } }</code> </pre><br><br>  Here we create an instance of the class AssetManager, which is responsible for downloading game resources and instruct it to load our model.  On each drawing, we check if the AssetManager model has still loaded (the update () method that returns a boolean).  If you load, then we push our nyashy plane in the instance instead of the pyramid that has become scorched and set loading = false so that this creation of inctance does not repeat on every frame, otherwise assets.update () will return true further throughout the application's time. <br><br>  When we start, we get the exception <code>java.io.FileNotFoundException: SPACE_FR.PNG</code> .  So the model file does not include textures, they need to be thrust separately.  We take from 4 presented pleasant texture, we rename into <code>SPACE_FR.PNG</code> , we put in <code>assets</code> , we start.  As a result, we get that in the introductory picture.  Well, for a snack - gif with gameplay: <br><br><img src="https://habrastorage.org/files/ddb/0c0/95a/ddb0c095a0c040c8a4eb672b70e70fcf.gif"><br><br>  <b>Bottom line:</b> we wrote a very simple, but almost complete from the point of view of the means used (lighting, motion, HUD, touches, models) game, having packed only 200 lines of code.  Of course, there is much to improve: a normal sight, skybox (sky or space around), sounds of shots and flight, game menu, normal hit detection, etc. However, the game already contains the very base of the gameplay and clearly shows the most basic points of game development on libGDX.  I hope this lesson will contribute to the emergence of many new interesting games on Android from both my students and the audience of Habr. <br><br><h2>  Sources: </h2><br><ol><li>  <a href="https://libgdx.badlogicgames.com/nightlies/docs/api/overview-summary.html">https://libgdx.badlogicgames.com/nightlies/docs/api/overview-summary.html</a> </li><li>  <a href="http://www.todroid.com/android-gdx-game-creation-part-i-setting-up-up-android-studio-for-creating-games/">http://www.todroid.com/android-gdx-game-creation-part-i-setting-up-up-android-studio-for-creating-games/</a> </li><li>  <a href="https://xoppa.github.io/blog/basic-3d-using-libgdx/">https://xoppa.github.io/blog/basic-3d-using-libgdx/</a> </li><li>  <a href="http://stackoverflow.com/questions/19699801/dewitters-game-loop-in-libgdx">http://stackoverflow.com/questions/19699801/dewitters-game-loop-in-libgdx</a> </li><li>  <a href="http://stackoverflow.com/questions/21286055/run-libgdx-application-on-android-with-unlimited-fps">http://stackoverflow.com/questions/21286055/run-libgdx-application-on-android-with-unlimited-fps</a> </li><li>  <a href="https://xoppa.github.io/blog/interacting-with-3d-objects/">https://xoppa.github.io/blog/interacting-with-3d-objects/</a> </li><li>  <a href="https://xoppa.github.io/blog/loading-models-using-libgdx/">https://xoppa.github.io/blog/loading-models-using-libgdx/</a> </li></ol><br><br>  <b>PS:</b> here is <a href="https://github.com/cepreu2github/cubegame">the github code</a> and <a href="">apk-file of the game</a> . </div><p>Source: <a href="https://habr.com/ru/post/276139/">https://habr.com/ru/post/276139/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276125/index.html">Chrome Cleanup Tool: a program for cleaning Chrome from garbage</a></li>
<li><a href="../276129/index.html">Security Week 04: Lenovo's WiFi Hotspot Conf-Call Backdoor, Amazon Distributes HTTPS for Free</a></li>
<li><a href="../276131/index.html">We place the site in an anonymous network I2P (+ paranoid mode)</a></li>
<li><a href="../276135/index.html">Parse.com is closing</a></li>
<li><a href="../276137/index.html">The digest of interesting materials from the world of Drupal # 17</a></li>
<li><a href="../276141/index.html">We fool the DPI with two scripts</a></li>
<li><a href="../276145/index.html">IaaS for business: How Russian business moves to the ‚Äúcloud‚Äù</a></li>
<li><a href="../276147/index.html">Half a year working with Blend4Web. Is it worth it?</a></li>
<li><a href="../276149/index.html">Hacking Kaspersky Crackme: a study of the protective mechanism (Part 1)</a></li>
<li><a href="../276151/index.html">How-to: Object-Oriented Python Backtesting</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>