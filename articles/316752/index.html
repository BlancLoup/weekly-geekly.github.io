<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The story of a single plugin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It all started with the fact that the tagbar stopped working for me . The plugin crashed with an error, supposedly the current version of my Exuberant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The story of a single plugin</h1><div class="post__text post__text-html js-mediator-article"><iframe width="560" height="315" src="https://www.youtube.com/embed/TvBJhOOSlOc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  It all started with the fact that the <strong>tagbar</strong> stopped working for <strong>me</strong> .  The plugin crashed with an error, supposedly the current version of my Exuberant Ctags is not Exuberant at all.  Having rummaged a bit in the source, I realized that the last external command ended with an error, and <strong>v: shell_error</strong> gave -1, which means, judging by the documentation of vim, that "the command could not be executed".  I did not dig further and installed <strong>fzf</strong> .  <strong>Fzf</strong> , like <strong>ctrlp</strong> , allows for a fuzzy search in files, tags, buffers, ..., but unlike the latter, it works much faster, but not without drawbacks.  The application works directly with the terminal and every time overwrites the history of the entered commands.  It also means that we cannot display the search results in the buffer ( <strong>neovim</strong> , judging by some screencasts, it can), for example, to the right of the main buffer when we are looking for the right tag.  Unlike sublime, <strong>fzf</strong> does not give more weight to the file name, which is why I often received in the top not the results that I expected to see.  Everything else, the lack of complete freedom in setting up the color scheme, which in general is not too important for the average user, but not for me, with my increased attention to detail.  By freedom, I mean, at a minimum, the distinction between color for ordinary (normal) text and the query string. </p><br><p>  All this prompted me to write my own plugin, the appearance of which resembles the standard directory viewer - <strong>netrw</strong> .  I will describe the problems I have encountered and the ways to solve them, assuming that this experience may be useful to someone. </p><a name="habracut"></a><br><h3 id="vim-script-language">  Vim script language </h3><br><p>  First of all, I would like to have a small tour for those who are taking the first steps in the vim script.  Variables have prefixes, some of which you have already seen and written yourself.  Usually, the plug-in is configured using global variables with the prefix <strong>g:.</strong>  When writing your plugin, it is appropriate to use the <strong>s:</strong> prefix, which makes variables available only within the script.  To refer to the function argument, use the prefix <strong>a:.</strong>  Variables without a prefix are local to the function in which they were declared.  The full list of prefixes can be viewed with the command <strong>: help internal-variables</strong> . </p><br><p>  To manage the buffer, there are two very simple functions: <strong>getline</strong> and <strong>setline</strong> .  With their help, you can insert search results into the buffer or get the value of the query.  I will not dwell on the description of each function, since it is often clear from the name that it does.  Almost any keyword from this article can be searched in the documentation, therefore <strong>: help getline</strong> or <strong>: help setline</strong> , and for a complete picture I advise you to look at <strong>: help function-list</strong> with a list of all functions grouped by sections. </p><br><p>  <strong>Developments</strong> </p><br><p>  Vim provides many events from the box, however, when writing your own plugin, you may need to create your own events.  Fortunately, this is done very simply. </p><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   CustomEvent autocmd User CustomEvent call ... //   ,   "No matching autocommands",         if(exists("#User#CustomEvent")) doautocmd User CustomEvent endif</span></span></code> </pre> <br><p>  <strong>Autoload</strong> </p><br><p>  I set all the functions in my plugin <strong>finder</strong> prefix <strong>#</strong> .  This is vim‚Äôs built-in autoload mechanism, which searches for a file with the same name in <strong>runtimepath</strong> .  The <strong>finder # call</strong> function should be located in the runtimepath / finder.vim file, the <strong>finder # files # index</strong> function should be located in the runtimepath / finder / files.vim file.  Then you need to add the plugin to the <strong>runtimepath</strong> . </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span> runtimepath+=<span class="hljs-keyword"><span class="hljs-keyword">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">plugin</span></span></code> </pre> <br><p>  But it is better to use plugin manager for these purposes, for example, <a href="https://github.com/junegunn/vim-plug">vim-plug</a> . </p><br><p>  <strong>Composite teams</strong> </p><br><p>  Often there is a situation where the team needs to be combined from different pieces or just insert the value of a variable.  For these purposes, in vim there is an <strong>execute</strong> command, which is often convenient to use with the <strong>printf</strong> function. </p><br><pre> <code class="hljs lisp">execute printf('syntax match finderPrompt /^\%%%il.\{%i\}/', b<span class="hljs-symbol"><span class="hljs-symbol">:queryLine</span></span>, len(<span class="hljs-name"><span class="hljs-name">b</span></span><span class="hljs-symbol"><span class="hljs-symbol">:prompt</span></span>))</code> </pre> <br><h3 id="nachnem">  Let's start </h3><br><p>  So, all we need is a query string and a search result.  The input function is responsible for user input in vim, but as far as I know, it does not allow placing the input line at the top, which is quite important when it comes to searching by tags, since it is more convenient to display tags in the order in which they are presented in the file .  Moreover, over time, I decided to make a similar hat, which shows <strong>netrw</strong> .  The input string needed to be implemented in the buffer, and here the first difficulties appear. </p><br><p>  <strong>Request</strong> </p><br><p>  To get the value of the request, we need to know the line containing the input field and the offset relative to the prompt, and also to set an event handler for the <strong>TextChangedI</strong> event.  Since for anyone who has previously programmed, there should be nothing complicated at this stage, I will omit the code;  I will add only that the handler needs to be hung up with the <strong>&lt;buffer&gt;</strong> attribute. </p><br><pre> <code class="hljs xml">autocmd TextChangedI <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">buffer</span></span></span><span class="hljs-tag">&gt;</span></span> call ...</code> </pre> <br><p>  <strong>Prompt</strong> </p><br><p>  Since the tooltip is on the same line as the user input, you need to somehow fix it.  For these purposes, it would be possible to clear the value of the <strong>backspace</strong> option, which is responsible for the behavior of keys such as &lt;BS&gt; and &lt;Del&gt;.  In particular, I was interested only in <strong>eol</strong> and <strong>start</strong> .  <strong>Eol</strong> permits deletion of the end of line character and, accordingly, merging of lines; <strong>start</strong> also permits deletion of only the text that was entered after the start of insert mode.  It was quite convenient and simple: I insert the "Files&gt;" hint, for example, then I start typing the text and when deleting the text, the hint remained in place.  True, I did not take into account one moment - quite a lot of logic is needed for such a plug-in to work and getting into normal mode was common practice.  Any mapping could easily start a new "session" and the text that was entered earlier ceased to be deleted.  I just needed to press &lt;Esc&gt;, for example: </p><br><pre> <code class="hljs xml">inoremap <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Cj</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Esc</span></span></span><span class="hljs-tag">&gt;</span></span>:call ...</code> </pre> <br><p>  I had to create a mapping for &lt;BS&gt; and delete the text manually. </p><br><pre> <code class="hljs xml">inoremap <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">buffer</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">BS</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Esc</span></span></span><span class="hljs-tag">&gt;</span></span>:call finder#backspace()<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">CR</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  There was some strange flicker of the cursor, which eventually became terribly annoying.  A lot of time passed before I realized that I was guilty of the transition to the command-line mode, which we usually initiate by pressing <strong>:.</strong>  At this very moment, the cursor that is above the text disappears.  The flicker effect is the stronger, the "heavier" the called function.  There were attempts to hang the handler on the <strong>TextChangedI</strong> event, which checked the current position of the cursor, and if the cursor was dangerously close to the tooltip, then it was necessary just to bind &lt;BS&gt; to do nothing.  Unfortunately, sometimes 1 character was deleted.  After some time, a solution was found - the attribute <strong>&lt;expr&gt;</strong> . </p><br><pre> <code class="hljs swift"><span class="hljs-built_in"><span class="hljs-built_in">map</span></span> {lhs} {rhs}</code> </pre> <br><p>  Where <strong>{rhs}</strong> is a valid expression (: help expression-syntax), the result of which is inserted into the buffer.  Special keys such as &lt;BS&gt; or &lt;Ch&gt; must be framed with double quotes and escaped with a <strong>\</strong> ((: help expr-quote) character). </p><br><pre> <code class="hljs objectivec">inoremap &lt;expr&gt;&lt;buffer&gt;&lt;BS&gt; finder<span class="hljs-meta"><span class="hljs-meta">#canGoLeft() ? </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\&lt;BS&gt;"</span></span></span><span class="hljs-meta"> : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> inoremap </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;expr&gt;</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;buffer&gt;</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Ch&gt;</span></span></span><span class="hljs-meta"> finder#canGoLeft() ? </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\&lt;BS&gt;"</span></span></span><span class="hljs-meta"> : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> inoremap </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;expr&gt;</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;buffer&gt;</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Del&gt;</span></span></span><span class="hljs-meta"> col(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"."</span></span></span><span class="hljs-meta">) == col(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"$"</span></span></span><span class="hljs-meta">) ? </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\&lt;Del&gt;"</span></span></span><span class="hljs-meta"> inoremap </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;expr&gt;</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;buffer&gt;</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Left&gt;</span></span></span><span class="hljs-meta"> finder#canGoLeft() ? </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\&lt;Left&gt;"</span></span></span><span class="hljs-meta"> : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span></span></code> </pre> <br><p>  <strong>Output</strong> </p><br><p>  In order to exit the buffer, you can bind &lt;Esc&gt;.  The unpleasant point is that some key combinations start with the same sequence of characters as &lt;Esc&gt;.  If you enter the input mode and press &lt;Cv&gt;, then any of the arrows, you can see <strong>^ [</strong> as a prefix.  For example, for the left arrow, the terminal sends <strong>^ [OD</strong> vim'u.  Therefore, when any arrow or &lt;S-Tab&gt; is pressed, vim will perform the action assigned to &lt;Esc&gt;, then try to interpret the rest of the characters: for the left arrow, it will insert the empty line at the top (O) and the capital literal "D" on the same line.  The <strong>esckeys</strong> option indicates whether new characters should be expected if the sequence starts with &lt;Esc&gt;, that is, <strong>^ [</strong> , in input mode.  It would seem that it is necessary, but it works only if we do not change the behavior of &lt;Esc&gt;. </p><br><div class="spoiler">  <b class="spoiler_title">-</b> <div class="spoiler_text"><p>  There could be your joke, dear IDE user. </p></div></div><br><p>  Perhaps I missed something, but for good reason on various resources it is advised not to change the behavior of this key.  If &lt;S-Tab&gt; is not so important, then the arrows would be a good idea to bind to the choice of the next / previous entry.  Therefore, instead of &lt;Esc&gt;, we use the <strong>InsertLeave</strong> event.  This entails new problems.  How to call a function without leaving the input mode?  Reading the documentation, I came across one interesting point - the &lt;Ctrl-c&gt; combination that exits insert mode without triggering the <strong>InsertLeave</strong> event, but, which is rather strange, if &lt;Cc&gt; is present in the mapping, it does not work and <strong>InsertLeave</strong> still pops up.  Plying across the expanses of the Internet, a solution was found, the general form of which is: </p><br><pre> <code class="hljs xml">inoremap <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">BS</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Cr</span></span></span><span class="hljs-tag">&gt;</span></span>=expr<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">CR</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  From the documentation it follows that this is an <strong>expression register</strong> .  This is exactly what I needed, except that the result of the expression was inserted into the buffer.  Actually, the whole plugin is built on this, since all gestures occur in insert mode.  In order not to return an empty string in each function (if this is not done, the function will return 0), I decided to use an intermediary who calls the desired function. </p><br><pre> <code class="hljs lisp">function! finder#call(<span class="hljs-name"><span class="hljs-name">fn</span></span>, ...) call call(<span class="hljs-name"><span class="hljs-name">a</span></span><span class="hljs-symbol"><span class="hljs-symbol">:fn</span></span>, a:<span class="hljs-number"><span class="hljs-number">000</span></span>) return <span class="hljs-string"><span class="hljs-string">""</span></span> endfunction</code> </pre> <br><p>  The namespace <strong>a:</strong> is responsible for accessing the arguments of the function, and the variable <strong>a: 000</strong> contains a list of optional parameters.  Since it is now possible to write the application logic without leaving the input mode, it would be possible to use the <strong>backspace</strong> option.  However, as I later learned, resetting the value of this option <strong>outraged delimitMate</strong> , because of which he could not function properly, and I decided to abandon these attempts. </p><br><p>  <strong>Backend</strong> </p><br><p>  Just nothing and we already have a pack of useless pixels.  It's time to add some life to our buffer.  Since vim script can hardly be called a fast language or a language in which it is pleasant to write something complicated, I decided to write a backend on D. Because the fuzzy search is for me <del>  too lazy to realize </del>  it is not needed, it will be a search taking into account the exact entry, and I decided that I would compare the source string with the user's query character-wise, finding that it would be much faster than using regular expressions.  Considering that I actually had 4 modes: ^ query, query, query $, ^ query $, the code looked a bit unattractive.  Seeing what I wrote, there was a desire to delete everything and search for regulars.  After a while, I realized that what was written could be done using standard Unix tools and decided to return to using <strong>grep</strong> , thoughts about which I had from the very beginning, but which I discarded due to the presence of "complex" logic.  The difficulty was that I had to search by file name, sort by the length of the file path and output not the source line, but its index.  It is worth noting that Unix <strong>grep</strong> was 4 times faster than <strong>std.regex</strong> , which is in D. </p><br><ol><li><p>  To get the file name, you can use the <strong>basename</strong> program, but, unfortunately, it does not read the standard input stream and works only directly with parameters.  You can also use <strong>sed 's!. * / !!'</strong>  which will cut everything to the last.  Vim's built-in function fnamemodify is also <strong>suitable</strong> . </p><br></li><li><p>  I decided to do the sorting by means of vim, since it is simpler in terms of implementation and creating my own extensions.  The sort function is responsible for sorting, for which you will need to write a <strong>comparator</strong> . </p><br></li><li>  To display the index, you can use the <strong>-n</strong> flag in <strong>grep</strong> , which displays the line number, the format of which is <strong>n: line</strong> and parsing which is not difficult. </li></ol><br><p>  <strong>Flicker cursor</strong> </p><br><p>  In general, this is a pretty hateful thing.  Flicker of the cursor can be seen by setting the <strong>incsearch</strong> option.  Just try to look for something in the buffer and watch the cursor while typing.  If everything is clear with the change in the behavior of &lt;BS&gt;, then writing <strong>&lt;expr&gt;</strong> everywhere, as it turned out, is impossible.  This flag prohibits changing any lines other than the one on which the cursor is located.  Therefore, for the rest of the logic, the above-mentioned <strong>expression register is used</strong> , which, like, removes the cursor from the current position to the time the expression is executed.  Since the search for several thousand files takes some time, the effect of the cursor flashing when typing each character appears.  I must say that non-blocking vim arrived in time, and specifically the function <strong>timer_start</strong> .  When the buffer began to render asynchronously, the problem was gone.  Not the best solution, I must say, but I did not find anything more suitable.  This is the only reason why the plugin requires vim 8th version. </p><br><p>  The third time the problem overtook when I had to do a preview.  The cursor blinked at the moment when the cursor position was changing in one of the buffers and the screen was being drawn.  I am afraid there is no distortion in the spirit: "to highlight the syntax of the character under the cursor" is not enough, and I decided to leave such machinations until better times. </p><br><p>  <strong>Notice traces</strong> </p><br><p>  Since we are constantly changing the contents of the buffer, the <strong>tabline</strong> will tell us that the buffer has been changed, and the work in the input mode will be accompanied by the corresponding inscription at the bottom left.  I don‚Äôt know about you, but I like minimal design, and I would like to remove such things.  Also, it would be nice to hide the <strong>ruler</strong> and <strong>statusline</strong> .  To prevent vim from tracking changes in the buffer, you can use the <strong>buftype</strong> option. </p><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">setlocal</span></span> buftype=nofile</code> </pre> <br><p>  With the status bar, ruler and caption <strong><code>-- INSERT --</code></strong> bit more complicated, because the options that are responsible for displaying them are global, which means we need to restore the previous value when exiting the buffer.  For this, it is convenient to listen to the <strong>OptionSet</strong> event. </p><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> noshowmode <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> laststatus=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> rulerformat=<span class="hljs-variable"><span class="hljs-variable">%0(%</span></span>) redraw</code> </pre> <br><p>  Instead of a <strong>rulerformat,</strong> one could use a <strong>noruler</strong> , but the latter requires redrawing the screen with pre-cleaning (redraw!), Which causes an unpleasant effect to the eye. </p><br><h3 id="sintaksis">  Syntax </h3><br><p>  Here I would like to summarize the most important points about the syntax that played an important role in the work of the plugin. </p><br><table><thead><tr><th>  Element </th><th>  Example </th><th>  Description </th></tr></thead><tbody><tr><td>  <strong>\ c</strong> </td><td>  \ c. * </td><td>  Ignore case when searching. </td></tr><tr><td>  <strong>. {-}</strong> </td><td>  . {-} p </td><td>  "Not greedy" analog <strong>. *</strong> </td></tr><tr><td>  <strong>\ zs</strong> , <strong>\ ze</strong> </td><td>  . {-} \ zsfoo \ ze. * </td><td>  Start and end of entry, respectively. </td></tr><tr><td>  <strong>\ @ =</strong> , <strong>\ @ &lt;=</strong> </td><td>  \ (hidden \) \ @ &lt;= text </td><td>  The so-called <strong>zero-width atoms</strong> - cut out the previous atom from the entry. </td></tr><tr><td>  <strong>\% l</strong> </td><td>  \% 1l </td><td>  Search on a specific line. </td></tr><tr><td>  <strong>\ &amp;</strong> </td><td>  p1 \ &amp; p2 \ &amp; .. </td><td>  Conjunction operator. </td></tr></tbody></table><br><p>  <strong>Basename</strong> </p><br><p>  Since we are working with the file name, we need to specify a region that limits the highlighting of the entry. </p><br><pre> <code class="hljs tex"><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">(</span></span></span></span>^<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">|</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span></span>(<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">/</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">)</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">@</span></span></span></span>&lt;=<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">)</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">[^\/]</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">+</span></span></span></span><span class="hljs-formula"><span class="hljs-formula">$</span></span></code> </pre> <br><p>  config / <strong>foobar.php</strong> <br>  <strong>foobar.php</strong> </p><br><p>  Now you need to highlight the desired characters.  For these purposes, you can use the conjunction operator <strong>\ &amp;</strong> (:: help branch). </p><br><pre> <code class="hljs tex"><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">(</span></span></span></span>^<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">|</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span></span>(<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">/</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">)</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">@</span></span></span></span>&lt;=<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">)</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">[^\/]</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">+</span></span></span></span><span class="hljs-formula"><span class="hljs-formula">$</span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">&amp;</span></span></span></span></span><span class="hljs-formula">.</span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">{</span></span></span></span></span><span class="hljs-formula">-}f</span></span></code> </pre> <br><p>  config / <strong>f</strong> oobar.php <br>  <strong>f</strong> oobar.php </p><br><p>  <strong>Tip</strong> : since this is a regular <strong>pattern</strong> (: help pattern), you can test everything in a separate buffer by pressing <strong>/</strong> . </p><br><p>  <strong>Comments</strong> </p><br><p>  In <strong>fzf</strong> there is a useful visual feature - the presence of text that does not affect the search results, that is, comments.  At first, I wanted to use some kind of invisible Unicode character to mark the beginning of a comment (the space, for obvious reasons, does not fit), but later I came across a useful feature for the syntax group ‚Äî <strong>conceal</strong> .  In short, <strong>conceal</strong> hides any text, leaving it in the buffer.  Two options are responsible for the behavior of <strong>conceal</strong> : <strong>conceallevel</strong> and <strong>concealcursor</strong> .  At a certain setting, the text may not be hidden, so I advise you to read them.  In my plugin, the lines are as follows: </p><br><pre> <code class="hljs objectivec">text<span class="hljs-meta"><span class="hljs-meta">#finderendline...</span></span></code> </pre> <br><p>  where <strong>...</strong> is an optional comment, and <strong>#finderendline</strong> is hidden.  An example of hidden text: </p><br><pre> <code class="hljs scala">syntax <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> hidden /pattern/ conceal</code> </pre> <br><p>  <strong>Scroll</strong> </p><br><p>  The work of the plugin in the input mode gives a lot of problems, one of which is scrolling.  Since the cursor is needed at the place where the request was entered, we cannot move it to highlight the desired line.  In order to navigate through the search results, you can use the syntax by creating the appropriate group.  <strong>Ordinary atom \% l</strong> fits perfectly.  For example, <strong>\ ^% 2l. * $</strong> Selects the second line. </p><br><p>  My screen contains 63 lines of text, and since there can be many more entries, the question is how to get to the 64th and subsequent lines.  Since the header and the query string should always be in the visible part of the screen, when approaching the end of the screen, we will cut (put into a temporary array) the first (second, third, ...) entry until we reach the end.  When moving up, everything is exactly the opposite. </p><br><h3 id="rezyume">  Summary </h3><br><p>  With the availability of this article, vim seems to be hinting - it was necessary to use <strong>input</strong> , however, when everything is already behind, I am glad that I took a non-standard way and got such valuable experience.  That's all, information on installing, using and creating your own extensions can be found in the <a href="https://github.com/damage220/vim-finder">repository</a> . </p><br><h3 id="poleznye-melochi">  Useful stuff </h3><br><p>  Having received a certain base after writing the plugin, I wanted to simplify my life a little. </p><br><p>  <strong>Exit insert mode</strong> </p><br><p>  Those who read <a href="https://habrahabr.ru/post/303524/">my previous article</a> know that I previously used sublime to edit text and code.  There are significant differences between sublime and vim in how they handle keyboard shortcuts.  If a sublime, when entering a combination, inserts text without delay, then vim first waits for a certain time, and only after inserts the desired character, if the combination is "broken".  From the very beginning of using vim-mode in general and vim'a in particular, I used <strong>df</strong> to exit insert mode.  It became so habitual that any attempts at retraining to <strong>jj</strong> , for example, did not succeed.  Each time, typing <strong>d</strong> and a character other than <strong>f</strong> , I observed a nasty jerk.  I decided to repeat the behavior from sublime. </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> g:lastInsertedChar = <span class="hljs-string"><span class="hljs-string">''</span></span> function! LeaveInsertMode() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> reltime = reltime() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timePressed = reltime[<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">1000</span></span> + reltime[<span class="hljs-number"><span class="hljs-number">1</span></span>] / <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(g:lastInsertedChar == <span class="hljs-string"><span class="hljs-string">'d'</span></span> &amp;&amp; v:<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> == <span class="hljs-string"><span class="hljs-string">'f'</span></span> &amp;&amp; timePressed - g:lastTimePressed &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v:<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">feedkeys</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\&lt;Esc&gt;x"</span></span></span></span></span><span class="hljs-function">) endif </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> g:lastInsertedChar</span></span> = v:<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> g:lastTimePressed = timePressed endfunction autocmd InsertCharPre * <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LeaveInsertMode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span></code> </pre> <br><p>  Maybe this is not the best code, but it performs its task.  The point is this: after pressing <strong>d</strong> , we have half a second to press <strong>f</strong> .  If the latter is true, <strong>f is</strong> not printed, and <strong>d</strong> is removed from the buffer.  After which the editor goes into normal mode. </p><br><p>  <strong>Read-only files</strong> </p><br><p>  The remaining minor addition will be a ban on editing certain files. </p><br><pre> <code class="hljs lisp">function! PHPVendorFiles() let path = expand(<span class="hljs-string"><span class="hljs-string">"%:p"</span></span>) if(<span class="hljs-name"><span class="hljs-name">stridx</span></span>(<span class="hljs-name"><span class="hljs-name">path</span></span>, <span class="hljs-string"><span class="hljs-string">"/vendor/"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) setlocal nomodifiable endif endfunction autocmd Filetype php call PHPVendorFiles()</code> </pre> <br><p>  This code prohibits editing a <strong>.php</strong> file if it is located in the <strong>vendor</strong> directory. </p><br><h3 id="postskriptum">  P.S </h3><br><p>  List of changes to my environment since the publication of the first article. </p><br><ul><li>  Moved to <strong>XTerm</strong> , which <strong>feels like</strong> 2 times faster than <strong>gnome-terminal</strong> . </li><li>  <strong>Airline</strong> removed as unnecessary. </li><li>  <strong>NERD Tree</strong> removed in favor of the standard <strong>netrw</strong> . </li><li>  <strong>Vundle</strong> removed in favor of multi <strong>-</strong> threaded <strong>vim-plug</strong> . </li><li>  <strong>CtrlP</strong> removed in favor of <strong>Finder</strong> . </li><li>  <strong>Tagbar</strong> <del>  has broken </del>  removed in favor of <strong>finder</strong> . </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/316752/">https://habr.com/ru/post/316752/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316740/index.html">Efficient storage: as we did from 50 Pb, 32 Pb</a></li>
<li><a href="../316742/index.html">How to create a trading robot using genetic programming</a></li>
<li><a href="../316746/index.html">Dual-pane using fragments</a></li>
<li><a href="../316748/index.html">Functional languages ‚Äã‚Äãin hardware design</a></li>
<li><a href="../316750/index.html">Security Week 48: Tech Support Locker, Mirai Mutations, Vulnerability in Firefox and Tor Browser</a></li>
<li><a href="../316754/index.html">Death transit traffic?</a></li>
<li><a href="../316756/index.html">Creating and testing a firewall in Linux, Part 2.2. Firewall tables. Access to TCP / IP structures</a></li>
<li><a href="../316758/index.html">Linux kernel documentation goes to Python Sphinx</a></li>
<li><a href="../316760/index.html">Enhance your video surveillance system using OpenCV and Telegram bot</a></li>
<li><a href="../316762/index.html">MemC3 - compact Memcache with increased parallelism - due to more stupid caching and smarter hashing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>