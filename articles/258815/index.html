<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Docker workflow</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Switching the hexlet.io infrastructure to Docker required some effort from us. We abandoned many old approaches and tools, rethought the meaning of ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Docker workflow</h1><div class="post__text post__text-html js-mediator-article">  Switching the <a href="https://ru.hexlet.io/%3Futm_source%3Dhabrahabr.ru%26utm_medum%3Dreferral">hexlet.io</a> infrastructure to Docker required some effort from us.  We abandoned many old approaches and tools, rethought the meaning of many familiar things.  What we got in the end, we like.  Most importantly, this transition has made it possible to greatly simplify, unify and make it much more supported.  In this article we will talk about the scheme for the deployment of infrastructure and deployment, which we finally arrived at, as well as describe the pros and cons of this approach. <br><a name="habracut"></a><br><h2>  Prehistory </h2><br>  Initially, we needed the Docker to run untrusted code in an isolated environment.  The task is something similar to what hosters do.  We directly in the production collect images, which are then used to start the practice.  This, by the way, is the rare case when it is impossible to do according to the principle ‚Äúone container - one service‚Äù.  We need all services and all the code for a specific task to be in the same environment.  Minimally, in each such container, the supervisord rises and our browser idea.  Then everything depends on the task itself: the author can add and deploy at least radishes, even Hadup. <br><br>  And it turned out that the docker allowed me to create a simple way of assembling practical tasks.  First, because if the practice has gathered and started working on the local machine from the author, then it is guaranteed (almost) that it will start in production as well.  For isolation.  And secondly, despite the fact that many consider the docker file to be a ‚Äúregular bash‚Äù with all the consequences, this is not so.  Docker is a prime example of using the functional paradigm in the right places.  It provides idempotency, but not in the same way as configuration management systems, due to internal verification mechanisms, but due to immutability.  Therefore, in the dockerfile, the usual bash, but it rolls as if it always happens on a fresh basic image, and you do not need to take the previous state into account when changing the image.  And caching removes (almost) the problem of waiting for reassembly. <br><br>  At the moment, this subsystem is essentially a continuous delivery for practical tasks.  Perhaps we will make a separate article on this topic if the audience has an interest. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Infrastructure docker </h2><br>  After that, we thought about translating to Docker and the rest of our system.  There were several reasons.  It is clear that in this way we would have achieved greater unification of our system, because the docker has already taken a serious (and not quite trivial) part of the infrastructure. <br><br>  In fact, there is another interesting case.  Many years ago I used chef, after that ansible, which is much simpler.  At the same time, I have always come across such a story: if you do not have your own admins, and you do not do the infrastructure and playbooks / kukbukami regularly, then there are often unpleasant situations in cases like: <br><ul><li>  The configuration management system has been updated (especially with the chef), and you spend two days on it to let everyone down. </li><li>  You forgot that there was some kind of software on the server, and with the new knurling conflicts start, or everything falls.  Looking for transition states.  Well, or how do those who cram cones: ‚Äúevery time on a new server‚Äù. </li><li>  Redistributing services across servers is a pain, everyone influences each other. </li><li>  There are still a thousand smaller reasons, mainly due to the lack of isolation. </li></ul><br><br>  In this regard, we looked at Docker as a miracle that will save us from these problems.  So it happened, in general.  The server still has to periodically redistribute from scratch, but much less frequently and, most importantly, we have reached a new level of abstraction.  Working at the configuration management system level, we think and manage services, and not parts of which they consist.  That is, the control unit is a service, not a package. <br><br>  Also, the key history of painless deployment is a quick, and, importantly, simple rollback.  In the case of Docker, it is almost always fixing the previous version and restarting services. <br><br>  And last but not least.  Building a hexlet is a little more complicated than just compiling assets (we are on rails, yes).  We have a massive js-infrastructure that is built using a webpack.  Naturally, all this farming should be collected on one server and then just scatter.  Capistrano does not allow this. <br><br><h2>  Deploying infrastructure </h2><br>  Almost all we need from configuration management systems is the creation of users, the delivery of keys, configs and images.  After switching to docker, playbooks became monotonous and simple: they created users, added configs, sometimes a little crown. <br><br>  Another very important point is the method of launching containers.  Despite the fact that Docker out of the box comes with his supervisor, and Ansible comes with a module for running Docker containers, we still decided not to use these approaches (although we tried).  The Docker module in Ansible has <a href="https://github.com/ansible/ansible-modules-core/issues%3Futf8%3D%25E2%259C%2593%26q%3Dis%253Aissue%2Bis%253Aopen%2Bdocker">many problems</a> , some of which are not at all clear how to solve.  This is largely due to the separation of the concepts of creation and start of the container, and the configuration is smeared between these stages. <br><br>  In the end, we stopped at upstart.  It is clear that soon you will still have to go to systemd, but it so happened that we use the ubuntu of the version where upstart is running by default.  At the same time we solved the issue of universal logging.  Well, and upstart allows you to flexibly configure the way to start the restart of the service, in contrast to the Docker‚Äôs restart_always: true. <br><br><div class="spoiler">  <b class="spoiler_title">upstart.unicorn.conf.j2</b> <div class="spoiler_text"><pre> description "Unicorn"
 
 start on filesystem or runlevel [2345]
 stop on runlevel [! 2345]
 
 env HOME = / home / {{run_user}}
 # change to match your deployment user
 setuid {{run_user}}
 setgid team
 
 respawn
 respawn limit 3 30
 
 pre-start script
     .  / etc / environment
     export HEXLET_VERSION
 
     / usr / bin / docker pull hexlet / hexlet - {{rails_env}}: $ HEXLET_VERSION
     / usr / bin / docker rm -f unicorn ||  true
 end script
 
 pre-stop script
     / usr / bin / docker rm -f unicorn ||  true
 end script
 
 script
   .  / etc / environment
   export HEXLET_VERSION
 
   RUN_ARGS = '- name unicorn' ~ / apprunner.sh bundle exec unicorn_rails -p {{unicorn_port}}
 end script
  </pre><br></div></div><br><br>  The most interesting thing here is the service start line: <br><br><pre><code class="hljs mel">RUN_ARGS=<span class="hljs-string"><span class="hljs-string">'--name unicorn'</span></span> ~/apprunner.sh bundle <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> unicorn_rails -p {{ unicorn_port }}</code> </pre> <br><br>  This is done in order to be able to run the container from the server, without the need to manually register all the parameters.  For example, so we can enter the rail console: <br><br><pre> <code class="hljs perl">RUN_ARGS=<span class="hljs-string"><span class="hljs-string">'-it'</span></span> ~./apprunner.sh bundle <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> rails c</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">apprunner.sh.j2</b> <div class="spoiler_text"><pre> <code class="hljs tex">#!/usr/bin/env bash . /etc/environment export HEXLET_VERSION <span class="hljs-formula"><span class="hljs-formula">${RUN_ARGS:=''} COMMAND="/usr/bin/docker run --read-only --rm </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">$</span></span>RUN_ARGS <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-v /tmp:/tmp <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-v /var/tmp:/var/tmp <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-p {{ unicorn_port }}:{{ unicorn_port }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e AWS_REGION={{ aws_region }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e SECRET_KEY_BASE={{ secret_key_base }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e DATABASE_URL={{ database_url }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e RAILS_ENV={{ rails_env }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e SMTP_USER_NAME={{ smtp_user_name }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e SMTP_PASSWORD={{ smtp_password }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e SMTP_ADDRESS={{ smtp_address }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e SMTP_PORT={{ smtp_port }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e SMTP_AUTHENTICATION={{ smtp_authentication }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e DOCKER_IP={{ docker_ip }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e STATSD_PORT={{ statsd_port }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e DOCKER_HUB_USERNAME={{ docker_hub_username }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e DOCKER_HUB_PASSWORD={{ docker_hub_password }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e DOCKER_HUB_EMAIL={{ docker_hub_email }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e DOCKER_EXERCISE_PREFIX={{ docker_exercise_prefix }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e FACEBOOK_CLIENT_ID={{ facebook_client_id }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e FACEBOOK_CLIENT_SECRET={{ facebook_client_secret }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e HEXLET_IDE_VERSION={{ hexlet_ide_image_tag }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e CDN_HOST={{ cdn_host }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e REFILE_CACHE_DIR={{ refile_cache_dir }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e CONTAINER_SERVER={{ container_server }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e CONTAINER_PORT={{ container_port }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-e DOCKER_API_VERSION={{ docker_api_version }} <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>hexlet/hexlet-{{ rails_env }}:<span class="hljs-formula"><span class="hljs-formula">$HEXLET_VERSION $</span></span>@" eval <span class="hljs-formula"><span class="hljs-formula">$COMMAND</span></span></code> </pre><br></div></div><br><br>  There is one subtle point.  Unfortunately, the history of teams is lost.  To restore performance, you need to prokidyvat relevant files, but, frankly, we did not do it. <br><br>  By the way, one more advantage of the docker is visible here: all external dependencies are indicated clearly and in one place.  If you are not familiar with this approach to configuration, I recommend referring to <a href="http://12factor.net/config">this document</a> from the company heroku. <br><br><h2>  DECORIZATION </h2><br><h4>  Dockerfile </h4><br><br><div class="spoiler">  <b class="spoiler_title">Dockerfile</b> <div class="spoiler_text"><pre> FROM ruby: 2.2.1
 
 RUN mkdir -p / usr / src / app
 WORKDIR / usr / src / app
 
 ENV RAILS_ENV production
 ENV REFILE_CACHE_DIR / var / tmp / uploads
 
 RUN curl -sL https://deb.nodesource.com/setup |  bash -
 
 RUN apt-get update -qq \
   &amp;&amp; apt-get install -yqq apt-transport-https libxslt-dev libxml2-dev imagejs nodejs
 
 RUN echo deb https://get.docker.com/ubuntu docker main&gt; /etc/apt/sources.list.d/docker.list \
   &amp;&amp; apt-key adv --keyserver hkp: //keyserver.ubuntu.com: 80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9 \
   &amp;&amp; apt-get update -qq \
   &amp;&amp; apt-get install -qqy lxc-docker-1.5.0
 
 # bundle config build.rugged - use-system-libraries
 # bundle config build.nokogiri - use-system-libraries
 
 COPY Gemfile / usr / src / app /
 COPY Gemfile.lock / usr / src / app /
 COPY package.json / usr / src / app /
 
 # without development test
 RUN npm install
 RUN bundle install --without development test
 
 COPY.  / usr / src / app
 RUN ./node_modules/gulp/bin/gulp.js webpack_production
 RUN bin / rake assets: precompile
 
 VOLUME / usr / src / app / tmp
 VOLUME / var / folders
</pre><br></div></div><br><br>  In the first line you can see that we don‚Äôt need to be steamed about installing ruby, we simply indicate the version we want to use (and for which there is an image, of course). <br><br>  The containers are started with the - read-only flag, which allows you to control the write to disk.  Practice shows that trying to write everything, in completely unexpected places.  Below you can see that we have created volume / var / folders, there it writes ruby ‚Äã‚Äãwhen creating a temporary directory.  But we wrap some sections outside, for example / var / tmp, to fumble data between different versions.  This is optional, but simply saves us resources. <br><br>  Also inside we put the docker in order to manage the docker from the docker.  It is necessary, just, for managing images with practice. <br><br>  Further, literally in four lines, we describe everything that capistrano does as a tool for building an application. <br><br><h4>  Image hosting </h4><br>  You can raise your own docker distribution (ex-registry), but we are quite satisfied with the docker hub, for which we pay $ 7 a month and get 5 private repositories.  He, of course, is far from perfect, and in terms of usability and capabilities.  And sometimes the assembly of images instead of 20 minutes is delayed for an hour.  In general, you can live, although there are alternative cloud solutions. <br><br><h2>  Build and Depla </h2><br>  The way the application is built varies depending on the deployment environment. <br><br>  At staging, we use an automated build, which is collected as soon as it sees changes in the staging branch. <br><br><img src="https://habrastorage.org/files/7c0/9f9/c28/7c09f9c28f0046c3a30bf09903d4f0c5.png"><br><br>  As soon as the image is assembled, the docker hub via the webhook notifies <a href="https://zapier.com/">zapier</a> , which, in turn, sends the information to Slack.  Unfortunately, docker hub does not know how to work directly with Slack (and the developers do not plan to support it). <br><br>  Deploying is done by the command: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">ansible-playbook</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">deploy</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.yml</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-i</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">staging</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ini</span></span></code> </pre><br><br>  Here is how we see it in slack: <br><br><img src="https://habrastorage.org/files/e74/d59/e04/e74d59e049ec4f53af58eb6c2ceeebd7.png"><br><br>  Unlike styling, the production image is not automatically compiled.  At the time of readiness, it is being built by manual launch on a special build server.  We have this server simultaneously serves as a <a href="http://en.wikipedia.org/wiki/Bastion_host">bastion</a> . <br><br>  Another difference is the active use of tags.  If in staging we always have the latest, then here during assembly we clearly indicate the tag (it is the same version). <br><br>  Build runs like this: <br><br><pre> <code class="hljs matlab">ansible-playbook build.yml -<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> production.ini -e <span class="hljs-string"><span class="hljs-string">'hexlet_image_tag=v100'</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">build.yml</b> <div class="spoiler_text"><pre> - hosts: bastions
   gather_facts: no
 
   vars:
     clone_dir: / var / tmp / hexlet
 
   tasks:
     - git:
         repo: git@github.com: Hexlet / hexlet.git
         dest: '{{clone_dir}}'
         accept_hostkey: yes
         key_file: / home / {{run_user}} /. ssh / deploy_rsa
       become: yes
       become_user: '{{run_user}}'
 
     - shell: 'cd {{clone_dir}} &amp;&amp; docker build -t hexlet / hexlet-production: {{hexlet_image_tag}}.'
       become: yes
       become_user: '{{run_user}}'
 
     - shell: 'docker push hexlet / hexlet-production: {{hexlet_image_tag}}'
       become: yes
       become_user: '{{run_user}}'
</pre><br></div></div><br><br>  Deploy production is performed by the command: <br><br><pre> <code class="hljs matlab">ansible-playbook deploy.yml -<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> production.ini -e <span class="hljs-string"><span class="hljs-string">'hexlet_image_tag=v100'</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">deploy.yml</b> <div class="spoiler_text"><pre> - hosts: localhost
   gather_facts: no
   tasks:
   - local_action:
       module: slack
       domain: hexlet.slack.com
       token: {{slack_token}}
       msg: "deploy started: {{rails_env}}: {{hexlet_image_tag}}"
       channel: "#operation"
       username: "{{ansible_ssh_user}}"
 
 - hosts: appservers
   gather_facts: no
   tasks:
     - shell: docker pull hexlet / hexlet - {{rails_env}}: {{hexlet_image_tag}}
       become: yes
       become_user: '{{run_user}}'
 
     - name: update hexlet version
       become: yes
       lineinfile:
         regexp: "HEXLET_VERSION"
         line: "HEXLET_VERSION = {{hexlet_image_tag}}"
         dest: / etc / environment
         backup: yes
         state: present
 
 - hosts: jobservers
   gather_facts: no
   tasks:
     - become: yes
       become_user: '{{run_user}}'
       run_once: yes
       delegate_to: '{{migration_server}}'
       shell:&gt;
         docker run --rm
         -e 'SECRET_KEY_BASE = {{secret_key_base}}'
         -e 'DATABASE_URL = {{database_url}}'
         -e 'RAILS_ENV = {{rails_env}}'
         hexlet / hexlet - {{rails_env}}: {{hexlet_image_tag}}
         rake db: migrate

 - hosts: webservers
   gather_facts: no
   tasks:
     - service: name = nginx state = running
       become: yes
       tags: nginx
 
     - service: name = unicorn state = restarted
       become: yes
       tags: [unicorn, app]
 
 - hosts: jobservers
   gather_facts: no
   tasks:
     - service: name = activejob state = restarted
       become: yes
       tags: [activejob, app]
 
 - hosts: localhost
   gather_facts: no
   tasks:
 
   - name: "Send deploy to honeybadger"
     local_action: shell cd .. &amp;&amp; bundle exec honeybadger deploy --environment = {{rails_env}}
 
   - local_action:
       module: slack
       domain: hexlet.slack.com
       token: {{slack_token}}
       msg: "deploy completed ({{rails_env}})"
       channel: "#operation"
       username: "{{ansible_ssh_user}}"
       # link_names: 0
       # parse: 'none'
</pre><br></div></div><br><br>  In general, the deployment itself is loading the necessary images on the servers, performing migrations and restarting services.  Suddenly, it turned out that the entire capistran was replaced by a dozen lines of straight-line code.  But at the same time a dozen gems of integration with the capistrana, suddenly, turned out to be simply not needed.  The tasks that they performed, most often, turn into one task for ansible. <br><br><h2>  Development </h2><br>  The first thing you have to give up when working with a docker is to develop it on Mac OS.  For normal operation, you need a Vagrant.  To customize the environment we have written a special playbook vagrant.yml.  For example, in it we install and configure the base, although in production we use RDS. <br><br>  Unfortunately (and perhaps fortunately) we never managed to set up a normal workflow of development through docker.  Too many compromises and difficulties.  At the same time, services like postgresql, redis and the like, we still run through it, even during development.  And all this stuff continues to be managed through upstart. <br><br><h2>  Monitoring </h2><br>  From interesting things we put google cadvisor, which, in turn, sent the collected data to influxdb.  Periodically, cadvisor began to eat some kind of wild memory and had to restart it with his hands.  And then it turned out that the influxdb is good, but the alert on top of it simply does not exist.  All this led to the fact that we abandoned any samopal.  Now we have a datadog with corresponding plugins connected, and we are very pleased. <br><br><h2>  Problems </h2><br>  After moving to the docker, I immediately had to abandon the quick fixes.  Building the image can take up to 1 hour.  And it pushes you to a more correct flow, to the possibility of quickly and painlessly rolling back to the previous version. <br><br>  Sometimes we stumble upon bugs in the docker itself (more often than we would like), for example, right now we cannot switch to 1.6.2 from 1.5 because they still have several unclosed tickets with problems that many people stumble upon. <br><br><h2>  Total </h2><br>  The changing state of the server when deploying software is the pain point of any configuration system.  Docker takes over most of this work, which allows servers to be in a very clean state for a long time, and we don‚Äôt have to worry about transition periods.  Changing the version of the same Ruby was not only a simple task, but also completely independent of the administrator.  And the unification of launch, deployment, deployment, assembly and operation allows us to spend much less time on system maintenance.  Yes, aws helps us of course, but this does not negate the advantages of docker / ansible ease of use. <br><br><h2>  Plans </h2><br>  The next step we want to introduce continuous delivery and completely abandon the staging.  The idea is that the rollout will first be carried out on the production server available only from inside the company. <br><br>  PS <br>  Well, for those who are not familiar with the ansible, yesterday we <a href="https://ru.hexlet.io/courses/ansible%3Futm_source%3Dhabrahabr.ru%26utm_medium%3Dreferral">released a basic course</a> . </div><p>Source: <a href="https://habr.com/ru/post/258815/">https://habr.com/ru/post/258815/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258803/index.html">Through hardship to the stars. How we stuffed bumps</a></li>
<li><a href="../258805/index.html">We write logging system in InterSystems Cach√©</a></li>
<li><a href="../258807/index.html">The path of the analyst. Practical guide IT-specialist</a></li>
<li><a href="../258809/index.html">Hello, SaaS | Remote work 2</a></li>
<li><a href="../258811/index.html">New experimental C ++ operators</a></li>
<li><a href="../258817/index.html">Simulation of aircraft flap fault scenarios using Wolfram SystemModeler</a></li>
<li><a href="../258819/index.html">Fungi hunting is a suspicious hobby</a></li>
<li><a href="../258823/index.html">How Yandex built a data center from scratch</a></li>
<li><a href="../258825/index.html">Œª-calculus and LISP</a></li>
<li><a href="../258827/index.html">Moving KodiCMS from the Kohana Framework to Laravel 5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>