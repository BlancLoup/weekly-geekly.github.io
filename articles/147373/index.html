<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Three Ages of the Singleton Pattern</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Singleton pattern appeared, perhaps, as soon as static objects appeared. In Smalltalk-80, ChangeSet was made this way, and slightly in various lib...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Three Ages of the Singleton Pattern</h1><div class="post__text post__text-html js-mediator-article">  The Singleton pattern appeared, perhaps, as soon as static objects appeared.  In Smalltalk-80, ChangeSet was made this way, and slightly in various libraries, sessions, statuses and similar objects began to appear, which were united by one thing - they were supposed to be the only ones for the entire program. <br><br>  In 1994, the well-known book ‚ÄúDesign Patterns‚Äù was published, introducing to the public, among 22 others, and our hero, who is now called Singleton.  There was also its implementation in C ++, like this: <br><a name="habracut"></a><br><br><pre><code class="hljs pgsql">//.h <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Singleton { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: static Singleton* Instance(); protected: Singleton(); private: static Singleton* _instance; } //.cpp Singleton* Singleton::_instance = <span class="hljs-number"><span class="hljs-number">0</span></span>; Singleton* Singleton::Instance() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_instance == <span class="hljs-number"><span class="hljs-number">0</span></span>){ _instance = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Singleton; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _instance; }</code> </pre> <br>  As for streams, the authors do not even write about them, considering this problem to be of minor relevance.  But a lot of attention was paid to all the subtleties of inheriting such classes from each other. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      No wonder - the year was 1995 and multitasking operating systems were too slow to embarrass anyone. <br><br>  In any case, this code does not age.  <b>Use such an implementation always if the class you want to declare will not be called from several threads.</b> <br><br>  In 1995, Scott Myers released his second book on C ++ Tricks.  Among other things, he urges it to use Singleton instead of static classes - to save memory and know exactly when its constructor will be executed. <br><br>  It was in this book that the canonical Myers singleton appeared and I see no reason not to bring it here: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> singleton* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> singleton inst; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;inst; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: singleton() {} };</code> </pre> <br><br>  Neatly, succinctly and skillfully beat the standard language.  A local static variable in a function will be called if and only if the function itself is called. <br><br>  Then it was expanded, banning slightly more operations: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CMySingleton</span></span> { public: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CMySingleton</span></span>&amp; Instance() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CMySingleton</span></span> singleton; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singleton; } <span class="hljs-comment"><span class="hljs-comment">// Other non-static member functions private: CMySingleton() {} // Private constructor ~CMySingleton() {} CMySingleton(const CMySingleton&amp;); // Prevent copy-construction CMySingleton&amp; operator=(const CMySingleton&amp;); // Prevent assignment };</span></span></code> </pre><br>  According to the new C ++ 11 standard, nothing more is needed to support threads.  But all compilers need to live to its full support. <br><br>  In the meantime, for at least a decade and a half, the best minds have tried to catch a multi-threaded singleton into a cell of language syntax.  C ++ did not support threads without third-party libraries - so very soon almost every single library with threads had its own Singleton, which was ‚Äúbetter than everyone else.‚Äù  Alexandrescu devotes a whole chapter to them, domestic developers struggle with him not for life, but for death, and someone Andrei Nasonov has been experimenting for a long time and as a result offers ... a completely different solution. <br><br>  In 2004, Meyers and Alexandrescu joined forces and described Singleton with Double-check locking.  The idea is simple - if the singleton is not found in the first if-e, we do the lock, and already inside we check it again. <br><br>  In the meantime, the court case, the problem of stream-safe Singleton has crept into other C-like languages.  First, in Java, and then in C #.  And now John Skeat offers a whole range of solutions, each of which has its advantages and disadvantages.  And they are offered by Microsoft. <br><br>  To begin with - the same option with double-check locking.  Microsoft advises to write it like this: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Singleton</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Singleton instance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncRoot = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Singleton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Singleton Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instance == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (syncRoot) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instance == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Singleton(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } } }</code> </pre> <br><br>  Skit, however, believes that this code is bad.  Why? <br><br>  - It does not work in Java.  The Java memory model prior to version 1.5 did not check whether the execution of the constructor completed before assigning a value.  Fortunately, this is no longer relevant - Java 1.7 has long been released, and Microsoft recommends this code and guarantees that it will work. <br>  - It is easy to break.  You get confused in brackets - that's all. <br>  - Because of the lock, it is slow enough <br>  - there are better <br><br>  There were options without the use of streaming interfaces. <br><br>  In particular, the well-known implementation through the readonly field.  According to Skit (and Microsoft), this is the first noteworthy option: Here‚Äôs what it looks like: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> sealed <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Singleton { private static readonly Singleton instance = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Singleton(); // Explicit static constructor <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> tell C# compiler // <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> mark <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> beforefieldinit static Singleton() { } private Singleton() { } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static Singleton Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } } }</code> </pre><br><br><br>  This option is also thread-safe and based on the curious property of the readonly fields - they are initialized not immediately, but on the first call.  Great idea, and the author himself recommends using it. <br><br>  Does this implementation have flaws?  Of course, yes: <br><br>  - If the class has static methods, then when they are called readonly, the field is initialized automatically. <br>  - A constructor can only be static.  This is a feature of the compiler - if the constructor is not static, then the type will be marked as beforefieldinit and readonly created simultaneously with the static ones. <br>  - Static constructors of several connected Singleton-s can randomly loop over each other, and then nothing will help and no one will save. <br><br>  Finally, the famous lazy implementation with a nested class. <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Singleton</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Singleton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Singleton Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nested.instance; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Nested</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Explicit static constructor to tell C# compiler // not to mark type as beforefieldinit static Nested() { } internal static readonly Singleton instance = new Singleton(); } }</span></span></code> </pre> <br><br>  It has the same drawbacks as any other code that uses nested classes. <br><br>  In the latest versions of C #, the System.Lazy class has appeared, which all this has been encapsulated.  So, the implementation has become even shorter: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Singleton</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Lazy&lt;Singleton&gt; lazy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lazy&lt;Singleton&gt;(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Singleton()); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Singleton Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lazy.Value; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Singleton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre> <br><br>  It is easy to see that both readonly implementations, the nested class variant, and its simplification in the form of a lazy object do not work with threads.  Instead, they use the very structures of the language that ‚Äúdeceive‚Äù the interpreter.  This is their most important difference from double-lock, which works with threads. <br><br>  Why is it wrong to "deceive" the language?  Because each such "hack" is very easy to accidentally break.  And because there is no benefit from it to people who write in other languages ‚Äã‚Äã- and yet the pattern implies universality. <br><br>  Personally, I think that the problem of flows should be solved by standard means.  C # has many classes built in and whole keywords to work with multithreading.  Why not use standard tools instead of trying to trick the compiler. <br><br>  As I said, lock is not the best solution.  The fact is that the compiler expands such a lock (obj): <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// other code }</span></span></code> </pre> <br><br>  about this code: <br><br><pre> <code class="hljs kotlin"><span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> lockTaken = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Monitor.Enter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ref lockTaken); <span class="hljs-comment"><span class="hljs-comment">// other code } finally { if(lockTaken) Monitor.Exit(this); }</span></span></code> </pre> <br><br>  Jeffrey Richter considers this code very unfortunate.  First, try is very slow.  Secondly, if try crashed, then something is wrong in the code.  And when the second thread starts to execute it, the error is likely to recur.  Therefore, he calls for using Monitor.Enter / Monitor.Exit for regular streams, and Singleton to rewrite atomic operations.  Like this: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Singleton</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Object s_lock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Singleton instance = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Singleton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Singleton Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(instance != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; Monitor.Enter(s_lock); Singleton temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Singleton(); Interlocked.Exchange(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> instance, temp); Monitor.Exit(s_lock); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } } }</code> </pre> <br><br>  A temporary variable is needed because the C # standard requires the compiler to first create a variable and then assign it.  As a result, it may turn out that in the instance is no longer null, but the initialization of singleton has not yet been completed.  See a description of similar cases in Chapter 29 of the CLR via C # Jeffrey Richter, section <i>The Famous Double-Check Locking Technique</i> . <br><br>  Thus, there was a place and double-lock <br><br>  <b>Use this option for multithreaded cases</b> .  It is simple, does not do anything poorly documented, it is difficult to break it and it is easily transferred to any language where there are atomic operations. </div><p>Source: <a href="https://habr.com/ru/post/147373/">https://habr.com/ru/post/147373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../147369/index.html">picotux is the smallest Linux computer in the world.</a></li>
<li><a href="../14737/index.html">Pros and cons of proprietary and open source software according to corporate clients</a></li>
<li><a href="../147370/index.html">Create a virtual machine template with SharePoint in Windows Azure</a></li>
<li><a href="../147371/index.html">Making an oracle deploy script independent of the environment</a></li>
<li><a href="../147372/index.html">Save resources when using virtual machines in Windows Azure</a></li>
<li><a href="../147374/index.html">Notepad ++. Cyrillic characters mistakenly in the code - a solution</a></li>
<li><a href="../147375/index.html">My Google Map Switches</a></li>
<li><a href="../147376/index.html">What I do not like Habr</a></li>
<li><a href="../147377/index.html">About hiring programmers and other engineers</a></li>
<li><a href="../147378/index.html">The status of SAMBA 4 at the moment</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>