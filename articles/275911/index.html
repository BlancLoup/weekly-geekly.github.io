<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Swift dictionary implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Swift dictionary is a container that stores multiple values ‚Äã‚Äãof the same type. Each value is associated with a unique key that acts as an identifier ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Swift dictionary implementation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/34b/d41/8fd/34bd418fda252189e7daabd1b5aa3113.png" alt="image"><br><br>  <i>Swift dictionary is a container that stores multiple values ‚Äã‚Äãof the same type.</i>  <i>Each value is associated with a unique key that acts as an identifier for this value within the dictionary.</i>  <i>Unlike elements in an array, elements in the dictionary do not have a specific order.</i>  <i>Use a dictionary when you need to search for values ‚Äã‚Äãbased on their identifier, just like in the real world a dictionary is used to look up the definition of a specific word.</i>  <i>(note)</i> <br><br>  <b>Swift dictionary:</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Swift dictionary consists of two general types: keys (must belong to the category Hashable) and values; </li><li>  You can create entries by entering a key and its value; </li><li>  The value can be set via a link to the key entered earlier; </li><li>  You can delete an entry by specifying the corresponding key; </li><li>  Each key is associated with one single value. </li></ul><br>  There are several ways to store data records (keys, values), one of which involves open addressing by means of linear probing required to run the Swift dictionary. <br><br>  Consider an example of a dictionary designed for 8 elements: it provides a maximum of 7 entries (keys, values) and at least one empty space (the so-called space) in the dictionary buffer, thanks to which a sort of blocking of the search by selections / inserts (retrivals / insertions). <br><a name="habracut"></a><br>  In memory, it will look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/807/75b/6f3/80775b6f383343dddf283ff211835b0c.png" alt="image"><br><br>  Permanent memory is given by: <br><br> <code>size = capacity * (sizeof(Bitmap) + sizeof(Keys) + sizeof(Values))</code> <br> <br>  If we systematize the data logically, we get something like: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7be/c07/39c/7bec0739cbf9f137ae03026733517c96.png" alt="image"><br><br>  Each column forms a memory segment in which three parameters are fixed: bitmap value, key and value. <br><br>  The bitmap value in the segment indicates whether the key and the corresponding value are valid and determined.  If the data is invalid / uninitialized, the segment is called a space. <br><br> <code>_HashedContainerStorageHeader (struct)</code> <br> <img src="https://habrastorage.org/getpro/habr/post_images/9b6/ef5/efd/9b6ef5efd6cf7a22f75d8ce6f8893145.png" alt="image"><br><br>  This structure acts as a header for the future memory buffer.  It contains the capacity and information about the volume, where the capacity is the actual capacity of the allocated memory, and the information about the volume is the number of actual elements currently in the buffer. <br><br>  <code>maxLoadFactorInverse</code> is a coefficient that allows the buffer to be expanded if necessary. <br><br><h4> <code>_NativeDictionaryStorageImpl&lt;Key, Value&gt; (class)</code> </h4> <br>  Subclass of <code>ManagedBuffer&lt;_HashedContainerStorageHeader, UInt8&gt;</code> <br><br>  The main task of this class is to allocate memory that is optimal for the dictionary and create pointers to bitmap, keys and values, which will then need to be processed.  For example: <br><br><pre> <code class="objectivec hljs">internal var _values: UnsafeMutablePointer&lt;Value&gt; { @warn_unused_result get { let start = <span class="hljs-built_in"><span class="hljs-built_in">UInt</span></span>(Builtin.ptrtoint_Word(_keys._rawValue)) &amp;+ <span class="hljs-built_in"><span class="hljs-built_in">UInt</span></span>(_capacity) &amp;* <span class="hljs-built_in"><span class="hljs-built_in">UInt</span></span>(strideof(Key.self)) let alignment = <span class="hljs-built_in"><span class="hljs-built_in">UInt</span></span>(alignof(Value)) let alignMask = alignment &amp;- <span class="hljs-built_in"><span class="hljs-built_in">UInt</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UnsafeMutablePointer&lt;Value&gt;( bitPattern:(start &amp;+ alignMask) &amp; ~alignMask) } }</code> </pre><br>  Since the memory Bitmap, keys and values ‚Äã‚Äãare adjacent, the values ‚Äã‚Äãfor pointers will be: <br><br><pre> <code class="hljs sql">internal class func <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">capacity</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) -&gt; StorageImpl { let requiredCapacity = bytesForBitMap(<span class="hljs-keyword"><span class="hljs-keyword">capacity</span></span>) + bytesForKeys(<span class="hljs-keyword"><span class="hljs-keyword">capacity</span></span>) + bytesForValues(<span class="hljs-keyword"><span class="hljs-keyword">capacity</span></span>) let r = super.create(requiredCapacity) { _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _HashedContainerStorageHeader(<span class="hljs-keyword"><span class="hljs-keyword">capacity</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">capacity</span></span>) } let <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> = r <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! StorageImpl let initializedEntries = _BitMap( <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>: storage._initializedHashtableEntriesBitMapStorage, bitCount: <span class="hljs-keyword"><span class="hljs-keyword">capacity</span></span>) initializedEntries.initializeToZero() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> }</code> </pre><br>  In the process of creating a buffer, all entries in bitmap are equated to zero, that is, all memory segments, in fact, are spaces.  It is also worth noting that for such a method of storing information, the general key type of this class does not necessarily have to be Hashable. <br><br> <code>// : ,    ,  <br> // (: Hashable) -     <br> //  ,   Hashable.</code> <br> <br><img src="https://habrastorage.org/getpro/habr/post_images/137/e87/bca/137e87bcaac77cd2986babe759b09584.png" alt="image"><br><br><h4> <code>_NativeDictionaryStorage&lt;Key : Hashable, Value&gt; ()</code> </h4> <br>  This structure captures the stored information in the buffer and selects a function that converts the adjacent allocated memory into an array of a logical segment.  Also note that the end of the segment array is associated with the beginning of the array, thereby forming a logical ring.  And that means if you are at the end of the segment array and are requesting the next function, in the end, you will be redirected to the beginning of the array. <br><br>  In order to insert or set a value using a key, it is necessary to find out which segment this key belongs to.  Since the key is Hashable, the hashValue function is suitable, the result of which is Int.  True, the specified hashValue may exceed the capacity of the dictionary buffer, and therefore, you may have to shrink it from zero to the maximum value of the capacity: <br><br><pre> <code class="objectivec hljs">@warn_unused_result internal func _bucket(k: Key) -&gt; Int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _squeezeHashValue(k.hashValue, <span class="hljs-number"><span class="hljs-number">0.</span></span>.&lt;capacity) }</code> </pre><br>  We can move between segments by accessing the <code>_next</code> and <code>_prev</code> .  <b>Capacity is always a number that can be expressed in binary.</b>  If we are at the end of the segment array, if desired, the rollback to the initial position is specified via the <code>_next</code> call. <br><br><pre> <code class="objectivec hljs">internal var _bucketMask: Int { <span class="hljs-comment"><span class="hljs-comment">// The capacity is not negative, therefore subtracting 1 will not overflow. return capacity &amp;- 1 } @warn_unused_result internal func _next(bucket: Int) -&gt; Int { // Bucket is within 0 and capacity. Therefore adding 1 does not overflow. return (bucket &amp;+ 1) &amp; _bucketMask } @warn_unused_result internal func _prev(bucket: Int) -&gt; Int { // Bucket is not negative. Therefore subtracting 1 does not overflow. return (bucket &amp;- 1) &amp; _bucketMask }</span></span></code> </pre><br>  To add a new item, we need to find out which segment it belongs to and then call a function that inserts the corresponding key and value into the selected segment, as well as setting the actual parameters for writing bitmap. <br><br><pre> <code class="objectivec hljs">@_transparent internal func initializeKey(k: Key, value v: Value, at i: Int) { _sanityCheck(!isInitializedEntry(i)) (keys + i).initialize(k) (values + i).initialize(v) initializedEntries[i] = <span class="hljs-literal"><span class="hljs-literal">true</span></span> _fixLifetime(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) }</code> </pre><br><br><h4>  <code>_find</code> function </h4><br><ul><li>  The _find function allows you to find out which segment will be involved when working with a key (insert or selection); </li><li>  Queries the source segment for the key to call <code>_bucket(key)</code> ; </li><li>  If the key in the parameter matches the segment key, returns to the initial position of the object; </li><li>  If the object is not found, the location of the first space is determined by the possible area for inserting the key; </li><li>  Bitmap allows you to check segments, separating the filled areas from the gaps; </li><li>  This is <a href="https://en.wikipedia.org/wiki/Linear_probing">linear probing</a> ; </li></ul><br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">///        . /// ///   ,      /// . @warn_unused_result internal func _find(key: Key, _ startBucket: Int) -&gt; (pos: Index, found: Bool) { var bucket = startBucket // The invariant guarantees there's always a hole, so we just loop // until we find one while true { let isHole = !isInitializedEntry(bucket) if isHole { return (Index(nativeStorage: self, offset: bucket), false) } if keyAt(bucket) == key { return (Index(nativeStorage: self, offset: bucket), true) } bucket = _next(bucket) } }</span></span></code> </pre><br><ul><li>  In fact, squeezeHashValue is an indicator that the key is present in the array of a segment, but collisions are possible.  For example, two keys may have the same hash value; </li><li>  In this case, select the function that will reveal the closest segment to insert the key. </li></ul><br><br><h4>  That is why, when analyzing the values ‚Äã‚Äãof the hash, Hashable acts as an almost ideal function that guarantees high performance. </h4><br><ul><li>  squeezeHashValue is really trying to create a great hash with several options; </li><li>  It seems that in order for the program to save different values ‚Äã‚Äãof the hash, the launch kernel was tied to the hashValue specified in the key type.  True, we are talking about the constant value of the placeholder; </li><li>  <code>_BitMap</code> struct is used as a wrapper that allows reading and writing to bitmap. </li></ul><br>  Visually we get, approximately, the following: <br><br><img src="http://i.imgur.com/2pT2qXZ.png" alt="image"><br><br><h4> <code>_NativeDictionaryStorageOwner (class)</code> </h4> <br>  This class is designed to track the correct counting of footnotes for copies made during the recording process.  Since the data is saved using the Dictionary and DictionaryIndex options, the link count will assign the entered information to 2, but if the dictionary belongs to the above class and the number of links for it is monitored, you have nothing to worry about. <br><br>  <i>/// This class is the launch ID COW.</i>  <i>is he</i> <i><br></i>  <i>/// is needed solely to separate unique reference counters for:</i> <i><br></i>  <i>/// - `Dictionary` and` NSDictionary`,</i> <i><br></i>  <i>/// - `DictionaryIndex`.</i> <i><br></i>  <i>///</i> <i><br></i>  <i>/// This is important because the uniqueness check for COW is carried out exclusively</i> <i><br></i>  <i>/// to identify the counters of the first type.</i> <i><br></i> <br>  So it does not look very nice: <br><br><img src="http://i.imgur.com/h6TW7Aj.png" alt="image"><br><br><h4> <code>_VariantDictionaryStorage&lt;Key : Hashable, Value&gt; ( )</code> </h4> <br>  This enumerated type works with two Native / Cocoa statements depending on the data stored in them. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Native(_NativeDictionaryStorageOwner&lt;Key, Value&gt;) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Cocoa(_CocoaDictionaryStorage)</code> </pre><br>  Main characteristics: <br><br><ul><li>  An enumerated type, based on Native or Cocoa, specifies adjustment functions in the process of storing information in the dictionary for operations such as insert, select, delete, and so on; </li><li>  Expands the amount of memory for storing data as it is filled; </li><li>  Updates or sets a key-value binding. </li><li>  If it is necessary to remove a Value from a segment array, a space may appear that will cause side effects during the probing process, leading to its premature interruption.  To prevent such negative phenomena, it is important to take into account the positions of all elements of the dictionary. </li></ul><br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/// -  idealBucket:  ,    . /// -  offset:  ,   . ///    . internal mutating func nativeDeleteImpl( nativeStorage: NativeStorage, idealBucket: Int, offset: Int ) { _sanityCheck( nativeStorage.isInitializedEntry(offset), "expected initialized entry") //   nativeStorage.destroyEntryAt(offset) nativeStorage.count -= 1 //       , //         . var hole = offset //      var start = idealBucket while nativeStorage.isInitializedEntry(nativeStorage._prev(start)) { start = nativeStorage._prev(start) } //      var lastInChain = hole var b = nativeStorage._next(lastInChain) while nativeStorage.isInitializedEntry(b) { lastInChain = b b = nativeStorage._next(b) } //  ,      ,     , //        . while hole != lastInChain { //     ,        // ,     . var b = lastInChain while b != hole { let idealBucket = nativeStorage._bucket(nativeStorage.keyAt(b)) //      ?   //         [, ] //    let c0 = idealBucket &gt;= start let c1 = idealBucket &lt;= hole if start &lt;= hole ? (c0 &amp;&amp; c1) : (c0 || c1) { break // Found it } b = nativeStorage._prev(b) } if b == hole { // No out-of-place elements found; we're done adjusting break } //       nativeStorage.moveInitializeFrom(nativeStorage, at: b, toEntryAt: hole) hole = b } }</span></span></code> </pre><br><br><img src="http://i.imgur.com/6rwgJ0T.png" alt="image"><br><br><h4>  And this is what our dictionary looks like. </h4><br>  (just one type of listed data) <br><img src="http://i.imgur.com/8busLKc.png" alt="image"></div><p>Source: <a href="https://habr.com/ru/post/275911/">https://habr.com/ru/post/275911/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275899/index.html">ABAP: Handsome # 2</a></li>
<li><a href="../275901/index.html">Advanced Oracle Troubleshoot Session - PGA / UGA Memory Fragmentation</a></li>
<li><a href="../275905/index.html">How Stripe turned into PayPal Mobile Era</a></li>
<li><a href="../275907/index.html">Project Updates Hosting Cafe</a></li>
<li><a href="../275909/index.html">Ten Popular SEO Myths About Google Promotion</a></li>
<li><a href="../275913/index.html">Patties in distribution semantics</a></li>
<li><a href="../275915/index.html">Cisco Nexus at the core of the corporate network</a></li>
<li><a href="../275917/index.html">Amnesia FreeBSD</a></li>
<li><a href="../275919/index.html">Color in design</a></li>
<li><a href="../275921/index.html">Data centers without people as a new trend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>