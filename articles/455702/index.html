<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Effective number generation in a given interval</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the overwhelming majority of my posts about random number generation, we mainly considered the properties of various generation schemes. This may b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Effective number generation in a given interval</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg" alt="image"></div><br>  In the overwhelming majority of my posts about random number generation, we mainly considered the properties of various generation schemes.  This may be unexpected, but the performance of the randomization algorithm may depend not on the chosen generation scheme, but on other factors.  In this post (which was inspired by the excellent <a href="https://arxiv.org/abs/1805.10941">article by Daniel Lemire</a> ) we explore the main reasons for the decline in performance of generating random numbers, which often outweigh the performance of the PRGS engine. <br><br>  Imagine this situation: <br><br>  As a homework assignment, Juan and Sasha implement the same randomized algorithm in C ++, which will be executed on the same university computer and with one data set.  Their code is almost identical and differs only in generating random numbers.  Juan is in a hurry to do his music lessons, so he simply chose the whirlwind of Mersenne.  Sasha, on the other hand, spent several extra hours on research.  Sasha conducted benchmarks of several of the fastest GPSNGs, which he recently learned from social networks, and chose the fastest.  At the meeting, Sasha was impatient to boast, and he asked Juan: “What GPSNU did you use?” 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      "Personally, I just took the whirlwind of Mersenne - it is built into the language and seems to work quite well." <br><br>  “Ha!”, Answered Sasha.  “I used <code>jsf32</code> .  It is much faster than the old and slow whirlwind of Mersenne!  My program runs in 3 minutes 15 seconds! ”. <br><br>  “Hmm, not bad, but mine does it in less than a minute,” says Juan and shrugs.  “Well, okay, I have to go to the concert.  Will you go with me?" <br><br>  “No,” Sasha replies.  "I ... uh ... need to look at my code again." <br><br>  This awkward fictional situation is <em>not</em> much fictional;  It is based on real results.  If your randomized algorithm does not run as fast as you would like, and the bottleneck seems to be the generation of random numbers, then, oddly enough, the problem may not be in the random number generator! <br><a name="habracut"></a><br><h3>  Introduction: Random Numbers in Practice </h3><br>  Most modern qualitative random number generators create machine words filled with random bits, that is, they usually generate numbers in the interval [0..2 <sup>32</sup> ) or [0..2 <sup>64</sup> ).  But in many cases of use, users need numbers at a certain interval — for example, to roll a die or select a random playing card, numbers are needed at small regular intervals.  However, many algorithms, from <a href="https://en.wikipedia.org/wiki/Fisher%25E2%2580%2593Yates_shuffle">mixing</a> and <a href="https://en.wikipedia.org/wiki/Reservoir_sampling">reservoir sampling</a> to <a href="https://doi.org/10.1145/274787.274812">randomized binary search trees,</a> require numbers taken from other intervals. <br><br><h3>  Methods </h3><br>  We will look at many different methods.  To simplify the discussion, instead of generating numbers in the interval [ <em>i</em> .. <em>j</em> ) or [ <em>i</em> .. <em>j</em> ], we will generate numbers in the interval [0 .. <em>k</em> ).  Having such a scheme, we can, for example, generate numbers in the interval [ <em>i</em> .. <em>j</em> ), specifying <em>k</em> = <em>j</em> - <em>i</em> , generating a number in the interval [0 .. <em>k</em> ), and then adding to it <em>i</em> . <br><br><h4>  C ++ Embedded </h4><br>  Many languages ​​have built-in tools for getting a random number in a specified interval.  For example, to get a card out of a deck with 52 cards in scripting languages ​​like Perl and Python, we can write <code>int(rand(52))</code> and <code>random.randint(0,52)</code> .  In C ++, we can similarly use <code>uniform_int_distribution</code> . <br><br>  C ++ code for implementing this approach is simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt; dist(<span class="hljs-number"><span class="hljs-number">0</span></span>, range<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dist(rng); }</code> </pre> <br>  Usually, the built-in tools use one of the techniques described below, but most users simply use these tools without thinking about what is happening “under the hood”, considering that these tools are properly designed and quite effective.  In C ++, built-in tools are more complicated, because they must be able to work with rather arbitrary generation engines - the generator producing values ​​in the interval from -3 to 17 can be quite acceptable and be used with <code>std::uniform_int_distribution</code> to create numbers in any interval, for example [0..1000).  That is, the built-in C ++ tools are too overcomplicated for most cases in which they are used. <br><br><h4>  The classical remainder of the division (with skewed) </h4><br>  Let's move from an overcomplicated approach to a too simplified one. <br><br>  When I studied programming, we generated numbers in the interval (for example, to select a card in a 52 card deck) using the division remainder operator.  To get a number in the interval [0..52), we wrote <code>rand() % 52</code> . <br><br>  In C ++, this approach can be implemented as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rng() % range; }</code> </pre> <br>  Despite the simplicity of this approach, it demonstrates the reason that getting numbers in the right interval is usually a slow task — it requires division (to calculate the remainder obtained by the <code>%</code> operator).  The division is usually at least an order of magnitude slower than other arithmetic operations, so a single arithmetic operation takes more time than all the work performed by fast PRNG. <br><br>  But in addition to low speed, he also <em>skewed</em> .  To understand why <code>rand() % 52</code> returns skewed numbers, suppose <code>rand()</code> creates numbers in the interval [0..2 <sup>32</sup> ), and notice that 52 does not divide 2 <sup>32</sup> completely, it divides it 82 595 524 times with the remainder 48. That is, if we use <code>rand() % 52</code> , then we will have 82,595,525 ways to choose the first 48 cards from the deck and only 82,595,524 ways to choose the last four cards.  In other words, there is a bias of 0.00000121% against these last four cards (perhaps they are kings!).  When I was a student and wrote homework about throwing dice or drawing cards, nobody was usually worried about such tiny distortions, but as the interval increases, the distortion increases linearly.  For a 32-bit GPSN, a limited interval less than 2 <sup>24</sup> has a skew less than 0.5%, but above 2 <sup>31 the</sup> skew is 50% - some numbers will return twice as often as others. <br><br>  In this article, we will mainly consider techniques that use strategies to eliminate systematic errors, but probably should be said that for 64-bit PRNGs, the amount of skew in most typical applications will most likely be negligible. <br><br>  Another problem may be that some generators have weak low bits.  For example, the PRGS families Xoroshiro + and Xoshiro + have low-order bits that do not pass statistical tests.  When we execute <code>% 52</code> (because 52 is even), we pass the low bit straight to the output. <br><br><h4>  Multiplication of floating-point numbers (skewed) </h4><br>  Another common technique is the use of GPSNG, which generates floating-point numbers in the interval [0..1) with the subsequent conversion of these numbers to the desired interval.  This approach is used in Perl, it is <a href="">recommended to</a> use <code>int(rand(10))</code> to generate an integer in the interval [0..10) by generating a floating point number, followed by rounding down. <br><br>  In C ++, this approach is written as: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rng_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> zeroone = <span class="hljs-number"><span class="hljs-number">0x1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>p<span class="hljs-number"><span class="hljs-number">-32</span></span> * rng(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range * zeroone; }</code> </pre> <br>  (Note that <code>0x1.0p-32</code> is a binary constant with a floating point for 2 <sup>-32</sup> , which we use to convert a random integer in the interval [0..2 <sup>32</sup> ) to double in the unit interval;  instead, we can perform this conversion using <code>ldexp(rng(), -32)</code> , but when I conducted a benchmark of this approach, it was much slower.) <br><br>  This approach is as skewed as the classic remainder of the division, but the bias is different.  For example, if we chose numbers in the interval [0..52), then the numbers 0, 13, 26, and 39 would occur at one time less than others. <br><br>  This version when generalizing to 64 bits is even more unpleasant, because it requires a floating point type, whose mantissa is at least 64 bits.  On x86 machines with Linux and macOS, we can use <code>long double</code> to use x86 floating-point numbers that have a 64-bit mantissa, but <code>long double</code> not ported universally to all systems — on some systems, <code>long double</code> equivalent to <code>double</code> . <br><br>  There is a good side - this approach works faster than residual solutions for PRNG with weaker low bits. <br><br><h4>  Integer multiplication (skewed) </h4><br>  The multiplication method can be adapted to arithmetic with a fixed rather than a floating point.  In fact, we just constantly multiply by 2 <sup>32</sup> , <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br>  It may seem that 64-bit arithmetic is required for this version, on x86 processors a good compiler compiles this code into a 32-bit <code>mult</code> instruction (which gives us two 32-bit output values, one of which is the return value).  It can be expected that this version will be fast, but it is skewed just like the method of multiplying floating-point numbers. <br><br><h4>  Division with drop (without skewing) </h4><br>  We can modify the floating point multiplication scheme into a scheme based on the division.  Instead of multiplying <code>x * range / 2**32</code> we calculate <code>x / (2**32 / range)</code> .  Since we work with integer arithmetic, rounding in this version will be done differently, and sometimes generate values ​​outside the desired interval.  If we discard these values ​​(for example, get rid of them and generate new values), then the result will be a method without distortions. <br><br>  For example, in the case of drawing a card using a 32-bit PRNG, we can generate a 32-bit number and divide it by 2 32/52 = 82 595 524 to select a card.  This technique works if the random value from the 32-bit PRNG is less than 52 × 82595524 = 2 32/32 - 48. If the random value from the PRNG is one of the last 48 values ​​of the upper part of the generator interval, then it should be discarded and look for another. <br><br>  In our code for this version, a trick with dividing 2 <sup>32</sup> by <code>range</code> without using 64-bit mathematics is used.  To directly calculate <code>2**32 / range</code> we need to present the number 2 <sup>32</sup> , which is too large (by one!) To be represented as a 32-bit integer.  Instead, we take into account that for unsigned integers, the unary negation operation <code>range</code> calculates a positive value of 2 <sup>32</sup> - <code>range</code> ;  dividing this value by <code>range</code> , we get an answer for a unit less than <code>2**32 / range</code> . <br><br>  Consequently, the C ++ code for generating a number using a drop-down division looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates divisor = 2**32 / range uint32_t divisor = ((-range) / range) + 1; if (divisor == 0) // overflow, it's really 2**32 return 0; for (;;) { uint32_t val = rng() / divisor; if (val &lt; range) return val; } }</span></span></code> </pre> <br>  Of course, such an approach requires two slow operations based on division, which are usually slower than other arithmetic operations, so you should not expect it to be fast. <br><br><h4>  The remainder of the division (double) without warps - method OpenBSD </h4><br>  We can also use the drop approach to eliminate skewing in the classical division residue method.  In the playing cards example, we again need to drop 48 values.  In this version, instead of discarding the <em>last</em> 48 values, we (equivalently) discard the <em>first</em> 48 values. <br><br>  Here is the implementation of this approach in C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br>  This technique eliminates skewing, but it requires two time-consuming division operations with a remainder for each output value (and an internal generator may be required to create several numbers).  Therefore, it is to be expected that the method will be approximately two times slower than the classical approach with a bias. <br><br>  The <a href=""><code> arc4random_uniform</code> OpenBSD <code> arc4random_uniform</code></a> (also used in OS X and iOS) uses this strategy. <br><br><h4>  The remainder of the division (single) without skewing - Java technique </h4><br>  In Java, a different approach is used to generate a number in an interval in which only one division operation with the remainder is used, with the exception of quite rare cases of discarding the result.  Code: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rng_t&amp; rng, uint32_t range)</span></span></span><span class="hljs-function"> </span></span>{ uint32_t x, r; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng(); r = x % range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x - r &gt; (-range)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre> <br>  To understand why this option works, you need to think a little.  Unlike the previous version based on residuals, which eliminates the skew by removing some of the lowest values ​​from the internal generation engine, this version filters the values ​​from the upper part of the engine interval. <br><br><h4>  Integral multiply without skews - Lemir technique </h4><br>  In almost the same way as we have eliminated the bias from the division remainder technique, we can eliminate the bias from the integer multiplication technique.  This technique was invented by Lemir. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><h4>  Bitmask with a drop (without skewing) - Apple technique </h4><br>  In our last approach, division and remainder operations are completely excluded.  Instead, it uses a simple masking operation to obtain a random number in the interval [0..2 <sup><em>k</em></sup> ), where <em>k</em> is the smallest value, such that 2 <sup><em>k is</em></sup> greater than the interval.  If the value is too large for our interval, we discard it and try to get another one.  The code is shown below: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask = ~<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); --range; mask &gt;&gt;= __builtin_clz(range|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng() &amp; mask; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt; range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br>  This approach was adopted by Apple when (in the macOS Sierra release) it performed <a href="">its own</a> <code>arc4random_uniform</code> code <code>arc4random_uniform</code> . <br><br><h3>  Benchmarking basic techniques </h3><br>  Now we have several approaches that can be assessed.  Unfortunately, when we are concerned about the costs of a single division, benchmarking becomes a non-trivial matter.  No benchmark is able to take into account all the factors affecting the scope, and there are no guarantees that the best option for your application will definitely be the best for mine. <br><br>  We use three benchmarks and test techniques with many different PRNGs. <br><br><h4>  Benchmark Large-Shuffle </h4><br>  Probably the most obvious benchmark is mixing.  In this benchmark, we imitate the implementation of large-scale mixing.  To sort an array of size <em>N,</em> we must generate numbers in the intervals [0 .. <em>N</em> ), [0 .. ( <em>N</em> -1)), ..., [0..1).  In this benchmark, we will assume that <em>N</em> is the maximum possible number (for <code>uint32_t</code> this is 2 <sup>32</sup> -1).  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; }</code> </pre> <br>  Notice that we “use” each number by adding it to the <code>sum</code> (so that optimization does not discard it), but do not do any mixing to focus on generating numbers. <br><br>  To test 64-bit generation, we have a similar test, but it would be impractical to perform a test corresponding to the mixing of an array of 2 <sup>64</sup> - 1 size (because it will take many thousands of years to execute this larger benchmark).  Instead, we cross the entire 64-bit interval, but generate the same number of output values ​​as in the 32-bit test.  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bound = (<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(i)&lt;&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>) | i; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bval = bounded_rand(rng, bound ); assert(bval &lt; bound); sum += bval; }</code> </pre> <br><h5>  Mersenne Vortex Results </h5><br>  The results shown below demonstrate the performance of this benchmark for each of the methods we considered using the Mersenn vortex and testing on the 32-bit discussed in the article (using <code>std::mt19937</code> from <code>libstdc++</code> ) and similar 64-bit code (using <code>std:mt19937_64</code> from <code>libstdc++</code> ).  The results are a geometric average of 15 runs with different seed values, which is then normalized so that the classical method of remainder has a unit run time. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/3eb/53f/b9f3eb53f894a14ac2698f44090b23a6.svg"></div><br>  It may seem that we have clear answers about performance - it looks like you can build techniques for their perfection, and ask yourself what the developers of <code>libstdc++</code> thought about when they wrote such a terrible implementation for 32-bit numbers.  But, as is often the case with benchmarking, the situation is more complicated than it seems from these results.  Firstly, there is a risk that the results may be specific for the Mersenn vortex, so we will expand the set of PRNGs tested.  Secondly, there may be a subtle problem with the benchmark itself.  Let's first deal with the first question. <br><br><h5>  Results of various PRNG </h5><br>  We will test 32-bit <code>arc4_rand32</code> using <code>arc4_rand32</code> , <code>chacha8r</code> , <code>gjrand32</code> , <code>jsf32</code> , <code>mt19937</code> , <code>pcg32</code> , <code>pcg32_fast</code> , <code>sfc32</code> , <code>splitmix32</code> , <code>xoroshiro64+</code> , <code>xorshift*64/32</code> <code>xoshiro128+</code> , <code>xoshiro128+</code> and <code>xoshiro128**</code> , and <code>pcg32_fast</code> will be <code>sfc32</code> to the <code>splitmix32</code> <code>xoroshiro64+</code> , <code>xorshift*64/32</code> <code>xoshiro128+</code> , <code>xoshiro128+</code> and <code>xoshiro128**</code> , and we will be using the <code>arc4_rand32</code> <code>xorshift*64/32</code> <code>xoshiro128+</code> , <code>xoshiro128+</code> and <code>xoshiro128**</code> , and we will be using the <code>arc4_rand32</code> <code>xorshift*64/32</code> <code>splitmix32</code> , <code>xoroshiro64+</code> , and <code>xorshift*64/32</code> , <code>xorshift*64/32</code> <code>splitmix32</code> , <code>xoroshiro64+</code> , and <code>xorshift*64/32</code> , <code>xorshift*64/32</code> <code>xoshiro128+</code> , <code>xoshiro128+</code> and <code>xoshiro128**</code> , and we will be using the <code>gjrand64</code> ; <code>jsf64</code> , <code>mcg128</code> , <code>mcg128_fast</code> , <code>mt19937_64</code> , <code>pcg64</code> , <code>pcg64_fast</code> , <code>sfc64</code> , <code>splitmix64</code> , <code>xoroshiro128+</code> , <code>xorshift*128/64</code> <code>xoshiro256+</code> , <code>xoshiro256+</code> and <code>xoshiro256*</code> .  These sets will give us a few slow PRNGs and a large number of very fast ones. <br><br>  Here are the results: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2dc/8c8/f1a/2dc8c8f1af9aa517a92260e7cbd3a73e.svg"></div><br>  We can see key differences from the results with the whirlwind of Mersenne.  Faster PRNG shifts the equilibrium towards the limiting code, and therefore the difference between different approaches becomes more pronounced, especially in the case of 64-bit PRNG.  With a wider set of <code>libstc++</code> implementation of <code>libstc++</code> ceases to seem so terrible. <br><br><h5>  findings </h5><br>  In this benchmark with a significant margin wins in speed approach based on multiply with warp.  There are many situations in which the boundaries will be small relative to the size of the PRNG, and performance is absolutely critical.  In such situations, a slight bias is not likely to have a noticeable effect, but the PRNG speed will have.  One such example is Quicksort with a random reference point.  Of the methods without distortions, the technique of bit masks looks promising. <br><br>  But before making serious conclusions, we need to point out the huge problem of this benchmark - most of the time is spent on very high boundaries, which most likely gives excessive importance to large intervals.  Therefore, we need to go to the second benchmark. <br><br><h4>  Benchmark Small-Shuffle </h4><br>  This benchmark is similar to the previous one, but performs a much smaller “array shuffle” (multiple).  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; } }</code> </pre> <br><h5>  Mersenne Vortex Results </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/d3b/4bd/6c5d3b4bdb5f2e45cd805a051d79ab9a.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Results of various PRNG </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/9ae/8c0/45a9ae8c040cb4d297fe82f00fa06e3c.svg"></div><br><h5>  findings </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This benchmark avoids too much emphasis on large boundaries and more accurately reflects real use cases, but now completely discards large boundaries. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark for all intervals </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This benchmark aims to avoid the drawbacks of the previous two; </font><font style="vertical-align: inherit;">he performs testing at each grade size of two, so that each size is present, but his influence is not overestimated.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bit = <span class="hljs-number"><span class="hljs-number">1</span></span>; bit != <span class="hljs-number"><span class="hljs-number">0</span></span>; bit &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">0x1000000</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bound = bit | (i &amp; (bit - <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, bound); assert(bval &lt; bound); sum += bval; } }</code> </pre> <br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mersenne Vortex Results </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/65c/447/f3465c447f9b19b430bb43533a655c2f.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Results of various PRNG </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/c58/2a2/64bc582a2fde24fd0faedbeaabb9f64c.svg"></div><br><h5>  findings </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many of our findings remain unchanged. </font><font style="vertical-align: inherit;">The skew multiplication method is fast if we can accept the error, and the bitmask scheme seems to be a good average choice. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We could complete this if we didn’t want to go back, take a critical look at our code and make changes to it.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Make improvements </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Up to this point, all methods of eliminating skews required the use of an additional remainder division operation, which is why they are performed much slower than skewed methods. </font><font style="vertical-align: inherit;">It would be helpful if we could reduce this advantage.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faster threshold based drops </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Some of our algorithms have code using a threshold value, for example: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When </font></font><code>range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">small compared with the PRNG output interval, most often the number will be </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">much more than the</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> threshold. </font><font style="vertical-align: inherit;">That is, if we can add a preliminary estimate of the threshold, which may be a little more, then we will save on the costly operation of taking the remainder of the division. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This task is handled by the following code:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> r = rng(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (r &lt; t) r = rng(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r % range; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This change can be applied to the "dual Mod without distortions" (see above), and to the "integer multiplication without distortions". </font><font style="vertical-align: inherit;">The idea came up with Lemir, who applied it to the second method (but not to the first).</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark Results Large-Shuffle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This optimization leads to a significant improvement in the results of the 64-bit benchmark (in which mod is even slower), but in fact slightly degrades performance in the 32-bit benchmark. </font><font style="vertical-align: inherit;">Despite the improvements, the bitmask method still wins.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb4/61d/b52/bb461db52be4a7d983dd7f97844179c0.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark results Small-Shuffle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the other hand, this change significantly speeds up the small-shuffle benchmark for the multiplication method of integers, and for the double remainder of the division. </font><font style="vertical-align: inherit;">In both cases, of the performance shifts closer to the results of the options without distortions. </font><font style="vertical-align: inherit;">The performance of the double remainder method (OpenBSD) is now almost equal to that of the single remainder method (Java).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/2bd/fe2/f072bdfe2660cf0f8789b124a8f02646.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark results for all intervals </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We see a similar improvement in the benchmark for all intervals. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/219/b1d/add/219b1daddfa6a55a2cb485b3ae774016.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It seems that we can declare a new universal winner: an optimized method of multiplying Lemir integers without distortions. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimization of the remainder of the division </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually, the calculation </font></font><code>a % b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requires division, but in situations where the </font></font><code>a &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">result will be simple </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but division is not required. </font><font style="vertical-align: inherit;">And when </font></font><code>a/2 &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the result is just </font></font><code>a - b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Therefore, instead of computing</font></font><br><br><pre> <code class="cpp hljs">a %= b;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we can perform </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) { a -= b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) a %= b; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The cost of division is so significant that increasing the cost of this more complex code can justify itself by saving time due to the absence of division. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark Results Large-Shuffle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adding this optimization significantly improves the large-shuffle benchmark results. </font><font style="vertical-align: inherit;">This is again more noticeable in the 64-bit code, where the operation of taking the remainder is more expensive. </font><font style="vertical-align: inherit;">In the double residue method (in the OpenBSD style), versions with optimization are shown for only one residue operation and for both.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e1a/669/c56e1a669836477e46f870bd1bc7a6c9.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this benchmark, the bitmask is still the winner, but the boundary between it and the approach of Lemir has narrowed considerably. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark results Small-Shuffle </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adding this optimization does not improve the performance of the small-shuffle benchmark, so the question remains whether it adds significant costs. </font><font style="vertical-align: inherit;">In some cases, no, in other costs increase slightly.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/4db/b65/6fa4dbb65b9a3f6c6f9e8ba4f7b455db.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark results for all intervals </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the benchmark for all intervals, the changes are also small. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0e/ae7/758/e0eae77583cc457a9e923540ad954257.svg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bonus: results of the PRNG comparison </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main reason for using a number of PRNG for testing the number schemes in the intervals was to avoid unintentional distortion of the results due to the peculiarities of the operation of certain PRNN schemes. </font><font style="vertical-align: inherit;">But we can use the same internal test results to compare the generation schemes themselves.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG with 32-bit numbers output </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The graph below shows the performance of different 32-bit generation schemes, averaged for all methods and fifteen runs, normalized by the performance of the 32-bit Mersenne vortex: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the one hand, I am glad to see that I’m </font></font><code>pcg32_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">really fast - only a small variant of Xoroshiro (which does not pass statistical tests) won it. </font><font style="vertical-align: inherit;">But it also shows why I rarely get upset about the performance of modern high-performance general-purpose PRNGs — the difference between the different methods is very small. </font><font style="vertical-align: inherit;">In particular, the fastest four schemes differ in performance by less than 5%, and I believe that this is simply caused by "noise".</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG with 64-bit numbers output </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The graph shows the performance of various 64-bit generation schemes, averaged among all the techniques and fifteen runs, normalized by the performance of the 32-bit Mersenn vortex. It may seem strange that normalization is performed on the 32-bit Mersenn vortex, but this allows us to see the additional costs of using 64-bit generation in cases when 32-bit generation is sufficient.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/16c/b24/92816cb249e7f76c4ed4e11c65f67475.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These results confirm that it is </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incredibly fast, but the last four technicians again differ by only about 5%, therefore it is difficult to choose from the fastest methods. </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>pcg64_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must be slower </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">because their basic generators are 128-bit linear congruential generators (LCG, LCG) and 128-bit multiplicative congruential generators (MCG, MCG). Despite the fact that they are not the fastest technicians in this set, </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it is still 20% faster than the 64-bit whirlwind of Mersenne. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But perhaps more importantly, these results also show that if you do not need 64-bit output, then 64-bit PRNG is usually slower than 32-bit.</font></font><br><br><h3>  findings </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From our benchmarks, we can see that the transition from the standardly used PRNGs (for example, the 32-bit Mersenn vortex) to faster PRNGs reduced the execution time of benchmarks by 45%. </font><font style="vertical-align: inherit;">But the transition from the standard method of finding numbers in the interval to our fastest method allowed us to reduce the benchmark time by about 66%; </font><font style="vertical-align: inherit;">in other words, up to one third of the original time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fastest method (without distortions) is the Lemire method (with my additional optimization). </font><font style="vertical-align: inherit;">Here he is:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = -range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) { t -= range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) t %= range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t) { x = rng(); m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using the Lemire method will improve the performance of most randomized algorithms more than the transition from the fast generation engine to the running one a little faster. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Applications: Testing Notes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code for all tests is posted on </font></font><a href="https://github.com/imneme/bounded-rands"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In general, I tested 23 methods for </font></font><code>bounded_rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using 26 different PRNGs (13 32-bit PRNGs and 13 64-bit), in two compilers (GCC 8 and LLVM 6), which gave me 26 * 23 * 2 = 1196 executable files, each of which was performed with the same 15 seed, which gives 1196 * 15 = 17,940 unique test runs, in each of which three benchmarks are combined. Basically, I ran tests on a 48-core machine with four Xeon E7-4830v3 processors with a frequency of 2.1 GHz. Performing a full set of tests required a little less than a month of CPU time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the end we will return to the situation from the introduction of the article. Imagine that Sasha used </font></font><code>jsf32.STD-libc++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and Juan -</font></font><code>mt19937.BIASED_FP_MULT_SCALE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In benchmark 3, the latter takes 69.6% less time. </font><font style="vertical-align: inherit;">That is, the time from this fictional situation is based on data from reality.</font></font></div><p>Source: <a href="https://habr.com/ru/post/455702/">https://habr.com/ru/post/455702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455694/index.html">The architecture of billing a new generation: the transformation with the transition to Tarantool</a></li>
<li><a href="../455696/index.html">Electronic state of the future. Part 2</a></li>
<li><a href="../455698/index.html">The book "How is JavaScript"</a></li>
<li><a href="../4557/index.html">IE 7: new version, new vulnerability</a></li>
<li><a href="../45570/index.html">All the same 100% height and margin</a></li>
<li><a href="../45571/index.html">New LinkedIn Search Platform</a></li>
<li><a href="../455710/index.html">Why do we need our own development department for 200 people in Leroy Merlin?</a></li>
<li><a href="../455714/index.html">Automatically export Google Forms to Notion using IFTTT and Django</a></li>
<li><a href="../455716/index.html">15 recommendations for deploying business intelligence software</a></li>
<li><a href="../45572/index.html">How not to get a job</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>