<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>My rake: from rags to riches</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prehistory 


 I have been working as a front-end developer for one year. On my first project there was an ‚Äúenemy‚Äù backend. It so happens that this is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>My rake: from rags to riches</h1><div class="post__text post__text-html js-mediator-article"><h2 id="predystoriya">  Prehistory </h2><br><p>  I have been working as a front-end developer for one year.  On my first project there was an ‚Äúenemy‚Äù backend.  It so happens that this is not a big problem when communication is established. </p><br><p>  But in our case it was not the case. </p><a name="habracut"></a><br><p>  We developed code that relied on the fact that the backend sends us certain data, a certain structure and a certain format.  While the backend was considered normal to change the contents of the answers - without warning.  As a result, we spent hours trying to determine why a certain part of the site stopped working. </p><br><p>  We realized that we needed to check what the backend returns before relying on the data it sent us.  We created a task to research the validation of data from the frontend. </p><br><p>  This study was entrusted to me. </p><br><p>  Approximately made a list of what I want to be in the tool that I would like to use to validate the data. </p><br><p>  The most important selection points were the following items: </p><br><ul><li>  declarative description (scheme) of validation, which is transformed into a function-validator, which returns true / false (valid, not valid) </li><li>  low entry threshold; </li><li>  the similarity of validated data with a description of validation; </li><li>  ease of integration of custom validations; </li><li>  ease of integration of custom error messages. </li></ul><br><p>  As a result, I found many validation libraries by looking at the TOP-5 (ajv, joi, roi ...).  They are all very good.  But it seemed to me that for the sake of solving 5% of complex cases - they doomed 95% of the most frequent cases to be quite wordy and cumbersome. </p><br><p>  So I thought: why not develop something that would suit me? <br>  Four months later, the seventh version of my <a href="https://www.npmjs.com/package/quartet">quartet</a> validation library was released. <br>  It was a stable version, fully tested, 11k downloads on npm.  We used it on three projects in a campaign for three months. </p><br><p>  These three months have played a very useful role.  <a href="https://www.npmjs.com/package/quartet">quartet</a> demonstrated all its advantages.  There are no problems with the data from the backend.  Every time they changed the answer - we immediately threw an error.  The time spent finding the causes of bugs was reduced dramatically.  There are practically no data bugs left. </p><br><p>  But there were also disadvantages. </p><br><p>  Therefore, I decided to analyze them and release a new version with corrections of all errors that were made during development. <br>  On these architectural errors and their solutions will discuss below. </p><br><h2 id="arhitekturnye-grabli">  Architectural rake </h2><br><h3 id="stroko-tipizirovannyy-yazyk-shemy">  "Strok" -typed schema language </h3><br><p>  I will give an example of the old version of the scheme for the person object. </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'null'</span></span>] }</code> </pre> <br><p>  This scheme validates an object with three properties: name - must be a string, age - must be a number, link to akkanut on LinkedIn - must either be null (if there is no account) or string (if there is an account). </p><br><p>  This scheme meets my requirements for readability, similarity with validated data, and I think the entry threshold for learning to write such schemes is not high.  Moreover, such a scheme can be easily written with the typescript type definition: </p><br><pre> <code class="javascript hljs">type Person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string age: number linkedin: string | <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> <br><p>  (As we see, the changes are more cosmetic) </p><br><p>  When deciding what should be used for the most frequent validations (for example, those used above).  I chose to use strings, like validator names. </p><br><p>  But the problem with strings is that they are not available to the compiler or error analyzer.  The string 'number' for them is not much different from 'numder'. </p><br><h3 id="reshenie">  Decision </h3><br><p>  In the new version of <a href="https://www.npmjs.com/package/quartet">quartet</a> 8.0.0.  I decided to remove from the quartet the use of strings as names of validators inside the schema. </p><br><p>  The scheme now looks like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string age: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [v.string, <span class="hljs-literal"><span class="hljs-literal">null</span></span>] }</code> </pre> <br><p>  This change has two big advantages: </p><br><ul><li>  compilers or error analyzers - will be able to detect that the name of the method is written with an error. </li><li>  Strings are more used as a schema element.  This means that for them it is possible to allocate a new functional in the library, which will be described below. </li></ul><br><h3 id="podderzhka-typescript">  TypeScript support </h3><br><p>  In general, the first seven versions were developed in pure JavaScript.  When switching to a Typescript project, it became necessary to somehow adapt the library for it.  Therefore, type declarations for the library were written. </p><br><p>  But this was a minus - when adding functionality, or when changing some elements of the library, it was always easy to forget to update the type declarations. </p><br><p>  There were also just minor inconveniences of this kind: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p>  When we created an object validator on the line (0).  We would like to see after checking the real answer from the backend on line (1) and handling the error.  On line (2) for a <code>person</code> have type Person.  But it did not happen.  Unfortunately, such a check was not a type guard. </p><br><h3 id="reshenie-1">  Decision </h3><br><p>  I made a decision to rewrite the whole <a href="https://www.npmjs.com/package/quartet">quartet</a> library into Typescript so that the compiler would check the library's type conformity.  Along the way, we add to the function that returns the compiled validator - a type parameter that would determine what type of guard this type of validator is. </p><br><p>  An example looks like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p>  Now on line (2) the <code>person</code> is of type <code>Person</code> . </p><br><h3 id="chitaemost">  Readability </h3><br><p>  There were also two cases where the code was hard to read: checking for compliance with a specific set of values ‚Äã‚Äã(checking enum) and checking the other properties of the object. </p><br><p>  a) Enum check <br>  Initially there was an idea, in my opinion a good one.  We will demonstrate it by adding the field "floor" to our object. <br>  The old version of the scheme looked like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(<span class="hljs-string"><span class="hljs-string">'male'</span></span>, <span class="hljs-string"><span class="hljs-string">'female'</span></span>) }</code> </pre> <br><p>  The option is very readable.  But as usual, everything went a little out of plan. <br>  Having the enum announced in the program, for example: </p><br><pre> <code class="javascript hljs">enum Sex { Male = <span class="hljs-string"><span class="hljs-string">'male'</span></span>, Female = <span class="hljs-string"><span class="hljs-string">'female'</span></span> }</code> </pre> <br><p>  Naturally you want to use it inside the scheme.  That at change of any of values ‚Äã‚Äã(For example 'male' -&gt; 'm', 'female' -&gt; 'f') the validation scheme also changed. </p><br><p>  Therefore, the enum validation is almost always written as: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)) }</code> </pre> <br><p>  That looks rather cumbersome. </p><br><p>  b) Validation of residual properties of the object </p><br><p>  Suppose we add another characteristic to our object ‚Äî it may have additional fields, but all of them must be links to social networks ‚Äî it means they must be equal either <code>null</code> or be a string. </p><br><p>  The old scheme would look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)), ...v.rest([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null }</span></span></code> </pre> <br><p>  This entry outlined the remaining properties - from those already listed.  Using the spread-operator - rather confuses the person who wants to understand this scheme. </p><br><h3 id="reshenie-2">  Decision </h3><br><p>  As described above, strings are no longer part of validation schemes.  The validation scheme has only three types of Javascript values.  Object - to describe the object validation scheme.  Array to describe - several options for validity.  Function (generated by the library or custom) - for all other validation options. </p><br><p>  This provision made it possible to add functionality that allowed us to increase the readability of the scheme. </p><br><p>  In fact, what if we want to compare the value with the string 'male'.  Do we really need to know anything other than the value itself and the string 'male'. </p><br><p>  Therefore, it was decided to add values ‚Äã‚Äãof primitive types as an element of the schema.  So, where you meet the primitive value in the scheme, this means that this is the valid value that the validator created by this scheme should check.  Let me give you an example: </p><br><p>  If we need to check the number for equality 42-mind.  Then we write it like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> check42 = v(<span class="hljs-number"><span class="hljs-number">42</span></span>) check42(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true check42(41) // =&gt; false check42(43) // =&gt; false check42('42') // =&gt; false</span></span></code> </pre> <br><p>  Let's see how this affects the person's scheme (without taking into account additional properties): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-comment"><span class="hljs-comment">// null is primitive value sex: ['male', 'female'] // 'male', 'female' are primitive values }</span></span></code> </pre> <br><p>  Using pre-defined enums, we can rewrite it like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex) <span class="hljs-comment"><span class="hljs-comment">// same as ['male', 'female'] }</span></span></code> </pre> <br><p>  In this case, the extra ceremoniality was removed in the form of using the enum method and using the spread-operator to insert valid values ‚Äã‚Äãfrom the object as parameters into this method. </p><br><p>  What is considered a primitive value: numbers, strings, characters, <code>true</code> , <code>false</code> , <code>null</code> and <code>undefined</code> . </p><br><p>  That is, if we need to compare the value with them - we simply use these values ‚Äã‚Äãthemselves.  And the validation library will create a validator that will strictly compare the value with those specified in the schema. </p><br><p>  To validate the residual properties, it was chosen to use a special property for all other fields of the object: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), [v.rest]: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string] }</code> </pre> <br><p>  Thus, the scheme looks more readable.  And more similar to ads from Typescript. </p><br><h3 id="svyazannost-validatora-s-funkciey-kotoraya-sozdala-ego">  The validator's association with the function that created it. </h3><br><p>  In older versions, error explanations were not part of the validator.  They were formed into an array inside the function <code>v</code> . </p><br><p>  Previously, in order to get explanations of validation errors, it was necessary to have a validator with you (to perform a check) and a function v (to get explanations of invalidity).  It all looked like this: <br><br>  a) We add explanations to the schema. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>) age: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>), <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v( v.enum(...Object.values(Sex)), <span class="hljs-string"><span class="hljs-string">'wrong sex value'</span></span> ), ...v.rest( v( [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong social networks link'</span></span> ) ) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null })</span></span></code> </pre> <br><p>  To any element of the schema, you can add an explanation of the error using the second argument of the compiler function v. </p><br><p>  b) Clear the array of explanations. </p><br><p>  Before validation, it was necessary to clear this global array in which all explanations were recorded during validation. </p><br><pre> <code class="javascript hljs">v.clearContext() <span class="hljs-comment"><span class="hljs-comment">// same as v.explanations = []</span></span></code> </pre> <br><p>  c) Validate </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPersonValid = checkPerson(person)</code> </pre> <br><p>  During this test, if the invalidity was detected, and at the stage of creating the scheme - she was given an explanation, then this explanation is placed in the global <code>v.explanation</code> array. </p><br><p>  d) Error handling </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isPersonValid) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(<span class="hljs-string"><span class="hljs-string">'Invalid person response: '</span></span> + v.explanation.join(<span class="hljs-string"><span class="hljs-string">'; '</span></span>)) } <span class="hljs-comment"><span class="hljs-comment">// ex. Throws 'Invalid person response: wrong name; wrong age'</span></span></code> </pre> <br><p>  As you can see there is a big problem.  Because if we want to use the validator is not in the place of its creation.  We will need to pass in the parameters not only it, but also the function that created it.  Because it is in it that there is an array in which the explanations will be folded. </p><br><h3 id="reshenie-3">  Decision </h3><br><p>  This problem was solved as follows: explanations have become part of the validation function itself.  What can be understood from its type: <br>  type Validator = (value: any, explanations ?: any []) =&gt; boolean </p><br><p>  Now if you need an explanation of the error, you are passing the array into which you want to add the explanations. </p><br><p>  Thus, the validator becomes an independent unit.  A method has also been added that can transform the validation function into a function that returns null if the value is valid and returns an array of explanations if the value is not valid. </p><br><p>  Now the validation with explanations looks like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(v.string, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>), <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v(v.number, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>) sex: v(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), <span class="hljs-string"><span class="hljs-string">'wrong sex'</span></span>) [v.rest]: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong social network'</span></span>) }) <span class="hljs-comment"><span class="hljs-comment">// ... const explanations = [] if (!checkPerson(person, explanation)) { throw new TypeError('Wrong person: ' + explanations.join('; ')) } // OR const getExplanation = v.explain(checkPerson) const explanations = getExplanation(person) if (explanations) { throw new TypeError('Wrong person: ' + explanations.join('; ')) }</span></span></code> </pre> <br><h2 id="posleslovie">  Afterword </h2><br><p>  I identified three prerequisites for which I had to rewrite everything: </p><br><ul><li>  The hope that people are not mistaken when writing lines </li><li>  Using global variables (in this case v.explanation array) </li><li>  Check on small examples during development - did not show the problems that arise when used in real large cases. </li></ul><br><p>  But I am glad that I conducted an analysis of these problems, and the released version is already used in our project.  And I hope it will be useful to us no less than the previous one. </p><br><p>  Thank you all for reading, I hope my experience will be useful to you. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/453502/">https://habr.com/ru/post/453502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453486/index.html">US Free Market Principles</a></li>
<li><a href="../453490/index.html">News from the world of OpenStreetMap ‚Ññ 461 (05.14.2019-20.05.2019)</a></li>
<li><a href="../453492/index.html">Automation of the company's business processes in Trello using semantic modeling technology</a></li>
<li><a href="../453496/index.html">Happy chemist, colleagues</a></li>
<li><a href="../4535/index.html">LinkedIn Launches Service Providers Directory</a></li>
<li><a href="../453508/index.html">Man without a smartphone</a></li>
<li><a href="../453510/index.html">All Your Own: Tutorial on Creating New Actions for UiPath RPA</a></li>
<li><a href="../453512/index.html">Style transfer</a></li>
<li><a href="../453514/index.html">Introductory Offers Guide for iOS</a></li>
<li><a href="../453520/index.html">Accelerate Ansible with Mitogen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>