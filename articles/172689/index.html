<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>StringBuilder Past and Present</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 My last article was devoted to the features of the string data type String in .NET. This article continues the tradition, but this time...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>StringBuilder Past and Present</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  My last article was devoted to the features of the string data type String in .NET.  This article continues the tradition, but this time we will look at the StringBuilder class. <br><br>  As you know, strings in .NET are immutable (without using unsafe), and therefore it is not a good idea to perform concatenation operations with them in large quantities.  This means that the following code has very serious problems with memory load: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) { s += <span class="hljs-string"><span class="hljs-string">"T"</span></span>; }</code> </pre> <a name="habracut"></a><br>  What is wrong with this code?  And the fact that each iteration creates a string one unit longer than the previous step, and then copying characters from the old string.  Thus, the total number of characters involved is equal to: <br><img src="http://habrastorage.org/storage2/79f/c9a/f99/79fc9af99c69a7feec6d0ac5b841451b.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This formula is nothing more than the sum of an arithmetic progression: <br><img src="http://habrastorage.org/storage2/948/9e7/8ef/9489e78ef5352fb557f292ebf16d8162.png"><br>  That is, such a concatenation script requires memory in proportion to O (n <sup>2</sup> ), n is the length of the string. <br><br>  To eliminate problems in such code, we use the StringBuilder class, knowing that operations with it do not lead to such memory wastes as with a String.  StringBuilder is actually a modifiable string. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> strB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) { strB.Append(<span class="hljs-string"><span class="hljs-string">"T"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> str = strB.ToString();</code> </pre><br>  This code, though not devoid of all the flaws and spends some memory on the wind, but it does it more restrained, compared with the previous code. <br><br>  The implementation of the StringBuilder class has changed dramatically in .NET 4.0 compared to previous versions, and therefore I think it will be interesting to write what happened to it. <br><br><h4>  StringBuilder in .NET 2.0 </h4><br>  The StringBuilder class in .NET 2.0 has the following fields: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StringBuilder</span></span> : <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DefaultCapacity = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> CapacityField = <span class="hljs-string"><span class="hljs-string">"Capacity"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MaxCapacityField = <span class="hljs-string"><span class="hljs-string">"m_MaxCapacity"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> StringValueField = <span class="hljs-string"><span class="hljs-string">"m_StringValue"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ThreadIDField = <span class="hljs-string"><span class="hljs-string">"m_currentThread"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> IntPtr m_currentThread; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_MaxCapacity; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> m_StringValue; &lt;------------------------------------- }</code> </pre><br>  <i>m_currentThread</i> - the identifier of the thread in which the object instance was created; <br>  <i>m_MaxCapacity</i> - the maximum capacity of this instance; <br>  <i>m_StringValue</i> is a string containing characters. <br><br>  In fact, the StringBuilder class internally works with the string data type String.  Since the strings on the mscorlib.dll side are mutable, then StringBuilder does not cost anything to change the string that is in <i>m_StringValue</i> . <br><br>  The initial length is 16 characters, and if there is not enough space to add new characters, StringBuilder replaces the internal string with a string two times longer and copies to the newly created all the characters from the previous one + new ones.  Doubling the length of a string leads to linear complexity (O (n)) from memory, as opposed to quadratic, which is inherent in ordinary strings. <br><br>  An important addition to the performance increase is setting the required capacity when creating an instance of the StringBuilder class.  Thus, we do not need another doubling of the size and copying of data in case of insufficient memory.  However, this is possible only if we know in advance the size of the resulting string. <br><br>  Consider the implementation of the most commonly used methods.  For code readability, I removed the conditions for checking the input parameters. <br><br><h5>  <i>Append () method</i> </h5><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Append</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> currentString = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.m_StringValue; IntPtr currentThread = Thread.InternalGetCurrentThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.m_currentThread != currentThread) currentString = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.GetStringForStringBuilder(currentString, currentString.Capacity); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = currentString.Length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> requiredLength = length + <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.NeedsAllocation(currentString, requiredLength)) <span class="hljs-comment"><span class="hljs-comment">//       { //    2          string newString = this.GetNewString(currentString, requiredLength); newString.AppendInPlace(value, length); this.ReplaceString(currentThread, newString); //    } else { currentString.AppendInPlace(value, length); this.ReplaceString(currentThread, currentString); } return this; }</span></span></code> </pre><br></div></div><br>  This method simply checks whether there is enough space in the current instance to add a new line, if so, it simply copies it in place to the unoccupied part of the line, otherwise doubling the size and copying the old and new lines. <br><br><h5>  <i>Insert method ()</i> </h5><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Insert(index, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Insert(index, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span> { IntPtr tid; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> threadSafeString = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetThreadSafeString(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> tid); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = threadSafeString.Length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> requiredLength; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { requiredLength = <span class="hljs-keyword"><span class="hljs-keyword">checked</span></span> (length + <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Length * count);<span class="hljs-comment"><span class="hljs-comment">//    } catch (OverflowException ex) { throw new OutOfMemoryException(); } if (this.NeedsAllocation(threadSafeString, requiredLength))//       { //    2          string newString = this.GetNewString(threadSafeString, requiredLength); newString.InsertInPlace(index, value, count, length, requiredLength);//   this.ReplaceString(tid, newString);//    } else { threadSafeString.InsertInPlace(index, value, count, length, requiredLength); this.ReplaceString(tid, threadSafeString); } return this; } } return this; }</span></span></code> </pre><br></div></div><br>  This method, similarly to the previous one, checks whether there is enough space in the current instance to insert a new line and, depending on this, doubles the size of the line or inserts it in place in the original line without resizing. <br><br><h5>  <i>Remove () method</i> </h5><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span> { IntPtr tid; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> threadSafeString = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetThreadSafeString(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> tid); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length1 = threadSafeString.Length; <span class="hljs-comment"><span class="hljs-comment">//  ,      threadSafeString.RemoveInPlace(startIndex, length, length1); this.ReplaceString(tid, threadSafeString);//    return this; }</span></span></code> </pre><br></div></div><br>  This method removes unnecessary characters by moving the rest of the line to the left.  When deleting the last character, you don‚Äôt actually need to shift anything, so deletion from the end is much faster than from any other part of the string. <br><br><h5>  <i>ToString () method</i> </h5><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.m_StringValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.m_currentThread != Thread.InternalGetCurrentThread() || <span class="hljs-number"><span class="hljs-number">2</span></span> * str.Length &lt; str.ArrayLength) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.InternalCopy(str);<span class="hljs-comment"><span class="hljs-comment">//   str.ClearPostNullChar(); this.m_currentThread = IntPtr.Zero; return str; //     }</span></span></code> </pre><br></div></div><br>  This method, as can be seen from the implementation, returns either a copy of the string, or a string with which it operates.  As a rule, the first call to this method returns a reference to the source string, so it is executed very quickly, but each subsequent call results in copying the string.  The StringBuilder class in .NET 2.0 focuses precisely on the speed of this method. <br><br>  In general, the StringBuilder class in .NET 2.0 is fairly simple to implement.  It uses a variable string, and if there is not enough space, it creates a new string, the length of which is twice the previous one.  Such a scenario of doubling the length leads to linear complexity in memory, which is an order of magnitude better than a quadratic one.  However, with large lengths of lines and it is not effective.  By the way, because of its larger size, the line can often be placed in a heap for large objects (LOH), which is also not good. <br><br><h4>  StringBuilder in .NET 4.0 </h4><br>  As I said, in .NET 4.0 the implementation of the StringBuilder class has changed.  Now Char [] is used to store characters instead of String, and the class itself is a linked list of StringBuilders, like RopeString. <br><br>  The reason for this change is quite obvious: with such an implementation, it is not necessary to re-allocate memory when it is scarce, which is inherent in the previous implementation.  This also means that the ToString () method works a little slower, since the final string must first be formed, and the Append () method works faster, since it does not require copying.  However, this fits into a typical use case for StringBuilder: many calls to Append (), and then one call to ToString (). <br><br>  The StringBuilder class in .NET 4.0 has the following fields: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StringBuilder</span></span> : <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DefaultCapacity = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxChunkSize = <span class="hljs-number"><span class="hljs-number">8000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] m_ChunkChars; &lt;------------------------------------- <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> StringBuilder m_ChunkPrevious; &lt;------------------------------------- <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_ChunkLength; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_ChunkOffset; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_MaxCapacity; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> CapacityField = <span class="hljs-string"><span class="hljs-string">"Capacity"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MaxCapacityField = <span class="hljs-string"><span class="hljs-string">"m_MaxCapacity"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> StringValueField = <span class="hljs-string"><span class="hljs-string">"m_StringValue"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ThreadIDField = <span class="hljs-string"><span class="hljs-string">"m_currentThread"</span></span>; }</code> </pre><br>  <i>m_ChunkChars</i> - an array containing the characters of the current linked list element (a piece of string); <br>  <i>m_ChunkPrevious</i> - a link to the previous element (StringBuilder) in the list; <br>  <i>m_ChunkLength</i> - the actual length of the current list item (the number of characters used); <br>  <i>m_ChunkOffset</i> - the total number of characters used by the string (logical length); <br>  <i>m_MaxCapacity</i> - the maximum capacity of the current StringBuilder instance. <br><br>  In .NET Framework 4 and .NET Framework 4.5, when you create an instance of a StringBuilder object by calling the StringBuilder (Int32, Int32) constructor, the length and capacity of the StringBuilder instance can increase beyond the value of its MaxCapacity property.  This can happen in particular when calling the Append and AppendFormat methods. <br><br>  The maximum length of the <i>MaxChunkSize</i> list <i>item</i> is 8000. As you understand, this is not just done.  Here is a comment from class developers: <br><br>  <b>We want to keep the heap (&lt;85K bytes ~ 40K chars) to be sure.</b>  <b>There are few signs of slowing down.</b> <b><br><br></b>  <b>We want the array of characters not to fall into a heap for large objects.</b>  <b>Making the maximum size of a list element (piece) large would mean that less memory allocation is needed, but more characters remain unused and insert / replace operations are slower.</b> <br><br>  Consider the implementation of the most commonly used methods. <br><br><h5>  <i>Append () method</i> </h5><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Append</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] chArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.m_ChunkChars; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.m_ChunkLength; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = index + length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; chArray.Length)<span class="hljs-comment"><span class="hljs-comment">//           { if (length &lt;= 2) { if (length &gt; 0) chArray[index] = value[0]; if (length &gt; 1) chArray[index + 1] = value[1]; } else { fixed (char* smem = value) fixed (char* dmem = &amp;chArray[index]) string.wstrcpy(dmem, smem, length); } this.m_ChunkLength = num; } else this.AppendHelper(value); } return this; } private unsafe void AppendHelper(string value) { fixed (char* chPtr = value) this.Append(chPtr, value.Length); } internal unsafe StringBuilder Append(char* value, int valueCount) { //  int num1 = valueCount + this.m_ChunkLength; if (num1 &lt;= this.m_ChunkChars.Length) { StringBuilder.ThreadSafeCopy(value, this.m_ChunkChars, this.m_ChunkLength, valueCount); this.m_ChunkLength = num1; } else { //   () int count = this.m_ChunkChars.Length - this.m_ChunkLength; if (count &gt; 0) { StringBuilder.ThreadSafeCopy(value, this.m_ChunkChars, this.m_ChunkLength, count); this.m_ChunkLength = this.m_ChunkChars.Length; } //  ,     int num2 = valueCount - count; this.ExpandByABlock(num2); //    () StringBuilder.ThreadSafeCopy(value + count, this.m_ChunkChars, 0, num2); this.m_ChunkLength = num2; } return this; }</span></span></code> </pre><br></div></div><br>  The Append () method works as follows: if there are enough characters in the current list item to insert a new line, then it is copied into it, if not, then the part that fits is copied, and for something that does not fit, a new list item is created ( an instance of StringBuilder-a), in which the length of the array is equal to the length of the entire source string or the length of the remaining string, whichever is greater.  However, as mentioned above, the maximum array length is 8000. <br><br>  In general, the formula for calculating the length of a new list item is as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = Math.Max(minBlockCharCount, Math.Min(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Length, <span class="hljs-number"><span class="hljs-number">8000</span></span>))</code> </pre><br>  where minBlockCharCount is the remaining length of the string after copying its part that fits into the current instance. <br><br>  Thus, as a result of the work of such a code <br><br><pre> <code class="cs hljs">StringBuilder s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder (); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; i++) { s.Append (<span class="hljs-string"><span class="hljs-string">"T"</span></span>); }</code> </pre><br>  the lengths of the arrays of the elements of the list will be equal: <b>8000</b> , 4092, 2048, 1024, 512, 256, 128, 64, 32, 16, 16. <br><br>  With such lengths of arrays, the operation of accessing a certain character in the source string is performed quite quickly almost in O (1), since there are not so many elements of the list. <br><br><h5>  <i>Insert method ()</i> </h5><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* chPtr = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Insert(index, chPtr, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Length); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> valueCount</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueCount &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; StringBuilder chunk; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indexInChunk; <span class="hljs-comment"><span class="hljs-comment">//          (StringBuilder) this.MakeRoom(index, valueCount, out chunk, out indexInChunk, false); this.ReplaceInPlaceAtChunk(ref chunk, ref indexInChunk, value, valueCount); }</span></span></code> </pre><br></div></div><br>  The Insert () method works as follows: if there is enough space to insert in the current list item (StringBuilder), the available characters are shifted to give space to the new text.  Otherwise, a new list item (StringBuilder) is created, into which some characters from the previous item that do not fit are copied.  Subsequent characters are not shifted to the left. <br><br>  What will be the result of this code? <br><br><pre> <code class="cs hljs">StringBuilder s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder (); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; i++) { s.Insert (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"T"</span></span>); }</code> </pre><br>  The result will be different from the code using Append (), and very seriously! <br><br>  We will get a very large list of StringBuilders, each element that will be 16 characters long.  As a result, the operation of accessing a certain symbol by index will be performed more slowly than expected, namely, in proportion to the list length, that is, O (n). <br><br><h5>  <i>Remove () method</i> </h5><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Length == length &amp;&amp; startIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .     . this.Length = 0; return this; } else { if (length &gt; 0) { StringBuilder chunk; int indexInChunk; this.Remove(startIndex, length, out chunk, out indexInChunk); } return this; } } private void Remove(int startIndex, int count, out StringBuilder chunk, out int indexInChunk) { int num = startIndex + count; //  ()         . chunk = this; StringBuilder stringBuilder = (StringBuilder) null; int sourceIndex = 0; while (true) { if (num - chunk.m_ChunkOffset &gt;= 0) { if (stringBuilder == null) { stringBuilder = chunk; sourceIndex = num - stringBuilder.m_ChunkOffset; } if (startIndex - chunk.m_ChunkOffset &gt;= 0) break; } else chunk.m_ChunkOffset -= count; chunk = chunk.m_ChunkPrevious; } indexInChunk = startIndex - chunk.m_ChunkOffset; int destinationIndex = indexInChunk; int count1 = stringBuilder.m_ChunkLength - sourceIndex; //       if (stringBuilder != chunk) { destinationIndex = 0; //    startIndex     () chunk.m_ChunkLength = indexInChunk; //       . stringBuilder.m_ChunkPrevious = chunk; stringBuilder.m_ChunkOffset = chunk.m_ChunkOffset + chunk.m_ChunkLength; //                () if (indexInChunk == 0) { stringBuilder.m_ChunkPrevious = chunk.m_ChunkPrevious; chunk = stringBuilder; } } stringBuilder.m_ChunkLength -= sourceIndex - destinationIndex; if (destinationIndex == sourceIndex) //     return; //          StringBuilder.ThreadSafeCopy(stringBuilder.m_ChunkChars, sourceIndex, stringBuilder.m_ChunkChars, destinationIndex, count1); }</span></span></code> </pre><br></div></div><br>  The implementation of this method has become significantly more complicated.  However, it should be noted that the previous implementation copied a large number of characters, shifting them to the left.  Here it is necessary to make an offset only within one element (StringBuilder-a) in the list. <br><br><h5>  <i>ToString () method</i> </h5><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.FastAllocateString(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Length); StringBuilder stringBuilder = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* chPtr = str) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stringBuilder.m_ChunkLength &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] chArray = stringBuilder.m_ChunkChars; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = stringBuilder.m_ChunkOffset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charCount = stringBuilder.m_ChunkLength; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* smem = chArray) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.wstrcpy(chPtr + num, smem, charCount); } stringBuilder = stringBuilder.m_ChunkPrevious; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (stringBuilder != <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; }</code> </pre><br></div></div><br>  This method traverses the entire linked list of StringBuilders, and successively copies the characters of each of the elements of the list into the resulting string. <br><br><h4>  Performance comparison </h4><br>  Perhaps the most interesting part is the performance comparison between the two versions of the class. <br><br>  <b>Test 1. How much memory is required to store a string of a given length.</b> <br><br><img src="http://habrastorage.org/storage2/ff5/6bf/956/ff56bf9560066482f1d89ba07cb81771.png"><br><br>  As you can see, with a small length of the string, the new implementation loses the old one.  It is understandable, because for each element of the list (StringBuilder) information is required on the length, capacity, offset from the beginning of the string + for the array of overhead characters.  But as soon as the string length becomes larger than 16384, the old implementation starts to lose (due to the doubling of the string size, it contains many unused characters). <br><br>  <b>Test 2. Append () method</b> <br><br><img src="http://habrastorage.org/storage2/3b8/b64/97b/3b8b6497b473f0c0a0d10cb774cbb1d6.png"><br><br>  Perhaps this is the very method in which the new implementation wins.  Since there is no need to double the length of the line when there is not enough memory and no characters are required to copy into it, this method is performed much faster, <b>almost twice (more precisely, 1.8 times).</b> <br><br>  <b>Test 3. Method Insert ()</b> <br><br>  We will insert into the string already filled with characters, 1000 characters long. <br><br>  1. Insert at the beginning of the line <br><br><img src="http://habrastorage.org/storage2/6f7/0da/c6d/6f70dac6d0d9fa3613034fb60b0ef9a1.png"><br><br>  2. Insert in the middle of the line <br><br><img src="http://habrastorage.org/storage2/94e/e3e/e5f/94ee3ee5f1dccf3979cef3c47b5d5098.png"><br><br>  3. Insert at the end of the line <br><br><img src="http://habrastorage.org/storage2/97b/f02/9a1/97bf029a1f76f07f57e544fda74e65e6.png"><br><br>  Comments are unnecessary - the new implementation loses when inserted in any place. <br><br>  <b>Test 4. Remove () method</b> <br><br>  We will remove 10 characters from the line already filled with characters until we have exhausted it. <br><br><img src="http://habrastorage.org/storage2/365/2b9/91b/3652b991beceb0b359260b81a8c2142f.png"><br><br>  The new implementation wins when deleting almost from any place, since now it is not necessary to shift the characters of the remaining line to the left (more precisely, it is required, but not as often and much as before). <br><br>  <b>Test 5. Method ToString ()</b> <br><br>  As mentioned above, this method loses the previous implementation.  The previous implementation returned simply a reference to the string with which it operated (the first time it was called), and the new one is forced to assemble the resulting string in pieces, bypassing each element of the linked list. <br><br><img src="http://habrastorage.org/storage2/5a3/76c/1fa/5a376c1fa1337a5497f0e6d3d58d56d0.png"><br><br>  The new implementation works much slower if the string was formed using the Insert () method, since the list will consist of a set of elements (StringBuilders) with a length of 16 characters. <br><br>  <b>Test 6. Appeal on a specific index</b> <br><br>  Given that now StringBuilder is a linked list, the operation of accessing a string at a specific index becomes expensive.  Especially if it was formed using the Insert method. <br><br><img src="http://habrastorage.org/storage2/b1e/6e5/cde/b1e6e5cde4f058efdf7c423741a44606.png"><br><br>  <b>Test 7. Common Scenario: Multiple calls to Append () and then ToString ()</b> <br><br>  As a rule, we work with this class in a specific scenario: a multiple call to the Append () method, followed by a single ToString () call.  The implementation of this class has changed exactly in the calculation for this scenario. <br><br><img src="http://habrastorage.org/storage2/888/1eb/58d/8881eb58d9ca11bc2a9a990fcc4482d4.png"><br><br><h4>  Conclusion </h4><br>  As we have seen, the StringBuilder class in .NET 2.0 has been optimized for the speed of the ToString () method, while in .NET 4.0 it has been optimized for the speed of the Append () method.  The new implementation of the Append () method works almost 2 times faster, while the Insert () and ToString () methods are slower.  But since we are working with this class in a specific scenario: we call the Append () method multiple times, followed by a single call to the ToString () method, then an increase in performance takes place. <br><br>  Given the new implementation of the class, in which only a multiple call of the Append () method leads to an increase in performance, the class could now be called StringAppender *) </div><p>Source: <a href="https://habr.com/ru/post/172689/">https://habr.com/ru/post/172689/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../172671/index.html">Google arranges spring cleaning and bans AdBlock in Android</a></li>
<li><a href="../172673/index.html">Why did Google decide to close Google Reader or how popular is RSS?</a></li>
<li><a href="../172677/index.html">12 projects will receive $ 25,000 for development from the creator of VKontakte Pavel Durov and Yuri Milner</a></li>
<li><a href="../172683/index.html">What's new in PhpStorm 6.0</a></li>
<li><a href="../172685/index.html">Twitter out for Windows 8</a></li>
<li><a href="../172691/index.html">Free seminars for IT students</a></li>
<li><a href="../172693/index.html">Feedly promises a painless migration of Google Reader users to your backend</a></li>
<li><a href="../172695/index.html">Minecraft 1.5 released</a></li>
<li><a href="../172699/index.html">New PHP extension under the old name: event</a></li>
<li><a href="../172701/index.html">JDeveloper 11g Developing Web Applications with Oracle ADF in Russian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>