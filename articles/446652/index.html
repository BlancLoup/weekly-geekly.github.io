<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MVCC-4. Snapshots of data</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Having considered the issues related to isolation , and having made a digression about organizing data at a low level , we last time talked in detail ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MVCC-4. Snapshots of data</h1><div class="post__text post__text-html js-mediator-article">  Having considered the issues related to <a href="https://habr.com/ru/company/postgrespro/blog/442804/">isolation</a> , and having made a digression about <a href="https://habr.com/ru/company/postgrespro/blog/444536/">organizing data at a low level</a> , we last time talked in detail about the <a href="https://habr.com/ru/company/postgrespro/blog/445820/">versatile lines</a> and traced how the service information in the version header changes during various operations. <br><br>  Today we will look at how consistent versions of data are obtained from string versions. <br><br><h1>  What is a snapshot of data </h1><br>  Physically, there may be several versions of the same line in the data pages.  In addition, each transaction should see only one (or none) version of each row so that together they constitute an ACID-agreed data picture at a specific point in time. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Isolation in PostgreSQL is built on the basis of snapshots of data (snapshot): each transaction works with its own snapshot of data that ‚Äúcontains‚Äù data that was recorded before the snapshot was taken, and not ‚Äúcontains‚Äù data that has not yet been fixed.  We <a href="https://habr.com/ru/company/postgrespro/blog/442804/">have already seen</a> that the insulation thus turns out to be more stringent than the standard requires, but not devoid of anomalies. <br><a name="habracut"></a><br>  At the Read Committed isolation level, a snapshot is created at the beginning of each transaction statement.  This snapshot is active while the statement is being executed.  In the picture, the moment of the snapshot creation (which, as we remember, is determined by the transaction number) is shown in blue. <br><br><img src="https://habrastorage.org/webt/5g/nz/nj/5gnznjhyp869w4ls01o0wy5kxlo.png"><br><br>  At the Repeatable Read and Serializable levels, a snapshot is created once at the beginning of the first transaction statement.  This snapshot remains active until the very end of the transaction. <br><br><img src="https://habrastorage.org/webt/ff/dp/17/ffdp17xhiqemal2dj8k6a21ql38.png"><br><br><h1>  Visibility of row versions in snapshot </h1><br><h2>  Visibility rules </h2><br>  Of course, the snapshot is not a physical copy of all the necessary versions of the lines.  In fact, a snapshot is defined by several numbers, and the visibility of versions of strings in a snapshot is determined by the rules. <br><br>  Whether or not this version of the row is visible in the snapshot depends on two fields of its header, xmin and xmax, that is, the numbers of the transaction that created and deleted.  Such intervals do not overlap, so one line is represented in any snapshot with at most one version of it. <br><br>  The exact rules of visibility are quite complex and take into account many different situations and extreme cases. <br><blockquote>  This is easily seen by looking at src / backend / utils / time / tqual.c (in version 12, the check moved to src / backend / access / heap / heapam_visibility.c). <br></blockquote><br>  Simplifying, we can say that the version of the line is visible when the changes made by the xmin transaction are visible in the snapshot and the changes made by the xmax transaction are not visible (in other words, it is already clear that the version of the line has appeared, but it is not yet clear that it has been deleted). <br><br>  In turn, the transaction changes are visible in the snapshot, if either this is the same transaction that created the snapshot (she sees her own changes), or the transaction was fixed before the snapshot was taken. <br><br>  You can depict transactions graphically in the form of segments (from the moment of beginning to the moment of fixation): <br><br><img src="https://habrastorage.org/webt/w2/cq/yr/w2cqyrzhqwmzzenek8ski3mhbzo.png"><br><br>  Here: <br><br><ul><li>  Changes to transaction 2 will be visible because it is completed before the snapshot is taken, </li><li>  Changes to transaction 1 will not be visible because it was active at the time of the snapshot, </li><li>  Changes to transaction 3 will not be visible, because it began after the snapshot was taken (no matter if it ended or not). </li></ul><br>  Unfortunately, the moment of committing transactions is unknown to the system.  Only the moment of its beginning is known (it is determined by the number of the transaction and is marked in the figures above with a dotted line), but the fact of completion is not recorded anywhere. <br><br>  All we can do is find out the <em>current</em> status of transactions when creating a snapshot.  This information is in the shared memory of the server in the ProcArray structure, which contains a list of all active sessions and their transactions. <br><br>  And after the fact, we will not be able to understand whether a transaction was active at the time of the snapshot creation or not.  Therefore, a list of all current active transactions must be memorized in a snapshot. <br><br>  It follows from the above that in PostgreSQL it is impossible to create a snapshot showing consistent data as of an arbitrary time ago, <em>even if</em> all the necessary versions of the rows exist in the table pages.  One often hears the question why there are no retrospective (or temporal; in Oracle, this is called a flashback query) queries ‚Äî this is one of the reasons. <br><blockquote>  It's funny that initially this functionality was, but later it was removed from the database.  You can read about this in an <a href="https://habr.com/ru/company/postgrespro/blog/438890/">article by Joseph Hellershtein</a> . <br></blockquote>  So, a snapshot of the data is determined by several parameters: <br><br><ul><li>  the moment of the snapshot creation, namely, the number of the next transaction that does not yet exist in the system ( <strong>snapshot.xmax</strong> ); </li><li>  a list of active transactions at the time of the snapshot ( <strong>snapshot.xip</strong> ). </li></ul><br>  For convenience and optimization, the number of the earliest of the active transactions ( <strong>snapshot.xmin</strong> ) is stored separately.  This value has an important meaning, which we will discuss below. <br><br>  Also, several more parameters are saved in the snapshot, but they are not important for us. <br><br><img src="https://habrastorage.org/webt/-r/8v/aa/-r8vaa6fvrltfpd4tjjnv_zxnk4.png"><br><br><h2>  Example </h2><br>  To see how visibility is determined by a snapshot, let's reproduce the three-transaction situation discussed above.  The table will have three rows, and: <br><br><ul><li>  the first one is added by a transaction that started before the snapshot was taken, but was completed later, </li><li>  the second one is added by a transaction that began and ended before the snapshot was taken, </li><li>  the third was added after the snapshot was taken. </li></ul><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts;</code> </pre> <br>  First transaction (not yet completed): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">=&gt; SELECT txid_current(); txid_current -------------- 3695 (1 row)</code> </pre><br>  The second transaction (completed before creating the snapshot) <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3696 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  We create a snapshot in a transaction in another session. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Finish the first transaction after the snapshot is created: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  And the third transaction (appeared after the snapshot creation): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3697 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Obviously, one line is still visible in our snapshot: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  The question is how PostgreSQL understands this. <br><br>  Everything is determined by the snapshot.  Let's look at it: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_snapshot();</code> </pre><pre> <code class="plaintext hljs">|| txid_current_snapshot || ----------------------- || 3695:3697:3695 || (1 row)</code> </pre><br>  Here, the colon lists snapshot.xmin, snapshot.xmax, and snapshot.xip (in this case, one number, but in general - a list). <br><br>  According to the rules formulated above, the snapshot should show the changes made by transactions with the numbers snapshot.xmin &lt;= xid &lt;snapshot.xmax, except for those listed in the snapshot.xip list.  Let's look at all the rows in the table (in the new snapshot): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | number | client | amount ------+------+----+--------+--------+--------- 3695 | 0 | 1 | 1001 | alice | 1000.00 3696 | 0 | 2 | 2001 | bob | 100.00 3697 | 0 | 3 | 2002 | bob | 900.00 (3 rows)</code> </pre><br>  The first line is not visible - it was created by a transaction that is included in the list of active (xip). <br>  The second line is visible - it is created by a transaction that falls within the range of the snapshot. <br>  The third line is not visible - it was created by a transaction that is not within the range of the snapshot. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Own changes </h1><br>  Somewhat complicates the picture is the case of determining the visibility of your own transaction changes.  Here you may need to see only a part of such changes.  For example, a cursor opened at a certain moment should not see changes made after that moment at any level of isolation. <br><br>  To do this, there is a special field in the row header (which is displayed in the pseudo columns cmin and cmax), indicating the sequence number of the operation within the transaction.  Cmin is the number to insert, cmax is to delete, but to save space in the row header, this is actually one field, not two different ones.  It is considered that insertion and deletion of the same row in a single transaction is rarely performed. <br><br>  If this does happen, then a special ‚Äúcombo‚Äù number is inserted into the same field, about which the serving process remembers the real cmin and cmax.  But this is completely exotic. <br><br>  A simple example.  Start a transaction and add a row to the table: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3698 (1 row)</code> </pre><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3001</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>);</code> </pre><br>  Let's output the contents of the table along with the cmin field (but only for rows added by our transaction ‚Äî for others it does not make sense): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Now open the cursor for the query that returns the number of rows in the table. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br>  And after that, add another line: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3002</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>);</code> </pre><br>  The query returns 4 - the string added after the cursor is opened will not be included in the data snapshot: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> count ------- 4 (1 row)</code> </pre><br>  Why?  Because in the snapshot only versions of lines with cmin &lt;1 are taken into account. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 3698 | 1 | 5 | 3002 | charlie | 200.00 (5 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Event horizon </h1><br>  The number of the earliest of the active transactions (snapshot.xmin) has an important meaning - it defines the ‚Äúevent horizon‚Äù of the transaction.  Namely, beyond its horizon, a transaction always sees only current versions of strings. <br><br>  Indeed, an irrelevant version is required to be seen only in the case when the current one is created by a transaction that has not yet ended, and therefore is not yet visible.  But beyond the ‚Äúhorizon‚Äù all transactions are already guaranteed to be completed. <br><br><img src="https://habrastorage.org/webt/8z/vp/oo/8zvpoocv891hhtnv9lcs6j7g4ry.png"><br><br>  The ‚Äúevent horizon‚Äù of the transaction can be seen in the system directory: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  You can also define an "event horizon" at the database level.  To do this, take all the active images and find the oldest xmin among them.  It will determine the horizon beyond which irrelevant versions of rows in this database will never be seen any transaction.  <em>Such versions of the lines can be cleared</em> - that is why the concept of the horizon is so important from a practical point of view. <br><br>  If a transaction holds a snapshot for a long time, it will also hold the event horizon of the database.  Moreover, an incomplete transaction will hold the horizon by the very fact of its existence, even if it does not hold a snapshot. <br><br>  This means that irrelevant versions of rows in this database cannot be cleared.  At the same time, a ‚Äúlong-running‚Äù transaction may not intersect with other transactions in any way - this is completely irrelevant, the database has one horizon for all. <br><br>  If now, in the form of a segment, not to depict transactions, but snapshots (from snapshot.xmin to snapshot.xmax), then the situation can be imagined as follows: <br><br><img src="https://habrastorage.org/webt/nd/ve/wi/ndvewikoeiljposax85zp7mmmn8.png"><br><br>  In this figure, the lowest snapshot refers to an incomplete transaction, and in the remaining snapshots, snapshot.xmin cannot be greater than its number. <br><br>  In our example, a transaction was started with the Read Committed isolation level.  Even though there is no active snapshot of data in it, it continues to hold the horizon: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">1.00</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  And only after the completion of the transaction, the horizon moves forward, allowing you to clear out irrelevant versions of the lines: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3700 (1 row)</code> </pre><br>  If the described situation really creates problems and there is no way to avoid it at the application level, then, starting from version 9.6, two parameters are available: <br><br><ul><li>  <em>old_snapshot_threshold</em> determines the maximum lifetime of a snapshot.  After this time, the server gets the right to delete irrelevant versions of strings, and if they are needed by a ‚Äúlong-playing‚Äù transaction, but it will receive a snapshot too old error. </li><li>  <em>idle_in_transaction_session_timeout</em> determines the maximum lifetime of an inactive transaction.  After this time, the transaction is aborted. </li></ul><br><h1>  Export Snapshot </h1><br>  There are situations when several parallel transactions must be guaranteed to see the same data pattern.  An example is the pg_dump utility, which can work in parallel mode: all workflows should see the database in the same state in order for the backup to be consistent. <br><br>  Of course, one cannot rely on the fact that the pictures of the data will coincide simply because the transactions are running ‚Äúat the same time‚Äù.  For this there is a mechanism for exporting and importing a snapshot. <br><br>  The pg_export_snapshot function returns a snapshot identifier that can be transferred (by means external to the DBMS) to another transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">--  </span></span></code> </pre><pre> <code class="plaintext hljs"> count ------- 3 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_export_snapshot();</code> </pre><pre> <code class="plaintext hljs"> pg_export_snapshot --------------------- 00000004-00000E7B-1 (1 row)</code> </pre><br>  Another transaction can import a snapshot using the SET TRANSACTION SNAPSHOT command before executing the first query in it.  You must first set the isolation level Repeatable Read or Serializable, because at the Read Committed level, operators will use their own snapshots. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span> <span class="hljs-string"><span class="hljs-string">'00000004-00000E7B-1'</span></span>;</code> </pre><br>  Now the second transaction will work with the snapshot of the first and, accordingly, see three lines (and not zero): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><br>  The lifetime of the exported snapshot is the same as the lifetime of the export transaction. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><br>  To be continued. </div><p>Source: <a href="https://habr.com/ru/post/446652/">https://habr.com/ru/post/446652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446642/index.html">Checklist for creating and publishing web applications</a></li>
<li><a href="../446644/index.html">How to lead SMM in 2019: 17 charts from Neil Patel</a></li>
<li><a href="../446646/index.html">InterSystems IRIS 2019.1 release</a></li>
<li><a href="../446648/index.html">Developing Kubernetes operator with Operator Framework</a></li>
<li><a href="../446650/index.html">How much do testers cost and what do their salaries depend on? Build a portrait of a successful QA-specialist</a></li>
<li><a href="../446654/index.html">How we saved the code review</a></li>
<li><a href="../446656/index.html">Speech coding at 1600 bps with LPCNet neural vocoder</a></li>
<li><a href="../446658/index.html">Interview with Andrei Stankevich about sports programming</a></li>
<li><a href="../446660/index.html">AI, student and big prizes: how to do machine learning in 8th grade</a></li>
<li><a href="../446662/index.html">Transactions and their control mechanisms</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>