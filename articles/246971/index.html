<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dirty tricks with macros C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I want to do two things: to tell why macros are evil and how to deal with it, as well as to demonstrate a couple of C ++ macros that I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dirty tricks with macros C ++</h1><div class="post__text post__text-html js-mediator-article">  In this article I want to do two things: to tell why macros are evil and how to deal with it, as well as to demonstrate a couple of C ++ macros that I use that simplify working with code and improve its readability.  The tricks are not really dirty: <br><ul><li>  Safe method call </li><li>  Unused variables </li><li>  String conversion </li><li>  Comma in the macro argument </li><li>  Endless cycle </li></ul><br>  I warn you in advance: if you are thinking of seeing something cool, puzzling and mind blowing under the cut, then there is nothing like that in the article.  An article about the bright side of macros. <a name="habracut"></a><br><br><h2>  Some useful links </h2><br>  For beginners: <a href="http://www.iar.com/Global/Resources/Developers_Toolbox/C_Cplusplus_Programming/Tips%2520and%2520tricks%2520using%2520the%2520preprocessor%2520%2528part%2520one%2529.pdf">Anders Lindgren</a> article <a href="http://www.iar.com/Global/Resources/Developers_Toolbox/C_Cplusplus_Programming/Tips%2520and%2520tricks%2520using%2520the%2520preprocessor%2520%2528part%2520one%2529.pdf">- Tips and tricks using the preprocessor (part one)</a> covers the very basics of macros. <br>  For advanced: <a href="http://www.iar.com/Global/Resources/Developers_Toolbox/C_Cplusplus_Programming/Tips%2520and%2520tricks%2520using%2520the%2520preprocessor%2520%2528part%2520two%2529.pdf">Anders Lindgren</a> article <a href="http://www.iar.com/Global/Resources/Developers_Toolbox/C_Cplusplus_Programming/Tips%2520and%2520tricks%2520using%2520the%2520preprocessor%2520%2528part%2520two%2529.pdf">- Tips and tricks using the preprocessor (part two)</a> covers more serious topics.  Something will be in this article, but not all, and with fewer explanations. <br>  For professionals: article (in English) <a href="http://www.stroustrup.com/icsm-2012-demacro.pdf">Aditya Kumar, Andrew Sutton, Bjarne Stroustrup - Rejuvenating C ++ Programs through Demacrofication</a> , describes the possibilities for replacing macros with C ++ 11 features. <br><br><h2>  Slight cultural difference </h2><br>  According to <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580_%25D0%25A1%25D0%25B8">Wikipedia</a> and my own feelings, in Russian we usually mean by the word ‚Äúmacro‚Äù this: <pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNC(x, y) ((x)^(y))</span></span></code> </pre>  And the following: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VALUE 1</span></span></code> </pre>  we call it the ‚Äúpreprocessor constant‚Äù (or simply ‚Äúdefaults‚Äù).  In English, a little bit wrong: the first is called function-like macro, and the second is object-like macro (again, I‚Äôll provide a link to <a href="https://en.wikipedia.org/wiki/C_preprocessor">Wikipedia</a> ).  That is, when they talk about macros, they can mean both one and the other, and all together.  Be careful when reading English texts. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  What is good and what is bad </h2><br>  Recently, the popular opinion is that <b>macros are evil</b> .  Opinion is not groundless, but, in my opinion, needs clarification.  <a href="http://stackoverflow.com/a/14041847">In one of the answers</a> to the question <a href="http://stackoverflow.com/questions/14041453/why-are-preprocessor-macros-evil-and-what-are-the-alternatives">Why are the preprocessor macros evil and what are the alternatives?</a>  I found a fairly complete list of reasons forcing us to consider macros as evil and some ways to get rid of them.  Below I will give the same list in Russian, but the examples and solutions to the problems will not be exactly the same as in the indicated link. <br><ol><li><div class="spoiler">  <b class="spoiler_title">Macros cannot be debugged</b> <div class="spoiler_text">  First, in fact, you can: <blockquote>  <a href="http://stackoverflow.com/a/1391012">Go to either "Properties".</a>  <a href="http://stackoverflow.com/a/1391012">Under Configuration Properties-&gt; C / C ++ -&gt; Preprocessor, set "Generate Prepared File", you prefer.</a>  <a href="http://stackoverflow.com/a/1391012">This will show what your macro expands to in context.</a>  <a href="http://stackoverflow.com/a/1391012">If you need to compile a code, you need to go.</a> </blockquote>  So, it would be more correct to say that ‚Äúmacros are difficult to debug‚Äù.  But, nevertheless, the problem with debugging macros exists. <br><br>  To determine if the macro you are using needs debugging, consider whether there is something in it that you want to push a breakpoint for.  This can be a change in values ‚Äã‚Äãobtained through parameters, a declaration of variables, a change in objects or data from the outside, and the like. </div></div>  Solutions to the problem: <br><ul><li>  get rid of macros completely by replacing them with functions (you can inline if this is important), </li><li>  the logic of macros is transferred to functions, and the macros themselves must be made responsible only for the transfer of data to these functions, </li><li>  use only macros that do not require debugging. </li></ul></li><li><div class="spoiler">  <b class="spoiler_title">When deploying a macro, strange side effects may occur.</b> <div class="spoiler_text">  In order to show which side effects are involved, an example is usually given with arithmetic operations.  I, too, will not depart from this tradition: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #define SUM(a, b) a + b int main() { //    x? int x = SUM(2, 2); std::cout &lt;&lt; x &lt;&lt; std::endl; x = 3 * SUM(2, 2); std::cout &lt;&lt; x &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre>  In the output we expect 4 and 12, and we get 4 and 8. The fact is that the macro simply substitutes the code where indicated.  And in this case, the code will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre>  This is a side effect.  For everything to work, as expected, you need to change our macro: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #define SUM(a, b) (a + b) int main() { //    x? int x = SUM(2, 2); std::cout &lt;&lt; x &lt;&lt; std::endl; x = 3 * SUM(2, 2); std::cout &lt;&lt; x &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre>  Now is true.  But that is not all.  Let's go to the multiplication: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MULT(a, b) a * b</span></span></code> </pre>  Immediately, we write it ‚Äúcorrectly‚Äù, but use it a little differently: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #define MULT(a, b) (a * b) int main() { //    x? int x = MULT(2, 2); std::cout &lt;&lt; x &lt;&lt; std::endl; x = MULT(3, 2 + 2); std::cout &lt;&lt; x &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre>  Deja vu: again we get 4 and 8. In this case, the expanded macro will look like: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre>  That is, now we need to write: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MULT(a, b) ((a) * (b))</span></span></code> </pre>  Use this version of the macro and voila: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #define MULT(a, b) ((a) * (b)) int main() { //    x? int x = MULT(2, 2); std::cout &lt;&lt; x &lt;&lt; std::endl; x = MULT(3, 2 + 2); std::cout &lt;&lt; x &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre>  Now everything is correct. <br><br>  If we abstract from arithmetic operations, then, in general, when writing macros, we need <br><ul><li>  brackets around the whole expression </li><li>  brackets around each of the macro parameters </li></ul>  That is, instead <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHOOSE(ifC, chooseA, otherwiseB) ifC ? chooseA : otherwiseB</span></span></code> </pre>  must be <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHOOSE(ifC, chooseA, otherwiseB) ((ifC) ? (chooseA) : (otherwiseB))</span></span></code> </pre><br>  This problem is aggravated by the fact that not all types of parameters can be wrapped in brackets (the real example will be further in the article).  Because of this, it is quite difficult to make high-quality macros. <br><br>  In addition, as the <a href="https://habrahabr.ru/users/encyclopedist/" class="user_link">encyclopedist</a> recalled in the comments, there are times when brackets do not save: <br><blockquote>  In the paragraph about side effects, you still forgot to mention a frequent problem - macros can calculate their arguments several times.  In the worst case, this leads to strange side effects, and more easily, to performance problems. <br>  Example <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SQR(x) ((x) * (x)) y = SQR(x++);</span></span></code> </pre></blockquote></div></div>  Solutions to the problem: <br><ul><li>  drop macros in favor of functions </li><li>  use macros with a clear name, a simple implementation and well-placed brackets, so that a programmer using such a macro can easily understand how to use it correctly. </li></ul></li><li><div class="spoiler">  <b class="spoiler_title">Macros have no namespace</b> <div class="spoiler_text">  If any macro is declared, it is not only global, but also simply will not allow to use something with the same name (the implementation of the macro will always be substituted).  The most probably well-known example is the <a href="http://easy-coding.blogspot.ru/2009/02/stdmin-stdmax-visual-studio.html">problem with min and max under Windows</a> . </div></div>  The solution to the problem is to choose names for macros that are less likely to intersect with something, for example: <br><ul><li>  names in UPPERCASE, they can usually intersect only with other macro names, </li><li>  names with a prefix (the name of your project, namespace, something else unique), intersection with other names will be possible with very little probability, but it will be a little more difficult for people to use such macros outside of your project. </li></ul></li><li><div class="spoiler">  <b class="spoiler_title">Macros can do something that you do not suspect.</b> <div class="spoiler_text">  In fact, this is the problem of choosing a name for a macro.  Let's say we take the same example, which is given in the answer by reference: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> begin() x = 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> end() x = 17 ... a few thousand lines of stuff here ... void dostuff() { int x = 7; begin(); ... more code using x ... printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x=%d\n"</span></span></span><span class="hljs-meta">, x); end(); }</span></span></code> </pre>  Here there are incorrectly chosen names that are misleading.  If the macros were called set0toX () and set17toX () or something similar, problems would have been avoided. </div></div>  Solutions to the problem: <br><ul><li>  correctly call macros, </li><li>  replace macros with functions </li><li>  Do not use macros that implicitly change anything. </li></ul></li></ol><br>  After all of the above, you can define "good" macros.  Good macros are macros that <br><ul><li>  do not require debugging (there‚Äôs simply no need to put a breakpoint inside) </li><li>  do not have side effects when unfolding (everything is wrapped in brackets) </li><li>  do not conflict with names anywhere (such kind of names are chosen, which with a small degree of probability will be used by someone else) </li><li>  do not change anything implicitly (the name accurately reflects what the macro does, and all work with the surrounding code, if possible, is carried out only through parameters and ‚Äúreturn value‚Äù) </li></ul><br><h2>  Safe method call </h2><br><div class="spoiler">  <b class="spoiler_title">The old version, not tested Habrom</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> prefix_safeCall(value, object, method) ((object) ? ((object)-&gt;method) : (value)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> prefix_safeCallVoid(object, method) ((object) ? ((void)((object)-&gt;method)) : ((void)(0)))</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Actually, I used this version</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> prefix_safeCall(defaultValue, objectPointer, methodWithArguments) ((objectPointer) ? ((objectPointer)-&gt;methodWithArguments) : (defaultValue)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> prefix_safeCallVoid(objectPointer, methodWithArguments) ((objectPointer) ? static_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;void&gt;((objectPointer)-&gt;methodWithArguments) : static_cast&lt;void&gt;(0))</span></span></span></span></code> </pre>  But Habr is not an IDE, so these long lines look ugly (at least on my monitor), and I shortened them to a readable form. </div></div><br>  <a href="https://habrahabr.ru/users/tenzink/" class="user_link">tenzink</a> in the comments <b>pointed out the problem with these macros</b> , which I safely did not consider when writing the article: <br><pre> <code class="cpp hljs">prefix_safeCallVoid(getObject(), method());</code> </pre>  With this call, getObject will be called twice. <br><br>  Unfortunately, as the article showed, not every programmer will guess about this, so I can no longer consider these macros to be good.  :-( <br><br>  Nevertheless, I encountered similar macros (somewhat differently implemented) in real production code, they were used by a team of programmers, including me.  Any problems because of them in my memory did not arise <br></div></div><br>  The new version, which appeared thanks to <a href="https://habrahabr.ru/users/lemelisk/" class="user_link">lemelisk</a> and C ++ 14: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> prefix_safeCall(defaultValue, objectPointer, methodWithArguments)\ [&amp;](auto&amp;&amp; ptr) -&gt; decltype(auto)\ {\ return ptr ? (ptr-&gt;methodWithArguments) : (defaultValue);\ }\ (objectPointer) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> prefix_safeCallVoid(objectPointer, methodWithArguments)\ [&amp;](auto&amp;&amp; ptr)\ {\ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(ptr)\ (ptr-&gt;methodWithArguments); \ }\ (objectPointer)</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Version for C ++ 11</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> prefix_safeCallBaseExpression(defaultValue, objectPointer, methodWithArguments)\ ((ptr) ? ((ptr)-&gt;methodWithArguments) : (defaultValue)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> prefix_safeCall(defaultValue, objectPointer, methodWithArguments)\ [&amp;](decltype((objectPointer))&amp;&amp; ptr)\ -&gt; decltype(prefix_safeCallBaseExpression(defaultValue, ptr, methodWithArguments))\ {\ return prefix_safeCallBaseExpression(defaultValue, ptr, methodWithArguments);\ }\ (objectPointer) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> prefix_safeCallVoid(objectPointer, methodWithArguments)\ [&amp;](decltype((objectPointer))&amp;&amp; ptr)\ {\ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ptr)\ (ptr-&gt;methodWithArguments);\ }\ (objectPointer)</span></span></code> </pre> </div></div><br>  Notice the methodWithArguments parameter.  This is the very example of a parameter that cannot be wrapped with parentheses.  This means that in addition to calling the method in the parameter, you can stuff something else.  However, by chance it is quite problematic to arrange this, so I do not consider these macros to be ‚Äúbad‚Äù. <br><br>  In addition, now we have added overhead to the call of lambda.  Theoretically, it can be assumed that the lambda, called in the same place where it is defined, will be inline.  But I did not find confirmation of this on the network, so it would be best to check it ‚Äúmanually‚Äù for your compiler. <br><br>  How these two macros are used is, I think, understandable.  If we have code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> somePointer = ...; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(somePointer) somePoiter-&gt;callSomeMethod();</code> </pre>  then using the safeCallVoid macro, it turns into: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> somePointer = ...; prefix_safeCallVoid(somePointer, callSomeMethod());</code> </pre>  and, similarly, for the case with the return value: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> somePointer = ...; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = prefix_safeCall(<span class="hljs-number"><span class="hljs-number">0</span></span>, somePointer, callSomeMethod());</code> </pre><br>  <b>For what?</b>  First of all, these macros allow you to increase the readability of the code, reduce nesting.  The greatest positive effect is given in conjunction with small methods (that is, if you follow the principles of refactoring). <br><br><h2>  Unused variables </h2><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> prefix_unused(variable) ((void)variable)</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Actually, the version I use is also different.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> prefix_unused1(variable1) static_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;void&gt;(variable1) #define prefix_unused2(variable1, variable2) static_cast&lt;void&gt;(variable1), static_cast&lt;void&gt;(variable2) #define prefix_unused3(variable1, variable2, variable3) static_cast&lt;void&gt;(variable1), static_cast&lt;void&gt;(variable2), static_cast&lt;void&gt;(variable3) #define prefix_unused4(variable1, variable2, variable3, variable4) static_cast&lt;void&gt;(variable1), static_cast&lt;void&gt;(variable2), static_cast&lt;void&gt;(variable3), static_cast&lt;void&gt;(variable4) #define prefix_unused5(variable1, variable2, variable3, variable4, variable5) static_cast&lt;void&gt;(variable1), static_cast&lt;void&gt;(variable2), static_cast&lt;void&gt;(variable3), static_cast&lt;void&gt;(variable4), static_cast&lt;void&gt;(variable5)</span></span></span></span></code> </pre>  Please note that, starting from two parameters, this macro can theoretically have side effects.  For greater reliability, you can use the classics: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> unused2(variable1, variable2) do {static_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;void&gt;(variable1); static_cast&lt;void&gt;(variable2);} while(false)</span></span></span></span></code> </pre>  But, in this form, it is harder to read, which is why I use the less ‚Äúsafe‚Äù option. <br></div></div><br>  Such a macro is, for example, in cocos2d-x, where it is called CC_UNUSED_PARAM.  Among the shortcomings: theoretically, it may not work on all compilers.  However, in cocos2d-x it is defined exactly the same for all platforms. <br><br>  Using: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  . prefix_unused(a); return 0; }</span></span></code> </pre><br>  <b>For what?</b>  This macro avoids a warning about an unused variable, and it seems to the reader who reads the code: ‚Äúthe one who wrote this knew that the variable is not used, everything is in order‚Äù. <br><br><h2>  String conversion </h2><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> prefix_stringify(something) std::string(#something)</span></span></code> </pre><br>  Yes, this is so severe, immediately in std :: string.  We will leave the pros and cons of using the string class outside the scope of the conversation, let's talk only about the macro. <br><br>  You can use it like this: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; prefix_stringify(<span class="hljs-string"><span class="hljs-string">"string\n"</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre>  And so: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; prefix_stringify(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; prefix_stringify(<span class="hljs-string"><span class="hljs-string">"string\n"</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre>  And even so: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; prefix_stringify(#define prefix_stringify(something) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(#something) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; prefix_stringify(<span class="hljs-string"><span class="hljs-string">"string\n"</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre>  However, in the last example, the line break will be replaced with a space.  For real transfer you need to use '\ n': <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; prefix_stringify(#define prefix_stringify(something) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(#something)\nstd::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; prefix_stringify(<span class="hljs-string"><span class="hljs-string">"string\n"</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre>  You can also use other characters, for example, '\' for string concatenation, '\ t', and others. <br><br>  <b>For what?</b>  It can be used to simplify the output of debug information or, for example, to create a factory of objects with text id (in this case, such a macro can be used when registering a class in a factory to turn a class name into a string). <br><br><h2>  Comma in macro parameter </h2><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> prefix_singleArgument(...) __VA_ARGS__</span></span></code> </pre><br>  <a href="http://stackoverflow.com/a/13842612">The idea is peeped here</a> . <br><br>  An example from the same place: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FOO(type, name) type name FOO(prefix_singleArgument(std::map</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int, int&gt;), map_var);</span></span></span></span></code> </pre><br>  <b>For what?</b>  It is used when it is necessary to transfer an argument to another macro, containing commas, as one argument and the impossibility to use brackets for this. <br><br><h2>  Endless cycle </h2><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> forever() for(;;)</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Version by Joel Spolsky</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ever (;;) for ever { ... }</span></span></code> </pre>  PS If someone, following the link, did not guess to read the name of the question, then it sounds like ‚Äúwhat is the worst real abuse of macros you have encountered?‚Äù ;-) </div></div><br>  Using: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> keyPressed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; forever() { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(keyPressed) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  <b>For what?</b>  When while (true), while (1), for (;;), and other standard loop creation paths do not seem too informative, you can use a similar macro.  The only plus he gives is a slightly better readability of the code. <br><br><h2>  Conclusion </h2><br>  When used correctly, macros are not at all something bad.  The main thing is not to abuse them and follow the simple rules for creating "good" macros.  And then they will become your best assistants. <br><br>  <b>Upd</b> .  Returned to the article "Safe method call", thanks to <a href="https://habrahabr.ru/users/lemelisk/" class="user_link">lemelisk</a> for the hint with lambdas. <br><br>  PS <br>  And what interesting macros do you use in your projects?  Feel free to share in the comments. </div><p>Source: <a href="https://habr.com/ru/post/246971/">https://habr.com/ru/post/246971/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246961/index.html">Really transparent WCF usage</a></li>
<li><a href="../246963/index.html">About the diagonal of the square</a></li>
<li><a href="../246965/index.html">Functional programming in Swift. Start</a></li>
<li><a href="../246967/index.html">Happy New Year!</a></li>
<li><a href="../246969/index.html">When technology outpaces needs: how did they think about IT development in 1985</a></li>
<li><a href="../246973/index.html">Hacker's guide to neural networks. Chapter 2: Machine Learning. We generalize SVM to a neural network.</a></li>
<li><a href="../246975/index.html">Assembler in 30 lines on Excel</a></li>
<li><a href="../246977/index.html">YACTL: Another Christmas tree garland</a></li>
<li><a href="../246979/index.html">This is correct, but wrong</a></li>
<li><a href="../246981/index.html">Numcap - npm to determine the operator and region by phone number</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>