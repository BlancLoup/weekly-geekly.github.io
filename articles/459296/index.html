<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript price in 2019</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Over the past few years in what is called the ‚Äú price of JavaScript ‚Äù, there have been significant positive changes due to the increased speed of pars...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript price in 2019</h1><div class="post__text post__text-html js-mediator-article">  Over the past few years in what is called the ‚Äú <a href="https://habr.com/ru/company/ruvds/blog/419369/">price of JavaScript</a> ‚Äù, there have been significant positive changes due to the increased speed of parsing and compiling scripts by browsers.  Now, in 2019, the main components of the load on the system generated by JavaScript are the load time of scripts and their execution time. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/459296/"><img src="https://habrastorage.org/webt/7x/g6/g_/7xg6g_poas_6_4qwu5u4clgjxrs.jpeg"></a> <br><br>  The user's interaction with the site may be temporarily disrupted if the browser is busy executing JavaScript code.  As a result, we can say that optimization of bottlenecks associated with loading and executing scripts can have a strong positive impact on the performance of sites. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">General practice recommendations for website optimization</font> </h2><br>  What does the above mean for web developers?  The point here is that the resources spent on parsing (parsing, parsing) and compiling scripts are not as serious as they used to be.  Therefore, when analyzing and optimizing JavaScript bundles, developers should heed the following three recommendations: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Strive to reduce the time required to download scripts. <br><br><ul><li>  Try to keep your JS bundles small.  This is especially important for sites designed for mobile devices.  Using small bundles improves code loading time, reduces memory usage, and reduces processor load. </li><li>  Try to ensure that the entire project code is not represented as a single large bundle.  If the size of a bundle exceeds approximately 50-100 Kb, divide it into separate fragments of a small size.  Thanks to HTTP / 2 multiplexing, multiple requests to the server and processing of multiple responses can be performed at the same time.  This reduces the load on the system associated with the need to perform additional requests to load data. </li><li>  If you are working on a mobile project - try to keep the code as small as possible.  This recommendation is associated with low data rates on mobile networks.  Also, strive for economical use of memory. </li></ul></li><li>  Aim to reduce the time required to execute scripts. <br><br><ul><li>  Avoid using <a href="https://w3c.github.io/longtasks/">lengthy tasks</a> that can load the main thread for a long time and increase the time it takes for the pages to be in a state in which users can interact with them.  Under current conditions, the execution of scripts, which occurs after they are loaded, makes the main contribution to the ‚ÄúJavaScript price‚Äù. </li></ul></li><li>  Do not embed large code snippets into pages. <br><br><ul><li>  Here it is worth adhering to the following rule: if the size of the script exceeds 1 Kb - try not to embed it in the page code.  One of the reasons for this recommendation is the fact that 1 Kb is the limit after which the <a href="https://v8.dev/blog/code-caching-for-devs">caching</a> of external script code starts working in Chrome.  Also, keep in mind that parsing and compiling embedded scripts are still performed in the main thread. </li></ul></li></ol><br><h2>  <font color="#3AC1EF">Why is loading and executing scripts so important?</font> </h2><br>  Why in modern conditions it is important to optimize the load time and run scripts?  Script loading time is extremely important in situations where sites are operated via slow networks.  Despite the fact that 4G (and even 5G) networks are increasingly spreading in the world, the <a href="https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType">NetworkInformation.effectiveType</a> property in many cases of using mobile Internet connections shows indicators that are at the level of 3G networks or even at lower levels. <br><br>  The time it takes to execute a JS code is important for mobile devices with slow processors.  Due to the fact that various CPUs and GPUs are used in mobile devices, due to the fact that when devices overheat, for the sake of their protection, the performance of their components decreases, a serious gap between the performance of expensive and cheap phones and tablets can be observed.  This greatly affects the performance of the JavaScript code, since the ability to execute such a code by some device is limited by the processor's capabilities of this device. <br><br>  In fact, if you analyze the total time spent on loading and preparing a page in a browser like Chrome, about 30% of this time can be spent on JS code execution.  Below is a load analysis of a very typical web page (reddit.com) on a high-performance desktop. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/8f6/af0/31d8f6af06d7158ecc9bd17710d216bb.png"></div><br>  <i><font color="#999999">In the process of loading the page about 10-30% of the time is spent on code execution by means of V8</font></i> <br><br>  If we talk about mobile devices, then on an average phone (Moto G4) to execute the JS code reddit.com takes 3-4 times longer than on a high-level device (Pixel 3).  On a weak device (Alcatel 1X worth less than $ 100) it takes at least 6 times more time to solve the same problem than on something like Pixel 3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71a/4f0/3a9/71a4f03a9f7d673740c6917f30cee360.png"></div><br>  <i><font color="#999999">The time required to process the JS code on mobile devices of different classes</font></i> <br><br>  Please note that the mobile and desktop versions of reddit.com are different.  Therefore, you can not compare the results of mobile devices and, say, MacBook Pro. <br><br>  When you are trying to optimize the execution time of the JavaScript code - pay attention to <a href="https://web.dev/long-tasks-devtools/">long-term tasks</a> that can permanently capture the UI stream.  These tasks can interfere with the performance of other, extremely important tasks, even when externally the page looks completely ready for work.  Long tasks should be broken down into smaller tasks.  Dividing the code into parts and controlling the order of loading of these parts can ensure that the pages will come to an interactive state more quickly.  This, hopefully, will result in users having less inconvenience in interacting with the pages. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/002/eef/32b/002eef32b869be9ae677bc41b41c86c2.png"></div><br>  <i><font color="#999999">Long tasks capture the main stream.</font></i>  <i><font color="#999999">They should be broken apart</font></i> <br><br><h2>  <font color="#3AC1EF">How to improve V8 affect the acceleration of parsing and compiling scripts?</font> </h2><br>  The speed of parsing the source JS code in V8, since the time of Chrome 60, has increased 2 times.  At the same time, parsing and compiling now make a smaller contribution to the ‚ÄúJavaScript price‚Äù.  This is due to other work on optimizing Chrome, leading to the parallelization of these tasks. <br><br>  In V8, the amount of work on parsing and compiling code produced in the main stream is reduced by an average of 40%.  For example, for Facebook, the improvement of this indicator was 46%, for Pinterest - 62%.  The highest score of 81% was obtained for YouTube.  Such results are possible due to the fact that parsing and compilation are moved to a separate stream.  And this is in addition to the already existing improvements concerning the streaming solution of the same tasks outside the main stream. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a7/41e/24c/4a741e24c05a9149d98ee568be74b564.png"></div><br>  <i><font color="#999999">JS parsing time in different versions of Chrome</font></i> <br><br>  You can also visualize how the V8 optimizations produced in different versions of Chrome affect the processor time required to process the code.  During the same time that Chrome 61 needed to parse the JS-code of Facebook, Chrome 75 can now parse the JS-code of Facebook and, in addition, parse the Twitter code 6 times. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6b/000/0e0/c6b0000e0b2bb98087ff12f8a9eb0d97.png"></div><br>  <i><font color="#999999">In the time that Chrome 61 needed to process the JS-code of Facebook, Chrome 75 can process both the Facebook code and the six-fold amount of Twitter code</font></i> <br><br>  Let's talk about how these improvements were achieved.  In a nutshell, the scripting resources can be parsed and compiled streaming in the workflow.  This means the following: <br><br><ul><li>  V8 can parse and compile JS code without blocking the main thread. </li><li> Stream processing of a script starts from the moment when the universal HTML parser encounters a <code>&lt;script&gt;</code> .  HTML parser handles scripts that block page parsing.  Meeting with asynchronous scripts, he continues to work. </li><li>  In most real-world scenarios characterized by certain network connection speeds, V8 parses the code faster than it can load.  As a result, V8 completes the task of parsing and compiling code within a few milliseconds after the last bytes of the script are loaded. </li></ul><br>  If you talk about it all in a little more detail, then the point here is as follows.  In much older versions of Chrome, the script needed to download the entire one before it could be parsed.  This approach is simple and understandable, but when it is used, processor resources are not efficiently used.  Chrome, between versions 41 and 68, starts parsing in asynchronous mode, immediately after the script has started loading, performing this task in a separate thread. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/574/43a/4fd/57443a4fd274a348de26652d006941c3.png"></div><br>  <i><font color="#999999">Scripts come to the browser fragments.</font></i>  <i><font color="#999999">V8 starts streaming data after it has at least 30 KB of code.</font></i> <br><br>  In Chrome 71, we moved to a task-based system.  Here the scheduler can simultaneously start several sessions of asynchronous / delayed script processing.  Due to this change, the load created by parsing to the main thread has decreased by about 20%.  This resulted in an estimated 2% improvement in TTI / FIDs from real sites. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3f/161/863/a3f16186348f3773a04f7caccc185592.png"></div><br>  <i><font color="#999999">Chrome 71 uses a task-based code processing system.</font></i>  <i><font color="#999999">With this approach, the scheduler can process several asynchronous / deferred scripts simultaneously.</font></i> <br><br>  In Chrome 72, we did stream processing in the basic way of script parsing.  Now even ordinary synchronous scripts are processed this way (although this does not apply to built-in scripts).  In addition, we have stopped canceling parsing operations based on tasks, in case the main thread needs parsed code.  This is done because it leads to the need to re-perform some part of the work already done. <br><br>  <a href="https://v8.dev/blog/v8-release-75">In the previous version of Chrome, there</a> was support for streaming parsing and streaming code compilation.  Then the script, loaded from the network, had to first get into the main stream, and then redirected to the stream processing system scripts. <br><br>  This often led to the fact that the stream parser had to wait for data that is already downloaded from the network but not yet redirected by the main stream for stream processing.  This happened because the main thread could be busy with some other tasks (such as parsing HTML, creating page layout or executing JS code). <br><br>  Now we are experimenting to start parsing the code when preloading pages.  Previously, the implementation of such a mechanism was hampered by the need to use the resources of the main stream to transfer jobs to the stream parser.  Details about parsing JS-code that runs "instantly" can be found <a href="https://www.youtube.com/watch%3Fv%3DD1UJgiG4_NI">here</a> . <br><br><h2>  <font color="#3AC1EF">How have improvements affected what you can see in the developer tools?</font> </h2><br>  In addition to the above, it can be noted that in the developer‚Äôs tools there used to be one <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D939275">problem</a> .  It consisted in the fact that information about the task of parsing was derived as if they completely blocked the main stream.  However, the parser performed operations blocking the main thread only when it needed new data.  Since we have moved from a single-stream use scheme for stream processing to a stream processing scheme, this has become quite obvious.  This is what you could see in Chrome 69. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/b4c/ab0/87cb4cab05a3c00e7b21dfc25524a9c8.png"></div><br>  <i><font color="#999999">The problem in the developer tools, because of which information about parsing scripts were displayed as if they completely blocked the main thread</font></i> <br><br>  Here you can see that the Parse Script task takes 1.08 seconds.  But parsing javascript is actually not so slow!  Most of this time, nothing useful is done except for waiting for data from the main stream. <br>  In Chrome 76, you can see a completely different picture. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef8/874/e37/ef8874e37664a31f03c822c71feb0fa8.png"></div><br>  <i><font color="#999999">In Chrome 76, the parsing procedure is divided into many small tasks.</font></i> <br><br>  In general, it can be noted that the Performance tab of the developer tools is great for seeing the overall picture of what is happening on the page.  In order to get more detailed information reflecting V8 features, such as parsing time and compile time, you can use the Chrome Tracing tool with RCS (Runtime Call Stats) support.  In the received RCS data, you can find the indicators Parse-Background and Compile-Background.  They are able to report how much time it took to parse and compile the JS code outside the main thread.  The Parse and Compile values ‚Äã‚Äãindicate how much time was spent on the corresponding actions in the main thread. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a4/200/d26/3a4200d269fe47bedac1d84c27722a2b.png"></div><br>  <i><font color="#999999">Analyzing RCS data using Google Tracing</font></i> <br><br><h2>  <font color="#3AC1EF">How did the changes affect the work with real sites?</font> </h2><br>  Let's look at a few examples of how stream processing scripts influenced the viewing of real sites. <br><br><h3>  <font color="#3AC1EF">‚ñçReddit</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/4ba/270/d774ba2709a772bbcfb26294b67ab385.png"></div><br>  <i><font color="#999999">View reddit.com on the MacBook Pro.</font></i>  <i><font color="#999999">Time to parse and compile JS code spent in the main and in the workflow</font></i> <br><br>  Reddit.com has several JS-bundles, each of which exceeds 100 Kb in size.  They are wrapped with external functions, which results in large volumes <a href="https://v8.dev/blog/preparser">of lazy compilation</a> in the main thread.  The time required for processing scripts in the main thread is crucial in the above scheme.  This is due to the fact that a large load on the main thread can increase the time it takes for a page to go online.  When processing the reddit.com site code, most of the time is spent in the main thread, and the resources of the working / background stream are used to a minimum. <br><br>  It would be possible to optimize this site by dividing some large bundles into parts (about 50 Kb each) and doing without wrapping the code in a function.  This would maximize parallel processing of scripts.  As a result, bundles could be simultaneously parsed and compiled in streaming mode.  This would reduce the load on the main stream when preparing the page for work. <br><br><h3>  <font color="#3AC1EF">‚ñçFacebook</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/d83/a53/bc2d83a53f5b73658168e3dba70c9a85.png"></div><br>  <i><font color="#999999">View facebook.com site on macbook pro.</font></i>  <i><font color="#999999">Time to parse and compile JS code spent in the main and in the workflow</font></i> <br><br>  We can also consider a site like facebook.com, which uses about 6 MB of compressed JS code.  This code is loaded using approximately 292 requests.  Some of them are asynchronous, some are aimed at preloading data, some have low priority.  Most Facebook scripts are small and narrow.  This can well affect the parallel processing of data by means of background / workflows.  The fact is that many small scripts can be simultaneously parsed and compiled by means of stream processing scripts. <br><br>  Please note that your site is probably different from Facebook.  You probably do not have applications that are kept open for a long time (like the one that is the Facebook site or the Gmail interface), and when working with which, it can be justified to load such serious volumes of scripts with a desktop browser.  But despite this, we can give a general recommendation that is valid for any projects.  It lies in the fact that the application code should be broken into bundles of a modest size, and the fact that you need to download these bundles only when they are needed. <br><br>  Although most of the work on parsing and compiling JS code can be performed using streaming tools in a background thread, some operations still require a main stream.  When the main thread is busy with something, the page cannot respond to user input.  Therefore, it is recommended to pay attention to the impact on the UX sites have loading and executing JS-code. <br><br>  Consider that now not all JavaScript engines and browsers implement stream processing of scripts and optimize their loading.  But despite this, we hope that the general optimization principles outlined above can improve the user experience of working with sites viewed in any of the existing browsers. <br><br><h2>  <font color="#3AC1EF">Price parsing json</font> </h2><br>  Parsing JSON code can be much more efficient than parsing JavaScript code.  The point is that the JSON grammar is much simpler than the JavaScript grammar.  This knowledge can be applied in order to improve the speed of preparing for web applications that use large configuration objects (such as Redux repositories), whose structure resembles JSON code.  As a result, it turns out that instead of presenting data in the form of object literals embedded in the code, you can represent them as strings of JSON objects and parse these objects during program execution. <br><br>  The first approach, using JS objects, looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-attr"><span class="hljs-attr">bar</span></span>: <span class="hljs-number"><span class="hljs-number">1337</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  The second approach, using JSON strings, involves the use of such constructs: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(<span class="hljs-string"><span class="hljs-string">'{"foo":42,"bar":1337}'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Since JSON strings must be processed only once, the approach that uses <code>JSON.parse</code> is much faster than using JavaScript object literals.  Especially - with the "cold" loading page.  It is recommended to use JSON strings to represent objects with sizes starting at 10 Kb.  However, as with any performance advice, this advice should not be thoughtlessly followed.  Before applying this production presentation technique, you need to make measurements and evaluate its real impact on the project. <br><br>  Using object literals as repositories for large amounts of data carries another threat.  The idea is that there is a risk that such literals can be processed twice: <br><br><ol><li>  The first processing pass is performed during the preliminary parsing of the literal. </li><li>  The second approach is performed in the course of the ‚Äúlazy‚Äù parsing of the literal. </li></ol><br>  It is impossible to get rid of the first pass of processing object literals.  But, fortunately, the second pass can be avoided by placing object literals at the top level or inside <a href="https://v8.dev/blog/preparser">PIFE</a> . <br><br><h2>  <font color="#3AC1EF">What can you say about parsing and compiling code when you re-visit sites?</font> </h2><br>  Optimize the performance of the site for those cases when users visit them more than once, thanks to the caching capabilities of the code and byte-code.  When a script is requested from the server for the first time, Chrome downloads it and sends it to V8 for compilation.  The browser also saves the file of this script in its disk cache.  When the second request is made to download the same JS file, Chrome takes it from the browser cache and passes the V8 again for compilation.  This time, however, the compiled code is serialized and attached to the cached script file as metadata. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b78/216/702/b7821670255f45c9ec4a08217b495153.png"></div><br>  <i><font color="#999999">The work of the code caching system in V8</font></i> <br><br>  When a script is requested for the third time, Chrome takes the file and its metadata from the cache, and then passes the V8 and both.  V8 deserializes metadata and, as a result, may skip the compilation step.  Code caching is triggered if visits are made to the site within 72 hours.  Chrome, moreover, uses the strategy of greedy caching code when a service worker is used to cache scripts.  Details about caching code can be read <a href="https://v8.dev/blog/code-caching-for-devs">here</a> . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  In 2019, the main performance bottlenecks of web pages are loading and executing scripts.  In order to improve the situation - strive to use synchronous (embedded) scripts of small sizes, which are necessary for organizing user interaction with the part of the page that is visible to him immediately after loading.  The scripts used to serve other parts of the pages are recommended to be loaded in deferred mode.  Break large bundles into small pieces.  This will facilitate the implementation of the strategy for working with code, the application of which will only load code when it is needed, and only where it is needed.  This will allow the maximum use of V8 features aimed at parallel code processing. <br><br>  If you are developing mobile projects, then you should strive to ensure that they use as little as possible JS-code.  This recommendation stems from the fact that mobile devices typically operate on fairly slow networks.  Such devices, in addition, may be limited in terms of available RAM and processor resources available to them.  Try to find a balance between the time required to prepare scripts uploaded from the network and using the cache.  This will maximize the amount of work involved in parsing and compiling code that runs outside the main thread. <br><br>  <b>Dear readers!</b>  Do you optimize your web projects taking into account the peculiarities of processing JS-code with modern browsers? <br><br> <a href="https://ruvds.com/turbo_vps/"><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div><p>Source: <a href="https://habr.com/ru/post/459296/">https://habr.com/ru/post/459296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459286/index.html">Semi-metal tungsten telluride - Swiss nanotechnology day knife</a></li>
<li><a href="../459288/index.html">ECS native implementation</a></li>
<li><a href="../45929/index.html">MySpace in Russia: details</a></li>
<li><a href="../459292/index.html">Automation testing of mobile applications: a comparison of tools</a></li>
<li><a href="../459294/index.html">What is more important: to know a programming language or to be able to solve a business problem?</a></li>
<li><a href="../459298/index.html">Angular: state of affairs in 2019</a></li>
<li><a href="../4593/index.html">"Soup" again answers the same questions.</a></li>
<li><a href="../45930/index.html">Russian coding4fun started</a></li>
<li><a href="../459300/index.html">Quasar 1.0: a new useful tool for Vue developers and not only for them.</a></li>
<li><a href="../459302/index.html">Repeat failed HTTP requests in Angular</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>