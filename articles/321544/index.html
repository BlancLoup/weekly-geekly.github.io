<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Events and streams. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I‚Äôll say right away that the article is not about threads, but about events in the context of threads in .NET. Therefore, I will not try to organize t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Events and streams. Part 1</h1><div class="post__text post__text-html js-mediator-article">  I‚Äôll say right away that the article is not about threads, but about events in the context of threads in .NET.  Therefore, I will not try to organize the work of streams correctly (with all the locks, callbacks, cancellations, etc.).  For the proper organization of the flow, there are other articles. <br><br>  All examples will be written in C # for version 4.0 of the framework (at 4.6 everything is somewhat simpler, but there are still many projects at 4.0).  I will also try to stick with C # 5.0. <br><a name="habracut"></a><br>  First, I want to note that there are already ready delegates for the event system in .NET, which I strongly advise you to use and not reinvent the wheel.  For example, I often met these 2 ways of organizing events: <br><br><div class="spoiler">  <b class="spoiler_title">Method 1</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WrongRaiser</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action MyEvent2; }</code> </pre> <br>  I would advise using this method with caution.  If it is not universalized, then you can write as a result more code than you could, which, in doing so, will not define a clearer structure than in the case of the methods below. <br>  From my own experience I can say that I started working with events in this way and eventually ended up in a trouble.  Now I would not allow this, but other methods have already become a habit. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Method 2</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WrongRaiser</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> MyDelegate MyEvent; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyEventArgs</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SomeProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDelegate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, MyEventArgs e</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  This method has the right to life, but it should be used for special cases, when for some reason the method described below does not fit.  Otherwise, you can get a lot of monotonous work. <br></div></div><br>  Now that has already been created for events. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Universal way</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Raiser</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler&lt;MyEventArgs&gt; MyEvent; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyEventArgs</span></span> : <span class="hljs-title"><span class="hljs-title">EventArgs</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SomeProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  As you can see, here we use the generic EventHandler class.  That is, there is no need to define your own handler. <br></div></div><br><br>  For further examples, a universal method will be used. <br><br>  Let's look at the simplest example of an event generator. <br><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EventRaiser</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _counter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler&lt;EventRaiserCounterChangedEventArgs&gt; CounterChanged; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Counter { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _counter; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_counter != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> old = _counter; _counter = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; OnCounterChanged(old, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ThreadStart(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) Counter = i; })).Start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCounterChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CounterChanged != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) CounterChanged.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventRaiserCounterChangedEventArgs(oldValue, newValue)); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EventRaiserCounterChangedEventArgs</span></span> : <span class="hljs-title"><span class="hljs-title">EventArgs</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NewValue { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OldValue { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventRaiserCounterChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { NewValue = newValue; OldValue = oldValue; } }</code> </pre><br>  We have a class that has the Counter property and can change it from 0 to 10. Moreover, the logic that changes the Counter is processed in a separate thread. <br><br>  And here is our entry point. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> raiser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventRaiser(); raiser.CounterChanged += Raiser_CounterChanged; raiser.DoWork(); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Raiser_CounterChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventRaiserCounterChangedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"OldValue: {0}; NewValue: {1}"</span></span>, e.OldValue, e.NewValue)); } }</code> </pre><br>  That is, we create an instance of our generator, subscribe to a change to a counter and change the values ‚Äã‚Äãin the event handler to the console. <br><br>  This is what we get as a result. <br><br><img src="https://habrastorage.org/files/ae9/218/50e/ae921850e62f4e4dbfe827ed31b86dfd.PNG"><br></div></div><br>  While everything is smooth.  But think, and in what flow the event handler is executed? <br><br>  After asking this question to my colleagues, I received the answer ‚Äúmostly‚Äù.  This meant that none of my colleagues understood how delegates work.  I will try to explain it on apples under the spoiler, who already knows everything, can not read. <br><br><div class="spoiler">  <b class="spoiler_title">Device delegates</b> <div class="spoiler_text">  The Delegate class has information about the method. <br>  There is also his heir MulticastDelegate, which has more than one element. <br><br>  So, when you subscribe to an event, an instance of the heir from MulticastDelegate is created.  Each next subscriber adds a new method (event handler) to the already created instance of MulticastDelegate. <br><br>  And when you call the Invoke method, for your event, handlers of all subscribers follow up in turn.  In this case, the thread in which you call these handlers does not know anything about the thread in which they were specified and, accordingly, cannot slip anything into this thread. <br></div></div><br>  In general, the event handlers in the example above are executed in the stream spawned in the DoWork () method.  That is, when generating an event, the thread that generated it in this way waits for all handlers to be executed.  I will prove it without pulling out Id streams, just logically.  For this, I changed a couple of places in the example above. <br><br><div class="spoiler">  <b class="spoiler_title">Proof that all the handlers in the example above are executed in the thread that caused the event</b> <div class="spoiler_text">  The method where we generate the event: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCounterChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CounterChanged != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { CounterChanged.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventRaiserCounterChangedEventArgs(oldValue, newValue)); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Event Raiser: old = {0}, new = {1}"</span></span>, oldValue, newValue)); } }</code> </pre><br>  Handler <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Raiser_CounterChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventRaiserCounterChangedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"OldValue: {0}; NewValue: {1}"</span></span>, e.OldValue, e.NewValue)); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); }</code> </pre><br>  In the handler, we put the current stream to sleep for half a second.  If the handlers worked in the main thread, this time would be enough for the thread generated in DoWork () to complete its work and output its results. <br><br>  But that's what we see in reality. <br><br><img src="https://habrastorage.org/files/f4b/4cc/fcf/f4b4ccfcf65741fabef4577ecd409413.PNG"><br></div></div><br>  I do not know who and how will handle the events generated by the class I wrote, but I don‚Äôt really want these handlers to hang the work of my class.  Therefore, I will use the BeginInvoke method instead of Invoke.  BeginInvoke spawns a new thread. <br><br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text">  Both the Invoke method and the BeginInvoke method are not members of the Delegate or MulticastDelegate class, they are members of the generated class (or for the universal class of the class already described). </div></div><br>  Now, changing the method in which the event is generated, we get the following <br><br><div class="spoiler">  <b class="spoiler_title">Multithread event generation</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCounterChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CounterChanged != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delegates = CounterChanged.GetInvocationList(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; delegates.Length; i++) ((EventHandler&lt;EventRaiserCounterChangedEventArgs&gt;)delegates[i]).BeginInvoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventRaiserCounterChangedEventArgs(oldValue, newValue), <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Event Raiser: old = {0}, new = {1}"</span></span>, oldValue, newValue)); } }</code> </pre><br>  The last two parameters are null.  The first is a callback, the second is a parameter.  I do not use the callback in this example, because the example is intermediate.  It can be useful for feedback, for example, so that the class generating the event can find out whether the event was processed and / or, if necessary, get the results of this processing, and, as suggested in the comments, frees the resources associated with the asynchronous operation. . <br><br>  If we run the program, we get this result. <br><br><img src="https://habrastorage.org/files/dd9/a75/33f/dd9a7533faac4d66bff0bb052b3688ce.PNG"><br></div></div><br>  I think everyone understands that now event handlers are executed in separate threads.  That is, the event generator is now up to the bulb, who, how and for how long will process its events. <br><br>  This raises another question: what about sequential processing?  We have the same Counter.  And what if it would be a successive change of states?  But the answer to this question I will not give you, it does not concern the topic of the current article.  I can only say that there are several ways. <br><br>  Well, and more.  In order not to perform similar actions time after time, I propose to bring them into a separate class. <br><br><div class="spoiler">  <b class="spoiler_title">Class for generating asynchronous events</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AsyncEventsHelper</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RaiseEventAsync&lt;T&gt;(EventHandler&lt;T&gt; h, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sender, T e) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : EventArgs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delegates = h.GetInvocationList(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; delegates.Length; i++) ((EventHandler&lt;T&gt;)delegates[i]).BeginInvoke(sender, e, h.EndInvoke, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } } }</code> </pre><br>  In this case, we use callback.  It is executed in the same thread as the handler.  That is, after the handler method has completed, the delegate calls h.EndInvoke. <br><br>  Use it like this <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCounterChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { AsyncEventsHelper.RaiseEventAsync(CounterChanged, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventRaiserCounterChangedEventArgs(oldValue, newValue)); }</code> </pre><br><br>  I think it has now become clear (if not) why a universal way was needed.  If you describe events in method 2, then such a thing does not work.  Well, or you have to create your own versatility for your delegates. </div></div><br><div class="spoiler">  <b class="spoiler_title">UPDATE:</b> <div class="spoiler_text">  For real projects, I advise you to change the architecture of events in the context of threads.  The described examples can harm the work of the application with threads and are presented only for the experiment and as an introduction. <br></div></div><br><h3>  Conclusion </h3><br>  Hopefully, I was able to convey information about how events work and where handlers work.  In the next part, I plan to go deep and tell you how to get the results of event handling during an asynchronous call. <br><br>  I am waiting for comments with suggestions, additions, questions. </div><p>Source: <a href="https://habr.com/ru/post/321544/">https://habr.com/ru/post/321544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321532/index.html">MIPSfpga and SDRAM. Part 2</a></li>
<li><a href="../321534/index.html">How to get the top five using data analysis?</a></li>
<li><a href="../321538/index.html">VxRail Hyper Converged Devices</a></li>
<li><a href="../321540/index.html">How to fill 100 timeshits in 2 minutes</a></li>
<li><a href="../321542/index.html">PIC Controller Programming Tools</a></li>
<li><a href="../321546/index.html">C # language is almost functional</a></li>
<li><a href="../321548/index.html">How smart contracts will change our lives</a></li>
<li><a href="../321550/index.html">It's hard to be a junior</a></li>
<li><a href="../321552/index.html">The first application on Spring Boot + ReactJS</a></li>
<li><a href="../321554/index.html">About ranks and virtualization in RAM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>