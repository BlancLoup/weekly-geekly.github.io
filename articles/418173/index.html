<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"There and back" for neural networks, or a review of auto-encoder applications in text analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We have already written in the very first article of our corporate blog about how the algorithm for detecting transferable borrowings works. Only a co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"There and back" for neural networks, or a review of auto-encoder applications in text analysis</h1><div class="post__text post__text-html js-mediator-article">  We have already written in the <a href="https://habr.com/company/antiplagiat/blog/354142/">very first article of our corporate blog</a> about how the algorithm for detecting transferable borrowings works.  Only a couple of paragraphs in that article are devoted to the topic of text comparison, although the idea is worthy of a much more detailed description.  However, as you know, it is impossible to tell everything at once, although I really want to.  In an attempt to pay tribute to this topic and the network architecture called ‚Äú <a href="https://habr.com/users/oleg_bakhteev/" class="user_link">auto-encoder</a> ‚Äù, to which we have very warm feelings, we with <a href="https://habr.com/users/oleg_bakhteev/" class="user_link">Oleg_Bakhteev</a> wrote this review. <br><br><img src="https://habrastorage.org/webt/fs/ka/ec/fskaecgqanvbmtzhf4hdqdd0bhw.png"><br>  Source: <a href="https://nlp.stanford.edu/courses/NAACL2013/NAACL2013-Socher-Manning-DeepLearning.pdf">Deep Learning for NLP (without Magic)</a> <br><br>  As we mentioned in that article, we had a ‚Äúsemantic‚Äù comparison of the texts - we compared not the text fragments themselves, but the vectors corresponding to them.  Such vectors were obtained as a result of training of the neural network, which displayed a text fragment of an arbitrary length into a vector of large but fixed dimension.  How to get such a mapping and how to teach the network to produce the desired results is a separate question, which will be discussed below. <br><a name="habracut"></a><br><h1>  What is an auto encoder? </h1><br>  Formally, an autocoder (or autoencoder) is a neural network that trains to reconstruct objects that are taken to the input of the network. <br><img src="https://habrastorage.org/webt/jy/jw/ip/jyjwipnzwzlyidenzeovey3jba4.png"><br>  The autocoder consists of two parts: the encoder <b>f</b> , which encodes the sample <b>X</b> into its internal representation <b>H</b> , and the decoder <b>g</b> , which restores the original sample.  Thus, the auto-encoder tries to combine the restored version of each sample object with the original object. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When training autocoder minimizes the following function: <br><img src="https://habrastorage.org/webt/9f/ay/cm/9faycmmbldgcxvehefjrurcusyq.png"><br><br>  Where <b>r</b> is the recovered version of the original object: <br><img src="https://habrastorage.org/webt/zf/oe/oi/zfoeoiwfxnrscvv0n5cv4keku5k.png"><br><br>  Consider an example presented in <a href="https://blog.keras.io/building-autoencoders-in-keras.html">blog.keras.io</a> : <br><img src="https://habrastorage.org/webt/lw/wp/i_/lwwpi_kn0wyrduexhkqyrg9jttk.png"><br>  The network receives object <b>x</b> as an input (in our case, the number 2). <br><br>  Our network encodes this object in a hidden state.  Then, the reconstruction of the object <b>r</b> , which should be similar to x, is reconstructed from the hidden state.  As we can see, the restored image (on the right) has become more blurred.  This is explained by the fact that we try to save in the hidden view only the most important features of the object, so the object is restored with losses. <br><br>  The autocoder model is trained on the basis of a damaged phone, where one person (encoder) transmits information <b>(x</b> ) to the second person (decoder <b>)</b> , and the latter, in turn, tells it to the third person <b>(r (x))</b> . <br><br>  One of the main purposes of such autocoders is to reduce the dimension of the original space.  When we deal with auto-encoders, the neural network training procedure itself forces the auto-encoder to memorize the main features of the objects, which will make it easier to restore the original objects of the sample. <br><br>  Here we can draw an analogy with the <a href="http://www.machinelearning.ru/wiki/index.php%3Ftitle%3D%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25B3%25D0%25BB%25D0%25B0%25D0%25B2%25D0%25BD%25D1%258B%25D1%2585_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2582">method of principal components</a> : this is the method of reducing the dimension, the result of which is the projection of the sample onto the subspace in which the dispersion of this sample is maximal. <br><br>  Indeed, the auto-encoder is a generalization of the principal component method: in the case where we restrict ourselves to considering linear models, the auto-encoder and the principal component method give the same vector representations.  The difference arises when we consider more complex models, for example, multilayer fully connected neural networks, as an encoder and a decoder. <br><br>  An example of comparing the principal component method and the auto-encoder is presented in the article <a href="https://www.cs.toronto.edu/~hinton/science.pdf">Reducing the Dimensionality of Data with Neural Networks</a> : <br><img src="https://habrastorage.org/webt/bj/ap/hq/bjaphq8tpjla39pbn2djsrm84y4.png"><br><br>  It demonstrates the results of auto-encoder training and the principal component method for sampling images of human faces.  The first line shows the faces of people from the control sample, i.e.  from the specially deferred part of the sample that was not used by the algorithms in the learning process.  The second and third lines contain the recovered images from the hidden states of the autocoder and the principal component method, respectively, of the same dimension.  It is clearly seen how much better the auto-encoder worked. <br><br>  In the same article, another illustrative example: a comparison of the results of the work of the auto-encoder and the <a href="http://lsa.colorado.edu/papers/JASIS.lsi.90.pdf">LSA</a> method for the task of information retrieval.  The LSA method, like the principal component method, is a classical machine learning method and is often used in tasks related to the processing of natural language. <br><img src="https://habrastorage.org/webt/di/h5/j3/dih5j3wsflfohomgzzrjo9e6n7k.png"><br>  The figure shows a 2D projection of a set of documents obtained using the auto-encoder and the LSA method.  Colors indicate the subject of the document.  It can be seen that the projection from the auto-encoder well breaks the documents by topic, while the LSA gives a much more noisy result. <br><br>  Another important use of autocoders is the <a href="http://www.iro.umontreal.ca/~lisa/pointeurs/BengioNips2006All.pdf">pre-training of networks</a> .  Network pre-training is used when the network being optimized is deep enough.  In this case, training the network from scratch can turn out to be quite complex, so first the entire network is represented as a chain of encoders. <br><br>  The pre-learning algorithm is quite simple: for each layer, we train our auto-encoder, and then we ask that the output of the next encoder is at the same time the input for the next layer of the network.  The resulting model consists of a chain of encoders, trained to eagerly preserve the most important features of objects, each on its own layer.  The pre-training scheme is presented below: <br><img src="https://habrastorage.org/webt/yy/mc/ui/yymcuigpqgegoa_7gwndzfxulia.png"><br>  Source: <a href="http://psyyz10.github.io/2015/11/SDA/">psyyz10.github.io</a> <br><br>  Such a structure is called Stacked Autoencoder and is often used as ‚Äúoverclocking‚Äù for further learning of the complete deep network model.  The motivation for such learning of a neural network is that a deep neural network is a nonconvex function: in the process of learning a network, the optimization of parameters can ‚Äúget stuck‚Äù in a local minimum.  The greedy pre-training of network parameters allows you to find a good starting point for final training and thus try to avoid such local minima. <br><br>  Of course, we have considered far from all possible structures, as there are still <a href="https://web.stanford.edu/class/cs294a/sparseAutoencoder_2011new.pdf">Sparse Autoencoders</a> , <a href="http://www.cs.toronto.edu/~larocheh/publications/icml-2008-denoising-autoencoders.pdf">Denoising Autoencoders</a> , <a href="http://www.icml-2011.org/papers/455_icmlpaper.pdf">Contractive Autoencoder</a> , <a href="http://jmlr.csail.mit.edu/papers/volume15/alain14a/alain14a.pdf">Reconstruction Contractive Autoencoder</a> .  They differ from each other using different error functions and penalty terms to them.  All these architectures, we think, are worthy of a separate review.  In our article, we first of all show the general concept of auto-encoders and those specific tasks of text analysis that are solved with its use. <br><br><h2>  How does this work in lyrics? </h2><br>  We now turn to specific examples of the use of autocoders for text analysis problems.  We are interested in both sides of the application - both models for obtaining internal representations, and using these internal representations as attributes, for example, in the further task of classification.  Articles on this topic most often affect such tasks as sentiment analysis, or detection of paraphrases, but there are also works describing the use of autocoders for comparing texts in different languages ‚Äã‚Äãor for machine translation. <br><br>  In the tasks of text analysis, the most frequent object is the sentence, i.e.  ordered sequence of words.  Thus, the autocoder takes on input this particular sequence of words, or rather, vector representations of these words, taken from some pre-trained model.  What is the vector representation of words, was considered on Habr√© in some detail, for example, <a href="https://habr.com/company/ods/blog/329410/">here</a> .  Thus, the auto-encoder, taking as input a sequence of words, should train some internal representation of the entire sentence, corresponding to those characteristics that are important to us, based on the task.  In the problems of text analysis, we need to map the sentences into vectors so that they are close in the sense of some distance function, most often a cosine measure: <br><br><img src="https://habrastorage.org/webt/fs/ka/ec/fskaecgqanvbmtzhf4hdqdd0bhw.png"><br>  Source: <a href="https://nlp.stanford.edu/courses/NAACL2013/NAACL2013-Socher-Manning-DeepLearning.pdf">Deep Learning for NLP (without Magic)</a> <br><br>  One of the first authors who showed the successful use of autocoders in text analysis was <a href="https://scholar.google.com/citations%3Fhl%3Den%26user%3DFaOcyfMAAAAJ%26view_op%3Dlist_works%26sortby%3Dpubdate">Richard Socher</a> . <br><br>  In his article <a href="https://papers.nips.cc/paper/4204-dynamic-pooling-and-unfolding-recursive-autoencoders-for-paraphrase-detection.pdf">Dynamic Pooling and Unfolding Recursive Autoencoders for Paraphrase Detection,</a> he describes a new autocoder structure - Unfolding Recursive Autoencoder (Unfolding RAE) (see the figure below). <br><img src="https://habrastorage.org/webt/zn/va/o9/znvao90juxs6ywwmm5ywwe6nrdm.png"><br>  Unfolding rae <br><br>  It is assumed that the sentence structure is defined by the <a href="https://web.stanford.edu/~jurafsky/slp3/12.pdf">syntax parser</a> .  The simplest structure is considered - the structure of a binary tree.  Such a tree consists of leaves - words of a fragment, internal nodes (branch nodes) - phrases, and a terminal vertex.  Taking the input sequence of words (x <sub>1</sub> , x <sub>2</sub> , x <sub>3</sub> ) (the three vector representations of words in this example), the autocoder sequentially encodes, in this case, right-to-left, the vector representations of the words into vector representations of word combinations, and then into presentation of the whole sentence.  Specifically, in this example, we first associate the vectors x <sub>2</sub> and x <sub>3</sub> , then multiply them by the matrix <i>W <sub>e</sub></i> having the dimension of <i>hidden √ó 2visible</i> , where <i>hidden</i> is where the size of the hidden internal representation, <i>visible</i> is the dimension of the word vector.  Thus, we reduce the dimension, then adding non-linearity using the tanh function.  In the first step, we get a hidden vector representation for the phrase two words <i>x <sub>2</sub></i> and <i>x <sub>3</sub></i> : <i>h <sub>1</sub></i> = <i>tanh‚Å° (W <sub>e</sub> [x <sub>2</sub> , x <sub>3</sub> ] + b <sub>e</sub> )</i> .  In the second, we merge it and the remaining word <i>h <sub>2</sub></i> = <i>tanh‚Å° (W <sub>e</sub> [h <sub>1</sub> , x <sub>1</sub> ] + b <sub>e</sub> )</i> and get a vector representation for the entire sentence ‚Äî <i>h <sub>2</sub></i> .  As mentioned above, in the definition of the auto-encoder, we need to minimize the error between objects and their restored versions.  In our case, these are words.  Therefore, having obtained the final vector representation of the entire sentence <i>h <sub>2</sub></i> , we decode its restored versions (x <sub>1</sub> ', x <sub>2</sub> ', x <sub>3</sub> ').  The decoder here works on the same principle as the encoder, only the matrix of parameters and the shift vector are different: <i>W <sub>d</sub></i> and <i>b <sub>d</sub></i> . <br><br>  Using the structure of a binary tree, it is possible to encode sentences of any length into a vector of fixed dimension - we always combine over a pair of vectors of the same dimension using the same matrix of parameters <i>W <sub>e</sub></i> .  In the case of a non-binary tree, you just need to initialize the matrices in advance for the cases if we want to combine more than two words - 3, 4, ... n, in this case, the matrix will simply have the dimension of <i>hidden √ó invisible</i> . <br><br>  It is noteworthy that in this article, the trained vector representations of phrases are used not only to solve the problem of classification - whether or not a couple of sentences are paraphrased.  Experimental data on the search for the nearest neighbors are also given - based only on the received vector of the proposal, the nearest ones in the sample of the vector are found for it, which are close to it in meaning: <br><br><img src="https://habrastorage.org/webt/d6/pv/ae/d6pvaevnd18k2ouizgs3t9k0xbk.png"><br><br>  However, no one bothers us to use for the consistent combination of words in a sentence and other network architectures for encoding and decoding. <br><br>  Here is an example from the article NIPS 2017 - <a href="https://papers.nips.cc/paper/7005-deconvolutional-paragraph-representation-learning.pdf">Deconvolutional Paragraph Representation Learning</a> : <br><img src="https://habrastorage.org/webt/g9/u7/0m/g9u70mec8rpyrbnxuqtnflyxcfo.png"><br><br>  We see that encoding sample <b>X</b> into a hidden representation of <b>h</b> occurs using a <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D1%2591%25D1%2580%25D1%2582%25D0%25BE%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25B5%25D0%25B9%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B5%25D1%2582%25D1%258C">convolutional neural network</a> , and the decoder works in the same way. <br><br>  Or here‚Äôs an example using <a href="https://en.wikipedia.org/wiki/Gated_recurrent_unit">GRU-GRU</a> in the <a href="https://arxiv.org/pdf/1506.06726.pdf">Skip-Thought Vectors</a> article. <br><br>  An interesting feature here is that the model works with triples of sentences: ( <i>s <sub>i-1</sub> , s <sub>i</sub> , s <sub>i + 1</sub></i> ).  The sentence <i>s <sub>i</sub></i> is encoded using the standard GRU formulas, and the decoder, using information about the internal representation <i>s <sub>i</sub></i> , attempts to decode <i>s <sub>i-1</sub></i> and <i>s <sub>i + 1</sub></i> , also using GRU. <br><br><img src="https://habrastorage.org/webt/ed/od/-r/edod-radj66y43mbsgu31zxo7nu.png"><br><br>  The principle of operation in this case resembles the standard model of <a href="https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf">neural network machine translation</a> , which operates according to the encoder-decoder scheme.  However, here we do not have two languages, we feed a phrase in one language to the input of our coding block, and we are trying to restore it.  In the process of learning, there is a minimization of some internal functional quality (this is not always a reconstruction error), then, if required, the pre-trained vectors are used as attributes in another task. <br><br>  In another work - <a href="http://www.emnlp2015.org/proceedings/EMNLP/pdf/EMNLP146.pdf">Bilingual Correspondence Recursive Autoencoders for the Statistical Machine Translation</a> - an architecture is presented that allows you to take a fresh look at machine translation.  First, recursive autocoders are taught separately for two languages ‚Äã‚Äã(according to the principle described above, where Unfolding RAE was introduced).  Then, between them, the third autoencoder is trained - a mapping between two languages.  This architecture has a clear advantage - when displaying texts in different languages ‚Äã‚Äãinto one common hidden space, we can compare them, without using machine translation, as an intermediate step. <br><br><img src="https://habrastorage.org/webt/tj/rq/un/tjrqunxjtnbgsivzz7iohnm8ibs.png"><br><br>  Pre-training autocoders on text fragments is often found in <a href="http://www.aclweb.org/anthology/P16-1177">ranking training</a> articles.  Here, again, it is important that, in order to train the final ranking quality functional, we first pre-train the autocoder to better initialize the request and response vectors to the network input. <br><br><img src="https://habrastorage.org/webt/5t/a1/qn/5ta1qnx9gqzl9dypb0t4nhgcjtg.jpeg"><br><br>  And, of course, we cannot but mention Variational autocoders ( <a href="">Variational Autoencoders</a> , or VAE) as generative models.  Best of all, of course, just watch <a href="https://habr.com/company/yandex/blog/321434/">this lecture entry from Yandex</a> .  It is enough for us to say the following: if we want to <i>generate</i> objects from the hidden space of a conventional auto-encoder, the quality of such generation will be low, since we know nothing about the distribution of the hidden variable.  But you can immediately train the auto-encoder for generation, introducing the distribution assumption. <br><br>  And then, using VAE, you can generate texts from this hidden space, for example, as the authors of the article <a href="https://arxiv.org/pdf/1511.06349.pdf%3Futm_campaign%3DRevue%2520newsletter%26utm_medium%3DNewsletter%26utm_source%3Drevue">Generating Sentences from a Continuous Space</a> or <a href="https://arxiv.org/pdf/1702.02390.pdf">A Hybrid Convolutional Variational Autoencoder for Text Generation do</a> . <br><br>  The VAE generative properties are also well manifested in the task of comparing texts in different languages ‚Äã‚Äã- <a href="https://www.ijcai.org/proceedings/2017/0582.pdf">A Variational Autoencoding Approach for Inducing Cross-lingual Word Embeddings is a</a> great example. <br><br>  As an output, we want to make a small forecast.  <a href="http://www.deeplearningbook.org/contents/representation.html">Representation Learning</a> - training internal presentations using VAE specifically, in conjunction with <a href="https://arxiv.org/pdf/1406.2661.pdf">Generative Adversarial Networks</a> , is one of the most evolving approaches in recent years - this can be judged by the most frequent topics of articles at the latest top machine learning <a href="https://iclr.cc/Conferences/2018/Schedule%3Ftype%3DPoster">conferences ICLR 2018</a> and <a href="https://icml.cc/Conferences/2018/Schedule%3Ftype%3DPoster">ICML 2018</a> .  This is quite logical - because its use has helped raise the quality in a number of tasks, and not only related to texts.  But this is a completely different review topic ... </div><p>Source: <a href="https://habr.com/ru/post/418173/">https://habr.com/ru/post/418173/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418163/index.html">Production Tests: Chaos Automation Platform on Netflix</a></li>
<li><a href="../418165/index.html">Quasar, Sobaken and Vermin: reveal the details of the current cyber espionage campaign</a></li>
<li><a href="../418167/index.html">ScadaPy: add the IEC 60870-5-104 protocol</a></li>
<li><a href="../418169/index.html">What's new in Veeam Availability Console 2.0 Update 1?</a></li>
<li><a href="../418171/index.html">What metrics to rely on, if users perform few conversions on the site?</a></li>
<li><a href="../418177/index.html">Editing .heic images without losing colors</a></li>
<li><a href="../418181/index.html">Roskomnadzor re-blocked the Hideme.ru VPN service. The site again moved to a new address.</a></li>
<li><a href="../418183/index.html">The use of speech analytics in business</a></li>
<li><a href="../418185/index.html">The story of one autopsy: how we reversed Hancitor</a></li>
<li><a href="../418187/index.html">In America, they suggested replacing all libraries with Amazon hubs. The public is indignant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>