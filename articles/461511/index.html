<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python Dependency Management: A Comparison of Approaches</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have been writing in python for about five years, of which the last three years have been developing my own project. Most of this way my team helps ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python Dependency Management: A Comparison of Approaches</h1><div class="post__text post__text-html js-mediator-article"><img src="http://ftcdn.pw/cd64d5e9-af9a-46cc-868b-c8873c98adb6.png" alt="image"><br><br>  I have been writing in python for about five years, of which the last three years have been developing my own project.  Most of this way my team helps me with this.  And with each release, with each new feature, we are increasingly trying to ensure that the project does not turn into a mess from unsupported code;  we deal with cyclic imports, mutual dependencies, allocate reusable modules, rebuild the structure. <br><br>  Unfortunately, in the Python community there is no universal concept of "good architecture", there is only the concept of "pythonicity", so we have to come up with the architecture ourselves.  Under the cut - Longrid with reflections on architecture and, first of all, on dependency management is applicable to Python. <br><a name="habracut"></a><br><h1>  django.setup () </h1><br>  I‚Äôll start with a question to the junglers.  Do you often write these two lines? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> django django.setup()</code> </pre> <br>  You need to start the file from this if you want to work with django objects without starting the django web server itself.  This applies to models, and tools for working with time ( <code><b>django.utils.timezone</b></code> ), and <code><b>django.urls.reverse</b></code> ( <code><b>django.urls.reverse</b></code> ), and much more.  If this is not done, then you will get an error: <br><br><pre> <code class="plaintext hljs">django.core.exceptions.AppRegistryNotReady: Apps aren't loaded yet.</code> </pre><br>  I am constantly writing these two lines.  I am a big fan of ejection code;  I like to create a separate <code><b>.py</b></code> file, twist some things in it, figure it out - and then embed it in the project. <br><br>  And this constant <code><b>django.setup()</b></code> annoys me a lot.  Firstly, you get tired of repeating it everywhere;  and, secondly, django initialization takes a few seconds (we have a big monolith), and when you restart the same file 10, 20, 100 times - it just slows down the development. <br><br>  How to get rid of <code><b>django.setup()</b></code> ?  You need to write code that minimally depends on django. <br><br>  For example, if we write a client of an external API, then we can make it dependent on django: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.conf <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> settings <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">APIClient</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.api_key = settings.SOME_API_KEY <span class="hljs-comment"><span class="hljs-comment"># : client = APIClient()</span></span></code> </pre><br>  or it can be independent of django: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">APIClient</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, api_key)</span></span></span><span class="hljs-function">:</span></span> self.api_key = api_key <span class="hljs-comment"><span class="hljs-comment"># : client = APIClient(api_key='abc')</span></span></code> </pre><br>  In the second case, the constructor is more cumbersome, but any manipulations with this class can be done without loading all the dzhangovskoy machinery. <br><br>  Tests are also getting easier.  How to test a component that depends on <code><b>django.conf.settings</b></code> settings?  Just lock them with the <code><b>@override_settings</b></code> decorator.  And if the component does not depend on anything, then there will be nothing to get wet: it passed the parameters to the constructor - and drove it. <br><br><h1>  Dependency management </h1><br>  The <code><b>django</b></code> dependency story is the most striking example of a problem that I encounter every day: dependency management problems in python - and the overall architecture of python applications. <br><br>  The relationship with dependency management in the Python community is mixed.  Three main camps can be distinguished: <br><br><ul><li>  Python is a flexible language.  We write as we want, depending on what we want.  We are not shy about cyclic dependencies, attribute substitution for classes in runtime, etc. <br><br></li><li>  Python is a special language.  There are idiomatic ways to build architecture and dependencies.  Data transfer up and down the call stack is performed by iterators, coroutines, and context managers. <br><br><div class="spoiler">  <b class="spoiler_title">Class report on this topic and an example</b> <div class="spoiler_text">  Brandon Rhodes, Dropbox: <a href="https://www.youtube.com/watch%3Fv%3DPBQN62oUnN8%26t%3D2s">Hoist your IO</a> . <br><br>  Example from the report: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""          """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"/etc/hosts"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> file: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parse_hosts(file): print(line) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_hosts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lines)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    -   """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lines: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> line.startswith(<span class="hljs-string"><span class="hljs-string">"#"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> line</code> </pre><br></div></div><br></li><li>  Python's flexibility is an extra way to shoot yourself in the foot.  You need a hard set of rules for dependency management.  A good example is the Russian <a href="https://www.youtube.com/watch%3Fv%3Db-Ry_4wX9Q8">dry-python</a> guys.  There is still a less hardcore approach - <a href="https://www.youtube.com/watch%3Fv%3DyG3ZdxBb1oo">Django structure for scale and longevity</a> , But the idea here is the same. <br></li></ul><br>  There are several articles on dependency management in python ( <a href="https://webdevblog.ru/vnedrenie-zavisimostej-v-python/">example 1</a> , <a href="https://habr.com/ru/post/212217/">example 2</a> ), but they all come down to advertising someone's Dependency Injection frameworks.  This article is a new entry on the same topic, but this time it is a pure thought experiment without advertising.  This is an attempt to find a balance between the three approaches above, do without an extra framework and make it ‚Äúpythonic‚Äù. <br><br>  I recently read <a href="https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164">Clean Architecture</a> - and I seem to understand what the value of dependency injection in python is and how it can be implemented.  I saw this on the example of my own project.  In a nutshell, this is <b>protecting the code from breaking when another code changes</b> . <br><br><h1>  Initial data </h1><br>  There is an API client that executes HTTP requests for the service shortener: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># shortener_client.py import requests class ShortenerClient: def __init__(self, api_key): self.api_key = api_key def shorten_link(self, url): response = requests.post( url='https://fstrk.cc/short', headers={'Authorization': self.api_key}, json={'url': url} ) return response.json()['url']</span></span></code> </pre><br>  And there is a module that shortens all the links in the text.  To do this, he uses the shortener API client: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_processor.py import re from shortener_client import ShortenerClient class TextProcessor: def __init__(self, text): self.text = text def process(self): changed_text = self.text links = re.findall( r'https?://[^\r\n\t") ]*', self.text, flags=re.MULTILINE ) api_client = ShortenerClient('abc') for link in links: shortened = api_client.shorten_link(link) changed_text = changed_text.replace(link, shortened) return changed_text</span></span></code> </pre><br>  The logic of code execution lives in a separate control file (let's call it a controller): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># controller.py from text_processor import TextProcessor processor = TextProcessor("""  1: https://ya.ru  2: https://google.com """) print(processor.process())</span></span></code> </pre><br>  Everything is working.  The processor parses the text, shortens the links using a shortener, returns the result.  The dependencies look like this: <br><br><img src="http://ftcdn.pw/58d8aa1d-0024-42c6-918e-05b2d41f126d.png" alt="image"><br><br><h1>  Problem </h1><br>  Here's the problem: the <code><b>TextProcessor</b></code> class depends on the <code><b>ShortenerClient</b></code> class - and <b>breaks when the</b> <code><b>ShortenerClient</b></code> <b>interface changes</b> . <br><br>  How can this happen? <br><br>  Suppose in our project we decided to track <code><b>shorten_link</b></code> and added the <code><b>callback_url</b></code> argument to the <code><b>shorten_link</b></code> method.  This argument means the address to which notifications should come when clicking on a link. <br><br>  The <code><b>ShortenerClient.shorten_link</b></code> method began to look like this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shorten_link</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, url, callback_url)</span></span></span><span class="hljs-function">:</span></span> response = requests.post( url=<span class="hljs-string"><span class="hljs-string">'https://fstrk.cc/short'</span></span>, headers={<span class="hljs-string"><span class="hljs-string">'Authorization'</span></span>: self.api_key}, json={<span class="hljs-string"><span class="hljs-string">'url'</span></span>: url, <span class="hljs-string"><span class="hljs-string">'callback_on_click'</span></span>: callback_url} ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json()[<span class="hljs-string"><span class="hljs-string">'url'</span></span>]</code> </pre><br>  And what happens?  And it turns out that when we try to start, we get an error: <br><br><pre> <code class="python hljs">TypeError: shorten_link() missing <span class="hljs-number"><span class="hljs-number">1</span></span> required positional argument: <span class="hljs-string"><span class="hljs-string">'callback_url'</span></span></code> </pre><br>  That is, we changed the shortener, but it was not he who broke, but his client: <br><br><img src="http://ftcdn.pw/13e9dcd5-7866-4c82-b1d0-e56134650b62.png" alt="image"><br><br>  So what?  Well, the calling file broke, we went and fixed it.  What is the problem? <br><br>  If this is solved in a minute - they went and corrected - then this, of course, is not a problem at all.  If there is little code in the classes and if you support them yourself (this is your side project, these are two small classes of the same subsystem, etc.), then you can stop there. <br><br>  Problems begin when: <br><br><ul><li>  the calling and called modules have a lot of code; </li><li>  different modules are supported by different people / teams. </li></ul><br>  If you write the <code><b>ShortenerClient</b></code> class, and your colleague writes <code><b>TextProcessor</b></code> , you get an offensive situation: <b>you changed the code, but it broke.</b>  And it broke in a place that you have not seen in life, and now you need to sit down and understand someone else's code. <br><br>  Even more interesting is when your module is used in several places, and not in one;  and your edit will break the code on the heap of files. <br><br>  Therefore, the problem can be formulated as follows: how to organize the code so that when the <code><b>ShortenerClient</b></code> interface is changed, <code><b>ShortenerClient</b></code> <b>itself <code><b>ShortenerClient</b></code> , and not its consumers</b> (of which there can be many)? <br><br>  The solution here is: <br><br><ul><li>  Class consumers and the class itself must agree on a common interface.  This interface should become law. </li><li>  If the class ceases to correspond to its interface, these will be its problems, and not the problems of consumers. </li></ul><br><img src="http://ftcdn.pw/dbb4d320-2683-4f2e-821e-dea621b54b53.png" alt="image"><br><br><h1>  Freeze the interface </h1><br>  What does fixing an interface look like in python?  This is an abstract class: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> abc <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ABC, abstractmethod <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ABC)</span></span></span><span class="hljs-class">:</span></span> @abstractmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, api_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> @abstractmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shorten_link</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, link)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  If now we inherit from this class and forget to implement some method, we get an error: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShortenerClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(AbstractClient)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__ini__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, api_key)</span></span></span><span class="hljs-function">:</span></span> self.api_key = api_key client = ShortenerClient(<span class="hljs-string"><span class="hljs-string">'123'</span></span>) &gt;&gt;&gt; TypeError: Can<span class="hljs-string"><span class="hljs-string">'t instantiate abstract class ShortenerClient with abstract methods __init__, shorten_link</span></span></code> </pre><br>  But this is not enough.  An abstract class captures only the names of methods, but not their signature. <br><br>  Need a second signature verification tool. This second tool is <code><b>mypy</b></code> .  It will help verify the signatures of inherited methods.  To do this, we must add annotations to the interface: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># shortener_client.py from abc import ABC, abstractmethod class AbstractClient(ABC): @abstractmethod def __init__(self, api_key: str) -&gt; None: pass @abstractmethod def shorten_link(self, link: str) -&gt; str: pass class ShortenerClient(AbstractClient): def __init__(self, api_key: str) -&gt; None: self.api_key = api_key def shorten_link(self, link: str, callback_url: str) -&gt; str: return 'xxx'</span></span></code> </pre><br>  If we now check this code with <code><b>mypy</b></code> , we get an error due to the extra <code><b>callback_url</b></code> argument: <br><br><pre> <code class="plaintext hljs">mypy shortener_client.py &gt;&gt;&gt; error: Signature of "shorten_link" incompatible with supertype "AbstractClient"</code> </pre><br>  Now we have a reliable way to commit the class interface. <br><br><h1>  Dependency inversion </h1><br>  Having debugged the interface, we must move it to another place in order to completely eliminate the consumer‚Äôs dependence on the <code><b>shortener_client.py</b></code> file.  For example, you can drag the interface directly to the consumer - to a file with the <code><b>TextProcessor</b></code> processor: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_processor.py import re from abc import ABC, abstractmethod class AbstractClient(ABC): @abstractmethod def __init__(self, api_key: str) -&gt; None: pass @abstractmethod def shorten_link(self, link: str) -&gt; str: pass class TextProcessor: def __init__(self, text, shortener_client: AbstractClient) -&gt; None: self.text = text self.shortener_client = shortener_client def process(self) -&gt; str: changed_text = self.text links = re.findall( r'https?://[^\r\n\t") ]*', self.text, flags=re.MULTILINE ) for link in links: shortened = self.shortener_client.shorten_link(link) changed_text = changed_text.replace(link, shortened) return changed_text</span></span></code> </pre><br>  And that will change the direction of addiction!  Now the <code><b>TextProcessor</b></code> owns the interaction interface, and as a result, <code><b>ShortenerClient</b></code> depends on it, and not vice versa. <br><br><img src="http://ftcdn.pw/33f3c619-63bf-420d-99d0-67bed0dfa628.png" alt="image"><br><br>  In simple words, we can describe the essence of our transformation as follows: <br><br><ul><li>  <code><b>TextProcessor</b></code> says: I am a processor, and I am involved in text conversion.  I do not want to know anything about the shortening mechanism: this is not my business.  I want to pull the <code><b>shorten_link</b></code> method so that it <code><b>shorten_link</b></code> everything for me.  So please, give me an object that plays according to my rules.  Decisions about the way I interact are made by me, not him. </li><li>  <code><b>ShortenerClient</b></code> says: it seems that I cannot exist in a vacuum, and they require certain behavior from me.  I'll go ask <code><b>TextProcessor</b></code> what I need to match so as not to break. </li></ul><br><h1>  Multiple consumers </h1><br>  If several modules use shortening links, then the interface should be put not in one of them, but in some separate file, which is located above the other files, higher in hierarchy: <br><br><img src="http://ftcdn.pw/a81ef19a-45aa-4b23-b93a-e9a6b9094670.png" alt="image"><br><br><h1>  Control component </h1><br>  If consumers do not import <code><b>ShortenerClient</b></code> , then who does import it and create a class object?  It must be a control component - in our case it is <code><b>controller.py</b></code> . <br><br>  The simplest approach is a straightforward dependency injection, Dependency Injection ‚Äúin the forehead‚Äù.  We create objects in the calling code, transfer one object to another.  Profit <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># controller.py import TextProcessor import ShortenerClient processor = TextProcessor( text=' 1: https://ya.ru  2: https://google.com', shortener_client=ShortenerClient(api_key='123') ) print(processor.process())</span></span></code> </pre><br><h1>  Python approach </h1><br>  A more ‚Äúpythonic‚Äù approach is believed to be Dependency Injection through inheritance. <br><br><div class="spoiler">  <b class="spoiler_title">Raymond Hettinger talks about this in great detail in his Super considered Super report.</b> <div class="spoiler_text"><div class="oembed">  <a href="https://www.youtube.com/watch%3Fv%3DEiOglTERPEo">https://www.youtube.com/watch?v=EiOglTERPEo</a> </div><br></div></div><br>  To adapt the code to this style, you need to slightly change the <code><b>TextProcessor</b></code> , making it inheritable: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_processor.py class TextProcessor: def __init__(self, text: str) -&gt; None: self.text = text self.shortener_client: AbstractClient = self.get_shortener_client() def get_shortener_client(self) -&gt; AbstractClient: """      """ raise NotImplementedError</span></span></code> </pre><br>  And then, in the calling code, inherit it: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># controller.py import TextProcessor import ShortenerClient class ProcessorWithClient(TextProcessor): """   ,    """ def get_shortener_client(self) -&gt; ShortenerClient: return ShortenerClient(api_key='abc') processor = ProcessorWithClient( text=' 1: https://ya.ru  2: https://google.com' ) print(processor.process())</span></span></code> </pre><br>  The second example is ubiquitous in popular frameworks: <br><br><ul><li>  At Django, we are constantly inherited.  We redefine methods of Class-based view, models, forms;  in other words, inject our dependencies into the already debugged work of the framework. </li><li>  In DRF, the same thing.  We are expanding views, serializers, permissions. </li><li>  And so on.  There are a lot of examples. </li></ul><br>  The second example looks prettier and more familiar, doesn't it?  Let's develop it and see if this beauty is preserved. <br><br><h1>  Python development </h1><br>  In business logic, there are usually more than two components.  Suppose that our <code><b>TextProcessor</b></code> is not an independent class, but only one of the <code><b>TextPipeline</b></code> elements that processes the text and sends it to the mail: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextPipeline</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text, email)</span></span></span><span class="hljs-function">:</span></span> self.text_processor = TextProcessor(text) self.mailer = Mailer(email) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_and_mail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> processed_text = self.text_processor.process() self.mailer.send_text(text=processed_text)</code> </pre><br>  If we want to isolate the <code><b>TextPipeline</b></code> from the classes used, we must follow the same procedure as before: <br><br><ul><li>  the <code><b>TextPipeline</b></code> class will declare interfaces for used components; </li><li>  used components will be forced to conform to these interfaces; </li><li>  some external code will put everything together and run. </li></ul><br>  The dependency diagram will look like this: <br><br><img src="http://ftcdn.pw/35f207fa-3ad7-4779-92c3-ae8f63401b8e.png" alt="image"><br><br>  But what will the assembly code for these dependencies now look like? <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextProcessor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ShortenerClient <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Mailer <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextPipeline <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProcessorWithClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TextProcessor)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_shortener_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; ShortenerClient:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShortenerClient(api_key=<span class="hljs-string"><span class="hljs-string">'123'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PipelineWithDependencies</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TextPipeline)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_text_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text: str)</span></span></span><span class="hljs-function"> -&gt; ProcessorWithClient:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProcessorWithClient(text) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_mailer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, email: str)</span></span></span><span class="hljs-function"> -&gt; Mailer:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mailer(email) pipeline = PipelineWithDependencies( email=<span class="hljs-string"><span class="hljs-string">'abc@def.com'</span></span>, text=<span class="hljs-string"><span class="hljs-string">' 1: https://ya.ru  2: https://google.com'</span></span> ) pipeline.process_and_mail()</code> </pre><br>  Have you noticed?  We first inherit the <code><b>TextProcessor</b></code> class to insert the <code><b>ShortenerClient</b></code> into it, and then inherit the <code><b>TextPipeline</b></code> to insert our overridden <code><b>TextProcessor</b></code> (as well as <code><b>Mailer</b></code> ) into it.  We have several levels of sequential redefinition.  Already complicated. <br><br>  Why are all frameworks organized in this way?  <b>Yes, because it is only suitable for frameworks.</b> <br><br><ul><li>  All levels of the framework are clearly defined, and their number is limited.  For example, in Django, you can override <code><b>FormField</b></code> to insert it into an override of a <code><b>Form</b></code> , to insert a form into an override of <code><b>View</b></code> .  Everything.  Three levels. </li><li>  Each framework serves one purpose.  This task is clearly defined. </li><li>  Each framework has detailed documentation that describes how and what to inherit;  what and with what to combine. </li></ul><br>  Can you clearly and unambiguously identify and document your business logic?  Especially the architecture of the levels at which it works?  Me not.  Unfortunately, Raymond Hettinger's approach does not scale to business logic. <br><br><h1>  Back to the forehead approach </h1><br>  At several levels of difficulty, a simple approach wins.  It looks simpler - and easier to change when logic changes. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextProcessor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ShortenerClient <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Mailer <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextPipeline pipeline = TextPipeline( text_processor=TextProcessor( text=<span class="hljs-string"><span class="hljs-string">' 1: https://ya.ru  2: https://google.com'</span></span>, shortener_client=ShortenerClient(api_key=<span class="hljs-string"><span class="hljs-string">'abc'</span></span>) ), mailer=Mailer(<span class="hljs-string"><span class="hljs-string">'abc@def.com'</span></span>) ) pipeline.process_and_mail()</code> </pre><br>  But, when the number of levels of logic increases, even such an approach becomes inconvenient.  We have to imperatively initiate a bunch of classes, passing them into each other.  I want to avoid many levels of nesting. <br><br>  Let's try another call. <br><br><h1>  Global Instance Storage </h1><br>  Let's try to create a global dictionary in which the instances of the components we need will lie.  And let these components reach each other through access to this dictionary. <br><br>  Let's call it <code><b>INSTANCE_DICT</b></code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_processor.py import INSTANCE_DICT class TextProcessor(AbstractTextProcessor): def __init__(self, text) -&gt; None: self.text = text def process(self) -&gt; str: shortener_client: AbstractClient = INSTANCE_DICT['Shortener'] # ...  </span></span></code> </pre><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_pipeline.py import INSTANCE_DICT class TextPipeline: def __init__(self) -&gt; None: self.text_processor: AbstractTextProcessor = INSTANCE_DICT[ 'TextProcessor'] self.mailer: AbstractMailer = INSTANCE_DICT['Mailer'] def process_and_mail(self) -&gt; None: processed_text = self.text_processor.process() self.mailer.send_text(text=processed_text)</span></span></code> </pre><br>  The trick is to <b>put our objects in this dictionary before they are accessed</b> .  This is what we will do in <code><b>controller.py</b></code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># controller.py import INSTANCE_DICT import TextProcessor import ShortenerClient import Mailer import TextPipeline INSTANCE_DICT['Shortener'] = ShortenerClient('123') INSTANCE_DICT['Mailer'] = Mailer('abc@def.com') INSTANCE_DICT['TextProcessor'] = TextProcessor(text=' : https://ya.ru') pipeline = TextPipeline() pipeline.process_and_mail()</span></span></code> </pre><br>  Pros of working through a global dictionary: <br><br><ul><li>  no engine hood magic and extra DI frameworks; </li><li>  flat list of dependencies in which you do not need to manage nesting; </li><li>  all DI bonuses: simple testing, independence, protection of components from breakdowns when other components change. </li></ul><br>  Of course, instead of creating <code><b>INSTANCE_DICT</b></code> , you can use some kind of DI framework;  but the essence of this will not change.  The framework will provide more flexible management of instances;  he will allow you to create them in the form of singleton or packs, like a factory;  but the idea will remain the same. <br><br>  Perhaps at some point this will not be enough for me, and I still choose some kind of framework. <br><br>  And, perhaps, all this is unnecessary, and it is easier to do without it: write direct imports and not create unnecessary abstract interfaces. <br><br>  What is your experience with dependency management in python?  And in general - is it necessary, or am I inventing a problem from the air? </div><p>Source: <a href="https://habr.com/ru/post/461511/">https://habr.com/ru/post/461511/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461503/index.html">Making the database available for remote connection</a></li>
<li><a href="../461505/index.html">8 bugs of novice JavaScript developers that prevent you from becoming a professional</a></li>
<li><a href="../461507/index.html">Why did we decide to launch the Gazprom Neft corporate accelerator StartupDrive, and who has already passed it</a></li>
<li><a href="../461509/index.html">Travel Assistants: A selection of gadgets and accessories</a></li>
<li><a href="../46151/index.html">AppleJack - Mac OS X troubleshooter</a></li>
<li><a href="../461519/index.html">Best Copy-Paste Algorithms for C and C ++. Haiku OS Recipe Collection</a></li>
<li><a href="../46152/index.html">Active users</a></li>
<li><a href="../461523/index.html">WAL in PostgreSQL: 4. Log setup</a></li>
<li><a href="../461525/index.html">How I did a really adaptive slider (carousel)</a></li>
<li><a href="../461527/index.html">DIY acoustic levitation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>