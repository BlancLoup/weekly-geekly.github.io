<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We develop the NIOS II processor module for IDA Pro</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="IDA Pro Disassembler Interface Screenshot 

 IDA Pro is a famous disassembler that has been used by information security researchers all over the worl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We develop the NIOS II processor module for IDA Pro</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habr.com/company/pt/blog/424085/"><img src="https://habrastorage.org/getpro/habr/post_images/141/008/5b2/1410085b245c7ef6a18074b47dda1b6b.gif" alt="image"></a> <br><br>  <i>IDA Pro Disassembler Interface Screenshot</i> <br><br>  IDA Pro is a famous disassembler that has been used by information security researchers all over the world for many years.  We at Positive Technologies also use this tool.  Moreover, we managed to develop our own <a href="https://github.com/ptresearch/nios2">disassembler processor module for the microprocessor architecture of NIOS II</a> , which improves the speed and convenience of code analysis. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Today I will talk about the history of this project and show you what happened in the end. <a name="habracut"></a><br><br><h2>  Prehistory </h2><br>  It all started in 2016, when we had to develop our own processor module to analyze the firmware in one task.  Development was carried out from scratch according to the manual of the <a href="">Nios II Classic Processor Reference Guide</a> , which was then the most relevant.  In total, this work took about two weeks. <br><br>  The processor module was developed for version IDA 6.9.  IDA Python was chosen for speed.  In the place where the processor modules live, the subdirectory procs inside the IDA Pro installation directory, there are three modules in Python: msp430, ebc, spu.  They can see how the module is arranged and how the basic disassembling functionality can be implemented: <br><br><ul><li>  parsing instructions and operands, </li><li>  simplifying and displaying them, </li><li>  creating offsets, cross references, as well as the code and data to which they refer, </li><li>  processing switch constructions </li><li>  handling of stack manipulations and stack variables. </li></ul><br>  Approximately this functionality was implemented at that time.  Fortunately, the tool came in handy in the process of working on another task, during which, a year later, it was actively used and refined. <br><br>  I decided to share the experience of creating a processor module with the community at the PHDays 8 conference. The presentation aroused interest (the video of the report was <a href="https://www.phdays.com/ru/broadcast/">published</a> on the PHDays website), even the creator of IDA Pro Ilfak Gilfanov attended it.  One of his questions was whether support for IDA Pro version 7 was implemented. At that time it was not there, but after the speech I promised to make the appropriate release of the module.  This is where the fun began. <br><br>  Now the most recent is the <a href="https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/hb/nios2/n2cpu-nii5v1gen2.pdf">manual from Intel</a> , which was used to verify and check for errors.  I have significantly reworked the module, added a number of new features, including solving the problems that previously could not be won.  And, of course, added support for the 7th version of IDA Pro.  That's what happened. <br><br><h2>  NIOS II software model </h2><br>  NIOS II is a software processor developed for Altera FPGAs (now part of Intel).  From the point of view of programs, it has the following features: byte order little endian, 32-bit address space, 32-bit instruction set, i.e., 4 bytes are fixed, 32 general registers and 32 special purposes are used for encoding each command. <br><br><h2>  Disassembling and Code References </h2><br>  So, we have opened a new file in IDA Pro, with firmware for NIOS II processor.  After installing the module, we will see it in the list of IDA Pro processors.  The choice of processor is presented in the figure. <br><br><img src="https://habrastorage.org/webt/9x/wd/ni/9xwdnil54uqjf3wru4nqcc0fkr8.png"><br><br>  Suppose that the module has not yet implemented even basic command parsing.  Given that each command takes 4 bytes, we group bytes by four, then everything will look something like this. <br><br><img src="https://habrastorage.org/webt/be/v9/_j/bev9_jokezmrwfxgr5gtscagrma.png"><br><br>  After implementing the basic functionality of decoding instructions and operands, displaying them, and analyzing control transfer instructions, the set of bytes from the example above is converted to the following code. <br><br><img src="https://habrastorage.org/webt/w6/zm/5c/w6zm5c7rzp0ee0qec2twmkzdnxe.png"><br><br>  As you can see from the example, cross-references are also formed from the control transfer commands (in this case, you can see the conditional transition and the procedure call). <br><br>  One of the useful properties that can be implemented in the processor modules is the comments to the commands.  If you turn off the output of byte values ‚Äã‚Äãand enable the display of comments, the same piece of code will already look like this. <br><br><img src="https://habrastorage.org/webt/gu/ia/u0/guiau0csjjbidgimzewinug4pvq.png"><br><br>  Here, if you first come across an assembler code of a new architecture for you, you can understand what is happening with the help of comments.  Further, the code examples will be in the same form - with comments, so as not to look at the NIOS II manual, but to immediately understand what is happening in the section of the code that is given as an example. <br><br><h2>  Pseudoinstructions and command simplification </h2><br>  Some of the NIOS II commands are pseudoinstructions.  For such teams there are no separate opcodes, and they are modeled as special cases of other teams.  In the disassembly process, instructions are simplified ‚Äî replacing certain combinations with pseudoinstructions.  Pseudoinstructions in NIOS II can generally be divided into four types: <br><br><ul><li>  when one of the sources is zero (r0) and can be removed from consideration, </li><li>  when there is a negative value in the command and the command is replaced with the opposite, </li><li>  when the condition is replaced with the opposite, </li><li>  when the 32-bit offset is entered in two teams in parts (junior and senior) and this is replaced by one command. </li></ul><br>  The first two types have been implemented, since the replacement of the condition does not give much, and the 32-bit offsets have more options than the ones presented in the manual. <br><br>  For example, for the first view, consider the code. <br><br><img src="https://habrastorage.org/webt/ix/if/kt/ixifktzau98plchui3ypjf0qn6c.png"><br><br>  It can be seen that the use of the zero register in calculations is often found here.  If you look closely at this example, you will notice that all commands except the transfer of control are variants of simply entering values ‚Äã‚Äãinto certain registers. <br><br>  After implementing the processing of pseudoinstructions, we get the same piece of code, but now it looks more readable, and instead of variations of the or and add commands, we get the variations of the mov command. <br><br><img src="https://habrastorage.org/webt/ka/4j/_q/ka4j_qwz2elzmsmccfrewbtn9cc.png"><br><br><h2>  Stack variables </h2><br>  The NIOS II architecture supports the stack, and in addition to the stack pointer sp, there is also a pointer to the stack frame fp.  Consider an example of a small procedure that uses a stack. <br><br><img src="https://habrastorage.org/webt/82/_o/1v/82_o1v_n-ojrlgtveqtfjln2vve.png"><br><br>  Obviously, space is allocated on the stack for local variables.  It can be assumed that the register ra is stored in the stack variable, and then restored from it. <br><br>  After adding functionality to the module that tracks changes to the stack pointer and creates stack variables, the same example will look like this. <br><br><img src="https://habrastorage.org/webt/zg/pk/fx/zgpkfxblezz4cp78gfqswegbjza.png"><br><br>  Now the code looks a little clearer, and it is already possible to name the stack variables and parse their purpose, following the cross-references.  The function in the example is of type __fastcall and its arguments in registers r4 and r5 are put on the stack to call a subroutine that is of type _stdcall. <br><br><h2>  32-bit numbers and offsets </h2><br>  The peculiarity of NIOS II is that in one operation, that is, when executing one command, you can, as a maximum, enter a direct value of 2 bytes (16 bits) into the register.  On the other hand, the processor registers and address space are 32-bit, that is, for addressing in the register, 4 bytes must be added. <br><br>  To solve this problem, two-part displacements are used.  A similar mechanism is used in processors in PowerPC: the offset consists of two parts, the highest and the lowest, and is entered in the register by two commands.  In PowerPC, it looks like this. <br><br><img src="https://habrastorage.org/webt/n8/qm/5z/n8qm5zedw9ffnckmjclzmhfwkh8.png"><br><br>  In this approach, cross-references are formed from both teams, although in fact the adjustment to the address occurs in the second command.  This can sometimes cause inconvenience when counting the number of cross-references. <br><br>  In the offset properties, the non-standard type HIGHA16 is used for the higher part, the type HIGH16 is sometimes used, and the lower part - LOW16. <br><br><img src="https://habrastorage.org/webt/l-/u3/6r/l-u36riq53_ejmry2mwdv7qewp4.png"><br><br>  In the calculation of 32-bit numbers from two parts there is nothing complicated.  Difficulties arise in the formation of operands as offsets for two separate commands.  All this processing falls on the processor module.  There are no examples of how to implement this (especially in Python) in the IDA SDK. <br><br>  In the report at PHDays, the displacements stood as an unsolved problem.  To solve the problem, we cheated: 32-bit offset only from the younger part - on the base.  The base is calculated as the highest part shifted to the left by 16 bits. <br><br><img src="https://habrastorage.org/webt/ip/lc/60/iplc60jwuylhovnugr8qgyxorbq.png"><br><br>  With this approach, a cross reference is formed only from the command for entering the lower part of the 32-bit offset. <br><br>  In the properties of the offset, the base is visible and the property is marked in order to treat it as a number, so that a large number of cross-references to the address itself, which is assumed as the base, are not formed. <br><br><img src="https://habrastorage.org/webt/_3/ui/wy/_3uiwyr9jt0lpipfsounaz07q3c.png"><br><br>  The code for NIOS II contains the following mechanism for inserting 32-bit numbers into a register.  First, the upper part of the offset is entered into the register with the movhi command.  Then the younger part joins her.  This can be done in three ways (commands): addition addi, subtraction subi, logical OR ori. <br><br>  For example, in the next section of the code, the registers are set to 32-bit numbers, which are then entered into registers ‚Äî arguments before the function call. <br><br><img src="https://habrastorage.org/webt/rs/4l/ms/rs4lmsgotpjsjrb92qh6gkk9s-y.png"><br><br>  After adding the calculation of offsets, we get the following representation of this block of code. <br><br><img src="https://habrastorage.org/webt/sg/3c/i_/sg3ci__0-wvfkj-5j40xuemubva.png"><br><br>  The resulting 32-bit offset is displayed next to the entry command for its lowest part.  This example is quite visual, and we could even easily calculate all 32-bit numbers in our mind just by attaching the lower and upper parts.  Judging by the values, most likely, they are not offsets. <br><br>  Consider the case when subtraction is used when entering the younger part.  In this example, to determine the final 32-bit numbers (offsets) on the move will not work. <br><br><img src="https://habrastorage.org/webt/i-/8x/yt/i-8xyto-q5iqeiffz3hua-d29ew.png"><br><br>  After applying the calculation of 32-bit numbers we get the following form. <br><br><img src="https://habrastorage.org/webt/tf/da/8-/tfda8-uw3xkthiqqe930jut8ovs.png"><br><br>  Here we see that now, if the address is in the address space, an offset is formed on it, and the value that was formed as a result of the junior and senior parts is not displayed next to it.  Here we get an offset to the string "10/22/08".  In order for the remaining offsets to point to valid addresses, increase the segment a little. <br><br><img src="https://habrastorage.org/webt/0i/qq/fh/0iqqfhcomre0yd3siixym3vt0o8.png"><br><br>  After increasing the segment, we find that now all the calculated 32-bit numbers are offsets and point to valid addresses. <br><br>  It was mentioned above that there is another option for calculating offsets when the logical OR command is used.  Here is an example code where two offsets are calculated this way. <br><br><img src="https://habrastorage.org/webt/xr/or/am/xroramzy4_lj_g3po7yxo-m0sxy.png"><br><br>  That, which is calculated in the register r8, is then pushed onto the stack. <br><br>  After the conversion, it is clear that in this case the registers are set to the addresses of the beginning of the procedures, that is, the procedure address is added to the stack. <br><br><img src="https://habrastorage.org/webt/wr/au/qm/wrauqmfpotzlhjdiz4_i8mnghri.png"><br><br><h2>  Reading and writing relative to the base </h2><br>  Before that, we considered cases when a 32-bit number entered using two commands could be just a number and also an offset.  In the following example, the base is entered into the upper part of the register, then a read or write occurs relative to it. <br><br><img src="https://habrastorage.org/webt/ho/2v/ve/ho2vvexmp7367xll5prt5xwpc8m.png"><br><br>  After processing such situations, we obtain offsets for variables from the read and write commands themselves.  At the same time, depending on the dimension of the operation, the size of the variable itself is set. <br><br><img src="https://habrastorage.org/webt/cl/pi/g-/clpig-mgt5xtsshbvp67wh9rrdg.png"><br><br><h2>  Switch constructions </h2><br>  The switch constructions met in binary files can facilitate the analysis.  For example, according to the number of choices made inside the switch construction, it is possible to localize a switch responsible for processing some protocol or set of commands.  Therefore, there is the task of recognizing the switch itself and their parameters.  Consider the following code snippet. <br><br><img src="https://habrastorage.org/webt/g9/t7/7u/g9t77ugtkercggcjphfq9xfam_0.png"><br><br>  The execution flow stops at the jmp r2 register transition.  Next come the code blocks that are referenced from the data, and at the end of each block there is a jump to the same label.  Obviously, this is a switch construction and these separate blocks handle specific cases from it.  Above, you can also see the check of the number of cases and the default jump. <br><br>  After adding the switch processing, this code will look like this. <br><br><img src="https://habrastorage.org/webt/rm/qj/hw/rmqjhwhrknmc_cycqu5d57kjpmq.png"><br><br>  Now the jump itself is indicated, the address of the table with offsets, the number of cases, as well as each case with the corresponding number. <br><br>  The table itself with offsets to the options is as follows.  To save space, the first five elements are given. <br><br><img src="https://habrastorage.org/webt/9b/ke/x9/9bkex9oxlk_vv4nrpdya3nckv3m.png"><br><br>  In essence, the switch processing is to go back through the code and search for all its components.  That is, a certain organization of the switch is described.  Sometimes there may be exceptions in the diagrams.  This may be the reason for cases when seemingly visual switches are not recognized in existing processor modules.  It turns out that the real switch simply does not fall under the scheme, which is defined inside the processor module.  There are still possible options when the scheme seems to be there, but inside it there are still other commands not participating in the scheme, or the main commands are swapped, or it is broken by transitions. <br><br>  The NIOS II processor module recognizes a switch with such "extraneous" instructions between the main commands, as well as with the rearranged main commands and with transitions that break the circuit.  A reverse pass through the execution path is used, taking into account possible transitions that break the circuit, with the installation of internal variables that signal different states of the recognizer.  As a result, about 10 different options for the organization of switch, found in the firmware, are recognized. <br><br><h2>  Instructions custom </h2><br>  There is an interesting feature in the NIOS II architecture - the custom instruction.  It gives access to 256 user-definable instructions that are possible in the NIOS II architecture.  In its work, in addition to general-purpose registers, the custom instruction can refer to a special set of 32 custom registers.  After implementing the custom command parsing logic, we get the following view. <br><br><img src="https://habrastorage.org/webt/ws/8d/zo/ws8dzozz7aext7buc0g3re8kwno.png"><br><br>  You may notice that the last two instructions have the same instruction number and seem to perform the same actions. <br><br>  According to the instructions custom there is a <a href="">separate manual</a> .  According to him, one of the most complete and modern versions of the custom instruction set is the NIOS II Floating Point Hardware 2 Component (FPH2) instruction set for working with floating point.  After implementing the FPH2 command parsing, the example will look like this. <br><br><img src="https://habrastorage.org/webt/ex/-q/1g/ex-q1g9sszau_hhllau3_xrvgdw.png"><br><br>  On the mnemonic of the last two teams, we are convinced that they really perform the same action - the fadds command. <br><br><h2>  Jumps by register value </h2><br>  In the studied firmwares, there is often a situation when a jump is made on the register value, into which a 32-bit offset is inserted, which determines the place of the jump. <br><br>  Consider a piece of code. <br><br><img src="https://habrastorage.org/webt/sj/ej/ys/sjejysq65hywye8w6usdbshkc60.png"><br><br>  In the last line there is a jump on the register value, while it is clear that the address of the procedure that begins in the first line of the example is entered into the register first.  In this case, it is obvious that the jump takes place at its beginning. <br><br>  After adding the jump recognition functionality, we get the following view. <br><br><img src="https://habrastorage.org/webt/ov/tm/j2/ovtmj2lcb_8lrx8qmxvekuul0lw.png"><br><br>  Next to the jmp r8 command is the address where the jump occurs, if it was possible to calculate it.  Also formed a cross-reference between the team and the address where the jump occurs.  In this case, the link is visible in the first line, the jump itself is performed from the last line. <br><br><h2>  Register value gp (global pointer), save and load </h2><br>  It is common to use a global pointer that is configured for an address, and relative to it, the variables are addressed.  In NIOS II, the global pointer register is used to store the global pointer.  At a certain point, as a rule, in the initialization procedures of the firmware, the value of the address is entered into the gp register.  The processor module handles this situation;  To illustrate this, the following are code samples and an IDA Pro output window with debug messages enabled in the processor module. <br><br>  In this example, the processor module finds and calculates the value of the gp register in the new database.  When closing the idb base, the gp value is stored in the base. <br><br><img src="https://habrastorage.org/webt/cx/ll/hk/cxllhko-hugm77k68idqqam4wzm.png"><br><br>  When loading an already existing idb base and if the gp value has already been found, it is loaded from the base, as shown in the debugging message in the following example. <br><br><img src="https://habrastorage.org/webt/-y/z7/1u/-yz71u_odhytnmobj0dlfb73v-k.png"><br><br><h2>  Read and write relative to gp </h2><br>  Common operations are reading and writing with an offset from the gp register.  For example, the following example performs three reads and one write of this type. <br><br><img src="https://habrastorage.org/webt/6b/0l/-b/6b0l-bqxv1qiuw5nvh3i08vvstk.png"><br><br>  Since the value of the address, which is stored in the register gp, we have already received, it is possible to address this kind of reading and writing. <br><br>  After adding the processing of read and write situations relative to the gp register, we obtain a more convenient picture. <br><br><img src="https://habrastorage.org/webt/wx/st/c1/wxstc1auiw0z0gvfzwmcooocooq.png"><br><br>  Here you can see which variables are addressed, track their use and identify their purpose. <br><br><h2>  Gp addressing </h2><br>  There is another use of the gp register for addressing variables. <br><br><img src="https://habrastorage.org/webt/ng/nn/oc/ngnnocz7scbya0x41l7gagf4bew.png"><br><br>  For example, here we see that registers are configured relative to the gp register to some variables or data areas. <br><br>  After adding functionality that recognizes such situations, which transforms into offsets and adds cross-references, we get the following form. <br><br><img src="https://habrastorage.org/webt/sm/0d/nd/sm0dndgvrmn2xwivnfux3ol-t1e.png"><br><br>  Here you can already see on which areas registers are configured for gp, and it becomes clearer what is happening. <br><br><h2>  Addressing relatively sp </h2><br>  Similarly, in the following example, the registers are tuned to some memory areas, this time relative to the sp register, the stack pointer. <br><br><img src="https://habrastorage.org/webt/p1/nv/k7/p1nvk7gox_d3cwi1gof80k_oizq.png"><br><br>  Obviously, the registers are tuned to some local variables.  Such situations ‚Äî setting arguments to local buffers before procedure calls ‚Äî are quite common. <br><br>  After adding processing (converting immediate values ‚Äã‚Äãto offsets), we obtain the following form. <br><br><img src="https://habrastorage.org/webt/mg/8s/ps/mg8spswm9tq-_zjj-80s0s6lbnk.png"><br><br>  Now it becomes clear that after calling the procedure, the values ‚Äã‚Äãare loaded from those variables whose addresses were passed as parameters before the function call. <br><br><h2>  Cross references from code to structure fields </h2><br>  Defining structures and using them in IDA Pro can facilitate code analysis. <br><br><img src="https://habrastorage.org/webt/l6/4u/8u/l64u8ubhx9-ypg1vo914_fa8vta.png"><br><br>  Looking at this section of the code, one can understand that the field field_8 is incremented and, possibly, is the counter of the occurrence of any event.  If the reading and writing fields are separated in the code at a great distance, cross-references can help in the analysis. <br><br>  Consider the structure itself. <br><br><img src="https://habrastorage.org/webt/px/zf/lt/pxzflte9x7kmxfrnipa_yjerstc.png"><br><br>  Although, as you can see, there are no references to the fields of the structures from the code to the elements of the structures. <br><br>  After such situations are handled, for our case everything will look like this. <br><br><img src="https://habrastorage.org/webt/k_/7t/zu/k_7tzupju7tyyje9r-i6ed6ra08.png"><br><br>  Now there are cross-references to the fields of structures from specific commands that work with these fields.  Forward and backward cross references are created, and you can track through different procedures, where the values ‚Äã‚Äãof the structure fields are read and where they are entered. <br><br><h2>  Discrepancies between the manual and reality </h2><br>  In the manual when decoding some commands certain bits must take strictly defined values.  For example, for the return command from an eret exception, bits 22-26 should be 0x1E. <br><br><img src="https://habrastorage.org/webt/6r/o4/ys/6ro4ys-mrzuck_-stdnjctilwq8.png"><br><br>  Here is an example of this command from a single firmware. <br><br><img src="https://habrastorage.org/webt/te/lv/at/telvatwfv4tmdjpaurhickredpo.png"><br><br>  Opening another firmware in a place with a similar context, we meet a different situation. <br><br><img src="https://habrastorage.org/webt/ss/p3/qg/ssp3qgrbyu4stqyfht6mmzitgmi.png"><br><br>  These bytes are not automatically converted into a command, although there is processing of all commands.  Judging by the environment, and even a similar address, it must be the same team.  Let's look carefully at the bytes.  This is the same eret command, with the exception that bits 22-26 are not equal to 0x1E, but equal to zero. <br><br>  It is necessary to correct a little analysis of this command.  Now it is not quite the manual, but true. <br><br><img src="https://habrastorage.org/webt/as/fn/nl/asfnnlau91zf6y1aan-f3l__wz0.png"><br><br><h2>  IDA 7 support </h2><br>  Beginning with IDA 7.0, the API provided by IDA Python for regular scripts has changed quite a lot.  As for the processor modules, the changes are colossal.  Despite this, the NIOS II processor module managed to be remade to version 7, and it successfully worked in it. <br><br><img src="https://habrastorage.org/webt/-w/zh/z_/-wzhz_lzuq_ad226tgx_0abl3ke.png"><br><br>  The only incomprehensible point: when loading a new binary file under NIOS II in IDA 7, the initial automatic analysis that is present in IDA 6.9 does not occur. <br><br><h2>  Conclusion </h2><br>  In addition to the basic disassembly functionality, examples of which are in the SDK, the processor module has many different features that facilitate the work of the code researcher.  It is clear that all this can be done manually, but, for example, when there are thousands and tens of thousands of displacements of different types on a binary file with firmware of a size of a couple of megabytes - why waste time on it?  Let the processor module do it for us.  After all, how pleasant the possibility of quick navigation through the code under study with the help of cross references helps!  This makes IDA such a convenient and enjoyable tool as we know it. <br><br>  <b>Author</b> : Anton Dorfman, Positive Technologies </div><p>Source: <a href="https://habr.com/ru/post/424085/">https://habr.com/ru/post/424085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424071/index.html">The theory of happiness. Thermodynamics of class inequality</a></li>
<li><a href="../424073/index.html">Remote code execution in the Microsoft JET Database Engine</a></li>
<li><a href="../424077/index.html">France is demanding to make the ‚Äúright to oblivion‚Äù global - what it can affect</a></li>
<li><a href="../424081/index.html">RESS - New architecture for mobile applications</a></li>
<li><a href="../424083/index.html">Service for trading on the stock exchange Robinhood accused of selling data on user requests to high-frequency traders</a></li>
<li><a href="../424087/index.html">The machine on the Arduino, controlled by an Android device via Bluetooth, is a full cycle (part 1)</a></li>
<li><a href="../424089/index.html">Conference for evil. Or good?</a></li>
<li><a href="../424091/index.html">WiX.Py: we assemble MSI package ‚Äúin three lines‚Äù</a></li>
<li><a href="../424093/index.html">From antique radio to DIY speakers: 12 channels on YouTube about acoustics devices</a></li>
<li><a href="../424095/index.html">By 2024, a cellular network for officials and security officials will appear in the Russian Federation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>