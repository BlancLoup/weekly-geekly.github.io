<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Do WAFs dream about statistical analyzers?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the most popular trends in the field of protecting applications of the current decade is virtual patching (VP) technology, which helps protect ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Do WAFs dream about statistical analyzers?</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/pt/blog/338110/"><img src="https://habrastorage.org/web/a66/306/d4d/a66306d4dd13434384ed1575510da38d.png" align="left"></a>  One of the most popular trends in the field of protecting applications of the current decade is virtual patching (VP) technology, which helps protect a web application from exploiting known vulnerabilities at the web application firewall level (here and further WAF is a dedicated solution operating on a separate node between the gateway to the external network and the web server).  VP technology is based on building rules for filtering HTTP requests on the WAF side based on the results of the static application security analysis tools (static application security testing, SAST).  However, due to the fact that SAST and WAF tools rely on different models of application presentation and different decision-making methods, there are still no truly effective solutions for their integration on the market.  In the framework of SAST, work with the application is carried out according to the white box model and, as a rule, formal approaches are used to search for vulnerabilities in the code.  For WAF, the application is a black box, and heuristics are used to detect attacks.  This does not allow VPs to be effectively used to protect against attacks in cases where the exploitation conditions of the vulnerability go beyond the trivial `http_parameter = plain_text_attack_vector` scheme. <br><br>  But what if ‚Äúmaking friends‚Äù of SAST and WAF in such a way that information on the internal device of the application obtained with the help of SAST became available on the WAF side and gave him the opportunity to detect attacks on detected vulnerabilities - not guessing, but proving the fact of the attack? <br><a name="habracut"></a><br><h2>  The glitz and poverty of traditional VP </h2><br>  The traditional approach to automating the creation of virtual patches for web applications is to provide WAF information about each vulnerability detected with SAST, including: <br><br><ul><li>  vulnerability class; </li><li>  Vulnerable entry point to the web application (URL or part thereof); </li><li>  the values ‚Äã‚Äãof the additional parameters of the HTTP request, in which the attack becomes possible; </li><li>  the values ‚Äã‚Äãof the vulnerable parameter ‚Äî the carrier of the attack vector; </li><li>  set of characters or words (tokens), the appearance of which in a vulnerable parameter will lead to exploitation of a vulnerability. </li></ul><br>  To determine the values ‚Äã‚Äãof the parameters of the HTTP request and the dangerous elements of the vulnerable parameter, both a simple enumeration of all possible elements and a generating function (as a rule, based on regular expressions) can be used.  Consider an ASP.NET page snippet vulnerable to <a href="https://habrahabr.ru/company/pt/blog/149152/">XSS</a> attacks: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cs hljs"><span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> condition = Request.Params[<span class="hljs-string"><span class="hljs-string">"condition"</span></span>]; <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> param = Request.Params[<span class="hljs-string"><span class="hljs-string">"param"</span></span>]; <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || param == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-number"><span class="hljs-number">05</span></span> { <span class="hljs-number"><span class="hljs-number">06</span></span> Response.Write(<span class="hljs-string"><span class="hljs-string">"Wrong parameters!"</span></span>); <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-number"><span class="hljs-number">08</span></span> } <span class="hljs-number"><span class="hljs-number">09</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> response; <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition == <span class="hljs-string"><span class="hljs-string">"secret"</span></span>) <span class="hljs-number"><span class="hljs-number">12</span></span> { <span class="hljs-number"><span class="hljs-number">13</span></span> response = <span class="hljs-string"><span class="hljs-string">"Parameter value is `"</span></span> + param + <span class="hljs-string"><span class="hljs-string">"`"</span></span>; <span class="hljs-number"><span class="hljs-number">14</span></span> } <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> { <span class="hljs-number"><span class="hljs-number">17</span></span> response = <span class="hljs-string"><span class="hljs-string">"Secret not found!"</span></span>; <span class="hljs-number"><span class="hljs-number">18</span></span> } <span class="hljs-number"><span class="hljs-number">19</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> Response.Write(<span class="hljs-string"><span class="hljs-string">"&lt;b&gt;"</span></span> + response + <span class="hljs-string"><span class="hljs-string">"&lt;/b&gt;"</span></span>);</code> </pre> <br>  As a result of the analysis of this code, the symbolic formula of the conditional set of its values ‚Äã‚Äãwill be derived for the attack vector: <br><br> <code>{condition = "secret" ‚áí param ‚àà { XSShtml-text }},  XSShtml-text ‚Äî    XSS-   TEXT,    HTML.</code> <br> <br>  Both exploit and virtual patch can be derived from this formula.  Based on the virtual patch descriptor, WAF generates filtering rules that allow you to block all HTTP requests that may lead to exploitation of the found vulnerability. <br><br>  This approach, of course, allows you to defend against a number of attacks, but it also has significant drawbacks: <br><br><ul><li>  to prove the vulnerability of the SAST tool enough to detect one of the possible vectors of attacks on it.  To effectively eliminate vulnerability, it is necessary to defend against all possible vectors, which can be difficult to communicate to the WAF side, since their set is not only infinite, but often cannot be expressed by regular expressions due to the irregularity of the attack vector grammars; </li><li>  the same applies to the values ‚Äã‚Äãof all additional query parameters at which the exploitation of a vulnerability becomes possible; </li><li>  information about dangerous elements of a vulnerable parameter is useless if, on the way from the entry point to the vulnerable point of execution, the attack vector undergoes intermediate transformations, changing the context of its grammar or even the entire grammar (for example, Base64, URL or HTML coding, string conversions). ). </li></ul><br>  These shortcomings lead to the fact that the VP technology, focused on protection from particular cases, does not effectively protect against all possible attacks on vulnerabilities detected using SAST tools.  In addition, traffic filtering rules constructed in this way often result in the blocking of regular HTTP requests and disruption of the protected application.  Let's change the vulnerable code a bit: <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> condition = Request.Params[<span class="hljs-string"><span class="hljs-string">"condition"</span></span>]; <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> param = Request.Params[<span class="hljs-string"><span class="hljs-string">"param"</span></span>]; <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || param == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-number"><span class="hljs-number">05</span></span> { <span class="hljs-number"><span class="hljs-number">06</span></span> Response.Write(<span class="hljs-string"><span class="hljs-string">"Wrong parameters!"</span></span>); <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-number"><span class="hljs-number">08</span></span> } <span class="hljs-number"><span class="hljs-number">09</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> response; <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-comment"><span class="hljs-comment">// CustomDecode    base64-URL-base64 12 if (CustomDecode(condition).Contains("secret")) 13 { 14 response = "Parameter value is `" + CustomDecode(param) + "`"; 15 } 16 else 17 { 18 response = "Secret not found!"; 19 } 20 21 Response.Write(response);</span></span></code> </pre><br>  The only difference with the previous example is that now both query parameters undergo some conversion and the condition on the `secret` parameter is relaxed until the substring is turned on.  The formula of the attack vector as a result of the analysis of this code will look like: <br><br> <code>(String.Contains (CustomDecode (condition)) ("secret")) ‚áí param ‚àà (CustomDecode { XSShtml-text })</code> <br> <br>  At the same time, for the function CustomDecode in the corresponding vertex of CompFG, the analyzer will display a formula describing the Base64-URL-Base64 transformation chain: <br><br> <code>(Base64Decode (UrlDecode (Base64Decode argument)))</code> <br> <br>  According to the formulas of this type, it is still possible to build an exploit (we described this in detail in one of our previous <a href="https://habrahabr.ru/company/pt/blog/305000/">articles</a> ), but the classical approach to building virtual patches is no longer possible here because: <br><br><ul><li>  exploitation of the vulnerability is possible only if the decoded query parameter `condition` will contain the substring‚Äú secret ‚Äù(line 12), but the set of values ‚Äã‚Äãfor such a parameter is very large, and it is difficult to express it through regular expressions due to irregular decoding functions; </li><li>  The request parameter, which is the attack vector, is also decoded (line 14), which prevents the SAST tool from generating many of its dangerous elements for WAF. </li></ul><br>  Since all the problems of the traditional VP grow from the inability to work with the application at the WAF level on the white box model, it is obvious that in order to eliminate them it is necessary to realize this possibility and refine the approach so that: <br><br><ul><li>  SAST provided WAF with complete information about all the transformations to which the vulnerable parameter and the conditions of a successful attack from the entry point to the vulnerable point are exposed so that WAF can calculate the values ‚Äã‚Äãof the arguments in it, based on the values ‚Äã‚Äãof the parameters of the HTTP request being processed; </li><li>  For detection of attacks, not heuristic methods were used, but formal methods based on the strict proof of certain statements and covering the general case of the operating conditions of each specific vulnerability instead of a limited set of particular ones. </li></ul><br>  This is how virtual execution time patching technology was born. <br><br><h2>  Runtime virtual patching </h2><br>  At the core of the runtime virtual patching (RVP) technology is the model of the application under investigation called computation flow graph (CompFG) used in the source code analyzer PT Application Inspector (PT AI).  This model was described in detail as part of the <a href="https://www.youtube.com/watch%3Fv%3DapQEQQm6GaE%26feature%3Dyoutu.be">AppSec Slums</a> Master Class on PHDays VII.  CompFG is built during application analysis as a result of abstract interpretation of its code in semantics, similar to traditional symbolic calculations.  The vertices of this graph contain generating formulas in the target language, specifying the set of valid values ‚Äã‚Äãfor all data streams present at the corresponding points of execution.  These threads are called execution point arguments.  For example, the top of the vulnerable point of the implementation of the above example in CompFG looks like this: <br><br><img src="https://habrastorage.org/web/6ab/daf/be2/6abdafbe2f82409882d0251767b0a9d8.png"><br><br>  One of the properties of CompFG is its concretizability - the ability to calculate the sets of specific values ‚Äã‚Äãof all arguments at any point of the application, setting values ‚Äã‚Äãfor all input parameters. <br><br>  The RVP workflow is divided into two phases, corresponding to the stages of the application life cycle ‚Äî deployment (steps D) and execution (steps R): <br><br><img src="https://habrastorage.org/web/67c/08d/e97/67c08de977c54682bd3e6909ecdf5181.png"><br><br><h2>  Deployment phase </h2><br>  Before deploying the next version of the application, it is analyzed using PT AI, as a result of which three formulas are derived from each vertex of CompFG describing the vulnerable execution point: <br><br><ul><li>  condition of reachability of the point itself; </li><li>  condition of accessibility of the values ‚Äã‚Äãof all its arguments; </li><li>  sets of values ‚Äã‚Äãof all its arguments and grammars to which they correspond. </li></ul><br>  All formula sets are grouped based on the fact that the vulnerability belongs to the control flow of one or another entry point into the web application.  The concept of an entry point is specific to each of the PT AI supported web frameworks and is defined in the analyzer's knowledge base. <br><br>  After that, the report with detected vulnerabilities and related formulas is uploaded in the form of code in a special domain language, based on the syntax of S-expressions and allowing the CompFG formulas to be described in a form independent of the target language.  The formula for the value of the vulnerable point argument of the previously reviewed sample code is as follows: <br><br> <code>(+ ("Parameter value is `") (FromBase64Str (UrlDecodeStr (FromBase64Str (GetParameterData (param))))) ("`")), <br></code> <br>  and the formula for its reachability is: <br><br> <code>(Contains (FromBase64Str (UrlDecodeStr (FromBase64Str (GetParameterData (condition))))) ("secret")). <br></code> <br>  The resulting report is loaded into PT Application Firewall (PT AF), and on its basis a binary module is generated, allowing to calculate all formulas present in it.  The decompiled code for calculating the condition of accessibility of the vulnerable point of the considered example looks like this: <br><br><img src="https://habrastorage.org/web/398/6a1/e5a/3986a1e5abc2422da22fa0b61ad35654.png"><br><br>  In order for the calculation of the formulas to be possible, on the PT AF side it is necessary to have (optional): <br><br><ul><li>  some base solvers all functions that may appear in the report; </li><li>  An isolated sandbox with a runtime environment for the language or platform on which the protected application is running (CLR, JVM, PHP, Python or Ruby interpreter, etc.) and the libraries that are used in the application. </li></ul><br>  The first option gives the maximum speed, but involves a huge amount of manual work on the part of the developers of WAF for describing calculators (even if limited to only the functions of standard libraries).  The second option allows you to calculate all the functions that may occur in the report, but also increases the processing time of each HTTP request due to the need to call the runtime environment to calculate each function.  The best option here is when the first option is used for the most common functions, and all the rest are calculated using the second one. <br><br>  It is quite possible that a formula will encounter a function where the analyzer cannot ‚Äúfail‚Äù (for example, calling a method related to a missing project dependency or to native code) and (or) which is also impossible on the PT AF side (for example, function of reading data from external sources or server environment).  Such functions are marked in the formulas with the unknown flag and processed in a special way (see below). <br><br><h2>  Stage of operation </h2><br>  At the operational stage, for each HTTP request, WAF delegates its processing to the generated binary module.  The module analyzes the request and determines its associated entry point into the web application.  For this point, the formulas for all the vulnerabilities detected as a result of its analysis are selected - and then calculated in a certain way. <br><br>  First, the formulas of both conditions are calculated: the reachability of the vulnerable point and the values ‚Äã‚Äãof all its arguments.  Instead of variables, the values ‚Äã‚Äãof the corresponding query parameters are substituted into each formula, after which its value is calculated.  If expressions with unknown flag are present in the formula, it is processed as follows: <br><br><ul><li>  each unknown flag propagates through the expression expression tree from bottom to top until it marks a Boolean expression; </li><li>  all such expressions (unknown domains) are replaced in the formula with Boolean variables and the resulting Boolean satisfiability problem is solved for the resulting formula; </li><li>  from the initial condition formula, n conditions are constructed - by substituting possible values ‚Äã‚Äãof unknown-domains from all solutions found at the previous step; </li><li>  the value of each of the formulas obtained is calculated, and if at least one of them is satisfiable, then the initial condition is also considered to be satisfiable. </li></ul><br>  If, as a result of the calculation, a false value of the original formula was obtained, this means that this HTTP request cannot lead the application to a vulnerable point with dangerous values ‚Äã‚Äãof all its arguments.  In this case, the RVP simply returns the processing of the request to the main WAF module. <br><br>  In the case of the fulfillment of the conditions of attack on vulnerability, it is the turn to calculate the value of the argument of the vulnerable point.  The algorithm used for this depends on the class of vulnerability to which the point being processed belongs.  Common to them is only the logic of processing formulas containing unknown nodes: unlike conditional formulas, such argument formulas cannot be calculated in any way, which is immediately reported to WAF - and then the transition to the next vulnerable point is made.  As an example, consider the most complex of the algorithms used to detect injection class attacks. <br><br><h2>  Injection detection </h2><br>  The class of injections includes any attacks whose purpose is to violate the integrity of the text in any formal language (HTML, XML, JavaScript, SQL, URLs, file paths, etc.) formed on the basis of data controlled by the attacker.  The attack is carried out through the transfer to the application of specially formed input data, the substitution of which in the attacked text will lead to going beyond the limits of the token and the introduction into the text of syntactic structures that are not provided for by the application logic. <br><br>  In the event that the current vulnerable point of the application belongs to this class of attacks, the value of its argument is calculated using the algorithm of the so-called incremental calculation with abstract interpretation in the semantics of taint analysis.  The essence of this algorithm is that each expression of the formula is calculated separately, from bottom to top, and the result of the calculation obtained at each step is additionally marked by the boundaries of ‚Äúpollution‚Äù, based on the semantics of each calculated function and the rules of the <a href="https://en.wikipedia.org/wiki/Taint_checking">traditional taint analysis</a> .  This allows you to select in the final result of the calculation all fragments that were obtained as a result of any transformations of the input data (tainted fragments). <br><br>  For example, for the code above and the HTTP request with the parameters `? Condition = YzJWamNtVjA% 3d &amp; param, for example, for example <br><br><img src="https://habrastorage.org/web/689/61f/2d2/68961f2d29914de99171d0930e36952d.png"><br><br>  Further, the obtained value is divided into tokens in accordance with the grammar of the argument of the vulnerable point, and if more than one token fell on any of the tainted fragments, then this is a formal sign of a detected attack (by definition, an injection): <br><br><img src="https://habrastorage.org/web/14a/518/941/14a5189417f542b48ae5455e63a5ff95.png"><br>  At the end of the calculation of the formulas for all vulnerabilities related to the current entry point, the request processing is transferred to the main WAF module along with the detection results. <br><br><h2>  Advantages and features of RVP </h2><br>  The approach to the protection of an application implemented in this way based on the results of the analysis of the security of its code has a number of significant advantages over the traditional VP: <br><br><ul><li>  due to the formal approach described above and the ability to take into account any intermediate transformations of the output data, all the indicated disadvantages of the traditional VP are eliminated; </li><li>  the formal approach also completely eliminates the possibility of errors of the first kind (false positives, false positive), provided there is no unknown-node in the formulas; </li><li>  the absence of any negative impact on the functions of the web application, since the protection is implemented not simply in accordance with them, but on their basis. </li></ul><br>  A prototype of the PT Application Inspector and PT Application Firewall integration module in the form of the HTTP module of the IIS web server under the .NET platform was developed for running in the technology and confirming its effectiveness.  You can watch a demonstration of his work with the reviewed code sample on <a href="https://www.youtube.com/watch%3Fv%3DU1NbKuZkb8c">YouTube</a> .  Performance tests on one and a half dozen open CMS showed more than acceptable results: the processing time of HTTP requests using RVP turned out to be comparable to the time they were processed by traditional (heuristic) WAF methods.  The average percentage of slowing the response of a web application to requests was: <br><br><ul><li>  0% when processing requests that do not lead to the vulnerable point; </li><li>  6‚Äì10% for processing requests that lead to a vulnerable point, but are not an attack (depending on the complexity of the grammar of the vulnerable point); </li><li>  4‚Äì7% when processing requests that lead to a vulnerable point and are an attack. </li></ul><br>  Despite the obvious advantages over traditional VP, RVP still has a number of conceptual limitations that I would like to get rid of: <br><br><ul><li>  there is no possibility to calculate the values ‚Äã‚Äãof such formulas in which there are external data from sources that are absent on the WAF side (file resources, database, server environment, etc.); </li><li>  The quality of formulas directly depends on the quality of approximation of some code fragments during its analysis (cycles, recursion, calls to external library methods, etc.); </li><li>  the description of the semantics of transforming functions for the base of calculators requires a certain amount of engineering work, which is weakly automated and allows for the appearance of errors related to the human factor. </li></ul><br>  However, it was possible to eliminate these shortcomings by shifting some of the RVP functionality to the application side and applying the technologies that underlie the self-protection of the runtime applications (runtime application self-protection, RASP). <br><br>  But about this - in the second part of the article :) </div><p>Source: <a href="https://habr.com/ru/post/338110/">https://habr.com/ru/post/338110/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338100/index.html">Remote desktop + distributed commands =?</a></li>
<li><a href="../338102/index.html">As I was interviewing for the position of Junior .Net Developer</a></li>
<li><a href="../338104/index.html">My experience in conducting Java courses for new employees</a></li>
<li><a href="../338106/index.html">Nuklear + - mini cross-platform GUI</a></li>
<li><a href="../338108/index.html">5 rules for working with amounts</a></li>
<li><a href="../338114/index.html">The digest of interesting materials for the mobile developer # 221 (September 11-17)</a></li>
<li><a href="../338116/index.html">Reverse engineering of the first smart watch Seiko UC-2000</a></li>
<li><a href="../338118/index.html">How to write your first Linux device driver. Part 2</a></li>
<li><a href="../338120/index.html">Metrics in the software development process: GQM model</a></li>
<li><a href="../338122/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ280 (September 11 - 17, 2017)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>