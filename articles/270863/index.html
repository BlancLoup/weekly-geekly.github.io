<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We are switching from STM32 to the Russian K1986BE92QI microcontroller. Practical application: We interrogate keys, we generate PWM. Comparison of CMSIS and SPL code (PWM + TIM + PORT). Part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction.  In the previous article, we repeated the general structure of the timer and examined in detail the manual way to configure the PWM chan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We are switching from STM32 to the Russian K1986BE92QI microcontroller. Practical application: We interrogate keys, we generate PWM. Comparison of CMSIS and SPL code (PWM + TIM + PORT). Part two</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction. </h4>  In the <a href="http://habrahabr.ru/post/267051/">previous article,</a> we repeated the general structure of the timer and examined in detail the manual way to configure the PWM channel using CMSIS.  But many do not like ‚Äúdigging into registers‚Äù and they prefer a fundamentally different level of abstraction, which allows, as it seems to them, to simplify the task.  In this article I will try to show you all the pros and cons of this approach. <a name="habracut"></a><br><br><h4>  The change in the supply of material. </h4>  In all previous articles, I described all the knowledge on a task in one consistently formed text, trying not to miss all the subtleties and details, while receiving a rather lengthy, but exhaustive, any questions article.  As a result, opinions about my articles are divided.  Someone liked that the articles did not contain references to literature and all the necessary information for understanding the article is in the article itself or in its predecessors.  But on the contrary, it was not interesting for someone to read about ‚Äúelementary things‚Äù (such as language syntax, standard block organization, etc.) and people closed the article that was not read.  Since I do not like to refer people to literature, but at the same time I don‚Äôt want anything in the article to be clear, the material will now be presented as follows: the main text is the text for people who understand what they read and have experience on this topic.  For those who do not know something or do not fully understand it - under the spoilers marked "Explanations to ...." - all the information necessary for understanding the article will be collected. <br><br><h4>  Task. </h4>  Our task is to solve the same problem that we solved in the previous article, but using only SPL capabilities.  As a result, we will be able to say which approach is more visual, fast and weighs less.  As a consequence, we will create as many functions as there were in the previous implementation with the same names, except that we add ‚ÄúSPL‚Äù to distinguish them and compare the effect of each function on the weight and performance of the code (Replacing the manual initialization function with function with automatic initialization by means of SPL). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Configuring I / O ports using SPL (PORT). </h4>  I propose to start with the simplest.  With I / O ports for a manually controlled LED.  Previously, this function was called initPinPortCForLed.  Now there will be initPinPortCForLedSPL.  Names of subsequent functions will have the same naming convention.  As we remember, in order for the port to start and we could light the LED - you need: <ol><li>  Send a clock signal to the port. </li><li>  Initialize the port itself. </li><li>  Set the value to the register RXTX. </li></ol>  So it was when we worked with CMSIS directly.  With SPL, it's a little different.  To configure any peripheral module you need to fill the structure.  Sometimes - not one.  And then transfer it to a function that sets everything up. <div class="spoiler">  <b class="spoiler_title">Explanation of what was said.</b> <div class="spoiler_text">  You can draw an analogy with the construction of the house: you make a drawing for all the requirements, and then pass it on to the people who are building the house themselves.  You do not care how the house will be built.  You mean exactly as in your drawing.  Here the ‚Äúdrawing‚Äù is the structure you have configured.  And ‚Äúpeople building a house‚Äù is a function of SPL.  For each block of the periphery there is its own structure.  You can find out what structure is required by looking into a file in the spl folder (in the project tree) with the name MDR32F9Qx_peripheral_name. </div></div>  First we need to send a clock signal to the port.  To do this, we need to refer to the file <u>MDR32F9Qx_rst_clk.h</u> .  In it, at the very end, there are functions that SPL can provide us.  Of all the variety of functions, we are only interested in <b>RST_CLK_PCLKcmd</b> .  With its help, we can send a clocking signal to any peripheral block. <pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RST_CLK_PCLKcmd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RST_CLK_PCLK, FunctionalState NewState)</span></span></span></span>;</code> </pre>  The function has two parameters: <br><ul><li>  <b>RST_CLK_PCLK</b> - the name of the peripheral unit to which you want to send or from which you want to remove the clock signal (clock signal).  Possible names can be found by searching the same <b>.h</b> file, by typing RST_CLK_PCLK as the desired one. <div class="spoiler">  <b class="spoiler_title">Possible values ‚Äã‚Äãfor RST_CLK_PCLK</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> USE_MDR1986VE9x </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* For cortex M3 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_CAN1 PCLK_BIT(MDR_CAN1_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_CAN2 PCLK_BIT(MDR_CAN2_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_USB PCLK_BIT(MDR_USB_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_EEPROM PCLK_BIT(MDR_EEPROM_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_RST_CLK PCLK_BIT(MDR_RST_CLK_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_DMA PCLK_BIT(MDR_DMA_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_UART1 PCLK_BIT(MDR_UART1_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_UART2 PCLK_BIT(MDR_UART2_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_SSP1 PCLK_BIT(MDR_SSP1_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_09 PCLK_BIT(0x40048000) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_I2C PCLK_BIT(MDR_I2C_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_POWER PCLK_BIT(MDR_POWER_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_WWDG PCLK_BIT(MDR_WWDG_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_IWDG PCLK_BIT(MDR_IWDG_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_TIMER1 PCLK_BIT(MDR_TIMER1_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_TIMER2 PCLK_BIT(MDR_TIMER2_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_TIMER3 PCLK_BIT(MDR_TIMER3_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_ADC PCLK_BIT(MDR_ADC_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_DAC PCLK_BIT(MDR_DAC_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_COMP PCLK_BIT(MDR_COMP_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_SSP2 PCLK_BIT(MDR_SSP2_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_PORTA PCLK_BIT(MDR_PORTA_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_PORTB PCLK_BIT(MDR_PORTB_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_PORTC PCLK_BIT(MDR_PORTC_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_PORTD PCLK_BIT(MDR_PORTD_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_PORTE PCLK_BIT(MDR_PORTE_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_26 PCLK_BIT(0x400D0000) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_BKP PCLK_BIT(MDR_BKP_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_28 PCLK_BIT(0x400E0000) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_PORTF PCLK_BIT(MDR_PORTF_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_EBC PCLK_BIT(MDR_EBC_BASE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RST_CLK_PCLK_31 PCLK_BIT(0x400F8000) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_RST_CLK_PCLK(PCLK) ((((PCLK) &amp; RST_CLK_PCLK_09) == 0x00) &amp;&amp; \ (((PCLK) &amp; RST_CLK_PCLK_26) == 0x00) &amp;&amp; \ (((PCLK) &amp; RST_CLK_PCLK_28) == 0x00) &amp;&amp; \ (((PCLK) &amp; RST_CLK_PCLK_31) == 0x00)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// #ifdef USE_MDR1986VE9x /* For cortex M3 */</span></span></span></span></code> </pre> </div></div>  Please note that for each series of microcontrollers this list is different.  In most points, the lists are identical, but some individual lines for each series may differ. </li><li>  <b>NewState</b> - the state in which you want to transfer the clocking signal.  Either <b>DISABLE</b> - disable clocking, or <b>ENABLE</b> - enable clocking. </li></ul>  Recall that our LED is connected to PC1.  It is not difficult to guess that in our case the function will look like this. <pre> <code class="cpp hljs">RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTC, ENABLE); <span class="hljs-comment"><span class="hljs-comment">//    C.</span></span></code> </pre>  Now we have a clock signal on the I / O port we need and we can begin to configure it.  First we need to find the function that configures the port.  It is in the file <u>MDR32F9Qx_port.h</u> .  Called <b>PORT_Init</b> and has the following form. <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PORT_Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MDR_PORT_TypeDef* PORTx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PORT_InitTypeDef* PORT_InitStruct)</span></span></span></span>;</code> </pre>  As we can see, this function also has 2 parameters: <ol><li>  <b>MDR_PORT_TypeDef</b> is the name of the port we are setting up.  In the format MDR_PORTX, where instead of X - the letter of our port (A, B, C ...).  In our case there will be <b>MDR_PORTC</b> . </li><li>  The second parameter is a <b>structure of the form PORT_InitTypeDef</b> .  Its description is in the same file ( <u>MDR32F9Qx_port.h</u> ).  Unfortunately, the SPL description is entirely in English.  As a result, a person who does not know English and is unfamiliar with the device of the periphery at the register level will be quite hard.  Yes, and sometimes on the true meaning of the comments to the functions have at first just guess.  An understanding of their purpose comes only after a careful study of the block diagram of a peripheral module. <div class="spoiler">  <b class="spoiler_title">Structure Description PORT_InitTypeDef</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> PORT_Pin; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Specifies PORT pins to be configured. This parameter is a mask of @ref PORT_pins_define values. */</span></span> PORT_OE_TypeDef PORT_OE; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Specifies in/out mode for the selected pins. This parameter is one of @ref PORT_OE_TypeDef values. */</span></span> PORT_PULL_UP_TypeDef PORT_PULL_UP; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Specifies pull up state for the selected pins. This parameter is one of @ref PORT_PULL_UP_TypeDef values. */</span></span> PORT_PULL_DOWN_TypeDef PORT_PULL_DOWN; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Specifies pull down state for the selected pins. This parameter is one of @ref PORT_PULL_DOWN_TypeDef values. */</span></span> PORT_PD_SHM_TypeDef PORT_PD_SHM; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Specifies SHM state for the selected pins. This parameter is one of @ref PORT_PD_SHM_TypeDef values. */</span></span> PORT_PD_TypeDef PORT_PD; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Specifies PD state for the selected pins. This parameter is one of @ref PORT_PD_TypeDef values. */</span></span> PORT_GFEN_TypeDef PORT_GFEN; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Specifies GFEN state for the selected pins. This parameter is one of @ref PORT_GFEN_TypeDef values. */</span></span> PORT_FUNC_TypeDef PORT_FUNC; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Specifies operating function for the selected pins. This parameter is one of @ref PORT_FUNC_TypeDef values. */</span></span> PORT_SPEED_TypeDef PORT_SPEED; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Specifies the speed for the selected pins. This parameter is one of @ref PORT_SPEED_TypeDef values. */</span></span> PORT_MODE_TypeDef PORT_MODE; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Specifies the operating mode for the selected pins. This parameter is one of @ref PORT_MODE_TypeDef values. */</span></span> }PORT_InitTypeDef;</code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">Explanation: what is a structure, how to fill it, where to get the values?</b> <div class="spoiler_text">  The structure, in fact, is an array, each fixed (has its place in the array) whose cell contains some parameter.  Unlike an array, each structure parameter can have its own type.  Like an array, before filling, the structure must be created. <pre> <code class="cpp hljs">PORT_InitTypeDef Led0PortC_structInit; <span class="hljs-comment"><span class="hljs-comment">//   C.</span></span></code> </pre>  Here PORT_InitTypeDef is a <b>type</b> .  In other words - just a template, on the basis of which the ‚Äúmarkup‚Äù of memory occurs.  Led0PortC_structInit - the name of a specific structure, invented by us.  Like creating a variable of type uint32_t, we set its name, for example Loop, and here we create a structure of type PORT_InitTypeDef with the name Led0PortC_structInit.  It is important to note that the declaration of the structure must be done in the function before the first command.  Otherwise the project will not meet.  After creating the structure you need to fill it.  Filling is as follows. <pre> <code class="cpp hljs">_._ = - ;</code> </pre>  And so - for each parameter from the description.  In the description of each cell there is an explanation of what values ‚Äã‚Äãyou can write to it.  As a rule, if the value is not some arbitrary number from any range, then the description contains the word <b><a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a></b> .  With the help of the word after it, you can find in the file all the available values ‚Äã‚Äãfor this cell.  Take the first cell as an example. <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> PORT_Pin; <span class="hljs-comment"><span class="hljs-comment">/*!&lt; Specifies PORT pins to be configured. This parameter is a mask of @ref PORT_pins_define values. */</span></span></code> </pre>  Using the search, we find <b>PORT_pins_define</b> . <div class="spoiler">  <b class="spoiler_title">We see the following.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_0 0x0001U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 0 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_1 0x0002U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 1 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_2 0x0004U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 2 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_3 0x0008U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 3 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_4 0x0010U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 4 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_5 0x0020U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 5 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_6 0x0040U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 6 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_7 0x0080U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 7 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_8 0x0100U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 8 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_9 0x0200U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 9 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_10 0x0400U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 10 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_11 0x0800U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 11 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_12 0x1000U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 12 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_13 0x2000U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 13 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_14 0x4000U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 14 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_15 0x8000U </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Pin 15 selected */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_Pin_All 0xFFFFU </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; All pins selected */</span></span></span></span></code> </pre> </div></div>  We have PORTC output 1. According to the idea, we can write <pre> <code class="cpp hljs">Led0PortC_structInit.PORT_Pin = PORT_Pin_1;</code> </pre>  But we still have such a define since the last article. <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  . #define LED0 (1&lt;&lt;0) // PORTC. #define LED1 (1&lt;&lt;1) // PORTC.</span></span></code> </pre>  This is the same port mask as in the description, but with a different name.  But it gives a clearer idea of ‚Äã‚Äãwhat we are connecting, so I will write it down. <pre> <code class="cpp hljs">Led0PortC_structInit.PORT_Pin = LED1; <span class="hljs-comment"><span class="hljs-comment">//   .</span></span></code> </pre> </div></div></li></ol>  Having filled out the structure, it will only be <b>necessary</b> to specify it as a parameter of the SPL <b>PORT_Init</b> function, not forgetting the "&amp;" before the name of the structure (passing a pointer to the structure). <div class="spoiler">  <b class="spoiler_title">We will receive ready function of a type.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initPinPortCForLedSPL</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PORT_InitTypeDef Led0PortC_structInit; <span class="hljs-comment"><span class="hljs-comment">//   C. RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTC, ENABLE); //    C. Led0PortC_structInit.PORT_Pin = LED1; //   . Led0PortC_structInit.PORT_FUNC = PORT_FUNC_PORT; //      . Led0PortC_structInit.PORT_GFEN = PORT_GFEN_OFF; //   . Led0PortC_structInit.PORT_MODE = PORT_MODE_DIGITAL; //  . Led0PortC_structInit.PORT_OE = PORT_OE_OUT; //    . Led0PortC_structInit.PORT_PD = PORT_PD_DRIVER; //  . Led0PortC_structInit.PORT_PD_SHM = PORT_PD_SHM_OFF; //   . Led0PortC_structInit.PORT_PULL_DOWN = PORT_PULL_DOWN_OFF; //   0 . Led0PortC_structInit.PORT_PULL_UP = PORT_PULL_UP_OFF; //   1 . Led0PortC_structInit.PORT_SPEED = PORT_SPEED_MAXFAST; //     . PORT_Init(MDR_PORTC, &amp;Led0PortC_structInit); //  . }</span></span></code> </pre> </div></div>  The key initialization function is similar.  The only difference is that we specify the output mode instead of the output - the input ( <i>PORT_OE_IN</i> ), and also turn on the input filter ( <i>PORT_GFEN_ON</i> ). <div class="spoiler">  <b class="spoiler_title">The function of initializing pins connected to the buttons.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initPinForButtonSPL</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . PORT_InitTypeDef buttonPortB_structInit; //        C. PORT_InitTypeDef buttonPortC_structInit; //    C. PORT_InitTypeDef buttonPortE_structInit; //   E. //   . RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTB, ENABLE); //    B. RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTC, ENABLE); //    C. RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTE, ENABLE); //    E. //   . buttonPortB_structInit.PORT_FUNC = PORT_FUNC_PORT; //      . buttonPortB_structInit.PORT_GFEN = PORT_GFEN_ON; //      . buttonPortB_structInit.PORT_MODE = PORT_MODE_DIGITAL; //   . buttonPortB_structInit.PORT_OE = PORT_OE_IN; //    . buttonPortB_structInit.PORT_PD = PORT_PD_DRIVER; //  . buttonPortB_structInit.PORT_PD_SHM = PORT_PD_SHM_OFF; //   . buttonPortB_structInit.PORT_Pin = UP_MSK|RIGHT_MSK; //       . buttonPortB_structInit.PORT_PULL_DOWN = PORT_PULL_DOWN_OFF; //   0 . buttonPortB_structInit.PORT_PULL_UP = PORT_PULL_UP_OFF; //   1 . buttonPortB_structInit.PORT_SPEED = PORT_SPEED_MAXFAST; //     . buttonPortC_structInit.PORT_FUNC = PORT_FUNC_PORT; // PORTC. buttonPortC_structInit.PORT_GFEN = PORT_GFEN_ON; buttonPortC_structInit.PORT_MODE = PORT_MODE_DIGITAL; buttonPortC_structInit.PORT_OE = PORT_OE_IN; buttonPortC_structInit.PORT_PD = PORT_PD_DRIVER; buttonPortC_structInit.PORT_PD_SHM = PORT_PD_SHM_OFF; buttonPortC_structInit.PORT_Pin = SELECT_MSK; buttonPortC_structInit.PORT_PULL_DOWN = PORT_PULL_DOWN_OFF; buttonPortC_structInit.PORT_PULL_UP = PORT_PULL_UP_OFF; buttonPortC_structInit.PORT_SPEED = PORT_SPEED_MAXFAST; buttonPortE_structInit.PORT_FUNC = PORT_FUNC_PORT; // PORTE. buttonPortE_structInit.PORT_GFEN = PORT_GFEN_ON; buttonPortE_structInit.PORT_MODE = PORT_MODE_DIGITAL; buttonPortE_structInit.PORT_OE = PORT_OE_IN; buttonPortE_structInit.PORT_PD = PORT_PD_DRIVER; buttonPortE_structInit.PORT_PD_SHM = PORT_PD_SHM_OFF; buttonPortE_structInit.PORT_Pin = DOWN_MSK|LEFT_MSK; buttonPortE_structInit.PORT_PULL_DOWN = PORT_PULL_DOWN_OFF; buttonPortE_structInit.PORT_PULL_UP = PORT_PULL_UP_OFF; buttonPortE_structInit.PORT_SPEED = PORT_SPEED_MAXFAST; //  . PORT_Init(MDR_PORTB, &amp;buttonPortB_structInit); PORT_Init(MDR_PORTC, &amp;buttonPortC_structInit); PORT_Init(MDR_PORTE, &amp;buttonPortE_structInit); }</span></span></code> </pre> </div></div><br><h4>  Setting the timer to generate PWM (PWM). </h4>  Before setting the timer itself, we will configure the output of the I / O port, to which we will output the PWM to alternative function mode.  Remember that in the last article we used the PORTA port and output 1. <div class="spoiler">  <b class="spoiler_title">The following will be released.</b> <div class="spoiler_text"><pre> <code class="cpp hljs">RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTA, ENABLE); <span class="hljs-comment"><span class="hljs-comment">//    A. PWMPortA_structInit.PORT_FUNC = PORT_FUNC_ALTER; //      . PWMPortA_structInit.PORT_GFEN = PORT_GFEN_OFF; //   . PWMPortA_structInit.PORT_MODE = PORT_MODE_DIGITAL; //  . PWMPortA_structInit.PORT_OE = PORT_OE_OUT; //    . PWMPortA_structInit.PORT_PD = PORT_PD_DRIVER; //  . PWMPortA_structInit.PORT_PD_SHM = PORT_PD_SHM_OFF; //   . PWMPortA_structInit.PORT_Pin = PORT_Pin_1; //   . PWMPortA_structInit.PORT_PULL_DOWN = PORT_PULL_DOWN_OFF; //   0 . PWMPortA_structInit.PORT_PULL_UP = PORT_PULL_UP_OFF; //   1 . PWMPortA_structInit.PORT_SPEED = PORT_SPEED_MAXFAST; //     . PORT_Init(MDR_PORTA, &amp;PWMPortA_structInit); //  .</span></span></code> </pre> </div></div>  Now we can proceed to setting up the timer itself.  First of all, we need to apply clocking to TIMER1.  This can also be done using the <b>RST_CLK_PCLKcmd</b> function discussed earlier. <pre> <code class="cpp hljs">RST_CLK_PCLKcmd(RST_CLK_PCLK_TIMER1, ENABLE); <span class="hljs-comment"><span class="hljs-comment">//    1.</span></span></code> </pre>  Next is to clearly identify the task.  We need: <ol><li>  Set the main timer. </li><li>  Configure channel timer. </li><li>  Set the timer output. </li><li>  Set the clock frequency for the entire timer. </li><li>  Enable timer. </li></ol>  For each item in the SPL has its own function, and for the first three points there are also their own structures.  All functions and their parameters are in the file <u>MDR32F9Qx_timer.h</u> .  Let's start with the first item.  To initialize the main timer there is a function <b>TIMER_CntInit</b> . <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIMER_CntInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MDR_TIMER_TypeDef* TIMERx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TIMER_CntInitTypeDef* TIMER_CntInitStruct)</span></span></span></span>;</code> </pre>  Here are two parameters. <ul><li>  <b>TIMERx</b> - selected for initialization timer.  It is specified in the format MDR_TIMERX, where X is the number of the desired timer.  In our case, MDR_TIMER1. </li><li>  <b>Structure type TIMER_CntInitTypeDef</b> - in this structure there is an enumeration of all possible parameters of the main timer. <div class="spoiler">  <b class="spoiler_title">Here is her description.</b> <div class="spoiler_text">  typedef struct { <br><br>  #if defined (USE_MDR1986VE9x) / * For Cortex M3 * / <br>  uint16_t TIMER_IniCounter;  / *! &lt;Specifies the initial counter value. <br>  This parameter can be a number between 0x0000 and 0xFFFF.  * / <br>  #elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T))) <br>  uint32_t TIMER_IniCounter;  / *! &lt;Specifies the initial counter value. <br>  This parameter can be a number between 0x0000 and 0xFFFFFFFF.  * / <br>  #endif // #elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T))) <br><br>  uint16_t TIMER_Prescaler;  / *! &lt;Specifies the prescaler value used to divide the TIMER clock. <br>  This parameter can be a number between 0x0000 and 0xFFFF. <br>  CLK = TIMER_CLK / (TIMER_Prescaler + 1) * / <br><br>  #if defined (USE_MDR1986VE9x) / * For Cortex M3 * / <br>  uint16_t TIMER_Period;  / *! &lt;Specifies the value to be loaded into the <br>  Auto-Reload Register (ARR) at the next update event. <br>  This parameter must be between 0x0000 and 0xFFFF.  * / <br>  #elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T))) / * For Cortex M1 * / <br>  uint32_t TIMER_Period;  / *! &lt;Specifies the value to be loaded into the <br>  Auto-Reload Register (ARR) at the next update event. <br>  This parameter must be between 0x0000 and 0xFFFFFFFF.  * / <br>  #endif // #elif ((defined (USE_MDR1986VE3)) || (defined (USE_MDR1986VE1T))) / * For Cortex M1 * / <br><br>  uint16_t TIMER_CounterMode;  / *! &lt;Specifies the counter mode. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_Counter_Mode * / <br><br>  uint16_t TIMER_CounterDirection;  / *! &lt;Specifies the counter direction. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_Counter_Direction * / <br><br>  uint16_t TIMER_EventSource;  / *! &lt;Specifies the Counter Event source. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_Event_Source * / <br><br>  uint16_t TIMER_FilterSampling;  / *! &lt;Specifies the filter sampling clock (FDTS). <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_Filter_Sampling * / <br><br>  uint16_t TIMER_ARR_UpdateMode;  / *! &lt;Specifies the Auto-Reload Register (ARR) updating mode. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_ARR_Update_Mode * / <br><br>  uint16_t TIMER_ETR_FilterConf;  / *! &lt;Specifies the ETR Filter configuration. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_FilterConfiguration * / <br><br>  uint16_t TIMER_ETR_Prescaler;  / *! &lt;Specifies the ETR Prescaler configuration. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_ETR_Prescaler * / <br><br>  uint16_t TIMER_ETR_Polarity;  / *! &lt;Specifies the ETR Polarity configuration. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_ETR_Polarity * / <br><br>  uint16_t TIMER_BRK_Polarity;  / *! &lt;Specifies the BRK Polarity configuration. <br>  This parameter can be a <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_BRK_Polarity * / <br>  } TIMER_CntInitTypeDef; </div></div></li></ul><div class="spoiler">  <b class="spoiler_title">Filling in all the fields and initializing the timer we get the following.</b> <div class="spoiler_text"><pre> <code class="cpp hljs">TIMER_CntInitTypeDef timerPWM_structInit; <span class="hljs-comment"><span class="hljs-comment">//      ( ). //   . timerPWM_structInit.TIMER_ARR_UpdateMode = TIMER_ARR_Update_Immediately; //  ARR     . timerPWM_structInit.TIMER_BRK_Polarity = TIMER_BRKPolarity_NonInverted; // BRK    (    ). timerPWM_structInit.TIMER_CounterDirection = TIMER_CntDir_Up; //  "". CNT  (CNT++). timerPWM_structInit.TIMER_CounterMode = TIMER_CntMode_ClkFixedDir; //    , . timerPWM_structInit.TIMER_ETR_FilterConf = TIMER_Filter_1FF_at_TIMER_CLK; //    1-    TIM_CLK (    -). timerPWM_structInit.TIMER_ETR_Polarity = TIMER_ETRPolarity_NonInverted; // ETR     (    ). timerPWM_structInit.TIMER_ETR_Prescaler = TIMER_ETR_Prescaler_None; //  ETR     (ETR  .). timerPWM_structInit.TIMER_EventSource = TIMER_EvSrc_None; //    . timerPWM_structInit.TIMER_FilterSampling = TIMER_FDTS_TIMER_CLK_div_1; // FDTS = TIMER_CLK. (  .). timerPWM_structInit.TIMER_IniCounter = 0; //   0.   . (CNT = 0.). timerPWM_structInit.TIMER_Period = PWM_speed; //        (ARR = PWM_speed). timerPWM_structInit.TIMER_Prescaler = 32000 - 1;//   . PSG . TIMER_CntInit(MDR_TIMER1, &amp;timerPWM_structInit); //   .</span></span></code> </pre> </div></div>  As you can see from the comments to the code for filling the structure - most of the items remain by default (disabled).  But despite this, you still need to specify. <br>  Next, you need to initialize the timer channel.  In our case - the first.  The function <b>TIMER_ChnInit</b> is responsible for channel initialization. <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIMER_ChnInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MDR_TIMER_TypeDef* TIMERx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)</span></span></span></span></code> </pre>  The first parameter is the name of the timer being initialized.  It remains the same as that of the initial timer initialization function.  But the structure is of type <b>TIMER_ChnInitTypeDef</b> . <div class="spoiler">  <b class="spoiler_title">Here is her description.</b> <div class="spoiler_text">  typedef struct <br>  { <br>  uint16_t TIMER_CH_Number;  / *! &lt;Specifies the Channel Number to be configured. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_Number * / <br><br>  uint16_t TIMER_CH_Mode;  / *! &lt;Specifies the TIMER Channel mode. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_Mode * / <br><br>  uint16_t TIMER_CH_ETR_Ena;  / *! &lt;Enables or disables ETR. <br>  This parameter can be a value of FunctionalState * / <br><br>  uint16_t TIMER_CH_ETR_Reset;  / *! &lt;Enables or disables ETR Reset. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_ETR_Reset * / <br><br>  uint16_t TIMER_CH_BRK_Reset;  / *! &lt;Enables or disables BRK Reset. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_BRK_Reset * / <br><br>  uint16_t TIMER_CH_REF_Format;  / *! &lt;Specifies the REF signal format. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_REF_Format * / <br><br>  uint16_t TIMER_CH_Prescaler;  / *! &lt;Specifies the TIMER Channel Prescaler configuration. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_Prescaler * / <br><br>  uint16_t TIMER_CH_EventSource;  / *! &lt;Specifies the Channel Event source. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_EventSource * / <br><br>  uint16_t TIMER_CH_FilterConf;  / *! &lt;Specifies the TIMER Channel Filter configuration. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_FilterConfiguration * / <br><br>  uint16_t TIMER_CH_CCR_UpdateMode;  / *! &lt;Specifies the TIMER CCR, CCR1 update mode. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_CCR_Update_Mode * / <br><br>  uint16_t TIMER_CH_CCR1_Ena;  / *! &lt;Enables or disables the CCR1 register. <br>  This parameter can be a value of FunctionalState * / <br><br>  uint16_t TIMER_CH_CCR1_EventSource;  / *! &lt;Specifies the Channel CCR1 Event source. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_CCR1_EventSource * / <br>  } TIMER_ChnInitTypeDef; </div></div><div class="spoiler">  <b class="spoiler_title">Also fill and initialize.</b> <div class="spoiler_text"><pre> <code class="cpp hljs">TIMER_ChnInitTypeDef timerPWM_channelStructInit; <span class="hljs-comment"><span class="hljs-comment">//   . //   PWM . timerPWM_channelStructInit.TIMER_CH_BRK_Reset = TIMER_CH_BRK_RESET_Disable; //   BRK   (BRK  ). timerPWM_channelStructInit.TIMER_CH_CCR1_Ena = DISABLE; // CCR1  . timerPWM_channelStructInit.TIMER_CH_CCR1_EventSource = TIMER_CH_CCR1EvSrc_PE; //       CAP1:    Chi. ( ,   ). timerPWM_channelStructInit.TIMER_CH_CCR_UpdateMode = TIMER_CH_CCR_Update_Immediately; //  CCR      (CCR  ). timerPWM_channelStructInit.TIMER_CH_ETR_Ena = DISABLE; // ETR  . timerPWM_channelStructInit.TIMER_CH_ETR_Reset = TIMER_CH_ETR_RESET_Disable; //  ETR  . timerPWM_channelStructInit.TIMER_CH_EventSource = TIMER_CH_EvSrc_PE; //     :  . (   ). timerPWM_channelStructInit.TIMER_CH_FilterConf = TIMER_Filter_1FF_at_TIMER_CLK; //    TIMER_CLK   . timerPWM_channelStructInit.TIMER_CH_Mode = TIMER_CH_MODE_PWM; //    . timerPWM_channelStructInit.TIMER_CH_Number = TIMER_CHANNEL1; //  . timerPWM_channelStructInit.TIMER_CH_Prescaler = TIMER_CH_Prescaler_None; //     . timerPWM_channelStructInit.TIMER_CH_REF_Format = TIMER_CH_REF_Format3; //  REF   CNT == ARR. TIMER_ChnInit(MDR_TIMER1, &amp;timerPWM_channelStructInit); //  .</span></span></code> </pre> </div></div>  I note that it is in this function that we form a signal at REF for PWM. <br>  Next you need to configure the channel timer to exit.  For this there is a function <b>TIMER_ChnOutInit</b> . <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIMER_ChnOutInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MDR_TIMER_TypeDef* TIMERx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)</span></span></span></span>;</code> </pre>  The first parameter is the name of our timer.  The second is the <b>TIMER_ChnOutInitStruct</b> structure. <div class="spoiler">  <b class="spoiler_title">Her description.</b> <div class="spoiler_text">  typedef struct <br>  { <br>  uint16_t TIMER_CH_Number;  / *! &lt;Specifies the Channel Number to be configured. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_Number * / <br><br>  uint16_t TIMER_CH_DirOut_Polarity;  / *! &lt;Specifies the TIMER CHx output polarity. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_OUT_Polarity * / <br><br>  uint16_t TIMER_CH_DirOut_Source;  / *! &lt;Specifies the TIMER CHx output source. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_OUT_Source * / <br><br>  uint16_t TIMER_CH_DirOut_Mode;  / *! &lt;Specifies the TIMER CHx output enable source. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_OUT_Mode * / <br><br>  uint16_t TIMER_CH_NegOut_Polarity;  / *! &lt;Enables or disables the TIMER CHxN output inversion. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_OUT_Polarity * / <br><br>  uint16_t TIMER_CH_NegOut_Source;  / *! &lt;Specifies the TIMER CHxN output source. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_OUT_Source * / <br><br>  uint16_t TIMER_CH_NegOut_Mode;  / *! &lt;Specifies the TIMER CHxN output enable source. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_OUT_Mode * / <br><br>  uint16_t TIMER_CH_DTG_MainPrescaler;  / *! &lt;Specifies the main prescaler of TIMER DTG. <br>  This parameter can be a number between 0x0000 and 0x00FF. <br>  Delay DTGdel = TIMER_CH_DTG_MainPrescaler * (TIMER_CH_DTG_AuxPrescaler + 1) clocks.  * / <br><br>  uint16_t TIMER_CH_DTG_AuxPrescaler;  / *! &lt;Specifies the auxiliary prescaler of TIMER DTG. <br>  This parameter can be a number between 0x0000 and 0x000F. <br>  Delay DTGdel = TIMER_CH_DTG_MainPrescaler * (TIMER_CH_DTG_AuxPrescaler + 1) clocks.  * / <br><br>  uint16_t TIMER_CH_DTG_ClockSource;  / *! &lt;Specifies the TIMER DTG clock source. <br>  This parameter can be a value of <a href="http://habrahabr.ru/users/ref/" class="user_link">ref</a> TIMER_CH_DTG_Clock_Source * / <br>  } TIMER_ChnOutInitTypeDef; </div></div><div class="spoiler">  <b class="spoiler_title">After filling in the structure and initialization, we will observe the following code.</b> <div class="spoiler_text"><pre> <code class="cpp hljs">TIMER_ChnOutInitTypeDef timerPWM_channelOUTPWMStructInit; <span class="hljs-comment"><span class="hljs-comment">//     . //  . timerPWM_channelOUTPWMStructInit.TIMER_CH_DirOut_Mode = TIMER_CH_OutMode_Output; //  . timerPWM_channelOUTPWMStructInit.TIMER_CH_DirOut_Polarity = TIMER_CHOPolarity_NonInverted; // . timerPWM_channelOUTPWMStructInit.TIMER_CH_DirOut_Source = TIMER_CH_OutSrc_REF; //   REF . timerPWM_channelOUTPWMStructInit.TIMER_CH_DTG_AuxPrescaler = 0; //   . timerPWM_channelOUTPWMStructInit.TIMER_CH_DTG_ClockSource = TIMER_CH_DTG_ClkSrc_TIMER_CLK; //     DTG - TIMER_CLK.  DTG     . timerPWM_channelOUTPWMStructInit.TIMER_CH_DTG_MainPrescaler = 0; //    DTG. timerPWM_channelOUTPWMStructInit.TIMER_CH_NegOut_Mode = TIMER_CH_OutMode_Input; //    .       , ..   . timerPWM_channelOUTPWMStructInit.TIMER_CH_NegOut_Polarity = TIMER_CHOPolarity_NonInverted; //    . timerPWM_channelOUTPWMStructInit.TIMER_CH_NegOut_Source = TIMER_CH_DTG_ClkSrc_TIMER_CLK; //     DTG - TIMER_CLK. timerPWM_channelOUTPWMStructInit.TIMER_CH_Number = TIMER_CHANNEL1; //  . TIMER_ChnOutInit(MDR_TIMER1, &amp;timerPWM_channelOUTPWMStructInit); //    .</span></span></code> </pre> </div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now it only remains to apply a clock to the timer and start it. </font><font style="vertical-align: inherit;">To supply a clock signal (the one on the basis of which the timer counts) is the function </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIMER_BRGInit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIMER_BRGInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MDR_TIMER_TypeDef* TIMERx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TIMER_BRG)</span></span></span></span>;</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first parameter, as usual, is the name of the timer, the second is the divisor. </font><font style="vertical-align: inherit;">The divider is calculated in the same way as for the PSG register in the previous article (in fact, this function is only written by our divider in the PSG ...). </font><font style="vertical-align: inherit;">I also note that the same function also allows the clock signal to be sent to the default timer. </font><font style="vertical-align: inherit;">Well, for the inclusion of the function responsible </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIMER_Cmd</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIMER_Cmd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MDR_TIMER_TypeDef* TIMERx, FunctionalState NewState)</span></span></span></span></code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameters - the name of the timer and its state </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ENABLE / DISABLE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to the results of the whole setup, we get the following.</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Initialization of the timer in the PWM mode for working with the LED in the SPL mode. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void initTimerPWMledSPL (uint32_t PWM_speed)</font></font><br>  { <br> PORT_InitTypeDef PWMPortA_structInit; //        . <br> TIMER_CntInitTypeDef timerPWM_structInit; //      ( ). <br> TIMER_ChnInitTypeDef timerPWM_channelStructInit; //   . <br> TIMER_ChnOutInitTypeDef timerPWM_channelOUTPWMStructInit; //     . <br><br> RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTA, ENABLE); //    A. <br> RST_CLK_PCLKcmd(RST_CLK_PCLK_TIMER1, ENABLE); //    1. <br><br> PWMPortA_structInit.PORT_FUNC = PORT_FUNC_ALTER; //      . <br> PWMPortA_structInit.PORT_GFEN = PORT_GFEN_OFF; //   . <br> PWMPortA_structInit.PORT_MODE = PORT_MODE_DIGITAL; //  . <br> PWMPortA_structInit.PORT_OE = PORT_OE_OUT; //    . <br> PWMPortA_structInit.PORT_PD = PORT_PD_DRIVER; //  . <br> PWMPortA_structInit.PORT_PD_SHM = PORT_PD_SHM_OFF; //   . <br> PWMPortA_structInit.PORT_Pin = PORT_Pin_1; //   . <br> PWMPortA_structInit.PORT_PULL_DOWN = PORT_PULL_DOWN_OFF; //   0 . <br> PWMPortA_structInit.PORT_PULL_UP = PORT_PULL_UP_OFF; //   1 . <br> PWMPortA_structInit.PORT_SPEED = PORT_SPEED_MAXFAST; //     . <br><br> PORT_Init(MDR_PORTA, &amp;PWMPortA_structInit); //  . <br><br> //   . <br> timerPWM_structInit.TIMER_ARR_UpdateMode = TIMER_ARR_Update_Immediately; //  ARR     . <br> timerPWM_structInit.TIMER_BRK_Polarity = TIMER_BRKPolarity_NonInverted; // BRK    (    ). <br> timerPWM_structInit.TIMER_CounterDirection = TIMER_CntDir_Up; //  ¬´¬ª. CNT  (CNT++). <br> timerPWM_structInit.TIMER_CounterMode = TIMER_CntMode_ClkFixedDir; //    , . <br> timerPWM_structInit.TIMER_ETR_FilterConf = TIMER_Filter_1FF_at_TIMER_CLK; //    1-    TIM_CLK (    -). <br> timerPWM_structInit.TIMER_ETR_Polarity = TIMER_ETRPolarity_NonInverted; // ETR     (    ). <br> timerPWM_structInit.TIMER_ETR_Prescaler = TIMER_ETR_Prescaler_None; //  ETR     (ETR  .). <br> timerPWM_structInit.TIMER_EventSource = TIMER_EvSrc_None; //    . <br> timerPWM_structInit.TIMER_FilterSampling = TIMER_FDTS_TIMER_CLK_div_1; // FDTS = TIMER_CLK. (  .). <br> timerPWM_structInit.TIMER_IniCounter = 0; //   0.   . (CNT = 0.). <br> timerPWM_structInit.TIMER_Period = PWM_speed; //        (ARR = PWM_speed). <br> timerPWM_structInit.TIMER_Prescaler = 32000 ‚Äî 1; //   . PSG . <br><br> TIMER_CntInit(MDR_TIMER1, &amp;timerPWM_structInit); //   . <br><br> //   PWM . <br> timerPWM_channelStructInit.TIMER_CH_BRK_Reset = TIMER_CH_BRK_RESET_Disable; //   BRK   (BRK  ). <br> timerPWM_channelStructInit.TIMER_CH_CCR1_Ena = DISABLE; // CCR1  . <br> timerPWM_channelStructInit.TIMER_CH_CCR1_EventSource = TIMER_CH_CCR1EvSrc_PE; //       CAP1:    Chi. ( ,   ). <br> timerPWM_channelStructInit.TIMER_CH_CCR_UpdateMode = TIMER_CH_CCR_Update_Immediately; //  CCR      (CCR  ). <br> timerPWM_channelStructInit.TIMER_CH_ETR_Ena = DISABLE; // ETR  . <br> timerPWM_channelStructInit.TIMER_CH_ETR_Reset = TIMER_CH_ETR_RESET_Disable; //  ETR  . <br> timerPWM_channelStructInit.TIMER_CH_EventSource = TIMER_CH_EvSrc_PE; //     :  . (   ). <br> timerPWM_channelStructInit.TIMER_CH_FilterConf = TIMER_Filter_1FF_at_TIMER_CLK; //    TIMER_CLK   . <br> timerPWM_channelStructInit.TIMER_CH_Mode = TIMER_CH_MODE_PWM; //    . <br> timerPWM_channelStructInit.TIMER_CH_Number = TIMER_CHANNEL1; //  . <br> timerPWM_channelStructInit.TIMER_CH_Prescaler = TIMER_CH_Prescaler_None; //     . <br> timerPWM_channelStructInit.TIMER_CH_REF_Format = TIMER_CH_REF_Format3; //  REF   CNT == ARR. <br><br> TIMER_ChnInit(MDR_TIMER1, &amp;timerPWM_channelStructInit); //  . <br><br> //  . <br> timerPWM_channelOUTPWMStructInit.TIMER_CH_DirOut_Mode = TIMER_CH_OutMode_Output; //  . <br> timerPWM_channelOUTPWMStructInit.TIMER_CH_DirOut_Polarity = TIMER_CHOPolarity_NonInverted; //  . <br> timerPWM_channelOUTPWMStructInit.TIMER_CH_DirOut_Source = TIMER_CH_OutSrc_REF; //   REF . <br> timerPWM_channelOUTPWMStructInit.TIMER_CH_DTG_AuxPrescaler = 0; //   . <br> timerPWM_channelOUTPWMStructInit.TIMER_CH_DTG_ClockSource = TIMER_CH_DTG_ClkSrc_TIMER_CLK; //     DTG ‚Äî TIMER_CLK.  DTG     . <br> timerPWM_channelOUTPWMStructInit.TIMER_CH_DTG_MainPrescaler = 0; //    DTG. <br> timerPWM_channelOUTPWMStructInit.TIMER_CH_NegOut_Mode = TIMER_CH_OutMode_Input; //    .       , ..   . <br> timerPWM_channelOUTPWMStructInit.TIMER_CH_NegOut_Polarity = TIMER_CHOPolarity_NonInverted;//    . <br> timerPWM_channelOUTPWMStructInit.TIMER_CH_NegOut_Source = TIMER_CH_DTG_ClkSrc_TIMER_CLK; //     DTG ‚Äî TIMER_CLK. <br> timerPWM_channelOUTPWMStructInit.TIMER_CH_Number = TIMER_CHANNEL1; //  . <br><br> TIMER_ChnOutInit(MDR_TIMER1, &amp;timerPWM_channelOUTPWMStructInit); //    . <br><br> TIMER_BRGInit(MDR_TIMER1, TIMER_HCLKdiv1); //      (   ). //      (  ¬´1¬ª)    . <br> TIMER_Cmd(MDR_TIMER1, ENABLE); //  . <br>  } </div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Timer setting for interrupt call (IRQ) </font></font></h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we need to configure a timer that generates interrupts for polling keys. </font><font style="vertical-align: inherit;">Here we will need to set the timer only for the first structure. </font><font style="vertical-align: inherit;">Since the channels and outputs we do not use. </font><font style="vertical-align: inherit;">The initialization of the timer will look the same as the previous one, with the exception of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIMER_EventSource</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cell </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In it, we must indicate on which event we have an interruption. </font><font style="vertical-align: inherit;">In the last article, we used CNT == ARR. </font><font style="vertical-align: inherit;">His and use.</font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, the following options are possible.</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER_EvSrc_None (((uint32_t)0x0) &lt;&lt; TIMER_CNTRL_EVENT_SEL_Pos) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; No events. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER_EvSrc_TM1 (((uint32_t)0x1) &lt;&lt; TIMER_CNTRL_EVENT_SEL_Pos) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Selects TIMER1 (CNT == ARR) event. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER_EvSrc_TM2 (((uint32_t)0x2) &lt;&lt; TIMER_CNTRL_EVENT_SEL_Pos) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Selects TIMER2 (CNT == ARR) event. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER_EvSrc_TM3 (((uint32_t)0x3) &lt;&lt; TIMER_CNTRL_EVENT_SEL_Pos) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Selects TIMER3 (CNT == ARR) event. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER_EvSrc_CH1 (((uint32_t)0x4) &lt;&lt; TIMER_CNTRL_EVENT_SEL_Pos) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Selects Channel 1 event. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER_EvSrc_CH2 (((uint32_t)0x5) &lt;&lt; TIMER_CNTRL_EVENT_SEL_Pos) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Selects Channel 2 event. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER_EvSrc_CH3 (((uint32_t)0x6) &lt;&lt; TIMER_CNTRL_EVENT_SEL_Pos) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Selects Channel 3 event. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER_EvSrc_CH4 (((uint32_t)0x7) &lt;&lt; TIMER_CNTRL_EVENT_SEL_Pos) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Selects Channel 4 event. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER_EvSrc_ETR (((uint32_t)0x8) &lt;&lt; TIMER_CNTRL_EVENT_SEL_Pos) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Selects ETR event. */</span></span></span></span></code> </pre> </div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Just do not forget about the inclusion of a timer clocking and the filing of a clock signal for the account. </font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is how we initialized the timer.</font></font></b> <div class="spoiler_text"> TIMER_CntInitTypeDef timerButtonCheck_structInit; //          . <br> RST_CLK_PCLKcmd(RST_CLK_PCLK_TIMER2, ENABLE); //    1. <br> TIMER_BRGInit(MDR_TIMER2, TIMER_HCLKdiv1); //      (   ). <br><br> //    . <br> timerButtonCheck_structInit.TIMER_ARR_UpdateMode = TIMER_ARR_Update_Immediately; //  ARR     . <br> timerButtonCheck_structInit.TIMER_BRK_Polarity = TIMER_BRKPolarity_NonInverted; // BRK    (    ). <br> timerButtonCheck_structInit.TIMER_CounterDirection = TIMER_CntDir_Up; //  ¬´¬ª. CNT  (CNT++). <br> timerButtonCheck_structInit.TIMER_CounterMode = TIMER_CntMode_ClkFixedDir; //    , . <br> timerButtonCheck_structInit.TIMER_ETR_FilterConf = TIMER_Filter_1FF_at_TIMER_CLK; //    1-    TIM_CLK (    -). <br> timerButtonCheck_structInit.TIMER_ETR_Polarity = TIMER_ETRPolarity_NonInverted; // ETR     (    ). <br> timerButtonCheck_structInit.TIMER_ETR_Prescaler = TIMER_ETR_Prescaler_None; //  ETR     (ETR  .). <br> timerButtonCheck_structInit.TIMER_EventSource = TIMER_EvSrc_TM2; //     CNT = ARR. <br> timerButtonCheck_structInit.TIMER_FilterSampling = TIMER_FDTS_TIMER_CLK_div_1; // FDTS = TIMER_CLK. (  .). <br> timerButtonCheck_structInit.TIMER_IniCounter = 0; //   0.   . (CNT = 0.). <br> timerButtonCheck_structInit.TIMER_Period = 250/25; //        (ARR = PWM_speed). <br> timerButtonCheck_structInit.TIMER_Prescaler = 32000 ‚Äî 1; //   . PSG . <br><br> TIMER_CntInit(MDR_TIMER2, &amp;timerButtonCheck_structInit); //   . </div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next, we use the built-in function in CMSIS to enable interrupts from the entire timer (we analyzed it in the previous article) and turn on the timer. </font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full initialization function.</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      25      SPL. void initTimerButtonCheckSPL (void) { TIMER_CntInitTypeDef timerButtonCheck_structInit; //          . RST_CLK_PCLKcmd(RST_CLK_PCLK_TIMER2, ENABLE); //    1. TIMER_BRGInit(MDR_TIMER2, TIMER_HCLKdiv1); //      (   ). //    . timerButtonCheck_structInit.TIMER_ARR_UpdateMode = TIMER_ARR_Update_Immediately; //  ARR     . timerButtonCheck_structInit.TIMER_BRK_Polarity = TIMER_BRKPolarity_NonInverted; // BRK    (    ). timerButtonCheck_structInit.TIMER_CounterDirection = TIMER_CntDir_Up; //  "". CNT  (CNT++). timerButtonCheck_structInit.TIMER_CounterMode = TIMER_CntMode_ClkFixedDir; //    , . timerButtonCheck_structInit.TIMER_ETR_FilterConf = TIMER_Filter_1FF_at_TIMER_CLK; //    1-    TIM_CLK (    -). timerButtonCheck_structInit.TIMER_ETR_Polarity = TIMER_ETRPolarity_NonInverted; // ETR     (    ). timerButtonCheck_structInit.TIMER_ETR_Prescaler = TIMER_ETR_Prescaler_None; //  ETR     (ETR  .). timerButtonCheck_structInit.TIMER_EventSource = TIMER_EvSrc_TM2; //     CNT = ARR. timerButtonCheck_structInit.TIMER_FilterSampling = TIMER_FDTS_TIMER_CLK_div_1; // FDTS = TIMER_CLK. (  .). timerButtonCheck_structInit.TIMER_IniCounter = 0; //   0.   . (CNT = 0.). timerButtonCheck_structInit.TIMER_Period = 250/25; //        (ARR = PWM_speed). timerButtonCheck_structInit.TIMER_Prescaler = 32000 - 1; //   . PSG . TIMER_CntInit(MDR_TIMER2, &amp;timerButtonCheck_structInit); //   . TIMER_ITConfig(MDR_TIMER2, TIMER_STATUS_CNT_ARR, ENABLE); //    CNT = ARR. NVIC_EnableIRQ(Timer2_IRQn); //      . TIMER_Cmd(MDR_TIMER2, ENABLE); //  . }</span></span></code> </pre> </div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We translate interruption on SPL. </font></font></h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The final step is to translate the SPL functions in the interrupt. </font><font style="vertical-align: inherit;">An interrupt has all the same standard name specified in the startup file. </font><font style="vertical-align: inherit;">Remember that when entering an interrupt, we need to reset the timer status flag. </font><font style="vertical-align: inherit;">To do this, use the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIMER_ClearFlag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">.</font></font><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIMER_ClearFlag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MDR_TIMER_TypeDef* TIMERx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Flags)</span></span></span></span></code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As parameters, you must specify the name of the port and the interrupt flag. </font><font style="vertical-align: inherit;">In our case will be:</font></font><pre> <code class="cpp hljs">TIMER_ClearFlag(MDR_TIMER2, TIMER_STATUS_CNT_ARR); <span class="hljs-comment"><span class="hljs-comment">//  .   .</span></span></code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, we inverted the LED state, indicating that the interrupt worked. </font><font style="vertical-align: inherit;">In the SPL there is no function to invert a bit, but there is a function to read and write single bits. </font><font style="vertical-align: inherit;">And we will use them.</font></font><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> PORT_ReadInputDataBit(MDR_PORT_TypeDef* PORTx, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> PORT_Pin); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PORT_WriteBit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MDR_PORT_TypeDef* PORTx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PORT_Pin, BitAction BitVal)</span></span></span></span>;</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For both, the first parameter is the name of the port, then the reading function needs to specify the pin name. </font><font style="vertical-align: inherit;">Specified exactly </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mask</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In the recording function, after the port name you should specify the bit that is written (also masked) and the value of the bit (0 or 1). </font><font style="vertical-align: inherit;">The read function can be used as a write function parameter. </font><font style="vertical-align: inherit;">Then we get:</font></font><pre> <code class="cpp hljs">PORT_WriteBit(MDR_PORTC, LED1, !PORT_ReadInputDataBit(MDR_PORTC, LED1)); <span class="hljs-comment"><span class="hljs-comment">//    .</span></span></code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that we need to read data from the buttons. </font><font style="vertical-align: inherit;">And one button. </font><font style="vertical-align: inherit;">To do this, we use the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PORT_ReadInputDataBit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">, which has been parsed above.</font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poll buttons will look like this.</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PORT_ReadInputDataBit(MDR_PORTB, UP_MSK) == <span class="hljs-number"><span class="hljs-number">0</span></span>) PWM_speed--; <span class="hljs-comment"><span class="hljs-comment">// ,   - .   - -   . else if (PORT_ReadInputDataBit(MDR_PORTE, DOWN_MSK) == 0) PWM_speed++; else if (PORT_ReadInputDataBit(MDR_PORTE, LEFT_MSK) == 0) PWM_speed--; else if (PORT_ReadInputDataBit(MDR_PORTB, RIGHT_MSK)== 0) PWM_speed++;</span></span></code> </pre> </div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains only to change the frequency at the end of the survey buttons. </font><font style="vertical-align: inherit;">For this there is a function </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIMER_SetCntAutoreload</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIMER_SetCntAutoreload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MDR_TIMER_TypeDef* TIMERx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Autoreload)</span></span></span></span></code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We only need to specify a timer with PWM and a new frequency. </font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, we have an interrupt view.</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer2_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ TIMER_ClearFlag(MDR_TIMER2, TIMER_STATUS_CNT_ARR); <span class="hljs-comment"><span class="hljs-comment">//  .   . PORT_WriteBit(MDR_PORTC, LED1, !PORT_ReadInputDataBit(MDR_PORTC, LED1)); //    . if (PORT_ReadInputDataBit(MDR_PORTB, UP_MSK) == 0) PWM_speed--; // ,   - .   - -   . else if (PORT_ReadInputDataBit(MDR_PORTE, DOWN_MSK) == 0) PWM_speed++; else if (PORT_ReadInputDataBit(MDR_PORTE, LEFT_MSK) == 0) PWM_speed--; else if (PORT_ReadInputDataBit(MDR_PORTB, RIGHT_MSK)== 0) PWM_speed++; // ,         250   0.5 . if (PWM_speed &lt; 1) PWM_speed = 1; else if (PWM_speed &gt; 500) PWM_speed = 500; TIMER_SetCntAutoreload(MDR_TIMER1, PWM_speed); //  . }</span></span></code> </pre> </div></div><br><h4>  Summarizing. </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we could see, using SPL, the code began to look much larger. </font><font style="vertical-align: inherit;">But let's compare the weight of the resulting code. </font><font style="vertical-align: inherit;">In the code written only using CMSIS with all kinds of optimization takes so much. </font></font><br><img src="https://habrastorage.org/files/513/f98/615/513f98615ae24aebb1fdfd015abb1778.PNG"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our code with optimization -O0 weighs so much. </font></font><br><img src="https://habrastorage.org/files/7e2/869/e62/7e2869e627e64a28a39a47c1ac17ea48.PNG"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With -O3 optimization. </font></font><br><img src="https://habrastorage.org/files/2a7/fd8/023/2a7fd802346d49fc85dbced4f2a3ffdc.PNG"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code using SPL weighs 2-2.5 times more than written by hand. </font><font style="vertical-align: inherit;">The result is not bad, but still inferior to manual writing. </font><font style="vertical-align: inherit;">The execution speed is, of course, much less. </font><font style="vertical-align: inherit;">This is a topic for a separate article, of which there are plenty. </font><font style="vertical-align: inherit;">Now let's summarize.</font></font><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benefits of using SPL </font></font></h5><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The code written with the help of SPL is perceived unambiguously, if there is an appropriate description for the SPL itself (which so far, unfortunately, is not). </font></font></li><li>     ‚Äî    .  .          SPL.    ,   B-. </li></ol><br><h5>   SPL </h5><ol><li>   ,    . </li><li>     . </li><li>     SPL  ,   CMSIS. </li><li>      ,   .    ,  ,        ‚Äî     . </li><li>        . </li></ol><br><h4>  Conclusion </h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPL has the right to life, but only after all its possibilities are clearly described. </font><font style="vertical-align: inherit;">And it is possible to use it only in tasks where a lot of computing power and memory size is not required. </font><font style="vertical-align: inherit;">Personally, it turned out to be </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">much easier for</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> me </font><b><font style="vertical-align: inherit;">to</font></b><font style="vertical-align: inherit;"> configure all the peripherals described, reading the documentation and skipping unnecessary registers. </font></font><br><br> <a href="https://cloud.mail.ru/public/5RZp/4iSH5eXQo"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Project file </font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Thank you </font></font><a href="http://habrahabr.ru/users/amomum/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amomum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for hint with --feedback unused. </font><font style="vertical-align: inherit;">Due to this, the code began to weigh really much less, in connection with this, I corrected the article.</font></font><br><div class="spoiler">  <b class="spoiler_title">List of previous articles.</b> <div class="spoiler_text"><ul><li> 1. <a href="http://habrahabr.ru/post/255199/">  STM32F103  198692QI.</a>  <a href="http://habrahabr.ru/post/255199/">Or the first acquaintance with the Russian microcontroller.</a> </li><li> 2. <a href="http://habrahabr.ru/post/255323/">  STM32    198692QI.</a>  <a href="http://habrahabr.ru/post/255323/">Setup project in keil and flashing LED.</a> </li><li> 3. <a href="http://habrahabr.ru/post/255415/">  STM32    198692QI.</a>  <a href="http://habrahabr.ru/post/255415/">System Timer (SysTick).</a> </li><li> 4. <a href="http://habrahabr.ru/post/255479/">  STM32    198692QI.</a>  <a href="http://habrahabr.ru/post/255479/">Setting the clock frequency.</a> </li><li> 5. <a href="http://habrahabr.ru/post/255513/">  STM32    198692QI.</a>  <a href="http://habrahabr.ru/post/255513/">Practical application: Generate and reproduce sound.</a>  <a href="http://habrahabr.ru/post/255513/">Part one: we generate a square and sinusoidal signal.</a>  <a href="http://habrahabr.ru/post/255513/">Mastering the DAC (DAC).</a> </li><li> 6. <a href="http://habrahabr.ru/post/256091/">  STM32    198692QI.</a>  <a href="http://habrahabr.ru/post/256091/">Practical application: Generate and reproduce sound.</a>  <a href="http://habrahabr.ru/post/256091/">Part two: generate a sinusoidal signal.</a>  <a href="http://habrahabr.ru/post/256091/">Mastering DMA.</a> </li><li> 7. <a href="http://habrahabr.ru/post/256577/">  STM32    198692QI.</a>  <a href="http://habrahabr.ru/post/256577/">Practical application: Generate and reproduce sound.</a>  <a href="http://habrahabr.ru/post/256577/">Part three: generate a sine wave.</a>  <a href="http://habrahabr.ru/post/256577/">A simple look at DMA + first acquaintance with timers.</a> </li><li> 8. <a href="http://habrahabr.ru/post/256621/">  STM32    198692QI.</a>  <a href="http://habrahabr.ru/post/256621/">Practical application: Generate and reproduce sound.</a>  <a href="http://habrahabr.ru/post/256621/">Part Four: we create the digital part of a single-voiced and multi-voiced musical postcard.</a> </li><li> 9, <a href="http://habrahabr.ru/post/267051/">  STM32    198692QI.</a>  <a href="http://habrahabr.ru/post/267051/">Practical application: We interrogate keys, we generate PWM.</a>  <a href="http://habrahabr.ru/post/267051/">Comparison of CMSIS and SPL code (PWM + TIM + PORT).</a>  <a href="http://habrahabr.ru/post/267051/">Part one.</a> </li></ul></div></div></div><p>Source: <a href="https://habr.com/ru/post/270863/">https://habr.com/ru/post/270863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270851/index.html">Moscow Python Meetup ‚Ññ30</a></li>
<li><a href="../270855/index.html">Development of 2D games on Windows, Mac OS, Linux and Android without programming. Part 2</a></li>
<li><a href="../270857/index.html">Semantic technologies are simple and accessible by the example of pedigrees.</a></li>
<li><a href="../270859/index.html">Facebook helps to find out if everything is good with your friends in case of emergency</a></li>
<li><a href="../270861/index.html">Parallel development of desktop and computer games: how things got upside down in different versions</a></li>
<li><a href="../270865/index.html">Out of my head. GTD in development</a></li>
<li><a href="../270871/index.html">Office in your pocket. We configure cloud PBX on mobile phones</a></li>
<li><a href="../270873/index.html">SolutionCop</a></li>
<li><a href="../270875/index.html">Project Naptha - select, copy and translate texts from any pictures</a></li>
<li><a href="../270877/index.html">Samba and forbidden characters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>