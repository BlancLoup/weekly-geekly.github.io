<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Closures in Javascript [Part 2]</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The previous part . 



- Closures Automatic garbage collection Creating closures 
- Automatic garbage collection 
- Creating closures 
- What can be ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Closures in Javascript [Part 2]</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/post/223459/">The previous part</a> . <br><br><ul><li>  Closures <br><ul><li>  Automatic garbage collection </li><li>  Creating closures </li></ul><br></li><li>  What can be done with closures? <br><ul><li>  Example 1: setTimeout with a function reference </li><li>  Example 2: Associating functions with object instance methods </li><li>  Example 3: Encapsulating Interconnected Functionality </li><li>  Other examples </li></ul><br></li><li>  Random closures </li><li>  Internet Explorer memory leak issue </li></ul><br><a name="habracut"></a><br><h2>  Closures </h2><br><h4>  Automatic garbage collection </h4><br>  ECMAScript uses automatic garbage collection.  The specification does not define the details, leaving the developers to deal with this, and some implementations are known for giving very little importance to garbage collection operations.  But the general idea is that if it becomes impossible to refer to an object (due to the lack of references to it, remaining available for the executable code), then it becomes accessible to the garbage collector and at some point any resources that used, will be released and returned to the system for reuse. <br><br>  As a rule, this happens immediately after exiting the execution context.  The scope chain structure, the activation / variable object and any objects created in the execution context, including function objects, are no longer accessible and thus become accessible to the garbage collector. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Creating closures </h4><br>  A closure is formed by returning a function object that was created in the context of executing a function call, from this function call, and assigning a reference to a nested function to a property of another object.  Or, if you directly assign a reference to such an object of a function, for example, a global variable, a property of a globally accessible object or an object passed by reference as an argument to an external function call. <br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleClosureForm</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg1, arg2</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localVar = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleReturned</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">innerArg</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((arg1 + arg2)/(innerArg + localVar)); } <span class="hljs-comment"><span class="hljs-comment">/*     ,   exampleReturned */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exampleReturned; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> globalVar = exampleClosureForm(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Now the function object created in the execution context of the <b>exampleClosureForm</b> call cannot be processed by the garbage collected because it is referenced by a global variable and is still available, this object can even be executed by calling <b>globalVar (n)</b> . <br><br>  But the incident is a bit more complicated, because now the global variable <b>globalVar</b> refers to the function object, this object was created with the <b>[[scope]]</b> property referring to the scope chain containing the activation / variables object belonging to the execution context in which it was created (and containing a global object).  Now the activation object / variables cannot be processed by the garbage collector, and when the function object is executed, referenced by <b>globalVar</b> , the entire scope chain, which its <b>[[scope]]</b> property refers to, will be added to <i>the scope of</i> the execution context that is created each time calling the function object. <br><br>  The closure is created.  The object of a nested function has free variables, and the object of activation / variables that is in the <i>chain of scopes of</i> this function is the medium connecting them. <br><br>  The activation / variable object is trapped because  it is referenced in <i>the scope chain</i> assigned to the <b>[[scope]]</b> internal property of the function object referenced by the <b>globalVar</b> variable.  The activation / variable object is saved along with its state, i.e.  with the values ‚Äã‚Äãof its properties.  In the process of resolving <i>the scope of</i> the execution context of calls to an internal function, identifiers corresponding to the named properties of this activation object / variables will be calculated, simply as properties of this object.  The values ‚Äã‚Äãof these properties can still be read and set, even after exiting the execution context in which they were created. <br><br>  In the example above, this activation / variable object has a state that represents the values ‚Äã‚Äãof the formal parameters, definitions of internal functions, and local variables at the moment when the external function terminates (its execution context has completed).  The <b>arg1</b> property has a value of <b>2</b> , <b>arg2</b> is a value of <b>4</b> , <b>localVar</b> is a value of <b>8,</b> and the property of <b>exampleReturned</b> is a reference to an object of a nested function that is returned from an external function.  (In the following, for convenience, we denote this object of activation \ variables as ActOuter1.) <br><br>  If you call <b>exampleClosureForm again</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondGlobalVar = exampleClosureForm(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  - then a new execution context will be created with a new activation object.  And a new function object will be returned with its own separate <b>[[scope]]</b> property referring to <i>the scope chain</i> containing the activation object from the second execution context with the values ‚Äã‚Äãof the <b>arg1</b> - <b>12</b> and <b>arg2</b> - <b>3</b> arguments.  (In the following, for convenience, we denote this activation object \ variables as ActOuter2.) <br><br>  The second and distinct closure was created by the second call to <b>exampleClosureForm</b> . <br><br>  Both of these function objects, created by executing <b>exampleClosureForm</b> , referenced by the global variables <b>globalVar</b> and <b>secondGlobalVar,</b> respectively, return the expression <b>((arg1 + arg2) / (innerArg + localVar))</b> .  It performs several statements to four identifiers.  How these identifiers are calculated determines the purpose and meaning of the closures. <br><br>  Consider executing the function object referenced by <b>globalVar</b> : <b>globalVar (2)</b> .  A new execution context is created and an activation object (let's call it ActInner1), which will be added to the top of <i>the scope chain</i> referenced by the <b>[[scope]]</b> property of the executed function object.  ActInner1 gets the innerArg property after the formal parameter is assigned the value of the argument <b>2</b> .  The chain of scopes of the new execution context will be the following: ActInner1-&gt; ActOuter1-&gt; global object. <br><br>  The resolution of identifier names is accomplished through a <i>chain of scopes</i> , thus.  to return the value of the expression <b>((arg1 + arg2) / (innerArg + localVar))</b> , the values ‚Äã‚Äãof these identifiers will be determined by searching for properties with the names corresponding to the identifiers in each object from the <i>chain of visibility</i> in turn. <br><br>  The first object in the chain is ActInner1 and it has an <b>innerArg</b> property with a value of <b>2</b> .  The remaining 3 identifiers correspond to ActOuter1 named properties;  <b>arg1</b> with a value of <b>2</b> , <b>arg2</b> - <b>4,</b> and <b>localVar</b> - <b>8</b> .  The function call returns <b>((2 + 4) / (2 + 8))</b> . <br><br>  Compare this with the execution of another identical function object referenced by <b>secondGlobalVar</b> : <b>secondGlobalVar (5)</b> .  Let's call the activation object the new execution context ActInner2, the chain will be like this: ActInner2-&gt; ActOuter2-&gt; global object.  ActInner2 returns <b>innerArg</b> as <b>5</b> and ActOuter2 returns <b>arg1</b> , <b>arg2</b> and <b>localVar</b> as <b>12</b> , <b>3</b> and <b>8,</b> respectively.  Return value: <b>((12 + 3) / (5 + 8))</b> . <br><br>  If we run <b>secondGlobalVar</b> again, a new activation object will appear at the beginning of <i>the scope chain</i> , but ActOuter2 will still be the next object in the chain, and the values ‚Äã‚Äãof its named properties will again be used to resolve identifier names <b>arg1</b> , <b>arg2</b> and <b>localVar</b> . <br><br>  It is in this way that nested ECMAScript functions obtain and maintain access to formal parameters, declarations of nested functions, and local variables of the execution context in which they were created.  And thus, the creation of closures allows such a function object to continue to refer to these values, read and modify them, while it exists.  The activation object / variables from the execution context in which the nested function was created remains in the <i>chain of scopes</i> referenced by the <b>[[scope]]</b> property of the function object until all references to the nested function are released and the function object will not be accessible to the garbage collector (along with all the objects that are unnecessary from now on in its chain of sight). <br><br>  Nested functions can themselves have nested functions, i.e.  nested functions returned by executing functions to form a closure can themselves return nested functions and create their own closures.  With each nesting, <i>the scope chain</i> will receive an additional activation object, arising along with the execution context in which the nested function object was created.  The ECMAScript specification requires that a <i>chain of scopes be</i> finite, but does not impose any restrictions on their length.  Perhaps in some implementations in practice there are some limitations, but so far there have been no reports of specific quantities.  Apparently, the number of possible further investments of functions is more than anyone might need. <br><br><h2>  What can be done with closures? </h2><br>  It may seem strange, but the answer to this question is absolutely everything.  I'm talking about the fact that closures allow ECMAScript to emulate anything, limiting only the ability to conceive and implement this emulation.  It‚Äôs a bit confusing and it‚Äôs probably better to start with something more practical. <br><br><h4>  Example 1: setTimeout with a function reference </h4><br>  Closures are often used to provide parameters for executing a function prior to its execution.  For example, when the function should be passed as the first argument to the <b>setTimeout</b> function, common in web browser environments. <br><br>  <b>setTimeout</b> assigns the execution time of a function (or a string of javascript code, but not in our case), accessible through the first argument, after an interval expressed in milliseconds (from the second argument).  To use <b>setTimeout,</b> you need to call this function and pass a reference to the function object as the first argument and an interval in milliseconds as the second, but the reference to the function object cannot contain parameters for the scheduled execution of this function. <br><br>  However, you can call another function that returns a reference to the object of the nested function, which we pass by reference to the <b>setTimeout</b> function.  The parameters used by the nested function are sent when the function that returns it is called.  <b>setTimout</b> executes the nested function without passing arguments, but this nested function still has access to the parameters provided by the call to the external function that returned it. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callLater</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">paramA, paramB, paramC</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*      ,   : */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*        setTimeout,     ,      ,     */</span></span> paramA[paramB] = paramC; }); } ... <span class="hljs-comment"><span class="hljs-comment">/*  ,       ,     .  ,        ,    .         : */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> functRef = callLater(elStyle, <span class="hljs-string"><span class="hljs-string">"display"</span></span>, <span class="hljs-string"><span class="hljs-string">"none"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*   setTimeout,     ,   funcRef,   : */</span></span> hideMenu=setTimeout(functRef, <span class="hljs-number"><span class="hljs-number">500</span></span>);</code> </pre><br><h4>  Example 2: Associating functions with object instance methods </h4><br>  There are many other circumstances where a reference to a function object is assigned so that the function will be executed some time in the future, in this case it will be useful to prepare parameters for the execution of this function that are not easily available at run time but unknown until the time of assignment. <br><br>  One example would be a javascript object that was created to encapsulate interaction with a specific DOM element.  It contains <b>doOnClick</b> , <b>doMouseOver</b> and <b>doMouseOut</b> methods for executing at the moment when the corresponding events fire on this DOM element, but there may be any number of instances of javascript objects created to associate with different DOM elements, and individual instances of objects may not know how they will be applied in the code in which they are created.  These instances of objects cannot determine how they are globally referenced because  they do not know which global variables (if any) will be assigned to them. <br><br>  Therefore, the problem lies in the execution of the function that handles the event, which is associated with a particular instance of the javascript object and knows which method of this object to call. <br><br>  The following example uses a simple generic closure-based function that associates an object instance with element event handlers.  Suppose that executing an event handler results in calling a particular method of an object instance, to which an event object and a reference to the associated element are passed, and returning the value that this method returns. <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*  ,       .       .      obj,   ,      ,   methodName -   . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">associateObjWithEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj, methodName</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   , , ,      DOM : */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*  ,     e  ,      DOM,    ,   IE,         ,   */</span></span> e = e||<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.event; <span class="hljs-comment"><span class="hljs-comment">/*      obj,      methodName   ,          ,    ,     this ( , ..        ,      ) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[methodName](e, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }); } <span class="hljs-comment"><span class="hljs-comment">/*  -  ,   DOM ,  ID      .      , ,      onclick, onmouseover  onmouseout,       . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DhtmlObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elementId</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*  ,     DOM  ( null,    )   ID  ,   .      el. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> el = getElementWithId(elementId); <span class="hljs-comment"><span class="hljs-comment">/*  el      boolean     if ,   el   ,    ,    null - .  ,    ,    el    DOM. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(el){ <span class="hljs-comment"><span class="hljs-comment">/*       ,     associateObjWithEvent,   (    this)  ,     ,     .  associateObjWithEvent     ,      DOM .         javascript    . */</span></span> el.onclick = associateObjWithEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"doOnClick"</span></span>); el.onmouseover = associateObjWithEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"doMouseOver"</span></span>); el.onmouseout = associateObjWithEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"doMouseOut"</span></span>); ... } } DhtmlObject.prototype.doOnClick = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event, element</span></span></span><span class="hljs-function">)</span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">//   doOnClick. } DhtmlObject.prototype.doMouseOver = function(event, element){ ... //   doMouseOver. } DhtmlObject.prototype.doMouseOut = function(event, element){ ... //   doMouseOut. }</span></span></code> </pre><br>  Thus, any instance of <b>DhtmlObject</b> can be associated with a DOM element without affecting the global namespace and without risking a <b>collision</b> with other instances of the <b>DhtmlObject</b> , and without having to consider how it is used by other code. <br><br><h4>  Example 3: Encapsulating Interconnected Functionality </h4><br>  Closures can be used to create additional scopes to group related and interdependent code in ways that minimize the risk of random interaction.  Suppose we have a function that creates a string, and in order to avoid repeating the concatenation operation (and creating a set of intermediate strings), it is advisable to use arrays to store parts of the string in a certain order, and then output the result using the <b>Array.prototype.join</b> ( with an empty string as an argument).  The array is used as a buffer for output, but if it is defined locally, inside a function, then each time the function is executed, it will be created anew, which is not necessary if only the variable contents of the array change with each function call. <br><br>  One of the ways is to create a global variable for this array, so as not to recreate it every time you use it.  But later, in addition to the global variable referring to the function that uses the buffer array, there will be another global property that refers to the array itself.  As a result, it becomes more difficult to control the code, in case it is used somewhere else, its author will have to remember that both the function definition and the array definition need to be added.  Also, such code is harder to combine with other code, because, in addition to checking the uniqueness of the function name, it is also necessary to check that the name of the array on which this function depends is also unique to the global namespace. <br><br>  A closure allows a buffer array to be associated (and neatly packaged) with a function that depends on it, and this simultaneously allows you to save the property name that was set for the array outside the global namespace and without the risk of name conflicts and random interactions. <br><br>  The trick is to create one additional execution context by executing, inline (in-line) an expression function that returns a nested function that will be used in external code.  The buffer array will then be defined as a local variable of an expression function with inline (in-line) execution.  Since the execution occurs once, the array is created only once, but is available to functions depending on it, with repeated uses. <br><br>  In the following code, a function is created that returns an HTML string, most of which is unchanged, but this sequence of characters must contain variable information accessible through parameters when the function is called. <br><br>  A reference to an object of a nested function is returned from the execution embedded in an expression function and assigned to a global variable, therefore this function object can be called as a global function.  A buffer array is defined as a local variable in an external function expression.  It is not laid out in the global namespace and is not recreated with each call to a function that uses it. <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*   getImgInPositionedDivHtml       -,      -.      HTML,     DIV,   IMG,           . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getImgInPositionedDivHtml = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* bufferAr - ,     - .            , ..         .     -  ,       . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffAr = [ <span class="hljs-string"><span class="hljs-string">'&lt;div id="'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-comment"><span class="hljs-comment">// 1, DIV ID  '" style="position:absolute;top:', '', // 3, DIV top  'px;left:', '', // 5, DIV left  'px;width:', '', // 7, DIV width 'px;height:', '', // 9, DIV height 'px;overflow:hidden;\"&gt;&lt;img src= '', // 11, IMG URL '\" width= '', // 13, IMG width '\" height= '', // 15, IMG height '\" alt= '', // 17, IMG alt  '\"&gt;&lt;\/div&gt;' ]; /*    ,     -.           getImgInPositionedDivHtml(...) */ return (function(url, id, width, height, top, left, altText){ /*           */ buffAr[1] = id; buffAr[3] = top; buffAr[5] = left; buffAr[13] = (buffAr[7] = width); buffAr[15] = (buffAr[9] = height); buffAr[11] = url; buffAr[17] = altText; /*  ,            (   ,       ) */ return buffAr.join(''); }); //  -. })(); /*^^-  (inline)   - */</span></span></code> </pre><br>       ( ) ,           -  ,          ,         .  ,           . <br><br><h4>   </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps one of the most well-known applications of closures is the </font></font><a href="http://www.crockford.com/javascript/private.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emulation of private instance variables in Douglas Crocford's ECMAScript objects</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Which can be extended with any kind of scope scaffold structure containing embedded accessibility and visibility, including </font></font><a href="http://myweb.tiscali.co.uk/cornford/js_info/private_static.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emulation of private static members of ECMAScript objects</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are an infinite number of applications for closures, understanding how they work is probably the best guide to understanding how they can be used.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Random closures </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you make any nested function available outside the body of the function in which it was created, a closure is formed. Therefore, closures are very easy to create, with the result that javascript developers who do not understand that closures are a language feature use nested functions for various tasks without obvious consequences, not realizing that closures were created or what consequences could be. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accidental creation of closures can have side effects, such as the memory leak problem in IE described in the next section; they can also affect code performance. The reason is not the closures themselves, in fact, if used carefully, they can significantly contribute to the creation of efficient code. The point is nested functions, the use of which may affect efficiency.</font></font><br><br>   ,          DOM . ,     ,     onclick    (link element). <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*   ,        href            */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quantaty = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*         (     linkRef),       onclick,      quantaty   href        ,    true,  ,    ,    href,     . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addGlobalQueryOnClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">linkRef</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   linkRef     true ( ,     ) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(linkRef){ <span class="hljs-comment"><span class="hljs-comment">/*  -            onclick   */</span></span> linkRef.onclick = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   -      href ,         */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.href += (<span class="hljs-string"><span class="hljs-string">'?quantaty='</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">escape</span></span>(quantaty)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; } }</code> </pre><br>  ,    <b>addGlobalQueryOnClick</b> ,     (     ).      ,  <b>addGlobalQueryOnClick</b>       ,     ,       (      -). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above code does not take advantage of the fact that internal functions have become available outside the function in which they were created (that is, the resulting closures). Exactly the same effect could be achieved by defining a function to use as an event handler separately and then assigning the reference to this function to the property of the event handler. Only one function object would be created and all elements using this event handler would use a reference to this one function.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*   ,        href            */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quantaty = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*         (     linkRef),       onclick,      quantaty   href        ,    true,  ,    ,    href,     . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addGlobalQueryOnClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">linkRef</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   linkRef     true ( ,     ) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(linkRef){ <span class="hljs-comment"><span class="hljs-comment">/*          ,  ,     . */</span></span> linkRef.onclick = forAddQueryOnClick; } } <span class="hljs-comment"><span class="hljs-comment">/*   ,         ,         href  . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forAddQueryOnClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.href += (<span class="hljs-string"><span class="hljs-string">'?quantaty='</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">escape</span></span>(quantaty)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br> . .          ,   ,         ,  ,          . <br><br>      -.    ,     <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleConst</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*      -             */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method1 = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">//   }; this.method2 = function(){ ... //   }; this.method3 = function(){ ... //   }; /*     . */ this.publicProp = param; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each time a constructor is used to create an object by executing </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new ExampleConst (n)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a new set of function objects is created, which act as its methods. That is, the more instances of an object are created, the more corresponding function objects are created. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Douglas Crockford‚Äôs javascript private field emulation technique uses a closure resulting from the assignment of references to the nested function objects to the open properties of the created object inside the constructor. But if the object's methods do not take advantage of the closures formed inside the constructor, then creating extra function objects for each instance will slow down the process of creating objects and require more resources.</font></font><br><br>                     prototype ,  ,      ,   . <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleConst</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.publicProp = param; } <span class="hljs-comment"><span class="hljs-comment">/*       -            prototype  */</span></span> ExampleConst.prototype.method1 = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">//   }; ExampleConst.prototype.method2 = function(){ ... //   }; ExampleConst.prototype.method3 = function(){ ... //   };</span></span></code> </pre><br><br><h2>     Internet Explorer </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internet Explorer browser (tested on versions 4-6 (6 is the current version at the time of this writing)) has a defect in the garbage collection system that prevents the processing of ECMAScript objects and some objects of the environment if these objects of the environment are part of a ‚Äúcircular‚Äù link. Environment objects in this case are any DOM Node objects (including the document object and its descendants) and ActiveX objects. If the circular reference contains one or more of them, then none of the participating objects will be released, and the memory they use will remain inaccessible to the system until the browser is closed.</font></font><br><br>   ‚Äî            ,      . ,   1  ,     2,  2  ,     3,   3  ,     1.      ECMAScript,     1, 2  3    , ,       , ,        .     Internet Explorer,          DOM Node  ActiveX,      ,        ,   .          ,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Closures are very good at creating circular references. If the object of the function creating the closure is assigned, for example, as an event handler of the DOM Node object, and the link to this Node has been assigned to one of the properties of activation objects / variables in the scope of this function, then a circular reference will appear. DOM_Node.onevent -&gt; function_object. [[Scope]] -&gt; scope_chain -&gt; Activation_object.nodeRef -&gt; DOM_Node. This is very easy to do, and a brief viewing of the site that forms such a link in a piece of code common to all pages can use most of the system memory (sometimes all).</font></font><br><br>   ,     ,      ,   ,     onunload  IE,     ,  .      (  )      IE. <br><br>   .  2004. <br>     : <br> Martin Honnen. <br> Yann-Erwan Perio (Yep). <br> Lasse Reichstein Nielsen. ( <a href="http://jibbering.com/faq/notes/closures/"> </a> ) <br> Mike Scirocco. <br> Dr John Stockton. <br> Garrett Smith. <br><br>       . </div><p>Source: <a href="https://habr.com/ru/post/229887/">https://habr.com/ru/post/229887/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../229877/index.html">Experience using AR.Drone 2.0 in conjunction with Windows</a></li>
<li><a href="../229879/index.html">Syringe - declarative IoC Container for PHP</a></li>
<li><a href="../229881/index.html">Update 1.0.8.19 for SailfishOS has been released</a></li>
<li><a href="../229883/index.html">Deferred reading: OpenSource alternative</a></li>
<li><a href="../229885/index.html">The story of another electric bicycle with their own hands: reloaded</a></li>
<li><a href="../229891/index.html">Consolidation of LAN and SAN data center networks based on DCB and FCoE protocols</a></li>
<li><a href="../229893/index.html">Functional JavaScript, Part 1: Introduction</a></li>
<li><a href="../229895/index.html">Synthesis of optimal facial recognition algorithm</a></li>
<li><a href="../229899/index.html">Copyright maze generated?</a></li>
<li><a href="../229901/index.html">Hayload in the cloud on a live example</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>