<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FastCGI application in Perl. Part one.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago I was assigned to write an online auction engine. I had a choice - to make the engine as a regular CGI, or to make something more intere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FastCGI application in Perl. Part one.</h1><div class="post__text post__text-html js-mediator-article">  Some time ago I was assigned to write an online auction engine.  I had a choice - to make the engine as a regular CGI, or to make something more interesting.  I decided to apply the FastCGI technology in the development of the engine. <br><br>  FastCGI is a client-server protocol that provides interaction between a web server and an application.  FastCGI is a further development of the CGI protocol. <br><br>  What is the difference? <br><a name="habracut"></a><br>  In the case of a regular CGI application, the interaction between the web server and the application is done through STDIN and STDOUT.  In the case when FastCGI is used, the interaction between the client and the server is done via Unix Sockets or via TCP / IP. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The more interesting of these two options is TCP / IP communication.  This option provides two key benefits: <br><br>  1) FastCGI applications can be run not only on the same server as the web server, but also on any other.  There can be any number of such servers and FastCGI applications running on them, and this, in turn, provides almost unlimited scope for system scaling.  Has the system stopped handling loads?  Do not worry - you can very simply, completely rebuilding nothing, add the required number of servers.  The maximum intervention in the existing system will consist, merely, in adding a line with a list of new IPs to the web server configuration. <br><br>  2) FastCGI application can be implemented as a daemon, i.e.  it can itself be a server.  A typical CGI application is launched by the web server with each new request.  The launch of the application takes the lion's share of the time, often the launch takes more time than the useful work performed by it.  A FastCGI application is always running, it does not need to waste time on launch, it only needs to perform useful work. <br><br>  For these charms you have to pay.  First, writing a FastCGI application is somewhat more complicated than writing a CGI application.  Secondly, the web server requires some additional configuration, and, possibly, replacement. <br><br>  Let's start with the web server. <br><br>  In our case, the web server will play an extremely small role; it will neither resolve virtual hosts, nor execute scripts, nor give statics.  All his work will be limited to the transfer of the request from the browser to the FastCGI application.  For such a task is well suited <a href="http://sysoev.ru/nginx/">nginx</a> . <br><br>  To configure nginx to work with our application, the following construction must be added to the nginx config: <br><br><pre> # Any queries in which the path will start from the fcgi-bin directory,
 # will be passed to the FastCGI application for processing.
 location / fcgi-bin / {
     # Where to send requests
     # in this case, the FastCGI application is on the same computer and is listening on port 9000
     fastcgi_pass localhost: 9000;
 }
</pre><br>  (for details on setting up nginx, please refer to the <a href="http_fastcgi_module.html">source</a> ) <br><br>  Run nginx.  Suppose a virtual host test.host has been configured in nginx, then the browser request to the address <a href="http://test.host/fcgi-bin/">test.host/fcgi-bin</a> will be transmitted by nginx to our FastCGI application.  While the application itself is not yet, something like this will be displayed in the browser: <br><br>  ‚ÄúThe page you are looking for is temporarily unavailable.  Please try again later.  ‚Äû <br><br>  This is normal.  It should be so. <br><br>  We now turn directly to writing a FastCGI application. <br><br>  The FastCGI protocol is implemented in Perl as an <a href="http://search.cpan.org/~skimo/FCGI-0.67/FCGI.PL">FCGI</a> module.  Please note that there are other modules on CPAN that allow you to work with FastCGI, for example, CGI :: Fast, but all of them are just add-ons over FCGI.  We will work directly with the ‚Äúfundamental‚Äù FCGI module. <br><br><pre> #! / usr / bin / perl

 # To heighten the order
 use strict;
 use warnings;

 # This module implements the FastCGI protocol.
 use FCGI;

 # Open the socket
 # our script will listen to port 9000
 # length of the connection queue (backlog) - 5 pieces
 my $ socket = FCGI :: OpenSocket (": 9000", 5);

 # Getting to listen
 my $ request = FCGI :: Request (\ * STDIN, \ * STDOUT, \ * STDERR, \% ENV, $ socket);

 my $ count = 1;

 # Endless cycle
 # for each accepted request, one cycle is performed.
 while ($ request-&gt; Accept ()&gt; = 0) {
     # Inside the loop, all useful work is performed
     print "Content-Type: text / plain \ r \ n \ r \ n";
     print $ count ++;
 };
</pre><br>  Let us examine some points in more detail. <br><br>  The OpenSocket function opens a socket and binds the port 9000 to it. Do not forget - it was this port that we previously specified in the nginx config.  Don't forget yet - ports below 1024 cannot be opened without being root. <br><br>  The backlog parameter of this function sets the number of connections that will wait in the queue while previous connections are serviced.  Honestly, I did not understand how this parameter works.  Theoretically, if the queue is full, new connections should be dropped.  But my change of this parameter doesn‚Äôt have a visible effect, what number do not indicate - all connections are still lining up in the queue, none is reset.  Probably, I am missing something somewhere, but this does not seem to affect the performance of the script. <br><br>  The Request function creates a request handler.  The handler intercepts the standard descriptors and binds them to the web server.  This means, in particular, that if at the request of the script some error occurs, the message about it will not be displayed on the console, but given to the web server.  You need to search for this message in the nginx log.  Well, in general, conventional CGI scripts have similar behavior in this regard, with the only difference that the CGI application logs are near, and the FastCGI application logs can be located on a completely different server. <br><br>  Do not neglect the output of the header "Content-Type" (well, or at least some of the title).  Without this, nginx will refuse to display anything to the browser.  In general, this behavior is also similar to the behavior of a web server when working with a regular CGI application. <br><br>  Well, they wrote the script, run it.  If you have not made a syntax error anywhere, the script will start silently, will not output anything and will not let go of the console - this is normal, it should be so.  Now the script has to listen to port 9000 and wait until it is accessed by the web server. <br><br>  Now we launch the browser and open the address <a href="http://test.host/fcgi-bin/">test.host/fcgi-bin</a> - remember, you already opened it when you checked the nginx configuration?  But this time, instead of the message about the inaccessibility of the page, a simple figure 1 should appear. Press the F5 button.  The figure should increase. <br><br>  Congratulations!  You have written and launched the FastCGI application.  This application is still very primitive and is not yet a real FastCGI server, but, by and large, you have already become acquainted with FastCGI technology. <br><br>  In the next part - the demonization of the application, turn the script into the server. <br><br>  ( <a href="http://m-ivanov.livejournal.com/4436.html">original article</a> ) </div><p>Source: <a href="https://habr.com/ru/post/52980/">https://habr.com/ru/post/52980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../52973/index.html">Error in gmail</a></li>
<li><a href="../52974/index.html">Entertaining mathematics</a></li>
<li><a href="../52976/index.html">Philips announced a photo player ... Or maybe an audio camera</a></li>
<li><a href="../52977/index.html">Clone Wars</a></li>
<li><a href="../52978/index.html">LDAP for internet project</a></li>
<li><a href="../52981/index.html">Brando Bluetooth Bracelet</a></li>
<li><a href="../52983/index.html">MySQL: Stored Procedures and Dynamic SQL</a></li>
<li><a href="../52986/index.html">Amazon is preparing an "international" version of the Kindle 3</a></li>
<li><a href="../52988/index.html">Contextual advertising VKontakte. Already working. My CTR is 3.62.</a></li>
<li><a href="../52989/index.html">What would you like to see on the Internet?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>