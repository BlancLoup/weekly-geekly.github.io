<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Condition Management in Polymer 2.0. Outside of parent / child bindings</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's organize a common state between divided DOM elements without Redux 
 To demonstrate how easy it is to use the framework and how productively you...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Condition Management in Polymer 2.0. Outside of parent / child bindings</h1><div class="post__text post__text-html js-mediator-article"><h3>  Let's organize a common state between divided DOM elements without Redux </h3><br>  To demonstrate how easy it is to use the framework and how productively you will work with it, the examples provided are often consciously simplified to fit simple situations.  Simplification makes sense when teaching people, but sometimes they can leave a gap in knowledge in those cases when you need to go beyond the trivial and start creating more complex, real-world applications. <br><a name="habracut"></a><br><br>  When it comes to managing a state, it becomes especially obvious, and Polymer here, of course, is no exception.  Typical examples that you will see most often include one parent, one or more children, and some kind of binding between them.  But what if things are not so simple?  How to transfer state between different parts of the application?  Do I need to start adding Redux to do this? <br><br>  Often you will hear rules like ‚Äúprops down, events up‚Äù and ‚Äúuse the Mediator pattern‚Äù, and this really makes sense, but here you can miss one thing - they work within a group of elements acting together as one, but these rules are less apply when your elements need to organize the overall state, but the elements are separated in the DOM, maybe even they are in different branches of the DOM tree.  You also do not want to create a chain of binders through the elements for which the transmitted data is not important and which do not have to worry about it, just down to get to the element that needs it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Specific solutions to this problem have been developed for some frameworks, sometimes rather heavy: <br><br>  Angular 2, mm ... 2+, or 4 (the one that is now the last one) offers to store the state in the services available through dependency injection for the components that need these services. <br><br>  React pushes for the use of a single central repository using Redux and view- components that can subscribe to its updates. <br><br>  Both of these approaches are essentially subspecies of singleton.  Some people are adamant now that ‚Äúsingletons are bad‚Äù (meaning that they should be avoided), which is wrong ‚Äî the whole point of the general condition is that there is only one source of truth about anything.  Naturally, any pattern can be used incorrectly, but the real problem with singletons is managing access to the state and synchronizing the state for all concerned, and not that the state becomes general. <br><br>  The browser already provides us with a collection of singletons, such as <code>window</code> , and we can put our state here.  This works great as a namespace until you choose something that should be unique to your application (using ‚ÄúgoogleMaps‚Äù for your own library might not be a good idea).  So why not use this method?  Well, there is a synchronization problem - if we change the value, then how does someone somewhere else find out that it has changed?  We definitely do not want to poll the status source by timer, it would be somewhat cumbersome to issue / subscribe to too many events. <br><br>  Let's leave the talk about the theory and take a look at a specific example to explore possible options.  Suppose we want to have the 'Options' panel in our <code>app-drawer-layout</code> from the Polymer Starter Kit (highlighted in red): <br><br><img src="https://habrastorage.org/webt/cj/2v/4c/cj2v4c-sywkcwt1p-x3aw1geqwg.png" alt="image"><br><br>  Although the view-elements that receive and display the value from 'Options' are so close on the screen (‚Äúlook, code, it's right HERE!‚Äù), They are millions of miles apart from a DOM point of view with various iron-pages, app -drawer, headers and other parts between them. <br><br>  Here is the code for the 'Options' panel: <br><br><pre> <code class="javascript hljs">&lt;link rel=<span class="hljs-string"><span class="hljs-string">"import"</span></span> href=<span class="hljs-string"><span class="hljs-string">"../bower_components/polymer/polymer-element.html"</span></span>&gt; &lt;link rel="import" href="../bower_components/paper-checkbox/paper-checkbox.html"&gt; &lt;dom-module id="my-options"&gt; &lt;template&gt; &lt;style&gt; :host { display: block; padding: 16px; } h3, p { margin: 8px 0; } &lt;/style&gt; &lt;h3&gt;Options&lt;/h3&gt; &lt;p&gt; &lt;paper-checkbox checked="{{ options.subscribe }}"&gt;Send Notifications&lt;/paper-checkbox&gt; &lt;/p&gt; &lt;/template&gt; &lt;script&gt; class MyOptions extends Polymer.Element { static get is() { return 'my-options'; } static get properties() { return { options: { type: Object, value: () =&gt; ({ subscribe: false }) } } } } window.customElements.define(MyOptions.is, MyOptions); &lt;/script&gt; &lt;/dom-module&gt;</code> </pre><br>  We would like to make the <code>options</code> property available from another place so that if someone needs access to its child property <code>subscribe</code> (or any other we add), this someone could get it and it would be updated with any changes but we don‚Äôt want everything to be open - we want to control access to it. <br><br>  Of course, we could start using something like Redux, and although this is indeed an option, such a solution has a significant cost in the form of additional requirements for building and code complexity.  This option has undeniable advantages, and if it makes sense to use it in your application for other reasons, it can be a good choice, but it can also be overkill and introduce as many problems as it solves, especially being added to a library that was not originally created under this design. <br><br>  One of the reasons to fall in love with Polymer is that it is built on the capabilities of the platform and we will see what can be achieved simply by using them + some pure JavaScript. <br><br>  Now is the right time to understand IIFE, or <a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">immediately called functions</a> , which enable us to run the code and declare variables without setting them out.  This is the basic structure that wraps the declaration of our class ‚Äî it declares a function and immediately executes it (exactly as its name implies): <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// existing code }());</span></span></code> </pre><br>  This actually does not change anything, except that our <code>MyOptions</code> class is <code>MyOptions</code> from the outside world (this is not important, since the only thing important for us is that it calls <code>window.customElements.define</code> ). <br><br>  In our application, there will be only one instance of <code>MyOptions</code> , and other elements will need access to it, so we will add a variable that refers to it and set its correct value in the constructor when the element is created: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> optionsInstance = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">// in class definition: constructor() { super(); if (!optionsInstance) optionsInstance = this; }</span></span></code> </pre><br>  <code>optionsInstance</code> is still hidden inside our IIFE, but now so that we don‚Äôt put it in it, it will have access to the initialized <code>MyOptions</code> instance. <br><br>  We want this instance to be responsible for the values, so we need to make sure that it follows the subscribers interested in the changes.  To do this, we add an array property to track the subscribers and instance methods that they can use to register and unregister: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// in properties: subscribers: { type: Array, value: () =&gt; [] } // in class definition: register(subscriber) { this.subscribers.push(subscriber); subscriber.options = this.options; subscriber.notifyPath('options'); } unregister(subscriber) { var i = this.subscribers.indexOf(subscriber); if (i &gt; -1) this.subscribers.splice(i, 1) }</span></span></code> </pre><br>  Note that when the subscriber is registered, we add it to the list, and also initialize a local variable in it that points to the <code>options</code> object.  Here we also encounter Polymer change detection ‚Äî setting the property itself does not notify the subscriber that this has happened, so we need a <code>notifyPath</code> call.  We also want to notify all subscribers whenever any properties of the <code>options</code> object change (for example, if 'subscribe' was called, not just when the object reference changes) and we use an observer with an asterisk to say that we are interested. ‚Äù all changes ‚Äù: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get observers() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'optionsChanged(options.*)'</span></span> ] } optionsChanged(change) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subscribers.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subscribers[i].notifyPath(change.path); } }</code> </pre><br>  The part related to notifications is simple - regardless of the path the observer has changed, this is the same path that we must notify our subscribers of the change, so we simply cycle through them and call <code>notifyPath</code> for each . <br><br>  Now we have the hooks and notifications that we need for subscribers, and we have two options.  Create an accessor element that will be inside the same IIFE (which means it will have access to <code>optionsInstance</code> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyOptionsValue</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Polymer</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get is() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'my-options-value'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get properties() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">options</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>, <span class="hljs-attr"><span class="hljs-attr">notify</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } connectedCallback() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.connectedCallback(); optionsInstance.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } disconnectedCallback() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.disconnectedCallback(); optionsInstance.unregister(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.customElements.define(MyOptionsValue.is, MyOptionsValue);</code> </pre><br>  Sonnected and disconnected callbacks are great for registering and unregistering instances.  This means that elements that can be very far from each other in the DOM tree can have direct links to each other and thus avoid the property-binding chain if we are limited to using the DOM structure for communication. <br><br>  An instance can be used inside an element, being imported into it: <br><br><pre> <code class="javascript hljs">&lt;link rel=<span class="hljs-string"><span class="hljs-string">"import"</span></span> href=<span class="hljs-string"><span class="hljs-string">"my-options.html"</span></span>&gt;</code> </pre><br>  and establishing a connection with him through the binding: <br><br><pre> <code class="javascript hljs">&lt;my-options-value options=<span class="hljs-string"><span class="hljs-string">"{{ options }}"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">my-options-value</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Send notifications option is: </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">[[ options.subscribe ]]</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br>  We need to set <code>notify: true</code> in the declaration of the properties of the element due to the bidirectional binding (child-to-parent), indicated by curly braces.  The <code>MyOptions</code> instance informs the instance (or instances) of <code>MyOptionsValue</code> about the change, and they, in turn, need to notify the element in which they are located. <br><br>  It <i>works</i> , and we can turn on or off the checkbox and watch updates, but we have an additional element, an additional binding, and we must add the options property to each view-element if we want to see warnings from the linter about undefined properties: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Polymer</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get is() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'my-view'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get properties() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">options</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span> } } } }</code> </pre><br>  <i>oh, another property of 'options' ...</i> <br><br>  One way to simplify things a bit is to use mixin.  Mixin is similar to class inheritance and makes it possible to combine element definitions, so code can be reused instead of duplication (previously, in Polymer 1.0, mixins were known as behaviors). <br><br>  Instead of creating an access element in our view-element and binding to the options property that it provides, our view-element <i>itself becomes</i> an access element - it has its own options property and processes the registration and deregistration of itself without additional code, not counting adding myxin to class definition: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyOptionsMixin</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Polymer</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get is() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'my-view'</span></span>; } }</code> </pre><br>  We still need to import <code>my-options.html</code> , but our view-element is simpler and does not require an intermediate access element: <br><br><pre> <code class="javascript hljs">&lt;p&gt;Send notifications option is: <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">[[ options.subscribe ]]</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br>  Now, every time an element needs access to the options property, we simply add a mixin to provide this property, which will be updated automatically.  Redux is not required. <br><br>  This approach actually has a name, it is called a ‚Äúmono-state‚Äù pattern.  There are already existing elements, such as <a href="https://github.com/PolymerElements/iron-meta">iron-meta</a> , that provide a general approach, but in my opinion it is simpler, cleaner and faster to create application-specific implementations ‚Äî often they are easier to adapt for specific cases and seem more understandable than using intermediate components. <br><br>  Here is the final, complete code for our classes, which I hope looks simpler.  I should also apologize for using ‚Äúsubscribe‚Äù as the name, which can be confused with instance subscriptions.  Initially, I used the name ‚Äúnotify‚Äù, which was even worse (since this is the name of one of the Polymer properties): <br><br><pre> <code class="javascript hljs">&lt;link rel=<span class="hljs-string"><span class="hljs-string">"import"</span></span> href=<span class="hljs-string"><span class="hljs-string">"../bower_components/polymer/polymer-element.html"</span></span>&gt; &lt;link rel="import" href="../bower_components/paper-checkbox/paper-checkbox.html"&gt; &lt;dom-module id="my-options"&gt; &lt;template&gt; &lt;style&gt; :host { display: block; padding: 16px; } h3, p { margin: 8px 0; } &lt;/style&gt; &lt;h3&gt;Options&lt;/h3&gt; &lt;p&gt; &lt;paper-checkbox checked="{{ options.subscribe }}"&gt;Send Notifications&lt;/paper-checkbox&gt; &lt;/p&gt; &lt;/template&gt; &lt;script&gt; (function() { let optionsInstance = null; class MyOptions extends Polymer.Element { static get is() { return 'my-options'; } static get properties() { return { options: { type: Object, value: () =&gt; ({ subscribe: false }) }, subscribers: { type: Array, value: () =&gt; [] } } } static get observers() { return [ 'optionsChanged(options.*)' ] } constructor() { super(); if (!optionsInstance) optionsInstance = this; } register(subscriber) { this.subscribers.push(subscriber); subscriber.options = this.options; subscriber.notifyPath('options'); } unregister(subscriber) { var i = this.subscribers.indexOf(subscriber); if (i &gt; -1) this.subscribers.splice(i, 1) } optionsChanged(change) { for(var i = 0; i &lt; this.subscribers.length; i++) { this.subscribers[i].notifyPath(change.path); } } } window.customElements.define(MyOptions.is, MyOptions); MyOptionsMixin = (superClass) =&gt; { return class extends superClass { static get properties() { return { options: { type: Object } } } connectedCallback() { super.connectedCallback(); optionsInstance.register(this); } disconnectedCallback() { super.disconnectedCallback(); optionsInstance.unregister(this); } } } }()); &lt;/script&gt; &lt;/dom-module&gt;</code> </pre><br>  View element, user: <br><br><pre> <code class="javascript hljs">&lt;link rel=<span class="hljs-string"><span class="hljs-string">"import"</span></span> href=<span class="hljs-string"><span class="hljs-string">"../bower_components/polymer/polymer-element.html"</span></span>&gt; &lt;link rel="import" href="my-options.html"&gt; &lt;link rel="import" href="shared-styles.html"&gt; &lt;dom-module id="my-view2"&gt; &lt;template&gt; &lt;style include="shared-styles"&gt; :host { display: block; padding: 10px; } &lt;/style&gt; &lt;div class="card"&gt; &lt;div class="circle"&gt;2&lt;/div&gt; &lt;h1&gt;View Two&lt;/h1&gt; &lt;p&gt;Ea duis bonorum nec, falli paulo aliquid ei eum.&lt;/p&gt; &lt;p&gt;Id nam odio natum malorum, tibique copiosae expetenda mel ea.Detracto suavitate repudiandae no eum. Id adhuc minim soluta nam.Id nam odio natum malorum, tibique copiosae expetenda mel ea.&lt;/p&gt; &lt;p&gt;Send notifications option is: &lt;b&gt;[[ options.subscribe ]]&lt;/b&gt;&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; class MyView2 extends MyOptionsMixin(Polymer.Element) { static get is() { return 'my-view2'; } } window.customElements.define(MyView2.is, MyView2); &lt;/script&gt; &lt;/dom-module&gt;</code> </pre><br>  Note: the example from this post works because the UI of the 'Options' panel is always the first in the DOM account, so access element subscribers can always find an existing instance.  If this is not the case, then it is easy enough to use the function instead, so that the first caller creates a single instance ‚Äî take a look at the <a href="https://github.com/PolymerElements/iron-a11y-announcer">iron-a11y-announcer</a> in which it is implemented. <br><br>  Also, in case this is not clear enough, although <code>MyOptionsMixin</code> defined inside IIFE, it is actually in the scope of the <code>window</code> , so other elements outside of IIFE can see and use it (if we wrote <code>var MyOptionsMixin‚Ä¶</code> then it would did not work, it would be visible only inside IIFE).  I should have used <code>window.MyOptionsMixin</code> to make it clearer, or, as is more common, to use the global namespace (child object in the <code>window</code> ) as well as Polymer does.  You may already have it - they are useful for <a href="https://www.captaincodeman.com/2017/04/06/polymer-app-configuration-url-generation">storing configuration properties</a> .  The safe way to check and add something to it looks like this: <br><br><pre> <code class="javascript hljs">MyApp = windows.MyApp || { } MyApp.MyOptionsMixin = ...</code> </pre><br>  (after which you can always use <code>MyApp.MyOptionsMixin</code> , referring to it). </div><p>Source: <a href="https://habr.com/ru/post/345808/">https://habr.com/ru/post/345808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345792/index.html">Frontend 2017: the most important</a></li>
<li><a href="../345794/index.html">The whole truth about the new office "Informzaschity", and How we survived the move</a></li>
<li><a href="../345800/index.html">Wonderful Premine in DAG cryptocurrency</a></li>
<li><a href="../345802/index.html">Simple PHP Task Scheduler</a></li>
<li><a href="../345804/index.html">How to enable the dark theme of the Unity editor</a></li>
<li><a href="../345814/index.html">Dynamic loading of the template Vue component</a></li>
<li><a href="../345816/index.html">WD Red drives - a balanced solution for use in small and medium NAS</a></li>
<li><a href="../345818/index.html">Visualization of the development of SEMrush.com 2017</a></li>
<li><a href="../345820/index.html">Backup Mikrotik with SSH and SCP</a></li>
<li><a href="../345822/index.html">Defining a file format with Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>