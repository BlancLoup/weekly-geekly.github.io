<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Open Source Photo Realism on GPU: Cycles Render</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the development of GPGPU technology, a lot of GPU renderers appeared on the market, among them iRay, V-ray RT, Octane, Arion. But, the opensource...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Open Source Photo Realism on GPU: Cycles Render</h1><div class="post__text post__text-html js-mediator-article">  With the development of GPGPU technology, a lot of GPU renderers appeared on the market, among them iRay, V-ray RT, Octane, Arion.  But, the opensource community is not asleep, and at least two free GPU renderers appeared to me: SmallLuxGPU and Cycles Render.  I want to share my impressions about the latter. <br><br>  Cycles Render - <a href="http://habrahabr.ru/post/142003/">unbiased rendering</a> , with the ability to render on the GPU (CUDA and OpenCL for ATI).  Lies in a box with Blender, which runs on Windows, Linux, OSX. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c03/ac3/f2d/c03ac3f2d31e98062e2716d8ca473725.jpg"><br>  <i>Cycles Render, a car with a procedural texture, <a href="http://ubuntuone.com/0pcrNsX8QUo909DriCp3Pz">FullHD</a> was preparing for 2 minutes on the GTX580.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Blender was of little interest to me, even despite some advantages I knew about: openness, ease of installer, speed of work.  It is extremely difficult for a conservator to transfer from 3d max to Blender: another management, ‚Äúit's all wrong!‚Äù.  But, being turned on the topic of anbias renders, especially on the GPU, I decided to try out Cycles, for one thing, and Blender to learn (at the time of publishing the article version <b>2.63</b> ). <br><a name="habracut"></a><br>  A small video about interactivity, and how it all works: <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/8bDaRXvXG0E%3Ffeature%3Doembed&amp;xid=17259,15700022,15700043,15700186,15700191,15700253,15700255,15700259&amp;usg=ALkJrhjxbB_kjbDcjvHOy1NtGF-EGGRuFA" frameborder="0" allowfullscreen=""></iframe><br>  <i>The rendering mode using Cycles can be done directly in the active viewport (this is not an innovation, just a convenience), or you can monitor the changes in the scene in real time from the camera.</i> <br><br>  <b>CPU vs GPU</b> <br>  The x86-64 processor cores have a very cumbersome instruction set, requiring a large crystal area.  Because of this, it is difficult to locate many cores on the CPU, but in single-threaded x86 applications it shows itself from the best side. <br>  But rendering is a multi-thread thing to ugliness.  The main thing here is the high speed of floating point operations, and operating with a large amount of data requires good memory bandwidth.  GPU is suitable for these purposes much better. <br>  But the GPU, as a platform that was originally sharpened for hardware rasterization (OpenGL, DirectX), is rather difficult to adapt to GPGPU tasks.  Many software solutions that are easily solved on a CPU require considerable dancing with a tambourine on a GPU through CUDA and OpenCL frameworks.  Often, due to the complexity of the implementation of algorithms, weak optimization of frameworks (for example, OpenCL), programming on the GPU is refused. <br>  For mathematical operations (rendering, physics calculation), a new processor architecture is needed with a small set of instructions, a large number of cores and a set of hardware solutions for fast additions and multiplications of floating-point numbers.  Or wait until the GPU hardware and software is better adapted to the needs of non-graphical computing. <br>  But since there is no such architecture and no desire to wait until everything ‚Äúbecomes cool,‚Äù developers around the world are already mastering the GPU.  Of course, GPU rendering increases the rendering speed several times. <br><br>  <a href="http://blenderartists.org/forum/showthread.php%3F239480-2.61-Cycles-render-benchmark">There is a small benchmark</a> where you can try your hardware. <br>  <i>My render time (core i5 2500 vs GTX580).</i> <i><br></i>  <i>Windows 7 64bit: CPU <b>5:39</b> : 64 CUDA <b>0:42</b> : 54.</i>  <i><b>8.07</b> times</i> <i><br></i>  <i>Ubuntu 12.04 64bit: CPU <b>3:48</b> : 77, CUDA <b>0:39</b> : 03.</i>  <i><b>5.84</b> times.</i> <br>  It would be interesting to find out about the rendering speed on the latest top Radeons. <br><br>  An interesting fact is that Unixes surpass Windows in rendering speed on the CPU.  So that you don‚Äôt think that my Windows lives badly, I‚Äôve dug up the evidence: one <a href="http://www.render.ru/forum/viewtopic.php%3Ftopic_id%3D120516">time</a> (4th message) and <a href="http://forums.cgsociety.org/archive/index.php/t-1044213.html">two</a> (in English).  What is the reason - I don‚Äôt want to guess, I don‚Äôt know. <br>  UPD: I already know, thanks to <a href="http://habrahabr.ru/users/lockal/" class="user_link">Lockal</a> for the <a href="http://habrahabr.ru/post/142213/">comment</a> . <br><br>  GPU detachment also depends on hardware, and the complexity of procedural textures.  In complex procedural textures, the GPU margin is slightly reduced.  By the way, about them. <br><br>  <b>Procedural textures</b> <br>  To create the desired material, you must have the skills to build shaders using the node graph.  How it works I will try to explain with an example: <br><img src="https://habrastorage.org/getpro/habr/post_images/34c/204/fd9/34c204fd9928a550f42d876b03bbeff1.jpg" title="Node graph"><br>  Where <i>(it seemed to me that backwards would be clearer)</i> : <br>  1. Exit.  Material Output is required to bring a function to the surface. <br>  2. The shader mixes the paint component (4) and gloss (5) in accordance with the parameter (3). <br>  3. The reflection coefficient of a glossy surface (the coefficient of reflection depends on the angle of incidence, than perpendicular to the surface is reflected less than a tangent) <br>  4. The shader mixes shaders 6 and 7 in equal proportions (Fac = 0.5). <br>  5. Specular reflection (varnished surface). <br>  6, 7. Diffuse and glossy (roughness 0.35) components of paint. <br>  8. Color converter.  At the Hue input, the fac texture parameter (9) is from 0 to 1. At the output, the light is shifted relative to red. <br>  9. Generator of cells of random color (r, g, b), where fac is intensity (from 0 to 1). <br><br>  Having mastered the principle of work, you can play a little: <br><img src="https://habrastorage.org/getpro/habr/post_images/070/4d8/e39/0704d8e392a166758b8e129bc37411bf.jpg"><br>  <i>You can combine any textures and types of surfaces.</i>  <i>There is <a href="http://ubuntuone.com/6Zibd7Xw4CLnwJfmJehRyA">FullHD</a> .</i> <br><br>  You can create light sources of negative luminosity. <br><img src="https://habrastorage.org/getpro/habr/post_images/816/7da/96f/8167da96fda0573dbdd9a3b225ba5514.jpg"><br>  <i>Light, anti-light.</i> <br><br>  Procedural can be done not only the surface, but also the environment: the sky, clouds, etc.  And with the help of nodes, you can also customize the post-processing of the image. <br><br>  <b>Incomprehensibility</b> <br>  Well, at first for me this question was incomprehensible, but then I realized what was happening.  Here, as I understand it, the question is between performance and convenience, and this applies to all anbias on the GPU (the Arion Render and all the anbias on the CPU do not sin with this feature). <br>  They have a glossy material for mirror and gloss reflections, and diffuse for scattered ones. <br>  The point is this.  If there is no scattering, then the magnitude of the random deviation at the point of incidence of the beam is 0, and the beam is reflected in a mirror.  If 1 (maximum) - then the beam can be reflected in any direction in the hemisphere of reflection.  That is, if we take a mirror and give it the maximum roughness, then we get white paper.  At least I got used to it, using Maxwell. <br><img src="https://habrastorage.org/getpro/habr/post_images/c5c/087/0e0/c5c0870e0939572280e163a01448ca83.jpg"><br>  <i>If the rough and glossy turned out to be somehow not very, and you can not call it plausible scattered, then diffuse is the most it.</i> <br><br>  The same goes for the translucent shader.  Translucent is translated as an opaque medium, but rendering means diffuse refraction.  I mean, Translucent is a frosted glass (Glass shader with a matte roughness). <br><img src="https://habrastorage.org/getpro/habr/post_images/487/b06/ee5/487b06ee5ef47a87277f1861ffdafe1c.jpg"><br>  <i>From these pictures we can say that Translucent looks normal.</i> <br><br>  It is clear that with the Glossy and Glass roughness close to 1 (visually, more than 0.7) it is better to use Diffuse and Translucent. <br><br>  Detailed information on shader properties is <a href="http://wiki.blender.org/index.php/Doc:2.6/Manual/Render/Cycles/Nodes/Shaders">here</a> . <br><br>  These questions are not fundamental for obtaining a realistic picture, but still, I would like to add some more generalizing and believable model of reflection for those who are used to such. <br>  For example: set the surface roughness with any one parameter, as is done in Maxwell, Fry, Indigo, Lux and the features of the reflection distribution - with additional sliders and check marks.  And for the most severe - to control the distribution of reflections using Bezier curves.  Let, at the expense of performance. <br><br>  In addition, Cycles render still suffers from this feature.  If we have several light sources in the scene (say, 2), then the probability that a beam fired from a camera will affect a large light source will be greater than a small one, regardless of the intensity of the light sources.  When a soft and hard light is combined in a scene, it may look like this (left), and it will take a long time to wait for the noise to pass. <br><img src="https://habrastorage.org/getpro/habr/post_images/4a9/c21/0d1/4a9c210d1809b62ed5ce2059c1ae91dc.jpg"><br>  <i>The picture on the left shows that it is the front light that is ‚Äúnoisy‚Äù, while the rear one feels great.</i> <br><br>  The first thing that can come to mind is to combine 2 render in post-processing. <br>  However, so that people do not suffer much, in Cycles there is such a function: ‚ÄúSample as lamp‚Äù, which is on by default.  If you uncheck it, a part of the rays emitted from the camera will be reflected from objects in a random direction, and not in the direction of the light source (pure path tracing).  In this case, the small light source will win, and the little one will lose a little.  I think this is a temporary solution, and sooner or later the program will be completed and will take over the solution of this problem. <br><br>  In general, the most difficult task in tracers is the correct distribution of computational loads over an image: which light source should be given more attention - which one less, which pixel needs many samples - which one does not, which material layer should be sampled more - and which practically does not affect the resulting image , in which direction it is better to reflect the beam, etc.  With this, so far tight. <br><br>  <b>Oranges vs tomatoes</b> <br>  Maybe some will think about comparing Cycles with Maxwell.  But the new open-source renderers need to grow and become equal to their older comrades. <br>  So, the resolution is 400x300, time 10 sec: <br><img src="https://habrastorage.org/getpro/habr/post_images/584/1dc/27b/5841dc27b71b025f119dd9d864f0b353.jpg"><br>  <i>Maxwell looks much livelier, anyway.</i> <br><br>  In Maxwell, no parameters of surfaces like sample as lamp were configured, the load distribution algorithm takes over. <br>  The strong noise from the caustics in Cycles (and the caustics, if desired, can be turned off) is due to the fact that it does not have Metropolis Sampling (the algorithm for optimizing beam beams, which is in Maxwell Render). <br><br>  It should be noted that when using light from the environment or one large light source, the image in Cycles is noticeably cleaner than in Maxwell. <br><img src="https://habrastorage.org/getpro/habr/post_images/32b/aa9/244/32baa9244f7726c269b426ea09b20730.jpg"><br>  <i>Rendered 5 seconds.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb7/a46/c25/eb7a46c25ae68ee68ceb19c776c9d7b2.jpg"><br>  <i>And a little more serious (core i5, 1 min).</i> <br><br>  <b>Bvh</b> <br>  Bounding Volume Hierarchy - translated as a hierarchy of limiting volumes (thanks to <a href="http://habrahabr.ru/users/don/" class="user_link">don</a> for the enlightenment in this part). <br>  <i>Honestly, in different renders the process of ‚Äúpre-developer preparation‚Äù is called differently, compiling mesh in Octane, Voxelisation - in Maxwell.</i>  <i>I, like many who work with Maxwell, used to call this business voxelization, but the above comrade says that this is not the same thing.</i>  <i>Please forgive this inaccuracy.</i> <br>  This case was designed not to check each ray for intersection with all the triangles in the scene.  And if there are millions of them?  They all need to be checked for intersection.  In this case, we hardly see the speed of more than a couple of samples per second.  And with each new triangle the task will become more and more complicated. <br>  The downside is that the BVH build is performed in Cycles always on the CPU.  Maybe sometime, voxelization on the GPU will appear, but so far it is not, from which its limitations follow.  For example, you have 10 million triangles in a scene, and 8 top-end video cards.  They will render the picture in seconds, while the object voxelization time can exceed a minute even on a cool Core i7.  If you use only core i7, then it will take you about a minute to voxelize, and 20-30 minutes to render.  In this case, the voxelization time is not critical. <br>  Voxelization of the above-rendered vehicle (400k triangles) takes 14 seconds. <br><br>  With interactive visualization (preview), voxelization is performed only before the start of rendering, and with changes in the geometry of objects (the position of the vertices, the use of modifiers).  And also, when you press Ctrl + Z (even if I haven‚Äôt done anything like this, I‚Äôd probably not finish it yet).  In building a BVH there is no need to navigate, scale, change the location and rotation of objects. <br><br>  When rendering (that is, at the final, by pressing the F12 button), voxelization is always performed.  When animating, you can avoid the constant rebuilding of BVH static objects by clicking on the Cache BVH checkmark. <br>  Let's hope that soon this issue will be somehow resolved in favor of speeding up the voxelization process, maybe this task can be transferred to the GPU. <br><br>  <b>Opencl</b> <br>  Distressed OpenCL under my Nvidia, the speed is inferior to CUDA two times.  Under Ubuntu, Blender with OpenCL just crashes.  Under Win7, it renders using OpenCL, but the render looks <a href="">wrong</a> for me, if the material consists of several layers, only one of them is shown, for example, the gloss or matte component.  And the <a href="">bugs in the viewport are</a> simply inimitable. <br>  On the Radeon, there seems to be no such bugs, maybe comments will be shown. <br><br>  <b>Interface brakes</b> <br>  If during rendering on a CPU it is not difficult to surf the web, then at full load the GPU is convenient only to read, Habr, for example.  With this, it is desirable to try to keep turning the pages to a minimum, so as not to strain from the brakes. <br>  Maybe there are some ways to change the priority of tasks on the GPU, but I don‚Äôt know about them. <br><br>  <b>If much intrigued</b> <br>  You can run it right now.  To do this, you need to <a href="http://www.blender.org/download/get-blender/">download Blender</a> and <a href="http://www.blenderfanatic.isapymesinventarios.com/oldTuts/cyclesEn.html">run Cycles</a> at home.  To select a GPU: File -&gt; User Preferences, select the System tab at the top, and at the bottom left you can choose a rendering platform (the default CPU value is set). <br><br>  <b>Subjective opinion</b> <br>  Today, Cycles is already good enough for visualization. <br>  I think it would be nice to use it for subject rendering: on the basis of Cycles you can create your own Bunkspeed Shot, Hypershot, Keyshot, Autodesk Showcase.  So that a person who is not dedicated to the wisdom of 3D editors can download a model and admire it from all sides in a beautiful render. <br>  The enthusiasm of developers can not but rejoice, as does the activity of the opensource community in general. <br>  I look forward to further development of the project. </div><p>Source: <a href="https://habr.com/ru/post/142213/">https://habr.com/ru/post/142213/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142208/index.html">Gigapixel panoramas of two capitals</a></li>
<li><a href="../142209/index.html">Moody's lowered Nokia‚Äôs status to ‚Äúhigh-risk investment‚Äù</a></li>
<li><a href="../142210/index.html">Gearman - Queue Server: Use in PHP Projects</a></li>
<li><a href="../142211/index.html">Minesweeper on DCPU-16</a></li>
<li><a href="../142212/index.html">Using Grab: Spider for parsing sites</a></li>
<li><a href="../142215/index.html">Personal account for the wholesale company. Is it really that hard?</a></li>
<li><a href="../142217/index.html">Google-sponsored research struggles with fake reviews</a></li>
<li><a href="../142218/index.html">Cluster? Easy!</a></li>
<li><a href="../142219/index.html">The relevance of SMBRelay attacks in modern Windows networks</a></li>
<li><a href="../142221/index.html">Duplication of an object when trying to get data from a table with the DateTime key</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>