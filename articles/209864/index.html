<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Making PHP web sites from scratch</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago I chose a library for working with web-based software. On the Internet, I came across articles on the integration of node.js with yii, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Making PHP web sites from scratch</h1><div class="post__text post__text-html js-mediator-article">  Some time ago I chose a library for working with web-based software.  On the Internet, I came across articles on the integration of node.js with yii, and almost all articles on websockets in Habr√© were limited to instructions on how to use phpdaemon. <br><br>  I studied the libraries <a href="http://daemon.io/">phpdaemon</a> and <a href="http://socketo.me/">ratchet</a> , they are quite monstrous (and using ratchet to send a message to a specific user it is recommended to use <a href="http://wamp.ws/">wamp</a> additionally).  It was not quite clear to me why use such monsters that require installation of other monsters.  After reading the sources of these, as well as other libraries, I figured out how everything works and I wanted to write a simple web server server in php on my own.  This helped me to fix the material studied and stumble upon some of the pitfalls that I had no idea about. <br><br>  So I decided to write the necessary functionality for me from scratch. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The resulting code and link to the demo chat at the end of the article. <br><a name="habracut"></a><br><h4>  Set goals: </h4><br>  1) deal with server sockets in php <br>  2) deal with the protocol of web sockets <br>  3) write a simple web-based server from scratch <br><br><h4>  1) Server sockets in php </h4><br>  Up to this point, I had a vague idea of ‚Äã‚Äãserver sockets.  Having read the source codes of several libraries for working with websockets, I ran into two schemes for their implementation: <br><br>  using php "socket" extension: <br><pre><code class="php hljs">$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);<span class="hljs-comment"><span class="hljs-comment">//  socket_bind($socket, '127.0.0.1', 8000);//    ip   socket_set_option($socket, SOL_SOCKET, SO_REUSEADDR, 1);//       socket_listen($socket);// </span></span></code> </pre> <br>  or using the php "stream" extension: <br><pre> <code class="php hljs">$socket = stream_socket_server(<span class="hljs-string"><span class="hljs-string">"tcp://127.0.0.1:8000"</span></span>, $errno, $errstr);</code> </pre><br>  I preferred the second option because of its brevity. <br><br>  So, we have created a server socket and now we want to handle new connections to it, for this again there are two options <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($connect = stream_socket_accept($socket, <span class="hljs-number"><span class="hljs-number">-1</span></span>)) {<span class="hljs-comment"><span class="hljs-comment">//   ( ) ... $connect }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">An example of a simple http server that responds to all requests: Hello</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env php &lt;?php $socket = stream_socket_server("tcp://0.0.0.0:8000", $errno, $errstr); if (!$socket) { die("$errstr ($errno)\n"); } while ($connect = stream_socket_accept($socket, -1)) { fwrite($connect, "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nConnection: close\r\n\r\n"); fclose($connect); } fclose($socket);</span></span></code> </pre><br></div></div><br><br>  or using stream_select <br><br><pre> <code class="php hljs">$connects = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   : $read = $connects; $read[] = $socket; $write = $except = null; if (!stream_select($read, $write, $except, null)) {//     ( ) break; } if (in_array($socket, $read)) {//   $connect = stream_socket_accept($socket, -1);//   $connects[] = $connect;//       unset($read[ array_search($socket, $read) ]); } foreach($read as $connect) {//   ... $connect unset($connects[ array_search($connect, $connects) ]); } }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">An example of a simple http server using stream_select, which responds to all requests: Hi</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env php &lt;?php $socket = stream_socket_server("tcp://0.0.0.0:8000", $errno, $errstr); if (!$socket) { die("$errstr ($errno)\n"); } $connects = array(); while (true) { //   : $read = $connects; $read []= $socket; $write = $except = null; if (!stream_select($read, $write, $except, null)) {//     ( ) break; } if (in_array($socket, $read)) {//   $connect = stream_socket_accept($socket, -1);//   $connects[] = $connect;//       unset($read[ array_search($socket, $read) ]); } foreach($read as $connect) {//   $headers = ''; while ($buffer = rtrim(fgets($connect))) { $headers .= $buffer; } fwrite($connect, "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nConnection: close\r\n\r\n"); fclose($connect); unset($connects[ array_search($connect, $connects) ]); } } fclose($server);</span></span></code> </pre><br></div></div><br>  Since  in the future, we will need to simultaneously process the server socket for new connections, and existing connections for new messages, then we‚Äôll look at the second option. <br><br><h4>  2) Protocol of websockets </h4><br>  <a href="http://habrahabr.ru/post/179585/">This article</a> describes the interaction protocol well. <br>  We are interested in two points: <br><h5>  "Handshake" or handshake: </h5><br>  We read the value of Sec-WebSocket-Key from the incoming header from the client, count on the basis of it Sec-WebSocket-Accept and send the final answer: <br><pre> <code class="php hljs">$SecWebSocketAccept = base64_encode(pack(<span class="hljs-string"><span class="hljs-string">'H*'</span></span>, sha1($SecWebSocketKey . <span class="hljs-string"><span class="hljs-string">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span></span>))); $response = <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 101 Web Socket Protocol Handshake\r\n"</span></span> . <span class="hljs-string"><span class="hljs-string">"Upgrade: websocket\r\n"</span></span> . <span class="hljs-string"><span class="hljs-string">"Connection: Upgrade\r\n"</span></span> . <span class="hljs-string"><span class="hljs-string">"Sec-WebSocket-Accept:$SecWebSocketAccept\r\n\r\n"</span></span>;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">An example of the function that does it.</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handshake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($connect)</span></span></span><span class="hljs-function"> </span></span>{ $info = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); $line = fgets($connect); $header = explode(<span class="hljs-string"><span class="hljs-string">' '</span></span>, $line); $info[<span class="hljs-string"><span class="hljs-string">'method'</span></span>] = $header[<span class="hljs-number"><span class="hljs-number">0</span></span>]; $info[<span class="hljs-string"><span class="hljs-string">'uri'</span></span>] = $header[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//    while ($line = rtrim(fgets($connect))) { if (preg_match('/\A(\S+): (.*)\z/', $line, $matches)) { $info[$matches[1]] = $matches[2]; } else { break; } } $address = explode(':', stream_socket_get_name($connect, true)); //   $info['ip'] = $address[0]; $info['port'] = $address[1]; if (empty($info['Sec-WebSocket-Key'])) { return false; } //     $SecWebSocketAccept = base64_encode(pack('H*', sha1($info['Sec-WebSocket-Key'] . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'))); $upgrade = "HTTP/1.1 101 Web Socket Protocol Handshake\r\n" . "Upgrade: websocket\r\n" . "Connection: Upgrade\r\n" . "Sec-WebSocket-Accept:$SecWebSocketAccept\r\n\r\n"; fwrite($connect, $upgrade); return $info; }</span></span></code> </pre><br></div></div><br><br><h5>  message exchange </h5><br>  After receiving the data from the web socket, we need to decode it, and encode it when sending it. <br>  Everything in <a href="http://habrahabr.ru/post/179585/">the same article</a> describes message coding well, but in essence we need only two functions: decode and encode. <br><div class="spoiler">  <b class="spoiler_title">An example of the implementation of decode and encode</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($data)</span></span></span><span class="hljs-function"> </span></span>{ $unmaskedPayload = <span class="hljs-string"><span class="hljs-string">''</span></span>; $decodedData = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-comment"><span class="hljs-comment">// estimate frame type: $firstByteBinary = sprintf('%08b', ord($data[0])); $secondByteBinary = sprintf('%08b', ord($data[1])); $opcode = bindec(substr($firstByteBinary, 4, 4)); $isMasked = ($secondByteBinary[0] == '1') ? true : false; $payloadLength = ord($data[1]) &amp; 127; // unmasked frame is received: if (!$isMasked) { return array('type' =&gt; '', 'payload' =&gt; '', 'error' =&gt; 'protocol error (1002)'); } switch ($opcode) { // text frame: case 1: $decodedData['type'] = 'text'; break; case 2: $decodedData['type'] = 'binary'; break; // connection close frame: case 8: $decodedData['type'] = 'close'; break; // ping frame: case 9: $decodedData['type'] = 'ping'; break; // pong frame: case 10: $decodedData['type'] = 'pong'; break; default: return array('type' =&gt; '', 'payload' =&gt; '', 'error' =&gt; 'unknown opcode (1003)'); } if ($payloadLength === 126) { $mask = substr($data, 4, 4); $payloadOffset = 8; $dataLength = bindec(sprintf('%08b', ord($data[2])) . sprintf('%08b', ord($data[3]))) + $payloadOffset; } elseif ($payloadLength === 127) { $mask = substr($data, 10, 4); $payloadOffset = 14; $tmp = ''; for ($i = 0; $i &lt; 8; $i++) { $tmp .= sprintf('%08b', ord($data[$i + 2])); } $dataLength = bindec($tmp) + $payloadOffset; unset($tmp); } else { $mask = substr($data, 2, 4); $payloadOffset = 6; $dataLength = $payloadLength + $payloadOffset; } /** * We have to check for large frames here. socket_recv cuts at 1024 bytes * so if websocket-frame is &gt; 1024 bytes we have to wait until whole * data is transferd. */ if (strlen($data) &lt; $dataLength) { return false; } if ($isMasked) { for ($i = $payloadOffset; $i &lt; $dataLength; $i++) { $j = $i - $payloadOffset; if (isset($data[$i])) { $unmaskedPayload .= $data[$i] ^ $mask[$j % 4]; } } $decodedData['payload'] = $unmaskedPayload; } else { $payloadOffset = $payloadOffset - 4; $decodedData['payload'] = substr($data, $payloadOffset); } return $decodedData; } function encode($payload, $type = 'text', $masked = false) { $frameHead = array(); $payloadLength = strlen($payload); switch ($type) { case 'text': // first byte indicates FIN, Text-Frame (10000001): $frameHead[0] = 129; break; case 'close': // first byte indicates FIN, Close Frame(10001000): $frameHead[0] = 136; break; case 'ping': // first byte indicates FIN, Ping frame (10001001): $frameHead[0] = 137; break; case 'pong': // first byte indicates FIN, Pong frame (10001010): $frameHead[0] = 138; break; } // set mask and payload length (using 1, 3 or 9 bytes) if ($payloadLength &gt; 65535) { $payloadLengthBin = str_split(sprintf('%064b', $payloadLength), 8); $frameHead[1] = ($masked === true) ? 255 : 127; for ($i = 0; $i &lt; 8; $i++) { $frameHead[$i + 2] = bindec($payloadLengthBin[$i]); } // most significant bit MUST be 0 if ($frameHead[2] &gt; 127) { return array('type' =&gt; '', 'payload' =&gt; '', 'error' =&gt; 'frame too large (1004)'); } } elseif ($payloadLength &gt; 125) { $payloadLengthBin = str_split(sprintf('%016b', $payloadLength), 8); $frameHead[1] = ($masked === true) ? 254 : 126; $frameHead[2] = bindec($payloadLengthBin[0]); $frameHead[3] = bindec($payloadLengthBin[1]); } else { $frameHead[1] = ($masked === true) ? $payloadLength + 128 : $payloadLength; } // convert frame-head to string: foreach (array_keys($frameHead) as $i) { $frameHead[$i] = chr($frameHead[$i]); } if ($masked === true) { // generate a random mask: $mask = array(); for ($i = 0; $i &lt; 4; $i++) { $mask[$i] = chr(rand(0, 255)); } $frameHead = array_merge($frameHead, $mask); } $frame = implode('', $frameHead); // append payload to frame: for ($i = 0; $i &lt; $payloadLength; $i++) { $frame .= ($masked === true) ? $payload[$i] ^ $mask[$i % 4] : $payload[$i]; } return $frame; }</span></span></code> </pre><br></div></div><br><br><h4>  Simple webbox server </h4><br>  So, we have all the necessary information. <br>  Using the code of a simple http server from the first part, as well as the handshake, decode and encode functions from the second, we can build a simple web socket server. <br><br><div class="spoiler">  <b class="spoiler_title">An example implementation of a simple web socket server</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env php &lt;?php $socket = stream_socket_server("tcp://0.0.0.0:8000", $errno, $errstr); if (!$socket) { die("$errstr ($errno)\n"); } $connects = array(); while (true) { //   : $read = $connects; $read []= $socket; $write = $except = null; if (!stream_select($read, $write, $except, null)) {//     ( ) break; } if (in_array($socket, $read)) {//   //     : if (($connect = stream_socket_accept($socket, -1)) &amp;&amp; $info = handshake($connect)) { $connects[] = $connect;//       onOpen($connect, $info);//   } unset($read[ array_search($socket, $read) ]); } foreach($read as $connect) {//   $data = fread($connect, 100000); if (!$data) { //   fclose($connect); unset($connects[ array_search($connect, $connects) ]); onClose($connect);//   continue; } onMessage($connect, $data);//   } } fclose($server); function handshake($connect) { $info = array(); $line = fgets($connect); $header = explode(' ', $line); $info['method'] = $header[0]; $info['uri'] = $header[1]; //    while ($line = rtrim(fgets($connect))) { if (preg_match('/\A(\S+): (.*)\z/', $line, $matches)) { $info[$matches[1]] = $matches[2]; } else { break; } } $address = explode(':', stream_socket_get_name($connect, true)); //   $info['ip'] = $address[0]; $info['port'] = $address[1]; if (empty($info['Sec-WebSocket-Key'])) { return false; } //     $SecWebSocketAccept = base64_encode(pack('H*', sha1($info['Sec-WebSocket-Key'] . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'))); $upgrade = "HTTP/1.1 101 Web Socket Protocol Handshake\r\n" . "Upgrade: websocket\r\n" . "Connection: Upgrade\r\n" . "Sec-WebSocket-Accept:$SecWebSocketAccept\r\n\r\n"; fwrite($connect, $upgrade); return $info; } function encode($payload, $type = 'text', $masked = false) { $frameHead = array(); $payloadLength = strlen($payload); switch ($type) { case 'text': // first byte indicates FIN, Text-Frame (10000001): $frameHead[0] = 129; break; case 'close': // first byte indicates FIN, Close Frame(10001000): $frameHead[0] = 136; break; case 'ping': // first byte indicates FIN, Ping frame (10001001): $frameHead[0] = 137; break; case 'pong': // first byte indicates FIN, Pong frame (10001010): $frameHead[0] = 138; break; } // set mask and payload length (using 1, 3 or 9 bytes) if ($payloadLength &gt; 65535) { $payloadLengthBin = str_split(sprintf('%064b', $payloadLength), 8); $frameHead[1] = ($masked === true) ? 255 : 127; for ($i = 0; $i &lt; 8; $i++) { $frameHead[$i + 2] = bindec($payloadLengthBin[$i]); } // most significant bit MUST be 0 if ($frameHead[2] &gt; 127) { return array('type' =&gt; '', 'payload' =&gt; '', 'error' =&gt; 'frame too large (1004)'); } } elseif ($payloadLength &gt; 125) { $payloadLengthBin = str_split(sprintf('%016b', $payloadLength), 8); $frameHead[1] = ($masked === true) ? 254 : 126; $frameHead[2] = bindec($payloadLengthBin[0]); $frameHead[3] = bindec($payloadLengthBin[1]); } else { $frameHead[1] = ($masked === true) ? $payloadLength + 128 : $payloadLength; } // convert frame-head to string: foreach (array_keys($frameHead) as $i) { $frameHead[$i] = chr($frameHead[$i]); } if ($masked === true) { // generate a random mask: $mask = array(); for ($i = 0; $i &lt; 4; $i++) { $mask[$i] = chr(rand(0, 255)); } $frameHead = array_merge($frameHead, $mask); } $frame = implode('', $frameHead); // append payload to frame: for ($i = 0; $i &lt; $payloadLength; $i++) { $frame .= ($masked === true) ? $payload[$i] ^ $mask[$i % 4] : $payload[$i]; } return $frame; } function decode($data) { $unmaskedPayload = ''; $decodedData = array(); // estimate frame type: $firstByteBinary = sprintf('%08b', ord($data[0])); $secondByteBinary = sprintf('%08b', ord($data[1])); $opcode = bindec(substr($firstByteBinary, 4, 4)); $isMasked = ($secondByteBinary[0] == '1') ? true : false; $payloadLength = ord($data[1]) &amp; 127; // unmasked frame is received: if (!$isMasked) { return array('type' =&gt; '', 'payload' =&gt; '', 'error' =&gt; 'protocol error (1002)'); } switch ($opcode) { // text frame: case 1: $decodedData['type'] = 'text'; break; case 2: $decodedData['type'] = 'binary'; break; // connection close frame: case 8: $decodedData['type'] = 'close'; break; // ping frame: case 9: $decodedData['type'] = 'ping'; break; // pong frame: case 10: $decodedData['type'] = 'pong'; break; default: return array('type' =&gt; '', 'payload' =&gt; '', 'error' =&gt; 'unknown opcode (1003)'); } if ($payloadLength === 126) { $mask = substr($data, 4, 4); $payloadOffset = 8; $dataLength = bindec(sprintf('%08b', ord($data[2])) . sprintf('%08b', ord($data[3]))) + $payloadOffset; } elseif ($payloadLength === 127) { $mask = substr($data, 10, 4); $payloadOffset = 14; $tmp = ''; for ($i = 0; $i &lt; 8; $i++) { $tmp .= sprintf('%08b', ord($data[$i + 2])); } $dataLength = bindec($tmp) + $payloadOffset; unset($tmp); } else { $mask = substr($data, 2, 4); $payloadOffset = 6; $dataLength = $payloadLength + $payloadOffset; } /** * We have to check for large frames here. socket_recv cuts at 1024 bytes * so if websocket-frame is &gt; 1024 bytes we have to wait until whole * data is transferd. */ if (strlen($data) &lt; $dataLength) { return false; } if ($isMasked) { for ($i = $payloadOffset; $i &lt; $dataLength; $i++) { $j = $i - $payloadOffset; if (isset($data[$i])) { $unmaskedPayload .= $data[$i] ^ $mask[$j % 4]; } } $decodedData['payload'] = $unmaskedPayload; } else { $payloadOffset = $payloadOffset - 4; $decodedData['payload'] = substr($data, $payloadOffset); } return $decodedData; } // : function onOpen($connect, $info) { echo "open\n"; fwrite($connect, encode('')); } function onClose($connect) { echo "close\n"; } function onMessage($connect, $data) { echo decode($data)['payload'] . "\n"; }</span></span></code> </pre><br></div></div><br><br>  In the given example, you can change user scripts onOpen, onClose and onMessage to implement the necessary functionality. <br><br>  The goals are achieved. <br>  If this material seems interesting to you, then in the next article I will describe how you can run several processes to handle connections (one master and several workers), interprocess communication, integration with your framework using the example of the yii component. <br><br>  <a href="http://sharoid.ru/chat.html">demo chat with the above functions</a> <br><br><div class="spoiler">  <b class="spoiler_title">Demo chat code</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env php &lt;?php class WebsocketServer { public function __construct($config) { $this-&gt;config = $config; } public function start() { //   $server = stream_socket_server("tcp://{$this-&gt;config['host']}:{$this-&gt;config['port']}", $errorNumber, $errorString); if (!$server) { die("error: stream_socket_server: $errorString ($errorNumber)\r\n"); } list($pid, $master, $workers) = $this-&gt;spawnWorkers();//   if ($pid) {// fclose($server);//         $WebsocketMaster = new WebsocketMaster($workers);//      $WebsocketMaster-&gt;start(); } else {// $WebsocketHandler = new WebsocketHandler($server, $master); $WebsocketHandler-&gt;start(); } } protected function spawnWorkers() { $master = null; $workers = array(); $i = 0; while ($i &lt; $this-&gt;config['workers']) { $i++; //  ,        $pair = stream_socket_pair(STREAM_PF_UNIX, STREAM_SOCK_STREAM, STREAM_IPPROTO_IP); $pid = pcntl_fork();//  if ($pid == -1) { die("error: pcntl_fork\r\n"); } elseif ($pid) { // fclose($pair[0]); $workers[$pid] = $pair[1];//      } else { // fclose($pair[1]); $master = $pair[0];//   break; } } return array($pid, $master, $workers); } } class WebsocketMaster { protected $workers = array(); protected $clients = array(); public function __construct($workers) { $this-&gt;clients = $this-&gt;workers = $workers; } public function start() { while (true) { //   ,    $read = $this-&gt;clients; stream_select($read, $write, $except, null);//  ,    if ($read) {//     foreach ($read as $client) { $data = fread($client, 1000); if (!$data) { //   unset($this-&gt;clients[intval($client)]); @fclose($client); continue; } foreach ($this-&gt;workers as $worker) {//     if ($worker !== $client) { fwrite($worker, $data); } } } } } } } abstract class WebsocketWorker { protected $clients = array(); protected $server; protected $master; protected $pid; protected $handshakes = array(); protected $ips = array(); public function __construct($server, $master) { $this-&gt;server = $server; $this-&gt;master = $master; $this-&gt;pid = posix_getpid(); } public function start() { while (true) { //   ,    $read = $this-&gt;clients; $read[] = $this-&gt;server; $read[] = $this-&gt;master; $write = array(); if ($this-&gt;handshakes) { foreach ($this-&gt;handshakes as $clientId =&gt; $clientInfo) { if ($clientInfo) { $write[] = $this-&gt;clients[$clientId]; } } } stream_select($read, $write, $except, null);//  ,    if (in_array($this-&gt;server, $read)) { //        //     ,    if ($client = stream_socket_accept($this-&gt;server, -1)) { $address = explode(':', stream_socket_get_name($client, true)); if (isset($this-&gt;ips[$address[0]]) &amp;&amp; $this-&gt;ips[$address[0]] &gt; 5) {//      ip @fclose($client); } else { @$this-&gt;ips[$address[0]]++; $this-&gt;clients[intval($client)] = $client; $this-&gt;handshakes[intval($client)] = array();//,     } } //    ,          unset($read[array_search($this-&gt;server, $read)]); } if (in_array($this-&gt;master, $read)) { //    $data = fread($this-&gt;master, 1000); $this-&gt;onSend($data);//   //   ,          unset($read[array_search($this-&gt;master, $read)]); } if ($read) {//     foreach ($read as $client) { if (isset($this-&gt;handshakes[intval($client)])) { if ($this-&gt;handshakes[intval($client)]) {//       continue;//            } if (!$this-&gt;handshake($client)) { unset($this-&gt;clients[intval($client)]); unset($this-&gt;handshakes[intval($client)]); $address = explode(':', stream_socket_get_name($client, true)); if (isset($this-&gt;ips[$address[0]]) &amp;&amp; $this-&gt;ips[$address[0]] &gt; 0) { @$this-&gt;ips[$address[0]]--; } @fclose($client); } } else { $data = fread($client, 1000); if (!$data) { //   unset($this-&gt;clients[intval($client)]); unset($this-&gt;handshakes[intval($client)]); $address = explode(':', stream_socket_get_name($client, true)); if (isset($this-&gt;ips[$address[0]]) &amp;&amp; $this-&gt;ips[$address[0]] &gt; 0) { @$this-&gt;ips[$address[0]]--; } @fclose($client); $this-&gt;onClose($client);//   continue; } $this-&gt;onMessage($client, $data);//   } } } if ($write) { foreach ($write as $client) { if (!$this-&gt;handshakes[intval($client)]) {//        continue;//      } $info = $this-&gt;handshake($client); $this-&gt;onOpen($client, $info);//   } } } } protected function handshake($client) { $key = $this-&gt;handshakes[intval($client)]; if (!$key) { //    $headers = fread($client, 10000); preg_match("/Sec-WebSocket-Key: (.*)\r\n/", $headers, $match); if (empty($match[1])) { return false; } $key = $match[1]; $this-&gt;handshakes[intval($client)] = $key; } else { //     $SecWebSocketAccept = base64_encode(pack('H*', sha1($key . '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'))); $upgrade = "HTTP/1.1 101 Web Socket Protocol Handshake\r\n" . "Upgrade: websocket\r\n" . "Connection: Upgrade\r\n" . "Sec-WebSocket-Accept:$SecWebSocketAccept\r\n\r\n"; fwrite($client, $upgrade); unset($this-&gt;handshakes[intval($client)]); } return $key; } protected function encode($payload, $type = 'text', $masked = false) { $frameHead = array(); $payloadLength = strlen($payload); switch ($type) { case 'text': // first byte indicates FIN, Text-Frame (10000001): $frameHead[0] = 129; break; case 'close': // first byte indicates FIN, Close Frame(10001000): $frameHead[0] = 136; break; case 'ping': // first byte indicates FIN, Ping frame (10001001): $frameHead[0] = 137; break; case 'pong': // first byte indicates FIN, Pong frame (10001010): $frameHead[0] = 138; break; } // set mask and payload length (using 1, 3 or 9 bytes) if ($payloadLength &gt; 65535) { $payloadLengthBin = str_split(sprintf('%064b', $payloadLength), 8); $frameHead[1] = ($masked === true) ? 255 : 127; for ($i = 0; $i &lt; 8; $i++) { $frameHead[$i + 2] = bindec($payloadLengthBin[$i]); } // most significant bit MUST be 0 if ($frameHead[2] &gt; 127) { return array('type' =&gt; '', 'payload' =&gt; '', 'error' =&gt; 'frame too large (1004)'); } } elseif ($payloadLength &gt; 125) { $payloadLengthBin = str_split(sprintf('%016b', $payloadLength), 8); $frameHead[1] = ($masked === true) ? 254 : 126; $frameHead[2] = bindec($payloadLengthBin[0]); $frameHead[3] = bindec($payloadLengthBin[1]); } else { $frameHead[1] = ($masked === true) ? $payloadLength + 128 : $payloadLength; } // convert frame-head to string: foreach (array_keys($frameHead) as $i) { $frameHead[$i] = chr($frameHead[$i]); } if ($masked === true) { // generate a random mask: $mask = array(); for ($i = 0; $i &lt; 4; $i++) { $mask[$i] = chr(rand(0, 255)); } $frameHead = array_merge($frameHead, $mask); } $frame = implode('', $frameHead); // append payload to frame: for ($i = 0; $i &lt; $payloadLength; $i++) { $frame .= ($masked === true) ? $payload[$i] ^ $mask[$i % 4] : $payload[$i]; } return $frame; } protected function decode($data) { $unmaskedPayload = ''; $decodedData = array(); // estimate frame type: $firstByteBinary = sprintf('%08b', ord($data[0])); $secondByteBinary = sprintf('%08b', ord($data[1])); $opcode = bindec(substr($firstByteBinary, 4, 4)); $isMasked = ($secondByteBinary[0] == '1') ? true : false; $payloadLength = ord($data[1]) &amp; 127; // unmasked frame is received: if (!$isMasked) { return array('type' =&gt; '', 'payload' =&gt; '', 'error' =&gt; 'protocol error (1002)'); } switch ($opcode) { // text frame: case 1: $decodedData['type'] = 'text'; break; case 2: $decodedData['type'] = 'binary'; break; // connection close frame: case 8: $decodedData['type'] = 'close'; break; // ping frame: case 9: $decodedData['type'] = 'ping'; break; // pong frame: case 10: $decodedData['type'] = 'pong'; break; default: return array('type' =&gt; '', 'payload' =&gt; '', 'error' =&gt; 'unknown opcode (1003)'); } if ($payloadLength === 126) { $mask = substr($data, 4, 4); $payloadOffset = 8; $dataLength = bindec(sprintf('%08b', ord($data[2])) . sprintf('%08b', ord($data[3]))) + $payloadOffset; } elseif ($payloadLength === 127) { $mask = substr($data, 10, 4); $payloadOffset = 14; $tmp = ''; for ($i = 0; $i &lt; 8; $i++) { $tmp .= sprintf('%08b', ord($data[$i + 2])); } $dataLength = bindec($tmp) + $payloadOffset; unset($tmp); } else { $mask = substr($data, 2, 4); $payloadOffset = 6; $dataLength = $payloadLength + $payloadOffset; } /** * We have to check for large frames here. socket_recv cuts at 1024 bytes * so if websocket-frame is &gt; 1024 bytes we have to wait until whole * data is transferd. */ if (strlen($data) &lt; $dataLength) { return false; } if ($isMasked) { for ($i = $payloadOffset; $i &lt; $dataLength; $i++) { $j = $i - $payloadOffset; if (isset($data[$i])) { $unmaskedPayload .= $data[$i] ^ $mask[$j % 4]; } } $decodedData['payload'] = $unmaskedPayload; } else { $payloadOffset = $payloadOffset - 4; $decodedData['payload'] = substr($data, $payloadOffset); } return $decodedData; } abstract protected function onOpen($client, $info); abstract protected function onClose($client); abstract protected function onMessage($client, $data); abstract protected function onSend($data); abstract protected function send($data); } //   class WebsocketHandler extends WebsocketWorker { protected function onOpen($client, $info) {//      } protected function onClose($client) {//     } protected function onMessage($client, $data) {//      $data = $this-&gt;decode($data); if (!$data['payload']) { return; } if (!mb_check_encoding($data['payload'], 'utf-8')) { return; } //var_export($data); //  ,  ,      $message = ' #' . intval($client) . ' (' . $this-&gt;pid . '): ' . strip_tags($data['payload']); $this-&gt;send($message); $this-&gt;sendHelper($message); } protected function onSend($data) {//      $this-&gt;sendHelper($data); } protected function send($message) {//   ,        @fwrite($this-&gt;master, $message); } private function sendHelper($data) { $data = $this-&gt;encode($data); $write = $this-&gt;clients; if (stream_select($read, $write, $except, 0)) { foreach ($write as $client) { @fwrite($client, $data); } } } } $config = array( 'host' =&gt; '0.0.0.0', 'port' =&gt; 8000, 'workers' =&gt; 1, ); $WebsocketServer = new WebsocketServer($config); $WebsocketServer-&gt;start();</span></span></code> </pre><br></div></div><br><h4>  Update (best of comments): </h4><br><ul><li>  one connection takes about 9kb of memory </li><li>  If you use <code>fgets()</code> when working with open sockets, you can get a "hang" (the function will wait for the end of the line or timeout), because the message does not end with a line break according to the web socket protocol.  use <code>fread()</code> </li><li>  when writing a response to the socket with the <code>fwrite()</code> function (the function returns the number of bytes written), it is necessary to check that all data has been written to the socket </li><li>  when responding from the server, you need to check the client's readiness to receive data using the <code>stream_socket_accept()</code> function </li><li>  if on the server to write characters to the socket that are missing in utf-8, then the client will disconnect the connection with an error: <br> <code>WebSocket connection to 'ws://sharoid.ru:8000/' failed: Could not decode a text frame as UTF-8.</code> </li> <li>  when checking that the client has not sent any data and need to close the socket, use <code>!strlen($data)</code> , and not <code>!$data</code> </li><li>  nginx <a href="http://habrahabr.ru/post/171757/">can be placed</a> in front of the webbox server </li></ul><br>  <b>The second part of the article: <a href="http://habrahabr.ru/company/ifree/blog/210228/">IPC.</a></b>  <b><a href="http://habrahabr.ru/company/ifree/blog/210228/">Interprocess communication</a></b> <br>  <b>The third part of the article: <a href="http://habrahabr.ru/company/ifree/blog/211504/">From chat to game: Battle City</a></b> <br>  <a href="https://github.com/morozovsk/websocket">The source code of the library and examples is on github and is available under the MIT license.</a> </div><p>Source: <a href="https://habr.com/ru/post/209864/">https://habr.com/ru/post/209864/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209850/index.html">Scala. Everyone out of the twilight!</a></li>
<li><a href="../209852/index.html">As we on the enthusiasm of automators trained</a></li>
<li><a href="../209854/index.html">Nest Protect: New Product Review</a></li>
<li><a href="../209856/index.html">Windows Azure Certification: PCI DSS Compliance and ISO Extension</a></li>
<li><a href="../209862/index.html">A week of free online Windows Azure courses, registration is open</a></li>
<li><a href="../209866/index.html">Super successful companies</a></li>
<li><a href="../209868/index.html">Developers can now easily integrate video calls into their web and mobile applications.</a></li>
<li><a href="../209870/index.html">UNIX_TIMESTAMP, ROUND and other DQL queries via queryBuilder in Symfony 2</a></li>
<li><a href="../209874/index.html">Facebook expands its ‚Äúarctic‚Äù data center in Lulea</a></li>
<li><a href="../209876/index.html">How can you make java better</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>