<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Increment in php</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Take a variable and increase it by 1. It sounds easy, right? Well ... From the point of view of a PHP developer, probably, yes. But is it really? Ther...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Increment in php</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/073/a91/045/073a910459ba4b998fd60ae7d559c160.jpg"><br><br>  Take a variable and increase it by 1. It sounds easy, right?  Well ... From the point of view of a PHP developer, probably, yes.  But is it really?  There may be some difficulties.  There are several ways to increment values, they may look equivalent, but under the hood PHP works differently, which can lead to, so to speak, interesting results. <br><a name="habracut"></a><br>  Consider three examples of adding a unit to a variable: <br><br><pre><code class="php hljs">$a = <span class="hljs-number"><span class="hljs-number">1</span></span>; $a++; <span class="hljs-comment"><span class="hljs-comment">#    var_dump($a); $b = 1; $b += 1; #    var_dump($b); $c = 1; $c = $c + 1; #    var_dump($c);</span></span></code> </pre> <br>  The code is different, but in each case the value of the variable increases.  And what will be the result? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="php hljs">int(<span class="hljs-number"><span class="hljs-number">2</span></span>) int(<span class="hljs-number"><span class="hljs-number">2</span></span>) int(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  Intuitively, all three methods look the same.  That is, for incrementing, you can use both <code>$a++</code> and <code>$a += 1</code> .  But let's look at another example: <br><br><pre> <code class="php hljs">$a = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; $a++; var_dump($a); $a = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; $a += <span class="hljs-number"><span class="hljs-number">1</span></span>; var_dump($a); $a = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; $a = $a + <span class="hljs-number"><span class="hljs-number">1</span></span>; var_dump($a); string(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-string"><span class="hljs-string">"fop"</span></span> int(<span class="hljs-number"><span class="hljs-number">1</span></span>) int(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  Surely many of you did not expect such a result!  Maybe someone already knew that adding to a string variable leads to a change in the character set, but two <code>int(1)</code> ?  Where did they come from?  From the point of view of a PHP developer, this looks very inconsistent, and it turns out that our three ways of incrementing are unequal.  Let's see what happens in the depths of PHP when executing code. <br><br><h1>  Bytecode </h1><br>  During the PHP script startup, your code is first compiled into an intermediate format - byte code.  This fact refutes the view that PHP is a truly interpreted language - it interprets bytecode, not PHP source code. <br><br>  The above code is converted to this <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B0%25D0%25B9%25D1%2582-%25D0%25BA%25D0%25BE%25D0%25B4">byte code</a> : <br><br><pre> <code class="bash hljs">compiled vars: !0 = <span class="hljs-variable"><span class="hljs-variable">$a</span></span>, !1 = <span class="hljs-variable"><span class="hljs-variable">$b</span></span>, !2 = <span class="hljs-variable"><span class="hljs-variable">$c</span></span> line <span class="hljs-comment"><span class="hljs-comment">#* EIO op fetch ext return operands --------------------------------------------------------------------------- 3 0 E &gt; ASSIGN !0, 1 4 1 POST_INC ~1 !0 2 FREE ~1 5 3 SEND_VAR !0 4 DO_FCALL 1 'var_dump' 7 5 ASSIGN !1, 1 8 6 ASSIGN_ADD 0 !1, 1 9 7 SEND_VAR !1 8 DO_FCALL 1 'var_dump' 11 9 ASSIGN !2, 1 12 10 ADD ~7 !2, 1 11 ASSIGN !2, ~7 13 12 SEND_VAR !2 13 DO_FCALL 1 'var_dump' 14 &gt; RETURN 1</span></span></code> </pre><br>  You can easily create such opcodes yourself using the <a href="http://derickrethans.nl/projects.html">VLD debugger</a> or the online service <a href="http://3v4l.org/">3v4l.org</a> .  Do not think about what it all means.  If you get rid of uninteresting things, then only these lines will remain: <br><br><pre> <code class="php hljs">compiled vars: !<span class="hljs-number"><span class="hljs-number">0</span></span> = $a, !<span class="hljs-number"><span class="hljs-number">1</span></span> = $b, !<span class="hljs-number"><span class="hljs-number">2</span></span> = $c line <span class="hljs-comment"><span class="hljs-comment">#* EIO op fetch ext return operands --------------------------------------------------------------------------- 4 1 POST_INC ~1 !0 2 FREE ~1 8 6 ASSIGN_ADD 0 !1, 1 12 10 ADD ~7 !2, 1 11 ASSIGN !2, ~7</span></span></code> </pre><br>  Thus, <code>$a++</code> turns into two opcodes ( <code>POST_INC  FREE</code> ), <code>$a += 1</code> - into one ( <code>ASSIGN_ADD</code> ) and <code>$a = $a + 1</code> too, into two.  Please note that in all three cases, different opcodes are obtained, which already implies a different execution of PHP. <br><br><h1>  Unary increment operator </h1><br>  Consider the first method of incrementing - the unary operator ( <code>$a++</code> ).  This PHP code is converted to the <code>POST_INC</code> opcode.  By the way, <code>PRE_INC</code> obtained from <code>++$a</code> , and you need to know the difference between them.  The second opcode, <code>FREE</code> , clears the result after <code>POST_INC</code> , because we do not use its return value: <code>POST_INC</code> changes the current operand in place.  In this case, you can ignore this opcode. <br><br>  The reason for the difference in the performance of these opcodes lies in the file <code>zend_vm_def.h</code> , which you can find in the source C code of PHP.  This is a large header file filled with macros, so it is not so easy to read, even if you know C. When you call the POST_INC <code>POST_INC</code> , the contents of <a href="">line 971 are</a> executed. <br><br>  In short, this is what happens: <br><br><ul><li>  It is checked whether the variable ( <code>$a</code> in the PHP code, which in the byte code turns into <code>!0</code> ) belongs to the type <code>long</code> .  In essence, the system checks whether the variable contains a number.  Although PHP is a language with dynamic typing, each variable still belongs to some ‚Äútype‚Äù.  Types may change, as we will see later.  If our variable belongs to <code>long</code> , then the C-function <code>fast_increment_function()</code> is <code>fast_increment_function()</code> and the return to the next opcode occurs. </li><li>  If the variable is non-numeric, then basic checks for the possibility of incrementing are performed.  For example, this cannot be done with string offsets <code>$a = "foobar"</code> ;  <code>$a[2]++</code> , we get an error. </li><li>  Next, it is checked whether a variable is a non-existent property of an object that has <code>__get</code> and <code>__set</code> magic PHP methods.  If so, then the correct value is retrieved using <code>__get</code> , <code>fast_increment_function()</code> is <code>fast_increment_function()</code> and the value is saved by calling the <code>__set</code> method.  These methods are called from C, not from PHP. </li><li>  Finally, if a variable is not a property, then <code>increment_function()</code> is simply called. </li></ul><br>  As you can see, the process of adding a number depends on the type of the variable.  If this number is, then surely everything will be reduced to a call to <code>fast_increment_function</code> , and if this is a magic property, then to a call to <code>increment_function()</code> .  Below we talk about the operation of these functions. <br><br><h1>  fast_increment_function () </h1><br>  The <code>fast_increment_function()</code> function belongs to <a href="">zend-operators</a> , and its task is to accelerate a specific variable as quickly as possible. <br><br>  If the variable is of the <code>long</code> type, then a very fast assembly language is used to increment it.  If the value has reached the maximum number of type INT ( <code>LONG_MAX</code> ), then the variable is automatically converted to double ( <code>double</code> ).  This is the fastest way to increase the number, since this part of the code is written in assembler.  It is believed that the compiler can not optimize the C-code better than the assembler.  But the method only works if the variable is of type <code>long</code> .  Otherwise, the function will be redirected to the <code>increment_function()</code> function.  Since incrementing (and decrementing) is most often done in very small inner loops (for example, <code>for</code> ), you need to do this as quickly as possible in order to maintain high PHP performance. <br><br><h1>  increment_function () </h1><br>  If <code>fast_increment_function()</code> is a fast way to increment a number, then <code>increment_function</code> is a slow ( <code>slow</code> ) way.  The process scenario also depends on the type of the variable. <br><br><ul><li>  If the variable is of the <code>long</code> type, then the number simply increases (and is converted to <code>double</code> when the maximum value is reached, which can no longer be stored in <code>long</code> ).  Most often this will be done with the help of <code>fast_increment_function</code> , but it may happen that <code>long</code> will be transferred to this function anyway, so a check is necessary here. </li><li>  If the variable is of type <code>double</code> , then it simply increases. </li><li>  If the variable is <code>NULL</code> , then <code>long 1</code> always returned. </li><li>  If the variable is of type <code>string</code> , then the magic described above is applied. </li><li>  If the variable is an object and has the functionality of the <code>internal</code> operator, then the <code>add</code> operator is called to add <code>long 1</code> .  Note that this only works for the <code>internal</code> classes that manually define these operator functions; you cannot define object operators in the user space PHP code.  It implements a single class in the source PHP code - <code>GMP</code> .  So you can make <code>$a = new gmp(1) + new gmp(3); // gmp(4)</code>  <code>$a = new gmp(1) + new gmp(3); // gmp(4)</code> .  Such an opportunity appeared since PHP 5.6, but operator overloading is impossible in PHP directly. </li><li>  If the variable is of some other type, then it cannot be incremented and the failure code is returned. </li></ul><br>  So, the system checks different types.  Note: there is no check here, say, to a boolean value, this suggests that such a type cannot be incremented. <code>$a = false; $a++</code>  <code>$a = false; $a++</code> not only will not work, but even the error will not return.  The variable simply does not change, but remains <code>false</code> . <br><br><h1>  String increment </h1><br>  And now the funny thing.  Working with strings is always full of nuances, but in this case, that's what happens. <br><br>  First, it checks if the string contains a number.  For example, string 123 contains the number 123. Such a ‚Äústring number‚Äù will be converted to a normal number of type <code>long (int(123)</code> ).  When converting, several tricks are used: <br><br><ul><li>  Spaces are removed. </li><li>  Hexadecimal numbers ( <code>0x123</code> ) are supported. </li><li>  Octal and binary numbers ( <code>0123</code> and <code>b11</code> ) are not supported. </li><li>  Supported scientific presentation ( <code>1E5</code> ). </li><li>  Supported <code>double</code> . </li><li>  The parts that are at the beginning or at the end of the string ( <code>135abc</code> or <code>ab123</code> ) are not supported and are not considered to be numbers. </li></ul><br>  If the result is a <code>long</code> or <code>double</code> , the number simply increases.  For example, if we take the string 123 and increment, we get an <code>int(124)</code> .  Note that the variable type changes from string to integer! <br><br>  If the string cannot be converted to <code>long</code> or <code>double</code> , then the function <code>increment_string()</code> called. <br><br><h1>  increment_string () </h1><br>  PHP uses a perl-like increment system.  If the string is empty, then it simply returns <code>string("1")</code> .  Otherwise, the carry system is used to increment the string. <br><br>  We start at the <b>end of the</b> variable.  If the character is from <code>a</code> to <code>z</code> , then it is incremented ( <code>a</code> becomes <code>b</code> , and so on).  If the character is <code>z</code> , then it changes to <code>a</code> and is ‚Äútransferred‚Äù one position <b>ahead of the</b> current one. <br><br>  That is: <code>a</code> becomes <code>b</code> , <code>ab</code> becomes <code>ac</code> (transfer is not needed), <code>az</code> becomes <code>ba</code> ( <code>z</code> becomes <code>a</code> , <code>a</code> becomes <code>b</code> , because we carry one character). <br><br>  The same applies to uppercase characters from <code>A</code> to <code>Z</code> , as well as to numbers from <code>0</code> to <code>9</code> .  When incrementing <code>9</code> turns into <code>0</code> and is transferred to the previous position. <br><br>  If we have reached the beginning of a string variable and need to make a transfer, then just one more character is added <b>BEFORE the</b> entire string.  The type is the same as that of the portable character: <br><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"z"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"aa"</span></span> <span class="hljs-string"><span class="hljs-string">"9"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"00"</span></span> <span class="hljs-string"><span class="hljs-string">"Zz"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"AAa"</span></span> <span class="hljs-string"><span class="hljs-string">"9z"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"10a"</span></span></code> </pre><br>  So when incrementing a string, you cannot change the type of each character.  If it was in lower case, then it will remain in it. <br><br>  But be careful if you increment the ‚Äúnumber in the string‚Äù several times. <br><br>  Incrementing <code>string("2D9")</code> will <code>string("2D9")</code> <code>string("2E0")</code> ( <code>string("2D9"</code> ) is not a number, so the usual string will be incremented).  But when <code>string("2E0")</code> incremented, you already get <code>double(3)</code> , because <code>2E0</code> is a scientific representation <code>2</code> and it will be converted to <code>double</code> , which can then be incremented to 3. So be careful with the increment cycles! <br><br>  This string incrementing system also explains why we can increment ‚ÄúZ‚Äù to ‚ÄúAA‚Äù, but cannot decrement ‚ÄúAA‚Äù back to ‚ÄúZ‚Äù.  Only the last ‚ÄúA‚Äù character is decremented, but what to do with the first one?  Should it also be decremented to ‚ÄúZ‚Äù with the help of (negative) transfer?  What about ‚Äú0A‚Äù?  Should it be <code>Z</code> ?  And if so, then with the new increment we will get <code>AA</code> .  In other words, we cannot simply remove characters during decrementing, as we add them when incrementing. <br><br><h1>  Summing Assignment Operator </h1><br>  We now consider the second example from the beginning of the paper ‚Äî the summing assignment operator ( <code>$a += 1</code> ).  It looks similar to the unary increment operator, but behaves differently in terms of the generated opcodes and actual execution.  The expression is fully processed using <a href="">zend_binary_assign_op_helper</a> , which, after a series of checks, calls <a href="">add_function</a> with two operands: <code>$a</code> and our <code>int(1)</code> value. <br><br><h1>  add_function () </h1><br>  The <code>add_function</code> method works differently depending on the types of variables.  For the most part, it consists of checking the types of operands: <br><br><ul><li>  If they both belong to <code>long</code> , then their values ‚Äã‚Äãsimply increase (when overflow is converted to <code>double</code> ). </li><li>  If one is <code>long</code> and the second is <code>double</code> , then both are converted to <code>double</code> and incremented. </li><li>  If they both belong to <code>double</code> , then they are simply added together. </li><li>  If both are arrays, they will be combined based on the keys: <code>$a = [ 'a', 'b' ] + [ 'c', 'd' ];</code>  .  It will turn out <code>[ 'a', 'b']</code> , as if they combined the second array, but they had the same keys.  Note that the union is not on the values, but on the keys. </li><li>  If the operands are objects, then it is checked whether the first of them has an internal operator functionality (as is the case with the <code>increment_function()</code> method).  You can't do this in PHP yourself, this is only supported by internal classes like GMP. </li></ul><br>  If the operands are of some other type (for example, <code>string + long</code> ), then using the <code>zendi_convert_scalar_to_number</code> method, both of them will be converted to scalars.  After the conversion, the <code>add_function</code> function will be applied <code>add_function</code> , and this time a match will probably be found for one of the described pairs. <br><br><h1>  zendi_convert_scalar_to_number () </h1><br>  The conversion of a scalar to a number depends on the type of scalar.  It usually comes down to one of the following algorithms: <br><br><ul><li>  If the scalar is a string, then using <code>is_numeric_string</code> check if it contains a number.  If not, an <code>int(0)</code> returned. </li><li>  If the scalar is <code>null</code> or boolean <code>false</code> , then <code>int(0)</code> returned. </li><li>  If the scalar is boolean <code>true</code> , then <code>int(1)</code> returned. </li><li>  If the scalar is a resource, then the numeric value of the resource number is returned. </li><li>  If a scalar is an object, then an attempt is made to convert it to <code>long</code> (as is the case with internal operators, there may be internal cast functionality, but it is not always implemented and is available only for main classes, and not for PHP- classes in user space). </li></ul><br><h1>  Sum statement </h1><br>  This is the easiest of all three options.  When it is executed, the <code>fast_add_function()</code> function is <code>fast_add_function()</code> .  Like <code>fast_increment_function()</code> , it directly uses the assembler code to increment numbers if both operands are <code>long</code> or <code>double</code> .  If this is not the case, then the function is redirected to the <code>add_function()</code> function used by the assignment expression. <br><br>  Since both the addition operator and the summing assignment operator use the same basic functionality, <code>$a = $a + 1  $a += 1</code> work the same way.  The only difference is that the addition operator CAN execute quickly if both operands are <code>long</code> or <code>double</code> .  So if you want to micro-optimize, <code>$a = $a + 1</code> will work faster than <code>$a += 1</code> .  Not only thanks to <code>fast_add_function()</code> , but also because we don‚Äôt need to process additional bytecode to save the results back to <code>$a</code> . <br><br><h1>  Conclusion </h1><br>  Incrementing a value is different from simple addition: <code>add_function</code> converts types to compatible pairs, and <code>increment_function</code> does not.  Now we can explain the results obtained: <br><br><pre> <code class="php hljs">$a = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; $a++; var_dump($a); <span class="hljs-comment"><span class="hljs-comment">// bool(false) $a = false; $a += 1; var_dump($a); // int(1) $a = false; $a = $a + 1; var_dump($a); // int(1)</span></span></code> </pre><br>  Since the <code>increment_function</code> does not convert a boolean value (this is not a number or a string that can be converted to a number), a silent failure occurs and the value is not incremented.  Therefore, it remains a <code>bool(false)</code> .  In the case of <code>add_function</code> , an attempt is made to find a matching pair of <code>boolean</code> and <code>long</code> , which does not exist.  As a result, both values ‚Äã‚Äãare converted to <code>long</code> : <code>bool(false)</code> becomes <code>int(0)</code> , and <code>int(1)</code> remains <code>int(1)</code> .  Now we have a pair of <code>long</code> &amp; <code>long</code> , so <code>add_function</code> simply summarizes them and it turns out <code>int(1)</code> .  (Question: what will the boolean <code>true</code> + <code>int(1)</code> turn into?) <br><br>  We can also explain another oddity: <br><br><pre> <code class="php hljs">$a = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>; $a++; var_dump($a); <span class="hljs-comment"><span class="hljs-comment">// string("fop") $a = "foo"; $a += 1; var_dump($a); // int(1) $a = "foo"; $a = $a + 1; var_dump($a); // int(1)</span></span></code> </pre><br>  Since the string cannot be converted to a number, the usual incrementing of the string is performed.  The add expression converts the strings to <code>long</code> after checking for the presence of numbers.  Since there are none, then the string is converted to <code>int(0)</code> and <code>int(1)</code> added to it. </div><p>Source: <a href="https://habr.com/ru/post/305906/">https://habr.com/ru/post/305906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305892/index.html">Modal windows on Angular, Angular 2 and ReactJS</a></li>
<li><a href="../305894/index.html">JIT compiler optimizes not cool, but very cool</a></li>
<li><a href="../305898/index.html">Cache, Hash and Nyash Mesh</a></li>
<li><a href="../305900/index.html">ES6 humanly</a></li>
<li><a href="../305904/index.html">Haordic Organization Visa (Part 4)</a></li>
<li><a href="../305908/index.html">"Closer to the people": Does the manager need to understand programming</a></li>
<li><a href="../305910/index.html">The evolution of mobile payments</a></li>
<li><a href="../305912/index.html">We prove the correctness of the search for the diameter of the tree</a></li>
<li><a href="../305916/index.html">Android and Data Binding: action handling</a></li>
<li><a href="../305918/index.html">Postfix Answering Machine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>