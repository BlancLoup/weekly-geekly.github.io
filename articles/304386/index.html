<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SObjectizer: what is it, what is it for and why does it look that way?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Developing multithreaded C ++ programs is not easy. Developing large multi-threaded programs in C ++ is not very easy. But, as is usually the case in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SObjectizer: what is it, what is it for and why does it look that way?</h1><div class="post__text post__text-html js-mediator-article">  Developing multithreaded C ++ programs is not easy.  Developing large multi-threaded programs in C ++ is not very easy.  But, as is usually the case in C ++, life is greatly simplified if you manage to pick up or make a tool ‚Äúsharpened‚Äù for a specific task.  Fourteen years ago, there was nothing particularly to choose from, so we made such a ‚Äúsharpened‚Äù instrument for ourselves and called it SObjectizer.  The experience of everyday use of SObjectizer in commercial software engineering does not yet allow regretting what has been done.  And if so, then why not try to talk about what it is, why it is and why we did it that way, and not otherwise ... <br><a name="habracut"></a><br><h4>  What is it? </h4><br>  <a href="https://sourceforge.net/projects/sobjectizer/">SObjectizer</a> is a small OpenSource tool, freely distributed under the 3-point BSD license.  The basic idea behind SObjectizer is the construction of an application from small entity agents that interact with each other through message exchange.  SObjectizer takes responsibility for: <br><ul><li>  message delivery to recipient agents within the same process; </li><li>  management of working threads on which agents process messages addressed to them; </li><li>  timers mechanism (in the form of deferred and periodic messages); </li><li>  the possibility of setting the parameters of the above mechanisms. </li></ul><br>  It can be said that SObjectizer is one of the implementations of the <a href="https://en.wikipedia.org/wiki/Actor_model">Actor Model</a> .  However, the main difference between SObjectizer and other similar developments is the combination of elements from the Actor Model with elements from other models, in particular, <a href="https://en.wikipedia.org/wiki/Publish%25E2%2580%2593subscribe_pattern">Publish-Subscribe</a> and <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a> . <br><br>  In the ‚Äúclassic‚Äù Actor Model, each actor is the immediate addressee in the send operation.  Those.  if we want to send a message to some actor, we must have a reference to the recipient actor or the id of this actor.  The send operation simply adds the message to the recipient's message queue. <br><br>  In SObjectizer, the send operation receives a link not to the actor, but to such a thing as the mbox (message box).  Mbox can be considered as a kind of proxy that hides the implementation of the message delivery procedure to the recipients.  There may be several such implementations, and they depend on the type of mbox.  If this is a multi-producer / single-consumer mbox, then, as in the ‚Äúclassic‚Äù Actor Model, the message will be delivered to a single recipient, the owner of the mbox.  But if this is a multi-producer / multi-consumer mbox, then the message will be delivered to all recipients who have subscribed to this mbox. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Those.  the send operation in SObjectizer is more like a publish operation from the Publish-Subscribe model than a send from the Actor Model.  The consequence of which is the availability of such practical opportunities in practice as broadcasting messages. <br><br>  The message delivery mechanism in SObjectizer is similar to the Publish-Subscribe model also by the subscription procedure.  If an agent wants to receive type A messages, then he should subscribe to type A messages from the corresponding mbox.  If he wants to receive messages of type B, he must subscribe to messages of type B. And so on.  At the same time, the message type plays the same role as the topic name in the Publish-Subscribe model.  Well, as in the Publish-Subscribe model, where the recipient can subscribe to any number of topics, an agent in SObjectizer can subscribe to any number of message types from different mboxes: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">example</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        //   mbox-. //        //  . so_subscribe(some_mbox) .event( &amp;example::first_handler ) .event( &amp;example::second_handler ) //        -. .event( []( const third_message &amp; msg ){...} ); //         //   mbox-. so_subscribe(another_mbox).event( &amp;example::first_handler ); so_subscribe(yet_another_mbox).event( &amp;example::first_handler ); ... } ... private : void first_handler( const first_message &amp; msg ) {...} void second_handler( const second_message &amp; msg ) {...} };</span></span></code> </pre> <br>  The next important difference between SObjectizer and other implementations of the ‚Äúclassic‚Äù Actor Model is that the agent does not have its own message queue in SObjectizer.  The message queue in SObjectizer belongs to the working context on which the agent is serviced.  And the working context is determined by the dispatcher to which the agent is attached. <br><br>  <a href="http://www.slideshare.net/YauheniAkhotnikau/dive-into-sobjectizer-55-eighth-part-dispatchers">A dispatcher</a> is one of the cornerstones in SObjectizer.  Dispatchers determine where and when agents will process their messages. <br><br>  The easiest dispatcher owns only one working thread.  All agents attached to such a dispatcher work on this common thread.  This thread owns one single message queue, and messages for all agents associated with the dispatcher are placed in this single queue.  The working thread takes the message from the queue, calls the message handler from the corresponding receiving agent, and then proceeds to the next message, etc. <br><br>  There are other types of dispatchers.  For example, dispatchers with workflow pools, dispatchers with agent priority support and different policies for handling these priorities, etc.  In all cases, the working context and message queue for the agent is assigned to the dispatcher to which the agent is associated. <br><br>  The next distinguishing feature of SObjectizer is the existence of such a thing as " <a href="http://www.slideshare.net/YauheniAkhotnikau/dive-into-sobjectizer-55-third-part-coops">agent cooperation</a> ".  A co-operation is a group of agents that jointly performs an applied task.  And these agents must begin and complete their work at the same time.  Those.  if any agent cannot start, then all other agents of cooperation will not start either.  If some agent cannot continue working, then all other agents of cooperation cannot continue their work. <br><br>  Cooperation appeared in SObjectizer because in a fair amount of cases, in order to perform more or less complex actions, it is necessary to create not one but several interconnected agents.  If you create them one by one, you need to decide, for example: <br><ul><li>  who starts first and in what order he creates the rest; </li><li>  how agents that have already started will determine that all other agents have already been created and can begin their work; </li><li>  what to do if there is a problem when starting the next agent. </li></ul><br>  In the case of cooperations, everything is simpler: interconnected agents are created all at once, are included in cooperation, and cooperation is registered in the SObjectizer.  And already SObjectizer itself ensures that the registration of cooperation is carried out transactionally (that is, that all agents of cooperation start, or that none start): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      3- : // -   TCP-  AMQP-   AMQP-; // -     . // -        // (      ); so_5::environment_t &amp; env = ...; //   ,     . //       , ,    // ,     SObjectizer-. auto coop = env.create_coop( so_5::autoname ); //  ... coop.make_agent&lt; amqp_client &gt;(...); coop.make_agent&lt; db_worker &gt;(...); coop.make_agent&lt; message_processor &gt;(...); //  . //       SObjectizer. env.register_coop( std::move(coop) );</span></span></code> </pre><br>  Partly cooperations solve the same problem <a href="http://erlang.org/doc/man/supervisor.html">as Erlang's supervisor system</a> : agents entering into cooperation are, as it were, under the control of the all-for-one supervisor.  Those.  Failure of one of the agents leads to deregistration of all other agents of cooperation. <br><br>  The next important feature of the SObjectizer is that the <a href="http://www.slideshare.net/YauheniAkhotnikau/dive-into-sobjectizer-55-second-part-states">agents in the SObjectizer are state machines</a> .  An agent can have an arbitrary number of states, one of which at a particular time is the current state.  The reaction of the agent to external influence depends on both the incoming message and the current state.  The agent can process the same message differently in different states, for which he signs different message handlers in each of the states. <br><br>  Agents in a SObjectizer can be quite complex finite automata: nesting of states, temporary constraints on the agent's stay in the state, states with deep and shallow-history, as well as state entry and exit handlers are supported. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">device_handler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     . //     ... state_t st_idle{ this }, st_activated{ this }, // ...   ,    //  st_activated. st_cmd_sent{ initial_substate_of{ st_activated } }, st_cmd_accepted{ substate_of{ st_activated } }, st_failure{ substate_of{ st_activated } }; ... public : virtual void so_define_agent() override { //     st_idle. st_idle.activate(); //      st_idle   //       st_activated. st_idle.transfer_to_state&lt; command &gt;( st_activated ); //   st_activated     : //   turn_off    st_idle. //      turn_off  //   . st_activated .event( [this](const turn_off &amp; msg) { turn_device_off(); st_idle.activate(); } ); //   st_cmd_sent ""    //   st_activated, .. st_cmd_sent   // . st_cmd_sent .event( [this](const command &amp; msg) { send_command_to_device(msg); // ,      150ms. send_delated&lt;check_status&gt;(*this, 150ms); } ) .event( [this](const check_status &amp;) { if(command_accepted()) st_cmd_accepted.activate(); else st_failure.activate(); } ); ... //   st_failure    50ms, //     st_idle. //        //  . st_failure .on_enter( [this]{ reset_device(); } ) .time_limit( 50ms, st_idle ); } ... };</span></span></code> </pre><br>  From a CSP model, SObjectizer borrowed such a thing as channels, which are called <a href="http://www.slideshare.net/YauheniAkhotnikau/dive-into-sobjectizer-55-ninth-part-message-chains">message chains</a> in SObjectizer.  CSP channels were added to SObjectizer as a tool to solve one specific problem: interaction between agents is built through message exchange, so it is very easy to give some command to the agent or send some information to the agent from any part of the application ‚Äî just send the message via send .  However, how can agents act on the non-SObjectizer part of the application? <br><br>  This problem is solved by message chains (mchains).  The message chain may look just like the mbox: you need to send messages to the mchain using all the same send-a.  But messages from the mchain functions of the receive and select functions are retrieved, for which you do not need to create SObjectizer agents. <br><br>  Working with the message chain in SObjectizer is similar to working with <a href="https://habrahabr.ru/post/278349/">channels in the Go language</a> .  Although there are serious differences: <br><ul><li>  SObjectizer mchains can simultaneously store messages of any type, while Go-shny channels are typed; </li><li>  In the go-shnoy select construct, you can use both send and receive operations.  Whereas in SObjectizer-ovsky select, only receive-operations are allowed (at least in versions up to 5.5.17 inclusive); </li><li>  SObjectizer mchains may or may not have a message queue size limit.  While in Go, channel size is always limited.  For a limited-size mchain, SObjectizer forces you to choose the appropriate behavior to try to put a new message on a full mchain (for example, wait a while and throw away the oldest message from mchain or wait for nothing and immediately throw an exception). </li></ul><br>  Message chains are a relatively recent addition to SObjectizer.  However, the thing turned out to be quite useful and rather unexpected consequence of its addition was the fact that it became possible to develop some multi-threaded applications on SObjectizer even without the use of agents: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_sum_demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-comment"><span class="hljs-comment">//  ,         . struct consumer_result { thread::id m_id; size_t m_values_received; uint64_t m_sum; }; wrapped_env_t sobj; //      . auto values_ch = create_mchain( sobj, //     ,   //   5       . chrono::minutes{5}, //   300   . 300u, //       . mchain_props::memory_usage_t::preallocated, //         5 , //     . mchain_props::overflow_reaction_t::abort_app ); //        . auto results_ch = create_mchain( sobj ); //  . vector&lt; thread &gt; workers; for( size_t i = 0; i != thread::hardware_concurrency(); ++i ) workers.emplace_back( thread{ [&amp;values_ch, &amp;results_ch] { //      // ,     //  . size_t received = 0u; uint64_t sum = 0u; receive( from( values_ch ), [&amp;sum, &amp;received]( unsigned int v ) { ++received; sum += v; } ); //    . send&lt; consumer_result &gt;( results_ch, this_thread::get_id(), received, sum ); } } ); //      .    //    ,     //   . for( unsigned int i = 0; i != 10000; ++i ) send&lt; unsigned int &gt;( values_ch, i ); //          //   . close_retain_content( values_ch ); //       . receive( //   ,     . from( results_ch ).handle_n( workers.size() ), []( const consumer_result &amp; r ) { cout &lt;&lt; "Thread: " &lt;&lt; r.m_id &lt;&lt; ", values: " &lt;&lt; r.m_values_received &lt;&lt; ", sum: " &lt;&lt; r.m_sum &lt;&lt; endl; } ); for_each( begin(workers), end(workers), []( thread &amp; t ) { t.join(); } ); }</span></span></code> </pre><br><br><h4>  Why is this? </h4><br>  Certainly, readers who have never used the Actor Model and Publish-Subscribe, have a question: "And what, does all of the above really simplify the development of multi-threaded C ++ applications?" <br><br>  Yes.  Simplifies.  Proven in humans.  Repeatedly. <br><br>  Clear business, simplifies not for all applications.  Indeed, multithreading is a tool that is used in two very different directions.  The first direction, called <a href="https://en.wikipedia.org/wiki/Parallel_computing">parallel computing</a> , uses streams to load all the available computing resources and reduce the total computation time for computing tasks.  For example, accelerating video transcoding by loading all the cores, with each core performing the same task, but on its own set of data.  This is not the direction for which SObjectizer was created.  Other tools are designed to simplify the solution of this class of problems: <a href="http://openmp.org/">OpenMP</a> , Intel <a href="https://www.threadingbuildingblocks.org/">Threading Building Blocks</a> , <a href="http://stellar.cct.lsu.edu/projects/hpx/">HPX</a> , etc. <br><br>  The second direction, called <a href="https://en.wikipedia.org/wiki/Concurrent_computing">concurrent computing</a> , uses multithreading to provide parallel execution of many (almost) independent activities.  For example, an email client in one stream can send outgoing mail, in the second - download incoming, in the third - edit the new letter, in the fourth - perform background spell checking in a new letter, in the fifth - perform a full-text search in the mail archive, etc. <br><br>  SObjectizer was created just for the direction of concurrent computing, and the above features of SObjectizer reduce the headache of the developer. <br><br>  First of all, by building the interaction between agents through asynchronous messaging. <br><br>  The interaction of independent threads through message queues is much easier than through manual work with shared data protected by semaphores or mutexes.  And the simpler it is, the more workflows in the application and the more often and diverse their interaction. <br><br>  Getting lost in mutexes and conditional variables is easy even on a dozen workflows.  And when the score goes to hundreds of workflows, then manual fussing with low-level synchronization primitives generally turns out to be beyond the capabilities of even experienced developers.  Whereas a hundred threads interacting through message queues, as practice has shown, is absolutely not a problem. <br><br>  So the main thing that gives the SObjectizer developer (like any other implementation of the Actor Model) is the ability to represent independent activities within the application as agents that communicate with the outside world only through messages. <br><br>  The next key point is the binding of agents to the appropriate working contexts. <br><br>  Common sense suggests (and practice confirms this) that it is not good to give out all agents on their own working thread.  The application may need ten thousand independent agents.  Or a hundred thousand.  Or even a million.  Obviously, the presence of such a number of working threads in the system will not lead to anything good.  Even if the OS will be able to create them (depending on which OS and on which equipment), the overhead of ensuring their work will still be too large for the application built in this way to work with acceptable performance and responsiveness. <br><br>  The opposite, when all agents are tied to a single common thread or to a single thread pool, is also not an ideal solution for all cases.  For example, in an application there may be a dozen agents who have to work with a third-party synchronous API (make queries to the database, communicate with devices connected to a computer, perform heavy computational operations, etc.).  Each such agent is able to slow down the work of all other agents that will be on the same working thread with it.  Several such agents can easily slow down the entire application if it uses a single pool of workflows: just each agent will take one of the pool's threads ... <br><br>  In order to solve these problems, SObjectizer has dispatchers and such an important operation as binding agents to the appropriate dispatchers.  All together, this gives the developer the necessary freedom and flexibility, while relieving the developer from the worries of managing these threads. <br><br>  A programmer can create as many dispatchers as he needs, and so distribute his agents among these dispatchers as he sees fit.  For example, in the application may be: <br><ul><li>  one dispatcher of type one_thread, on which a certain agent runs an AMQP client; </li><li>  one dispatcher of type thread_pool, on which the agents responsible for processing messages from AMQP-shny topics work; </li><li>  one active_obj dispatcher to which agents are attached to interact with the DBMS; </li><li>  another active_obj dispatcher on which agents will communicate that communicate with HSMs connected to the computer; </li><li>  and another thread_pool dispatcher for agents that monitor and control the entire kitchen described above. </li></ul><br>  Another thing that the SObjectizer users themselves point out as one of the most important is the support for deferred and periodic messages.  Those.  <a href="http://www.slideshare.net/YauheniAkhotnikau/dive-into-sobjectizer-55-fifth-part-timers">work with timers</a> . <br><br>  It is often necessary to perform some action in N milliseconds.  And then after M milliseconds, check for the result.  And, if there is no result, wait K milliseconds and repeat all over again.  Nothing complicated: there is send_delayed, which makes a message postponed for a specified time. <br><br>  Often, agents work on a clock basis.  For example, once a second, the agent wakes up, performs a pack of operations accumulated during the last second, and then falls asleep before the next tact.  Again, nothing complicated: there is send_periodic, which repeats the delivery of the same message with a given tempo. <br><br><h4>  Why is SObjectizer exactly like that? </h4><br>  SObjectizer has never been an experimental project, it has always been used to simplify everyday work with C ++.  Each new version of SObjectizer went straight to work, SObjectizer was constantly used in the development of commercial projects (in particular, in several business-critical projects of Intervale, but not only).  It left its mark on its development. <br><br>  The work on the last version of SObjectizer (we call it SObjectizer-5) began in 2010, when the C ++ 11 standard was not yet adopted, some C ++ 11 things were already supported in some places, and some had to wait more than five years. <br><br>  In such conditions, not everything could be done conveniently and concisely from the first time.  Mostly there was not enough experience using C ++ 11.  Very often, we were limited by the capabilities of compilers that we had to deal with.  We can say that the forward movement went by trial and error. <br><br>  At the same time, we also needed to take care of compatibility: when SObjectizer is at the heart of business-critical applications, you cannot just throw away some piece of SObjectizer or change some of its API in some fundamental way.  Therefore, even if time showed that somewhere we were mistaken and something could be made easier and more convenient, then there was no opportunity to ‚Äútake and rewrite‚Äù.  We were moving and moving in an evolutionary way, gradually adding new features, but not throwing out old pieces overnight.  As a small illustration: there has not been any serious backward compatibility violation since the release of version 5.5.0 in the fall of 2014, although since then there have already been about 20 releases as part of the development of version 5.5. <br><br>  SObjectizer acquired its unique features as a result of many years of use of SObjectizer in real projects.  Unfortunately, this uniqueness ‚Äúclimbs sideways‚Äù when trying to tell the SObjectizer to the general public.  Too SObjectizer is not like <a href="http://www.erlang.org/">Erlang</a> and other projects created in the image and likeness of Erlang (for example, <a href="http://actor-framework.org/">C ++ Actor Framework</a> or <a href="http://akka.io/">Akka</a> ). <br><br>  Here, for example, we have the ability to run several independent instances of SObjectizer in one application.  The opportunity is very exotic.  But it was added because in practice sometimes this is necessary.  To support this feature, a concept like the SObjectizer Environment has appeared in SObjectizer.  And this SObjectizer Environment needed to be ‚Äúpulled‚Äù through a fair amount of the SObjectizer API, which could not but affect the brevity of the code. <br><br>  But in the C ++ Actor Framework, this feature was not originally available.  The actors API in CAF looked much simpler, and the code examples were shorter.  Because of this, we often come across statements that CAF is perceived as simpler and clearer than SObjectizer. <br><br> , ,  , <a href="http://blog.actor-framework.org/2016-05/a-glimpse-at-the-future-of-caf/">    CAF-     ,       SObjectizer Environment (   actor_system)</a> .     CAF    .       CAF-.   ,  , CAF     SObjectizer. <br><br>   ,      SObjectizer,      ,      :    SObjectizer-5    .    -  ¬´   ?   Erlang- ,  Akka ‚Äî ,  CAF ‚Äî ,    ?!!¬ª <br><br>  Not.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For a very simple reason: there was such support in SObjectizer-4, but over time it turned out that there was no transport that would ideally fit different conditions. If the nodes of the distributed application chase each other large chunks of video files - this is one thing. If they exchange hundreds of thousands of small packages, that‚Äôs completely different. If a C ++ application needs to communicate with Java applications - this is the third.</font></font> Etc. <br><br>       SObjectizer-5  ,            ,     ,    . -  AMQP, - MQTT, - REST.      .     ,   . <br><br>        ,   ,         C++  -  : <br><ul><li>         <a href="http://actor-framework.org/">CAF</a> ,      Erlang-  C++,   ; </li><li> ,    <a href="http://www.state-machine.com/products/index.html">QP</a> ,      ; </li><li>     Actor Model    <a href="http://www.stdthread.co.uk/pro/">Just::Thread Pro Actor Edition</a> . </li></ul><br>           . ,  ,    SObjectizer   , -, <a href="https://sourceforge.net/p/sobjectizer/wiki/Performance%2520Comparison%2520SO-5.5.15.2%2520vs%2520CAF-0.14.4%2520%2528Russian%2529/"></a> ,  , <a href="https://sourceforge.net/p/sobjectizer/wiki/Basics/">   </a>     . ,  ,   ,  SObjectizer       . <br><br><h4>  Afterword </h4><br>             ,    ,    SObjectizer-  : ¬´  ?¬ª, ¬´ ?¬ª  ¬´   ?¬ª                SObjectizer-.     ,      -   .     ,         SObjectizer-,    ,       ,      .,  .. </div><p>Source: <a href="https://habr.com/ru/post/304386/">https://habr.com/ru/post/304386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304374/index.html">Creating an OSSIM plugin to collect logs from the database</a></li>
<li><a href="../304378/index.html">We work with a budget institution. Part 3</a></li>
<li><a href="../304380/index.html">Still want a well-fed and bright future for their children?</a></li>
<li><a href="../304382/index.html">Cyber ‚Äã‚ÄãPandemic: Computer Attacks in Healthcare</a></li>
<li><a href="../304384/index.html">Hobby projects: chip-in.me - who, to whom and how much</a></li>
<li><a href="../304392/index.html">Fear of high rates, or how to optimize the budget</a></li>
<li><a href="../304394/index.html">Free Master in one of the top universities in the world: Italy</a></li>
<li><a href="../304396/index.html">How to quickly connect google proto3 to your spring (boot) web project</a></li>
<li><a href="../304398/index.html">UX button design: creation tips, types and states</a></li>
<li><a href="../304400/index.html">How is the largest automotive community Drive2.ru - traffic, monetization and user content</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>