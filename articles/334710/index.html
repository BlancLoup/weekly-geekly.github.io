<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagger 2. Subcomponents. Best practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√©, there have already been several good articles on installing and working with Dagger 2 : 



- Part 1: The Basics 
- Part 2: Subcomponents 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagger 2. Subcomponents. Best practice</h1><div class="post__text post__text-html js-mediator-article">  On Habr√©, there have already been several good articles on installing and working with <a href="https://github.com/google/dagger"><b>Dagger 2</b></a> : <br><br><ul><li>  <a href="https://habrahabr.ru/post/279125/">Part 1: The Basics</a> </li><li>  <a href="https://habrahabr.ru/post/279641/">Part 2: Subcomponents</a> </li></ul><br>  I want to share my experience using Dagger 2 on real projects with real cases.  Reveal to the reader the power and convenience of both Dagger himself and such an aspect as Subcomponent. <br><br>  Before you go under the cat, you should read the above articles. <br>  Anyone interested, you are welcome! <br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/getpro/habr/post_images/0bf/05a/e32/0bf05ae327f370ed954bd5fe97ccbc0e.jpg" alt="image"></div><a name="habracut"></a><br>  A friend of mine taught me a great way how to sort everything out: representing some architecture (either a single class, or even a small piece of code), try to transfer it to the real world.  Find in your everyday life something similar to the logic of your code.  And then, based on the example of real life, you will understand how this or that program component (object) should behave.  Understand what the result should end up. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This time I will do the same. <br><br>  Let's digress from programming and fast forward to the surgery room. <br><br>  Saving lives is an extremely important task.  Each member of the medical team must accurately carry out their work and not prevent others from doing their own. <br><br>  On the shelves neatly laid out all the tools.  The head physician with great concentration and painstakingly performs the operation, occasionally turning to an assistant to get a new instrument, say, a scalpel.  At different points in time, it may be necessary to have a ‚Äúdifferent scalpel‚Äù, and therefore it is important for the assistant to also not be distracted from the process and deliver exactly the right tool. <br><br>  The doctor absolutely does not care about the shelf on which the instrument he needs is lying.  It is more important for him to concentrate fully on the operation in order to avoid mistakes - this is his <i>area of ‚Äã‚Äãresponsibility</i> . <br><br>  The assistant is responsible for the availability of all the necessary tools for the operation, for their cleanliness, for the timely provision of tools to the doctor.  Well and the most interesting, the assistant decides on his own, depending on the situation, which tool to choose;  Of course, if the doctor did not have precise instructions. <br><br>  In our case, the assistant is Dagger.  The doctor is our program component with a clear purpose in the program.  It is in the delegation (from the doctor to the assistant) of the creation and provision of dependencies (tools) that the pattern is - Dependency Injection (dependency injection). <br><br>  <b>What can be learned from this example:</b> <br><br><ol><li>  The component should not contain the logic of creating other components. <br><br></li><li>  The component should not care about the implementation of its tools.  In our example, if the surgeon asks: ‚ÄúA scalpel!‚Äù, The situation assistant will return the desired one from the set.  So  we can say that the doctor does not work with specific implementations of tools, but with their interfaces. </li></ol><br>  <b>Practice.</b>  <b>Let's go back to programming.</b> <br><br>  In the vast majority of applications there is work with any list of data. <br>  The adapter, which accepts to the constructor, is responsible for data processing: <br><br><ol><li>  Listener - for interaction events with list items; </li><li>  Perhaps context or LayoutInflater to create ViewHodlers; </li><li>  Well, the data list itself, if, of course, it was initialized in advance (otherwise the adapter implements its setList () method). </li></ol><br>  But what is the result?  Having received in our Fragment'e (or Activity) design <br><br><pre><code class="java hljs">Adapter adapter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Adapter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, getContext(), list); recyclerView.setAdapter(adapter);</code> </pre> <br>  We preoccupied our component by initializing another component.  Our doctor moved away from the operating table to find the right instrument. <br><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/getpro/habr/post_images/498/2fc/cd1/4982fccd134c582b7283a9b346fc5cc9.jpg" alt="image"></div><br><br>  With Dagger, however, we will not just get rid of the first line of the presented code, namely, we will free the component from the logic of creating another component - from unnecessary logic for it. <br><br>  Wait a minute, a question may appear here: <br><br>  <i>If the adapter initialization is delegated to Dagger, where does it get the Listener (the object of our component that implements the Listener)?</i>  <i>Storing a singleton fragment or activation is more than a bad idea!</i> <br><br>  Such a question may arise if you: <br><br><ol><li>  Use one or two Components for the entire application; </li><li>  All dependencies store singletonami; </li><li>  And you don't want to know about Subcomponents and Component dependency. </li></ol><br>  <b>Let's go into a small abstraction, which I lacked at the beginning of studying Dagger.</b> <br><br>  Most examples of using Dagger in the ‚ÄúInternet‚Äù necessarily include creating the so-called AppComponent with its AppModule with root Context dependency (or your class extending Application, which is essentially also Context). <br><br>  We will understand why. <br><br>  <b>"In the beginning was the word ..."</b> <br><br>  Having Context, we can get other dependencies, for example: SharedPreferences, LayoutInflater, some system service, etc.  Accordingly, having SharedPreferences, we can receive PreferenceHelper - a class-utility for working with preferences.  Having LayoutInflater, we can receive any ViewFactory.  From these ‚Äúhigher level‚Äù dependencies, we can also get more and more complex, complex ones.  And all this diversity has gone from only one object - the context.  In this case, it can be called the <b>core of</b> our AppComponent. <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/getpro/habr/post_images/de0/7b9/32d/de07b932dea03a37ea3535a3bd796c72.jpg" alt="image"></div><br>  And all of the above is just those dependencies that must exist throughout the life of the entire application, i.e.  Singleton'y.  That is why as the core we have the object that exists all this time - the object context of the application. <br><br>  Continuing this thought, let us think how long should our Adapter exist?  Obviously, while there is a screen with which this adapter works. <br><br>  Adapter, we will provide a ViewHolderFactory, which must exist as long as the Adapter exists.  In addition to the Adapter, we will give Fragment some ViewController, and it should also exist, only as long as the Fragment exists, etc. <br><br>  If to understand, all dependences used exclusively while this screen is ‚Äúalive‚Äù depend on this screen.  So  we can say that our Fragment (or Activity) will be the <b>core of</b> our local Component, the Component, which exists while our screen exists. <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/getpro/habr/post_images/625/596/674/625596674d47fa9f71de32749bc3ec48.jpg" alt="image"></div><br>  To realize a well-defined lifetime of this local handful (column) of our dependencies, we will use Subcomponent. <br><br>  <b>Ask me "how?"</b> <br><br>  For now, let's forget about the sub prefix and imagine that we implement just the Component.  If it will be easier for you, imagine that our screen is the whole of our application. <br><br>  To begin with, we need a base module.  Since  our list screen, call it ListModule. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListModule</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  Now we need the very core - the basic dependence, from which all the rest will go.  As mentioned earlier, the basic dependency for the screen is the "screen object" itself - for example, ListFragment.  Let's transfer it in the designer of the module. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ListFragment fragment; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ListFragment fragment)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fragment = fragment; } }</code> </pre><br>  The basis is, further creativity. <br><br>  Provide our adapter: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Adapter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Adapter(fragment, context, fragment.initList()); }</code> </pre><br>  <i>NOTE: We have a Context, but obviously we did not provide it in this module or in other modules of our Component.</i>  <i>More on this later.</i> <br><br>  You can even separately provide the list of data itself (this is redundant, but for example it will do): <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Model&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideListOfModels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fragment.initList(); } <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Adapter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, List&lt;Model&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Adapter(fragment, context, list); }</code> </pre><br>  Now, to make it work as it should, a few settings. <br><br>  In order to prompt Dagger, that: <br><br><ol><li>  All dependencies of Component are one graph, separate from the main one; </li><li>  We want not to create a new dependency every time, but to cache the only one; </li></ol><br>  There are so-called Scope annotations.  Each Scope annotation looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Scope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.Runtime) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Singleton {}</code> </pre><br>  <i>A singleton</i> is a basic annotation provided by Dagger.  It is provided simply so that you have something to push off from.  The ‚Äúsingleton‚Äù itself will not happen in a magical way, unless you save your AppComponent in the App class (the class extending Application).  Those.  Dagger guarantees that a single dependency instance will be created for a given instance of Component.  But you are responsible for the uniqueness of the Component instance. <br><br>  Similarly, create your scope-annotation: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Scope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.Runtime) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> ListScope {}</code> </pre><br>  Our annotation does not give way to the annotations of Singleton, the whole point is how we use them. <br><br>  Scope-annotation we mark our provide-methods and Component, containing our modules. <br><br><blockquote>  <b>IMPORTANT:</b> In one Component signed by a certain Scope there can only be modules whose provide methods are signed by the same Scope.  So  we do not intersect two different dependency graphs. </blockquote><br>  The final view of our ListModule: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ListFragment fragment; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ListFragment fragment)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fragment = fragment; } <span class="hljs-meta"><span class="hljs-meta">@ListScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Model&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideListOfModels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fragment.initList(); } <span class="hljs-meta"><span class="hljs-meta">@ListScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Adapter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context contex, List&lt;Model&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Adapter(fragment, context, list); } }</code> </pre><br>  And our Component: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ListScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Subcomponent</span></span>(modules = ListModule.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ListFragment fragment)</span></span></span></span>; }</code> </pre><br>  The key here is the <i>@Subcomponent</i> annotation.  So we inform you that we want to have access to all dependencies of our parent Component, but note that we don‚Äôt indicate the parent here.  In our example, the parent will be AppComponent. <br><br>  <i>* It is from AppComponent that we get the Context for initializing the adapter.</i> <br><br>  To get your Subcomponent, in the parent Component you need to describe the method of getting it, passing all the Subcomponent modules to the arguments (in our case only one module). <br><br>  What it looks like: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = AppModule.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ListComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ListModule listModule)</span></span></span></span>; }</code> </pre><br>  Dagger will take care of the implementation of this method. <br><br>  <b>We organize the time of life</b> <br><br>  As already mentioned, AppComponent is because Singleton, because we store its only instance in the App class.  We can create an instance of our Subcomponent only with the help of the parent, and therefore all the logic of receiving and storing the Subcomponent can also be transferred to the App class, with one important difference: We will add the ability to create a Subcomponent at any time and destroy it at any time. <br><br>  In the App class, we describe the following logic: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ListComponent listComponent; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ListComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initListComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ListFragment fragment)</span></span></span><span class="hljs-function"> </span></span>{ listComponent = appComponent.listComponent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ListModule(fragment)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listComponent } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ListComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getListComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listComponent; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroyListComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ listComponent = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre><br>  <i>NOTE: On large projects, it makes sense to bring the logic of working with Dagger from the App class to the helper class using composition.</i> <br><br>  Well, it remains to describe the use of all this in our fragment: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListFragment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fragment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> Adapter adapter; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); App.getInstance().initListComponent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); init(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ recyclerView.setAdapter(adapter); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy(); App.getInstance.destroyListComponent(); } }</code> </pre><br>  Thus, we tied the life time of our graph to the life cycle of a fragment. <br><br>  This may seem redundant in the case of one dependency (although, even with one dependency, taking out such logic makes your code cleaner and less <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D1%2586%25D0%25B5%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">hooked</a> ).  Most of the work is architecture.  And so now, if you need to provide a new dependency, it will be reduced to the implementation of one provide-method. <br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/getpro/habr/post_images/5f7/1d5/74a/5f71d574aa69aa3547e0621b8d1d4ca3.jpg" alt="image"></div><br><h3>  <b>BONUS</b> </h3><br>  When all dependencies are highlighted in provide-methods, there appears such a pleasant bun, like getting rid of any dependencies.  Consider again the example with the adapter. <br><br>  ListFragment implements Listener of the events connected with ViewHolder objects of our list.  Accordingly, in order to deliver the Listener to each ViewHolder, it becomes necessary to store a reference to the Listener in the Adapter. <br><br>  Get rid of the middleman. <br><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/getpro/habr/post_images/69a/e58/707/69ae58707544338dd240803a5abcfa27.jpg" alt="image"></div><br><br>  A good practice is to take away the creation of ViewHolders in the ViewHolderFactory.  So do: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListItemViewHolderFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Listener listener; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LayoutInflater layoutInflater; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListItemViewHolderFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LayoutInflater layoutInflater, Listener listener)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.layoutInflater = layoutInflater; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listener = listener; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ListItemViewHolder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ViewGroup parent)</span></span></span><span class="hljs-function"> </span></span>{ View view = layoutInflater.inflate(R.layout.item, parent, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ListItemViewHolder(view, listener); } }</code> </pre><br>  Our module will change to this type: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ListFragment fragment; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ListFragment fragment)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fragment = fragment; } <span class="hljs-meta"><span class="hljs-meta">@ListScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Model&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideListOfModels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fragment.initList(); } <span class="hljs-meta"><span class="hljs-meta">@ListScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Adapter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ListItemViewHolderFactory factory, Context context, List&lt;Model&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Adapter(factory, context, list); } <span class="hljs-meta"><span class="hljs-meta">@ListScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ListItemViewHolderFactory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideVhFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LayoutInflater layoutInflater)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ListItemViewHolderFactory (layoutInflater, fragment); } }</code> </pre><br>  <i>NOTE: Remember to provide the LayoutInflater in the AppModule.</i> <br><br>  It seems to me that this example shows well how flexible the work with dependencies becomes. <br><br>  Now imagine the world in which we make the code review of a certain component (class), and we see only its logic.  There is no need to "jump" between software components to track the thread of events.  External tools appear by themselves, and with other components ours interact through interfaces (or do not interact at all). <br><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/getpro/habr/post_images/50d/e4f/f14/50de4ff14481729978b6e01f9a4fa80f.jpg" alt="image"></div><br>  I hope this article has given you a ground for reflection and creativity, and the world of Dagger has become a little closer. <br><br>  The next time we analyze the second part of the assistant‚Äôs functionality, return a specific implementation of the scalpel depending on the situation.  Let's talk about the authorized zone and work with social networks. <br><br>  Thanks for attention. <br><br>  <a href="https://github.com/udy18rus/dagger2sample">The example described in the article on githaba.</a> <br><br>  <b>UPD:</b> <a href="https://habrahabr.ru/post/337070/">The second part</a> </div><p>Source: <a href="https://habr.com/ru/post/334710/">https://habr.com/ru/post/334710/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334698/index.html">Three laws of configydynamics</a></li>
<li><a href="../334700/index.html">Vulnerability in Alfa-Bank Ukraine: getting the full name of the client by phone number</a></li>
<li><a href="../334702/index.html">Development under Sailfish OS in the eyes of an iOS developer</a></li>
<li><a href="../334704/index.html">Unified Style Language</a></li>
<li><a href="../334708/index.html">Practical examples of attacks inside the GSM network</a></li>
<li><a href="../334712/index.html">Character development for the game "Allods Online"</a></li>
<li><a href="../334714/index.html">"Man in the middle" using revoked certificates. Part 2</a></li>
<li><a href="../334716/index.html">Create offline facial recognition with an accuracy of 99.38% in Python and Node.js</a></li>
<li><a href="../334718/index.html">The first Mail.Ru Group specialization is Coursera, the largest educational platform.</a></li>
<li><a href="../334720/index.html">Search for Go packages on PowerShell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>