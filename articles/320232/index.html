<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>R Development: Cycle Mysteries</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Less than a week ago, in the Hacker magazine, the author's version of the material devoted to features using cycles when developing on R. was publishe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>R Development: Cycle Mysteries</h1><div class="post__text post__text-html js-mediator-article"><p>  Less than a week ago, in the Hacker magazine, the author's version of the <a href="https://aka.ms/habr_320232_8">material</a> devoted to features using cycles when developing on R. was <a href="https://aka.ms/habr_320232_2">published</a> . By agreement with Hacker, we share the full version of the first <a href="https://aka.ms/habr_320232_2">article</a> .  You will learn how to write cycles when processing large amounts of data. </p><br><img src="https://habrastorage.org/files/4f9/0ad/5ff/4f90ad5ff50f4b29bf295d52c0b0b6cf.jpg"><a name="habracut"></a><br><p>  <em>Note: the author‚Äôs spelling and punctuation is preserved.</em> </p><br><p>  In many programming languages, cycles serve as basic building blocks that are used for any repetitive tasks.  However, in R, excessive or incorrect use of cycles can lead to a perceptible drop in performance ‚Äî despite the fact that there are an unusually large number of ways to write cycles in this language. </p><br><p> Today we will consider the features of using regular cycles in R, as well as get acquainted with the <code>foreach</code> function from the package of the same name, which offers an alternative approach to this seemingly basic task.  On the one hand, <code>foreach</code> combines the best of standard functionality, on the other hand, it allows you to easily switch from sequential to parallel computations with minimal changes in the code. </p><br><h1 id="o-ciklah">  About cycles </h1><br><p>  To begin with, it often turns out to be an unpleasant surprise for those who switch to R from classical programming languages: if we want to write a loop, then we have to think about it for a second.  The fact is that in languages ‚Äã‚Äãfor working with large amounts of data, cycles tend to be inferior in efficiency to specialized query functions, filtering, aggregation and data transformation.  This is easy to remember using the example of databases, where most of the operations are performed using the SQL query language, rather than using cycles. </p><br><p>  To understand how important this rule is, let's turn to numbers.  Suppose we have a very simple table of two columns <code>a</code> and <code>b</code> .  The first grows from 1 to 100 000, the second decreases from 100 000 to 1: </p><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">testDF</span></span> &lt;- <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.frame(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> = 1:100000, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class"> = 100000:1)</span></span></code> </pre> <br><p>  If we want to calculate the third column, which will be the sum of the first two, then you will be surprised how many novice R-developers can write code like this: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:nrow(testDF)) testDF[<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;- testDF[<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] + testDF[<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] # !</code> </pre> <br><p>  On my laptop, calculations take 39 seconds, although the same result can be achieved in 0.009 seconds by using the function for working with tables from the <code>dplyr</code> package: </p><br><pre> <code class="hljs matlab">testDF &lt;- testDF <span class="hljs-comment"><span class="hljs-comment">%&gt;% mutate(c = a + b)</span></span></code> </pre> <br><p>  The main reason for such a serious difference in speed is the loss of time when reading and writing cells in the table.  It is thanks to the optimization at these stages that special functions benefit.  But it is not necessary to write off good old cycles for scrap, because without them it is still impossible to create a full program.  Let's see what's up with the cycles in R. </p><br><h1 id="klassicheskie-cikly">  Classic loops </h1><br><p>  R supports the basic classic ways of writing loops: </p><br><ul><li><p>  <code>for</code> - the most common type of cycles.  The syntax is very simple and familiar to developers in various programming languages.  We tried to use it at the very beginning of the article.  <code>for</code> performs the function passed to it for each element. </p><br><pre> <code class="hljs swift">#    <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(i) #      strings strings &lt;- <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(str <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> strings) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(str)</code> </pre> <br></li><li><p>  Slightly less common <code>while</code> and <code>repeat</code> , which are also often found in other programming languages.  In <code>while</code> before each iteration, a logical condition is checked, and if it is observed, then the loop is iterated; if not, the loop ends: </p><br><pre> <code class="hljs lisp">while(<span class="hljs-name"><span class="hljs-name">cond</span></span>) expr</code> </pre> <br></li></ul><br><p>  In <code>repeat</code> loop repeats until the <code>break</code> statement is called explicitly: </p><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> expr</code> </pre> <br><p>  It is worth noting that <code>for</code> , <code>while</code> and <code>repeat</code> always return NULL - and this is where they differ from the next group of loops. </p><br><h1 id="cikly-na-osnove-apply">  Apply based loops </h1><br><p>  <code>apply</code> , <code>eapply</code> , <code>lapply</code> , <code>mapply</code> , <code>rapply</code> , <code>sapply</code> , <code>tapply</code> , <code>vapply</code> - a fairly large list of function loops, united by one idea.  They differ in what the cycle is applied to and what returns. </p><br><p>  Let's start with the basic <code>apply</code> that applies to matrices: </p><br><pre> <code class="hljs lisp">apply(<span class="hljs-name"><span class="hljs-name">X</span></span>, MARGIN, FUN, ...)</code> </pre> <br><p>  In the first parameter ( <code>X</code> ) we specify the source matrix, in the second parameter ( <code>MARGIN</code> ) we specify the way to bypass the matrix (1 - in rows, 2 - in columns, with (1,2) - in rows and columns), the third parameter is the function FUN, which will be called for each item.  The results of all calls will be combined into one vector or matrix, which the function <code>apply</code> will return as the resulting value. </p><br><p>  For example, create a matrix <code>m</code> size 3 x 3. </p><br><pre> <code class="hljs xml">m <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">matrix</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1:9</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">nrow</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">3,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ncol</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">3)</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">print</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">m</span></span></span><span class="hljs-tag">) [,</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag">] [,</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span><span class="hljs-tag">] [,</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">3</span></span></span><span class="hljs-tag">] [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag">,] </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">7</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span><span class="hljs-tag">,] </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">5</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">8</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">3</span></span></span><span class="hljs-tag">,] </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">3</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">6</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">9</span></span></span></span></code> </pre> <br><p>  Let's try the function <code>apply</code> in action. </p><br><pre> <code class="hljs 1c">apply(m, MARGIN = <span class="hljs-number"><span class="hljs-number">1</span></span>, FUN = sum) <span class="hljs-meta"><span class="hljs-meta">#   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   [1] 12 15 18 apply(m, MARGIN = 2, FUN = sum) #   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  [1] 6 15 24</span></span></code> </pre> <br><p>  For simplicity, I passed the existing function <code>sum</code> to <code>apply</code> , but you can use your functions - in fact, therefore <code>apply</code> is a complete implementation of the loop.  For example, we replace the sum with our function, which first performs the summation and, if the sum is equal to 15, replaces the return value by 100. </p><br><pre> <code class="hljs lua">apply(m, MARGIN = <span class="hljs-number"><span class="hljs-number">1</span></span>, #       FUN = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> #       apply { s &lt;- sum(x) #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == <span class="hljs-number"><span class="hljs-number">15</span></span>) #    <span class="hljs-number"><span class="hljs-number">15</span></span>,     <span class="hljs-number"><span class="hljs-number">100</span></span> s &lt;- <span class="hljs-number"><span class="hljs-number">100</span></span> (s) } ) [<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span></code> </pre> <br><p>  Another common feature of this family is <code>lapply</code> . </p><br><pre> <code class="hljs lisp">lapply(<span class="hljs-name"><span class="hljs-name">X</span></span>, FUN, ...)</code> </pre> <br><p>  The first parameter is a list or vector, and the second is the function to be called for each element.  The <code>sapply</code> and <code>vapply</code> functions are wrappers around <code>lapply</code> .  The first tries to bring the result to a vector, matrix, or array.  The second adds a check of return types. </p><br><p>  Such a way of using <code>sapply</code> as working with columns is quite common.  For example, we have a table </p><br><pre> <code class="hljs xml">data <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data.frame</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">co1_num</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">1,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">col2_num</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">2,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">col3_char</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"a"</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">col4_char</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"b"</span></span></span><span class="hljs-tag">)</span></span></code> </pre> <br><p>  When transferring a <code>sapply</code> table, it will be treated as a list of columns (vectors).  Therefore, by applying <code>sapply</code> to our <code>data.frame</code> and specifying <code>data.frame</code> as the called function, we will check which columns are numeric. </p><br><pre> <code class="hljs pgsql">sapply(data, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>.numeric) co1_num col2_num col3_char col4_char <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span></code> </pre> <br><p>  We display only columns with numeric values: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span>[,sapply(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>.numeric)] co1_num col2_num <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  The cycles based on <code>apply</code> are different from the classic ones in that the result of the cycle operation is returned, consisting of the results of each iteration. </p><br><p>  Remember that slow loop we wrote at the very beginning with <code>for</code> ?  Most of the time was lost because at each iteration the results were recorded in a table.  We write an optimized version using <code>apply</code> . </p><br><p>  Apply <code>apply</code> to the original table, selecting the processing line by line, and as the function used, we specify the basic sum function <code>sum</code> .  As a result, <code>apply</code> will return a vector, where for each row will be the sum of its columns.  Add this vector as a new column to the original table and get the desired result: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">a_plus_b</span></span> &lt;- apply(testDF, <span class="hljs-number"><span class="hljs-number">1</span></span>,sum) testDF<span class="hljs-variable"><span class="hljs-variable">$c</span></span> &lt;- a_plus_b</code> </pre> <br><p>  Measurement of execution time shows 0.248 seconds, which is one hundred times faster than the first option, but still ten times slower than the functions of operations with tables. </p><br><h1 id="foreach">  foreach </h1><br><p>  <code>foreach</code> is not a basic R function.  The corresponding package must be installed, and before the call to connect: </p><br><pre> <code class="hljs cmake"><span class="hljs-keyword"><span class="hljs-keyword">install</span></span>.packages(<span class="hljs-string"><span class="hljs-string">"foreach"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#     ( ) library(foreach) #  </span></span></code> </pre> <br><p>  Despite the fact that <code>foreach</code> is a third-party function, today it is a very popular approach to writing loops.  <code>foreach</code> was developed by one of the most respected R companies in the world - <strong>Revolution Analytics</strong> , which created its commercial distribution kit R. In 2015, the company was bought by Microsoft, and now all its developments are included in Microsoft SQL Server R Services.  However, <code>foreach</code> is an ordinary open source project under the Apache License 2.0 license. </p><br><p>  The main reasons for the popularity of <code>foreach</code> : </p><br><ul><li>  the syntax is similar to <code>for</code> - as I said, the most popular type of loop; </li><li>  <code>foreach</code> returns values ‚Äã‚Äãthat are collected from the results of each iteration, while you can define your function and implement any logic to collect the final value of the cycle from the results of iterations; </li><li>  It is possible to use multithreading and run iterations in parallel. </li></ul><br><p>  Let's start c simple.  For numbers from 1 to 10 at each iteration, the number is multiplied by 2. The results of all iterations are recorded in the result variable as a list: </p><br><pre> <code class="hljs cs">result &lt;- <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(i = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) %<span class="hljs-keyword"><span class="hljs-keyword">do</span></span>% (i*<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  If we want the result to be not a list, but a vector, then we need to specify <code>c</code> as a function to combine the results: </p><br><pre> <code class="hljs cs">result &lt;- <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(i = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, .combine = <span class="hljs-string"><span class="hljs-string">"c"</span></span>) %<span class="hljs-keyword"><span class="hljs-keyword">do</span></span>% (i*<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  You can even simply add up all the results by combining them with the <code>+</code> operator, and then the number 110 will simply be written into the <code>result</code> variable: </p><br><pre> <code class="hljs cs">result &lt;- <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(i = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, .combine = <span class="hljs-string"><span class="hljs-string">"+"</span></span>) %<span class="hljs-keyword"><span class="hljs-keyword">do</span></span>% (i*<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  In this case, you can simultaneously specify several variables in the <code>foreach</code> for traversal.  Let the variable <code>a</code> grow from 1 to 10, and <code>b</code> decrease from 10 to 1. Then we get the <code>result</code> vector of 10 numbers 11: </p><br><pre> <code class="hljs cs">result &lt;- <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(a = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, .combine = <span class="hljs-string"><span class="hljs-string">"c"</span></span>) %<span class="hljs-keyword"><span class="hljs-keyword">do</span></span>% (a+b)</code> </pre> <br><p>  Loop iterations can return more than simple values.  Suppose we have a function that returns <code>data.frame</code> : </p><br><pre> <code class="hljs matlab">customFun &lt;- <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param = param, result1 = sample(1:100, 1)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result2</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1:100, 1)</span></span></span><span class="hljs-function">) }</span></span></code> </pre> <br><p>  If we want to call this function a hundred times and combine the results into one <code>data.frame</code> , then in .combine, we can use the <code>rbind</code> function to <code>rbind</code> : </p><br><pre> <code class="hljs cs">result &lt;- <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(param = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>,.combine = <span class="hljs-string"><span class="hljs-string">"rbind"</span></span>) %<span class="hljs-keyword"><span class="hljs-keyword">do</span></span>% customFun(param)</code> </pre> <br><p>  As a result, in the <code>result</code> variable, we have a single table of results. </p><br><p>  In <code>.combine</code> it is also possible to use your own function, and with the help of additional parameters you can optimize performance if your function can take more than two parameters at once (in the <code>foreach</code> documentation there is a description of the parameters <code>.multicombine</code> and <code>.maxcombine</code> ). </p><br><p>  One of the main advantages of <code>foreach</code> is the ease of transition from sequential processing to parallel processing.  In fact, this transition is carried out by replacing <code>%do%</code> with <code>%dopar%</code> , but there are a few nuances: </p><br><ol><li><p>  Before calling <code>foreach</code> , you should already have a parallel backend registered.  R has several popular implementations of parallel backend <code>doParallel</code> , <code>doSNOW</code> , <code>doMC</code> , and each has its own characteristics, but for the sake of simplicity, I suggest choosing the first one and writing a few lines of code to connect it: </p><br><pre> <code class="hljs cs">library(doParallel) <span class="hljs-meta"><span class="hljs-meta">#     cl &lt;- makeCluster(8) #  ¬´¬ª    registerDoParallel(cl) #  ¬´¬ª</span></span></code> </pre> <br></li></ol><br><p>  If we now call a cycle of eight iterations, each of which just waits for one second, it will be seen that the cycle will work in one second, since all iterations will be run in parallel: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>.time({ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>) %dopar% Sys.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) # }) <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> elapsed <span class="hljs-number"><span class="hljs-number">0.008</span></span> <span class="hljs-number"><span class="hljs-number">0.005</span></span> <span class="hljs-number"><span class="hljs-number">1.014</span></span></code> </pre> <br><p>  After using parallel backend, you can stop: </p><br><pre> <code class="hljs lisp"> stopCluster(<span class="hljs-name"><span class="hljs-name">cl</span></span>)</code> </pre> <br><p>  There is no need to create and delete the parallel backend each time before <code>foreach</code> .  As a rule, it is created once in a program and is used by all functions that can work with it. </p><br><ol><li>  You need to explicitly specify which packages to load into the worker threads using the <code>.packages</code> parameter. </li></ol><br><p>  For example, you want to create a file at each iteration using the <code>readr</code> package that was loaded into memory before calling <code>foreach</code> .  In the case of a sequential cycle ( <code>%do%</code> ), everything will work without errors: </p><br><pre> <code class="hljs sql"> library(readr) foreach(i=1:8) %<span class="hljs-keyword"><span class="hljs-keyword">do</span></span>% write_csv(data.frame(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>), paste0(<span class="hljs-string"><span class="hljs-string">"file"</span></span>, i, <span class="hljs-string"><span class="hljs-string">".csv"</span></span>))      (<span class="hljs-string"><span class="hljs-string">`%dopar%`</span></span>)    : <span class="hljs-keyword"><span class="hljs-keyword">library</span></span>(readr) foreach(i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>) %<span class="hljs-keyword"><span class="hljs-keyword">do</span></span>% write_csv(data.frame(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>), paste0(<span class="hljs-string"><span class="hljs-string">"file"</span></span>, i, <span class="hljs-string"><span class="hljs-string">".csv"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">Error</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> write_csv(data.frame(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>), paste0(<span class="hljs-string"><span class="hljs-string">"file"</span></span>, i, <span class="hljs-string"><span class="hljs-string">".csv"</span></span>)) : task <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">failed</span></span> - <span class="hljs-string"><span class="hljs-string">"could not find function "</span></span>write_csv<span class="hljs-string"><span class="hljs-string">""</span></span></code> </pre> <br><p>  The error occurs because the <code>readr</code> package is not loaded inside the parallel stream.  Fix this error with the <code>.packages</code> parameter: </p><br><pre> <code class="hljs perl"> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>, .packages = <span class="hljs-string"><span class="hljs-string">"readr"</span></span>) %dopar% write_csv(data.frame(id = <span class="hljs-number"><span class="hljs-number">1</span></span>), paste<span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-string"><span class="hljs-string">"file"</span></span>, i, <span class="hljs-string"><span class="hljs-string">".csv"</span></span>))</code> </pre> <br><ol><li>  The console output in a parallel stream is not displayed on the screen.  Sometimes it can be great to complicate debugging, so usually complex code is first written without parallelism, and then it is replaced with <code>%do%</code> by <code>%dopar%</code> or it redirects the output of each iteration to its file using the <code>sink</code> function. </li></ol><br><h1 id="vmesto-vyvodov">  Instead of conclusions </h1><br><ul><li><p>  When working with large amounts of data cycles are not always the best choice.  The use of specialized functions for sampling, aggregation and transformation of data is always more efficient than cycles. </p><br></li><li><p>  R offers many options for implementing loops.  The main difference between the classical <code>for</code> , <code>while</code> and <code>repeat</code> functions from the <code>apply</code> based function group is that the latter return a value. </p><br></li><li>  Using <code>foreach</code> loops from the same external package allows simplifying the writing of loops, flexibly operating the values ‚Äã‚Äãreturned by iterations, and by connecting multi-threaded processing it is also great to increase the solution's performance. </li></ul><br><h1 id="www">  Www </h1><br><ul><li>  <a href="https://aka.ms/habr_320232_3">Official foreach package documentation</a> </li><li>  <a href="https://aka.ms/habr_320232_4">Official foreach functionality review</a> </li><li>  <a href="https://aka.ms/habr_320232_6">Data analysis using R. Part 1</a> </li><li>  <a href="https://aka.ms/habr_320232_5">Studying R. Part 2: vectorization and visualization</a> </li><li>  <a href="https://aka.ms/habr_320232_7">We program in the R language: how to write cycles for processing large amounts of data</a> <br></li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/320232/">https://habr.com/ru/post/320232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320222/index.html">How IT professionals work. Ilya Titov, Managing Director for IT at Modbank</a></li>
<li><a href="../320224/index.html">IAP in Unity3D</a></li>
<li><a href="../320226/index.html">Is your call very important to us? Or how the prioritization system works in service departments</a></li>
<li><a href="../320228/index.html">Automation of load testing: a bunch of Jmeter + TeamCity + Grafana</a></li>
<li><a href="../320230/index.html">We test the Fujitsu PRIMERGY RX2530 M2 server</a></li>
<li><a href="../320234/index.html">Learning lessons from 7 games born on gamejams</a></li>
<li><a href="../320236/index.html">‚ÄúA‚Äù means ‚ÄúAstral‚Äù. Interview with Ivan Polyakov (Apus Software)</a></li>
<li><a href="../320238/index.html">How We Implemented DevOps: Publishing an Image to Docker Hub Using Visual Studio Team Services</a></li>
<li><a href="../320240/index.html">Basic planning tools and ways to implement them</a></li>
<li><a href="../320242/index.html">Clean Recycler Adapter. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>