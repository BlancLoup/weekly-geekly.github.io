<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Event-oriented Python backtesting step by step. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In previous articles, we talked about what an event-oriented backtesting system was, explored the class hierarchy that needs to be developed for it, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Event-oriented Python backtesting step by step. Part 3</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/company/itinvest/blog/266623/"><img src="https://habrastorage.org/files/ecc/936/679/ecc9366797aa47e2a868041d4cd98c7b.png"></a> <br><br>  In previous articles, we talked about what an event-oriented backtesting system was, explored the <a href="http://habrahabr.ru/company/itinvest/blog/263097/">class hierarchy</a> that needs to be developed for it, and discussed how such systems <a href="http://habrahabr.ru/company/itinvest/blog/264141/">use market data</a> in the context of historical testing and for ‚Äúlive‚Äù work on the exchange. <br><br>  Today we describe the NaivePortfolio object, which is responsible for tracking positions in the portfolio and, based on incoming signals, generates orders with a limited number of stocks. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Position Tracking and Order Processing </h4><br>  The order management system is one of the most complex components of an event-oriented back tester.  Its role is to track current market positions and their market value.  Thus, on the basis of the data obtained from the corresponding backtester component, the liquidation value of the position is calculated. <br><br>  In addition to analyzing positions, the portfolio component must take into account risk factors and be able to use techniques for determining the size of positions ‚Äî this is necessary for optimizing orders sent to the market through a broker's trading system. <br><br>  A <code>Portfolio</code> object must be able to process <code>SignalEvent</code> objects, generate <code>OrderEvent</code> objects <code>OrderEvent</code> and interpret <code>FillEvent</code> objects to update positions.  Thus, it is not surprising that Portfolio objects are usually the most voluminous elements of the backtesting system in terms of lines of code. <br><br><h4>  Implementation </h4><br>  Let's create a new file portfolio.py and import the necessary libraries - the same implementations of the abstract base class that we used earlier.  You need to import the floor function from the math library to generate integer orders.  <code>FillEvent</code> and <code>OrderEvent</code> objects <code>FillEvent</code> also <code>OrderEvent</code> ‚Äî a <code>Portfolio</code> object handles each of them. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># portfolio.py import datetime import numpy as np import pandas as pd import Queue from abc import ABCMeta, abstractmethod from math import floor from event import FillEvent, OrderEvent</span></span></code> </pre><br>  An abstract base class for Portfolio and two abstract methods <code>update_signal</code> and <code>update_fill</code> .  The first handles new trading signals that are taken from the event queue, and the last one works with information about the executed orders received from the engine handler object. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># portfolio.py class Portfolio(object): """  Portfolio          : , , 5 , 30 , 60   . """ __metaclass__ = ABCMeta @abstractmethod def update_signal(self, event): """  SignalEvent         . """ raise NotImplementedError("Should implement update_signal()") @abstractmethod def update_fill(self, event): """           FillEvent. """ raise NotImplementedError("Should implement update_fill()")</span></span></code> </pre><br>  The main object of today's article is the <code>NaivePortfolio</code> class.  It is designed to calculate the size of positions and reserved funds and process trade orders in a simple manner ‚Äî simply by sending them to a brokerage trading system with a specified number of shares.  In the real world, everything is more complicated, but such simplifications help to understand how the portfolio order processing system should function in event-oriented products. <br><br>  <code>NaivePortfolio</code> requires the amount of initial capital - in the example it is set at $ 100,000.  You must also set the day and time to start work. <br><br>  Portfolio contains <code>all_positions</code> and <code>current_positions</code> .  The first item stores a list of all previous positions recorded by the time stamp of a market event.  Position is simply the amount of a financial instrument.  Negative positions mean that shares are sold short.  The second element stores a dictionary containing the current positions for the last update of the bars. <br><br>  In addition to the items responsible for the positions, the portfolio stores information on the current market value of open positions (holdings).  ‚ÄúCurrent market value‚Äù in this case means the closing price obtained from the current bar, which is approximate, but rather plausible at the moment.  The <code>all_holdings</code> element stores a historical list of the cost of all positions, and <code>current_holdings</code> stores the most recent dictionary of meanings: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># portfolio.py class NaivePortfolio(Portfolio): """  NaivePortfolio    (..   -)    /   ,   .       BuyAndHoldStrategy. """ def __init__(self, bars, events, start_date, initial_capital=100000.0): """          .           ( ,     ). Parameters: bars - The DataHandler object with current market data. events - The Event Queue object. start_date - The start date (bar) of the portfolio. initial_capital - The starting capital in USD. """ self.bars = bars self.events = events self.symbol_list = self.bars.symbol_list self.start_date = start_date self.initial_capital = initial_capital self.all_positions = self.construct_all_positions() self.current_positions = dict( (k,v) for k, v in [(s, 0) for s in self.symbol_list] ) self.all_holdings = self.construct_all_holdings() self.current_holdings = self.construct_current_holdings()</span></span></code> </pre><br>  The following construct_all_positions method simply creates a dictionary for each financial instrument, sets each value to zero and then adds the date and time key.  Python dictionary generators are used. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># portfolio.py def construct_all_positions(self): """   ,  start_date   ,      . """ d = dict( (k,v) for k, v in [(s, 0) for s in self.symbol_list] ) d['datetime'] = self.start_date return [d]</span></span></code> </pre><br>  Metozh <code>construct_all_hldings</code> is similar to the one described above, but adds some additional keys for free funds, commissions and the balance of the account after the transactions, the total commission paid and the total amount of existing assets (open positions and money).  Short positions are considered as "negative".  The values ‚Äã‚Äãof <code>starting cash</code> and <code>total account</code> equal to the initial capital: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># portfolio.py def construct_all_holdings(self): """      ,  start_date   ,      . """ d = dict( (k,v) for k, v in [(s, 0.0) for s in self.symbol_list] ) d['datetime'] = self.start_date d['cash'] = self.initial_capital d['commission'] = 0.0 d['total'] = self.initial_capital return [d]</span></span></code> </pre><br>  The <code>construct_current_holdings</code> method is almost identical to the previous one, except that it does not ‚Äúwrap‚Äù the dictionary in the list: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># portfolio.py def construct_current_holdings(self): """  ,         . """ d = dict( (k,v) for k, v in [(s, 0.0) for s in self.symbol_list] ) d['cash'] = self.initial_capital d['commission'] = 0.0 d['total'] = self.initial_capital return d</span></span></code> </pre><br>  At each heartbeat, that is, for each request for market data from a <code>DataHandler</code> object, the portfolio must update the current market value of the held positions.  In the real trading scenario, this information can be downloaded and parsed directly from the brokerage system, but for the backtesting system it is necessary to calculate these values ‚Äã‚Äãseparately. <br><br>  Unfortunately, due to bid / asset spreads and liquidity, there is no such thing as a ‚Äúcurrent market value‚Äù.  Therefore, it is necessary to evaluate it by multiplying the amount of the asset held by the ‚Äúprice‚Äù.  In our example, the closing price of the previous bar is used. For intraday trading strategies, this is a fairly realistic approach, but for trading on time intervals for more than a day, everything is not so likely since the opening price may differ significantly from the opening price of the next bar. <br><br>  The <code>update_timeindex</code> method <code>update_timeindex</code> responsible for processing the current value of new positions.  It receives the latest prices from the market data processor and creates a new dictionary of tools that represent current positions, and equating ‚Äúnew‚Äù positions to ‚Äúcurrent‚Äù positions.  This scheme only changes when a <code>FillEvent</code> .  After this, the method <code>all_positions</code> current position set to the <code>all_positions</code> list.  Then, the present value values ‚Äã‚Äãare updated in a similar way, except that the market value is calculated by multiplying the number of current positions by the closing price of the last bar ( <code>self.current_positions[s] * bars[s][0][5]</code> ).  New values ‚Äã‚Äãobtained are added to the <code>all_holdings</code> list: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># portfolio.py def update_timeindex(self, event): """           .   , ..        (OLHCVI).  MarketEvent   . """ bars = {} for sym in self.symbol_list: bars[sym] = self.bars.get_latest_bars(sym, N=1) # Update positions dp = dict( (k,v) for k, v in [(s, 0) for s in self.symbol_list] ) dp['datetime'] = bars[self.symbol_list[0]][0][1] for s in self.symbol_list: dp[s] = self.current_positions[s] # Append the current positions self.all_positions.append(dp) # Update holdings dh = dict( (k,v) for k, v in [(s, 0) for s in self.symbol_list] ) dh['datetime'] = bars[self.symbol_list[0]][0][1] dh['cash'] = self.current_holdings['cash'] dh['commission'] = self.current_holdings['commission'] dh['total'] = self.current_holdings['cash'] for s in self.symbol_list: # Approximation to the real value market_value = self.current_positions[s] * bars[s][0][5] dh[s] = market_value dh['total'] += market_value # Append the current holdings self.all_holdings.append(dh)</span></span></code> </pre><br>  The <code>update_positions_from_fill</code> method determines exactly what <code>FillEvent</code> (buy or sell) was, and then updates the current_positions dictionary by adding or removing the appropriate number of stocks: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># portfolio.py def update_positions_from_fill(self, fill): """   FillEvent     ,     . Parameters: fill - The FillEvent object to update the positions with. """ # Check whether the fill is a buy or sell fill_dir = 0 if fill.direction == 'BUY': fill_dir = 1 if fill.direction == 'SELL': fill_dir = -1 #     self.current_positions[fill.symbol] += fill_dir*fill.quantity</span></span></code> </pre><br>  The corresponding <code>update_holdings_from_fill</code> method <code>update_holdings_from_fill</code> similar to the one described above, but it updates the <i>holdings</i> value.  To simulate the cost of execution, the method does not use the price associated with the <code>FillEvent</code> .  Why so prosithodit?  In the backtesting environment, the execution price is actually unknown, which means it must be assumed.  Thus, the exercise price is set as the ‚Äúcurrent market price‚Äù (closing price of the last bar).  The value of the current positions for a particular instrument is then equated to the price of execution multiplied by the number of securities in the order. <br><br>  After determining the exercise price, the current value of holdings, available funds and total values ‚Äã‚Äãcan be updated.  Also the total commission is updated: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># portfolio.py def update_holdings_from_fill(self, fill): """   FillEvent    holdings   . : fill -  FillEvent,    . """ # Check whether the fill is a buy or sell fill_dir = 0 if fill.direction == 'BUY': fill_dir = 1 if fill.direction == 'SELL': fill_dir = -1 # Update holdings list with new quantities fill_cost = self.bars.get_latest_bars(fill.symbol)[0][5] # Close price cost = fill_dir * fill_cost * fill.quantity self.current_holdings[fill.symbol] += cost self.current_holdings['commission'] += fill.commission self.current_holdings['cash'] -= (cost + fill.commission) self.current_holdings['total'] -= (cost + fill.commission)</span></span></code> </pre><br>  Next, the abstract method <code>update_fill</code> from the abstract base <code>Portfolio</code> class is implemented.  It simply executes the two previous methods <code>update_positions_from_fill</code> and <code>update_holdings_from_fill</code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># portfolio.py def update_fill(self, event): """            FillEvent. """ if event.type == 'FILL': self.update_positions_from_fill(event) self.update_holdings_from_fill(event)</span></span></code> </pre><br>  A Portfolio object must not only trigger FillEvent events, but also generate an <code>OrderEvent</code> when receiving <code>SignalEvent</code> signal events.  The generate_naive_order method uses a signal to open a long or short position, the target financial instrument and then sends the corresponding order with 100 shares of the desired asset.  100 here is an arbitrary value.  In the course of real trading, it would be determined by a risk management system or a module for calculating the value of positions.  However, in <code>NaivePortfolio</code> you can ‚Äúnaively‚Äù send orders right after receiving signals without any risk management. <br><br>  The method handles the opening of long and short positions, as well as the exit from them based on the current number and a specific financial instrument.  Then the corresponding <code>OrderEvent</code> object is <code>OrderEvent</code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># portfolio.py def generate_naive_order(self, signal): """   OrderEvent           . : signal -   SignalEvent. """ order = None symbol = signal.symbol direction = signal.signal_type strength = signal.strength mkt_quantity = floor(100 * strength) cur_quantity = self.current_positions[symbol] order_type = 'MKT' if direction == 'LONG' and cur_quantity == 0: order = OrderEvent(symbol, order_type, mkt_quantity, 'BUY') if direction == 'SHORT' and cur_quantity == 0: order = OrderEvent(symbol, order_type, mkt_quantity, 'SELL') if direction == 'EXIT' and cur_quantity &gt; 0: order = OrderEvent(symbol, order_type, abs(cur_quantity), 'SELL') if direction == 'EXIT' and cur_quantity &lt; 0: order = OrderEvent(symbol, order_type, abs(cur_quantity), 'BUY') return order</span></span></code> </pre><br>  The <code>update_signal</code> method simply calls the method described above and adds the generated order to the event queue. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># portfolio.py def update_signal(self, event): """   SignalEvent        . """ if event.type == 'SIGNAL': order_event = self.generate_naive_order(event) self.events.put(order_event)</span></span></code> </pre><br>  The final method in <code>NaivePortfolio</code> is to generate a capital curve.  It creates a stream of information about profits, which is useful for calculating the performance of the strategy, then the curve is normalized on a percentage basis.  The initial account size is set to wound 1.0: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># portfolio.py def create_equity_curve_dataframe(self): """  pandas DataFrame    all_holdings. """ curve = pd.DataFrame(self.all_holdings) curve.set_index('datetime', inplace=True) curve['returns'] = curve['total'].pct_change() curve['equity_curve'] = (1.0+curve['returns']).cumprod() self.equity_curve = curve</span></span></code> </pre><br>  The <code>Portfolio</code> object is the most complex aspect of the entire event-oriented back tester.  Despite the complexity, the processing of positions here is implemented at a very simple level. <br><br>  In the next article we will look at the last part of an event-oriented historical testing system - the <code>ExecutionHandler</code> object, which uses <code>OrderEvent</code> objects to create a <code>FillEvent</code> from them. <br><br>  <i>To be continued‚Ä¶</i> <br><br>  PS Earlier in our blog on Habr√© we have already <a href="http://habrahabr.ru/company/itinvest/blog/224353/">considered the</a> various stages of the development of trading systems.  <a href="http://www.itinvest.ru/promo/adv/">ITinvest</a> and our partners conduct <a href="http://www.itinvest.ru/education/schedule/">online courses</a> on this topic. </div><p>Source: <a href="https://habr.com/ru/post/266623/">https://habr.com/ru/post/266623/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266611/index.html">Layout letters: What is "kinetic email"</a></li>
<li><a href="../266613/index.html">Duck stories: duck looking for bugs</a></li>
<li><a href="../266615/index.html">Asynchronous execution of PHP script on subprocesses</a></li>
<li><a href="../266617/index.html">Free realtime list of online users (Parse.com + Pubnub)</a></li>
<li><a href="../266619/index.html">Overview of alternatives Proof of Work. Part 2. Proof of Activity, Proof of Burn, Proof of Capacity and Generals</a></li>
<li><a href="../266625/index.html">Cisco internship program - Cisco International Internship Program. How it was</a></li>
<li><a href="../266627/index.html">Himself a virtual operator</a></li>
<li><a href="../266629/index.html">Increase array efficiency</a></li>
<li><a href="../266637/index.html">Support is over: What to do? Who and what can help?</a></li>
<li><a href="../266639/index.html">Why do I need AshleyMadison if I don't smoke?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>