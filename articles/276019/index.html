<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fuzzy search in the dictionary with the universal Levenshtein automaton. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of the article, we considered the Levenshtein universal automaton - a powerful tool for filtering words that are separated from a ce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fuzzy search in the dictionary with the universal Levenshtein automaton. Part 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/aac/c4a/28b/aacc4a28b3764c268e842b5f5901566f.png"><br><br>  In the <a href="http://habrahabr.ru/post/275937">first part of the article,</a> we considered the Levenshtein universal automaton - a powerful tool for filtering words that are separated from a certain word W by a Levenshtein distance of no more than a given one.  Now it's time to learn how to use this tool to effectively solve the fuzzy search problem in the dictionary. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The simplest and most obvious algorithm for solving a fuzzy search problem in a dictionary using a Levenshtein automaton is a brute force algorithm.  In this case, for each word in the dictionary, the Levenshtein distance (Damerau-Levenshtein) is estimated to the search query.  An example implementation in C # can be seen in the <a href="http://habrahabr.ru/post/275937">first part of the article</a> . <br><br>  The use of even this simple algorithm gives a performance gain compared with the use of dynamic programming methods.  However, there are more efficient algorithms. <br><br><h3>  Schultz and Mihov basic algorithm </h3><br>  Consider the first such algorithm - as far as I know, it was proposed by <a href="http://link.springer.com/article/10.1007%252Fs10032-002-0082-8">Schulz and Mikhov (2002)</a> , so I will call it the basic algorithm of Schulz and Mihov, or simply the <i>basic algorithm</i> .  So, let for the allegedly distorted word <b>W</b> and the threshold value of the editing distance <b>N, a</b> deterministic Lowenstein automaton <b>A <sub>N</sub> (W) is given</b> .  Let the considered dictionary <b>D</b> also be represented in the form of a deterministic finite automaton <b>A <sub>D</sub></b> having the input alphabet <b>E.</b>  The states of automata will be denoted as <b>q</b> and <b>q <sup>D,</sup></b> respectively, the transition functions as <b>V</b> and <b>V <sup>D</sup></b> , and the set of final states as <b>F</b> and <b>F <sup>D.</sup></b>  The algorithm of fuzzy search in the dictionary proposed by Schulz and Mikhov is a standard <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D1%2581_%25D0%25B2%25D0%25BE%25D0%25B7%25D0%25B2%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D0%25BC">search</a> procedure <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D1%2581_%25D0%25B2%25D0%25BE%25D0%25B7%25D0%25B2%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D0%25BC">with a return</a> and can be described by the following pseudo-code: <br><br><img src="https://habrastorage.org/files/5ca/ca4/5b2/5caca45b223a42f5a00eafb987e88c1a.png"><br><br>  The algorithm starts with the initial states of automata.  As new characters are fed into the input, subsequent states are placed on the stack if they are not empty.  If the successive states of both automata are finite, the search word is found. <br><br>  This algorithm can still be imagined as the "intersection" of finite automata.  Only those words that correspond to the final states of both automata fall into the resulting sample.  In this case, only those prefixes that translate both automata into a non-empty state are considered. <br><br>  The computational complexity of the algorithm depends on the size of the dictionary and the editing distance <b>N.</b>  If <b>N</b> reaches the size of the longest word in the dictionary, then the algorithm reduces to a complete search of the states of the automaton <b>A <sub>D.</sub></b>  But when solving practical problems, as a rule, small values ‚Äã‚Äãof <b>N are used</b> .  In this case, the algorithm considers only a very small subset of the states of the automaton <b>A <sub>D.</sub></b>  When <b>N</b> = 0, the algorithm finds the word <b>W</b> in the dictionary over time <b>O (| W |)</b> . <br><br>  It should be noted that the described algorithm ensures the absence of losses during the search.  That is, 100% of words in the dictionary, separated from <b>W</b> by a distance of not more than <b>N,</b> will be included in the resulting sample. <br><br><h3>  Features of software implementation </h3><br>  I guess you are already familiar with such a data structure as a <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">prefix tree</a> .  The prefix tree is also known as ‚Äúloaded tree‚Äù (or ‚Äúbor‚Äù, ‚Äúray‚Äù, ‚ÄúTrie‚Äù) and is successfully used to store dictionaries.  The figure shows a prefix tree for a dictionary of four words: ‚Äúfast‚Äù, ‚Äúfunny‚Äù, ‚Äúfully‚Äù, ‚Äúfuzzy‚Äù. <br><br><img src="https://habrastorage.org/files/c73/4fa/f64/c734faf642104210832b6b069df8588b.png"><br><br>  If you are not familiar with the prefix tree, then you can familiarize yourself with the publications in which this structure is considered in detail, for example, <a href="http://habrahabr.ru/post/111874">here</a> . <br><br>  Why do I want to use a prefix tree for dictionary storage?  Because the prefix tree can be considered as a finite state machine.  Each tree node represents the state of the automaton.  The initial state is the root of the tree, and the final states are the nodes corresponding to the words.  For each node and symbol only one transition is possible - the automaton is deterministic. <br><br>  So, considering the prefix tree as a deterministic finite automaton and having the software implementation of the deterministic Levenshtein automaton, it is easy to turn the pseudo-code of the algorithm into code in any programming language.  Under the spoiler example in C #. <br><br><div class="spoiler">  <b class="spoiler_title">Basic algorithm</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Find all words in dictionary such that Levenstein distance to typo less or equal to editDistance </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">Set of possible corrections</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="typo"&gt;</span></span></span><span class="hljs-comment">Garbled word.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="dictionary"&gt;</span></span></span><span class="hljs-comment">Dictionary.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="editDistance"&gt;</span></span></span><span class="hljs-comment">Edit distance.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment"> GetCorrections(string typo, TrieNode dictionary, int editDistance) { var corrections = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment"> (); if (string.IsNullOrEmpty (typo.Trim())) { return corrections; } //Create automaton LevTAutomataImitation automaton = new LevTAutomataImitation (typo, editDistance); //Init stack with start states Stack</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TypoCorrectorState&gt;</span></span></span><span class="hljs-comment"> stack = new Stack</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TypoCorrectorState&gt;</span></span></span><span class="hljs-comment"> (); stack.Push (new TypoCorrectorState () { Node = dictionary, AutomataState = 0, AutomataOffset = 0, }); //Traversing trie with standart backtracking procedure while (stack.Count &gt; 0) { //State to process TypoCorrectorState state = stack.Pop(); automaton.LoadState (state.AutomataState, state.AutomataOffset); //Iterate over TrieNode children foreach (char c in state.Node.children.Keys) { //Evaluate state of Levenstein automaton for given letter int vector = automaton.GetCharacteristicVector (c, state.AutomataOffset); AutomataState nextState = automaton.GetNextState (vector); //If next state is not empty state if (nextState != null) { TrieNode nextNode = state.Node.children [c]; //Push node and automaton state to the stack stack.Push (new TypoCorrectorState () { Node = nextNode, AutomataState = nextState.State, AutomataOffset = nextState.Offset }); //Check if word with Levenstein distance </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;= n found if (nextNode.IsWord &amp;&amp; automaton.IsAcceptState (nextState.State, nextState.Offset)) { corrections.Add (nextNode.Value); } } } } return corrections; }</span></span></span></span></code> </pre> <br></div></div><br><br><h3>  FB-Trie Algorithm </h3><br>  Go ahead.  In <a href="http://www.cis.uni-muenchen.de/people/Schulz/Pub/aspaperCISreport.pdf">2004, Mihov and Schulz</a> proposed a modification of the above algorithm, the main idea of ‚Äã‚Äãwhich is to use a direct and inverse prefix tree in combination with splitting the search query <b>W</b> into two approximately equal parts <b>W <sub>1</sub></b> and <b>W <sub>2</sub></b> .  The algorithm is known as FB-Trie (from forward and backward trie). <br><br>  Under the inverse prefix tree, you should understand the prefix tree constructed from the inversions of all vocabulary words.  Inversion of a word, I call simply a word written backwards. <br><br>  An important point - in their work, Mihov and Schulz showed that the Damerau-Levenshtein distance between inversions of two rows is equal to the distance between the rows themselves. <br><br>  The operation of the algorithm for <b>N = 1 is</b> based on the following statement: any string <b>S</b> that is separated from the string <b>W</b> at Damerau-Levenshtein distance <b>d (S, W) &lt;= 1</b> can be divided into two parts <b>S <sub>1</sub></b> and <b>S <sub>2</sub></b> only in such a way that one of three mutually exclusive conditions: <br><br>  <b>a) d (S <sub>1</sub> , W <sub>1</sub> ) = 0 and d (S <sub>2</sub> , W <sub>2</sub> ) &lt;= 1</b> <br><br><img src="https://habrastorage.org/files/1b3/59d/857/1b359d857a1c4d6ea80f03cf192f4875.png"><br><br>  <b>b) d (S <sub>1</sub> , W <sub>1</sub> ) &lt;= 1 and d (S <sub>2</sub> , W <sub>2</sub> ) = 0</b> <br><br><img src="https://habrastorage.org/files/573/1b5/1fb/5731b51fbe3d4665a80e6e950ba6cd75.png"><br><br>  <b>c) d (S <sub>1</sub> , W <sub>1</sub> ') = 0 and d (S <sub>2</sub> , W <sub>2</sub> ') = 0</b> <br><br><img src="https://habrastorage.org/files/6a2/c4d/ff8/6a2c4dff857044a895e42b5a507c0031.png"><br><br>  In paragraph ‚Äúc‚Äù, the strings <b>W <sub>1</sub> '</b> and <b>W <sub>2</sub> '</b> are obtained from the strings <b>W <sub>1</sub></b> and <b>W <sub>2</sub></b> by replacing the last character <b>W <sub>1</sub></b> with the first character <b>W <sub>2</sub></b> and vice versa.  For example, if <b>W <sub>1</sub></b> = 'FU', and <b>W <sub>2</sub></b> = 'ZZY', then <b>W <sub>1</sub> '</b> =' FZ ', and <b>W <sub>2</sub> '</b> = 'UZY'. <br><br>  How can you quickly find in the dictionary all the words that fit the variant ‚Äúa‚Äù?  Very simple: find a node in the prefix tree with the prefix <b>W <sub>1</sub></b> , then bypass all its successors in accordance with the basic algorithm of Schulz and Mihov and select those whose keys are no more than 1 from <b>W <sub>2</sub></b> . <br><br><div class="spoiler">  <b class="spoiler_title">Option A</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//May be for some S d(S1, W1) = 0 and d(S2, W2) &lt;= 1? TrieNode lnode = ForwardDictionary.GetNode (left); if (lnode != null) { corrections.AddRange(GetCorrections(right, lnode, 1)); }</span></span></code> </pre><br></div></div><br><br>  For option ‚Äúb‚Äù, the inverse prefix tree is useful: find the node in it corresponding to the inverted string <b>W <sub>2</sub></b> , then go around all its heirs and select those whose keys are separated from the inverted <b>W <sub>1</sub></b> by no more than 1 - again, in accordance with the basic algorithm . <br><br><div class="spoiler">  <b class="spoiler_title">Option B</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//May be for some S d(S1, W1) = 1 and d(S2, W2) = 0? TrieNode rnode = BackwardDictionary.GetNode (rright); if (rnode != null) { corrections.AddRange(GetCorrections(rleft, rnode, 1)))); }</span></span></code> </pre><br></div></div><br><br>  For the ‚Äúin‚Äù variant, it is necessary to simply swap two characters in the word <b>W</b> on the boundary of the partition and check whether the received word is contained in the prefix tree. <br><br><div class="spoiler">  <b class="spoiler_title">Option B</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//May be there is a transposition in the middle? char[] temp = typo.ToCharArray (); char c = temp [llen - 1]; temp [llen - 1] = temp [llen]; temp [llen] = c; TrieNode n = ForwardDictionary.GetWord (new string(temp)); if (n != null) { corrections.Add (n.Key); }</span></span></code> </pre><br></div></div><br><br>  To solve the fuzzy search problem in the dictionary using the FB-Trie algorithm, you just need to find the three sets of words listed above and combine them. <br><br>  For <b>N = 2,</b> two more cases will need to be considered: <br><br>  <b>a) d (S <sub>1</sub> , W <sub>1</sub> ) = 0 and d (S <sub>2</sub> , W <sub>2</sub> ) &lt;= 2</b> <br><br><img src="https://habrastorage.org/files/680/6a7/c2a/6806a7c2a3894e159349e4ef2f549816.png"><br><br>  <b>b) 1 &lt;= d (S <sub>1</sub> , W <sub>1</sub> ) &lt;= 2 and d (S <sub>2</sub> , W <sub>2</sub> ) = 0</b> <br><br><img src="https://habrastorage.org/files/ebc/553/ba5/ebc553ba5987455cab1e590ab6a0bece.png"><br><br>  <b>c) d (S <sub>1</sub> , W <sub>1</sub> ) = 1 and d (S <sub>2</sub> , W <sub>2</sub> ) = 1</b> <br><br><img src="https://habrastorage.org/files/861/646/b1c/861646b1c5c64f2da958931e63d6c42f.png"><br><br>  And if the last character of the string <b>S <sub>1</sub></b> is equal to the first character <b>W <sub>2</sub></b> , and the last character <b>W <sub>1</sub></b> is equal to the first character <b>S <sub>2</sub></b> , then two more cases are possible: <br><br>  <b>d) d (S <sub>1</sub> , W <sub>1</sub> ') = 0 and d (S <sub>2</sub> , W <sub>2</sub> ') &lt;= 1</b> <br><br><img src="https://habrastorage.org/files/1d6/b45/566/1d6b455664f147bebd345c5c68e98a87.png"><br><br>  <b>d) d (S <sub>1</sub> , W <sub>1</sub> ') &lt;= 1 and d (S <sub>2</sub> , W <sub>2</sub> ') = 0</b> <br><br><img src="https://habrastorage.org/files/02a/7c4/090/02a7c40904af49bb9c097d6c10ddbdf7.png"><br><br>  The first two cases are easily detected by analogy with the options ‚Äúa‚Äù and ‚Äúb‚Äù for <b>N</b> = 1, but the Levenshtein machine is used for <b>N</b> = 2. <br><br>  The options ‚Äúd‚Äù and ‚Äúd‚Äù for <b>N</b> = 2 repeat the options ‚Äúa‚Äù and ‚Äúb‚Äù for <b>N</b> = 1, except that instead of substrings <b>W <sub>1</sub></b> and <b>W <sub>2</sub></b> , <b>W <sub>1</sub> '</b> and <b>W <sub>1</sub> ' are used</b> . <br><br>  The ‚Äúin‚Äù option is a bit more complicated.  In the first step, it is necessary to find in the direct prefix tree all the nodes corresponding to the prefixes that are no more than 1 from <b>W</b> 1 (basic algorithm).  In the second step, for each such node, it is necessary to bypass the children and select those that correspond to the keys that are no more than 1 from <b>W <sub>2</sub></b> (again, the basic algorithm). <br><br>  For <b>N</b> = 3, seven cases will need to be considered.  I will not bring them here - you can see in the original article by <a href="http://www.cis.uni-muenchen.de/people/Schulz/Pub/aspaperCISreport.pdf">Mihov and Schultz (2004)</a> .  By analogy, one can continue for arbitrary <b>N</b> , although the need for this in solving practical problems is unlikely to arise. <br><br><h3>  Performance scores </h3><br>  Curiously, the search time using the FB-Trie algorithm decreases as the word length <b>W</b> increases. <br><br>  A detailed analysis of the search time using the FB-Trie algorithm in comparison with other well-known fuzzy search algorithms can be found in Leonid Boytsov‚Äôs <a href="http://searchivarius.org/personal/leonid-boytsovs-publications">‚ÄúIndexing Methods for Approximate Dictionary Searching: Comparative Analysis‚Äù (2011)</a> .  In this paper, a thorough comparison of the search time and the amount of memory consumed for such algorithms as: <br><br><ul><li>  brute force; </li><li>  various modifications of the n-gram method; </li><li>  various modifications of the sample extension method; </li><li>  signature hashing; </li><li>  FB-Trie and other algorithms. </li></ul><br>  I will not repeat here all the numerous figures and graphs, but I will confine myself to general conclusions for natural languages. <br><br>  So, the FB-Trie algorithm provides a reasonable compromise between performance and memory consumption.  If your application needs to maintain an editing distance of 2 or more, and the dictionary contains more than 500,000 words, the FB-Trie algorithm is a rational choice.  It will provide the minimum search time at a reasonable memory consumption (about 300% of the memory occupied by the lexicon). <br><br>  If you decide to limit yourself to the <b>N</b> = 1 editing distance, or you have a small dictionary, then a number of algorithms may work faster (for example, the Mor ‚àí Fraenkel method or <a href="http://fastss.csg.uzh.ch/">FastSS</a> ), however, be prepared for increased memory consumption (up to 20,000% of the lexicon size).  If you have dozens of gigabytes of RAM to store a fuzzy index, you can use these methods for large dictionary sizes. <br><br>  So that the reader can decide how much it is - 500,000 words, I will give some figures on the number of words in the Russian language (taken <a href="http://www.speakrus.ru/dict/">from here</a> ). <br><br><ol><li>  Lopatin's spelling dictionary contains 162,240 words - the lexicon file size is 2 MB. </li><li>  The list of Russian surnames includes at least 247,780 surnames - the lexicon file size is 4.6 MB. </li><li>  The complete accentuated paradigm of the Russian language according to A. A. Zaliznyak is 2,645,347 word forms, the size of the lexicon file is about 35MB. </li></ol><br><br>  And what if you do not have the ability to store the dictionary in the form of two prefix trees?  For example, it is presented in the form of a sorted list.  In this case, the use of a Levenshtein automaton for a fuzzy search is possible, but impractical.  Perhaps - because there are various modifications of complete enumeration (for example, with clipping along the length of the word <b>| W |</b> plus minus <b>N</b> ).  It is impractical - because you will not get a performance gain compared to more simple-to-implement methods (for example, <a href="http://habrahabr.ru/post/114997">the sample extension algorithm</a> ). <br><br>  I note that the basic algorithm of Schulz and Mihov requires two times less memory than the FB-Trie algorithm.  However, you will have to pay an increase in the search time by an order of magnitude (estimation of the authors of the algorithm). <br><br>  On this consideration of fuzzy search algorithms in the dictionary using a Levenshtein automaton is considered complete. <br><br>  Yes, full C # Spellchecker source code can be found <a href="http://github.com/ibendrup/LevenshteinAutomaton">here</a> .  Probably, my implementation is not optimal in terms of performance, but it will help you understand the operation of the FB-Trie algorithm and may be useful in solving your applied problems. <br><br>  Everyone who read the publication - many thanks for your interest. <br><br><h3>  Links </h3><br><ol><li>  <a href="http://habrahabr.ru/post/275937">The first part of my publication</a> </li><li>  Lowenstein automaton and <a href="http://link.springer.com/article/10.1007%252Fs10032-002-0082-8">Schulz and Mikhov</a> basic algorithm <a href="http://link.springer.com/article/10.1007%252Fs10032-002-0082-8">(2002)</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D1%2581_%25D0%25B2%25D0%25BE%25D0%25B7%25D0%25B2%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D0%25BC">Return search</a> </li><li>  The FB-Trie algorithm in an article by <a href="http://www.cis.uni-muenchen.de/people/Schulz/Pub/aspaperCISreport.pdf">Mihov and Schultz (2004)</a> </li><li>  <a href="http://searchivarius.org/personal/leonid-boytsovs-publications">Leonid Boytsov site on fuzzy search</a> </li><li>  <a href="http://habrahabr.ru/post/114997">Good post about a fuzzy search in the dictionary and text</a> </li><li>  Post on Habr√© on the <a href="http://habrahabr.ru/post/111874/">prefix tree</a> </li><li>  <a href="http://fastss.csg.uzh.ch/">FastSS</a> algorithm </li><li>  Sources to <a href="http://github.com/ibendrup/LevenshteinAutomaton">C #</a> article </li><li>  Implementations in java: <a href="http://github.com/universal-automata/liblevenshtein-java">one</a> and <a href="http://github.com/itdraft/levenshtein-automaton">two</a> </li><li>  A set of <a href="http://www.speakrus.ru/dict/">Russian language</a> dictionaries </li></ol></div><p>Source: <a href="https://habr.com/ru/post/276019/">https://habr.com/ru/post/276019/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276009/index.html">In Lenovo software, the immutable password was sewn 12345678</a></li>
<li><a href="../276011/index.html">Unmanaged C ++ library in .NET. Full integration</a></li>
<li><a href="../276013/index.html">Practical use of Linux Deploy on desktops</a></li>
<li><a href="../276015/index.html">HPE Proactive Care Advanced - a new service for a new type of IT</a></li>
<li><a href="../276017/index.html">Adjusted sliding exam, coclassifiers, fractal classifiers and local error probability</a></li>
<li><a href="../276023/index.html">Install / Update Veeam B & R v9 on Hyper-V Server</a></li>
<li><a href="../276025/index.html">SLES 12, Watchdog Timer and IBM / Lenovo Servers</a></li>
<li><a href="../276027/index.html">Debugging and Profiling in Visual Studio 2015</a></li>
<li><a href="../276031/index.html">From Phone to Cloud: Azure Mobile Services. Where to begin?</a></li>
<li><a href="../276033/index.html">BPG format can replace animated gif and not only</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>