<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Waited for: YAML and Ansible support (no cows) in dapp</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the beginning of this year, we considered that our Open Source-utility for supporting the processes CI / CD - dapp version 0.25 - has a sufficient ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Waited for: YAML and Ansible support (no cows) in dapp</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/i4/we/xd/i4wexdrdmfpkv5hh1xj4yrydw5i.png"></div><br>  At the beginning of this year, we considered that our Open Source-utility for supporting the processes CI / CD - dapp version 0.25 - has a sufficient set of functions and work was started on innovations.  In version 0.26, the YAML syntax appeared, and Ruby DSL was declared classical (it will no longer be supported at all).  In the next version, 0.27, the main innovation can be considered the appearance of the collector with Ansible.  It's time to talk about these updates in more detail. <br><a name="habracut"></a><br><h2>  Prehistory </h2><br>  We have been developing <a href="https://github.com/flant/dapp">dapp for</a> more than 2 years and actively use in the daily service of many projects of various scales.  The first versions of the utility were designed to use <b>Chef</b> to build images.  When we added to this the fact that <b>Ruby</b> was familiar to almost all of our engineers and developers, we made the logical decision to implement the dapp as a Ruby gem.  It was considered appropriate to make the Dappfile config in the form of Ruby DSL - all the more so since we know a successful example from a close area - Vagrant. <br><br>  As the utility developed, it became clear that dapp needed a second specialization - <b>application delivery to Kubernetes</b> .  This is how <a href="https://habrahabr.ru/company/flant/blog/336170/">the Helm charts mode</a> appeared, and the engineers mastered the YAML syntax and patterns on Go, while the developers started sending patches to Helm.  On the one hand, the delivery to Kubernetes has become an integral part of the dapp, and on the other, the de facto standard in the Docker and Kubernetes ecosystem is Go.  Our dapp, being written in Ruby, is now out of the big picture: if it‚Äôs difficult for us to reuse Docker code, users often just don‚Äôt want to install Ruby on building machines - because it‚Äôs much easier and more familiar to download a binary ... As a result, the main development goals of dapp : a) translation of the code base to Go; b) implementation of the YAML syntax. <br><br>  In addition, since then, Chef has ceased to arrange us for a number of reasons, both for controlling machines and for assembling.  As it turned out, the transition to Ansible solves some of the problems not only of our DevOps engineers: the most frequent issue at conferences was the <b>support of Ansible in dapp</b> .  Thus, the third goal was the implementation of Ansible-collector. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  YAML syntax </h2><br>  I have already introduced the introduction to the YAML syntax in <a href="https://habrahabr.ru/company/flant/blog/348436/">this article</a> , but now I‚Äôll take a closer look at it. <br><br>  The build configuration can be described in the <code>dappfile.yaml</code> file (or <code>dappfile.yml</code> ).  Configuration processing steps are as follows: <br><br><ol><li>  dapp reads <code>dappfile.y[a]ml</code> ; </li><li>  a go-templating engine is started, the final YAML is rendered; </li><li>  The rendered config is broken up into YAML documents ( <code>---</code> with a line break); </li><li>  verifies that each YAML document contains a dimg or artifact attribute at the top level; </li><li>  checks the composition of the remaining attributes; </li><li>  if everything is in order, then the final config is made of the specified dimgs and artifacts. </li></ol><br>  The classic Dappfile is Ruby DSL, due to which some programming was possible: reference to the <code>ENV</code> dictionary for environment variables, defining dimg in loops, defining general assembly instructions using context inheritance.  In order not to take away such opportunities from the developers, it was decided to add <b>support for Go-templates</b> to dappfile.yml - similar to Helm's charts. <br><br>  However, we refused to inherit the context through nesting and through dimg_groups, since  it made more confusion than convenience.  Therefore, <code>dappfile.yml</code> is a linear array of YAML documents, each of which is a dimg or artifact description. <br><br>  As before, a dimg can be one and it can be nameless: <br><br><pre> <code class="hljs pgsql">dimg: ~ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: alpine:latest shell: beforeInstall: - apk <span class="hljs-keyword"><span class="hljs-keyword">update</span></span></code> </pre> <br>  Artifacts must have a name, because  Now it is not the export of files from the artifact image that is described, but the import (similar to the multi-stage capability from the Dockerfile).  Therefore, you need to specify which artifact you want to get the files from: <br><br><pre> <code class="hljs cs">artifact: application-assets ... --- dimg: ~ ... import: - artifact: application-assets <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>: /app/<span class="hljs-keyword"><span class="hljs-keyword">public</span></span>/assets after: install - artifact: application-assets <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>: /vendor to: /app/vendor after: install</code> </pre> <br>  The <code>git</code> , <code>git remote</code> , <code>shell</code> directives went from DSL to YAML almost ‚Äúas is‚Äù, but there are two points: instead of underscores, camelCase is used (as in Kubernetes) and you need not to repeat the directives, but to merge the parameters, specifying the array: <br><br><pre> <code class="hljs cs">git: - <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>: / to: /app owner: app <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>: app excludePaths: - <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>/assets - vendor - .helm stageDependencies: install: - package.json - Bowerfile - Gemfile.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> - app/assets<span class="hljs-comment"><span class="hljs-comment">/* - url: https://github.com/kr/beanstalkd.git add: / to: /build shell: beforeInstall: - useradd -d /app -u 7000 -s /bin/bash app - rm -rf /usr/share/doc/* /usr/share/man/* - apt-get update - apt-get -y install apt-transport-https git curl gettext-base locales tzdata setup: - locale-gen en_US.UTF-8</span></span></code> </pre> <br>  A basic description of all available attributes is available in the <a href="">documentation</a> . <br><br><h3>  docker ENV and LABEL </h3><br>  In <code>dappfile.yml</code> , environment variables and labels can be added as follows: <br><br><pre> <code class="hljs xml">docker: ENV: <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>: <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> ... LABELS: <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>: <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> ...</code> </pre> <br>  In YAML, it will not be possible to repeat <code>ENV</code> or <code>LABELS</code> , as it was in the Dappfile and in the Dockerfile. <br><br><h3>  Template engine </h3><br>  Templates can be used to define a common build configuration for different dimg or artifacts.  This can be, for example, a simple indication of a common base image using a variable: <br><br><pre> <code class="hljs perl">{{ $base_image := <span class="hljs-string"><span class="hljs-string">"alpine:3.6"</span></span> }} dimg: app from: {{ $base_image }} ... --- dimg: worker from: {{ $base_image }}</code> </pre> <br>  ... or something more complicated using defined templates: <br><br><pre> <code class="hljs ruby">{{ $base_image <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= <span class="hljs-string"><span class="hljs-string">"alpine:3.6"</span></span> }} {{- define <span class="hljs-string"><span class="hljs-string">"base beforeInstall"</span></span> }} - <span class="hljs-symbol"><span class="hljs-symbol">apt:</span></span> name=php update_cache=yes - <span class="hljs-symbol"><span class="hljs-symbol">get_url:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">url:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">https:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/getcomposer.org/download</span></span><span class="hljs-regexp"><span class="hljs-regexp">/1.5.6/composer</span></span>.phar <span class="hljs-symbol"><span class="hljs-symbol">dest:</span></span> /usr/local/bin/composer <span class="hljs-symbol"><span class="hljs-symbol">mode:</span></span> <span class="hljs-number"><span class="hljs-number">0755</span></span> {{- <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>}} <span class="hljs-symbol"><span class="hljs-symbol">dimg:</span></span> app <span class="hljs-symbol"><span class="hljs-symbol">from:</span></span> {{ $base_image }} <span class="hljs-symbol"><span class="hljs-symbol">ansible:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">beforeInstall:</span></span> {{- <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">"base beforeInstall"</span></span> .}} - <span class="hljs-symbol"><span class="hljs-symbol">user:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> app <span class="hljs-symbol"><span class="hljs-symbol">uid:</span></span> <span class="hljs-number"><span class="hljs-number">48</span></span> ... --- <span class="hljs-symbol"><span class="hljs-symbol">dimg:</span></span> worker <span class="hljs-symbol"><span class="hljs-symbol">from:</span></span> {{ $base_image }} <span class="hljs-symbol"><span class="hljs-symbol">ansible:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">beforeInstall:</span></span> {{- <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">"base beforeInstall"</span></span> .}} ...</code> </pre> <br>  In this example, part of the instructions for the <code>beforeInstall</code> stage <code>beforeInstall</code> defined as a common part and then connected in each dimg. <br><br>  You can read more about the capabilities of Go-templates in the <a href="https://golang.org/pkg/text/template/">documentation</a> for the text / template module and in the <a href="http://masterminds.github.io/sprig/">documentation</a> for the sprig module, the functions from which complement the standard features. <br><br><h2>  Ansible support </h2><br>  Ansible-collector consists of three parts: <br><br><ol><li>  <b>The image of dappdeps / ansible</b> , in which Python 2.7 lies, compiled with its glibc and other libraries to work in any distribution (especially important for Alpine).  Immediately installed Ansible. </li><li>  <b>Support for</b> describing the assembly of stages using Ansible in <code>dappfile.yaml</code> . </li><li>  <b>Builder in dapp</b> , running containers for stages.  Tracks specified in <code>dappfile.yml</code> are executed in these containers.  Builder creates a playbook and generates a command to launch it. </li></ol><br>  Ansible is being developed as a system for managing a large number of remote hosts, and therefore things that are relevant for a local launch can be ignored by developers.  For example, <b>there is no real-time output</b> from running commands, as was the case in Chef: an assembly may include a lengthy command, the output of which would be good to see in real time, but Ansible will show the output only after completion.  When launched via GitLab CI, this can be interpreted as a hang of a build. <br><br>  The second trouble was the <a href="https://docs.ansible.com/ansible/devel/plugins/callback.html"><b>stdout callbacks</b></a> , which are part of Ansible.  Among them was not "moderately informative."  There is either too verbose output with full result in the form of JSON, or minimalism with the host name, module name and status.  Of course, I'm exaggerating, but there really isn't a suitable module for assembling images. <br><br>  The third thing we encountered was the dependence of some Ansible modules on external utilities (not scary), Python modules (even less scary), and <b>on binary Python modules</b> (a nightmare!).  Again, the authors of Ansible did not take into account that their creation will be run separately from the system binaries and that, for example, <code>userdel</code> will not be located in <code>/sbin</code> , but somewhere in another directory ... <br><br>  The problem with binary modules is a feature of the apt module.  It uses the python-apt module as an SO-library.  Another feature of the apt module turned out that when performing a task, in case of unsuccessful loading of python-apt, an attempt is made to install a package with this module into the system. <br><br>  To solve the above problems, <a href="https://github.com/ansible/ansible/compare/stable-2.4...flant:stable-2.4%2Bdapp">a</a> ‚Äúlive‚Äù output for the raw and script task <a href="https://github.com/ansible/ansible/compare/stable-2.4...flant:stable-2.4%2Bdapp">was implemented</a> , since  they can run without Ansiballz.  I also had to implement my stdout callback, add the <code>useradd</code> , <code>userdel</code> , <code>usermod</code> , <code>getent</code> and similar utilities to dappdeps / ansible and copy the python-apt modules. <br><br>  As a result, the Ansible collector in dapp works with Linux distributions of Ubuntu, Debian, CentOS, Alpine, but not all <a href="http://docs.ansible.com/ansible/latest/modules_by_category.html">modules are</a> yet tested and therefore there is a list of modules in Dapp that are supported exactly.  If the module is used in the configuration not from the list, the assembly will not start - this is a temporary measure.  A list of supported modules can be found <a href="">here</a> . <br><br>  The build configuration using Ansible in <code>dappfile.yml</code> is similar to the <code>shell</code> configuration.  The necessary steps are listed in the <code>ansible</code> key and an array of tasks is defined for each of them - almost as in a regular playbook, only the name of the stage is indicated instead of the <code>tasks</code> attribute: <br><br><pre> <code class="hljs pgsql">ansible: beforeInstall: - <span class="hljs-type"><span class="hljs-type">name</span></span>: "Create non-root main application user" <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>: app <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: "Non-root main application user" uid: <span class="hljs-number"><span class="hljs-number">7000</span></span> shell: /bin/bash home: /app - <span class="hljs-type"><span class="hljs-type">name</span></span>: "Disable docs and man files installation in dpkg" <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>: content: | <span class="hljs-type"><span class="hljs-type">path</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span>=/usr/<span class="hljs-keyword"><span class="hljs-keyword">share</span></span>/man<span class="hljs-comment"><span class="hljs-comment">/* path-exclude=/usr/share/doc/* dest: /etc/dpkg/dpkg.cfg.d/01_nodoc install: - name: "Precompile assets" shell: | set -e export RAILS_ENV=production source /etc/profile.d/rvm.sh cd /app bundle exec rake assets:precompile args: executable: /bin/bash</span></span></code> </pre> <br>  The example is taken from the <a href="">documentation</a> . <br><br>  Now the question arises: if there is only a list of tasks in <code>dappfile.yml</code> , then where is the rest (top level playbook, inventory), how to turn on <code>become</code> and where are talking cows (or how to turn them off)?  It's time to describe how to run Ansible. <br><br>  <b>The builder</b> is <b>responsible for launching</b> - this is not a very complicated piece of code that defines the launch parameters of the Docker-container with the stage: environment variables, the ansible-playbook launch command, the necessary mounts.  Also, the builder creates a <a href="http://flant.github.io/dapp/definitions.html">directory</a> in the <a href="http://flant.github.io/dapp/definitions.html">temporary directory of the application</a> where several files are generated: <br><br><ul><li>  <code>hosts</code> - inventory for Ansible.  There is only one localhost host with the path to Python inside the mounted image dappdeps / ansible; </li><li>  <code>ansible.cfg</code> - Ansible configuration.  In the config, the <code>local</code> connection type, the path to inventory, the path to callback stdout, the paths to temporary directories and the <code>become</code> settings are specified: all tasks are started from the root user;  if you use <code>become_user</code> , then all environment variables will be accessible to the user process and <code>$HOME</code> ( <code>sudo -E -H</code> ) will be set correctly; </li><li>  <code>playbook.yml</code> - this file is generated from the list of tasks for the stage being executed.  The file specifies the <code>hosts: all</code> filter and disables the implicit fact collection by setting the <code>gather_facts: no</code> setting.  The setup and set_fact modules are in the list of supported ones, so you can use them to explicitly collect facts. </li></ul><br>  The list of tasks for the <code>beforeInstall</code> stage from the example previously turns into this <code>playbook.yml</code> : <br><br><pre> <code class="hljs coffeescript">--- hosts: all gather_facts: <span class="hljs-literal"><span class="hljs-literal">no</span></span> tasks: - name: <span class="hljs-string"><span class="hljs-string">"Create non-root main application user"</span></span> user: name: app ... - name: <span class="hljs-string"><span class="hljs-string">"Disable docs and man files installation in dpkg"</span></span> copy: content: | path-exclude=<span class="hljs-regexp"><span class="hljs-regexp">/usr/share/man/</span></span>* path-exclude=<span class="hljs-regexp"><span class="hljs-regexp">/usr/share/doc/</span></span>* dest: /etc/dpkg/dpkg.cfg.d/<span class="hljs-number"><span class="hljs-number">01</span></span>_nodoc</code> </pre> <br><h3>  Features of Ansible for assembly </h3><br><h4>  Become </h4><br>  The settings for <code>become</code> in <code>ansible.cfg</code> are: <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">become</span></span>] become = yes become_method = sudo become_flags = -E -H become_exe = path_to_sudo_insdie_dappdeps/ansible_image</code> </pre> <br>  Therefore, in the task it is enough to specify only <code>become_user: username</code> to run the script or copy from the user. <br><br><h4>  Command modules </h4><br>  Ansible has 4 modules for running commands and scripts: <code>raw</code> , <code>script</code> , <code>shell</code> and <code>command</code> .  <code>raw</code> and <code>script</code> are executed without the Ansiballz mechanism, which is slightly faster, and there is a live output for them.  Using <code>raw</code> you can run multiline ad-hoc scripts: <br><br><pre> <code class="hljs pgsql">- raw: | mvn -B -f pom.xml -s /usr/<span class="hljs-keyword"><span class="hljs-keyword">share</span></span>/maven/<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>/settings-docker.xml dependency:resolve mvn -B -s /usr/<span class="hljs-keyword"><span class="hljs-keyword">share</span></span>/maven/<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>/settings-docker.xml package -DskipTests</code> </pre> <br>  True, the <code>environment</code> attribute is not supported, but it can be circumvented as follows: <br><br><pre> <code class="hljs perl">- raw: | mvn -B -f pom.xml -<span class="hljs-keyword"><span class="hljs-keyword">s</span></span> $SETTINGS dependency:resolve mvn -B -<span class="hljs-keyword"><span class="hljs-keyword">s</span></span> $SETTINGS <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> -DskipTests args: executable: SETTINGS=<span class="hljs-regexp"><span class="hljs-regexp">/usr/share</span></span><span class="hljs-regexp"><span class="hljs-regexp">/maven/ref</span></span><span class="hljs-regexp"><span class="hljs-regexp">/settings-docker.xml /bin</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ash -e</span></span></code> </pre> <br><h4>  Files </h4><br>  At this stage, there is no mechanism for forwarding files from the repository to containers, except for the <code>git</code> directive.  To add various kinds of configs, scripts and other small files to the image, you can use the copy module: <br><br><pre> <code class="hljs pgsql"> - <span class="hljs-type"><span class="hljs-type">name</span></span>: "Disable docs and man files installation in dpkg" <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>: content: | <span class="hljs-type"><span class="hljs-type">path</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span>=/usr/<span class="hljs-keyword"><span class="hljs-keyword">share</span></span>/man<span class="hljs-comment"><span class="hljs-comment">/* path-exclude=/usr/share/doc/* dest: /etc/dpkg/dpkg.cfg.d/01_nodoc</span></span></code> </pre> <br>  If the file is large, in order not to store it inside <code>dappfile.yml</code> , you can use the Go-template and the function <code>.Files.Get</code> : <br><br><pre> <code class="hljs objectivec"> - name: <span class="hljs-string"><span class="hljs-string">"Disable docs and man files installation in dpkg"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>: content: | {{.Files.Get <span class="hljs-string"><span class="hljs-string">".dappfiles/01_nodoc"</span></span> | indent <span class="hljs-number"><span class="hljs-number">6</span></span>}} dest: /etc/dpkg/dpkg.cfg.d/<span class="hljs-number"><span class="hljs-number">01</span></span>_nodoc</code> </pre> <br>  In the future, the mechanism of connecting files to the assembly container will be implemented to make it easier to copy large and binary files, as well as use <code>include*</code> or <code>import*</code> . <br><br><h4>  Templates </h4><br>  About go-patterns in <code>dappfile.yaml</code> has already been said.  Ansible for its part supports jinja2 templates, and the separators of the two systems are the same, so the jinja call needs to be escaped from the Go template: <br><br><pre> <code class="hljs pgsql"> - <span class="hljs-type"><span class="hljs-type">name</span></span>: "create temp file for archive" tempfile: state: directory register: tmpdir - <span class="hljs-type"><span class="hljs-type">name</span></span>: Download archive get_url: url: https://cdn.example.com/files/archive.tgz dest: <span class="hljs-string"><span class="hljs-string">'{{`{{ tmpdir.path }}`}}/archive.tgz'</span></span></code> </pre> <br><h4>  Debugging build issues </h4><br>  When performing a task, some kind of error may occur, but the messages on the screen are sometimes not enough to understand.  In this case, you can start by specifying the environment variable <code>ANSIBLE_ARGS="-vvv"</code> - then the output will contain all the arguments for tasks and all the arguments of the results (similar to using json stdout callback). <br><br>  If the situation is not clarified, you can run the assembly in introspect mode: <code>dapp dimg bulid --introspect-error</code> .  Then the build will stop after the error and the shell will be launched in the container.  The command that caused the error will be visible, and in the adjacent terminal you can go to the temporary directory and edit the <code>playbook.yml</code> : <br><br><img src="https://habrastorage.org/webt/lb/v1/mg/lbv1mgwgcr6-svspffwub8k7qhi.png"><br><br><h2>  Go to go </h2><br>  This is our third goal in the development of dapp, but from the user's point of view, it makes little difference, besides simplifying the installation.  For release 0.26, the parser <code>dappfile.yaml</code> was implemented on Go.  Now, work continues on translating the main dapp functionality to Go: running assembly containers, builders, working with Git.  Therefore, it will not be superfluous for your help in testing - including Ansible modules.  We are waiting for the issue on <a href="https://github.com/flant/dapp">GitHub</a> or go to our group in the Telegram: <a href="https://t.me/dapp_ru">dapp_ru</a> . <br><br><h2>  PS </h2><br>  <b>So what's up with the cows?</b>  The cowsay program is not in dappdeps / ansible, and the callback stdout used does not call those methods where cowsay is enabled.  Unfortunately, Ansible in dapp without cows (but no one will stop you from creating an issue). <br><br><h2>  Pps </h2><br>  Read also in our blog: <br><br><ul><li>  " <a href="https://habrahabr.ru/company/flant/blog/333682/">Officially present dapp - DevOps utility to maintain the CI / CD</a> "; </li><li>  ‚Äú <a href="https://habrahabr.ru/company/flant/blog/348436/">Build projects with dapp.</a>  <a href="https://habrahabr.ru/company/flant/blog/348436/">Part 1: Java</a> ; </li><li>  ‚Äú <a href="https://habrahabr.ru/company/flant/blog/345580/">Build and heat applications in Kubernetes using dapp and GitLab CI</a> ‚Äù; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/336212/">Practice with dapp.</a>  <a href="https://habrahabr.ru/company/flant/blog/336212/">Part 1: Build simple applications</a> "; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/336170/">Practice with dapp.</a>  <a href="https://habrahabr.ru/company/flant/blog/336170/">Part 2. Deploying Docker images in Kubernetes with the help of Helm</a> ‚Äù; </li><li>  ‚Äú <a href="https://habrahabr.ru/company/flant/blog/324274/">We assemble Docker images for CI / CD quickly and conveniently along with dapp (review and video of the report)</a> ‚Äù. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/351838/">https://habr.com/ru/post/351838/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351828/index.html">Welcome to Badoo PHP Meetup April 7</a></li>
<li><a href="../351830/index.html">The Department of Information Technology, Communications and Information Protection of the City of N requires ...</a></li>
<li><a href="../351832/index.html">‚ÄúTolik - sweetheart‚Äù, or as we did a survey of IT-satisfaction for 20 thousand people</a></li>
<li><a href="../351834/index.html">Blockchain on Go. Part 5: Addresses</a></li>
<li><a href="../351836/index.html">Sound games: an invisible market awaits heroes</a></li>
<li><a href="../351842/index.html">"From Japan to Singapore": a new submarine cable will pass through 9 countries in Asia</a></li>
<li><a href="../351844/index.html">Thymeleaf Tutorial: Chapter 8. Template Layout</a></li>
<li><a href="../351846/index.html">VR in our life: travel, tours and pornography</a></li>
<li><a href="../351848/index.html">Russian VR market: why not</a></li>
<li><a href="../351850/index.html">VR yesterday, today and tomorrow: one of the first opinions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>