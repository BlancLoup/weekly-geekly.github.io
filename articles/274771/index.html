<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Details of the test-first, which is so lacking</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We all have heard about test-first, a development philosophy that encourages writing tests before code. I am sure that anyone who tried to use this me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Details of the test-first, which is so lacking</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/eca/323/744/eca3237444cf4d828fa4defabade3685.jpg" align="left">  We all have heard about test-first, a development philosophy that encourages writing tests before code.  I am sure that anyone who tried to use this method in practice, faced with the fact that he simply can not write a test before the function (usually in this case just ignore this problem and violate the test-first locally).  I believe that the reason for such failures is fundamental, and I will try to show why. <br><br>  <i>To begin with, it should be clarified that hereinafter I will speak about testing a function in the broad sense of the word as testing some conditional primitive code unit.</i>  <i>Let us leave aside the question of what kind of similar unit should be tested (for example, a method or a class); these details will not affect the further course of reasoning.</i>  <i>I will use the expression "function testing" in this sense throughout the article.</i> <br><br>  It may seem to you that the industry has long figured out all the problems associated with the test-first, and the reason for all possible failures is only that we, as developers, do not have sufficient qualifications to successfully use the necessary techniques, and not at all some fundamental problems .  Alas, here and there different programmers ask the same questions, how exactly to do test-first, and get sometimes unintelligible answers.  I think, without exaggeration, we can say that the community around the world suspects something, but a lot remains unsaid. <br><a name="habracut"></a><br><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: absolute; visibility: hidden; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="639794835499581440"></twitter-widget><blockquote class="twitter-tweet" lang="ru" data-twitter-extracted-i1553524168727370676="true"><p lang="en" dir="ltr">  Red-green-refactor is not enough to actually use as a workflow.  In real life TDD is more like this: <a href="http://t.co/TuGxzrQQkg">pic.twitter.com/TuGxzrQQkg</a> </p>  - Sarah Mei (@sarahmei) <a href="https://twitter.com/sarahmei/status/639794835499581440">September 4, 2015</a> </blockquote><script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's try to understand the problems that can fundamentally prevent us from being guided by the test-first in the form in which it is usually stated.  Plan our reasoning: <br><br><ol><li>  In general, it is possible to write a test for a function in advance only if we consider it as a black box. </li><li>  In the general case, the function as a black box should not be considered (or even impossible) in the test. </li><li>  From points 1 and 2 it immediately follows that in the general case it is not necessary (or even impossible) to write a test for a function in advance. </li><li>  What to do? </li></ol><br><h1>  1. The unwritten function can only be tested as a black box. </h1><br>  <i>The term test-first is closely related to another, much more popular today: <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0_%25D1%2587%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B7_%25D1%2582%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">TDD</a> .</i>  <i>I will not dwell on the differences of one technique from another, suffice it to say that test-first is an integral part of TDD (although it can also be used separately from it).</i>  <i>Further in the article I will talk about test-first, keeping in mind, however, that everything said with minimal clarification is also true for TDD.</i> <br><br>  At the moment when test-first suggests that I write a test for a function, all I know about it is its interface.  It may not be final, but in order to begin development, it is supposed to decide on at least some of its versions.  Traditionally, you can consider two main parts of the interface: input and output.  But it should be understood that for a function, the input data is not only the parameters with which it is called, but the output is not only what it returns directly.  A function can have several technical ways to return values: for example, the usual <code>return</code> , exceptions, and writing to parameters (this can all be called differently).  In addition, the state of the system under test can also act as input and output data.  (The simplest example of such interaction with the state of the system can be a function that manipulates global variables. Despite its degeneracy, this situation is not exceptional: the interaction point can be the objects that the method is called from, singletones, global pools, databases - in any form etc.) <br><br>  So, all the knowledge that is available to me about the function before writing a test is its interface in the broad sense of the word.  And in the context of this context I put the knowledge not only about <i>how the</i> function works with the data, but also about what <i>it</i> does with them (I, of course, know the purpose of the function).  Obviously, tests written with only the interface taken into account are black box testing: the internal logic and function source code are not available to me, at least simply because I have not developed this logic and have not yet written the code. <br><br>  Perhaps you believe that testing the black box is a great idea, and this is exactly what we need, and we would use this technique even if we already had the code.  However, in the next section, I will try to show what potential problems this poses and why the widespread use of such an approach may be inappropriate.  Despite the fact that this may seem obvious, a certain formalization here does not hurt at all. <br><br><h1>  2. The unwritten function should not be tested as a black box. </h1><br>  One of the main tasks facing the programmer who writes the test is the selection of input data on which the function should be checked. <br><br>  As a rule, in modern industrial development, theoretical proof of the loyalty of programs (a) is practically impossible and (b) is not required.  Much of the confidence that a program does what it should is based on a certain hypothesis, which the programmer puts into a simpler set of hypotheses with the help of tests, an informal understanding of which would be more accessible. <br><br>  What I mean?  Most often, it is obvious to me that a function behaves identically on some subset of the input data space, which is usually called the "equivalence class".  Saying ‚Äúobviously‚Äù, I mean the very hypothesis on which my belief is built that my program works as it should (in fairness it should be noted that this is a common problem in all engineering disciplines: some things have to be done).  In the absence of any hypotheses, any testing would be useless;  only formal proof (which, I repeat, on the verge of the impossible) would help me. <br><br>  But if there is such a hypothesis about the presence of equivalence classes, it is enough for me to test the function of the function on only one input data in order to make sure that it functions correctly throughout the class.  So, the analysis of the splitting of all possible input data into equivalence classes, in order to select test examples for them, is one of the main tasks that the author of the test faces. <br><br>  But when testing with the black box method, ignoring the possible presence of equivalence classes, you cannot choose these examples in any normal way - there will be either too many of them, and extra work will be done, or too little, and testing will not be completed. <br><br>  How will knowledge of code affect our choice of equivalence classes?  Two main ways: we can (a) use the fact that part of the code has already been tested, and (b) analyze the details of the algorithm. <br><br>  Let's talk about each of them in more detail. <br><br><h3>  With a black box it is not known what has already been tested. </h3><br>  Let me start with an example.  I'm going to write the function <code>number_of_german_letters(str)</code> , which returns the number of letters of the German alphabet contained in the string <code>str</code> . <br><br>  <i>This task, by the way, is not as simple as it may seem.</i>  <i>The German alphabet contains all Latin letters (A ‚Äî Z), three letters with umlauts (√Ñ, √ñ, √ú) and an etcet (√ü) ligature.</i>  <i>Here are at least a few things that you can forget to think about: letters with umlauts in Unicode are present both in the form of independent symbols, and in the form of a combination of the Latin letter symbol and the umlaut symbol.</i>  <i>The letter √ü has only a small-line outline (if a word with √ü is written in capital letters, then it is replaced with SS), <b>but</b> in Unicode 5.1 there is a capital pattern: ).</i>  <i>I am sure that I didn‚Äôt take something into account (for example, I just don‚Äôt know if the old version of the ligature ‚Äî ≈øs ‚Äî is being used and whether it should be considered German).</i> <br><br>  The question immediately arises: do I have a function that checks whether the letter belongs to the German alphabet (for example, <code>is_german_letter</code> )?  If there is and I will use it in <code>number_of_german_letters</code> , then I will not need to re-check the recognition of German letters.  It is necessary to check only the code that considers the German letters: the fact that he correctly recognizes them, already "proves" the test for <code>is_german_letter</code> .  Rechecking is not only useless, but also, most likely, harmful. <br><br>  If re-checking does not seem harmful to you, here are a few arguments that can convince you: <br><br><ul><li>  If I recheck the work of the <code>is_german_letter</code> function in <code>number_of_german_letters</code> , then, logically, I should recheck still lower-level functions, including the library for working with unicode, the meaninglessness of which is more obvious. </li><li>  Exactly the same logic is true when using <code>number_of_german_letters</code> itself in higher-level functions, including those that give this data to the user in the form of a picture (for example), which will be a waste of energy.  The fallacy of this approach is particularly noticeable when it comes to the function wrapper, which adds little or nothing.  If I get the functions <code>number_of_german_letters_int</code> , <code>number_of_german_letters_float</code> and <code>number_of_german_letters_str</code> , then I‚Äôll have to repeat all the tests for <code>number_of_german_letters</code> in each of them (well, if we follow the same logic, for all the more low-level functions, I can also draw the <code>number_of_german_letters_int</code> , and the <code>number_of_german_letters_str</code> will also have the numbers of the <code>number_of_german_letters_int</code> , and the <code>number_of_german_letters_str</code> will also be the numbers of the <code>number_of_german_letters_int</code> , and the <code>number_of_german_letters_float</code> also be the <code>number_of_german_letters_str</code> , and if you follow the same logic. </li><li>  Although the counterargument can be that the full retesting has its own bonus.  In conditions when each test rechecks the function as a whole, without knowing about its dependencies and its internal structure, the test <i>really</i> informs whether this function works.  Under the conditions of testing only the new one that the function introduces, any red test may indicate the inoperability of <i>any other</i> function (since the dependencies are unknown, and as many as others may depend on the ‚Äúreddened‚Äù function).  However, usually this interpretation of the results is quite enough and this is not a problem - you can just fix first what broke.  Full retesting at every level is not worth it. </li></ul><br>  However, I remind you that we are dealing with black box testing, which means that we do not know whether the <code>is_german_letter</code> function will be used.  But this knowledge plays a crucial role in the selection of the input data sets discussed above.  If <code>is_german_letter</code> used, the strings <code>abc1√ñ</code> and <code>abc1√ü</code> actually test the same, that is, they represent the same set of input conditions (equivalence within which is postulated by my hypothesis).  However, if the <code>number_of_german_letters</code> determines the ‚ÄúGermanity‚Äù of the letters independently, it is quite possible that these lines test different aspects of the function. <br><br>  It is also completely unknown whether this function will work correctly with Unicode: since this is a black box, I cannot be sure that any ready-to-use, tested library will be used for working with Unicode!  You need to check how the function behaves on various non-valid Unicode sequences, for example. <br><br>  So, testing the function as a black box, I have to repeat the tests already done again and again.  Yes, there are some features that I subconsciously trust (such as a library for working with Unicode, for example), but this trust does not have a clear framework.  It is worth adding that it is advisable to formulate a testing task not as ‚Äúcheck everything that a function does‚Äù, but ‚Äúcheck only the logic that it <i>introduces</i> ‚Äù.  If the function can only count German letters, then the test should check its ability to read letters.  True, I would also like to make sure that it calls the correct function to determine the ‚ÄúGermanity‚Äù of letters (that is, to check the integration), but for this it is usually enough to have one test, rather than a full retest.  (There is a theoretical justification for this: with this approach, the function still has one equivalence class, which we confirm with one test.) <br><br>  All this greatly limits my ability to test using the black box method.  We will talk about how to solve this problem in the fourth part, but first consider another factor that impedes such testing. <br><br><h3>  Unknown algorithm details </h3><br>  Obviously, when testing a black box, we don‚Äôt have knowledge of the algorithms used inside it (that's why it is a black box).  It seems that this does not always interfere with the choice of data for testing: sometimes at least some of them can be selected on the basis of the formulation of the problem.  But this is a false impression: all such considerations may turn out to be incorrect with different implementations of the functional.  Whether there is a branch in the function code or not, whether libraries are used or not ‚Äî this all influences which test data you need to select. <br><br>  An interesting example is optimization.  The function code may work in a different way on values ‚Äã‚Äãthat appear to be uniform.  For example, I can multiply by 2 <sup>n</sup> on a binary processor with the help of shift operation, not multiplication: this optimization makes separate checks necessary, but the formulation of the problem itself (multiplication of two numbers) in no way outlines the power of two.  Sometimes the exclusivity and heterogeneity of those or other values ‚Äã‚Äãcan be completely unclear before implementation. <br><br>  To be fair, it should be noted that optimization can also be viewed as a separate feature that can be added on a separate iteration, with its own test-first.  And yet one should not think that an unexpected jump in values ‚Äã‚Äãis an exceptional rarity.  Two more vivid examples come to my mind: <br><br><ul><li>  When setting the lifetime of a value in memcached, any value greater than <code>60*60*24*30</code> is considered the number of seconds since the beginning of the UNIX epoch, and the rest is the <i>number of seconds from the current moment</i> . </li><li>  In Ruby, strings of up to 23 characters are stored in memory differently than those that are longer. </li></ul><br>  It may seem to you that this and the previous paragraph have much in common with each other, and you will be right: these are different manifestations of the same problem.  The first paragraph deals mainly with tests that seem to be necessary but not needed, while the second, on the contrary, deals with tests that seem unnecessary but necessary. <br><br><h1>  3. Conclusions from points 1 and 2 </h1><br>  So, in point 1, I tried to show that test-first inevitably forces us to deal with testing the black box.  In paragraph 2, it describes the fundamental and intractable problems that arise when testing a black box.  If the writing in clauses 1 and 2 is correct, it is necessary to recognize that test-first is generally associated with problems that we have no way to avoid. <br><br>  What to do?  In the next paragraph, we will talk about possible test-first modifications that will help us get around these problems (since we have no fundamental way to solve them).  It should also be noted that, although what has been said is primarily applicable to unit-tests of a function, this is also true for integration testing (which is often the case with the black box). <br><br><h1>  4. How to work with test-first </h1><br>  So, we are faced with the task of a certain refinement of test-first, which would help us get around the problems mentioned in the previous paragraphs.  However, these modifications, if possible, should not deprive us of the advantages and bonuses that we would like to receive from the test-first. <br><br>  What does test-first give us?  This is quite an extensive topic, different authors point to different advantages, a comparative analysis of which is beyond the scope of this article, so I‚Äôll just give you a non-exhaustive list: <br><br><ul><li>  Test-first helps the programmer to more clearly understand what the function should do, even before he started writing it. </li><li>  The programmer can also test the interface before the start of the implementation and, perhaps, find some problems in it at an early stage, when it is almost worthless to abandon it. </li><li>  You will most likely not write untested or poorly testable code using test-first. </li><li>  Test-first as a whole disciplines the development: with it you will not have the opportunity to ‚Äúforget‚Äù about some tests, and you will most likely not even think of writing functions of 500 lines (to test such a function, as a rule, is monstrous time-consuming task). </li></ul><br>  Next, I will give a set of techniques that I use in my daily work and which allow me to combine the charm and benefits of the test-first, avoiding, however, the negative consequences discussed in the preceding paragraphs.  They are based on the fact that the concept of "test" includes both components that can be written before the code, and those that can not.  They must be separated from each other by introducing another level of abstraction. <br><br><h3>  Write test pattern before function </h3><br>  We have already decided that there is no way to write an exhaustive test suite before the code, so my solution is this: I create a special test pattern. <br><br>  Let's talk more about what I call this pattern.  Strictly speaking, any test can be represented as a code that iterates over a set of pairs ( <i>IN, OUT</i> ) and verifies that with the input data, the <i>IN</i> function returns the <i>OUT</i> output.  This set of pairs will be referred to as the table.  Let me remind you that we are talking about the interface of the function in the broad sense of the word (see clause 1).  In practice, <i>IN</i> and <i>OUT</i> can be as complex as you like, but in our example with <code>number_of_german_letters</code> these are likely to be pairs ( <i>source_string, letter_number</i> ).  So, considering all that was said in the previous paragraphs, it is difficult to create a table before writing the code, but I can write the code that will check the next pair of <i>IN</i> and <i>OUT</i> , knowing only the interface.  Or, speaking less formally, I can choose what and how exactly I want to check, but I still can not know exactly what values. <br><br>  If you look at the test as a code serving a similar table, then before the function I can already write this code, but I still can not fill the table with data.  That is, I repeat, I already know how to set the initial parameters of the function and how to remove the result of its work from the system under test, but I still do not know which of these pairs to include in my test.  What does such a test look like in practice?  Applying this approach to our <code>number_of_german_letters</code> function, if there is an internal function defining ‚ÄúGermanity,‚Äù we can get away with a small number of rows in this table, whereas, if not, the table will have to be filled with much more.  But the test pattern in both cases will be the same. <br><br>  So, under the test pattern, I mean such a code, in which it remains only to put pairs ( <i>IN, OUT</i> ).  You can start, for example, by placing all your checks inside a loop on an empty table, then all the code will be ready, but not yet executed (since the loop does not iterate).  And although this type most closely matches the idea under discussion, in practice I practically do not use it.  Instead, I usually use this idea in a somewhat simplified form. <br><br>  Instead of looping over the table, I simply write code that corresponds to one iteration with one pair of values.  What values ‚Äã‚Äãdo I choose?  This does not play a fundamental role, since one such pair will never be redundant.  <i>IN</i> will always belong to some set of values ‚Äã‚Äãon which I am going to test, I choose one set or a dozen as a result, as in the aggregate all sets must cover all the values ‚Äã‚Äãanyway.  And even in the case of a primitive wrapper, this single check will be useful because it will verify the integrity of integration with other functions.  When I need to extend the test to check more than one pair ( <i>IN, OUT</i> ), I can easily wrap this code in a loop on the table (or just accumulate checks if it seems more adequate to me). <br><br><h3>  Return to the test after writing the function </h3><br> ,   ,    ,    (      ).        ,       -   , . .     (      ). <br><br>            ,  ,     (    ). <br><br>       :     .   ,       ,       , ,        ,      , , ,      . ,       .   ,          ,  ,            . <br><br> ,     ,    test-first  test-template-first,         ,    .       ,          . <br><br><h3>   </h3><br>  test-first,   ,    <i></i>    .   ,      ,          ; ,     ,          .  ,  ,    ,   <i></i> - ,            ,    ,     . <br><br> ,      ,     ,        ,     .         ,         . <br><br>                ,       ,   ,       ¬´¬ª  .   ,  :   ,       ,     .     test-first  test-last,     . <br><br> ,   : test-first ‚Äî      ,      ,      ,     ,      . <br><br>   ‚Äî    (,      ),         . <br><br><h1>  findings </h1><br>   , test-first ‚Äî   ,    ,      ,     ,      .          ,   ,            .  ,  -         ,    ,   ,           ,      . <br><br> <i>        ‚Äî <a href="https://habrahabr.ru/users/nickolas_v/" class="user_link">nickolas_v</a> ,          ( ) ,       .</i> </div><p>Source: <a href="https://habr.com/ru/post/274771/">https://habr.com/ru/post/274771/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274749/index.html">LetsEncrypt in Go</a></li>
<li><a href="../274757/index.html">Rust in 2016</a></li>
<li><a href="../274759/index.html">Well tuned emacs</a></li>
<li><a href="../274765/index.html">Software Internet gateway for not a small company (Shorewall, buns). Part 4</a></li>
<li><a href="../274767/index.html">ProDBG switches to Rust</a></li>
<li><a href="../274775/index.html">Automatically launching Libre / OpenOffice in listening mode from Python</a></li>
<li><a href="../274779/index.html">Work with PGP digital signatures using the Bouncy Castle Cryptography Library in Java</a></li>
<li><a href="../274785/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ193 (January 3 - 10, 2016)</a></li>
<li><a href="../274787/index.html">Happy Birthday to Donald Knut</a></li>
<li><a href="../274789/index.html">Open Source Society University</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>