<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a simple interpreter in C ++ using TDD, part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part was written lexer . Further development of the parser will be considered. 

 Parser 
 The parser will be implemented using the sorti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a simple interpreter in C ++ using TDD, part 2</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/231657/">first part was written lexer</a> .  Further development of the parser will be considered. <br><br><h4>  Parser </h4><br>  The parser will be implemented using the sorting station algorithm, since it is quite simple and does not need recursion.  The algorithm itself is as follows: <br><br>  At the beginning, an empty output stream and an empty stack are given.  Let's start reading tokens from the input stream in turn. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  If this number, then pass it to the output stream. </li><li>  If this is a left-associative operator, then we push the tokens from the stack into the output stream until it is empty, or the bracket does not meet its top, or the operator with lower priority. </li><li>  If this is an opening bracket, then put it on the stack. </li><li>  If this is a closing parenthesis, then push the tokens from the stack into the output stream until the opening bracket is detected.  Push the opening bracket from the stack, but do not pass it to the output stream.  If the stack is empty and the parenthesis is not found, then we generate an error. </li></ul><br>  After reaching the end of the input stream, push all the remaining operators on the stack into the output stream.  If anything other than operators is found in it, then we generate an error. <br><br>  Let us estimate what tests may be needed to start. <br><br><ul><li>  When an empty list is received, an empty list is returned. </li><li>  When getting a list with one number, it returns a list with that number. </li><li>  Upon receipt of [1 + 2], it returns [1 2 +]. </li><li>  Upon receipt of [1 + 2 + 3], it returns [1 2 + 3 +], since the + operator is left associative. </li><li>  Upon receipt of [1 * 2 + 3], [1 2 * 3 +] is returned. </li><li>  When receiving [1 + 2 * 3], [1 2 3 * +] is returned, because the * operator has higher priority. </li></ul><br>  We will deal with brackets and errors later.  So, we will write the first test from the list. <br><br><pre><code class="cpp hljs">TEST_CLASS(ParserTests) { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEST_METHOD(Should_return_empty_list_when_put_empty_list) { Tokens tokens = Parser::Parse({}); Assert::IsTrue(tokens.empty()); } };</code> </pre> <br><a name="habracut"></a><br>  Like last time, the parser will be a free function in the <code>Parser</code> namespace. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Parser { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Tokens </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tokens &amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(); } } <span class="hljs-comment"><span class="hljs-comment">// namespace Parser</span></span></code> </pre><br>  Make the test pass by applying ({} ‚Üí nil). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Tokens </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tokens &amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; }</code> </pre><br>  The following test is almost the same as the previous one. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_parse_single_number) { Tokens tokens = Parser::Parse({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>) }); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>) }, tokens); }</code> </pre><br>  Applying (constant ‚Üí scalar) let's deal with it. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Tokens </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tokens &amp;tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokens; }</code> </pre><br><ul><li>  <s>When an empty list is received, an empty list is returned.</s> </li><li>  <s>When getting a list with one number, it returns a list with that number.</s> </li><li>  Upon receipt of [1 + 2], it returns [1 2 +]. </li><li>  ... </li></ul><br>  Further more interesting, it is necessary to process several tokens at once. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_parse_num_plus_num) { Tokens tokens = Parser::Parse({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>) }); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Plus) }, tokens); }</code> </pre><br>  To begin, slightly change the <code>Parse</code> function without violating previous tests. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Tokens </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tokens &amp;tokens)</span></span></span><span class="hljs-function"> </span></span>{ Tokens output; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Token &amp;token : tokens) { output.push_back(token); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; }</code> </pre><br>  Now it‚Äôs easy to add a stack for operations and get a test to pass <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Tokens </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tokens &amp;tokens)</span></span></span><span class="hljs-function"> </span></span>{ Tokens output; Tokens <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Token &amp;token : tokens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(token.Type() == TokenType::Number) { output.push_back(token); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.push_back(token); } } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy(<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.crbegin(), <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.crend(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(output)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; }</code> </pre><br><ul><li>  <s>Upon receipt of [1 + 2], it returns [1 2 +].</s> </li><li>  Upon receipt of [1 + 2 + 3], it returns [1 2 + 3 +], since the + operator is left associative. </li><li>  ... </li></ul><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_parse_two_additions) { Tokens tokens = Parser::Parse({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>) }); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Plus) }, tokens); }</code> </pre><br>  The test does not pass, since all operators are located at the end of the list.  We will throw everything from the stack to the output list with each detection of the operator. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Tokens </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tokens &amp;tokens)</span></span></span><span class="hljs-function"> </span></span>{ Tokens output, <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> popAll = [&amp;]() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.empty()) { output.push_back(<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.back()); <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.pop_back(); }}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Token &amp;token : tokens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(token.Type() == TokenType::Operator) { popAll(); <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.push_back(token); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } output.push_back(token); } popAll(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; }</code> </pre><br>  Understand the priority of operators.  Add a test for the function that will determine the priority of the operator transferred to it. <br><br><ul><li>  <s>Upon receipt of [1 + 2 + 3], it returns [1 2 + 3 +], since the + operator is left associative.</s> </li><li>  Pairs of operators + - and * / should have equal priorities. </li><li>  The precedence of the + and - operators must be less than that of * and / </li><li>  ... </li></ul><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_get_same_precedence_for_operator_pairs) { Assert::AreEqual(Parser::PrecedenceOf(Operator::Plus), Parser::PrecedenceOf(Operator::Minus)); Assert::AreEqual(Parser::PrecedenceOf(Operator::Mul), Parser::PrecedenceOf(Operator::Div)); }</code> </pre><br>  Add the PrecedenceOf method to the Parser namespace and apply ({} ‚Üí nil). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrecedenceOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  The test passes, proceed to the next. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_get_greater_precedence_for_multiplicative_operators) { Assert::IsTrue(Parser::PrecedenceOf(Operator::Mul) &gt; Parser::PrecedenceOf(Operator::Plus)); }</code> </pre><br>  Apply (unconditional ‚Üí if). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrecedenceOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator op)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (op == Operator::Mul || op == Operator::Div) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><ul><li>  <s>Pairs of operators + - and * / should have equal priorities.</s> </li><li>  <s>The precedence of the + and - operators must be less than that of * and /</s> </li><li>  Upon receipt of [1 * 2 + 3], [1 2 * 3 +] is returned. </li><li>  When receiving [1 + 2 * 3], [1 2 3 * +] is returned, because the * operator has higher priority. </li></ul><br>  Let's start with the last test, as it seems simpler. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_parse_add_and_mul) { Tokens tokens = Parser::Parse({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::Plus), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(Operator::Mul), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>) }); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(<span class="hljs-number"><span class="hljs-number">2</span></span>), Token(<span class="hljs-number"><span class="hljs-number">3</span></span>), Token(Operator::Mul), Token(Operator::Plus) }, tokens); }</code> </pre><br>  It does not pass, because the parser should not push operators with lower priority from the stack.  Add to the lambda, pushing operations from the stack, a predicate that determines when to stop. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Tokens </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tokens &amp;tokens)</span></span></span><span class="hljs-function"> </span></span>{ Tokens output, <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> popToOutput = [&amp;output, &amp;<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> whenToEnd) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.empty() &amp;&amp; !whenToEnd(<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.back())) { output.push_back(<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.back()); <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.pop_back(); }}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Token ¬§t : tokens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(current.Type() == TokenType::Operator) { popToOutput([&amp;](Operator top) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PrecedenceOf(top) &lt; PrecedenceOf(current); }); <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.push_back(current); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } output.push_back(current); } popToOutput([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; }</code> </pre><br>  To test the algorithm, add the last test, making it a bit more complicated.  Let's try to handle a complex expression with several operations. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_parse_complex_experssion) { <span class="hljs-comment"><span class="hljs-comment">// 1 + 2 / 3 - 4 * 5 = 1 2 3 / + 4 5 * - Tokens tokens = Parser::Parse({ Token(1), Token(Operator::Plus), Token(2), Token(Operator::Div), Token(3), Token(Operator::Minus), Token(4), Token(Operator::Mul), Token(5) }); AssertRange::AreEqual({ Token(1), Token(2), Token(3), Token(Operator::Div), Token(Operator::Plus), Token(4), Token(5), Token(Operator::Mul), Token(Operator::Minus) }, tokens); }</span></span></code> </pre><br>  He immediately passes.  Passing tests without writing any code is a dubious practice, but sometimes useful for behaviors in which you are not completely sure.  Function <code>Parse</code> , written in a functional style, of course, is short and concise, but poorly expandable.  Like last time, we will allocate a separate class into the <code>Detail</code> namespace and transfer all the functionality of the parser into it, leaving the <code>Parse</code> function as the facade.  To do this is quite easy, because you do not need to be afraid to break anything. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Tokens </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tokens &amp;tokens)</span></span></span><span class="hljs-function"> </span></span>{ Detail::<span class="hljs-function"><span class="hljs-function">ShuntingYardParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tokens)</span></span></span></span>; parser.Parse(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser.Result(); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Class Detail :: ShuntingYardParser</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Detail { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShuntingYardParser</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ShuntingYardParser(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Tokens &amp;tokens) : m_current(tokens.cbegin()), m_end(tokens.cend()) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; m_current != m_end; ++m_current) { ParseCurrentToken(); } PopToOutputUntil(StackIsEmpty); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Tokens &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_output; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StackIsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseCurrentToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(m_current-&gt;Type()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TokenType::Operator: ParseOperator(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TokenType::Number: ParseNumber(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseOperator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PopToOutputUntil([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PrecedenceOf(m_stack.back()) &lt; PrecedenceOf(*m_current); }); m_stack.push_back(*m_current); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_output.push_back(*m_current); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PopToOutputUntil</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">whenToEnd</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!m_stack.empty() &amp;&amp; !whenToEnd()) { m_output.push_back(m_stack.back()); m_stack.pop_back(); } } Tokens::const_iterator m_current; Tokens::const_iterator m_end; Tokens m_output; Tokens m_stack; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace Detail</span></span></code> </pre><br></div></div><br>  Add support for brackets.  Make a list of tests, starting with the simplest to implement. <br><br><ul><li>  Upon receipt of [(1)], [1] is returned. </li><li>  Upon receipt of [(1 + 2) * 3], [1 2 + 3 *] is returned. </li><li>  Upon receipt of [1)], an exception is generated. </li><li>  Upon receipt of [(1], an exception is generated. </li></ul><br>  Add the first test. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_skip_paren_around_number) { Tokens tokens = Parser::Parse({ Token(Operator::LParen), Token(<span class="hljs-number"><span class="hljs-number">1</span></span>), Token(Operator::RParen) }); AssertRange::AreEqual({ Token(<span class="hljs-number"><span class="hljs-number">1</span></span>) }, tokens); }</code> </pre><br>  Since at the moment we do not distinguish brackets from other operators, it does not work.  Let's make a small change (unconditional ‚Üí if) to the <code>ParseOperator</code> method. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseOperator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Operator currOp = *m_current; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(currOp) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::LParen: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::RParen: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: PopToOutputUntil([&amp;]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PrecedenceOf(m_stack.back()) &lt; PrecedenceOf(currOp); }); m_stack.push_back(*m_current); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Before adding the next test, we will refactor the tests currently written.  Create static token instances for operators and some numbers.  This will significantly reduce the amount of code in the tests. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator::Plus)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator::Minus)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator::Mul)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator::Div)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pLeft</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator::LParen)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Operator::RParen)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Token _1(<span class="hljs-number"><span class="hljs-number">1</span></span>), _2(<span class="hljs-number"><span class="hljs-number">2</span></span>), _3(<span class="hljs-number"><span class="hljs-number">3</span></span>), _4(<span class="hljs-number"><span class="hljs-number">4</span></span>), _5(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre><br>  As a result, the next test will look much smaller and clearer. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_parse_expression_with_parens_in_beginning) { Tokens tokens = Parser::Parse({ pLeft, _1, plus, _2, pRight, mul, _3 }); AssertRange::AreEqual({ _1, _2, plus, _3, mul }, tokens); }</code> </pre><br>  <code>ParseOperator</code> method of the <code>ParseOperator</code> class to match the algorithm described above. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseOperator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(*m_current) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::LParen: m_stack.push_back(*m_current); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::RParen: PopToOutputUntil([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LeftParenOnTop(); }); m_stack.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: PopToOutputUntil([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LeftParenOnTop() || OperatorWithLessPrecedenceOnTop(); }); m_stack.push_back(*m_current); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OperatorWithLessPrecedenceOnTop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PrecedenceOf(m_stack.back()) &lt; PrecedenceOf(*m_current); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LeftParenOnTop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Operator&gt;(m_stack.back()) == Operator::LParen; }</code> </pre><br>  We do not have any test for matching the closing brackets with the opening.  To test the generation of exceptions, the <code>Assert</code> class has a special method <code>ExpectException</code> , which accepts the type of exception as a template parameter, which must be generated. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_throw_when_opening_paren_not_found) { Assert::ExpectException&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logic_error&gt;([]() {Parser::Parse({ _1, pRight }); }); }</code> </pre><br>  Add a check for the presence of an opening bracket when processing the closing bracket. <br><br><pre> <code class="cpp hljs"> ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::RParen: PopToOutputUntil([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LeftParenOnTop(); }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_stack.empty() || m_stack.back() != Operator::LParen) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logic_error(<span class="hljs-string"><span class="hljs-string">"Opening paren not found."</span></span>); } m_stack.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br>  Now test for the absence of a closing bracket. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_throw_when_closing_paren_not_found) { Assert::ExpectException&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logic_error&gt;([]() {Parser::Parse({ pLeft, _1 }); }); }</code> </pre><br>  This situation can be identified by the presence of opening parentheses in stacks at the end of parsing. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; m_current != m_end; ++m_current) { ParseCurrentToken(); } PopToOutputUntil([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_stack.back() == Token(Operator::LParen)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logic_error(<span class="hljs-string"><span class="hljs-string">"Closing paren not found."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }); }</code> </pre><br>  So, all the tests pass, you can put the code in the class <code>ShuntingYardParser</code> in order. <br><br><div class="spoiler">  <b class="spoiler_title">ShuntingYardParser class after refactoring</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShuntingYardParser</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ShuntingYardParser(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Tokens &amp;tokens) : m_current(tokens.cbegin()), m_end(tokens.cend()) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; m_current != m_end; ++m_current) { ParseCurrentToken(); } PopToOutputUntil([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StackHasNoOperators(); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Tokens &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_output; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseCurrentToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(m_current-&gt;Type()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TokenType::Operator: ParseOperator(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TokenType::Number: ParseNumber(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out_of_range(<span class="hljs-string"><span class="hljs-string">"TokenType"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StackHasNoOperators</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_stack.back() == Token(Operator::LParen)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logic_error(<span class="hljs-string"><span class="hljs-string">"Closing paren not found."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseOperator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(*m_current) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::LParen: PushCurrentToStack(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operator::RParen: PopToOutputUntil([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LeftParenOnTop(); }); PopLeftParen(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: PopToOutputUntil([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LeftParenOnTop() || OperatorWithLessPrecedenceOnTop(); }); PushCurrentToStack(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PushCurrentToStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_stack.push_back(*m_current); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopLeftParen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_stack.empty() || m_stack.back() != Operator::LParen) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::logic_error(<span class="hljs-string"><span class="hljs-string">"Opening paren not found."</span></span>); } m_stack.pop_back(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OperatorWithLessPrecedenceOnTop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PrecedenceOf(m_stack.back()) &lt; PrecedenceOf(*m_current); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LeftParenOnTop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Operator&gt;(m_stack.back()) == Operator::LParen; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_output.push_back(*m_current); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PopToOutputUntil</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">whenToEnd</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!m_stack.empty() &amp;&amp; !whenToEnd()) { m_output.push_back(m_stack.back()); m_stack.pop_back(); } } Tokens::const_iterator m_current, m_end; Tokens m_output, m_stack; };</code> </pre><br></div></div><br>  For confidence, you can write a test to parse a complex expression. <br><br><pre> <code class="cpp hljs"> TEST_METHOD(Should_parse_complex_experssion_with_paren) { <span class="hljs-comment"><span class="hljs-comment">// (1+2)*(3/(4-5)) = 1 2 + 3 4 5 - / * Tokens tokens = Parser::Parse({ pLeft, _1, plus, _2, pRight, mul, pLeft, _3, div, pLeft, _4, minus, _5, pRight, pRight }); AssertRange::AreEqual({ _1, _2, plus, _3, _4, _5, minus, div, mul }, tokens); }</span></span></code> </pre><br>  He immediately passes, which was expected. <br><br>  All code at the moment: <br><br><div class="spoiler">  <b class="spoiler_title">Interpreter.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;wchar.h&gt; #include &lt;algorithm&gt; namespace Interpreter { enum class Operator : wchar_t { Plus = L'+', Minus = L'-', Mul = L'*', Div = L'/', LParen = L'(', RParen = L')', }; inline std::wstring ToString(const Operator &amp;op) { return{ static_cast&lt;wchar_t&gt;(op) }; } enum class TokenType { Operator, Number }; inline std::wstring ToString(const TokenType &amp;type) { switch(type) { case TokenType::Operator: return L"Operator"; case TokenType::Number: return L"Number"; default: throw std::out_of_range("TokenType"); } } class Token { public: Token(Operator op) :m_type(TokenType::Operator), m_operator(op) {} Token(double num) :m_type(TokenType::Number), m_number(num) {} TokenType Type() const { return m_type; } operator Operator() const { if(m_type != TokenType::Operator) { throw std::logic_error("Should be operator token."); } return m_operator; } operator double() const { if(m_type != TokenType::Number) { throw std::logic_error("Should be number token."); } return m_number; } friend inline bool operator==(const Token &amp;left, const Token &amp;right) { if(left.m_type == right.m_type) { switch(left.m_type) { case Interpreter::TokenType::Operator: return left.m_operator == right.m_operator; case Interpreter::TokenType::Number: return left.m_number == right.m_number; default: throw std::out_of_range("TokenType"); } } return false; } private: TokenType m_type; union { Operator m_operator; double m_number; }; }; inline std::wstring ToString(const Token &amp;token) { switch(token.Type()) { case TokenType::Number: return std::to_wstring(static_cast&lt;double&gt;(token)); case TokenType::Operator: return ToString(static_cast&lt;Operator&gt;(token)); default: throw std::out_of_range("TokenType"); } } typedef std::vector&lt;Token&gt; Tokens; namespace Lexer { namespace Detail { class Tokenizer { public: Tokenizer(const std::wstring &amp;expr) : m_current(expr.c_str()) {} void Tokenize() { while(!EndOfExperssion()) { if(IsNumber()) { ScanNumber(); } else if(IsOperator()) { ScanOperator(); } else { MoveNext(); } } } const Tokens &amp;Result() const { return m_result; } private: bool EndOfExperssion() const { return *m_current == L'\0'; } bool IsNumber() const { return iswdigit(*m_current) != 0; } void ScanNumber() { wchar_t *end = nullptr; m_result.push_back(wcstod(m_current, &amp;end)); m_current = end; } bool IsOperator() const { auto all = { Operator::Plus, Operator::Minus, Operator::Mul, Operator::Div, Operator::LParen, Operator::RParen }; return std::any_of(all.begin(), all.end(), [this](Operator o) {return *m_current == static_cast&lt;wchar_t&gt;(o); }); } void ScanOperator() { m_result.push_back(static_cast&lt;Operator&gt;(*m_current)); MoveNext(); } void MoveNext() { ++m_current; } const wchar_t *m_current; Tokens m_result; }; } // namespace Detail inline Tokens Tokenize(const std::wstring &amp;expr) { Detail::Tokenizer tokenizer(expr); tokenizer.Tokenize(); return tokenizer.Result(); } } // namespace Lexer namespace Parser { inline int PrecedenceOf(Operator op) { return (op == Operator::Mul || op == Operator::Div) ? 1 : 0; } namespace Detail { class ShuntingYardParser { public: ShuntingYardParser(const Tokens &amp;tokens) : m_current(tokens.cbegin()), m_end(tokens.cend()) {} void Parse() { for(; m_current != m_end; ++m_current) { ParseCurrentToken(); } PopToOutputUntil([this]() {return StackHasNoOperators(); }); } const Tokens &amp;Result() const { return m_output; } private: void ParseCurrentToken() { switch(m_current-&gt;Type()) { case TokenType::Operator: ParseOperator(); break; case TokenType::Number: ParseNumber(); break; default: throw std::out_of_range("TokenType"); } } bool StackHasNoOperators() const { if(m_stack.back() == Token(Operator::LParen)) { throw std::logic_error("Closing paren not found."); } return false; } void ParseOperator() { switch(*m_current) { case Operator::LParen: PushCurrentToStack(); break; case Operator::RParen: PopToOutputUntil([this]() { return LeftParenOnTop(); }); PopLeftParen(); break; default: PopToOutputUntil([this]() { return LeftParenOnTop() || OperatorWithLessPrecedenceOnTop(); }); PushCurrentToStack(); break; } } void PushCurrentToStack() { return m_stack.push_back(*m_current); } void PopLeftParen() { if(m_stack.empty() || m_stack.back() != Operator::LParen) { throw std::logic_error("Opening paren not found."); } m_stack.pop_back(); } bool OperatorWithLessPrecedenceOnTop() const { return PrecedenceOf(m_stack.back()) &lt; PrecedenceOf(*m_current); } bool LeftParenOnTop() const { return static_cast&lt;Operator&gt;(m_stack.back()) == Operator::LParen; } void ParseNumber() { m_output.push_back(*m_current); } template&lt;class T&gt; void PopToOutputUntil(T whenToEnd) { while(!m_stack.empty() &amp;&amp; !whenToEnd()) { m_output.push_back(m_stack.back()); m_stack.pop_back(); } } Tokens::const_iterator m_current; Tokens::const_iterator m_end; Tokens m_output; Tokens m_stack; }; } // namespace Detail inline Tokens Parse(const Tokens &amp;tokens) { Detail::ShuntingYardParser parser(tokens); parser.Parse(); return parser.Result(); } } // namespace Parser } // namespace Interpreter</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">InterpreterTests.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CppUnitTest.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Interpreter.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">warning</span></span></span><span class="hljs-meta">(disable: 4505) namespace InterpreterTests { using namespace Microsoft::VisualStudio::CppUnitTestFramework; using namespace Interpreter; using namespace std; namespace AssertRange { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class T, class ActualRange&gt; static void AreEqual(initializer_list&lt;T&gt; expect, const ActualRange &amp;actual) { auto actualIter = begin(actual); auto expectIter = begin(expect); Assert::AreEqual(distance(expectIter, end(expect)), distance(actualIter, end(actual)), L"Size differs."); for(; expectIter != end(expect) &amp;&amp; actualIter != end(actual); ++expectIter, ++actualIter) { auto message = L"Mismatch in position " + to_wstring(distance(begin(expect), expectIter)); Assert::AreEqual&lt;T&gt;(*expectIter, *actualIter, message.c_str()); } } } // namespace AssertRange static const Token plus(Operator::Plus), minus(Operator::Minus); static const Token mul(Operator::Mul), div(Operator::Div); static const Token pLeft(Operator::LParen), pRight(Operator::RParen); static const Token _1(1), _2(2), _3(3), _4(4), _5(5); TEST_CLASS(LexerTests) { public: TEST_METHOD(Should_return_empty_token_list_when_put_empty_expression) { Tokens tokens = Lexer::Tokenize(L""); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_tokenize_single_plus_operator) { Tokens tokens = Lexer::Tokenize(L"+"); AssertRange::AreEqual({ plus }, tokens); } TEST_METHOD(Should_tokenize_single_digit) { Tokens tokens = Lexer::Tokenize(L"1"); AssertRange::AreEqual({ _1 }, tokens); } TEST_METHOD(Should_tokenize_floating_point_number) { Tokens tokens = Lexer::Tokenize(L"12.34"); AssertRange::AreEqual({ 12.34 }, tokens); } TEST_METHOD(Should_tokenize_plus_and_number) { Tokens tokens = Lexer::Tokenize(L"+12.34"); AssertRange::AreEqual({ plus, Token(12.34) }, tokens); } TEST_METHOD(Should_skip_spaces) { Tokens tokens = Lexer::Tokenize(L" 1 + 12.34 "); AssertRange::AreEqual({ _1, plus, Token(12.34) }, tokens); } TEST_METHOD(Should_tokenize_complex_experssion) { Tokens tokens = Lexer::Tokenize(L"1+2*3/(4-5)"); AssertRange::AreEqual({ _1, plus, _2, mul, _3, div, pLeft, _4, minus, _5, pRight }, tokens); } }; TEST_CLASS(TokenTests) { public: TEST_METHOD(Should_get_type_for_operator_token) { Token opToken(Operator::Plus); Assert::AreEqual(TokenType::Operator, opToken.Type()); } TEST_METHOD(Should_get_type_for_number_token) { Token numToken(1.2); Assert::AreEqual(TokenType::Number, numToken.Type()); } TEST_METHOD(Should_get_operator_code_from_operator_token) { Token token(Operator::Plus); Assert::AreEqual&lt;Operator&gt;(Operator::Plus, token); } TEST_METHOD(Should_get_number_value_from_number_token) { Token token(1.23); Assert::AreEqual&lt;double&gt;(1.23, token); } }; TEST_CLASS(ParserTests) { public: TEST_METHOD(Should_return_empty_list_when_put_empty_list) { Tokens tokens = Parser::Parse({}); Assert::IsTrue(tokens.empty()); } TEST_METHOD(Should_parse_single_number) { Tokens tokens = Parser::Parse({ _1 }); AssertRange::AreEqual({ _1 }, tokens); } TEST_METHOD(Should_parse_num_plus_num) { Tokens tokens = Parser::Parse({ _1, plus, _2 }); AssertRange::AreEqual({ _1, _2, plus }, tokens); } TEST_METHOD(Should_parse_two_additions) { Tokens tokens = Parser::Parse({ _1, plus, _2, plus, _3 }); AssertRange::AreEqual({ _1, _2, plus, _3, plus }, tokens); } TEST_METHOD(Should_get_same_precedence_for_operator_pairs) { Assert::AreEqual(Parser::PrecedenceOf(Operator::Plus), Parser::PrecedenceOf(Operator::Minus)); Assert::AreEqual(Parser::PrecedenceOf(Operator::Mul), Parser::PrecedenceOf(Operator::Div)); } TEST_METHOD(Should_get_greater_precedence_for_multiplicative_operators) { Assert::IsTrue(Parser::PrecedenceOf(Operator::Mul) &gt; Parser::PrecedenceOf(Operator::Plus)); } TEST_METHOD(Should_parse_add_and_mul) { Tokens tokens = Parser::Parse({ _1, plus, _2, mul, _3 }); AssertRange::AreEqual({ _1, _2, _3, mul, plus }, tokens); } TEST_METHOD(Should_parse_complex_experssion) { Tokens tokens = Parser::Parse({ _1, plus, _2, div, _3, minus, _4, mul, _5 }); AssertRange::AreEqual({ _1, _2, _3, div, plus, _4, _5, mul, minus }, tokens); } TEST_METHOD(Should_skip_parens_around_number) { Tokens tokens = Parser::Parse({ pLeft, _1, pRight }); AssertRange::AreEqual({ _1 }, tokens); } TEST_METHOD(Should_parse_expression_with_parens_in_beginning) { Tokens tokens = Parser::Parse({ pLeft, _1, plus, _2, pRight, mul, _3 }); AssertRange::AreEqual({ _1, _2, plus, _3, mul }, tokens); } TEST_METHOD(Should_throw_when_opening_paren_not_found) { Assert::ExpectException&lt;std::logic_error&gt;([]() {Parser::Parse({ _1, pRight }); }); } TEST_METHOD(Should_throw_when_closing_paren_not_found) { Assert::ExpectException&lt;std::logic_error&gt;([]() {Parser::Parse({ pLeft, _1 }); }); } TEST_METHOD(Should_parse_complex_experssion_with_paren) { // (1+2)*(3/(4-5)) = 1 2 + 3 4 5 - / * Tokens tokens = Parser::Parse({ pLeft, _1, plus, _2, pRight, mul, pLeft, _3, div, pLeft, _4, minus, _5, pRight, pRight }); AssertRange::AreEqual({ _1, _2, plus, _3, _4, _5, minus, div, mul }, tokens); } }; }</span></span></span></span></code> </pre><br></div></div><br>  <a href="https://github.com/Unril/InterpreterTDD/releases/tag/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2586_%25D0%25B2%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B9_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">The code for the article on GitHub</a> .  The names of commits and their order correspond to the tests and refactoring described above.  The end of the second part corresponds to the label "End of the second part" <br><br>  In the <a href="http://habrahabr.ru/post/232097/">next part, we</a> will consider the development of a calculator and a facade for the entire interpreter, as well as refactoring of the entire code to eliminate duplication. </div><p>Source: <a href="https://habr.com/ru/post/232081/">https://habr.com/ru/post/232081/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../232061/index.html">Communal paradise without worries and troubles</a></li>
<li><a href="../232065/index.html">What hinders the development of electronic document circulation in Russia?</a></li>
<li><a href="../232073/index.html">URL.js or friends with javascript handling links</a></li>
<li><a href="../232075/index.html">Stripe announces new decentralized currency Stellar</a></li>
<li><a href="../232079/index.html">SpamAssassin Training</a></li>
<li><a href="../232083/index.html">How to stop worrying and start shooting panoramas</a></li>
<li><a href="../232085/index.html">Experience using smart glasses Epson Moverio BT-200</a></li>
<li><a href="../232087/index.html">Automating the mounting of samba partitions on Mac OS</a></li>
<li><a href="../232089/index.html">Simple MVC model implementation with template hierarchy support</a></li>
<li><a href="../232091/index.html">Intel Pro 2500 - new SSD series with hardware encryption</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>