<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Play! Lift! Srsly?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Play! and Lift, - these two frameworks are the personification of where the main flow of Scala web developers is heading. Truly, try searching for Sca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Play! Lift! Srsly?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/ea4/076/849/ea4076849cc0a49aefec18257e20d623.jpg" align="left">  Play!  and Lift, - these two frameworks are the personification of where the main flow of Scala web developers is heading.  Truly, try searching for Scala frameworks on Stack Overflow and you will understand that I'm right.  I believe that the percentage of sane people who are tired of complex harvesters is great, so I‚Äôll tell you about the ‚Äúother‚Äù <b>Xitrum</b> framework. <br><a name="habracut"></a><br>  Xitrum is completely opposite to them in philosophy; it is a minimalist framework, the goal of which is to directly render content.  There is no magic and no programming by convention.  With its minimalism, it is close to Scalatra, but unlike it is completely asynchronous, because  built on the basis of Netty (v4) and Akka (for more than a year now I have been following Scalatra and so far Netty support has not been announced).  But do not worry, the threshold of entry is extremely low - the actors are only optional, although they are a significant plus in favor of the framework. <br><br>  Immediately on performance.  In the minimum configuration, xitrum runs and runs with a memory limit of 64Mb.  Spending on CPU time is not significant, i.e.  The framework itself does not load the processor.  Everything else is up to you. <br><br><div class="spoiler">  <b class="spoiler_title">User Reviews</b> <div class="spoiler_text">  From the official site: <br><blockquote>  This is a really impressive body of work, arguably the most complete one. </blockquote><br><blockquote>  Xitrum is truly a full stack web framework, including all the bases that are covered, and identifies a list of files.  Tack on built-in JSON converter, before / around / after interceptors, request / session / cookie / flash scopes, integrated validation (for server &amp; client-side, nice) , Netty (with Nginx, hello blazing fast), etc.  and you have, wow. <br></blockquote><br>  My opinion: <br><blockquote>  The best framework I've ever seen for Scala / Java.  Xitrum really catches me, it's like a mixture of Dancer + Rails with static typing, amazing! </blockquote><br></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The project is originally from Japan and has extensive documentation.  The project developers leave a very pleasant impression, always listen to what they write in the official group and very quickly close bugs.  For almost a year now, as I have not received a single failure or hung task in the tracker. <br><br><div class="spoiler">  <b class="spoiler_title">Ngoc Dao about your project (from the correspondence)</b> <div class="spoiler_text"><blockquote>  I began to develop Xitrum in the summer of 2010, for use in real-life <a href="http://mobilus.co.jp/">Mobilus</a> projects.  At that time, Play supported only Java, and Lift was the only full-fledged framework for Scala.  We tried to use it for several months, but it turned out that it is not so simple, at least for us who are familiar with Rails development.  Therefore, as a technical manager, I decided to create a fast and scalable Scala web framework for my team, as easy to use as Rails.  In fact, the result was more like Merb, rather than Rails (there is no data access layer in xitrum). <br></blockquote><br><br>  Over time, many people have participated in the development of the framework.  Currently, the Xitrum core development team consists of two people: <a href="https://github.com/georgeOsdDev">Oshida</a> and <a href="https://github.com/ngocdaothanh">Ngoc</a> . <br></div></div><br><br>  So, xitrum: <br><ul><li>  Tipo safe (typesafe) in all respects where possible </li><li>  Fully asynchronous.  It is not necessary to send an answer to the request immediately, you can run complex calculations and give an answer when it is ready.  Such things as Long polling, chunked response, WebSockets, SockJs, EventStream are very easy to implement. </li><li>  Very productive, static return is comparable in performance to Nginx </li><li>  Automatic assembly of routes (routes) of the application, there is no need to get any xml and so on </li><li>  Simple processing of request, session and cookie parameters </li><li>  Pre and post filters </li><li>  Native support for response caching (Rails style), ETag support </li><li>  Great for developing a RESTful API, built-in support for documentation based on Swagger Doc </li><li>  GNU gettext-based I18N with dynamic reload of translation files in case of changes.  Automatic generator of pot files from sources </li><li>  Modularity - xitrum automatically merges routes from all jar dependencies </li><li>  On-demand type safe secure template engine Scalate or any other you want </li></ul><br><br>  Xitrum is a controller-first framework.  It is very easy to dynamically change the controller's views at runtime, which is not trivial for some Scala / Java frameworks.  In my memory, this is generally the only framework from the Java world that allowed, without any crutches, to write a CMS with dynamic templating, so: <br><br>  I think it would be appropriate to introduce the reader to the basics of the framework, I will describe more complex things another time if there is interest. <br><br><div class="spoiler">  <b class="spoiler_title">Creating an empty project and folder structure</b> <div class="spoiler_text">  The new project is easiest to create as follows: <br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/ngocdaothanh/xitrum-new my-app <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> my-app sbt/sbt run</code> </pre> <br>  By default, the server will start on port 8000. In the project, the Scalate template engine is connected by default.  This is an ideal project to start, there is nothing superfluous in it, except for the standard controller and a pair of views that can be deleted. <br><br>  To import a project into eclipse, use <i>sbt / sbt eclipse</i> , in idea <i>sbt / sbt gen-idea</i> . <br>  <b>Important:</b> in eclipse, you need to manually add the <b>config</b> folder to the classpath, otherwise the project will not run from eclipse ( <a href="https://github.com/typesafehub/sbteclipse/issues/182">sbt-eclipse # 182</a> bug). <br><br>  Project directory structure: <br><pre> <code class="bash hljs">./script <span class="hljs-comment"><span class="hljs-comment">#      production ./config #   (akka, logback, xitrum) ./public #    (css, js, ) ./project # sbt ./src # src ./src/main/scalate #    ./src/main/scala # scala  ./src/main/scala/quickstart/Boot.scala #    </span></span></code> </pre><br></div></div><br><br><h2>  Simple controller </h2><br>  In xitrum, each request can only be processed by the heir from Action.  That is, for each independent route processed by our server, we must declare a separate controller class. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> xitrum.<span class="hljs-type"><span class="hljs-type">Action</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> xitrum.annotation.<span class="hljs-type"><span class="hljs-type">GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">"url/to/HelloAction"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloAction</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span></span>() { respondHtml( &lt;xml:group&gt; &lt;p&gt;<span class="hljs-type"><span class="hljs-type">Hello</span></span> world!&lt;/p&gt; &lt;/xml:group&gt; ) } }</code> </pre><br>  Each new request arriving at the server will be processed by a new instance of the class, i.e., it does not make sense to store the state in these classes.  It is very important to understand the fact that request processing is asynchronous.  Unless you call the <i>respond * ()</i> method, the connection with the client will not be closed and the client will wait for your response, perhaps forever.  The <i>execute</i> method runs on a Netty stream, so you should not put long operations in it, for example: <br><br><pre> <code class="scala hljs"><span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">"url/to/HelloAction"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloAction</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span></span>() { <span class="hljs-type"><span class="hljs-type">Thread</span></span>.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-comment"><span class="hljs-comment">// :    Netty  respond() } }</span></span></code> </pre><br>  With this implementation of the controller, your server is unlikely to serve more than 1 connection per second.  To solve this problem, you need to use either FutureAction or ActorAction. <br><ul><li>  Action - the exectue method will be executed directly in the Netty stream. </li><li>  FutureAction - the execute method will be executed in a separate thread (Akka system dispatcher) </li><li>  ActorAction - the usual actor acts as a controller </li></ul><br><br><h2>  Routing </h2><br><br>  Xitrum supports all types of HTTP requests using GET, POST and other annotations.  Any controller can handle an unlimited number of routes.  You can determine the order of the controllers using the First and Last annotations.  The default controller is defined as METHOD (": *") <br><br><pre> <code class="scala hljs"><span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">"url1"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@First</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">"url1"</span></span>, <span class="hljs-string"><span class="hljs-string">"url2"</span></span>, <span class="hljs-string"><span class="hljs-string">"..."</span></span>) <span class="hljs-meta"><span class="hljs-meta">@POST</span></span>(<span class="hljs-string"><span class="hljs-string">"url1"</span></span>, ...) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">":*"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Last</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Default</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre><br>  To get a link to the controller, the Action provides a <i>url</i> method that generates a GET link with parameters. <br><br><pre> <code class="scala hljs">url[<span class="hljs-type"><span class="hljs-type">HelloAction</span></span>](<span class="hljs-string"><span class="hljs-string">"name"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"caiiiycuk"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// url/to/HelloAction?name=caiiiycuk</span></span></code> </pre><br>  A link to static resources from the public or classpath directory can be obtained using the <i>publicUrl</i> and <i>resourceUrl</i> methods, respectively.  Classic redirects like <i>forwardTo</i> and <i>redirectTo are</i> <i>supported</i> . <br><br><h2>  Parsing parameters </h2><br><br>  Xitrum allows you to transparently work with three types of parameters: <br><ul><li>  uriParams - parameters after '?'  (for example: example.com/blah <b>? x = 1 &amp; y = 2</b> ) </li><li>  bodyParams - parameters passed in the body of the POST request </li><li>  pathParams - parameters encoded in url (for example: example.com/article/ <b>: id</b> ) </li></ul><br><br>  Access to the parameters is very simple: <br><br><pre> <code class="scala hljs">param(<span class="hljs-string"><span class="hljs-string">"X"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   X  String,      params("X") //   X  List[String],      paramo("X") //   X  Option[String] paramso("X") //   X  Option[List[String]] param[Type]("X") //   X  [Type],      params[Type]("X") //   X  List[[Type]],      paramo[Type]("X") //   X  Option[[Type]] paramso[Type]("X") //   X  Option[List[[Type]]]</span></span></code> </pre><br>  pathParams are set by analogy with Rails using the ':' symbol (:: id,: article,: etc), optionally, parameter values ‚Äã‚Äãcan be restricted using regular expressions enclosed in '&lt;&gt;' (for example: id &lt;[0-9] + &gt;). <br><br><pre> <code class="scala hljs"><span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">"articles/:id&lt;[0-9]+&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"articles/:id&lt;[0-9]+&gt;.:format"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArticlesShow</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id = param[<span class="hljs-type"><span class="hljs-type">Int</span></span>](<span class="hljs-string"><span class="hljs-string">"id"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> format = paramo(<span class="hljs-string"><span class="hljs-string">"format"</span></span>).getOrElse(<span class="hljs-string"><span class="hljs-string">"json"</span></span>) ... } }</code> </pre><br>  Sometimes it becomes necessary to read the binary data of the POST request body; this is done like this: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> body = requestContentString <span class="hljs-comment"><span class="hljs-comment">//  String val bodyMap = requestContentJson[Type] //  Json,  Type val raw = request.getContent //  ByteBuf</span></span></code> </pre><br><br><h2>  Templates </h2><br><br>  By itself, xitrum does not have a built-in template engine; without a template engine, it is possible to generate the following types of response: <br><ul><li>  respondText - reply with the string ‚Äúplain / text‚Äù </li><li>  respondHtml - reply with the string "text / html" </li><li>  respondJson - convert Scala object to Json string </li><li>  respondBinary - binary data </li><li>  respondFile - send file using zero-copy (send-file) </li><li>  Less important are respondJs, respondJsonP, respondJsonText, respondJsonPText, respondEventSource </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">Chunked response support</b> <div class="spoiler_text">  There is a situation where the response to the request does not fit in the server‚Äôs memory.  For example, our server generates an annual report in CSV format.  Naturally in this situation, we cannot save the entire report in memory and send it to the client in one answer.  Life cycle chunked response: <br><ol><li>  Call the <i>setChunked Method</i> </li><li>  Call <i>respond * ()</i> as many times as necessary </li><li>  Call <i>respondLastChunk</i> when all data is sent. </li></ol><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> generator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MyCsvGenerator</span></span> setChunked() respondText(header, <span class="hljs-string"><span class="hljs-string">"text/csv"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (generator.hasNextLine) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> line = generator.nextLine respondText(line) } respondLastChunk()</code> </pre><br><br>  When using chunked response with ActorAction, you can very easily implement <a href="http://www.cubrid.org/blog/dev-platform/faster-web-page-loading-with-facebook-bigpipe/">Facebook BigPipe</a> . <br></div></div><br><br>  For templating you can use <a href="http://scalate.fusesource.org/">Scalate</a> , it is connected in a template project.  The template engine supports several different syntaxes: mustache, scaml, jade and ssp.  I prefer to use ssp because it is closest to html.  In the template project, jade is configured, to change the type of syntax, in the xitrum.conf configuration, replace the line defaultType = jade with defaultType = ssp. <br><br><div class="spoiler">  <b class="spoiler_title">Scalate features</b> <div class="spoiler_text"><ul><li>  HTML compatible syntax (ssp) </li><li>  HAML similar syntax (jade) </li><li>  Download templates on the fly (runtime) </li><li>  Compiled templates (error checking at compile time) </li><li>  Inclusion of a template in a template </li><li>  Pattern inheritance (the ability to override blocks) </li><li>  Automatic tag escaping </li><li>  Using Scala code directly in the template </li></ul><br></div></div><br><br>  When using Scalate for each controller, you can define your own view; according to the Scalate rules, the path to the template should correspond to the controller's package. <br><br><pre> <code class="scala hljs">src/main/scala/quickstart/action/<span class="hljs-type"><span class="hljs-type">SiteIndex</span></span>.scala #   src/main/scalate/quickstart/action/<span class="hljs-type"><span class="hljs-type">SiteIndex</span></span>.ssp #   src/main/scalate/quickstart/action/<span class="hljs-type"><span class="hljs-type">SiteIndex</span></span>/ #    <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> quickstart.action <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> xitrum.annotation.<span class="hljs-type"><span class="hljs-type">GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SiteIndex</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultLayout</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span></span>() { respondView() } }</code> </pre><br>  As you can see, to display the SiteIndex.ssp ‚Äã‚Äãtemplate, it is enough to call <i>respondView ()</i> .  The concept of a fragment is provided, with it you can change the view of the controller. <br><br><pre> <code class="scala hljs"><span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SiteIndex</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultLayout</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span></span>() { respondHtml(renderFragment(<span class="hljs-string"><span class="hljs-string">"some"</span></span>)) #      } }</code> </pre><br><br>  Xitrum does not impose restrictions on the strict correspondence of the view and the controller, so the same view can be used in different controllers.  As a result, by default, templates can only use methods from the base action trait.  You can transfer data to a template using the <i>at</i> method. <br><br><table><tbody><tr><th>  Controller </th><th>  Template </th></tr><tr><td><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span></span>() { at(<span class="hljs-string"><span class="hljs-string">"login"</span></span>) = <span class="hljs-string"><span class="hljs-string">"caiiiycuk"</span></span> at(<span class="hljs-string"><span class="hljs-string">"rating"</span></span>) = <span class="hljs-number"><span class="hljs-number">5</span></span> respondView() }</code> </pre><br></td><td><pre> <code class="html hljs xml">Hello ${at("login")} You rating is ${at("rating")}</code> </pre><br></td></tr></tbody></table><br>  If you decide to limit yourself to one template per controller, then the pattern that allows you to import the current controller into the template will be very useful.  When used, controller methods can be transparently invoked from a template. <br><br><table><tbody><tr><th>  Controller </th><th>  Template </th></tr><tr><td><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Random</span></span>.nextInt <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span></span>() { respondView() }</code> </pre><br></td><td><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">val</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">myAction</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">currentAction.asInstanceOf[MyAction];</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">import</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">myAction._</span></span></span><span class="hljs-tag"> %&gt;</span></span> You random number is ${random}</code> </pre><br></td></tr></tbody></table><br>  Of some interest is the atJson method, - it performs automatic conversion of models to Json, this turns out to be very useful when passing data directly to JavaScript. <br><br><table><tbody><tr><th>  Controller </th><th>  Template </th></tr><tr><td><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">login: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">execute</span></span></span><span class="hljs-class">(</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span></span>{ at(<span class="hljs-string"><span class="hljs-string">"user"</span></span>) = <span class="hljs-type"><span class="hljs-type">User</span></span>(<span class="hljs-string"><span class="hljs-string">"admin"</span></span>, <span class="hljs-string"><span class="hljs-string">"Admin"</span></span>) respondView() }</code> </pre><br></td><td><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> user = ${atJson(</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">"user"</span></span></span><span class="actionscript">)}; alert(user.login); alert(user.name); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br></td></tr></tbody></table><br><br><h2>  Session and cookies </h2><br><br>  Inside the controller, you need to use the <i>requestCookies</i> variable to access cookies, and to set a new cookie, respectively, <i>responseCookies</i> . <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  requestCookies.get("myCookie") match { case None =&gt; ... case Some(string) =&gt; ... } //  responseCookies.append(new DefaultCookie("name", "value"))</span></span></code> </pre><br>  Xitrum automatically provides for saving, restoring and encrypting session in cookies.  Work with session is carried out through the <i>session</i> variable. <br><br><pre> <code class="scala hljs">session.clear <span class="hljs-comment"><span class="hljs-comment">//   session("userId") = 1 //   session.isDefinedAt("userId") //   session("userId") //   </span></span></code> </pre><br><br><h2>  Filters </h2><br><br>  The request processing can be additionally controlled using filters; there are three of them: <i>beforeFilter</i> , <i>afterFilter</i> and <i>aroundFilter</i> .  <i>beforeFilter</i> is executed before any processing of the request, if it returns false, then no further processing of the request by this controller will be performed.  Opposite <i>afterFilter</i> are executed last. <br><br><pre> <code class="bash hljs">before1 -<span class="hljs-literal"><span class="hljs-literal">true</span></span>-&gt; before2 -<span class="hljs-literal"><span class="hljs-literal">true</span></span>-&gt; +--------------------+ --&gt; after1 --&gt; after2 | around1 (1 of 2) | | around2 (1 of 2) | | action | | around2 (2 of 2) | | around1 (2 of 2) | +--------------------+</code> </pre><br>  Example, defining an internationalization language before processing a request. <br><br><pre> <code class="scala hljs">beforeFilter { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lango: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = yourMethodToGetUserPreferenceLanguageInSession() lango <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> =&gt; autosetLanguage(<span class="hljs-string"><span class="hljs-string">"ru"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Some</span></span>(lang) =&gt; setLanguage(lang) } <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span></span>() { ... }</code> </pre><br><br><h2>  Caching </h2><br><br>  So, request processing is simplified as follows: (1) request -&gt; (2) before filters -&gt; (3) execute controller method -&gt; (4) after filters -&gt; (5) response.  Xitrum has built-in capabilities for caching the entire request processing chain (2 - 3 - 4 - 5) using the <i>CachePageMinute</i> annotation and the execute (3) method itself, the <i>CacheActionMinute</i> annotation.  The cache lifetime is indicated in minutes.  Only responses with a status of 200 Ok are included in the cache. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> xitrum.<span class="hljs-type"><span class="hljs-type">Action</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> xitrum.annotation.{<span class="hljs-type"><span class="hljs-type">GET</span></span>, <span class="hljs-type"><span class="hljs-type">CacheActionMinute</span></span>, <span class="hljs-type"><span class="hljs-type">CachePageMinute</span></span>} <span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">"articles"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@CachePageMinute</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArticlesIndex</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span></span>() { ... } } <span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">"articles/:id"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@CacheActionMinute</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArticlesShow</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span></span>() { ... } }</code> </pre><br>  By default, the framework uses its Lru cache implementation for caching.  However, the implementation of the caching mechanism can be easily changed in the configuration.  For a clustered cache, Hazelcast is the most suitable <a href="https://github.com/ngocdaothanh/xitrum-hazelcast">connection method</a> . <br><br>  In addition to annotations, xitrum provides access to the <i>Cache</i> object.  It can be used to cache your data. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> xitrum.<span class="hljs-type"><span class="hljs-type">Config</span></span>.xitrum.cache <span class="hljs-comment"><span class="hljs-comment">// Cache with a prefix val prefix = "articles/" + article.id cache.put(prefix + "/likes", likes) cache.put(prefix + "/comments", comments) // Later, when something happens and you want to remove all cache related to the article cache.remove(prefix)</span></span></code> </pre><br><br>  Methods provided by the Cache object <br><ul><li>  put (key, value) - permanently put a pair of "key, value" in the cache </li><li>  putSecond, putMinute, putHour, putDay (key, value, interval) - the value will be removed from the cache after a specified period of time </li><li>  putIfAbsent, putIfAbsentSecond, putIfAbsentMinute, putIfAbsentHour, putIfAbsentDay - the same thing only the value in the cache will not be updated if it already contains </li></ul><br><br><h2>  RESTful API </h2><br><br>  Thanks to clear routing, implementing a RESTful API is trivial.  Out-of-the-box Documentation API supported by Swagger <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> xitrum.{<span class="hljs-type"><span class="hljs-type">Action</span></span>, <span class="hljs-type"><span class="hljs-type">SkipCsrfCheck</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> xitrum.annotation.{<span class="hljs-type"><span class="hljs-type">GET</span></span>, <span class="hljs-type"><span class="hljs-type">Swagger</span></span>} <span class="hljs-meta"><span class="hljs-meta">@Swagger</span></span>( <span class="hljs-type"><span class="hljs-type">Swagger</span></span>.<span class="hljs-type"><span class="hljs-type">Note</span></span>(<span class="hljs-string"><span class="hljs-string">"Dimensions should not be bigger than 2000 x 2000"</span></span>) <span class="hljs-type"><span class="hljs-type">Swagger</span></span>.<span class="hljs-type"><span class="hljs-type">OptStringQuery</span></span>(<span class="hljs-string"><span class="hljs-string">"text"</span></span>, <span class="hljs-string"><span class="hljs-string">"Text to render on the image, default: Placeholder"</span></span>), <span class="hljs-type"><span class="hljs-type">Swagger</span></span>.<span class="hljs-type"><span class="hljs-type">Response</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-string"><span class="hljs-string">"PNG image"</span></span>), <span class="hljs-type"><span class="hljs-type">Swagger</span></span>.<span class="hljs-type"><span class="hljs-type">Response</span></span>(<span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-string"><span class="hljs-string">"Width or height is invalid or too big"</span></span>) ) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageApi</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SkipCsrfCheck</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text = paramo(<span class="hljs-string"><span class="hljs-string">"text"</span></span>).getOrElse(<span class="hljs-string"><span class="hljs-string">"Placeholder"</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">"image/:width/:height"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Swagger</span></span>( <span class="hljs-comment"><span class="hljs-comment">// &lt;--   ImageApi Swagger.Summary("Generate rectangle image"), Swagger.IntPath("width"), Swagger.IntPath("height") ) class RectImageApi extends Api { def execute { val width = param[Int]("width") val height = param[Int]("height") // ... } } @GET("image/:width") @Swagger( // &lt;--   ImageApi Swagger.Summary("Generate square image"), Swagger.IntPath("width") ) class SquareImageApi extends Api { def execute { val width = param[Int]("width") // ... } }</span></span></code> </pre><br>  At runtime, xitrum will generate swagger.json which can be used in Swagger UI for easy viewing of documentation. <br><br>  <b>Important</b> : for all POST requests, protection against CSRF attacks is provided, therefore, you should send csrf-token with any POST request, or, explicitly disable this protection using inheritance from the SkipCsrfCheck trait.  Learn more about using <a href="http://ngocdaothanh.github.io/xitrum/guide/restful.html">csrf-token</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Internationalization</b> <div class="spoiler_text">  Internationalization is done using GNU gettext.  The controller has a method <i>t</i> for performing internationalization. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span></span>() { respondHtml(t(<span class="hljs-string"><span class="hljs-string">"hello_world"</span></span>)) }</code> </pre><br>  The current translation language is selected using the <i>setLanguage</i> method; in addition, the <i>autosetLanguage</i> method can be used to automatically select the language in accordance with the browser Accept-Language.  To get the pot template, you need to run sbt compile.  Files with translations should be put in the project classpath (usually in config / i18n).  If the translation file was changed while the server was running, it will be re-read and the translation will be applied without restarting the server. <br></div></div><br><br>  If you read this article to the end, then I suppose now you know about 70% of the framework functionality.  And it seems to me that this confirms my idea that the threshold of entry is very low.  Therefore, I recommend trying and asking questions. <br><br>  The rest of the material you can always look at the official website in the textbook.  Questions that I would like to additionally tell: <br><ul><li>  Integration with JRebel </li><li>  Using ActorAction </li><li>  Postbacks </li><li>  WebScoket, SockJS, EventSource </li><li>  Deploy </li></ul><br><br>  Sources <br><ul><li>  <a href="http://ngocdaothanh.github.io/xitrum/guide/index.html">Documentation</a> </li><li>  <a href="https://groups.google.com/group/xitrum-framework">Google group</a> </li><li>  <a href="http://ngocdaothanh.github.io/xitrum/">Official site</a> </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">Demonstration project</b> <div class="spoiler_text">  Demonstration project showing most of what xitrum is capable of (it seems it is not very useful for training): <br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/ngocdaothanh/xitrum-demos.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> xitrum-demos sbt/sbt run</code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/214913/">https://habr.com/ru/post/214913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../214899/index.html">Captain ... Brava? Ah, wonderful new world ...</a></li>
<li><a href="../214901/index.html">Using SPI from Python on Raspberry Pi</a></li>
<li><a href="../214903/index.html">Declassified Satosi Nakamoto's personality</a></li>
<li><a href="../214907/index.html">Digital Termenvox based on Leap Motion (powered by .NET)</a></li>
<li><a href="../214911/index.html">Turn Git's boring logs into exciting animations.</a></li>
<li><a href="../214915/index.html">Sound attack</a></li>
<li><a href="../214917/index.html">Magic Circle: CSS Puzzle</a></li>
<li><a href="../214919/index.html">One year in the life of the project. Answers@Mail.ru</a></li>
<li><a href="../214921/index.html">Counter common sense. On the possible blocking of Yandex by the decision of the Khabarovsk court</a></li>
<li><a href="../214923/index.html">Found the creator of bitcoin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>