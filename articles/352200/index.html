<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to turn a website into a mobile application using 7 lines of JSON</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the material, the translation of which we publish today, we will focus on creating mobile applications based on existing web projects. The author o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to turn a website into a mobile application using 7 lines of JSON</h1><div class="post__text post__text-html js-mediator-article">  In the material, the translation of which we publish today, we will focus on creating mobile applications based on existing web projects.  The author of this article demonstrates tools that allow you to develop applications using the native capabilities of iOS and Android platforms and include materials from working sites or local resources with minimal effort.  His story begins with the very seven lines of JSON-code that allow you to turn sites into mobile applications. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/352200/"><img src="https://habrastorage.org/getpro/habr/post_images/09e/818/3c7/09e8183c774104e45edfafbc39594c8b.png" alt="image"></a> <br>  <i><font color="#999999">Turning a website into a mobile application</font></i> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Overview</font> </h2><br>  The figure above shows the code that allows you to turn a website into a mobile application.  In particular, seven lines of JSON, highlighted in orange, are responsible for the ‚Äútransformation‚Äù.  The remaining program text fragments describe the capabilities related to the mobile platform on which the application runs. <br><br>  What if I tell you that in order to take advantage of this approach, you do not need to redo the site, using some framework that brings the look of the resource closer to the type of mobile application?  Moreover, what if the whole development process is to connect the site to a mobile application like the one shown above using a regular URL? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition, here is another question: ‚ÄúCan one simply use JSON editing to work with native APIs, with components of the user interface, to use system transitions between pages?‚Äù. <br><br>  While you are thinking about the answers to these questions, I suggest taking a look at how a minimal application looks and works, created using the tools that I want to talk about here. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/492/faf/772/492faf772a25127c594e52e7a167903e.gif"></div><br>  <i><font color="#999999">Minimum application</font></i> <br><br>  Notice how I embedded a <a href="https://github.com/Jasonette">page</a> with github.com in this application, but everything else is native components, like the <a href="https://docs.jasonette.com/document/">top navigation bar</a> and the <a href="https://docs.jasonette.com/document/">bottom control panel</a> .  In this case, the transitions between the pages of the application use the system capabilities.  This is done automatically and does not require intervention in the site code. <br><br>  Before I talk about how this is done, you may have a very reasonable question: ‚ÄúAll this is good, but is it possible, using the method in question, to create something really useful, and not something like a simple‚Äú viewer "Web pages in the native application container?". <br><br>  Great question.  As a matter of fact, this article is devoted to the answer to it.  If in a nutshell, the essence of the method considered here is to create a two-way communication channel between the container for displaying web content and the application.  This gives the application the ability to call JavaScript functions located in the container, and the container will allow access to native APIs located outside of it. <br><br>  Take a look at an example that illustrates the above. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/356/cd0/18d/356cd018d36356643e8beeb9fb6e71a1.gif"></div><br>  <i><font color="#999999">Application for creating QR codes</font></i> <br><br>  Here are the main components of this application: <br><br><ol><li>  Native navigation header that supports built-in navigation. <br></li><li>  WebView element in which a web application that generates QR codes is embedded. <br></li><li>  System component for entering texts in the lower part of the window. <br></li></ol><br>  A description of all these elements can be made simply by casting the appropriate JSON markup attributes, similar to the one shown above. <br><br>  And finally, pay attention to the fact that the interaction of application components is shown here.  Namely, the QR code changes after entering new data.  This is done due to the possibility of calling a JavaScript function located inside the web application, which is responsible for creating QR codes based on the data transferred to it. <br><br>  It should be noted that none of the mobile application development frameworks fundamentally tried to solve the problem of ‚Äútransparent integration of web containers into native applications‚Äù, since all of them are either completely oriented towards the system capabilities of mobile platforms or rely entirely on HTML5. <br><br>  When they talk about the future of mobile applications, usually everything revolves around the question of which approach will win: based on HTML5 or on native APIs.  Tellingly, such considerations do not raise the topic of the coexistence of these two approaches, and, moreover, the synergy effect is not considered, which, thanks to the joint use of various technologies, will allow to achieve results that are not easy to achieve, relying on only one thing. <br><br>  In this article I am going to talk about the following things: <br><br><ul><li>  About why sharing a web code and native components is often a good idea. <br></li><li>  About why transparent integration of HTML and native components is not an easy task, and how I managed to solve it. <br></li><li>  And, most importantly, I will talk about how you can use the technologies that will be discussed in order to quickly develop your own applications. <br></li></ul><br><h2>  <font color="#3AC1EF">Why use web technology in mobile apps?</font> </h2><br>  Before we continue, let's first talk about whether it‚Äôs okay to use the HTML and JS capabilities in mobile applications, and when this approach can be useful.  Here are some situations when mixing web technologies with the native capabilities of mobile platforms can be useful. <br><br><h3>  <font color="#3AC1EF">‚ñç1.</font>  <font color="#3AC1EF">Using technologies created for the web</font> </h3><br>  For the implementation of some parts of the application may make sense to use web technologies.  For example, <a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a> is a web-based technology.  To use it, you can use the web engine built into the mobile platform ( <code>WKWebView</code> for iOS and <code>WebView</code> for Android) instead of installing a third-party library that simply ‚Äúemulates‚Äù WebSocket. <br><br>  With this approach, you do not need to use additional libraries, it is enough, using standard technologies, to do what you need.  This leads us to the following situation. <br><br><h3>  <font color="#3AC1EF">‚ñç2.</font>  <font color="#3AC1EF">Reducing the size of the application package</font> </h3><br>  The use of web technologies in mobile applications helps to do things that without these technologies would require huge third-party libraries. <br><br>  For example, in order to embed a QR code generator in a mobile application, you need a third-party library that will increase the size of the application package.  However, if you use the standard tool for browsing the web and the JS library connected to the page using the simple <code>&lt;script&gt;</code> construction, you can get everything you need without installing third-party libraries. <br><br><h3>  <font color="#3AC1EF">‚ñç3.</font>  <font color="#3AC1EF">Solving the problem of lack of reliable mobile libraries</font> </h3><br>  For some of the latest technologies, their robust and stable mobile implementations have not yet been created.  However, most of these technologies are available in a web environment.  As a result, the most effective way to integrate them into mobile applications is to use the appropriate JavaScript library. <br><br><h3>  <font color="#3AC1EF">‚ñç4.</font>  <font color="#3AC1EF">Development of projects using both mobile platforms and web applications</font> </h3><br>  Many novice developers who want to turn their websites into mobile applications find themselves in a difficult situation, finding out that some of the functions of their web projects are too complex to recreate them from scratch for each of the targeted mobile platforms. <br><br>  For example, one of the pages of a certain site may be too complicated to quickly convert it into a mobile application format, while the rest of the content of the site is easily ported to a mobile application. <br><br>  In such a case, it would be very useful if most of the application could be created using the mobile platform, but some particularly complex page could be transparently integrated into the application in its original form. <br><br><h2>  <font color="#3AC1EF">How it works?</font> </h2><br><h3>  <font color="#3AC1EF">‚ñçA.</font>  <font color="#3AC1EF">Jasonette</font> </h3><br>  <a href="http://jasonette.com/">Jasonette</a> is an open source project aimed at creating cross-platform native applications based on JSON markup. <br><br>  The Jasonette framework is similar to a web browser, but instead of turning HTML code into web pages, it converts JSON markup to native iOS and Android applications.  Similarity with the browser lies in the fact that any application based on Jasonette has the same basic code, which interprets different sets of JSON data in the process of building the final application.  The developer does not need to work with the library code.  The process of creating an application is to prepare its JSON description, which allows Jasonette to convert web pages into native applications in real time. <br><br>  Read more about Jasonette <a href="https://medium.freecodecamp.org/how-to-build-cross-platform-mobile-apps-using-nothing-more-than-a-json-markup-f493abec1873">here</a> .  In general, it can be said that the Jasonette project is aimed at developing native applications, and here we will talk about how to integrate HTML pages into these native applications. <br><br><h3>  <font color="#3AC1EF">‚ñçB.</font>  <font color="#3AC1EF">Jasonette Web Container</font> </h3><br>  By themselves, native mobile apps are fine, but sometimes they want to use web technologies, which can be done using standard web containers.  However, their integration into applications is not easy.  Here is what is needed for the transparent integration of web technologies into native applications: <br><br><ol><li>  The web container should be a natural part of the mobile application interface.  The container should look like any other component of the user interface of the application.  Otherwise, it will result in something clumsy, looking like what it really is - a website that is shown in a mobile application. <br></li><li>  The parent application must be able to control the child web container.  With this approach, an application, of which the control for viewing the contents of a web page is a part, will have convenient means to influence it. <br></li><li>  The child web container must be able to trigger system events in the parent application.  The web container embedded in the application must have the means to access the native API. <br></li></ol><br>  In fact, the implementation of all this requires considerable effort, so I started with the first item of this list - with a simple embedding of the web container in the pages of native applications.  So I released the first version of <a href="http://jasonette.com/webcontainer/">JSON Web Container</a> . <br><br>  This thing turned out to be useful, but it lacked the ability to interact with the parent container of the web container.  Namely, the parent application could not control the web container, and the container could not access the parent application.  As a result, the container was completely isolated from its environment in the form of an application. <br><br><h3>  <font color="#3AC1EF">‚ñçC.</font>  <font color="#3AC1EF">Jasonette Web Container 2.0: Application and Container Interaction</font> </h3><br>  After the release of the first version, I experimented with the second part of the above task, which was to allow the container to interact with the parent application. <br>  Let's talk about how I managed to add interactivity to a regular web container, which made it much more powerful and interesting. <br><br><h2>  <font color="#3AC1EF">Implementation: Interactive Web Container</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç1.</font>  <font color="#3AC1EF">Download by URL</font> </h3><br><h4>  <b>Task</b> </h4><br>  Previously, <a href="https://jasonette.com/webcontainer/">in the first version</a> , in order to use the web container as a component to view the data, you first had to write <code>"html"</code> in the attribute <code>$jason.body.background.type</code> , and then in the attribute <code>$jason.body.background.text</code> , enter the HTML code. <br><br><pre> <code class="hljs perl">{ <span class="hljs-string"><span class="hljs-string">"$jason"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"head"</span></span>: {     ...   },   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: {     <span class="hljs-string"><span class="hljs-string">"background"</span></span>: {       <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>,       <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span></span>     }   } } }</code> </pre> <br>  It‚Äôs quite natural that developers find it easier to initialize the container using a regular link to a web page, instead of entering all the HTML code of the page in one line. <br><br><h4>  <b>Decision</b> </h4><br>  The <code>url</code> attribute appeared in Web Container 2.0.  It supports local files in particular.  By using the <code>file://...</code> construct in the container, you can output the file that comes with the application. <br><br><pre> <code class="hljs perl">{ <span class="hljs-string"><span class="hljs-string">"$jason"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"head"</span></span>: {     ...   },   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: {     <span class="hljs-string"><span class="hljs-string">"background"</span></span>: {       <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>,       <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"file://index.html"</span></span>     }   } } }</code> </pre> <br>  Similarly, the output of web pages from the Internet is carried out (using a structure of the form <code>http[s]://‚Ä¶</code> ) <br><br><pre> <code class="hljs perl">{ <span class="hljs-string"><span class="hljs-string">"$jason"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"head"</span></span>: {     ...   },   <span class="hljs-string"><span class="hljs-string">"body"</span></span>: {     <span class="hljs-string"><span class="hljs-string">"background"</span></span>: {       <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>,       <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://news.ycombinator.com"</span></span>     }   } } }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç2.</font>  <font color="#3AC1EF">Bilateral interaction between the application and the web container</font> </h3><br><h4>  <b>Task</b> </h4><br>  Previously, web containers were used only to display some content, they could not interact with the main application.  This meant that the following usage scenarios were impossible: <br><br><ol><li>  The impact of Jasonette on a web container.  Namely, it was impossible to call JavaScript functions located in a container from a Jasonette application. <br></li><li>  The impact of the container on Jasonette.  It was impossible to call native APIs from code located in a container. <br></li></ol><br>  The web container could only be used for displaying pages.  This is similar to how <code>iframe</code> elements are embedded into regular web pages when the page cannot access what is inside these elements. <br><br><h4>  <b>Decision</b> </h4><br>  The goal of the Jasonette project is to create a standard markup language that allows you to describe cross-platform mobile applications.  In this case, we need a markup language that can accurately describe the interaction between the parent application and the child web container. <br><br>  In order to achieve this, I used <a href="http://www.jsonrpc.org/specification">JSON-RPC</a> technology, which allowed us to organize the interaction of the application and the web container.  Since everything in Jasonette is expressed as JSON objects, it was natural to use the standard JSON-RPC format as a communication protocol. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd2/bd9/9fb/fd2bd99fb08ac985bb3bf52914f17052.png"></div><br>  <i><font color="#999999">Before using JSON-RPC, Jasonette and the web container could not interact.</font></i>  <i><font color="#999999">After JSON-RPC implementation, two-way communication between the main application and the container has become possible.</font></i> <br><br>  In order to be able to call the JS functions that are in the web container, we declare the action <code>$agent.request</code> . <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"$agent.request"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"$webcontainer"</span></span>,   <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"login"</span></span>,   <span class="hljs-attr"><span class="hljs-attr">"params"</span></span>: [<span class="hljs-string"><span class="hljs-string">"username"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>] } }</code> </pre> <br>  <a href="https://docs.jasonette.com/agents/">$ agent.request</a> is a native API that initiates a JSON-RPC request to a web container.  To use this mechanism, you need to pass an <code>options</code> object to it as a parameter. <br><br>  The <code>options</code> object is the <a href="http://www.jsonrpc.org/specification">JSON-RPC request</a> that will be sent to the web container. <br><br>  Consider its attributes. <br><br><ul><li>  <code>id</code> : the web container is built on top of the low-level agent architecture.  Usually several agents may be associated with one <code>view</code> element, each of them may have a unique identifier (ID).  However, a web container is a <a href="https://docs.jasonette.com/web/">special type of agent</a> that can only have the <code>$webcontainer</code> identifier, which is why we use this identifier in the request. <br></li><li>  <code>method</code> : the name of the javascript function to call. <br></li><li>  <code>params</code> : an array of parameters to pass to the called JS function. <br></li></ul><br>  Here is the full code of the markup described: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"$jason"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"head"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"actions"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"$load"</span></span>: {         <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"$agent.request"</span></span>,         <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: {           <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"$webcontainer"</span></span>,           <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"login"</span></span>,           <span class="hljs-attr"><span class="hljs-attr">"params"</span></span>: [<span class="hljs-string"><span class="hljs-string">"alice"</span></span>, <span class="hljs-string"><span class="hljs-string">"1234"</span></span>]         }       }     }   },   <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"header"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Web Container 2.0"</span></span>     },     <span class="hljs-attr"><span class="hljs-attr">"background"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"file://index.html"</span></span>     }   } } }</code> </pre> <br>  Consider the meaning of the code given here. <br><br>  When loading an item <a href="https://docs.jasonette.com/actions/">($ jason.head.actions. $ Load</a> ), you need to perform a JSON-RPC request described in <code>options</code> to the web container agent ( <a href="https://docs.jasonette.com/agents/">$ agent.request</a> ). <br><br>  The parameters of the web container are specified in <a href="https://docs.jasonette.com/web/">$ jason.body.background</a> ; in this case, the local file <code>file://index.html</code> . <br><br>  During the call to the container, the <code>login</code> function will be searched, which, when called, thanks to <code>params</code> , will be passed two arguments, <code>"alice"</code> and <code>"1234"</code> .  It will look like this: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">login</span></span>("alice", "1234")</code> </pre> <br>  Here I only talked about how the parent application can call JS functions from the web container, however, a <a href="https://docs.jasonette.com/agents/">reverse process</a> is also possible when the container accesses the application to call the native APIs.  Details on this can be found in the agent <a href="https://docs.jasonette.com/agents/">documentation</a> . <br><br><h4>  <b>Example</b> </h4><br>  Let us discuss an example of an application for creating QR codes that you have already seen above. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/356/cd0/18d/356cd018d36356643e8beeb9fb6e71a1.gif"></div><br>  <i><font color="#999999">Application for creating QR codes</font></i> <br><br><ol><li>  <a href="https://docs.jasonette.com/document/">The</a> text input <a href="https://docs.jasonette.com/document/">component</a> at the bottom of the window is 100% native. <br></li><li>  The QR code is generated by a <a href="https://github.com/Jasonette/Jasonpedia/blob/gh-pages/webcontainer/agent/fn/agent.html">web application</a> hosted in a web container. <br></li><li>  When the user enters some text into the field and presses the <code>Generate</code> button, the action of the <code>$agent.request</code> agent of the web container is called, which causes the JS function <code>qr</code> called. <br></li></ol><br>  The code for this application can be found <a href="">here.</a> <br><br><h3>  <font color="#3AC1EF">‚ñç3.</font>  <font color="#3AC1EF">Script injection</font> </h3><br><h4>  <b>Task</b> </h4><br>  Sometimes you need to dynamically inject JavaScript code into web containers after you have loaded the source HTML code. <br><br>  Imagine you want to create your own web browser.  To do this, you may need to embed your JS scripts in each web container in order to be able to influence its behavior.  In fact, this is how web browser extensions work. <br><br>  Even if you do not develop a web browser, you may need to use script injection if you need to provide the necessary behavior for pages that you cannot directly control.  The only way a mobile application can interact with a web container is to use the <code>$agent</code> API.  But if you cannot change the HTML content, the only way to add the <code>$agent</code> interface to a web container is to dynamically implement the scripts. <br><br><h4>  <b>Decision</b> </h4><br>  As already mentioned, the <code>$jason.body.background</code> web container is just an agent.  This means that when working with it, you can use the same <code>$agent.inject</code> method as with normal agents. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb6/d2b/808/fb6d2b8080c471cc80367dafb50d4b1b.png"></div><br>  <i><font color="#999999">Embedding JS code into a page loaded into a web container</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç4.</font>  <font color="#3AC1EF">URL conversion processing</font> </h3><br>  Previously, a web container could handle link clicks in only two ways, being in one of two modes. <br><br><ol><li>  In read-only mode, the web container is treated as a read-only item, with all events, such as tapping or scrolling, being ignored.  All web containers are read-only until they are switched to regular browser mode, as described below. <br></li><li>  In the "normal browser" mode, the web container can interact with the page as if we were working with a regular browser.  You can enable this mode by writing the value <code>"type": "$default"</code> to the <code>action</code> attribute. <br></li></ol><br><h4>  <b>Task</b> </h4><br>  The problem here is that both of the above options are solutions that represent the concept of ‚Äúall or nothing.‚Äù <br><br>  When operating in read-only mode, the container ignores all user actions. <br><br>  When operating in the "normal browser" mode, the web container works, literally, as a browser.  When a user touches a link, the page to which the link leads is loaded.  In this case, the developer is not able to intercept this event and call, for example, some native API. <br><br><h4>  <b>Decision</b> </h4><br>  Due to the capabilities of the new web container, the <code>action</code> attribute can be specified in the <code>$jason.body.background</code> attribute, which contains a description of the mechanism for processing links clicks. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe6/c4a/fa4/fe6c4afa443fff03f55ccd7094273520.png"></div><br>  <i><font color="#999999">Action to handle link interactions</font></i> <br><br>  Consider an example. <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"$jason"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"head"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"actions"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"displayBanner"</span></span>: {         <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"$util.banner"</span></span>,         <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: {           <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Clicked"</span></span>,           <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Link {{$jason.url}} clicked!"</span></span>         }       }     }   },   <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"background"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"file://index.html"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: {         <span class="hljs-attr"><span class="hljs-attr">"trigger"</span></span>: <span class="hljs-string"><span class="hljs-string">"displayBanner"</span></span>       }     }   } } }</code> </pre> <br>  Here we attached to the web container the action <code>"trigger": "displayBanner"</code> .  This means that when the user clicks on any link displayed on the page displayed in the web container, the <code>displayBanner</code> action will be triggered.  At the same time, the web container itself will not process the click on the link. <br><br>  In addition, if you analyze the <code>displayBanner</code> event, you will notice the <code>$jason</code> variable.  In this case, the link that was clicked will be passed to the action through this variable.  For example, if you click on the link that contains the address <code>"https://google.com"</code> , the following will fall into <code>$jason</code> : <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://google.com"</span></span> }</code> </pre> <br>  This means that by analyzing the <a href="https://docs.jasonette.com/web/">value of</a> <code>$jason.url</code> various actions can be <code>$jason.url</code> . <br><br>  Consider another example, which is an implementation of a web browser. <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"$jason"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"head"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"actions"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"handleLink"</span></span>: [{         <span class="hljs-attr"><span class="hljs-attr">"{{#if $jason.url.indexOf('signin') !== -1 }}"</span></span>: {           <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"$href"</span></span>,           <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: {             <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"file://key.html"</span></span>           }         }       }, {         <span class="hljs-attr"><span class="hljs-attr">"{{#else}}"</span></span>: {           <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"$default"</span></span>         }       }]     }   },   <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: {     <span class="hljs-attr"><span class="hljs-attr">"background"</span></span>: {       <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"file://index.html"</span></span>,       <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: {         <span class="hljs-attr"><span class="hljs-attr">"trigger"</span></span>: <span class="hljs-string"><span class="hljs-string">"handleLink"</span></span>       }     }   } } }</code> </pre> <br>  Here we check whether the URL contains the string <code>signin</code> , and, depending on the results of the check, we perform various actions. <br><br><ol><li>  If the URL contains a <code>signin</code> , a native login window opens. <br></li><li>  If the URL of this line does not contain, the action specified by the parameter <code>"type": "$default"</code> is performed, as a result, our program behaves like a normal browser. <br></li></ol><br><h2>  <font color="#3AC1EF">Examples</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç Web browser development</font> </h3><br>  Now we can take advantage of the capabilities of the new Web Container element for application development.  Namely, we are talking about the following: <br><br><ol><li>  Ability to standard processing clicks on the links, which corresponds to the behavior of a regular browser. <br></li><li>  The ability to handle clicks on links, based on their content. <br></li></ol><br>  All this gives us the opportunity, for example, to create our own browser, writing literally a half dozen lines of JSON code.  Since we can now intercept link clicks, we can analyze <code>$jason.url</code> and perform actions corresponding to different URLs. <br><br>  Consider an example. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25a/4d8/87b/25a4d887b14b2ef772f42e2d5ab95c87.gif"></div><br>  <i><font color="#999999">Standard browser behavior</font></i> <br><br>  Here the web container behaves like a regular browser ( <code>"type": "$default"</code> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/7fc/000/b887fc000aa161bf725040643c3abda0.gif"></div><br>  <i><font color="#999999">Behavior based on the analysis of the $ jason.url parameter</font></i> <br><br>  Here, when you click on a link, a native transition between pages is applied. <br><br>  This can be achieved by processing various actions based on the value of <code>$jason.url</code> . <br><br>  The first step in creating such an application is to join the <code>visit</code> action web container. <br><br><pre> <code class="hljs objectivec">{ ... <span class="hljs-string"><span class="hljs-string">"body"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"background"</span></span>: {     <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>,     <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://news.ycombinator.com"</span></span>,     <span class="hljs-string"><span class="hljs-string">"action"</span></span>: {       <span class="hljs-string"><span class="hljs-string">"trigger"</span></span>: <span class="hljs-string"><span class="hljs-string">"visit"</span></span>     }   } } }</code> </pre> <br>  The second step is to perform in the <code>visit</code> action the corresponding operation based on the analysis of <code>$jason.url</code> . <br><br>  The following shows how we check whether the <code>newest</code> , <code>show</code> , <code>ask</code> , and so on lines are in <code>$jason.url</code> (they are links in the top menu).  If something like this can be found, we allow the web container to behave like a normal browser, setting the value to <code>"type": "$default"</code> . <br><br>  If it was not possible to find a match to the above template, we make the <code>$href</code> native transition to the new window, passing the URL that the user clicked as a parameter. <br><br><pre> <code class="hljs perl">... <span class="hljs-string"><span class="hljs-string">"actions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"visit"</span></span>: [   {     <span class="hljs-string"><span class="hljs-string">"{{#if /\\/(newest|show|ask)$/.test($jason.url) }}"</span></span>: {       <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"$default"</span></span>     }   },   {     <span class="hljs-string"><span class="hljs-string">"{{#else}}"</span></span>: {       <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"$href"</span></span>,       <span class="hljs-string"><span class="hljs-string">"options"</span></span>: {         <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://jasonette.github.io/Jasonpedia/webcontainer/agent/hijack.json"</span></span>,         <span class="hljs-string"><span class="hljs-string">"preload"</span></span>: {           <span class="hljs-string"><span class="hljs-string">"background"</span></span>: <span class="hljs-string"><span class="hljs-string">"#ffffff"</span></span>         },         <span class="hljs-string"><span class="hljs-string">"options"</span></span>: {           <span class="hljs-string"><span class="hljs-string">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{$jason.url}}"</span></span>         }       }     }   } ] },</code> </pre> <br>  <a href="">Here</a> you can see the full JSON-code of this example, which, by the way, takes only 48 lines. <br><br><h3>  <font color="#3AC1EF">‚ñçFast hybrid application development</font> </h3><br>  By ‚Äúhybrid‚Äù applications usually mean normal web applications ‚Äúwrapped‚Äù in native mobile applications. <br><br>  However, here we mean something else.  In our case, we are talking about real hybrid applications, when the same application can have several native views and several web views at the same time.  In addition, one representation of such an application can have several native user interface components and a web container, and, all this is displayed in one native layout. <br><br>  The transition between a control that displays web content and standard controls should be so invisible that it would be difficult to detect the boundary between them. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/a13/77d/122a1377d161cb5ab1d273a9f9f147a8.gif"></div><br>  <i><font color="#999999">Hybrid application</font></i> <br><br>  In this example, I created an application that displays the site <a href="https://www.jasonbase.com/">jasonbase.com</a> in a web container acting as the main element for data visualization. <br><br>  Jasonbase is a free hosting service that I created specifically to host JSON markup applications based on Jasonette. <br><br>   ,  ‚Äî  ,      Jasonette-,  ,    ,     -,    <code>$href</code>     JASON. <br><br>      Jasonbase.com  ,    .    -  Jasonette-   -          , ,  ,   , ,  ,      ,    . <br><br>      <a href=""></a> . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br> ,        ,        ,      . <br><br>    ,  ,    ,        : <br><br><ul><li>  -   . <br></li><li>  JavaScript-,      . <br></li><li>    ,        ,   API. <br></li></ul><br>   ,    Jasonette,    ,     : <br><br><ol><li>   ,     ,   -      . <br></li><li>   (JSON-RPC), ,  ,        -. <br></li></ol><br>     ,   ‚Äî   ,     ,  ,     ,   . <br><br>    ,   ,          (  ,        -  ,    ). ,   ,  JS-  ,         . <br><br>  ,     Jasonette,  ,  ,  ,   . , , <a href="https://docs.jasonette.com/web/"></a>  ,  . <br><br>       ,   , : ¬´  ‚Äî   ¬ª. ,    Jasonette, , , , ,   ,         HTML,   ,       . <br><br> -   Jasonette   ,    -.  ¬´¬ª    ¬´-¬ª.         . <br><br>       ,      ,    ,        ,  HTML-.    ,         .     ,      . <br><br>    ,    ,         Jasonette  -        .  ,      .   ‚Äî . <br><br>  <b>Dear readers!</b>     Jasonette   -  ? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/352200/">https://habr.com/ru/post/352200/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352190/index.html">Divide and conquer: demarcation of access to the records of conversations</a></li>
<li><a href="../352192/index.html">How to become a GPU engineer in an hour</a></li>
<li><a href="../352194/index.html">How to grow from a junior tester into a good tester? Continuation</a></li>
<li><a href="../352196/index.html">Comparison of ITSM-systems</a></li>
<li><a href="../352198/index.html">Classes and factory functions in javascript. What to choose?</a></li>
<li><a href="../352202/index.html">The book "Head First. Design patterns. Updated anniversary edition ¬ª</a></li>
<li><a href="../352206/index.html">Release of PVS-Studio for macOS: 64 weaknesses in Apple XNU Kernel</a></li>
<li><a href="../352208/index.html">How to perform many UI tests in parallel using Selenium Grid?</a></li>
<li><a href="../352210/index.html">Automation in the development of the platform "1C: Enterprise"</a></li>
<li><a href="../352212/index.html">Gaijin Engineer in Tokyo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>