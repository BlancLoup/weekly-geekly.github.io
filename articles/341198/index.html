<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Some features of programming time events in games</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Survived . Recently, the problem of synchronizing gameplay with real time was discovered not just anywhere, but in the game "Quake Champions" . The na...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Some features of programming time events in games</h1><div class="post__text post__text-html js-mediator-article"><p>  <strong>Survived</strong> .  Recently, the <a href="https://dtf.ru/11758-igroki-obnaruzhili-svyaz-mezhdu-skorostyu-strelby-i-chastotoy-kadrov-v-quake-champions">problem of synchronizing gameplay with real time</a> was discovered <a href="https://dtf.ru/11758-igroki-obnaruzhili-svyaz-mezhdu-skorostyu-strelby-i-chastotoy-kadrov-v-quake-champions">not just anywhere, but in the game <strong>"Quake Champions"</strong></a> .  The name of the game <strong>"Quake"</strong> used to be synonymous with something cool, high-tech and perfect.  And it never occurred to me that in a couple of decades and there would be no stone left from the former superiority, and in the new game with the name <strong>"Quake"</strong> gross errors will appear, leading to the fact that one of the players can get an advantage only because he has better iron.  The fact is that the speed of shooting in a new shooter depends on fps, that is, the number of bullets fired by players with different fps values ‚Äã‚Äãfor the same period of time will be different, which means one of them can gain an advantage. </p><br><p>  This article is recommended to read to all game developers, and in particular to developers of programs for moving mechanisms.  Yes, there were similar problems in the <a href="https://github.com/arduino/Arduino/commit/1064554b87274f4136460312286ff89b3b94f034">library</a> code <a href="https://github.com/arduino/Arduino/commit/1064554b87274f4136460312286ff89b3b94f034">for working with stepper motors for Arduino</a> .  But if you create programs to control the flight of missiles, or for nuclear reactors, then guys, this article will not help you.  You need other levels of synchronicity, and special hardware running RTOS. </p><a name="habracut"></a><br><h1 id="vstuplenie">  Introduction </h1><br><p>  Anyone who has ever developed an application containing an animation (whether it be a game, visualization of physical processes, or just an animation of a user interface) has encountered the problem of synchronizing processes with real time.  The speed of the application can never be constant even for the same computer, not to mention computers with different parameters of the processor, RAM and hard disk. </p><br><p>  When solving this problem, a problem arises (and not very trivial, as it may seem at first glance), which is usually called ‚Äútimer synchronization‚Äù, ‚Äúlinking to timer‚Äù, ‚Äúlinking to real time‚Äù.  The essence of this task is to make the animation and other events in the program tied to real time and not depend on computer performance. </p><br><p>  I hope you all played some kind of dynamic network shooter, like Quake or Half-Life, and you know how fast events happen there, how important a player‚Äôs quick reaction and accuracy of his actions are.  In order for a player to play comfortably, the game must show maximum performance, the delay in delivery of network packets is minimal, the keyboard and mouse must be comfortable (and usually fabulously expensive).  But even with the satisfaction of all these conditions, a game written without taking into account the nuances of the model of temporary processes of program execution can deliver a lot of unpleasant moments.  In general, time synchronization is fatal in very fast dynamic games, but sometimes spoils the mood in other areas that are completely unrelated to games. </p><br><h1 id="otlichie-prirodnogo-vremeni-ot-vremeni-kompyuternogo">  The difference of "natural" time from time "computer". </h1><br><p>  Even physicists have not yet come to a common understanding of what time is.  But for ordinary people, in observable reality, where space-time is not too distorted, it seems that time flows continuously, and events occur in parallel.  It seems that the objects are actually where we see them, and our everyday experience constantly confirms this.  Time in programs looks very different than in observable reality.  Forgetting about this, it is difficult to correctly model the behavior of objects in time.  Let's understand the properties of "computer" time. </p><br><h1 id="diskretnost-kvantovanie">  Discreteness (Quantization) </h1><br><p>  The effects of the flow of time are created through animation - creating a sequence of static pictures (frames), which, with a quick change, create the illusion of movement.  Due to the inertia of vision and perception, the brain is forced to complete the missing elements of the movement, so when playing a sequence of little different frames, it seems to us that the movement occurs smoothly.  The division of the time process into frames gives computer time the property of discreteness - that is, objects in the path of their movement can occupy only a certain finite number of positions, in the case of "natural" time, it seems that objects in their path occupy an incalculable number of positions. </p><br><h1 id="neodnorodnost">  Heterogeneity </h1><br><p>  At one moment of ‚Äúnatural‚Äù time, the processor core performs only one operation.  This gives the "computer" time the property that distinguishes it from the "natural" time - this is the property of the heterogeneity of its flow.  That is, for all of our game objects, time does not flow at the same time. </p><br><p>  Suppose we have two objects, the state of each object depends on the state of the other.  The state will be calculated for objects sequentially, which means that the first object will calculate its state based on the previous state of another object (irrelevant), and the second object will calculate its state based on the state of the first object (actual, but not correct, t. to. it was calculated from the irrelevant state of the second object).  A vicious circle of errors is formed due to the fact that objects are processed sequentially, because the ‚Äúcomputer‚Äù time is not uniform. </p><br><h1 id="vysokoproizvoditelnyy-taymer">  High performance timer </h1><br><p>  To measure time intervals in programs, it is advisable to use functions that provide relatively high accuracy.  In Windows, QueryPerfomanceCounter is used, in Linux gettimeofday.  Accuracy can differ on different processors, but they almost always give accuracy better than 1 millisecond. </p><br><h1 id="tipichnyy-main-loop">  Typical main loop </h1><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dt = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (is_run) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (active == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) WaitMessage(); timer.start(); doUpdate(dt); doRender(); dt = timer.elapsed(); }</code> </pre> <br><h1 id="vidy-sinhronizacii">  Types of sync </h1><br><p>  I distinguish between two ways to synchronize time, each has its own advantages and disadvantages. </p><br><h1 id="integrirovanie">  Integration </h1><br><p>  The first method is called "integration".  It differs in that the update of the state of objects is called strictly every frame, while we need to measure the time spent on building the frame and use this time to build the next one.  For example, we need the value of a variable to increase by one per second.  For this we can do the following: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt)</span></span></span><span class="hljs-function"> </span></span>{ value += dt; }</code> </pre> <br><p>  This is an example of the simplest integration. </p><br><p>  There are many numerical integration algorithms, the most famous are the Euler method and the Runge-Kutta methods.  The Euler method is the simplest method for solving differential equations, but is not suitable for solving complex equations, since it gives unsatisfactory accuracy.  The Euler method is the fastest method and is well suited for use in game development.  Runge-Kutta methods are used to solve complex systems of differential equations, and are used where high accuracy is needed. </p><br><p>  Suppose we have a standard task: it is necessary to calculate the movement of the body under the action of force.  The integration will look like this: </p><br><pre> <code class="cpp hljs">vec3 pos; vec3 velocity; vec3 force; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt)</span></span></span><span class="hljs-function"> </span></span>{ pos += velocity * dt + (force * dt * dt) / <span class="hljs-number"><span class="hljs-number">2</span></span>; velocity += force * dt; }</code> </pre> <br><p>  Here we see the well-known school formula: </p><br><pre> <code class="hljs lisp">S = v0*t + (<span class="hljs-name"><span class="hljs-name">a</span></span> * t^2) / 2</code> </pre> <br><p>  An important note is that if we change the order of integration of speed and position, we get the wrong result. </p><br><p>  Now let's talk about the disadvantages of this method.  The fact is that the formula for integration is not always as simple as it might seem.  I can cite as an example the game STALKER, in which I could not normally play on my weak computer - but not because fps was very unacceptable, but just because the developers used something to smooth the rotation of the camera like this: </p><br><pre> <code class="cpp hljs">vec3 camera_angles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt)</span></span></span><span class="hljs-function"> </span></span>{ vec3 new_camera_angles = input.getMouseDelta(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> k = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-comment"><span class="hljs-comment">// k = 0.0f..1.0f camera_angles = new_camera_angles * k + camera_angles * (1.0f - k); }</span></span></code> </pre> <br><p>  Because of this, the camera was too inert at low fps values.  It would seem that simple and obvious smoothing, but incorrectly implemented, it creates discomfort for the player at low fps values, not allowing him to enjoy all the delights of the exclusion zone.  As a result, I never played in STALKER. </p><br><h1 id="fixed-time-step">  Fixed time step </h1><br><p>  This method is based on the fact that we update the state of objects given a constant number of times per second, thereby fixing the time step.  The undeniable advantage of this method is that we no longer need to integrate - the formulas become simple and predictable.  We simply make it so that the onUpdate () function is called, say, 60 times per second, and we forget about the constant need to integrate all state change processes.  Undoubtedly, this method makes life much easier, especially when the game contains network interactions. </p><br><p>  I would advise using this method to those who are not too willing to delve into the problems of proper time control and integration, but still this method does not completely solve the problems of time heterogeneity.  For online games, this is probably the only option when all processes on different computers will occur more or less synchronously. </p><br><p>  Naturally, the method also contains pitfalls: </p><br><ul><li>  Updating the logic is no longer associated with frames, so the movements may not look as smooth as when integrated.  It does not make sense to show the player more frames per second than the refresh rate of the logic.  Therefore, it is better to make the refresh rate of the logic equal to the frame scan frequency - say, 60, 85, or 120. If the game is too dynamic, it is better to make 120, many modern game monitors can show so many frames. </li><li>  There is a problem that I call the ‚Äútemporary collapse‚Äù, or you can call it ‚Äúthe black hole of time‚Äù.  The problem arises when the execution time of the onUpdate () function is quite large (suppose all the physics are calculated there, and a huge number of objects have been added).  At the same time, the onUpdate () game loop begins to be called more and more times, and the program just hangs.  We spend a lot of time on onUpdate (), which means we need to compensate for the past time with two onUpdate (), two onUpdate () are already four onUpdate () in the next cycle - and so on.  Therefore, it is necessary to control the rendering time of logic, and if it is too large, it is necessary to limit it.  Naturally, after this, no synchronicity can be expected, but this will save from a hang.  In this case, the user can be informed that his computer cannot cope with the calculations, and offer to purchase a faster computer :) </li></ul><br><h1 id="periodicheskie-sobytiya">  Periodic events </h1><br><p>  Let us turn to more specific examples.  Periodic event I call an event that occurs after a fixed time interval.  An example of such an event is the implementation of an onUpdate () call with a specified frequency when implementing a fixed time step. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> freq = <span class="hljs-number"><span class="hljs-number">10.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> time_to_event = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ifreq = <span class="hljs-number"><span class="hljs-number">1</span></span> / freq; time_to_event -= dt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (time_to_event &lt;= <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) { event(); time_to_event += ifreq; } }</code> </pre> <br><p>  In this example, the onUpdate () event will be triggered at a freq rate once per second.  We see that if the ifreq is less than dt (that is, the specified calling frequency is greater than fps ‚Äî the calling frequency of doUpdate ()), then onUpdate () will be called several times within the same doUpdate ().  It seems to be all right, but what if you imagine that onUpdate () creates an object that also has a state variable in time? </p><br><p>  Let's imagine that we have a shot event from an automaton that should be processed inside onUpdate, just like any game logic.  If two shots happen within one onUpdate (), the bullets will simply be created at one point and will fly parallel alongside, although in fact they are separated by a time period of ifreq, for which one bullet flew farther than the other. </p><br><p>  Let's see how to avoid this: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bullet</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt)</span></span></span><span class="hljs-function"> </span></span>{ } }; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fire_rate = <span class="hljs-number"><span class="hljs-number">10.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> time_to_shoot = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;Bullet *&gt; bullets; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;bullets.size(); i++) { bullets[i]-&gt;update(dt); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ifire = <span class="hljs-number"><span class="hljs-number">1</span></span> / freq; time_to_shoot -= dt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (time_to_shoot &lt;= <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) { Bullet *bullet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bullet(); bullet-&gt;update(-time_to_shoot); bullets.push_back(bullet); time_to_shoot += ifreq; } }</code> </pre> <br><p>  In this example, we will compensate the pool for the time that has passed from the moment it was launched to the next onUpdate () call, where Bullet :: update () will be called in the normal manner. </p><br><p>  And what will happen if the player moves when shooting, or the direction of the shot will change?  This also needs to be taken into account: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bullet</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTransform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Transform &amp;tf)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fire_rate = <span class="hljs-number"><span class="hljs-number">10.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> time_to_shoot = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;Bullet *&gt; bullets; Transform old_tf; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> first_update = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;bullets.size(); i++) { bullets[i]-&gt;update(dt); } Transform tf = getBarrelTransform(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_update) { old_tf = tf; first_update = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ifire = <span class="hljs-number"><span class="hljs-number">1</span></span> / freq; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> k = time_to_shoot / dt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> delta_k = ifire / dt; time_to_shoot -= dt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (time_to_shoot &lt;= <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> k = <span class="hljs-number"><span class="hljs-number">1.0f</span></span> - (-time_to_shoot / dt); Bullet *bullet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bullet(); bullet-&gt;setTransform(lerp(old_tf, tf, k)); bullet-&gt;update(-time_to_shoot); bullets.push_back(bullet); time_to_shoot += ifreq; } old_tf = tf; }</code> </pre> <br><p>  In this case, we still made a small assumption.  The fact is that the law of motion of the barrel of a weapon may be non-linear, but we linearly interpolate the transformation, approximately estimating the position of the barrel within the time range of dt.  Of course, it is possible to absolutely exactly find the required position, but this will complicate the code even more. </p><br><p>  In fact, if you go deeper into this topic, it becomes clear that the more accurately we want to handle temporary events, the more difficult the program will be.  It would seem that the simple and obvious code of a periodic event became much more complicated when we began to take into account the properties of the ‚Äúprogram‚Äù time.  Therefore, in some cases it is necessary to put up with the fact that not everything is as correct as it would be in the ideal case.  But it is also impossible not to take into account the properties of ‚Äúcomputer time‚Äù, especially in very dynamic network games, where I would like to get the maximum response from management, and to achieve maximum synchronization between the clients and the server. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/341198/">https://habr.com/ru/post/341198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341180/index.html">Paul Graham. All articles in Russian. Two years later</a></li>
<li><a href="../341182/index.html">Virtual Infrastructure Provider Development: 1cloud Experience</a></li>
<li><a href="../341192/index.html">Localization of comments in the code. Yandex lecture</a></li>
<li><a href="../341194/index.html">About backups, black friday and communication between people: how we messed up and learned not to do it anymore</a></li>
<li><a href="../341196/index.html">Transfer of tasks and schedules from one instance of MS SQL Server to another using T-SQL</a></li>
<li><a href="../341200/index.html">2.Check Point to the maximum. HTTPS Inspection</a></li>
<li><a href="../341202/index.html">MockK - library for mocking in Kotlin</a></li>
<li><a href="../341206/index.html">The digest of interesting materials for the mobile developer # 227 (October 23 - October 29)</a></li>
<li><a href="../341208/index.html">Barnes-Hut t-SNE and LargeVis: visualization of large amounts of data</a></li>
<li><a href="../341212/index.html">Hacking Bitcoin on TV: obfuskuy, not obfuskuy, still get QR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>