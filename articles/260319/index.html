<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript immutability</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Immutability is the basic principle of functional programming, which also has much to offer object-oriented programs. In this article, I will tell you...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript immutability</h1><div class="post__text post__text-html js-mediator-article">  Immutability is the basic principle of functional programming, which also has much to offer object-oriented programs.  In this article, I will tell you about what exactly is the cornerstone of immutability, how to use this concept in JavaScript, and why it is useful. <br><a name="habracut"></a><br><h1>  What is immutability? </h1><br>  The book definition of changeability reads as follows: "the tendency of an object to change or transform."  In programming, we use this word when we mean objects whose state can be changed over time.  The immutable value is exactly the opposite; it will never change after creation. <br><br>  If this seems odd, let me remind you that most of the values ‚Äã‚Äãthat we use all the time are actually immutable: <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> statement = <span class="hljs-string"><span class="hljs-string">"I am an immutable value"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> otherStr = statement.slice(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>);</code> </pre> <br>  I think that no one will be surprised if he finds out that the second line in no way changes the string value of the <b>statement</b> .  In reality, there are no string methods that would modify the string on which they perform the action, they all return new strings.  The reason is that strings are immutable - they cannot be converted; we can only create new strings. <br><br>  Strings are not the only immutable values ‚Äã‚Äãembedded in JavaScript.  Numbers are also immutable.  In general, can you imagine an environment where the calculation of the expression <b>2 + 3</b> <i>changes the value of the</i> number <b>2</b> ?  It sounds absurd, although we do it all the time with our objects and arrays. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  In JavaScript, variability is abundant </h1><br>  In JavaScript, strings and numbers are designed to be immutable.  However, consider the following example using arrays: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v2 = arr.push(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  What is the value of <b>v2</b> ?  If the arrays behaved according to strings and numbers, then v2 would contain a new array with one element inside - 2. However, this is a different case.  Instead, the link <b>arr</b> was changed to contain a number, and <b>v2</b> contains a new length <b>arr</b> . <br><br>  Imagine the <b>ImmutableArray</b> type.  His behavior, borrowing from numbers and strings, would look like this: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v2 = arr.push(<span class="hljs-number"><span class="hljs-number">5</span></span>); arr.toArray(); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4] v2.toArray(); // [1, 2, 3, 4, 5]</span></span></code> </pre><br>  Similarly, an immutable associative array, which could be used instead of most objects, would have methods for ‚Äúsetting‚Äù properties that would not actually set anything, but would return a new object with the required changes: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableMap({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> olderPerson = person.set(<span class="hljs-string"><span class="hljs-string">"age"</span></span>, <span class="hljs-number"><span class="hljs-number">33</span></span>); person.toObject(); <span class="hljs-comment"><span class="hljs-comment">// {name: "Chris", age: 32} olderPerson.toObject(); // {name: "Chris", age: 33}</span></span></code> </pre><br>  Just as <b>2 + 3</b> does not change the values ‚Äã‚Äãof either 2 or 3, the celebration by someone of their 33rd birthday does not cancel the truth that a person was 32 years old. <br><br><h1>  JavaScript immutability in practice </h1><br>  JavaScript (for now) does not have immutable lists and associative arrays, so now we need a third-party library.  There are 2 very good libraries available.  The first one is <a href="https://github.com/swannodette/mori">Mori</a> , which allows you to use persistent data structures from ClojureScript, as well as JavaScript support APIs.  The second is <a href="https://github.com/facebook/immutable-js">immutable.js</a> , written by developers from Facebook.  In this demonstration, I will use immutable.js for the simple reason that its API is more familiar to JavaScript developers. <br><br>  In this demonstration, we will consider the principle of working with immutable data in Minesweeper.  The board is represented by an immutable associative array, in which <b>tiles</b> are the most interesting part of the data.  This is an immutable list of immutable associative arrays, where each of the latter (i.e. assoc. Masses - <i>approx. Lane</i> ) represents a separate tile on the board.  The entire construct is initialized using JavaScript objects and arrays, and then becomes ‚Äúimmortal‚Äù thanks to the <b>fromJS</b> function from immutable.js: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Immutable.fromJS({ <span class="hljs-attr"><span class="hljs-attr">cols</span></span>: options.cols, <span class="hljs-attr"><span class="hljs-attr">rows</span></span>: options.rows, <span class="hljs-attr"><span class="hljs-attr">tiles</span></span>: initTiles(options.rows, options.cols, options.mines) }); }</code> </pre><br>  The rest of the core of the game logic is implemented as functions that take this immutable structure as their first argument and return a new instance.  The most important function is <b>revealTile</b> .  When called, she marks the tile as open to open it.  With a variable data structure, it will be very simple: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revealTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">game, tile</span></span></span><span class="hljs-function">) </span></span>{ game.tiles[tile].isRevealed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  But with immutable structures like those suggested above, it becomes more than difficult: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revealTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">game, tile</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updatedTile = game.get(<span class="hljs-string"><span class="hljs-string">'tiles'</span></span>).get(tile).set(<span class="hljs-string"><span class="hljs-string">'isRevealed'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updatedTiles = game.get(<span class="hljs-string"><span class="hljs-string">'tiles'</span></span>).set(tile, updatedTile); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> game.set(<span class="hljs-string"><span class="hljs-string">'tiles'</span></span>, updatedTiles); }</code> </pre><br>  Fe!  Fortunately, such things are not uncommon.  Therefore, in our toolkit there is a method for such purposes: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revealTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">game, tile</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> game.setIn([<span class="hljs-string"><span class="hljs-string">'tiles'</span></span>, tile, <span class="hljs-string"><span class="hljs-string">'isRevealed'</span></span>], <span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre><br>  The <b>revealTile</b> function <b>now</b> returns a <i>new immutable instance</i> in which one of the tiles is different from the previous version.  <b>setIn is</b> null-stable and is filled with empty objects if any of the parts of the key do not exist.  In the case of the Minesweeper board, this is not desirable, since the missing tile means that we are trying to open the tile outside the board.  This can be mitigated by using <b>getIn</b> to search for a tile before performing actions on it: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revealTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">game, tile</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> game.getIn([<span class="hljs-string"><span class="hljs-string">'tiles'</span></span>, tile]) ? game.setIn([<span class="hljs-string"><span class="hljs-string">'tiles'</span></span>, tile, <span class="hljs-string"><span class="hljs-string">'isRevealed'</span></span>], <span class="hljs-literal"><span class="hljs-literal">true</span></span>) : game; }</code> </pre><br>  If the tile does not exist, then we simply return the existing game.  It was a brief acquaintance with immutability in practice, if you want to understand more carefully, go to this <a href="http://codepen.io/SitePoint/pen/zGYZzQ">codepen</a> , it contains the full implementation of the rules of the game Minesweeper. <br><br><h1>  And what about performance? </h1><br>  You might think that this will have a significant performance degradation and in some ways you will be right.  Every time you add something to an immutable object, we need to create a new instance by copying the existing values ‚Äã‚Äãand adding a new value to it.  This will definitely lead to more memory load, as well as to greater computational costs than would be required for the mutation of an individual object. <br><br>  Since immutable objects never change, they can be implemented using a strategy called ‚Äústructural sharing‚Äù, which generates much less memory costs than you would expect.  Compared to embedded arrays and objects, costs will still exist, but they will have a fixed value and can usually be compensated for by other benefits that are available due to immutability.  In practice, in many cases the use of immutable data will increase the overall performance of your application, even if certain operations become more costly in isolation. <br><br><h1>  Improved change tracking </h1><br>  In any UI framework, one of the most difficult tasks is to search for mutations.  This is such a well-known test that EcmaScript 7 provides a separate API to help track object mutations with better performance: <b>Object.observe ()</b> .  While some people like this API, others feel that this is not the answer to that question.  In any case, it does not solve the problem of tracking mutations properly: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tiles = [{<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">isRevealed</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">isRevealed</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}]; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.observe(tiles, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }); tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  The mutation of the <b>tiles [0]</b> object does not activate our mutation observer, therefore, the proposed mutation tracking mechanism is not suitable even for a trivial application case.  How can immutability help in this situation?  Suppose that an application has state <b>a</b> , and a potentially new application has state <b>b</b> : <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a === b) { <span class="hljs-comment"><span class="hljs-comment">//   ,  }</span></span></code> </pre><br>  If the state of the application has not changed, then this is the same instance as before and we do not need to do anything at all.  This definitely requires that we track the state-containing link, but the whole problem now comes down to the fact that we need to manage a single link. <br><br><h1>  findings </h1><br>  I hope that in this article you have gained some knowledge of how immutability will help you improve your code, and that a continued example can shed light on the practical aspects of working in this direction.  Immutability is gaining popularity and this will not be the last article on this topic that you will read this year.  Try it, and I promise that you will like it very quickly as much as you liked me. </div><p>Source: <a href="https://habr.com/ru/post/260319/">https://habr.com/ru/post/260319/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260303/index.html">The hijacking of Telecom Malaysia trunk provider noticeably worsened global routing last Friday.</a></li>
<li><a href="../260309/index.html">New panels and connections for Kubotronika</a></li>
<li><a href="../260311/index.html">Using git capabilities in the modular project build system</a></li>
<li><a href="../260315/index.html">Bitbucket has announced a plugin system: a new round of wrestling cloud VCS</a></li>
<li><a href="../260317/index.html">Quick start Data Binding in Android</a></li>
<li><a href="../260323/index.html">"Magic quadrant" IaaS providers from Gartner</a></li>
<li><a href="../260325/index.html">How to get an invite to Dribbble with a 100% guarantee</a></li>
<li><a href="../260329/index.html">Run docker compose on Windows</a></li>
<li><a href="../260331/index.html">Run HP ALM tests using Jenkins</a></li>
<li><a href="../260333/index.html">OS Day in Innopolis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>