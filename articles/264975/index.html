<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intervals in C ++, part 3: we represent incrementors (Iterable)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In previous posts I described the problems I encountered when creating a library for working with intervals. Now I will describe to you my solution: i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intervals in C ++, part 3: we represent incrementors (Iterable)</h1><div class="post__text post__text-html js-mediator-article">  In previous posts I described the problems I encountered when creating a library for working with intervals.  Now I will describe to you my solution: improvements to the concept of intervals, which allow you to create intervals with delimiters and infinite intervals that fit perfectly into the hierarchy of the standard library without loss of performance. <br><br>  At the end of the previous post, I summarized the shortcomings of the existing intervals: <br><br><ul><li>  spacing with limiters and infinite spans generates bad code </li><li>  they have to model weaker concepts than they could </li><li>  You can easily transfer an infinite interval to an algorithm that does not digest it. </li><li>  they are difficult to use </li><li>  intervals that can be infinite or very large can cause an overflow in difference_type </li></ul><br>  The first problem is especially difficult, so let's start with it. <br><a name="habracut"></a><br><h2>  Spacing concept </h2><br>  To begin with, let's strictly define the concept of an interval.  In the C ++ standard, this word is used everywhere, but it is not defined anywhere.  It can be understood that an interval is something from which begin and end can be extracted, a couple of iterators that are designed so that end can be reached by starting from begin.  In terms of my proposal, this concept can be formalized as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Iterator_type = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(begin(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;T&gt;())); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Range = requires(T range) { { begin(range) } -&gt; Iterator_type&lt;T&gt;; { end(range) } -&gt; Iterator_type&lt;T&gt;; requires Iterator&lt;Iterator_type&lt;T&gt;&gt;; };</code> </pre> <br><br>  There are also improvements to the Range interval concept called InputRange, ForwardRange, etc.  In fact, they simply require more from their iterators.  The entire hierarchy is shown below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c08/f6b/ae8/c08f6bae8ddb569fab87f5d9f40331bc.png" alt="image"><br><br>  These concepts are the basis for the Boost.Range library (http://www.boost.org/libs/range) <br><br><h2>  Problem 1: Bad Code Generation </h2><br>  If you remember, to implement intervals both with a limiter and infinite, in the form of a pair of iterators, the end iterator must be a signal one.  And such an iterator is more of a <i>concept</i> than the physical position of an element in a sequence.  You can think of it as an element with the ‚Äúlast + 1‚Äù position ‚Äî the only difference is that you don‚Äôt know where its position is until you reach it.  Since the type of signal iterator is the same as that of a normal one, a check at the program execution stage is required to determine if this iterator is a signal iterator.  This leads to slow comparison of iterators and inconvenient implementations of methods. <br><br><h2>  Incremental concept </h2><br>  What are iterators for?  We increase them, dereference and compare, right?  And what can be done with the signal iterator?  Not really a lot of things.  His position does not change, it cannot be dereferenced, because  his position is always ‚Äúlast + 1‚Äù.  But it <i>can be</i> compared with an iterator.  It turns out that the signal iterator is a weak iterator. <br><br>  The problem with intervals is that we are trying to turn a signal iterator into a regular one.  But he is not.  So let's not do it - <i>let them be a different type</i> . <br><br>  The concept of Range requires that begin and end be of the same type.  If you can make them different, it will already be a weaker concept - the concept of Iterable.  Incrementors are like iterators, only begin and end have different types.  Concept: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Sentinel_type = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(end(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;T&gt;())); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Iterable = requires(T range) { { begin(range) } -&gt; Iterator_type&lt;T&gt;; { end(range) } -&gt; Sentinel_type&lt;T&gt;; requires Iterator&lt;Iterator_type&lt;T&gt;&gt;; requires EqualityComparable&lt; Iterator_type&lt;T&gt;, Sentinel_type&lt;T&gt;&gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Range = Iteratable&lt;T&gt; &amp;&amp; Same&lt;Iterator_type&lt;T&gt;, Sentinel_type&lt;T&gt;&gt;;</code> </pre><br><br>  Naturally, the Range concept is part of the Iterable concept.  It simply refines it by adding a constraint on the equality of the begin and end types. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14e/f71/2c4/14ef712c4656831e0c80fe9c345b79b9.png" alt="image"><br><br>  This is the hierarchy, if we consider intervals, incrementors and iterators, but it is not necessary to define them exactly in the program as well.  Notice that ‚Äúintervalness‚Äù ‚Äîthat is, the similarity of the begin and end types is orthogonal to the strength of the begin iterator.  When we need to include a RandomAccessRange simulation in the code, we can say it requires a RandomAccessIterable &amp;&amp; Range and just change the whole concept. <br><br>  The difference between, for example, BidirectionalIterable and ForwardIterable in the concept modeled by the iterator begin from Iterator. <br><br><h2>  Iterable and STL algorithms </h2><br>  But wait, because the STL algorithms will not work with incrementors, because they want begin and end to have the same type.  And there is.  Therefore, I have gone through the entire STL to check what can be rewritten.  For example, std :: find <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIterator</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; first != last; ++first) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*first == value) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; }</code> </pre><br>  Now std :: find uses Ranges.  But note that the algorithm does not attempt to change the position of the end iterator.  The search algorithm can be easily changed so that it works with Iterables instead of Ranges: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIterator</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sentinel</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sentinel</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; first != last; ++first) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*first == value) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; }</code> </pre><br><br>  That's all - the change is so small that it is difficult to even notice. <br><br>  So which C ++ 98 algorithms can be adapted to work with Iterables instead of Ranges?  It turns out almost everything.  It is easier to list those that are not amenable.  It: <br><br><ul><li>  copy_backward </li><li>  algorithms for working with sets and pyramids (push_heap, pop_heap, make_heap, sort_heap) </li><li>  inplace_merge </li><li>  nth_element </li><li>  partial_sort and partial_sort_copy </li><li>  next_permutation and prev_permutation </li><li>  random_shuffle </li><li>  reverse and reverse_copy </li><li>  sort and stable_sort </li><li>  stable_partition </li></ul><br>  The remaining fifty require a purely mechanical change in the code.  Having defined the concept of Iterable as it is defined in the Range, we give any algorithm that works with Iterable to work with Ranges in the same way.  This is useful and important - there is too much code written for iterators to do for them some kind of incompatible abstraction. <br><br><h2>  Perf Proof </h2><br><br>  And what will we get?  Let's return to our C-lines.  I described the c_string_range class and found that enumerating characters generates bad code.  We start again, only using range_facade, to build Iterable instead of Range. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ranges; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c_string_iterable</span></span></span><span class="hljs-class"> :</span></span> range_facade&lt;c_string_iterable&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> range_core_access; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *sz_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">current</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *sz_; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ++sz_; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *sz_ == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c_string_iterable </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;that)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sz_ == that.sz_; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: c_string_iterable(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *sz) : sz_(sz) {} };</code> </pre><br><br>  The code is much simpler than the old one.  All work is done by range_facade.  The iterator and signal iterator are implemented as primitives.  To test it, I generated optimized machine code for the following functions, one of which uses the old c_string_range class, and the other the new c_string_iterable: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Range-based int range_strlen( c_string_range::iterator begin, c_string_range::iterator end) { int i = 0; for(; begin != end; ++begin) ++i; return i; } // Iterable-based int iterable_strlen( range_iterator_t&lt;c_string_iterable&gt; begin, range_sentinel_t&lt;c_string_iterable&gt; end) { int i = 0; for(; begin != end; ++begin) ++i; return i; }</span></span></code> </pre><br><br>  Even without knowing the assembler, you can understand the difference. <br><br><table><tbody><tr><td><pre> <code class="hljs mel">;Range-based strlen pushl %ebp movl %esp, %ebp pushl %esi leal <span class="hljs-number"><span class="hljs-number">8</span></span>(%ebp), %ecx movl <span class="hljs-number"><span class="hljs-number">12</span></span>(%ebp), %esi xorl %eax, %eax testl %esi, %esi movl <span class="hljs-number"><span class="hljs-number">8</span></span>(%ebp), %edx jne LBB2_4 jmp LBB2_1 .<span class="hljs-keyword"><span class="hljs-keyword">align</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">0x90</span></span> LBB2_8: incl %eax incl %edx movl %edx, (%ecx) LBB2_4: testl %edx, %edx jne LBB2_5 cmpb $0, (%esi) jne LBB2_8 jmp LBB2_6 .<span class="hljs-keyword"><span class="hljs-keyword">align</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">0x90</span></span> LBB2_5: cmpl %edx, %esi jne LBB2_8 jmp LBB2_6 .<span class="hljs-keyword"><span class="hljs-keyword">align</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">0x90</span></span> LBB2_3: leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%edx,%eax), %esi incl %eax movl %esi, (%ecx) LBB2_1: movl %edx, %esi addl %eax, %esi je LBB2_6 cmpb $0, (%esi) jne LBB2_3 LBB2_6: popl %esi popl %ebp ret</code> </pre><br></td><td><pre> <code class="hljs mel">;Iterable-based strlen pushl %ebp movl %esp, %ebp movl <span class="hljs-number"><span class="hljs-number">8</span></span>(%ebp), %ecx xorl %eax, %eax cmpb $0, (%ecx) je LBB1_4 leal <span class="hljs-number"><span class="hljs-number">8</span></span>(%ebp), %edx .<span class="hljs-keyword"><span class="hljs-keyword">align</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">0x90</span></span> LBB1_2: cmpb $0, <span class="hljs-number"><span class="hljs-number">1</span></span>(%ecx,%eax) leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%eax), %eax jne LBB1_2 addl %eax, %ecx movl %ecx, (%edx) LBB1_4: popl %ebp ret</code> </pre><br></td></tr></tbody></table><br>  The incrementor code is much cooler.  And it is almost identical with the assembler obtained <a href="http://habrahabr.ru/company/cpp_russia/blog/264201/">from the naked iterator C.</a> <br><br><h2>  Iterators, signal iterators, and parity </h2><br><br>  But what does the comparison of two objects of different types for equivalence mean? <br><br>  A little for the uninitiated: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf">N3351</a> determines in which cases comparisons of different types are permissible.  It is not enough that the syntax "x == y" is valid and gives a boolean value.  If x and y have different types, then these types must be EqualityComparable by themselves, and they must have a <i>general</i> type to which they can be converted, and it must also be EqualityComparable.  Suppose we compare char and short.  This is possible because they are EqualityComparable, and they can be converted to an int, which is also EqualityComparable. <br><br>  Iterators can be compared, and signal iterators are compared in a trivial way.  The difficulty is to find a common type for them.  In general, each iterator and signal has a common type that can be created like this: suppose the existence of a new type of iterator I, which is a type-sum, and contains either an iterator or a signal iterator.  When they are compared, it behaves semantically as if both of them were first converted into two objects of type I, let's call them lhs and rhs, and then compare them with the following label: <br><br><table width="639" cellpadding="7"><tbody><tr><td width="198">  lhs signal iterator? <br><br></td><td width="199">  rhs signal iterator? <br><br></td><td width="198">  lhs == rhs? <br><br></td></tr><tr><td width="198">  true <br><br></td><td width="199">  true <br><br></td><td width="198">  true <br><br></td></tr><tr><td width="198">  true <br><br></td><td width="199">  false <br><br></td><td width="198">  done (rhs.iter) <br><br></td></tr><tr><td width="198">  false <br><br></td><td width="199">  true <br><br></td><td width="198">  done (lhs.iter) <br><br></td></tr><tr><td width="198">  false <br><br></td><td width="199">  false <br><br></td><td width="198">  lhs.iter == rhs.iter <br><br></td></tr></tbody></table><br><br>  This label resembles the one that turned out when analyzing the behavior of <a href="http://habrahabr.ru/company/cpp_russia/blog/264201/">the comparison operator c_string_range :: iterator</a> .  This is not by accident - it was a special case of this more general scheme.  It confirms the intuitive conclusion that you can already notice by looking at my two classes, c_string_range and c_string_iterable.  One is a pair of iterators, the other is a pair of iterators / signalers, but their work patterns are similar.  We feel that it is possible to build an equivalent Range from any Iterable, if we donate a small bit of speed.  And now we have found confirmation of this. <br><br>  The ability to compare iterators and signal iterators directly allows us to use the C ++ type system to optimize a large category of iterations, removing the ramifications in the parity comparison operator. <br><br><h2>  Objections </h2><br><br>  The idea of ‚Äã‚Äãgiving different types of begin and end is not new, and it was not me who invented it.  I learned about it from Dave Abrahams many years ago.  Recently, a similar idea was <a href="http://www.open-std.org/pipermail/ranges/2013-January/000088.html">filed by</a> Dietmar Kuehl on the Ranges mailing list, and in response to his letter, Sean Parent expressed the following objection: <br><br><blockquote>  I think we assign too much to iterators.  Algorithms that work with termination based on checking a signal iterator or based on counting are different entities.  See copy_n () and copy_sentinel () <br><br>  <a href="http://stlab.adobe.com/copy_8hpp.html">stlab.adobe.com/copy_8hpp.html</a> <br><br>  Regarding the intervals - I'm sure that you can build it with: <br><br><ol><li>  iterator pairs </li><li>  iterator and quantity </li><li>  iterator and signal </li></ol><br><br>  And in this case, copy (r, out) can produce the desired algorithm. </blockquote><br><br>  If I understood him correctly, he talks about the existence of three parallel concepts of intervals: IteratorRange, CountedRange and SentinelRange.  And these hierarchies do not need to try to link together.  The copying algorithm should contain three different implementations, one for each concept.  Then you have to triple the order of 50 algorithms - and this is too much repetition in the code. <br><br>  Worse, some algorithms are based on refined concepts.  For example, in <a href="http://libcxx.llvm.org/">libc ++,</a> the rotate algorithm chooses one of three implementations, depending on whether you pass it direct, bidirectional, or random access iterators.  And to enable three different implementations of Iterator, Counted and SentinelRanges would require 9 rotate algorithms!  With all due respect, this is insane. <br><br><h2>  Total </h2><br><br>  At the beginning of the post I gave a list of problems associated with intervals with paired iterators.  I showed a new concept, Iterable, which deals with performance issues, and raised the issue of the complexity of implementing intervals.  So far I have not described how this concept works at infinite intervals, as we will discuss in the fourth, final post. <br><br>  All code can be found in the <a href="https://github.com/ericniebler/range-v3">github</a> repository. <br><br><h2>  Thanks </h2><br>  I would like to thank Andrew Sutton for helping with Concpets Lite syntax and for explaining the requirements of the EqualityComparable concept for different types and general improvement and formalization of many ideas.  Articles have become much better thanks to his great contribution. <br>  <i><b>Other articles of the cycle</b></i> <i><br></i>  <i><a href="http://habrahabr.ru/company/cpp_russia/blog/264201/">Intervals in C ++, part 1: Intervals with limiters</a></i> <i><br></i>  <i><a href="http://habrahabr.ru/company/cpp_russia/blog/264473/">Intervals in C ++, part 2: Infinite intervals</a></i> <i><br></i>  <i><a href="http://habrahabr.ru/company/cpp_russia/blog/265355/">Intervals in C ++, part 4: to infinity and beyond</a></i> </div><p>Source: <a href="https://habr.com/ru/post/264975/">https://habr.com/ru/post/264975/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264963/index.html">Object language restrictions (and a little about the meta model)</a></li>
<li><a href="../264965/index.html">The right bonus for your new server - Part 2</a></li>
<li><a href="../264967/index.html">How-to: Techniques for creating interactive emails using CSS</a></li>
<li><a href="../264969/index.html">My view on yii 2 configuration files</a></li>
<li><a href="../264973/index.html">A look at Angry Birds 2, Niki Minaj and Jason Statham as new stars of Glu, the rise in price of a loyal user - and other news of the week for a mobile developer</a></li>
<li><a href="../264977/index.html">The University of Innopolis opened a school of high-performance computing in scientific and engineering problems</a></li>
<li><a href="../264981/index.html">Asterisk. Start</a></li>
<li><a href="../264983/index.html">In search of an analogue of first-order functions in the Cach√© DBMS</a></li>
<li><a href="../264985/index.html">Sync CI Notifications with Telegram</a></li>
<li><a href="../264987/index.html">Median: precisely, sometimes precisely and almost exactly</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>