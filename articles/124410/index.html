<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ensuring uninterrupted client-server interaction (WEB)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With this post I will try to describe the protocol with which you can increase the reliability of the WEB application in the event of problems connect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ensuring uninterrupted client-server interaction (WEB)</h1><div class="post__text post__text-html js-mediator-article"> With this post I will try to describe the protocol with which you can increase the reliability of the WEB application in the event of problems connecting to the server.  I will try to describe abstracting from technologies, however, the text will show examples of server-side Java code and JavaScript / SmartClient on the UI for clarity described and for the reason that this protocol was implemented within the framework of an existing project using these technologies. <br><a name="habracut"></a><br>  Suppose we use a web system that provides a user interface for accessing a bank account.  We create a new payment document, specify the details, the amount and click the "hold" button.  At this point, somewhere between the client browser and the remote server, there is a connection problem.  In response to the XHR request, the status comes 503. It is unambiguous to determine whether the request was received by the remote server and whether it was executed is not possible.  The client displays information about the connection error.  What will happen if we click ‚Äúhold‚Äù for the same document again and the server has already done it?  It can be assumed that the server will most likely produce a validation error stating that such a document has already been posted, or else it will duplicate it.  Of course, it all depends on the organization of client-server interaction. <br><br>  I want to bring to your attention one of the possible solutions to this kind of problems based on a fairly simple protocol. <br><br>  <b>How does this protocol solve connection problems?</b> <br>  - Client requests are transactional *.  If an HTTP connection problem occurs, the user interface is blocked.  Attempts are made periodically to send a transaction that fails until a response is received from the service. <br>  - If the request was sent to the server but the response was not delivered back for reasons of connection problems, the client will be resubmitted until a response is received from the Backend service.  On the server, it will be determined that the transaction has already been completed earlier and it will return the result from the results cache. <br>  - If the transaction was sent to the server and the response was not received due to a connection failure, the server also determined that the task was not completed yet when the connection was restored, then the corresponding response will be sent to the client and attempts to get the execution result will be repeated until it is counted by the server. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      * The term transaction, in this context, means an atomic task (or an atomic set of tasks) that performs a request to the service, receives the result of the execution, and makes changes to the user interface.  In the event of a failure will be repeated attempts to send it. <br><br>  <b>When does it make sense to use this protocol?</b> <br>  - When the system architecture is built in such a way that all requests from the client go through one point and fall on one dispatcher (which in turn scatters them to the necessary service). <br>  - When connection interruptions occur frequently. <br>  - If there are long-running, synchronous server tasks and requests are timed out somewhere in the infrastructure between the client and the server.  These are the tasks that keep the connection until they finish the execution. <br><br>  On the project in which I am currently involved, frequent interruptions of the connection occur as they are accessed from ships / platforms in the ocean through a satellite channel.  In addition, the system has been developed for a long time and it contains synchronous services that can be executed for a long time, requests to which are cut upon reaching a timeout by a proxy server.  Of course, such services are not correct in terms of architecture, but there is something there is.  The capabilities of this protocol may not be an alternative to the refactoring of such services, but at least a work round of the above described problem. <br><br>  <b>Protocol Description</b> <br><img src="https://habrastorage.org/getpro/habr/post_images/c51/d8c/848/c51d8c84866a3eaa54d5bb82b13608a8.png"><br>  <b>Client part</b> <br>  - Each request to the Backend service is wrapped in a transaction <br>  - Each transaction within one browser window is characterized by a unique transaction identifier.  For example, the ID of a new transaction will be calculated by incrementing the ID of the previous one. <br>  - Each request is added a unique identifier of the browser window.  This is done due to the fact that several browser windows can operate within a single web session, and transaction identifiers are unique within a single browser window.  Details will be described below. <br>  - In case of connection problems (HTTP status, 4xx, 5xx response codes or client timeout), the request and response are sent to the connection error handler. <br>  - The connection error handler blocks the user interface and sends the transaction again for execution at a certain time interval, and displays a corresponding message to the user. <br>  - When the connection is restored, the user interface lock is released and the normal processing of the received response continues. <br><br>  <b>Server part</b> <br>  - When a request is sent to the dispatcher, the browser's window ID and transaction ID are determined from it. <br>  - The response cache is taken from the server user web session object. <br>  - Based on the response cache, browser window ID and transaction ID, it is determined whether the transaction was completed before. <br>  - If the transaction was completed before the dispatcher returns the result. <br>  - If the transaction is in progress, the server returns information to the client about it. <br>  - If it is determined that the transaction has not yet been executed: <br>  1) in the cache there is a label that for a given browser window ID and transaction ID indicating that the transaction is taken into processing <br>  2) the dispatcher transfers the operation (operations) from the transaction for processing to the corresponding service and receives the result from it <br>  3) the dispatcher puts the result of the transaction into the response cache, respectively, the browser window ID and transaction ID <br>  4) the dispatcher gives the result of the transaction in response. <br>  - When the user server web session becomes outdated, the cache is deleted as part of the deletion of the session object. <br>  - Clearing the answer from the cache is provided when the boundary response time in the cache is reached.  This is necessary to prevent memory overflow in case of long user sessions. <br>  - In the case of an attempt to get the result of a transaction that was allocated from the cache after the lifetime has passed, the relevant information about this will be transmitted to the client. <br><br>  <b>Description of some implementation details</b> <br><br>  <b>Client part JavaScript, SmartClient 6.5</b> <br>  - in SmartClient, all RPC errors are intercepted by default using the RPCManager.handleError (response, request) method <br><br>  redefine it and add interception of connection problems as follows <br> <code>.. <br> if (response.status == isc.RPCResponse.STATUS_TRANSPORT_ERROR || response.status == isc.RPCResponse.STATUS_SERVER_TIMEOUT) { <br> isc.RPCManager.handleHttpError(response, request); <br> } <br> ..</code> <br> <br>  We implement the RPCManager.handleHttpError (response, request) method in which we block the user interface (with a message about the problem and with a countdown to the next attempt) and re-send the transaction. <br><br>  Remember that it is necessary to ensure the uniqueness of the browser identifier within the web session.  The browser identifier is defined in the static variable RPCManager.clientId which will be set to timestamp isc.timeStamp () during class initialization. <br>  To add a clientId to each request, override the method through which all RPC requests go in SmartClient <br> <code>isc.RPCManager.addClassMethods({ <br> .. <br> sendRequestOriginal : RPCManager.sendRequest, <br> sendRequest : function (request) { <br> if (request.params == null) { <br> request.params = new Object(); <br> } <br> request.params.clientId = RPCManager.clientId; <br> isc.RPCManager.sendRequestOriginal(request); <br> } <br> ..</code> <br> <br>  <b>Java server side, SmartClient DMI</b> <br>  In SmartClient, client-server communication is organized according to their internal protocol SmartClient DMI (Direct Method Invocation).  There is its server Java implementation. <br>  Here, the entry point is the com.isomorphic.servlet.IDACall servlet that dispatches requests for specific DMI services. <br>  Inherit from this class and define our implementation in web.xml <br>  Overriding method <code>public void processRequest(HttpServletRequest request, HttpServletResponse response)</code> <br>  If there are no servlet sources, remember that you can always decompile the class file.  We will need this to understand what is happening in this servlet and to introduce our functionality into the processing of SmartClient DMI. <br><br>  From the HTTP request we get the browser identifier that is transmitted by the client. <br> <code>request.getParameter(CLIENT_ID)</code> <br> <br>  The session object is obtained by <code>request.getSession()</code> <br>  Remember that we have to work carefully since the session object is scrolling between many threads of requests to the server within this session.  By combining synchronized block by session calls where needed. <br><br>  The cache of answers is stored in the session object as the <code>setAttribute()/getAttribute()</code> attribute <br><br>  The cache structure is as follows: <br> <code>Map&lt;Long, Map&lt;Long, CacheTransaction&gt;&gt; cache</code> <br> <br>  The key is the browser ID in the session. <br>  The value is a transaction card whose key in turn is the transaction ID and the value of the object with the results of the transaction transactions. <br><br>  We create these maps with thread-free ones using <code>Collections.synchronizedMap()</code> <br>  A thread-safe here will only be atomic calls, so also do not forget about the synchronized block where necessary. <br><br> <code>public class CacheTransaction { <br> private long transactionNum; <br> private long requestTimestamp; <br> private Map&lt;Long, Object&gt; responses; <br> ..</code> <br>  Here, the <code>Map&lt;Long, Object&gt; responses</code> - the map of the service responses by request. <br>  The key here is the hash of the request and the value of the object respons. <br><br>  In the implementation of this protocol, pay attention to performance and memory used by the cache!  Each request will be checked for availability in the cache.  In this example implementation, this is not a problem, since each session has its own cache.  You can adjust the memory used by setting the lifetime of the object in the cache.  Also note that there is no need to store requests in the cache, it is convenient to store the hash on request as a key and respond as a value.  Here, the request and response are not meant as HttpRequest and HttpResponse, but objects of the request and response of the target service. <br>  In the case of scalable solutions, we remember that we have session objects.  Therefore, we organize either replication of sessions between nodes or load balancing with a sticky session. </div><p>Source: <a href="https://habr.com/ru/post/124410/">https://habr.com/ru/post/124410/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../124402/index.html">Expansion to highlight the author's comments in posts Habrahabra</a></li>
<li><a href="../124403/index.html">We pronounce correctly</a></li>
<li><a href="../124404/index.html">About the dangers of changeable significant types</a></li>
<li><a href="../124407/index.html">The shortest link from Google</a></li>
<li><a href="../124409/index.html">W3C Digest. What's new in CSS3. Release 1</a></li>
<li><a href="../124411/index.html">The basics of IP telephony from Cisco or familiarity with Cisco CallManager Express</a></li>
<li><a href="../124412/index.html">Lead Firebug Developer Moved to Google Chrome Team</a></li>
<li><a href="../124413/index.html">Abrakadabra - movie catalog ex.ua</a></li>
<li><a href="../124414/index.html">FreeNAS Legacy (0.7) is dead. Long live NAS4Free!</a></li>
<li><a href="../124415/index.html">Student plagiarism in essays is ineradicable, so we must abandon essays</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>