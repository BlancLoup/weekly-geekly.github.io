<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Distributor ok.ru/music</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I work in a team of the Odnoklassniki platform and today I‚Äôll tell you about the architecture, design and implementation details of the music distribu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Distributor ok.ru/music</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/rb/nt/x3/rbntx3qeblgswwx-nfjkji5csli.png"><br><br>  I work in a team of the Odnoklassniki platform and today I‚Äôll tell you about the architecture, design and implementation details of the music distribution service. <br><a name="habracut"></a><br><blockquote>  The article is a transcript of the <a href="https://jokerconf.com/2018/talks/5emw0phf8qe6qycic42iq2/">report</a> on <a href="https://jokerconf.com/">Joker 2018</a> . </blockquote><br><h1>  Some statistics </h1><br>  First, a few words about OK.  This is a giant service that is used by more than 70 million users.  They are served by 7 thousand machines in 4 data centers.  Recently, on traffic, we broke through the 2 TB / s mark without counting numerous CDN sites.  We squeeze the maximum out of our hardware, the most loaded services serve up to 100,000 requests per second from a four core node.  At the same time, almost all services are written in Java. <br><br>  In OK, many sections, one of the most popular - "Music".  In it, users can upload their tracks, buy and download music in different qualities.  The section has a wonderful catalog, recommendation system, radio and much more.  But the main purpose of the service, of course, is to play music. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The distributor of music is engaged in data transfer to user players and mobile applications.  It can be caught in the web inspector, if you look at requests to the domain musicd.mycdn.me.  API distributor is extremely simple.  It responds to HTTP <code>GET</code> requests and issues the requested track range. <br><br><img src="https://habrastorage.org/webt/j9/va/ze/j9vazesvr2fuqtpvhec0uj7gbmq.png"><br><br>  At peak load reaches 100 Gb / s through half a million connections.  In fact, the music distributor is a cache front-end in front of our internal storage of tracks, which is based on <a href="http://profyclub.ru/docs/174">One Blob Storage</a> and <a href="https://2017.jokerconf.com/2017/talks/4fasygftomyekgaqaaiauo/">One Cold Storage</a> and contains petabytes of data. <br><br>  Since I started talking about caching, let's look at the playback statistics.  We see a pronounced TOP. <br><br><img src="https://habrastorage.org/webt/q6/jv/pc/q6jvpcopw2t0xt29sl84lwp1gkg.png"><br><br>  About 140 tracks cover 10% of all auditions in a day.  If we want our caching server to have a hit hit of at least 90%, then we need to put half a million tracks into it.  95% - almost a million tracks. <br><br><h1>  Distributor Requirements </h1><br>  What goals did we set when developing the next version of the distributor? <br><br>  We wanted one node to hold 100 thousand connections.  And these are slow client connections: a bunch of browsers and mobile applications via networks with varying speeds.  At the same time, the service, like all our systems, must be scalable and fault-tolerant. <br><br>  First of all, we need to scale the bandwidth of the cluster in order to keep up with the growing popularity of the service and be able to give more and more traffic.  You also need to be able to scale the total capacity of the cluster cache, because cache hit directly depends on it and the share of requests that will go into the track repository. <br><br>  Today it is necessary to be able to scale any distributed system horizontally, that is, add machines and data centers.  But we wanted to implement and vertical scaling.  Our typical modern server contains 56 cores, 0.5-1 TB of RAM, a 10 or 40 Gbps network interface and a dozen SSD disks. <br><br>  Speaking of horizontal scalability, an interesting effect arises: when you have thousands of servers and tens of thousands of disks, something constantly breaks.  Failure of the discs is a routine, we change them for 20-30 pieces a week.  And server failures do not surprise anyone, 2-3 machines a day go under replacement.  We had to face data center failures, for example, in 2018 there were three such failures, and this is probably not the last time. <br><br>  Why am I all this?  When we design any systems, we know that they will break sooner or later.  Therefore, we always <a href="https://techtrain.ru/talks/1pqtojnosesumeo00ayccm/">carefully study the</a> failure scenarios of all system components.  The main way to deal with failures is to backup using data replication: several copies of data are stored on different nodes. <br><br>  We also reserve network bandwidth.  This is important, because if a component of the system fails, the load on the other components should not be allowed to collapse the system. <br><br><h1>  Balancing </h1><br>  First you need to learn how to balance user requests between data centers, and to do this automatically.  This is in case you need to conduct network work, or if the data center has failed.  But balancing is also needed inside data centers.  Moreover, we want to distribute requests between nodes not randomly, but with weights.  For example, when we post a new version of the service and we want to introduce a new node smoothly into the rotation.  Weights also help a lot with load testing: we increase the weight and get much more workload on the node to understand the limits of its capabilities.  And when the node fails under load, we quickly zero the weight and remove it from the rotation, using the mechanisms of balancing. <br><br>  How does the query path from the user to the node, which will return the data, taking into account the balancing? <br><br><img src="https://habrastorage.org/webt/uu/tz/uf/uutzuf3bnfpetnns91ca-rcf5mc.png"><br><br>  The user logs in through the website or mobile application and receives the URL of the track: <br><br> <code>musicd.mycdn.me/v0/stream?id=...</code> <br> <br>  To get the IP address from the host name in the URL, the client refers to our GSLB DNS, which knows about all our data centers and CDN sites.  GSLB DNS gives the client the IP address of the balancer of one of the data centers, and the client establishes a connection with it.  The balancer knows about all the nodes inside the data centers and their weight.  He on behalf of the user establishes a connection with one of the nodes.  We <a href="http://www.highload.ru/2017/abstracts/2858.html">use L4 balancers based on NFWare</a> .  The node gives the user data directly, bypassing the balancer.  In services like a distributor, outgoing traffic significantly exceeds incoming traffic. <br><br>  If a data center fails, GSLB DNS detects this and promptly takes it out of rotation: it stops giving users the IP address of the balancer of this data center.  If a node fails in the data center, then its weight is reset, and the balancer inside the data center stops sending requests to it. <br><br>  Now consider the balancing of tracks on the nodes inside the data center.  We will consider data centers as independent autonomous units, each of them will live and work, even if all the others died.  Tracks need to be balanced on the machines evenly, so that there is no load imbalance, and replicate them to different nodes.  If one node fails, the load should be distributed equally among the rest. <br><br>  This problem can be <a href="https://medium.com/%40dgryski/consistent-hashing-algorithmic-tradeoffs-ef6b8e2fcae8">solved in different ways</a> .  We stopped at <a href="https://en.wikipedia.org/wiki/Consistent_hashing">consistent hashing</a> .  The entire possible range of track identifier hashes is wrapped in a ring, and then each track is mapped to a point on this ring.  Then we more or less evenly distribute the ring ranges between the nodes in the cluster.  The nodes that will store the track are selected by hashing the tracks to a point on the ring and moving clockwise. <br><br><img src="https://habrastorage.org/webt/qr/ty/xf/qrtyxfbchjhlp5taqfs0fbicnk0.jpeg"><br><br>  But such a scheme has a drawback: in case of failure of the N2 node, for example, its entire load will fall on the next replica on the ring - N3.  And if it does not have a double performance margin - and this is not economically justified - then, most likely, the second node will also have to be bad.  N3 with a high degree of probability will develop, the load will be transferred to N4 and so on - a cascade failure will occur along the entire ring. <br><br>  This problem can be solved by increasing the number of replicas, but then the total useful capacity of the cluster in the ring decreases.  Therefore, we do otherwise.  With the same number of nodes, the ring is divided into a much larger number of ranges, which are randomly scattered around the ring.  Replicas for the track are selected by the above algorithm. <br><br><img src="https://habrastorage.org/webt/kc/uf/5-/kcuf5-1mmekp60d5emkp5ckkgps.png"><br><br>  In the example above, each node is responsible for two ranges.  If one of the nodes fails, its entire load will fall not on the next node around the ring, but will be distributed between two other nodes of the cluster. <br><br>  The ring is calculated on the basis of a small set of parameters algorithmically and deterministically at each node.  That is, we do not store it in some kind of config.  We have more than one hundred thousand of these ranges in production, and in case of failure of any of the nodes, the load is distributed absolutely evenly among all other live nodes. <br><br>  How does track output to a user in a consistent hashing system look like? <br><br>  The user through the L4-balancer falls on a random node.  The choice of the node is random, because the balancer knows nothing about the topology.  But then every replica in the cluster knows about it.  The node that receives the request determines whether it is a replica for the requested track.  If not, it switches to proxy mode from one of the replicas, establishes a connection with it, and it searches for data in its local storage.  If the track is not there, the replica pulls it out of the track repository, saves it to the local repository and gives the proxy, which forwards the data to the user. <br><br><img src="https://habrastorage.org/webt/c5/pu/wl/c5puwlig-lfxy20leny4y4utqig.png"><br><br>  If the disk in the replica fails, the data from the storage will be transferred to the user directly.  And if the replica fails, then the proxy knows about all the other replicas for this track, it will establish a connection with another live replica and receive data from it.  So we guarantee that if a user has requested a track and at least one replica is alive, he will receive an answer. <br><br><h1>  How does the node </h1><br><img src="https://habrastorage.org/webt/2m/up/ob/2mupob-rqyqsbic50lc-qn2xwqe.png"><br><br>  A node is a pipeline from a set of stages through which a user request passes.  First, the request goes to the external API (we give everything via HTTPS).  Further validation of the request is performed - signatures are checked.  Then IDv3 tags are constructed, if necessary, for example, when purchasing a track.  The request goes to the routing stage, where, based on the cluster topology, it is determined how the data will be given: either the current node is a replica for this track, or we will be proxying from another node.  In the second case, the node through the proxy client establishes a connection with the replica via the internal HTTP API without checking signatures.  The replica searches for data in the local storage, if it finds a track, it returns it from its disk;  and if it does not find it, it pulls up tracks from the repository, caches and gives them away. <br><br><h1>  Load on node </h1><br>  Let us estimate what load one node should hold in such a configuration.  Suppose we have three data centers of four nodes. <br><br><img src="https://habrastorage.org/webt/in/-z/nz/in-znz1gekgg217y9oxdlm5pv-g.png"><br><br>  The entire service should serve 120 Gbit / s, that is, 40 Gbit / s per data center.  For example, networkers arranged maneuvers or an accident occurred, and two data centers DC1 and DC3 remained.  Now each of them should give 60 Gbit / s.  But here the developers wanted to roll out some kind of update, in each data center there are 3 live nodes left and each of them should give 20 Gbit / s. <br><br><img src="https://habrastorage.org/webt/6q/tc/sz/6qtcszoeoi4w1zjxvh_o1u35vni.png"><br><br>  But initially there were 4 nodes in each data center.  And if we store two replicas in the data center, then with a probability of 50%, the node that received the request will not be a replica for the requested track and will begin to proxy the data.  That is, half of the traffic inside the data center is proxied. <br><br><img src="https://habrastorage.org/webt/yi/aj/tc/yiajtck3angspynaidxuar_t5gm.png"><br><br>  So, one node should give users 20 Gbit / s.  Of these, 10 Gbps it pulls from its neighbors in the data center.  But the scheme is symmetrical: the same 10 Gbit / s node gives its neighbors in the data center.  It turns out that 30 Gbps comes from the node, of which 20 Gbps should serve itself, since it is a replica of the requested data.  And the data will go either from the disks or from the RAM, where about 50 thousand "hot" tracks fit.  Taking into account our statistics of playing this allows you to remove 60-70% of the load from the discs, and it will remain about 8 Gbit / s.  This thread is quite capable of giving a dozen SSD. <br><br><h1>  Data storage on node </h1><br>  If each track is put in a separate file, then the overhead of managing these files will be huge.  Even restarting the node and scanning the data on the disks will take minutes, if not tens of minutes. <br><br>  There are less obvious limitations in this scheme.  For example, you can load tracks only from the very beginning.  And if the user requested playback from the middle and there was a cache miss, then we will not be able to give a single byte until we load the data to the desired location from the track repository.  Moreover, we can also store the tracks only as a whole, even if it is a gigantic audiobook, which is already abandoned in the third minute.  It will still lie like a dead weight on the disk, waste expensive space and reduce the cache hit of this node. <br><br>  Therefore, we do it in a completely different way: we split up tracks into blocks of 256 KB each, because this correlates with the size of the block in the SSD, and we are already operating with these blocks.  On a disk in 1 TB 4 million blocks are located.  Each disk in the node is an independent storage, and all blocks of each track are distributed across all disks. <br><br>  We did not immediately come to such a scheme, at first all the blocks of one track lay on one disc.  But this led to severe load imbalances between the disks, since if one of the disks had hit a popular track, all requests for its data would fall on one disk.  To avoid this, we distributed the blocks of each track across all discs, equalizing the load. <br><br>  In addition, do not forget that we have a lot of RAM, but we decided not to do the samopisny cache, since we have a wonderful page cache in Linux. <br><br>  How to store blocks on disks? <br><br>  First, we decided to create one giant XFS file on the disk and place all the blocks in it.  Then came the idea to work directly with the block device.  We implemented both options, compared them and it turned out that when working directly with a block device, the recording is 1.5 times faster, the response time is 2-3 times lower, the overall system load is 2 times lower. <br><br><h1>  Index </h1><br>  But it is not enough to be able to store blocks, it is necessary to maintain an index from blocks of music tracks to blocks on a disk. <br><br><img src="https://habrastorage.org/webt/me/4y/0b/me4y0bk_xbwco9r_5y6smyhmxmc.png"><br><br>  It turned out to be quite compact, one index record takes up only 29 bytes.  For a storage size of 10 TB, the index takes a little more than 1 GB. <br><br>  There is an interesting point.  Each such record has to keep the total size of the entire track.  This is a classic example of denormalization.  The reason is that, according to the specification in the HTTP range response, we must return the total size of the resource, as well as form the Content-length header.  If it were not for this, then everything would have been even more compact. <br><br>  To the index, we formulated a number of requirements: to work quickly (preferably stored in RAM), so that it was compact and did not take up space from page cache.  Another index must be persistent.  If we lose it, we will lose information about where in the disk which track is stored, and this is equivalent to cleaning the disks.  And in general, I would like the old blocks, which have not been addressed for a long time, were somehow supplanted, freeing up space for more popular tracks.  We chose the <a href="https://github.com/ben-manes/caffeine/wiki/Efficiency">LRU crowding policy</a> : the blocks are crowded out once a minute, we keep 1% of the blocks free.  Of course, the index structure must be thread-safe, because we have 100 thousand connections per node.  <code>SharedMemoryFixedMap</code> from our open source <a href="https://github.com/odnoklassniki/one-nio">one-nio</a> library ideally satisfies all these conditions. <br><br>  We put the index on <code>tmpfs</code> , it works quickly, but there is a nuance.  When the machine is restarted, everything that was on <code>tmpfs</code> , including the index, is lost.  In addition, if because of the <a href="https://habr.com/company/odnoklassniki/blog/148139/"><code> sun.misc.Unsafe</code></a> our process collapsed, it is unclear in what condition the index remained.  Therefore, we make an impression of it once an hour  But this is not enough: once we use block crowding, we have to maintain <a href="https://en.wikipedia.org/wiki/Write-ahead_logging">WAL</a> , in which we write information about the crowded blocks.  The block entries in the casts and the WAL need to be somehow streamlined during restoration.  For this we use block generation.  It plays the role of a global transaction counter and is incremented every time the index changes.  Let's look at an example of how this works. <br><br>  Take an index with three entries: two blocks of track # 1 and one block of track # 2. <br><br><img src="https://habrastorage.org/webt/l6/ux/51/l6ux512_lbpedki0bb3g0ouggau.png"><br><br>  The stream of creation of impressions is awakened and is iterated on this index: the first and second tuples fall into the impression.  Then the displacement stream addresses the index, realizes that the seventh block has not been addressed for a long time, and decides to use it for something else.  The process displaces the block and writes an entry to WAL.  He gets to block 9, sees that he, too, has not been contacted for a long time, and also marks him as repressed.  Here the user accesses the system and a cache miss occurs - a track is requested that we don‚Äôt have.  We save the block of this track in our storage, having overwritten the 9th block.  At the same time, the generation is incremented and becomes equal to 22. Next, the process of creating the cast is activated, which has not completed its work, reaches the last record and writes it to the cast.  As a result, we have two live recordings in the index, a cast and a WAL. <br><br><img src="https://habrastorage.org/webt/sy/vj/0_/syvj0_-kknmn4i5pulf_p8bclc4.png"><br><br>  When the current node falls, it will restore the initial state of the index as follows.  First, we scan the WAL and build a map of dirty blocks.  The map stores the mapping from the block number to the generation when this block was supplanted. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9p/g5/gn/9pg5gn-8atbixm4swmytkscxwpm.png" width="300"></div><br><br>  After that, we begin to iterate over the image, using the map as a filter.  We look at the first record of the cast, it concerns the block ‚Ññ3.  He is not mentioned among the dirty, so he is alive and falls into the index.  We get to block number 7 with the eighteenth generation, but the map of dirty blocks tells us that just in the 18th generation, the block was ousted.  Therefore, it does not enter the index.  We reach the last entry, which describes the contents of the 9th block with 22 generation.  This block is mentioned in the map of dirty blocks, but it was supplanted before.  This means that it has been reused for new data and is indexed.  The goal is achieved. <br><br><h1>  Optimization </h1><br>  But that's not all, we go down deeper. <br><br>  Let's start with page cache.  We were counting on it initially, but when we started to conduct load testing of the first version, <a href="https://github.com/brendangregg/perf-tools/blob/master/fs/cachestat">it turned</a> out that page cache hit rate does not reach 20%.  We assumed that the problem is in read ahead: we do not store files, but blocks, while serving a bunch of connections, and in such a configuration it is efficient to work with the disk randomly.  We almost never read anything consistently.  Fortunately, in Linux there is a <a href="http://man7.org/linux/man-pages/man2/posix_fadvise.2.html"><code>posix_fadvise</code></a> call that allows you to tell the kernel how we are going to work with the file descriptor - in particular, we can say that we don‚Äôt need to read ahead by passing the <code>POSIX_FADV_RANDOM</code> flag.  This system call is available through <a href="">one-nio</a> .  In operation, our cache hit is 70-80%.          2 ,    HTTP   20%. <br><br>  .     heap.    TLB- ,   Huge Pages   Java-.          (GC Time/Safepoint Total Time  20-30% ),     ,    HTTP latency    . <br><br><h1>  Incident </h1><br>       ( ) . <br><br>             .  ,     ,           ,    ,      .        ,   - .   ,    .  ,        ,    .   ,     Daft Punk    ‚Ññ2  sdc,            sdd. <br><br><img src="https://habrastorage.org/webt/9q/pu/9g/9qpu9gxbc-uph2jp7tsjkup4b5a.png"><br><br> ,            .    Linux <a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming"></a> :      ,      . <br><br><img src="https://habrastorage.org/webt/3s/y-/vm/3sy-vmtyncu3miiwjhzyu0j9xi4.png"><br><br>   .        ID.   <a href="https://en.wikipedia.org/wiki/World_Wide_Name">WWN</a>           ,   WAL.      ,      ,             . <br><br><h1>   </h1><br>       ,            .    CDN    ,    CDN    -.      .        . ,          ,  . <br><br>     .            <a href="https://opentracing.io/">Open Tracing</a>  <a href="https://zipkin.io/">Zipkin</a> .      ,    .          ,    ,       HTTP-    .      ,   ,  ,   ,     ,   ,        . <br><br><h1>   </h1><br>         . ,  :  ,     ,    . <br><br><pre> <code class="java hljs">ByteBuffer buffer = ByteBuffer.allocate(size); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = fileChannel.read(buffer, position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ... } buffer.flip(); socketChannel.write(buffer);</span></span></code> </pre> <br>        ,       : <br><br><ul><li>       <code>FileChannel.read()</code>    kernel space  user space; </li><li>            <code>SocketChannel.write()</code> ,    user space  kernel space. </li></ul><br>  ,  Linux   <a href="http://man7.org/linux/man-pages/man2/sendfile.2.html"><code>sendfile()</code></a> ,              ,    user space.  ,     <a href="https://github.com/odnoklassniki/one-nio">one-nio</a> .                ,      <code>sendfile()</code> ‚Äî    10 /   <code>sendfile()</code>    0. <br><br>     user-space SSL-     <code>sendfile()</code>      ,        .       .     <code>SocketChannel</code>  <code>FileChannel</code> ,   <a href="https://github.com/jvm-profiling-tools/async-profiler">Async Profiler</a>         ,         <code>sun.nio.ch.IOUtil</code> ,      <code>read()</code>  <code>write()</code>   .    . <br><br><pre> <code class="java hljs">ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = readIntoNativeBuffer(fd, bb, position, nd); bb.flip(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) dst.put(bb); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { Util.offerFirstTemporaryDirectBuffer(bb); }</code> </pre> <br>    .       heap <code>ByteBuffer</code> ,         ,    ,     heap <code>ByteBuffer</code> ,       .        . <br><br>  .      <a href="https://github.com/odnoklassniki/one-nio">one-nio</a> .   <code>MallocMT</code> ‚Äî  ,   .    SSL       ,     Java heap,    <code>ByteBuffer</code> ,      <code>FileChannel</code>       .      . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Allocator allocator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MallocMT(size, concurrency); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Socket socket)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (socket.getSslContext() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> address = allocator.malloc(size); ByteBuffer buf = DirectMemory.wrap(address, size); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> available = channel.read(buf, offset); socket.writeRaw(address, available, flags);</code> </pre><br><h1> 100 000    </h1><br>          .     .       100 .  .      ? <br><br> ,     ‚Äî                 .   ,   .             ,          .     . <br><br><img src="https://habrastorage.org/webt/mt/vg/eo/mtvgeoszcpcv6zpc-qi_rbqeyhy.png"><br><br>      ,    ,     .     ,    .        .       ,     ,       .         . <br><br>       .      .     ,      , ..         .        .       ,    ,          .       ,      .  back pressure. <br><br>     <a href="http://www.reactive-streams.org/"> </a> .    ,  subscriber      publisher   demand. Demand ,      subscriber    demand,    . Publisher    ,          demand     . <br><br>        push  pull.  push  subscriber  ,  publisher,    publisher    demand  subscriber,   .    ,      subscriber-.  pull ,  publisher ,  subscriber.   publisher     ,  demand .   subscriber ,     , publisher        demand. <br><br>      .     publisher     subscriber  . <br><br>      . <code>Publisher</code>   <code>Subscriber</code> ,       : <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; s)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br> <code>Subscription</code>   demand   .  There is simply no place. <br><br>         ,   ,  chunk.   ,     heap ,   . Chunk ‚Äî        ,       <code>ByteBuffer</code> ,      . <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Chunk</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteBuffer dst)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Socket socket)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FileChannel channel, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span></span>; }</code> </pre> <br>    : <br><br><ul><li>  ,     cache hit      ,    <code>RandomAccessFile</code> .      ,       .     ,          <code>sendfile()</code> .      . </li><li>   cache miss   :             .     , ‚Äî  ,     , ‚Äî      . </li><li> ,    -      heap.        <code>ByteBuffer</code> . </li></ul><br><br>      API,      ,      .      Typed Actor Model,  <a href="https://github.com/reactive-streams/reactive-streams-jvm/tree/master/examples"></a>  <a href="https://github.com/reactive-streams/reactive-streams-jvm"> </a> <a href="http://www.reactive-streams.org/"> </a> .     ,       ,   ,        .      . <br><br><div class="spoiler"> <b class="spoiler_title"> ,    .</b> <div class="spoiler_text">     .   publisher  subscriber   ,    ,   executor,       . <code>AtomicBoolean</code>  happens before   . <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Incoming messages final Queue&lt;M&gt; mailbox; // Message processing works here final Executor executor; // To ensure HB relationship between runs final AtomicBoolean on = new AtomicBoolean();</span></span></code> </pre> <br>    : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ enqueue(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(n)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enqueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> M message)</span></span></span><span class="hljs-function"> </span></span>{ mailbox.offer(message); tryScheduleToExecute(); }</code> </pre> <br>  <code>tryScheduleToExecute()</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (on.compareAndSet(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { executor.execute(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { ... } }</code> </pre> <br>  <code>run()</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (on.get()) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dequeueAndProcess(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { on.set(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!messages.isEmpty()) { tryScheduleToExecute(); } } }</code> </pre> <br>  <code>dequeueAndProcess()</code> : <br><br><pre> <code class="java hljs">M message; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((message = mailbox.poll()) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Pattern match if (message instanceof Request) { doRequest(((Request) message).n); } else { ‚Ä¶ } }</span></span></code> </pre> </div></div><br>     .    ,  <code>volatile</code> , <code>Atomic*</code> , contention  .       100 000    200 . <br><br><h1>  Eventually </h1><br>  production   12 ,          .        10 /    .     .    Java  <a href="https://github.com/odnoklassniki/one-nio">one-nio</a> . <br><br><img src="https://habrastorage.org/webt/oa/pz/cq/oapzcqjf6y9ccxrnk1wzrpaigdy.jpeg"><br><br>     ,     . 99-  20 .   ‚Äî    HTTPS-.   ‚Äî         <code>sendfile()</code>  HTTP. <br><br>    cache hit  production 97%,    latency   ,         ,   ,   . <br><br><img src="https://habrastorage.org/webt/xp/fd/eq/xpfdequddx6cnglrzrgdxtbspuc.jpeg"><br><br>    75-    ,       1 .         ‚Äî   300 .  Those. 0.7  ‚Äî   . <br><br>      ,      ,     ,   . ,    . </div><p>Source: <a href="https://habr.com/ru/post/434206/">https://habr.com/ru/post/434206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434196/index.html">3CX v16 Alpha 2 and plans for the new year</a></li>
<li><a href="../434198/index.html">Selecting the operation of the web server on personal experience</a></li>
<li><a href="../434200/index.html">Is it so scary Rust, as it is painted</a></li>
<li><a href="../434202/index.html">4 secrets how not to lose work in data science</a></li>
<li><a href="../434204/index.html">OneWeb offers Russia a share in the project in exchange for frequencies</a></li>
<li><a href="../434208/index.html">How Go saved our ‚ÄúBlack Friday‚Äù</a></li>
<li><a href="../434210/index.html">Analysis of the quiz contest on Android from the HeadHunter booth at Mobius 2018 Moscow</a></li>
<li><a href="../434212/index.html">Tesla Tower. What happens in and near the skyscraper when lightning strikes?</a></li>
<li><a href="../434214/index.html">Dynamic Java Proxy: What is it and how to use it?</a></li>
<li><a href="../434216/index.html">Brute-force attacks using Kali Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>