<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a file system in the Linux kernel</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Who is this article for? 


 This article is based on the practice of operating systems at the Academic University . The material was prepared for stu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a file system in the Linux kernel</h1><div class="post__text post__text-html js-mediator-article"><h4>  Who is this article for? </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/009/a4e/9d8/009a4e9d8c58831bc8b7c6e1e3944248.jpg" alt="image" align="left"><br><br>  This article is based on the practice of operating systems at the <a href="http://mit.spbau.ru/">Academic University</a> .  The material was prepared for students, and there will be nothing difficult here, just a basic knowledge of the command line, the C language, Makefile and general theoretical knowledge about file systems. <br><br>  All material is divided into several parts, this article will describe the introductory part.  I will briefly talk about what is needed for development in the Linux kernel, then we will write the simplest loadable kernel module, and finally write the skeleton of the future file system ‚Äî a module that registers a rather useless (so far) file system in the kernel.  People already familiar (albeit superficially) with the development of the Linux kernel will not find anything interesting here. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  The file system is one of the central OS subsystems.  The development of file systems went along with the development of the OS.  At the moment we have a whole zoo of a wide variety of file systems from the old ‚Äúclassic‚Äù <a href="http://en.wikipedia.org/wiki/Unix_File_System">UFS</a> , to the new interesting <a href="http://en.wikipedia.org/wiki/NILFS">NILFS</a> (although the idea is not new, look at the <a href="http://en.wikipedia.org/wiki/Log-structured_File_System_(BSD)">LFS</a> ) and <a href="http://en.wikipedia.org/wiki/Btrfs">BTRFS</a> .  So, one can say that the theory and practice of creating file systems is fully developed.  We will not try to overthrow monsters like ext3 / 4 and BTRFS, our file system will be educational in nature, for example we will get acquainted with the Linux kernel. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Setting up the environment </h4><br>  Before we go into the kernel, let's prepare everything necessary to build our file system module.  Everyone has their own preferences in Linux distributions, but I‚Äôm used to using Ubutnu, so I‚Äôll show the environment settings using her example, fortunately it‚Äôs not at all difficult.  First we need a compiler and tools for building: <br><br> <code>sudo apt-get install gcc build-essential <br></code> <br><br>  Next, we will need the kernel sources, or not.  We will go in a simple way - we will not rebuild the kernel from source, just set ourselves the kernel headers, this will be enough to write a loadable module.  You can set the headers like this: <br><br> <code>sudo apt-get install linux-headers-`uname -r` <br></code> <br><br>  Here I must make a small lyrical digression.  Poking around in the kernel on a working machine is not the best idea, so I strongly advise you to do this all in a virtual machine.  We will not do anything dangerous, so the saved data is safe, but if <br>  something goes wrong, you will probably have to reboot the system, and this is pretty annoying.  In addition, it is more convenient to debug kernel modules in a virtual machine (such as QEMU), although this issue will not be discussed in this article. <br><br><h4>  Checking the environment </h4><br>  To check the environment, we will write and run a kernel module that will not do anything useful (Hello, World!).  Let's look at the module code, I called it super.c (do not think anything, super is from superblock): <br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;linux/init.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;linux/module.h&gt; static <span class="hljs-type"><span class="hljs-type">int</span></span> __init aufs_init(<span class="hljs-type"><span class="hljs-type">void</span></span>) { pr_debug("aufs module loaded\n"); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } static <span class="hljs-type"><span class="hljs-type">void</span></span> __exit aufs_fini(<span class="hljs-type"><span class="hljs-type">void</span></span>) { pr_debug("aufs module unloaded\n"); } module_init(aufs_init); module_exit(aufs_fini); MODULE_LICENSE("GPL"); MODULE_AUTHOR("kmu");</code> </pre><br><br>  At the very beginning there are two headers, consider that they are an obligatory part of any loadable kernel module, there is nothing interesting in them.  Next come the two functions aufs_init and aufs_fini - they will be called after loading and before unloading the module, respectively. <br><br>  Some of you may be confused by the label __init.  __init is a hint to the kernel that the function is used only during module initialization, which means that after module initialization this function can be unloaded from memory.  There is a similar marker for the data, however, the kernel may well ignore these hints.  Accessing __init functions and data from the main module code is a potential error, so it is checked during module building that there are no such references.  If such an appeal is found, the kernel build system will issue a warning.  Similarly, validation is done for __exit functions and data.  If you are interested in the details of what __init and __exit are, then you can refer to the <a href="">sources</a> . <br><br>  Note that aufs_init returns an int.  Thus, the kernel finds out that something went wrong during the module initialization - if the module returned a non-zero value, it means an error occurred during the initialization. <br><br>  To specify which functions to call when loading and unloading a module, two macros are used: module_init and module_exit.  They are revealed in a certain amount of compiler magic, but we will not go into details, interested people can turn to <a href="">lxr</a> and follow the links (I must say, it‚Äôs a very handy thing to master the kernel). <br><br>  pr_debug is a function (actually it is a macro, but so far it doesn‚Äôt matter to us) output to the kernel log, the printf family of functions with some extensions is very similar, for example, for printing IP and MAC addresses.  A complete list of modifiers can be found in the kernel <a href="http://lxr.free-electrons.com/source/Documentation/printk-formats.txt%3Fv%3D3.14">documentation</a> .  Together with pr_debug, there is a whole family of macros: pr_info, pr_warn, pr_err, and others.  Those who are a little familiar with the development of Linux modules surely know about the printk function, in principle, the pr_ * macros are expanded into printk calls, so printk can be used instead. <br><br>  Next come the macros with information for descendants - the license and the author.  There are other macros that allow you to save a wide variety of information about the module, for example, MODULE_VERSION, MODULE_INFO, MODULE_SUPPORTED_DEVICE and others.  By the way, the funny fact is that if you use a license other than the GPL, then you cannot use some of the functions available to the GPL modules. <br><br>  Now we will collect and load our module.  To do this, write a Makefile that will build our module: <br><br><pre> <code class="hljs javascript">obj-m := aufs.o aufs-objs := <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.o CFLAGS_super.o := -DDEBUG all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</code> </pre><br><br>  In fact, this build Makefile calls the kernel Makefile, which should be located in the / lib / modules / $ (shell uname -r) / build directory (uname -r is a command that returns the version of the running kernel) if you have headers (or sources) kernels are in a different directory, then you need to fix it. <br><br>  obj-m - allows you to specify the name of the future module, in our case, the module will be called aufs.ko (namely ko - from the kernel object).  And aufs-objs allows you to specify from which source files to collect the aufs module, in our case only one file super.c will be used.  In addition, you can specify various compiler flags to be used (in addition to those used by the kernel Makefile) when building object files, in our case I pass the -DDEBUG flag when building super.c.  If you do not pass the -DDEBUG flag, then we will not see the pr_debug output in the system log. <br><br>  To build a module you need to run the command make.  If all is well, then the file aufs.ko should appear in the directory - this is our loadable module.  Downloading a module is quite simple: <br><br> <code>sudo insmod ./aufs.ko <br></code> <br><br>  To make sure that the module is loaded, you can look at the output of the lsmod command: <br><br> <code>lsmod | grep aufs <br></code> <br><br>  To view the system log, you need to call the dmesg command, and there we need to see messages from our module.  Unloading the module is also not difficult: <br><br> <code>sudo rmmod aufs <br></code> <br><br><h4>  Back to the file system </h4><br>  So, the environment is set up and working, we have learned how to build the simplest module, load and unload it, it's time to take up the file system.  Designing a file system should begin "on a piece of paper," with a thorough thought through the data structures used and so on.  But we will go in a simple way and postpone the details of storing files and folders (and much more) on the disk for the next time, and now we will write the skeleton of our future file system. <br><br>  The life of the file system begins with registration.  You can register the file system by calling <a href="">register_filesystem</a> .  We will register the file system in the module initialization function.  To unregister a file system there is a function <a href="">unregister_filesystem</a> , and we will call it in the function aufs_fini of our module. <br><br>  Both functions take as a parameter a pointer to the file_system_type structure - it will ‚Äúdescribe‚Äù the file system, consider that it is a file system class.  There are enough fields in this structure, but we are only interested in some of them: <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file_system_type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aufs_type</span></span></span><span class="hljs-class"> = </span></span>{ .owner = <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>, .name = <span class="hljs-string"><span class="hljs-string">"aufs"</span></span>, .mount = aufs_mount, .kill_sb = kill_block_super, .fs_flags = <span class="hljs-type"><span class="hljs-type">FS_REQUIRES_DEV</span></span>, };</code> </pre><br><br>  First of all, we are interested in the name field, it stores the name of the file system, this is the name that will be used when mounting, but more on that later, just remember it. <br><br>  mount and kill_sb - two fields storing pointers to functions.  The first function will be called when mounting the file system, and the second when unmounting.  We only need to implement one, and instead of the second we will use kill_block_super, which the kernel kindly provides. <br><br>  The fs_flags field stores various flags, in our case it stores the FS_REQUIRES_DEV flag, which says that our file system needs a disk to work with (although this is not the case yet).  You can not specify this flag, everything will work fine without it. <br><br>  Finally, the owner field is needed to organize the counter of links to the module.  The reference counter is needed so that the module is not unloaded ahead of time, for example, if the file system was mounted, then unloading the module can lead to a crash, the reference counter will not allow unloading the module while it is being used, that is, until we unmount the file system. <br><br>  Now consider the function aufs_mount.  It should mount the device and return the structure describing the root directory of the file system.  It sounds quite difficult, but, fortunately, even here the kernel will do almost everything for us: <br><br><pre> <code class="hljs objectivec"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> dentry *aufs_mount(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> file_system_type *type, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> flags, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *dev, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *data) { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> dentry *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> entry = mount_bdev(type, flags, dev, data, aufs_fill_sb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(entry)) pr_err(<span class="hljs-string"><span class="hljs-string">"aufs mounting failed\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pr_debug(<span class="hljs-string"><span class="hljs-string">"aufs mounted\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entry; }</code> </pre><br><br>  In fact, most of the work happens inside the moun_bdev function, we are only interested in its parameter aufs_fill_sb - this is a pointer to a function (again) that will be called from mount_bdev to initialize the superblock.  But before we move on to it, we will focus on the <a href="">dentry</a> structure, <a href="">which is</a> important for the core file subsystem.  This structure represents the path section in the file name, for example, if we refer to the file / usr / bin / vim, then we will have instances of the dirent structure representing the path sections / (root directory), bin / and vim.  The kernel supports the cache of these structures, which allows you to quickly search for inode (another center structure) by the name (path) of the file.  So, the aufs_mount function should return the dentry representing the root directory of our file system, and the aufs_fill_sb function will create it. <br><br>  So, aufs_fill_sb so far the most important function in our module, and it looks like this: <br><br><pre> <code class="hljs rust"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> int aufs_fill_sb(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">super_block</span></span></span></span> *sb, void *data, int silent) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inode</span></span></span></span> *root = NULL; sb-&gt;s_magic = AUFS_MAGIC_NUMBER; sb-&gt;s_op = &amp;aufs_super_ops; root = new_inode(sb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!root) { pr_err(<span class="hljs-string"><span class="hljs-string">"inode allocation failed\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; } root-&gt;i_ino = <span class="hljs-number"><span class="hljs-number">0</span></span>; root-&gt;i_sb = sb; root-&gt;i_atime = root-&gt;i_mtime = root-&gt;i_ctime = CURRENT_TIME; inode_init_owner(root, NULL, S_IFDIR); sb-&gt;s_root = d_make_root(root); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sb-&gt;s_root) { pr_err(<span class="hljs-string"><span class="hljs-string">"root creation failed\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  First of all, we fill out the <a href="">super_block</a> structure.  What kind of structure is this?  Usually, file systems store in a special place on a disk partition (this place is chosen by the file system) a set of file system parameters, such as block size, number of free / occupied blocks, file system version, ‚Äúpointer‚Äù to the root directory, magic number by which the driver the file system can verify that the exact file system is stored on the disk, and not something else, well, and other data.  This structure is called the superblock (see picture below).  The super_block structure in the Linux kernel, in general, is designed for similar purposes, we keep in it the magic number and the dentry for the root directory (the same one that mount_bdev returns). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80b/0bd/0a0/80b0bd0a071554b0c5440d8e3c6b4fbc.gif" alt="image"><br><br>  In addition, in the s_op field of the super_block structure, we store a pointer to the <a href="">super_operations</a> structure ‚Äî these are the ‚Äúclass methods‚Äù of super_block, i.e., another structure that stores a bunch of function pointers. <br><br>  Here I will make another digression, the Linux kernel is written in C, that is, without support for various OOP features from the language, but you can structure the program following OOP ideas without support from the language, so structures containing a bunch of function pointers are quite common in the core, this is the way to implement polymorphism of subtypes (aka virtual functions) with available means. <br><br>  But back to the super_block structure and its ‚Äúmethods‚Äù, we will not go into the details of the super_operations structure now, we will be interested only in one of its fields - put_super.  In put_super, we will keep the ‚Äúdestructor‚Äù of our superblock: <br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aufs_put_super</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> super_block *sb</span></span></span><span class="hljs-function">)</span></span> { pr_debug(<span class="hljs-string"><span class="hljs-string">"aufs super block destroyed\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> super_operations <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aufs_super_ops = { .put_super = aufs_put_super, };</code> </pre><br><br>  While the aufs_put_super function does nothing useful, we use it exclusively to print another line to the system log.  The aufs_put_super function will be called inside kill_block_super (see above) before destroying the super_block structure, i.e., when the file system is unmounted. <br><br>  Now back to our most important function, aufs_fill_sb.  Before creating a dentry for the root directory, we need to create a root inode.  The inode structure is perhaps the most important in the file subsystem; each file system object (file, folder, special file, journal, etc.) is identified by an inode.  As with super_block, the inode structure reflects how file systems are stored on disk.  The inode name comes from index node, i.e. it indexes files and folders on the disk.  Usually inside the inode on the disk is stored an indication of where the file data is stored on the disk (in which blocks the file contents are stored), various access flags (read / write / execute), information about the file owner, time of creation / modification / access and other similar things (see picture above). <br><br>  While we are not able to read from a disk, so we fill inode with dummy data.  We use the current time as the creation / modification / access time, and delegate the assignment of the owner and access rights to the kernel (call the inode_init_owner function).  Well, finally create a dentry associated with the root inode. <br><br><h4>  Check the frame </h4><br>  The frame of our file system is ready, it's time to check it out.  Building and loading the file system driver is no different from building and loading a regular module.  Instead of a real disk for experiments, we will use a loop device.  This is such a ‚Äúdisk‚Äù driver that writes data not to a physical device, but to a file (disk image).  Create a disk image until it stores any data, so everything is simple: <br><br> <code>touch image <br></code> <br><br>  In addition, we need to create a directory that will be the mount point (root) of our file system: <br><br> <code>mkdir dir <br></code> <br><br>  Now using this image we will mount our file system: <br><br> <code>sudo mount -o loop -t aufs ./image ./dir <br></code> <br><br>  If the operation was completed successfully, then we should see messages from our module in the system log.  To unmount the file system, do this: <br><br> <code>sudo umount ./dir <br></code> <br><br>  And again we check the system log. <br><br><h4>  Total </h4><br>  We are superficially acquainted with the creation of loadable kernel modules and the basic structures of the file subsystem.  We also wrote a real file system, which can only be mounted and unmounted, while it is pretty stupid, even cd to the root of the file system does not work, but we are going to fix it in the future. <br><br>  Next, we plan to consider reading data from the disk, to begin with, we will determine how we will store the data on the disks, and learn how to read the superblock and inodes from the disk. <br><br><h4>  References and references </h4><br><br><ol><li>  The code for the article is on <a href="https://github.com/krinkinmu/aufs">github</a> </li><li>  Not so long ago, an Indian had already written a simple file system from scratch for educational purposes, he did a great <a href="https://github.com/psankar/simplefs">job.</a> </li><li>  I understand that sending newbies to the source code of the kernel is not very pedagogical (although it is useful to read the source code), but nevertheless I advise anyone interested to look at the source code of a very simple <a href="http://lxr.free-electrons.com/source/fs/ramfs/">ramfs</a> file system.  In addition, unlike our file system, ramfs does not use a disk, but stores everything in memory. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/218833/">https://habr.com/ru/post/218833/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../218819/index.html">Developing an application for Firefox OS with a real example</a></li>
<li><a href="../218821/index.html">Recovering data in MySQL from an EBS snapshot</a></li>
<li><a href="../218825/index.html">We start to study Cortex-M on the example of STM32, part 2</a></li>
<li><a href="../218827/index.html">UP Review! 3D Printer Mini</a></li>
<li><a href="../218829/index.html">Testing client-server API security</a></li>
<li><a href="../218837/index.html">Dev Story: Crystalux - nuances of developing and promoting puzzles for Android</a></li>
<li><a href="../218841/index.html">The program of the course "Java Core"</a></li>
<li><a href="../218843/index.html">How long can you be mistaken thinking that Foglight will promptly report a problem with memory loading</a></li>
<li><a href="../218845/index.html">Hello% habrauser%! Let's get acquainted!</a></li>
<li><a href="../218847/index.html">Two days to the International Space Apps Challenge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>