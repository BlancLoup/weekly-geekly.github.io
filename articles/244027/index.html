<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We analyze the proxying methods based on HAProxy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently I had to deal with proxying access to web servers using HAProxy. The main problem was encrypted access. Who is interested in this topic, welc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We analyze the proxying methods based on HAProxy</h1><div class="post__text post__text-html js-mediator-article"> Recently I had to deal with proxying access to web servers using HAProxy.  The main problem was encrypted access.  Who is interested in this topic, welcome under cat. <br><a name="habracut"></a><br>  There are a number of web servers in our company.  To save addresses, access to them is organized through HAProxy.  Like this: <br><br><img src="https://habrastorage.org/files/232/45e/dda/23245edda6984e41a8b0cae9bfaa3139.jpg"><br><br>  At the same time, the configuration of HAProxy itself is extremely simple ( <u>example No. 1</u> ): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>frontend http_frontend</i> <i><br></i>  <i>bind *: 80</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>option httpclose</i> <i><br></i>  <i>acl is_mytest1 hdr_end (host) -i mytest1.loc</i> <i><br></i>  <i>use_backend mytest1_web if is_mytest1</i> <i><br></i>  <i>acl is_mytest2 hdr_end (host) -i mytest2.loc</i> <i><br></i>  <i>use_backend mytest2_web if is_mytest2</i> <i><br><br></i>  <i>backend mytest1_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server mytestweb1 192.168.1.5:80 check cookie mytestweb1</i> <i><br><br></i>  <i>backend mytest2_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server mytestweb2 192.168.1.10:80 check cookie mytestweb2</i> <br><br>  Hereinafter I will give not complete examples of the config file, but only pieces of interest to us. <br><br>  Extremely simple - we listen to port 80 and parse all incoming traffic.  If mytest1.loc is requested, it is placed in the access-list is_mytest1, in this case the mytest1_web backend is used, in which we redirect traffic to the internal host 192.168.1.5, where we have this site.  Similarly for mytest2.loc.  Everything is extremely simple and at the same time we save real IP addresses. <br><br>  There was a question of resiliency, especially since we also have servers in the neighboring town where we can put up these websites.  Well, there is a virtual machine with Linux in the Amazon cloud, which does the same thing, but for sites located in the cloud.  Can we use 2 HAProxy in a row?  Raise about this test circuit and see: <br><br><img src="https://habrastorage.org/files/eb1/948/673/eb1948673dd74e9e8442dbd44484de8c.jpg"><br><br>  The configurations of HAProxy2 and HAProxy3 have not changed, but the balancing parameter has been added to HAProxy1 ( <u>example # 2</u> ): <br><br>  <i>frontend http_frontend</i> <i><br></i>  <i>bind *: 80</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>option httpclose</i> <i><br></i>  <i>acl is_mytest1 hdr_end (host) -i mytest1.loc</i> <i><br></i>  <i>use_backend mytest1_web if is_mytest1</i> <i><br></i>  <i>acl is_mytest2 hdr_end (host) -i mytest2.loc</i> <i><br></i>  <i>use_backend mytest2_web if is_mytest2</i> <i><br><br></i>  <i>backend mytest1_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server HAProxy1 1.1.1.1:80 check cookie haproxy1_1</i> <i><br></i>  <i>server HAProxy2 3.3.3.3:80 check cookie haproxy2_1</i> <i><br><br></i>  <i>backend mytest2_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server HAProxy1 1.1.1.1:80 check cookie haproxy1_3</i> <i><br></i>  <i>server HAProxy2 3.3.3.3:80 check cookie haproxy2_3</i> <br><br>  Everything worked fine.  It would seem, you can rejoice, but here it was decided to redo the sites for work through SSL.  And the problems started. <br><br>  Let's return to the beginning and consider everything from the beginning.  The first assumption is that we do not need to encrypt the traffic between the proxy server and the site itself.  Secondly, we do not need to worry about linking the certificate to the site, that is, we use self-signed certificates everywhere. <br><br><img src="https://habrastorage.org/files/de5/883/010/de588301089741e396acec9c53a27112.jpg"><br><br>  What do we need to do?  Generate and install a self-signed certificate on our HAProxy server, then the client, accessing the site, will go to our proxy server, take its certificate, establish a secure connection with the server and then be redirected to the website.  And for all sites behind the proxy server, one certificate will be used. <br><br>  So let's get started.  We generate: <br><br>  <i>openssl req -new -x509 -nodes -out server.crt -keyout server.key</i> <br><br>  Write to one file: <br><br>  <i>cat server.key&gt; /etc/ssl/mytest.loc.pem</i> <i><br></i>  <i>cat server.crt &gt;&gt; /etc/ssl/mytest.loc.pem</i> <br><br>  And edit the configuration of HAProxy ( <u>example number 3</u> ): <br><br>  <i>frontend http_frontend</i> <i><br></i>  <i>bind *: 80</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>option httpclose</i> <i><br></i>  <i>acl is_mytest1 hdr_end (host) -i mytest1.loc</i> <i><br></i>  <i>use_backend mytest1_web if is_mytest1</i> <i><br></i>  <i>acl is_mytest2 hdr_end (host) -i mytest2.loc</i> <i><br></i>  <i>use_backend mytest2_web if is_mytest2</i> <i><br><br></i>  <i>backend mytest1_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server mytestweb1 192.168.1.5:80 check cookie mytestweb1</i> <i><br><br></i>  <i>backend mytest2_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server mytestweb2 192.168.1.10:80 check cookie mytestweb2</i> <i><br><br></i>  <i>frontend https_frontend</i> <i><br></i>  <i>bind *: 443 ssl crt /etc/ssl/mytest.loc.pem</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>option httpclose</i> <i><br></i>  <i>acl is_mytest1 hdr_end (host) -i mytest1.loc</i> <i><br></i>  <i>use_backend mytest1_web if is_mytest1</i> <i><br></i>  <i>acl is_mytest2 hdr_end (host) -i mytest2.loc</i> <i><br></i>  <i>use_backend mytest2_web if is_mytest2</i> <br><br>  By the way, checking the configuration before restarting is a very good habit: <br><br>  <i>haproxy -c -f /etc/haproxy/haproxy.cfg</i> <i><br></i>  <i>Configuration file is valid</i> <br><br>  Check and see that everything works fine. <br><br>  Well, now let's take the case when each site has its own certificate, and not a self-signed one, but a purchased one.  And it has a strict binding to the name of the site.  In this case, we can resolve the issue in two ways: place certificates for sites on the HAProxy server or proxy TCP instead of HTTP.  But in both cases we will not be able to manage with one IP address for our two sites. <br><br>  Consider the first case: <br><br><img src="https://habrastorage.org/files/9a0/608/2fe/9a06082fe0c646999ad0d2f9575578cb.jpg"><br><br>  The difference between this case and the previous one (with self-signed certificates) is only in the fact that here we have to listen to individual interfaces and issue a certificate depending on the interface ( <u>example No. 4</u> ): <br><br>  <i>frontend http_frontend</i> <i><br></i>  <i>bind *: 80</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>option httpclose</i> <i><br></i>  <i>acl is_mytest1 hdr_end (host) -i mytest1.loc</i> <i><br></i>  <i>use_backend mytest1_web if is_mytest1</i> <i><br></i>  <i>acl is_mytest2 hdr_end (host) -i mytest2.loc</i> <i><br></i>  <i>use_backend mytest2_web if is_mytest2</i> <i><br><br></i>  <i>backend mytest1_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server mytestweb1 192.168.1.5:80 check cookie mytestweb1</i> <i><br><br></i>  <i>backend mytest2_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server mytestweb2 192.168.1.10:80 check cookie mytestweb2</i> <i><br><br></i>  <i>frontend https_frontend_site1</i> <i><br></i>  <i>bind 1.1.1.1:443 ssl crt /etc/ssl/mytest.loc1.pem</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>option httpclose</i> <i><br></i>  <i>acl is_mytest1 hdr_end (host) -i mytest1.loc</i> <i><br></i>  <i>use_backend mytest1_web if is_mytest1</i> <i><br><br></i>  <i>frontend https_frontend_site2</i> <i><br></i>  <i>bind 9.9.9.9:443 ssl crt /etc/ssl/mytest.loc2.pem</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>option httpclose</i> <i><br></i>  <i>acl is_mytest2 hdr_end (host) -i mytest2.loc</i> <i><br></i>  <i>use_backend mytest2_web if is_mytest2</i> <br><br>  It seems everything is clear, if traffic came to the interface with the address 1.1.1.1, it means that the client requests the site mytest1.loc.  So, we give him the certificate of this site and then we proxy on the <i>backend mytest1_web</i> . <br><br>  In the second case, we forward all TCP traffic that came to us to port 443 completely.  This should be done, for example, when for some reason you do not want site certificates stored on a proxy server.  Or, for example, do not trust the internal network between the proxy and web servers. <br><br><img src="https://habrastorage.org/files/f80/d55/6a8/f80d556a8b384e729ae25fb8b5756d8b.jpg"><br><br>  The configuration of HAProxy will be approximately the following ( <u>example No. 5</u> ): <br><br>  <i>frontend mytest1_frontend</i> <i><br></i>  <i>bind 1.1.1.1:443</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>use_backend mytest1_webssl</i> <i><br><br></i>  <i>backend mytest1_webssl</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>option ssl-hello-chk</i> <i><br></i>  <i>server mytestweb 192.168.1.5:443</i> <i><br><br></i>  <i>frontend mytest2_frontend</i> <i><br></i>  <i>bind 9.9.9.9:443</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>use_backend mytest2_webssl</i> <i><br><br></i>  <i>backend mytest2_webssl</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>option ssl-hello-chk</i> <i><br></i>  <i>server mytestweb 192.168.1.10:443</i> <br><br>  It seems quite understandable configuration.  Probably, it is worth saying that since we are sending all TCP traffic, we cannot analyze it, and therefore the presence of any access-lists in the frontend part will generate an error. <br><br>  It is time to return to our task with the division of web sites for different cities.  To begin, consider the simpler case: <br><br><img src="https://habrastorage.org/files/c65/e7b/fcb/c65e7bfcb48b4088abfd51afdc1c831b.jpg"><br><br>  Since we have the Internet between HAProxy1 and HAProxy2, even when using self-signed certificates, we cannot use HTTP PROXY MODE on HAProxy1, otherwise the whole point in encrypting such a connection is lost.  We will use on HAProxy1 tcp mode, and on HAProxy2 http mode. <br><br>  Configuration for HAProxy1 ( <u>Example # 6</u> ): <br><br>  <i>frontend https_frontend</i> <i><br></i>  <i>bind *: 443</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>use_backend https_web</i> <i><br><br></i>  <i>backend https_web</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>option ssl-hello-chk</i> <i><br></i>  <i>server haproxy2 1.1.1.1:443</i> <br><br>  The configuration for HAProxy2 will be identical to the configuration in <u>example No. 3</u> <br><br>  It is time to add the second part of the servers: <br><img src="https://habrastorage.org/files/be5/21a/134/be521a1348f54c15a3fc43049e81bf8e.jpg"><br><br>  Configuration for HAProxy1 ( <u>example number 7</u> ): <br><br>  <i>frontend https_frontend</i> <i><br></i>  <i>bind *: 443</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>use_backend https_web</i> <i><br><br></i>  <i>backend https_web</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>option ssl-hello-chk</i> <i><br></i>  <i>server haproxy2 1.1.1.1:443 check</i> <i><br></i>  <i>server haproxy3 3.3.3.3:443 check</i> <br><br>  All the difference of this example from the previous one is the presence of balancing and fault tolerance between HAProxy2 and HAProxy3, which, by our condition, must be located in different cities. <br><br>  Well, the last example would be if there are non-signed certificates.  Suppose they are installed on HAProxy servers - as in <u>Example 4</u> : <br><br><img src="https://habrastorage.org/files/d11/27a/0cc/d1127a0cce9c407194e8428af9ccb9f9.jpg"><br><br>  The configuration for HAProxy1 will be as in the previous example, and for HAProxy2 - as in <u>example 4</u> .  Same for HAProxy3 with minor changes to real addresses in the <i>frontend</i> part. <br><br>  It is also worth saying that all 3 HAProxy servers can be configured in TCP MODE - and this will also be a workable solution. <br><br>  And finally, I would like to say: if someone knows some fundamentally different solutions for this task, I would be grateful if you share them. <br><br>  A small update.  It seemed to me here that if we forward traffic, then there is no need for us to use a set of different IP addresses on HAProxy2 and HAProxy3, it is much easier just to use different ports. <br>  Let's consider the following scheme: <br><img src="https://habrastorage.org/files/27a/58f/2ae/27a58f2aea614193927140c8123d1741.jpg"><br><br>  We have two different host sites in different cities.  One is for HAProxy2 and the other is for HAProxy3.  And the central proxy server, on which the task of balancing rests, while the sites <a href="http://www.mytest1.loc/">www.mytest1.loc</a> and <a href="http://www.mytest2.loc/">www.mytest2.loc</a> must be balanced, and the site <a href="http://www.mytest3.loc/">www.mytest3.loc</a> exists only on one site, therefore access to it should only be forwarded through proxy server. All sites must be accessible via both HTTP and HTTPS with non-signed certificates. <br>  Configuration HAProxy1: <br>  <i>frontend http_frontend</i> <i><br></i>  <i>bind *: 80</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>option httpclose</i> <i><br></i>  <i>acl is_mytest1 hdr_end (host) -i mytest1.loc</i> <i><br></i>  <i>use_backend mytest1_web if is_mytest1</i> <i><br></i>  <i>acl is_mytest2 hdr_end (host) -i mytest2.loc</i> <i><br></i>  <i>use_backend mytest2_web if is_mytest2</i> <i><br></i>  <i>acl is_mytest3 hdr_end (host) -i mytest3.loc</i> <i><br></i>  <i>use_backend mytest3_web if is_mytest3</i> <i><br><br></i>  <i>backend mytest1_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server mytestweb1 1.1.1.1:80 check cookie mytestweb1</i> <i><br></i>  <i>server mytestweb1 2.2.2.2:80 check cookie mytestweb1</i> <i><br><br></i>  <i>backend mytest2_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server mytestweb2 1.1.1.1:80 check cookie mytestweb2</i> <i><br></i>  <i>server mytestweb2 2.2.2.2:80 check cookie mytestweb2</i> <i><br><br></i>  <i>backend mytest3_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server mytestweb3 2.2.2.2:80 check cookie mytestweb3</i> <i><br><br></i>  <i>frontend mytest1_frontend</i> <i><br></i>  <i>bind 3.3.3.3:443</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>use_backend mytest_webssl1</i> <i><br><br></i>  <i>backend mytest_webssl1</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>option ssl-hello-chk</i> <i><br></i>  <i>server mytestweb1 1.1.1.1 Down5551</i> <i><br></i>  <i>server mytestweb2 2.2.2.2 Down5551</i> <i><br><br></i>  <i>frontend mytest2_frontend</i> <i><br></i>  <i>bind 4.4.4.4:443</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>use_backend mytest_webssl2</i> <i><br><br></i>  <i>backend mytest_webssl2</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>option ssl-hello-chk</i> <i><br></i>  <i>server mytestweb1 1.1.1.1 Down5552</i> <i><br></i>  <i>server mytestweb2 2.2.2.2 Down5552</i> <i><br><br></i>  <i>frontend mytest3_frontend</i> <i><br></i>  <i>bind 5.5.5.5:443</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>use_backend mytest_webssl3</i> <i><br><br></i>  <i>backend mytest_webssl3</i> <i><br></i>  <i>mode tcp</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>option ssl-hello-chk</i> <i><br></i>  <i>server mytestweb2 2.2.2.2 Down5553</i> <i><br></i> <br>  And the HAProxy3 configuration: <br><br>  <i>frontend http_frontend</i> <i><br></i>  <i>bind *: 80</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>option httpclose</i> <i><br></i>  <i>acl is_mytest1 hdr_end (host) -i mytest1.loc</i> <i><br></i>  <i>use_backend mytest1_web if is_mytest1</i> <i><br></i>  <i>acl is_mytest2 hdr_end (host) -i mytest2.loc</i> <i><br></i>  <i>use_backend mytest2_web if is_mytest2</i> <i><br></i>  <i>acl is_mytest3 hdr_end (host) -i mytest3.loc</i> <i><br></i>  <i>use_backend mytest3_web if is_mytest3</i> <i><br><br></i>  <i>frontend mytest1_frontend</i> <i><br></i>  <i>bind 2.2.2.2 ro5551 ssl crt /etc/ssl/mytest1.loc.pem</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>option httpclose</i> <i><br></i>  <i>option forwardfor</i> <i><br></i>  <i>reqadd X-Forwarded-Proto: \ https</i> <i><br></i>  <i>use_backend mytest1_web</i> <i><br><br></i>  <i>frontend mytest2_frontend</i> <i><br></i>  <i>bind 2.2.2.2 bn5552 ssl crt /etc/ssl/mytest2.loc.pem</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>option httpclose</i> <i><br></i>  <i>option forwardfor</i> <i><br></i>  <i>reqadd X-Forwarded-Proto: \ https</i> <i><br></i>  <i>use_backend mytest2_web</i> <i><br><br></i>  <i>frontend mytest3_frontend</i> <i><br></i>  <i>bind 2.2.2.2 ro5553 ssl crt /etc/ssl/mytest3.loc.pem</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>option httpclose</i> <i><br></i>  <i>option forwardfor</i> <i><br></i>  <i>reqadd X-Forwarded-Proto: \ https</i> <i><br></i>  <i>use_backend mytest3_web</i> <i><br><br></i>  <i>backend mytest1_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>stats enable</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server mytestweb1 192.168.1.5:80 check cookie mytestweb1</i> <i><br><br></i>  <i>backend mytest2_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>stats enable</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server mytestweb2 192.168.1.10:80 check cookie mytestweb2</i> <i><br><br></i>  <i>backend mytest3_web</i> <i><br></i>  <i>mode http</i> <i><br></i>  <i>balance roundrobin</i> <i><br></i>  <i>stats enable</i> <i><br></i>  <i>cookie SERVERID insert indirect nocache</i> <i><br></i>  <i>server mytestweb3 192.168.1.15:80 check cookie mytestweb3</i> <i><br></i> </div><p>Source: <a href="https://habr.com/ru/post/244027/">https://habr.com/ru/post/244027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244011/index.html">How to increase the speed of communication and productivity: The introduction of Vim ideology in the messenger</a></li>
<li><a href="../244013/index.html">HungryBread - a startup about a lunch in a pleasant company</a></li>
<li><a href="../244015/index.html">Configuring Beans with Annotations: Solving the Inheritance Problem for Annotation Interfaces</a></li>
<li><a href="../244017/index.html">Pseudo-practical example of closures and decorators</a></li>
<li><a href="../244023/index.html">CryptSync and GnuPG - customization options and inability to use</a></li>
<li><a href="../244029/index.html">Corporate software: main trends and why they are important</a></li>
<li><a href="../244031/index.html">Protect .net applications from prying eyes</a></li>
<li><a href="../244033/index.html">HP 9830B Recovery</a></li>
<li><a href="../244035/index.html">Overview of Microsoft Azure platform updates for October-November</a></li>
<li><a href="../244037/index.html">SSL certificates: everyone, everyone, and let no one leave offended</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>