<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Arbitrary order of template initialization list</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think many who work with templates are familiar with the following situation. We have a certain template class with a bunch of template parameters. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Arbitrary order of template initialization list</h1><div class="post__text post__text-html js-mediator-article">  I think many who work with templates are familiar with the following situation.  We have a certain template class with a bunch of template parameters. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deferred</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deadline</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">disable</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Deferred</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">disable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Deadline</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">disable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_container</span></span></span></span></code> </pre> <br>  Let it be some kind of delayed task execution interface (active queue).  And we want to expand its functionality by adding deferred execution and deadlines.  But we do not want all this to be immediately turned on, but we want to be able to assemble the necessary configuration to fit our needs.  The problem with such patterns (which have many parameters and almost all already have a default value) is that in order to redefine, say, the last parameter, we need to specify everything in front of it. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> some_container&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, disable, deadline&gt; deadline_container; &lt;source&gt;    &lt;source lang=cpp&gt; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> some_container&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, deadline&gt; deadline_container;</code> </pre><br>  And even better, that even the order of the task would not matter and the next two would be equivalent 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> some_container&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, deferred, deadline&gt; full_container1; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> some_container&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, deadline, deferred&gt; full_container1;</code> </pre><br>  But we are well aware that as soon as we change two parameters, we will have something completely different than what we expected (this is not a tuple for you where the order indication does not matter) <br>  I think many have already thought that all this can be achieved by adding a layer between our type and the user, for which to write all possible specializations.  If you have only 2 template parameters, then yes, if 3 is already difficult, and if 4, 5 is added, then write is gone.  And, as a rule, the addition of a new parameter leads to the alteration of all previous specializations (since in specialization we cannot increase the number of template parameters, but we can only reduce them). <br>  If you are interested, I ask under the cat, I will show you how to achieve this. <br><a name="habracut"></a><br>  But to start a little bit of tar.  Template types are good because the user can parameterize them with different types, including their own.  The way I want to show does not allow to customize a template with an arbitrary type.  Those.  for example, you define your deadline_super type which is comparable to the deadline type, then you can substitute it in the template specialization <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> some_container&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, disable, deadline_super&gt;</code> </pre><br>  But you can not use this type in the mechanism that will allow to specialize the template in any way.  Perhaps this is the only serious limitation.  Given this aspect, it becomes clear that this mechanism is convenient to use when writing modular components, rather than expandable or polymorphic. <br>  The whole implementation is based on a boost component like <a href="http://www.boost.org/doc/libs/1_55_0b1/libs/mpl/doc/refmanual/set.html">mpl :: set</a> .  I will not talk much about what <a href="http://www.boost.org/doc/libs/1_55_0b1/libs/mpl/doc/refmanual.html">boost :: mpl is</a> , let me just say that mpl :: set allows you to create a container similar to std :: set but at the compilation stage and consisting of types. <br>  The first thing we need is a way to check the type list for the type we need, and issue some default value (struct disable) otherwise <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsSet</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_plugin_impl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_plugin_impl</span></span></span><span class="hljs-class">&lt;Plugin, boost::mpl::false_&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> disable_plugin type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_plugin_impl</span></span></span><span class="hljs-class">&lt;Plugin, boost::mpl::true_&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Plugin type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_plugin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> get_plugin_impl&lt;Plugin, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> boost::mpl::has_key&lt;List, Plugin&gt;::type&gt;::type type; };</code> </pre><br>  This will allow us to find out from the list of types whether the type we need was set and if not, then use the default value.  As you can see, this code depends on only one type that participates in the parameterization of the final structure (and reports that we do not use this particular type), therefore, when adding new template types, this code will not change. <br>  In the next step, we define all types that are used in the final template. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_plugins</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> get_plugin&lt;List, deferred_plugin&gt;::type deferred; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> get_plugin&lt;List, deadline_plugin&gt;::type deadline; };</code> </pre><br>  And this is the place that will change when adding new template parameters.  But this happens extremely easily, and no 2 ^ n combinations should be listed. <br>  Next, we introduce an interlayer between the final template type and the user. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">P1</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">disable_plugin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">P2</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">disable_plugin</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::mpl::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;P1, P2&gt; plugin_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> get_plugins&lt;plugin_list&gt; plugs; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> plugs::deferred deferred; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> plugs::deadline deadline; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> some_container&lt;T, deferred, deadline&gt; type; };</code> </pre><br>  It allows us to abstract from the number and order of indication of template parameters.  In essence, it combines all those (2 ^ n + K) specializations that we would have to write for a different number of specified template parameters and their order. <br><br>  Returning to our template type, I'll show you how it works. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> static_type(name) \ static const std::string&amp; type() \ { \ static std::string type_(name); \ return type_; \ } \ struct deferred_plugin { static_type(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"deferred"</span></span></span><span class="hljs-meta">); }; struct deadline_plugin { static_type(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"deadline"</span></span></span><span class="hljs-meta">); }; struct disable_plugin { static_type(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"disable"</span></span></span><span class="hljs-meta">); }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class T, class Deferred, class Deadline&gt; struct some_container { static const std::string&amp; type() { static std::string type_("some_container&lt;" + Deferred::type() + ", " + Deadline::type() + "&gt;"); return type_; } };</span></span></span></span></code> </pre><br>  Using <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; container&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::type::type() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; container&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, deadline_plugin&gt;::type::type() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; container&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, deferred_plugin&gt;::type::type() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; container&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, deferred_plugin, deadline_plugin&gt;::type::type() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; container&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, deadline_plugin, deferred_plugin&gt;::type::type() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Exhaust <br><br><blockquote>  some_container &lt;disable, disable&gt; <br>  some_container &lt;disable, deadline&gt; <br>  some_container &lt;deferred, disable&gt; <br>  some_container &lt;deferred, deadline&gt; <br>  some_container &lt;deferred, deadline&gt; <br></blockquote><br>  Please note that the order of the specialization is preserved in the desired form, regardless of the order in which the types were specified when instantiating the template. <br><br>  That's all, I hope someone it will help make the code more beautiful and neat. <br>  Source: <a href="https://github.com/cupper/arbitrary_initialization_template">git</a> </div><p>Source: <a href="https://habr.com/ru/post/219999/">https://habr.com/ru/post/219999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../219989/index.html">History of checkers (in illustrations)</a></li>
<li><a href="../219991/index.html">Telepresence Tod Bot - go for coffee without getting up from the table</a></li>
<li><a href="../219993/index.html">Encoding of binary data into a string with an arbitrary length alphabet (BaseN)</a></li>
<li><a href="../219995/index.html">jWidget - object-oriented JavaScript MV * framework</a></li>
<li><a href="../219997/index.html">Serialization of objects in MultiCAD.NET. Management of compatibility of drawings and proxies</a></li>
<li><a href="../220001/index.html">Kenju fork Kendo UI Web (GPL3)</a></li>
<li><a href="../220003/index.html">How browsers implement digital certificate revocation</a></li>
<li><a href="../220005/index.html">Some interesting and useful things for web developer # 16</a></li>
<li><a href="../220007/index.html">Zalman ZM-VE400 Review</a></li>
<li><a href="../220009/index.html">Warm lamp light</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>