<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.js, Express and MongoDB: API in half an hour</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For a novice programmer, the development for Node.js may seem like a real nightmare. This is due to the flexibility of this platform and the lack of c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.js, Express and MongoDB: API in half an hour</h1><div class="post__text post__text-html js-mediator-article">  For a novice programmer, the development for Node.js may seem like a real nightmare.  This is due to the flexibility of this platform and the lack of clear guidelines.  But, in fact, everything is not so scary. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/40c/c61/f5d/40cc61f5d4aa464e9af53a8f1f618a89.jpg"></div><br>  Here, for example, a typical task: development of the REST API, the server part of a certain application.  The abundance of Node's own capabilities and many additional modules that can help in this task, can lead the novice into a dead end, caused by the wealth of choice.  The main issues here are the selection of components and setting up their collaboration. <br><a name="habracut"></a><br>  One way to create the server side of the application is to use a bundle from Node.js, the Express framework, and MongoDB.  In fact, today I will talk about how to create a working API layout that can serve as the basis for almost any application.  Here we implement the main REST routes, we will interact with the API via HTTP and use simple options for working with the database. <br><br>  In order to successfully master this material, you need to understand what the REST API is, have an understanding of CRUD operations, and have a basic knowledge of JavaScript.  Here I am using ES6, nothing particularly complicated, mostly switch functions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We‚Äôll develop a skeleton of the server side of the application for creating notes similar to <a href="http://keep.google.com/">Google Keep</a> .  In this case, you can perform all four CRUD actions with notes, namely, create (create), read (read), update (update), and delete (delete). <br><br><h2>  <font color="#3AC1EF">Preliminary preparation</font> </h2><br>  If you haven't got a Node yet, it's time to <a href="https://howtonode.org/how-to-install-nodejs">install it</a> .  After installation, create a folder and execute the command to initialize a new project: <br><br><pre><code class="hljs swift">npm <span class="hljs-keyword"><span class="hljs-keyword">init</span></span></code> </pre> <br>  During initialization, answer the questions, in particular, give the application the name "notable" (or, if you like, any other). <br><br>  Now the file <i>package.json</i> should appear in the folder.  This means that you can begin to install additional packages on which the project depends. <br><br>  As a framework, we plan to use Express.  The database management system will be MongoDB.  In addition, as an aid to working with JSON, use the package body-parser.  Install all this: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> <span class="hljs-comment"><span class="hljs-comment">--save express mongodb body-parser</span></span></code> </pre> <br>  Also, I highly recommend installing Nodemon as a dev dependency.  This is a simple little package that, when files change, automatically restarts the server. <br><br>  To install this package run the command: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> <span class="hljs-comment"><span class="hljs-comment">--save-dev nodemon</span></span></code> </pre> <br>  You can then add the following script to the <i>package.json</i> file: <br><br><pre> <code class="hljs pgsql">// package.json "scripts": {   "dev": "nodemon server.js" },</code> </pre> <br>  The finished <i>package.json</i> will look something like this: <br><br><pre> <code class="hljs pgsql">// package.json { "name": "notable", "version": "1.0.0", "description": "", "main": "server.js", "scripts": {   "dev": "nodemon server.js" }, "author": "", "license": "ISC", "dependencies": {   "body-parser": "^1.15.2",   "express": "^4.14.0",   "mongodb": "^2.2.16" }, "devDependencies": {   "nodemon": "^1.11.0" } }</code> </pre> <br>  Now create the <i>server.js</i> file and get to work on the API. <br><br><h2>  <font color="#3AC1EF">Server</font> </h2><br>  Let's start with connecting dependencies in the <i>server.js</i> file. <br><br><pre> <code class="hljs perl">// server.js const express        = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); const MongoClient    = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'mongodb'</span></span>).MongoClient; const bodyParser     = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'body-parser'</span></span>); const app            = express();</code> </pre> <br>  MongoClient will be used to interact with the database.  In addition, here we initialize the <code>app</code> constant, symbolizing our application, with an instance of the Express framework.  For the server to work, all that remains is for the application to indicate that it starts listening to HTTP requests. <br><br>  Here we specify the port and start listening as follows: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> server.js const port = <span class="hljs-number"><span class="hljs-number">8000</span></span>; app.listen(port, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'We are live on '</span></span> + port); });</code> </pre> <br>  Now, if you run the <code>npm run dev</code> command (or - <code>node server.js</code> , if you did not install Nodemon), the following message should appear in the terminal: "We are live on port 8000". <br><br>  So the server is working.  But now he does absolutely nothing useful.  Let's deal with this. <br><br><h2>  <font color="#3AC1EF">Routes Oriented to CRUD Operations</font> </h2><br>  We are planning to create 4 routes.  Namely: <br><br><ul><li>  CREATE - create notes. </li><li>  READ - reading notes. </li><li>  UPDATE - update notes. </li><li>  DELETE - delete notes. </li></ul><br>  Having mastered this scheme, you will be able to understand how, with the help of Node, to organize almost any necessary REST route. <br><br>  In order to test the API, you need something that can simulate the requests of the client side of the application.  An excellent program called <a href="https://www.getpostman.com/">Postman</a> will help us to solve this problem.  It allows you to perform simple HTTP requests with the specified body and parameters. <br><br>  Install Postman.  Now everything is ready for setting up routes. <br><br><h2>  <font color="#3AC1EF">About project structure</font> </h2><br>  In most Node.js tutorials (and in many real-world applications), all routes are placed in one large <i>route.js</i> file.  I do not like this approach.  If you decompose files in different folders, it will improve the readability of the code, the application will be easier to manage. <br><br>  Our application cannot be called large, but I suggest that you do everything as it should, considering, nevertheless, its modest scale.  Create the following folders: the <i>app</i> folder, and inside it the <i>routes</i> .  In the <i>routes</i> folder, create the <i>index.js</i> and <i>note_routes.js files</i> .  In other words, the project structure will look like this: <i>root&gt; app&gt; routes&gt; index.js</i> and <i>note_routes.js</i> . <br><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> app <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> app <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> routes <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> routes touch index.js touch note_routes.js</code> </pre> <br>  Such a structure, for a small application, may seem redundant, but it will be very useful in a larger system built on the basis of our example.  In addition, any project is best to start using the best of the existing developments. <br><br><h2>  <font color="#3AC1EF">Creating Notes: CREATE Route</font> </h2><br>  Let's start with the route CREATE.  To do this, we answer the question: "How to create a note?". <br>  Before we start creating notes, we need to expand the application infrastructure.  In Express, routes are wrapped in a function that takes an Express instance and a database as arguments. <br><br>  It may look like this: <br><br><pre> <code class="hljs lua">// routes/note_routes.js module.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(app, db)</span></span></span></span> { };</code> </pre> <br>  Now you can export this function via <i>index.js</i> : <br><br><pre> <code class="hljs lua">// routes/index.js const noteRoutes = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./note_routes'</span></span>); module.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(app, db)</span></span></span></span> { noteRoutes(app, db); // , ,      };</code> </pre> <br>  Importing what happened in <i>server.js</i> : <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> server.js const express        = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); const MongoClient    = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'mongodb'</span></span>).MongoClient; const bodyParser     = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'body-parser'</span></span>); const app            = express(); const port = <span class="hljs-number"><span class="hljs-number">8000</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./app/routes'</span></span>)(app, {}); app.listen(port, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'We are live on '</span></span> + port); });</code> </pre> <br>  Please note that since we have not yet configured the database, an empty object is passed as the second argument. <br><br>  Now create the CREATE route.  The syntax here is pretty simple: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">app, db</span></span></span><span class="hljs-function">) </span></span>{ app.post(<span class="hljs-string"><span class="hljs-string">'/notes'</span></span>, (req, res) =&gt; {   <span class="hljs-comment"><span class="hljs-comment">//    .   res.send('Hello') }); };</span></span></code> </pre> <br>  When an application receives a POST request using the path '/ notes', it will execute the code inside the callback function, passing it the request object (which contains the request parameters or JSON data) and the response object (which is understandably used for the response). <br><br>  What we have already can be tested.  Let's send, with the help of Postman, a POST request to the address <b>localhost: 8000 / notes</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d8/c11/3b7/6d8c113b7d06bfbc24bc41fc3172a7d8.png"><br>  <i><font color="#999999">‚ÄúHello‚Äù should come in response to the request</font></i> <br><br>  Fine.  The first route is created.  The next step is to add parameters to the request, process them in the API, and finally, save the note in the database. <br><br><h2>  <font color="#3AC1EF">Request parameters</font> </h2><br>  In Postman, go to the <b>Body</b> tab and add several key-value pairs by selecting the <b>x-www-form-urlencoded</b> radio button.  Namely, the first key will be the <b>title</b> , its value is <b>My Note Title</b> .  The second key is <b>body</b> , its value is <b>What a great note</b> . <br><br>  This will add encoded data to the request that can be processed by the API. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/168/62f/f01/16862ff0156da71a2e4cf34ac7e2290c.png"><br>  <i><font color="#999999">The title of my note, and she herself is very simple, and here you can show imagination</font></i> <br><br>  In the <i>note_route.js</i> file, just output the body of the note to the console. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> note_routes.js <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = function(app, db) { app.post(<span class="hljs-string"><span class="hljs-string">'/notes'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.body)   res.send(<span class="hljs-string"><span class="hljs-string">'Hello'</span></span>) }); };</code> </pre> <br>  Try sending a request using Postman, and you will see ... <code>undefined</code> . <br><br>  Unfortunately, Express cannot handle URL-encoded forms on its own.  Here we will come to the aid of a previously installed package body-parser. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> server.js const express        = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); const MongoClient    = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'mongodb'</span></span>).MongoClient; const bodyParser     = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'body-parser'</span></span>); const app            = express(); const port = <span class="hljs-number"><span class="hljs-number">8000</span></span>; app.use(bodyParser.urlencoded({ extended: <span class="hljs-literal"><span class="hljs-literal">true</span></span> })); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./app/routes'</span></span>)(app, {}); app.listen(port, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'We are live on '</span></span> + port); });</code> </pre> <br>  Now, after performing the POST request, its body can be seen in the terminal as an object. <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">title</span></span>: <span class="hljs-string"><span class="hljs-string">'My Note Title'</span></span>, body: <span class="hljs-string"><span class="hljs-string">'What a great note.'</span></span> }</code> </pre> <br>  In order for the first route to fully work, it remains only to configure the database and add a note to it. <br><br>  To quickly create and configure a database, we use the <a href="https://mlab.com/">mLab</a> service.  It is easy to work with him, for small amounts of information it is free. <br><br>  Create an account on mLab and deploy the new MongoDB database.  To do this, click on the <b>Create</b> <b>New</b> button in the <b>MongoDB Deployments</b> section, in the appeared window, in the <b>Plan</b> section, select <b>Single-node</b> .  In the <b>Standard Line</b> list, select <b>Sandbox</b> and give the database a name.  Next, in the database management window, go to the <b>Users</b> tab and add a database user, setting a name and password. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ca/a00/7de/6caa007de80aec2f63231427ff05d56b.png"><br>  <i><font color="#999999">New database user</font></i> <br><br>  Copy the second URL from the same page - the database connection string. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/141/336/2b5/1413362b5286919cfeb0448e98b5432c.png"><br>  <i><font color="#999999">URL to connect to the database</font></i> <br><br>  Add the <i>config</i> directory to the project root, create a <i>db.js</i> file in it. <br><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> config <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> config touch db.js</code> </pre> <br>  Add the following to the <i>db.js</i> file: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> = { url :    URL };</code> </pre> <br>  Do not forget to add the username and password to the URL (not the ones from the account in mLab, but those that were created for the database).  If you are posting a project on Github, don't forget to include a <i>.gitignore</i> file (like <a href="https://github.com/scottdomes/notable-node-api-tutorial/blob/master/.gitignore">this</a> ).  So you will not make the public domain the name and password for working with the database. <br><br>  Now, in <i>server.js</i> , you can use MongoClient to connect to the database and wrap it in a function that is passed to it when you create the application settings: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> server.js const express        = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); const MongoClient    = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'mongodb'</span></span>).MongoClient; const bodyParser     = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'body-parser'</span></span>); const db             = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./config/db'</span></span>); const app            = express(); const port = <span class="hljs-number"><span class="hljs-number">8000</span></span>; app.use(bodyParser.urlencoded({ extended: <span class="hljs-literal"><span class="hljs-literal">true</span></span> })); MongoClient.connect(db.url, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, database)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err) <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./app/routes'</span></span>)(app, database); app.listen(port, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'We are live on '</span></span> + port); });              })</code> </pre> <br>  This completes the preparation of the infrastructure.  From now on, we will deal exclusively with the ways. <br><br><h2>  <font color="#3AC1EF">Adding records to the database</font> </h2><br>  MongoDB stores data in collections (collections), which fully justify their name.  In our case, the notes will be stored in a collection, which, as it is easy to guess, will be called <code>notes</code> . <br><br>  During client setup, the database connection string was passed to it, <code>db</code> argument.  In the route code access to the database can be obtained as follows: <br><br><pre> <code class="hljs cs">db.collection(<span class="hljs-string"><span class="hljs-string">'notes'</span></span>)</code> </pre> <br>  Creating a note in the database is equivalent to invoking the <code>insert</code> command for the <code>notes</code> collection: <br><br><pre> <code class="hljs coffeescript">const note = { text: req.body.body, title: req.body.title} db.collection(<span class="hljs-string"><span class="hljs-string">'notes'</span></span>).insert(note, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, results)</span></span></span><span class="hljs-function"> =&gt;</span></span> { }</code> </pre> <br>  After successful completion of the command (or after, for whatever reason, it cannot be executed), you need to either send back the newly created note object, or an error message.  Here is the code <i>note_routes.js</i> , supplemented with these considerations: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> note_routes.js <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = function(app, db) { app.post(<span class="hljs-string"><span class="hljs-string">'/notes'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   const note = { text: req.body.body, title: req.body.title };   db.collection(<span class="hljs-string"><span class="hljs-string">'notes'</span></span>).insert(note, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, result)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {       res.send({ <span class="hljs-string"><span class="hljs-string">'error'</span></span>: <span class="hljs-string"><span class="hljs-string">'An error has occurred'</span></span> });     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       res.send(result.ops[<span class="hljs-number"><span class="hljs-number">0</span></span>]);     }   }); }); };</code> </pre> <br>  Try what happened.  Send a POST request from Postman (with the <b>x-www-form-urlencoded</b> flag), setting the <b>Body and</b> tab values ‚Äã‚Äãon the <b>Body</b> tab. <br><br>  The answer should look something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f6/d3d/e04/2f6d3de0489d855a2448345e5b6ba9a0.png"><br>  <i><font color="#999999">Successful addition of a record to the database</font></i> <br><br>  If you now look at the base, logging in to mLab, you can find the newly created note in it. <br><br><h2>  <font color="#3AC1EF">Reading Notes: READ Route</font> </h2><br>  The infrastructure we have prepared above is suitable for all routes, so now things will go faster. <br><br>  So, we are going to request the newly created note, passing along the path <b>localhost: 8000 / notes / {id notes}</b> .  In our case, the path will look like this: <b>localhost: 8000 / notes / 585182bd42ac5b07a9755ea3</b> . <br><br>  If you do not have the ID of one of the already created notes, you can look into the mLab database and find it there, or create a new note and copy its identifier. <br><br>  Here is how it looks in <i>note_route.js</i> : <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> note_routes.js <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = function(app, db) { app.get(<span class="hljs-string"><span class="hljs-string">'/notes/:id'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   }); app.post(<span class="hljs-string"><span class="hljs-string">'/notes'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   const note = { text: req.body.body, title: req.body.title };   db.collection(<span class="hljs-string"><span class="hljs-string">'notes'</span></span>).insert(note, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, result)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {       res.send({ <span class="hljs-string"><span class="hljs-string">'error'</span></span>: <span class="hljs-string"><span class="hljs-string">'An error has occurred'</span></span> });     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       res.send(result.ops[<span class="hljs-number"><span class="hljs-number">0</span></span>]);     }   }); }); };</code> </pre> <br>  Just as before, we are going to call a certain command for a collection of a database of notes.  Use the <code>findOne</code> method for this. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> note_routes.js <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = function(app, db) { app.get(<span class="hljs-string"><span class="hljs-string">'/notes/:id'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   const details = { <span class="hljs-string"><span class="hljs-string">'_id'</span></span>: &lt;  ID&gt; };   db.collection(<span class="hljs-string"><span class="hljs-string">'notes'</span></span>).findOne(details, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, item)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {       res.send({<span class="hljs-string"><span class="hljs-string">'error'</span></span>:<span class="hljs-string"><span class="hljs-string">'An error has occurred'</span></span>});     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       res.send(item);     }   }); }); app.post(<span class="hljs-string"><span class="hljs-string">'/notes'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   const note = { text: req.body.body, title: req.body.title };   db.collection(<span class="hljs-string"><span class="hljs-string">'notes'</span></span>).insert(note, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, result)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {       res.send({ <span class="hljs-string"><span class="hljs-string">'error'</span></span>: <span class="hljs-string"><span class="hljs-string">'An error has occurred'</span></span> });     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       res.send(result.ops[<span class="hljs-number"><span class="hljs-number">0</span></span>]);     }   }); }); };</code> </pre> <br>  The identifier from the URL parameters can be pulled using the <code>req.params.id</code> construct.  However, if you simply insert a string instead of &lt;&lt; &gt;&gt; from the code above, it will not work. <br><br>  MongoDB requires an ID not as a string, but as a special object.  It is called <b>ObjectID</b> . <br><br>  Here's what, after some minor changes, we did: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> note_routes.js var ObjectID = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'mongodb'</span></span>).ObjectID; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = function(app, db) { app.get(<span class="hljs-string"><span class="hljs-string">'/notes/:id'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   const id = req.params.id;   const details = { <span class="hljs-string"><span class="hljs-string">'_id'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectID(id) };   db.collection(<span class="hljs-string"><span class="hljs-string">'notes'</span></span>).findOne(details, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, item)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {       res.send({<span class="hljs-string"><span class="hljs-string">'error'</span></span>:<span class="hljs-string"><span class="hljs-string">'An error has occurred'</span></span>});     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       res.send(item);     }   }); }); app.post(<span class="hljs-string"><span class="hljs-string">'/notes'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   const note = { text: req.body.body, title: req.body.title };   db.collection(<span class="hljs-string"><span class="hljs-string">'notes'</span></span>).insert(note, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, result)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {       res.send({ <span class="hljs-string"><span class="hljs-string">'error'</span></span>: <span class="hljs-string"><span class="hljs-string">'An error has occurred'</span></span> });     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       res.send(result.ops[<span class="hljs-number"><span class="hljs-number">0</span></span>]);     }   }); }); };</code> </pre> <br>  Test it with one of the identifiers of the notes available in the database.  The answer in Postman should look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a4/99b/476/8a499b47610f1fa969512bb4c1a7a7c3.png"><br>  <i><font color="#999999">Successful request for notes from the database</font></i> <br><br><h2>  <font color="#3AC1EF">Deleting notes: DELETE route</font> </h2><br>  Deleting objects is practically the same thing as searching them in the database.  Only instead of the <code>findOne</code> function <code>findOne</code> use the <code>remove</code> function.  Here is the complete code for the corresponding path.  It highlights what is different from the code of an already existing method that processes a GET request. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> note_routes.js <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... app.<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(<span class="hljs-string"><span class="hljs-string">'/notes/:id'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   const id = req.params.id;   const details = { <span class="hljs-string"><span class="hljs-string">'_id'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectID(id) };   db.collection(<span class="hljs-string"><span class="hljs-string">'notes'</span></span>).remove(details, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, item)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {       res.send({<span class="hljs-string"><span class="hljs-string">'error'</span></span>:<span class="hljs-string"><span class="hljs-string">'An error has occurred'</span></span>});     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       res.send(<span class="hljs-string"><span class="hljs-string">'Note '</span></span> + id + <span class="hljs-string"><span class="hljs-string">' deleted!'</span></span>);     }   }); }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...</code> </pre> <br><h2>  <font color="#3AC1EF">Update notes: route UPDATE</font> </h2><br>  And here is the last route.  Processing a PUT request is essentially a hybrid of READ and CREATE operations.  First you need to find the object, then - update it in accordance with the data received in the request.  Now, if you, while testing the previous code snippet, deleted your only note, create another one. <br><br>  Here is the route code for updating the notes: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> note_routes.js <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... app.put (<span class="hljs-string"><span class="hljs-string">'/notes/:id'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   const id = req.params.id;   const details = { <span class="hljs-string"><span class="hljs-string">'_id'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectID(id) };   const note = { text: req.body.body, title: req.body.title };   db.collection(<span class="hljs-string"><span class="hljs-string">'notes'</span></span>).update(details, note, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, result)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {         res.send({<span class="hljs-string"><span class="hljs-string">'error'</span></span>:<span class="hljs-string"><span class="hljs-string">'An error has occurred'</span></span>});     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         res.send(note);     }   }); }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...</code> </pre> <br>  Now you can edit any note.  Here is what it looks like: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0b/0d8/54f/e0b0d854f7caca35f0a1937c4f200bd0.png"><br>  <i><font color="#999999">Successful update notes</font></i> <br><br>  Pay attention to the lack of our example.  If there is no body or note header in the PUT request, the corresponding fields in the database will simply be cleared. <br><br>  I did not load the example with additional checks.  If you want, you can modify the operation of updating the notes yourself, adding new data to the database only if the request is correct. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  You now have a working Node API that supports four basic CRUD operations.  The server part of the application is able, in response to HTTP client requests, to create notes in the database, find them, delete and edit them. <br><br>  The main purpose of my story is to acquaint everyone with a bunch of Node + Express + MongoDB and with the methodology for developing server applications.  Of course, if today you had your first acquaintance with these tools, in order to get a better understanding, you will need to read the documentation.  However, understanding what is happening will allow you to quickly fill in the gaps in knowledge and begin to work on your own projects, using, as a starting point, the application that we have been working with here. <br><br>  If you have experience with Node.js, Express and MongoDB in real projects, maybe you can advise something useful for beginners?  And if you have just tried all this for the first time, we are waiting for your impressions. </div><p>Source: <a href="https://habr.com/ru/post/321104/">https://habr.com/ru/post/321104/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321094/index.html">Price Games: Strategies and Psychology of the Buyer</a></li>
<li><a href="../321096/index.html">Standard exchange of 1C-Bitrix for BASH: incremental upload of XML files from the import and offers directory</a></li>
<li><a href="../321098/index.html">Agile in small teams - how beautiful it is to break your neck</a></li>
<li><a href="../321100/index.html">DUMP-2017: the new season. We meet on April 14 in Yekaterinburg</a></li>
<li><a href="../321102/index.html">"Clock Signal Component Issue" or again a massive marriage in Cisco devices</a></li>
<li><a href="../321106/index.html">Data Oriented Design in practice</a></li>
<li><a href="../321108/index.html">We start the gas flow rate sensor</a></li>
<li><a href="../321110/index.html">Recursive multiple add IP to lock in the .htaccess file</a></li>
<li><a href="../321112/index.html">Osiris - the new reincarnation of the Locky Trojan</a></li>
<li><a href="../321114/index.html">The deadline of the Stepik Contest contest is extended until March 31, it's time to create IT tasks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>