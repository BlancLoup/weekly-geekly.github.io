<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Balanced B-tree Search Tree (t = 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction and formulation of the problem 
 In the 3rd year of study at my university, I was faced with the task of implementing a B-tree containing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Balanced B-tree Search Tree (t = 2)</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction and formulation of the problem </h2><br>  In the 3rd year of study at my university, I was faced with the task of implementing a B-tree containing unique keys, ordered in ascending order (with degree t = 2) in c ++ (with the ability to add, delete, search for elements and, accordingly, rebuild the tree) . <br><br>  Having re-read several articles on <a href="http://habrahabr.ru/">Habr√©</a> (for example, <a href="https://habrahabr.ru/post/114154/">B-tree</a> , <a href="https://habrahabr.ru/post/303374/">2-3-tree. Naive implementation</a> and others), it would seem, everything was clear.  Only theoretically, not practically.  But I managed to cope with these difficulties.  The purpose of my post is to share my experience with users. <br><a name="habracut"></a><br><h2>  Few highlights </h2><br>  A b-tree is a tree that satisfies the following properties: <br>  1. Each node contains at least one key.  The root contains from 1 to 2t-1 keys.  Any other node contains from t-1 to 2t-1 keys.  Leaves are no exception to this rule.  Here t is a tree parameter, not less than 2. <br>  2. The leaves have no descendants.  Any other node containing n keys contains n + 1 descendants.  Wherein: <br>  a) The first descendant and all its descendants contain keys from the interval <img src="https://habrastorage.org/getpro/habr/post_images/084/fc2/8c3/084fc28c3ee7d41f0cfee7191f6e4423.svg" alt="image">  ; <br>  b) For <img src="https://habrastorage.org/getpro/habr/post_images/4f6/f8b/5da/4f6f8b5da2ca56d28371bba348e7fd95.svg" alt="image">  , i-th child and all its descendants contain keys from the interval <img src="https://habrastorage.org/getpro/habr/post_images/197/bdc/84a/197bdc84a958ea1942abce87c5f5fa37.svg" alt="image">  ; <br>  c) (n + 1) -th descendant and all its descendants contain keys from the interval <img src="https://habrastorage.org/getpro/habr/post_images/9b9/75f/39b/9b975f39be80837350bd71e5cd21ff46.svg" alt="image">  . <br>  3. The depth of all leaves is the same. <br><br><h2>  Implementation </h2><br>  To begin, create a node structure of our tree. <br><div class="spoiler">  <b class="spoiler_title">Node structure</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t=<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BNode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> keys[<span class="hljs-number"><span class="hljs-number">2</span></span>*t]; BNode *children[<span class="hljs-number"><span class="hljs-number">2</span></span>*t+<span class="hljs-number"><span class="hljs-number">1</span></span>]; BNode *parent; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; <span class="hljs-comment"><span class="hljs-comment">//  int countSons; //  bool leaf; };</span></span></code> </pre> <br></div></div><br>  Now create a class Tree, which includes the appropriate methods. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Class tree</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: BNode *root; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert_to_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, BNode *node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BNode *node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BNode *node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deletenode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BNode *node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, BNode *node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, BNode *node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFromNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, BNode *node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeLeaf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, BNode *node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lconnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BNode *node, BNode *othernode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rconnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BNode *node, BNode *othernode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">repair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BNode *node)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Tree(); ~Tree(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span></span>; };</code> </pre> </div></div><br>  Immediately describe the constructor and destructor.  The destructor calls the recursive method of removing elements from the tree. <br><br><div class="spoiler">  <b class="spoiler_title">Constructor and destructor</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Tree::Tree() { root=<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } Tree::~Tree(){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(root!=<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) deletenode(root); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Tree::deletenode(BNode *node){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node!=<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;=(<span class="hljs-number"><span class="hljs-number">2</span></span>*t<span class="hljs-number"><span class="hljs-number">-1</span></span>); i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;children[i]!=<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) deletenode(node-&gt;children[i]); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(node); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } }</code> </pre> </div></div><br>  First of all, consider <b>adding a</b> key to a node.  In my case (t = 2) it will look like this: <br><img src="https://habrastorage.org/web/61b/f5f/adf/61bf5fadfe0b4ebcba52bff58686310f.png" alt="image"><br>  That is, as soon as there are more than 3 elements in a node, the node is broken. <br>  So, to add an element to the tree, you must implement several methods. <br>  The first is a simple addition to the node.  In this method, the sorting method is called, which is necessary to fulfill the condition about increasing values ‚Äã‚Äãof the tree.  The second method is <br>  adding a value to the node in which the desired position is preliminarily searched and <br>  of necessity (in the node becomes more than 3 elements) the third method is called - the method of splitting the node into: parent and two sons. <br><br>  The first method is the simple add method. <br><div class="spoiler">  <b class="spoiler_title">Simple add method</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Tree::insert_to_node(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> key, BNode *node){ node-&gt;keys[node-&gt;count]=key; node-&gt;count=node-&gt;count+<span class="hljs-number"><span class="hljs-number">1</span></span>; sort(node); }</code> </pre> </div></div><br>  <b>The method of sorting</b> numbers in the node: <br><br><div class="spoiler">  <b class="spoiler_title">Sorting method</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Tree::sort(BNode *node) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;(<span class="hljs-number"><span class="hljs-number">2</span></span>*t<span class="hljs-number"><span class="hljs-number">-1</span></span>); i++){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j&lt;=(<span class="hljs-number"><span class="hljs-number">2</span></span>*t<span class="hljs-number"><span class="hljs-number">-1</span></span>); j++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((node-&gt;keys[i]!=<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (node-&gt;keys[j]!=<span class="hljs-number"><span class="hljs-number">0</span></span>)){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((node-&gt;keys[i]) &gt; (node-&gt;keys[j])){ m=node-&gt;keys[i]; node-&gt;keys[i]=node-&gt;keys[j]; node-&gt;keys[j]=m; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre> </div></div><br>  I think everything is clear. <br><br>  The second method is a method of adding a value to a node with a preliminary position search: <br><br><div class="spoiler">  <b class="spoiler_title">The method of adding to the node with a preliminary search</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Tree::insert(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> key){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root==<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { BNode *newRoot = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BNode; newRoot-&gt;keys[<span class="hljs-number"><span class="hljs-number">0</span></span>]=key; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">1</span></span>; j&lt;=(<span class="hljs-number"><span class="hljs-number">2</span></span>*t<span class="hljs-number"><span class="hljs-number">-1</span></span>); j++) newRoot-&gt;keys[j]=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;=(<span class="hljs-number"><span class="hljs-number">2</span></span>*t); i++) newRoot-&gt;children[i]=<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; newRoot-&gt;count=<span class="hljs-number"><span class="hljs-number">1</span></span>; newRoot-&gt;countSons=<span class="hljs-number"><span class="hljs-number">0</span></span>; newRoot-&gt;leaf=<span class="hljs-literal"><span class="hljs-literal">true</span></span>; newRoot-&gt;parent=<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; root=newRoot; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { BNode *ptr=root; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ptr-&gt;leaf==<span class="hljs-literal"><span class="hljs-literal">false</span></span>){ <span class="hljs-comment"><span class="hljs-comment">//    ,       for (int i=0; i&lt;=(2*t-1); i++){ //   if (ptr-&gt;keys[i]!=0) { if (key&lt;ptr-&gt;keys[i]) { ptr=ptr-&gt;children[i]; break; } if ((ptr-&gt;keys[i+1]==0)&amp;&amp;(key&gt;ptr-&gt;keys[i])) { ptr=ptr-&gt;children[i+1]; //    ,    "" break; } } else break; } } insert_to_node(key, ptr); while (ptr-&gt;count==2*t){ if (ptr==root){ restruct(ptr); break; } else { restruct(ptr); ptr=ptr-&gt;parent; } } } }</span></span></code> </pre> </div></div><br>  The third method is <b>the node splitting method</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Node splitting method</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Tree::restruct(BNode *node){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;count&lt;(<span class="hljs-number"><span class="hljs-number">2</span></span>*t<span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  BNode *child1 = new BNode; int j; for (j=0; j&lt;=t-2; j++) child1-&gt;keys[j]=node-&gt;keys[j]; for (j=t-1; j&lt;=(2*t-1); j++) child1-&gt;keys[j]=0; child1-&gt;count=t-1; //    if(node-&gt;countSons!=0){ for (int i=0; i&lt;=(t-1); i++){ child1-&gt;children[i]=node-&gt;children[i]; child1-&gt;children[i]-&gt;parent=child1; } for (int i=t; i&lt;=(2*t); i++) child1-&gt;children[i]=nullptr; child1-&gt;leaf=false; child1-&gt;countSons=t-1; //  } else { child1-&gt;leaf=true; child1-&gt;countSons=0; for (int i=0; i&lt;=(2*t); i++) child1-&gt;children[i]=nullptr; } //  BNode *child2 = new BNode; for (int j=0; j&lt;=(t-1); j++) child2-&gt;keys[j]=node-&gt;keys[j+t]; for (j=t; j&lt;=(2*t-1); j++) child2-&gt;keys[j]=0; child2-&gt;count=t; //    if(node-&gt;countSons!=0) { for (int i=0; i&lt;=(t); i++){ child2-&gt;children[i]=node-&gt;children[i+t]; child2-&gt;children[i]-&gt;parent=child2; } for (int i=t+1; i&lt;=(2*t); i++) child2-&gt;children[i]=nullptr; child2-&gt;leaf=false; child2-&gt;countSons=t; //  } else { child2-&gt;leaf=true; child2-&gt;countSons=0; for (int i=0; i&lt;=(2*t); i++) child2-&gt;children[i]=nullptr; } // if (node-&gt;parent==nullptr){ //  ,    node-&gt;keys[0]=node-&gt;keys[t-1]; for(int j=1; j&lt;=(2*t-1); j++) node-&gt;keys[j]=0; node-&gt;children[0]=child1; node-&gt;children[1]=child2; for(int i=2; i&lt;=(2*t); i++) node-&gt;children[i]=nullptr; node-&gt;parent=nullptr; node-&gt;leaf=false; node-&gt;count=1; node-&gt;countSons=2; child1-&gt;parent=node; child2-&gt;parent=node; } else { insert_to_node(node-&gt;keys[t-1], node-&gt;parent); for (int i=0; i&lt;=(2*t); i++){ if (node-&gt;parent-&gt;children[i]==node) node-&gt;parent-&gt;children[i]=nullptr; } for (int i=0; i&lt;=(2*t); i++){ if (node-&gt;parent-&gt;children[i]==nullptr) { for (int j=(2*t); j&gt;(i+1); j--) node-&gt;parent-&gt;children[j]=node-&gt;parent-&gt;children[j-1]; node-&gt;parent-&gt;children[i+1]=child2; node-&gt;parent-&gt;children[i]=child1; break; } } child1-&gt;parent=node-&gt;parent; child2-&gt;parent=node-&gt;parent; node-&gt;parent-&gt;leaf=false; delete node; } }</span></span></code> </pre> </div></div><br>  The following methods were implemented for the <b>search</b> , returning true or false (the second method is recursive): <br><br><div class="spoiler">  <b class="spoiler_title">Search</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Tree::search(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> key){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> searchKey(key, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;root); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Tree::searchKey(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> key, BNode *node){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node!=<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;leaf==<span class="hljs-literal"><span class="hljs-literal">false</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;=(<span class="hljs-number"><span class="hljs-number">2</span></span>*t<span class="hljs-number"><span class="hljs-number">-1</span></span>); i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;keys[i]!=<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(key==node-&gt;keys[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((key&lt;node-&gt;keys[i])){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> searchKey(key, node-&gt;children[i]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> searchKey(key, node-&gt;children[i]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;=(<span class="hljs-number"><span class="hljs-number">2</span></span>*t<span class="hljs-number"><span class="hljs-number">-1</span></span>); j++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key==node-&gt;keys[j]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> </div></div><br>  The implementation of the <b>method of removing a</b> key from a node was the most difficult.  Indeed, in some cases, deletions need to glue adjacent nodes, and in some take values ‚Äã‚Äãfrom the nodes of the "brothers".  For example: <br><br><img src="https://habrastorage.org/web/866/156/d9d/866156d9d68c46e58f1a3475852d0da3.png" alt="image"><br><br>  Removal is a few cases.  The first one is a simple method of removing a key from a node: <br><br><div class="spoiler">  <b class="spoiler_title">Method of deleting a key from a node</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Tree::removeFromNode(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> key, BNode *node){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;node-&gt;count; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;keys[i]==key){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=i; j&lt;node-&gt;count; j++) { node-&gt;keys[j]=node-&gt;keys[j+<span class="hljs-number"><span class="hljs-number">1</span></span>]; node-&gt;children[j]=node-&gt;children[j+<span class="hljs-number"><span class="hljs-number">1</span></span>]; } node-&gt;keys[node-&gt;count<span class="hljs-number"><span class="hljs-number">-1</span></span>]=<span class="hljs-number"><span class="hljs-number">0</span></span>; node-&gt;children[node-&gt;count<span class="hljs-number"><span class="hljs-number">-1</span></span>]=node-&gt;children[node-&gt;count]; node-&gt;children[node-&gt;count]=<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } node-&gt;count--; }</code> </pre> </div></div><br>  In the second case, after removing the key, it is necessary to connect the neighboring nodes.  Therefore, the second and third methods are <b>methods of connecting nodes</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Methods of connecting nodes</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Tree::lconnect(BNode *node, BNode *othernode){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node==<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;=(othernode-&gt;count<span class="hljs-number"><span class="hljs-number">-1</span></span>); i++){ node-&gt;keys[node-&gt;count]=othernode-&gt;keys[i]; node-&gt;children[node-&gt;count]=othernode-&gt;children[i]; node-&gt;count=node-&gt;count+<span class="hljs-number"><span class="hljs-number">1</span></span>; } node-&gt;children[node-&gt;count]=othernode-&gt;children[othernode-&gt;count]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;=node-&gt;count; j++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;children[j]==<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; node-&gt;children[j]-&gt;parent=node; } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> othernode; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Tree::rconnect(BNode *node, BNode *othernode){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node==<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;=(othernode-&gt;count<span class="hljs-number"><span class="hljs-number">-1</span></span>); i++){ node-&gt;keys[node-&gt;count]=othernode-&gt;keys[i]; node-&gt;children[node-&gt;count+<span class="hljs-number"><span class="hljs-number">1</span></span>]=othernode-&gt;children[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]; node-&gt;count=node-&gt;count+<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;=node-&gt;count; j++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;children[j]==<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; node-&gt;children[j]-&gt;parent=node; } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> othernode; }</code> </pre> </div></div><br>  The fourth method is <b>the node repair method</b> .  In this method, the tree is literally rebuilt until all the conditions of the B-tree are satisfied: <br><br><div class="spoiler">  <b class="spoiler_title">Method of "repair" node</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Tree::repair(BNode *node){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((node==root)&amp;&amp;(node-&gt;count==<span class="hljs-number"><span class="hljs-number">0</span></span>)){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root-&gt;children[<span class="hljs-number"><span class="hljs-number">0</span></span>]!=<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>){ root-&gt;children[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;parent=<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; root=root-&gt;children[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> root; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } BNode *ptr=node; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k2; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> positionSon; BNode *parent=ptr-&gt;parent; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;=parent-&gt;count; j++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parent-&gt;children[j]==ptr){ positionSon=j; <span class="hljs-comment"><span class="hljs-comment">//      break; } } // ptr-  ( ) if (positionSon==0){ insert_to_node(parent-&gt;keys[positionSon], ptr); lconnect(ptr, parent-&gt;children[positionSon+1]); parent-&gt;children[positionSon+1]=ptr; parent-&gt;children[positionSon]=nullptr; removeFromNode(parent-&gt;keys[positionSon], parent); if(ptr-&gt;count==2*t){ while (ptr-&gt;count==2*t){ if (ptr==root){ restruct(ptr); break; } else { restruct(ptr); ptr=ptr-&gt;parent; } } } else if (parent-&gt;count&lt;=(t-2)) repair(parent); } else { // ptr-  ( ) if (positionSon==parent-&gt;count){ insert_to_node(parent-&gt;keys[positionSon-1], parent-&gt;children[positionSon-1]); lconnect(parent-&gt;children[positionSon-1], ptr); parent-&gt;children[positionSon]=parent-&gt;children[positionSon-1]; parent-&gt;children[positionSon-1]=nullptr; removeFromNode(parent-&gt;keys[positionSon-1], parent); BNode *temp=parent-&gt;children[positionSon]; if(ptr-&gt;count==2*t){ while (temp-&gt;count==2*t){ if (temp==root){ restruct(temp); break; } else { restruct(temp); temp=temp-&gt;parent; } } } else if (parent-&gt;count&lt;=(t-2)) repair(parent); } else { // ptr      insert_to_node(parent-&gt;keys[positionSon], ptr); lconnect(ptr, parent-&gt;children[positionSon+1]); parent-&gt;children[positionSon+1]=ptr; parent-&gt;children[positionSon]=nullptr; removeFromNode(parent-&gt;keys[positionSon], parent); if(ptr-&gt;count==2*t){ while (ptr-&gt;count==2*t){ if (ptr==root){ restruct(ptr); break; } else { restruct(ptr); ptr=ptr-&gt;parent; } } } else if (parent-&gt;count&lt;=(t-2)) repair(parent); } } }</span></span></code> </pre> </div></div><br>  The fifth method is the method of removing a key from a <u>sheet</u> : <br><br><div class="spoiler">  <b class="spoiler_title">The method of removing the key from the sheet</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Tree::removeLeaf(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> key, BNode *node){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((node==root)&amp;&amp;(node-&gt;count==<span class="hljs-number"><span class="hljs-number">1</span></span>)){ removeFromNode(key, node); root-&gt;children[<span class="hljs-number"><span class="hljs-number">0</span></span>]=<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> root; root=<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node==root) { removeFromNode(key, node); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;count&gt;(t<span class="hljs-number"><span class="hljs-number">-1</span></span>)) { removeFromNode(key, node); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } BNode *ptr=node; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k2; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> positionSon; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;=node-&gt;count<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key==node-&gt;keys[i]) { position=i; <span class="hljs-comment"><span class="hljs-comment">//    break; } } BNode *parent=ptr-&gt;parent; for (int j=0; j&lt;=parent-&gt;count; j++){ if (parent-&gt;children[j]==ptr){ positionSon=j; //      break; } } // ptr-  ( ) if (positionSon==0){ if (parent-&gt;children[positionSon+1]-&gt;count&gt;(t-1)){ //    ,  t-1  k1=parent-&gt;children[positionSon+1]-&gt;keys[0]; //k1 -     k2=parent-&gt;keys[positionSon]; //k2 -  , ,  ,  ,  k1 insert_to_node(k2, ptr); removeFromNode(key, ptr); parent-&gt;keys[positionSon]=k1; //  k1  k2 removeFromNode(k1, parent-&gt;children[positionSon+1]); // k1    } else { //   &lt;u&gt;&lt;/u&gt;    t-1  removeFromNode(key, ptr); if (ptr-&gt;count&lt;=(t-2)) repair(ptr); } } else { // ptr-  ( ) if (positionSon==parent-&gt;count){ //    ,  t-1  if (parent-&gt;children[positionSon-1]-&gt;count&gt;(t-1)){ BNode *temp=parent-&gt;children[positionSon-1]; k1=temp-&gt;keys[temp-&gt;count-1]; //k1 -     k2=parent-&gt;keys[positionSon-1]; //k2 -  , ,    ,  k1 insert_to_node(k2, ptr); removeFromNode(key, ptr); parent-&gt;keys[positionSon-1]=k1; removeFromNode(k1, temp); } else { //  &lt;u&gt;&lt;/u&gt;     t-1  removeFromNode(key, ptr); if (ptr-&gt;count&lt;=(t-2)) repair(ptr); } } else { // ptr      //    ,  t-1  if (parent-&gt;children[positionSon+1]-&gt;count&gt;(t-1)){ k1=parent-&gt;children[positionSon+1]-&gt;keys[0]; //k1 -     k2=parent-&gt;keys[positionSon]; //k2 -  , ,    ,  k1 insert_to_node(k2, ptr); removeFromNode(key, ptr); parent-&gt;keys[positionSon]=k1; //  k1  k2 removeFromNode(k1, parent-&gt;children[positionSon+1]); // k1    } else { //    ,  t-1  if (parent-&gt;children[positionSon-1]-&gt;count&gt;(t-1)){ BNode *temp=parent-&gt;children[positionSon-1]; k1=temp-&gt;keys[temp-&gt;count-1]; //k1 -     k2=parent-&gt;keys[positionSon-1]; //k2 -  , ,    ,  k1 insert_to_node(k2, ptr); removeFromNode(key, ptr); parent-&gt;keys[positionSon-1]=k1; removeFromNode(k1, temp); } else { //      t-1  removeFromNode(key, ptr); if (ptr-&gt;count&lt;=(t-2)) repair(ptr); } } } } }</span></span></code> </pre> </div></div><br>  The sixth method is the <b>method of deletion from an arbitrary node</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Method to remove from an arbitrary node</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Tree::remove(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> key, BNode *node){ BNode *ptr=node; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position; <span class="hljs-comment"><span class="hljs-comment">//  int i; for (int i=0; i&lt;=node-&gt;count-1; i++){ if (key==node-&gt;keys[i]) { position=i; break; } } int positionSon; //      if (ptr-&gt;parent!=nullptr){ for(int i=0; i&lt;=ptr-&gt;parent-&gt;count; i++){ if (ptr-&gt;children[i]==ptr){ positionSon==i; break; } } } //     ptr=ptr-&gt;children[position+1]; int newkey=ptr-&gt;keys[0]; while (ptr-&gt;leaf==false) ptr=ptr-&gt;children[0]; //       1 -       // -   key   ,      if (ptr-&gt;count&gt;(t-1)) { newkey=ptr-&gt;keys[0]; removeFromNode(newkey, ptr); node-&gt;keys[position]=newkey; } else { ptr=node; //      ptr=ptr-&gt;children[position]; newkey=ptr-&gt;keys[ptr-&gt;count-1]; while (ptr-&gt;leaf==false) ptr=ptr-&gt;children[ptr-&gt;count]; newkey=ptr-&gt;keys[ptr-&gt;count-1]; node-&gt;keys[position]=newkey; if (ptr-&gt;count&gt;(t-1)) removeFromNode(newkey, ptr); else { //   ,  t-1 -  removeLeaf(newkey, ptr); } } }</span></span></code> </pre> </div></div><br>  And the seventh method - the <b>deletion method</b> itself, which accepts as input data the value of the key to be removed from the tree. <br><br><div class="spoiler">  <b class="spoiler_title">Main removal method</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Tree::remove(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> key){ BNode *ptr=<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;root; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> positionSon; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchKey(key, ptr)==<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,       for (i=0; i&lt;=ptr-&gt;count-1; i++){ if (ptr-&gt;keys[i]!=0) { if(key==ptr-&gt;keys[i]) { position=i; break; } else { if ((key&lt;ptr-&gt;keys[i])){ ptr=ptr-&gt;children[i]; positionSon=i; i=-1; } else { if (i==(ptr-&gt;count-1)) { ptr=ptr-&gt;children[i+1]; positionSon=i+1; i=-1; } } } } else break; } } if (ptr-&gt;leaf==true) { if (ptr-&gt;count&gt;(t-1)) removeFromNode(key,ptr); else removeLeaf(key, ptr); } else remove(key, ptr); }</span></span></code> </pre> </div></div><br>  Something like that.  I hope someone article will be useful.  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/337594/">https://habr.com/ru/post/337594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337580/index.html">The task of rewarding: feel like a manager</a></li>
<li><a href="../337582/index.html">Validating React Components with Livr.js</a></li>
<li><a href="../337584/index.html">India adopted a law on "turning off" the Internet</a></li>
<li><a href="../337586/index.html">The digest of interesting materials for the mobile developer # 220 (September 4 - September 10)</a></li>
<li><a href="../337590/index.html">Esoteric language translated into C ++ templates</a></li>
<li><a href="../337596/index.html">Jack and Android or the Tale of Earth and Sky</a></li>
<li><a href="../337598/index.html">ggplot2: how to easily combine multiple graphs in one, part 2</a></li>
<li><a href="../337602/index.html">Work and life in Bulgaria. Part two</a></li>
<li><a href="../337604/index.html">Spring: Your Next Java Microfilm</a></li>
<li><a href="../337606/index.html">Count to three: four</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>