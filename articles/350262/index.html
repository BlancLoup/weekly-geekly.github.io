<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Native or not? 4 myths about cross-platform development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Smartphones continue to win more and more space under the sun, not only as a tool for consuming photos of cats, but also as a working tool. Therefore,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Native or not? 4 myths about cross-platform development</h1><div class="post__text post__text-html js-mediator-article">  Smartphones continue to win more and more space under the sun, not only as a tool for consuming photos of cats, but also as a working tool.  Therefore, the demand for mobile development is growing.  It is considered that Tru and Cool are Objective-C / Swift for iOS and Java / Kotlin for Android.  There is no question, tru and cool, but there are a large number of real-world scenarios in which the use of cross-platform frameworks is more preferable in comparison with native tools.  More under the cut! <br><br><img src="https://habrastorage.org/webt/rq/ec/qh/rqecqheqgrnug5wy_vgdalb_ak4.jpeg"><a name="habracut"></a><br><br>  <i>Note: we continue the series of publications of the full versions of articles from the magazine Hacker.</i>  <i>Spelling and punctuation of the author saved.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I give the word to the author. <br><br>  Some developers expect from the cross-platform frameworks to solve all their life problems, while others perceive them with hostility.  In both "warring camps" there are misconceptions caused by a lack of understanding of how and what works.  This adds fuel to the fire, because instead of technical arguments in the course are emotions. <br><br>  Also among developers, especially beginners, there are many myths about cross-platform mobile frameworks.  In our article we will analyze the most popular ones.  But first, let's look at mobile development through the eyes of a business that gives money to the whole IT blackjack. <br><br><h2>  Why do we need cross-platform tools? </h2><br>  Historically, there has always been competition in the computer market, and each manufacturer provided an optimal set of so-called native (native) tools for developing applications for their operating systems and devices. <br><br>  <b>Native tools = provided by the owner of the ecosystem.</b> <br><br>  All other signs of ‚Äúnativeness‚Äù are SECONDARY - the behavior and interface of applications, access to OS capabilities, performance, and so on. <br><br>  Moreover, it almost always turned out that native tools are incompatible with each other not only at the level of development languages, agreements and architectures adopted, but also at the level of operating systems and libraries.  As a result, to implement the same algorithms and interfaces, it was required to write an application for several environments in different programming languages, and then support it on the basis of ‚Äúone team per platform‚Äù.  At the same time, the capabilities and appearance of applications on different platforms are almost always 90% identical.  Compare for the sake of interest the implementation of your favorite programs for iOS and Android. <br><br>  The second important point is the availability of the necessary knowledge and experience within the team: if they are not there, then it will take time to learn. <br><br>  In order to solve both of these problems, cross-platform development tools (not only mobile) have appeared on the market for a long time, offering: <br><br>  - maximize the common code base in a single programming language to make the product easier to develop and maintain; <br>  - use existing competencies and specialists to implement applications on new platforms. <br><br>  Since there are a lot of programming languages ‚Äã‚Äã(and environments) now (and specialists who speak these languages), there are a fair amount of tools for cross-platform development.  As an example, we will focus on the popular in our area <b>PhoneGap, Xamarin, React Native and Q</b> t. <br><br><img src="https://habrastorage.org/webt/h3/lb/hv/h3lbhvdu72lyohyp1_78rmojgou.png"><br><br>  Now you can talk about myths. <br><br><h2>  Myth 1. Magic </h2><br>  The most frequent myth disturbing the minds of beginning developers is associated with the belief in supersonic algorithms (and the superprogrammers who created them), which magically transform cross-platform applications into native ones.  Something in the spirit of "converting JavaScript code into Swift and further compiling already Swift applications."  This myth is also fueled by the developers of cross-platform tools, promising the creation of ‚Äúnative applications‚Äù.  And it‚Äôs not that someone is cunning here, but a rich imagination and lack of understanding of the basic mechanisms sometimes lead the developers to think about shamanistic techniques. <br><br>  The main principle underlying cross-platform solutions is to divide the code into two parts: <br><br><ul><li>  <b>cross-platform</b> , living in a virtual environment and having limited access to the capabilities of the target platform through a special bridge; </li><li>  <b>native</b> , which provides application initialization, management of the life cycle of key objects and has full access to system APIs. </li></ul><br><img src="https://habrastorage.org/webt/-a/bt/ya/-abtyawxqjyzf6ncn9sqt6en2mg.png"><br><br>  In order to connect the ‚Äúnative‚Äù world and the ‚Äúcross-platform‚Äù world, it is necessary to use a special bridge **, it defines the possibilities and limitations of cross-platform frameworks. <br><br>  When using bridge, performance is always reduced by converting data between ‚Äúworlds‚Äù, as well as converting API calls and libraries. <br><br>  So, all cross-platform applications must have a native part, otherwise the operating system simply can not run them.  So let's take a closer look at what system APIs and mechanisms are provided by iOS, Android and Windows themselves.  Moving on to the next myth. <br><br><h2>  Myth 2. Native! </h2><br>  So, we have a cross-platform part of the application that lives in a virtual environment and interacts with the operating system through the framework infrastructure and the bridge. <br><br>  All operating systems: iOS, Android and Windows UWP - provide access to the following subsystems (sets of system APIs): <br><br><ul><li>  WebView (the web browser built into the application) is used in PhoneGap-based hybrid applications and is actually the local web site execution environment; </li><li>  JavaScript engines are used in React Native and its counterparts to quickly execute JS code and exchange data between Native and JS; </li><li>  OpenGL ES (or DirectX) is used in game engines and Qt / QML or equivalent applications for drawing the interface; </li><li>  The UI subsystem is responsible for the native user interface of the application, which is important for React Native and Xamarin. </li></ul><br><img src="https://habrastorage.org/webt/dg/v8/hn/dgv8hnkfkoqc6cpcpwdtwutoz0y.png"><br><br>  Cross-platform applications have a native part and the same full access to system APIs as native applications.  The difference is that the call to the system method goes across the bridge and the framework infrastructure: <br><br>  <b>WebView</b> - the application lives in its web browser by analogy with a one-page website.  No access to native controls (buttons, lists, etc.), all based on HTML / CSS / JavaScript.  On the other hand, a web developer will feel like a fish in water. <br><br>  <b>JavaScript engines</b> have become popular relatively recently, since in iOS, a similar mechanism was added only in version 7.0.  Of the features it is worth considering the need for serialization in JSON of complex data structures that are transferred between the JavaScript and Native environments.  If we briefly describe a similar class of solutions, then the JavaScript environment executes the JS code that controls the native application. <br><br>  <b>OpenGL ES and DirectX</b> are low-level subsystems and are used to draw the user interface in games and, for example, Qt / QML.  That is, when using OpenGL / DirectX, developers themselves draw controls and animations that can only be similar to native ones.  On the other hand, it is a low-level subsystem with very high performance, so it is used in cross-platform game engines. <br><br>  All cross-platform applications have a native part, and therefore potentially the same full access to the system APIs as the ‚Äúnative‚Äù ones.  Also, cross-platform applications are assembled and packaged with ‚Äúnative‚Äù tools in ‚Äúnative‚Äù installation packages.  The key question is how the interaction between the cross-platform part and the native part is organized.  For example, inside WebView or using Open GL ES / DirectX there is no possibility to create a user interface with fully native look'n'feel, but at the same time there is full access to GPS, Push notifications and other functionality.  And the JavaScript or C # code is quite free to control the native application and its behavior, providing a fully native look'n'feel. <br><br>  If to summarize, then yes, it is ‚Äúnon-native‚Äù from the point of view of the development tools used (not from Apple, Google).  But an application can be completely native in terms of accessing system APIs and provide a fully native look and feel.  And we are moving to the next myth. <br><br><h2>  Myth 3. Crutch on a crutch </h2><br>  It should be understood here that native APIs are not considered crutches by default (although there are different opinions here as well), therefore all indignation is directed to the cross-platform part.  Obviously, the execution environment (for example, WebView, JavaScript-engine or Mono) is also difficult to call a crutch - adult mature solutions with a long history. <br><br>  It seems that the crutch is called the way the cross-platform part integrates with the native.  To better understand how various frameworks work, we will use PhoneGap, Xamarin, Qt and React Native as examples of the operating system mechanisms used to link cross-platform and native parts. <br><br>  We start with PhoneGap.  Below is the top-level architecture of the application based on this framework. <br><br><img src="https://habrastorage.org/webt/59/e3/3c/59e33c535c696123750485.png"><br><br>  The application on PhoneGap is in fact a native application that displays WebView as the only UI control.  It is through him that the interaction with the native part takes place.  All standard WebView in iOS, Android and Windows UWP support the ability to add their own native handlers for JS properties and methods.  At the same time, the JS code lives in its isolated environment and does not know anything about the native part ‚Äî it simply jerks the necessary JS methods or changes the necessary JS properties.  Everything is inside the standard Web DOM, to which new elements are simply added that are associated with the native implementation. <br><br>  Next, consider React Native. <br><br><img src="https://habrastorage.org/webt/59/e3/3c/59e33c538860d110131276.png"><br><br>  When creating applications on React Native, the developer will almost always need to implement the native part in Objective-C, Java or C #, and the management of the native application will come from JavaScript.  In fact, the JavaScript engine is a WebView element that is available separately.  The interaction goes through the same JS-bridge, as is the case with PhoneGap.  However, in React Native, the JS code controls not the Web DOM tree, but the native application. <br><br>  It is necessary to take into account that due to the limitations of iOS (there is no possibility to implement JIT), JavaScript code is interpreted on the fly and not compiled.  In general, this does not really affect performance in real applications, but it‚Äôs worth remembering. <br><br>  Now consider the classic Xamarin.iOS and Xamarin.Android, since Xamarin.Forms (supporting Windows UWP) is an add-on to them. <br><br><img src="https://habrastorage.org/webt/59/e3/4a/59e34aa75e4f9001952495.png"><br><br>  Xamarin uses the Mono library to interact with the target operating system, which allows you to invoke native code using the [P / Invoke] mechanism (https://en.wikipedia.org/wiki/Platform_Invocation_Services).  It is also used to communicate with native APIs in iOS / Android.  That is, C # wrappers are created for all public native API methods, which, in turn, call system APIs.  Thus, from the Xamarin application, you can access all system APIs. <br><br>  And finally, consider Qt, since there are a lot of questions about it from experienced developers. <br><br><img src="https://habrastorage.org/webt/1g/5g/kz/1g5gkz_vdn0_xrsnmkzx23h1ofi.png"><br><br>  Qt is a ‚Äúthing in itself,‚Äù there are both advantages and limitations.  Qt libraries simply connect to the C ++ system APIs that exist on all operating systems.  For drawing the user interface, low-level mechanisms are used, but its own graphics engine that supports stylized ‚Äúunder a native‚Äù.  At the same time, on Android, you have to access the Java API via a special bridge (JNI bridge), and for Windows UWP you use the Open GL ES to DirectX call converter, since Open GL is not available for UWP. <br><br><br>  To summarize: all cross-platform frameworks use the standard native features of operating systems, are mature, are created by experienced teams and the open source community with the support of the giants of the IT industry.  Finally, the time has come for the strongest argument. <br><br><h2>  Myth 4. Slow </h2><br>  An important trump card that people like to use in disputes about cross-platform frameworks is poor performance.  Again, it depends on what to compare and in which parrots to count. <br><br>  Recall that the feature of cross-platform applications lies in the parallel existence of two worlds connected by a bridge: <br><br><ul><li>  PhoneGap: HTML / JS and Native Java / Objective-C / C #; </li><li>  React Native: JS and Native Java / Objective-C / C #; </li><li>  Xamarin: Mono and Native Java / Objective-C; </li><li>  Qt: C ++ and Native Java / Objective-C. </li></ul><br>  Thus, when comparing performance, you need to consider the speed of work: <br><br><ul><li>  cross-platform part; </li><li>  native part; </li><li>  the bridge. </li></ul><br>  If you type in the search engine, for example, react native vs swift performance, then you can see a lot of different tests, and many of them point out that performance drops dramatically with the active use of the bridge, including the active manipulation of the UI from the cross-platform code.  For Xamarin, the situation looks the same - the cross-platform part is very fast and comparable to the native one in data processing, however, when using a bridge, performance may drop.  Qt generally works at the C ++ level, which is fast on its own.  If, however, we consider solutions based on PhoneGap, then the performance here will strongly depend on WebView, but still you should not actively change the UI in JavaScript code or conduct scientific calculations. <br><br>  Slow?  Yes, there may be a drop in performance due to inept interaction with the operating system through the bridge.  However, the cross-platform worlds themselves are as fast as the native ones. <br><br><h2>  Conclusion </h2><br>  Today we reviewed the device of popular cross-platform mobile frameworks and dismantled the main myths with which they are surrounded. <br><br>  Stay in touch and write questions in the comments! <br><br><h2>  about the author </h2><br><img src="https://habrastorage.org/files/f70/e9c/e7a/f70e9ce7a2bd45a98e19652a08b15e26.JPG" align="left" width="120">  Vyacheslav Chernikov - head of development at <a href="https://aka.ms/habr_321454_4">Binwell</a> .  In the past, he was one of the Nokia Champion and Qt Certified Specialists, currently he is the Xamarin and Azure platform specialist.  He came to the sphere of mobile in 2005, since 2008 he has been developing mobile applications: he started with Symbian, Maemo, Meego, Windows Mobile, then switched to iOS, Android and Windows Phone. <br><br>  Articles Vyacheslav you can also read the <a href="https://aka.ms/habr_323296_8">blog on Medium</a> . <br><br>  We remind you that this is the full version of an <a href="https://xakep.ru/2017/12/25/crossplatform-myths/">article from Hacker magazine</a> . </div><p>Source: <a href="https://habr.com/ru/post/350262/">https://habr.com/ru/post/350262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350252/index.html">Rich Text Editor development: problems and solutions</a></li>
<li><a href="../350254/index.html">Dragon Bones: 2D character creation and skeletal, mesh animation</a></li>
<li><a href="../350256/index.html">Dovecot and Apache Solr integration</a></li>
<li><a href="../350258/index.html">What is missing in Trello for Agile development and where to look for alternatives?</a></li>
<li><a href="../350260/index.html">End of software engineering and last methodologist</a></li>
<li><a href="../350266/index.html">We train on cats: modification of collections and tables in iOS</a></li>
<li><a href="../350268/index.html">Cybersecurity for drivers: how to avoid cyber attacks on connected cars?</a></li>
<li><a href="../350270/index.html">InfiniBox F2230 Review</a></li>
<li><a href="../350272/index.html">FastTrack Training. "Network Basics". "Switches from Cisco". Eddie Martin December 2012</a></li>
<li><a href="../350274/index.html">Developing a game on SVG + React. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>