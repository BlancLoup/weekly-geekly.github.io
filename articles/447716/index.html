<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unity: draw a lot of health bars in one drawcall</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I had to solve a problem that is quite common in many games from above: to render on the screen a whole bunch of stripes of the health of en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unity: draw a lot of health bars in one drawcall</h1><div class="post__text post__text-html js-mediator-article">  Recently, I had to solve a problem that is quite common in many games from above: to render on the screen a whole bunch of stripes of the health of enemies.  Like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/081/95e/14e08195e0e331c7f24a8ba50c556d7e.png"></div><br>  Obviously, I wanted to do this as efficiently as possible, preferably in a single draw call.  As usual, before starting work, I did a little online research on other people's decisions, and the results were very different. <br><br>  I will not shame anyone for the code, but suffice it to say that some of the solutions were not entirely brilliant, for example, someone added a Canvas object to each enemy (which is very inefficient). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The method I came to as a result is slightly different from what I‚Äôve seen from others, and doesn‚Äôt use any UI classes at all (including Canvas), so I decided to document it for the public.  And for those who want to study the source code, I posted <a href="https://github.com/sinbad/UnityInstancedHealthBars">it on Github</a> . <br><a name="habracut"></a><br><h2>  Why not use Canvas? </h2><br>  One Canvas for each enemy is obviously a bad decision, but I could use a common Canvas for all enemies;  the only Canvas would also lead to the rendering of the draw calls. <br><br>  However, I don‚Äôt like the amount of work done with each approach associated with such an approach.  If you use Canvas, then in each frame you will have to perform the following operations: <br><br><ul><li>  Determine which of the enemies are on the screen, and select a strip of UI for each of them from the pool. </li><li>  Project the enemy's position in the camera to position the strip. </li><li>  Change the size of the "fill" part of the strip, probably as Image. </li><li>  Most likely to change the size of the strips in accordance with the type of enemies;  for example, large enemies should have large stripes so that it does not look stupid. </li></ul><br>  Anyway, all this would pollute the buffers of the Canvas geometry and result in the rebuilding of all the vertex data in the processor.  I did not want all this to be done for such a simple element. <br><br><h2>  Briefly about my decision </h2><br>  Brief description of my work process: <br><br><ul><li>  Attaching objects strips of energy to the enemies in 3D. <br><ul><li>  This allows you to automatically position and truncate the strips. </li><li>  The position / size of the strip can be adjusted according to the type of enemy. </li><li>  We will send the strips to the camera in code with the help of transform, which is still there. </li><li>  The shader ensures that they will always be rendered on top of everything. </li></ul></li><li>  Use Instancing to render all stripes in a single draw call. </li><li>  We use simple procedural UV coordinates to display the level of occupancy of the strip. </li></ul><br>  And now let's consider the solution in more detail. <br><br><h2>  What is Instancing? </h2><br>  Standard equipment has long been used in working with graphics: several objects are combined together so that they have common vertex data and materials and can be rendered in one draw call.  We need exactly this, because every draw call is an additional load on the CPU and GPU.  Instead of performing a single draw call on each object, we render them all at the same time and use a shader to add variability to each copy. <br><br>  You can do this manually by duplicating the vertices of the X mesh in one buffer, where X is the maximum number of copies that can be rendered, and then using an array of shader parameters to transform / color / vary each copy.  Each copy must have knowledge of how numbered it is in order to use this value as an array index.  Then we can use an indexed render call that orders ‚Äúrender only to N‚Äù, where N is the number of instances that you <em>actually</em> need in the current frame, less than the maximum number X. <br><br>  Most modern APIs already have code for this, so you do not need to manually do this.  This operation is called "Instancing";  in fact, it automates the process described above with predefined constraints. <br><br>  <a href="https://docs.unity3d.com/Manual/GPUInstancing.html">The Unity engine also supports instancing</a> , it has its own API and a set of shader macros to help in its implementation.  It uses certain assumptions, for example, that a complete 3D transformation is required in each instance.  Strictly speaking, for 2D strips it is not needed completely - we can do with simplifications, but since they are, we will use them.  This will simplify our shader, as well as provide the ability to use 3D-indicators, for example, circles or arcs. <br><br><h2>  Class Damageable </h2><br>  Our enemies will have a component called <code>Damageable</code> , giving them health and allowing them to take damage from collisions.  In our example, it is quite simple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Damageable</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxHealth; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceThreshold = <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceScale = <span class="hljs-number"><span class="hljs-number">5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentHealth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentHealth = MaxHealth; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCollisionEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collision other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Collision would usually be on another component, putting it all here for simplicity float force = other.relativeVelocity.magnitude; if (force &gt; DamageForceThreshold) { CurrentHealth -= (int)((force - DamageForceThreshold) * DamageForceScale); CurrentHealth = Mathf.Max(0, CurrentHealth); } } }</span></span></code> </pre> <br><h2>  HealthBar object: position / rotation </h2><br>  The health band object is very simple: in fact, it‚Äôs just a quad attached to the enemy. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be5/2ef/6e2/be52ef6e247fca661f9136e2835bb5dc.png"><br><br>  We use the <strong>scale of</strong> this object to make the strip long and thin, and place it directly above the enemy.  Do not worry about its rotation, we will fix it with the code attached to the object in <code>HealthBar.cs</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlignCamera</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mainCamera != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camXform = mainCamera.transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> forward = transform.position - camXform.position; forward.Normalize(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> up = Vector3.Cross(forward, camXform.right); transform.rotation = Quaternion.LookRotation(forward, up); } }</code> </pre> <br>  This code always directs the quad towards the camera.  We <em>can</em> perform resizing and rotation in the shader, but I implement them here for two reasons. <br><br>  First, instancing in Unity always uses the full transform of each object, and since we still pass all the data, we can use it.  Secondly, setting the scale / rotation here ensures that the bounding parallelogram for truncating the strip will always be correct.  If we did specify the size and rotation of the shader responsibility, then Unity could truncate the stripes that should be visible when they are close to the edges of the screen, because the size and rotation of their bounding parallelogram will not match what we are going to render.  Of course, we could implement our own truncation method, but usually it‚Äôs better to use what we have (Unity code is native and has access to more spatial data than we do). <br><br>  I will explain how the strip is rendered after we look at the shader. <br><br><h2>  HealthBar shader </h2><br>  In this version we will create a simple classic red and green strip. <br><br>  I use a 2x1 texture, with one green pixel on the left and one red on the right.  Naturally, I turned off mipmapping, filtering and compression, and for the parameter addressing mode set the value to Clamp - this means that the pixels of our strip will always be perfectly green or red, and not spread around the edges.  This will allow us to change the texture coordinates in the shader to shift the line separating the red and green pixels down and up along the strip. <br><br>  <em>(Since there are only two colors here, I could simply use the step function in the shader to return to the point of one or the other. However, in this method, it‚Äôs convenient that you can use a more complex texture if desired, and this will work similarly while the transition is in the middle of the texture.)</em> <br><br>  To begin, we will declare the properties we need: <br><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"UI/HealthBar"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Fill (<span class="hljs-string"><span class="hljs-string">"Fill"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  <code>_MainTex</code> is a red-green texture, and <code>_Fill</code> is a value from 0 to 1, where 1 is total health. <br><br>  Next, we need to order the strip to be rendered in the overlay queue, which means to ignore all the depth in the scene and to render on top of everything: <br><br><pre> <code class="cpp hljs"> SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Overlay"</span></span> } Pass { ZTest Off</code> </pre> <br>  The next part is the shader code itself.  We are writing a shader without lighting (unlit), so we don‚Äôt need to worry about integration with various Unity surface shaders, it‚Äôs just a simple vertex / fragment shader pair.  First, let's write bootstrapping: <br><br><pre> <code class="cpp hljs"> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vertex vert #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> fragment frag #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile_instancing #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UnityCG.cginc"</span></span></span></span></code> </pre> <br>  At most, this is a standard bootstrap, with the exception of <code>#pragma multi_compile_instancing</code> , which tells the Unity compiler what to compile for Instancing. <br><br>  The vertex structure must include instance data, so we will do the following: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">appdata</span></span></span><span class="hljs-class"> {</span></span> float4 vertex : POSITION; float2 uv : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID };</code> </pre> <br>  We also need to specify what exactly will be in these instances, besides what Unity (transform) processes for us: <br><br><pre> <code class="cpp hljs"> UNITY_INSTANCING_BUFFER_START(Props) UNITY_DEFINE_INSTANCED_PROP(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, _Fill) UNITY_INSTANCING_BUFFER_END(Props)</code> </pre> <br>  So we‚Äôre announcing that Unity has to create a buffer called ‚ÄúProps‚Äù to store the data for each instance, and inside it we will use one float per instance for the property called <code>_Fill</code> . <br><br>  You can use multiple buffers;  it is worth doing if you have several properties that are updated with different frequencies;  separating them, you can, for example, not to change one buffer when you change the other, which is more efficient.  But we do not need this. <br><br>  Our vertex shader almost completely performs the standard work, because the size, position and rotation are transferred to the transform.  This is implemented using <code>UnityObjectToClipPos</code> , which automatically uses the transform of each instance.  One can imagine that without instancing it would usually be a simple use of a single matrix property.  but when using instancing inside the engine, it looks like an array of matrices, and Unity independently selects the matrix that is appropriate for this instance. <br><br>  It also needs to change UV to change the location of the red to green transition point in accordance with the <code>_Fill</code> property.  Here is the corresponding code snippet: <br><br><pre> <code class="cpp hljs"> UNITY_SETUP_INSTANCE_ID(v); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fill = UNITY_ACCESS_INSTANCED_PROP(Props, _Fill); <span class="hljs-comment"><span class="hljs-comment">// generate UVs from fill level (assumed texture is clamped) o.uv = v.uv; o.uv.x += 0.5 - fill;</span></span></code> </pre> <br>  <code>UNITY_SETUP_INSTANCE_ID</code> and <code>UNITY_ACCESS_INSTANCED_PROP</code> do all the magic by accessing the correct version of the <code>_Fill</code> property from the constant buffer for this instance. <br><br>  We know that in the normal state, the UV coordinates of a quadrilateral (quad) cover the entire texture interval, and that the dividing line of the strip is in the middle of the texture horizontally.  Therefore, small mathematical calculations horizontally move the strip left or right, and the value of the Clamp texture ensures the filling of the remaining part. <br><br>  The fragment shader could not be simpler, because all the work has already been done: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2D(_MainTex, i.uv);</code> </pre> <br>  The full shader code with comments is available in <a href="https://github.com/sinbad/UnityInstancedHealthBars">the GitHub repository</a> . <br><br><h2>  Healthbar material </h2><br>  Then everything is simple - we just need to assign the material that this shader uses to our strip.  You don‚Äôt need to do much more, all you have to do is select the desired shader in the upper part, assign a red-green texture, and, most importantly, <strong>check the ‚ÄúEnable GPU Instancing‚Äù box</strong> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/06e/6e0/dcd/06e6e0dcd1965aa73f1dbbcf64e90a22.png" alt="image"><br><br><h2>  HealthBar Fill Property Update </h2><br>  So, we have a health strip object, a shader and the material that needs to be rendered, now we need to set the <code>_Fill</code> property for each instance.  We do this inside <code>HealthBar.cs</code> as follows: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateParams</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { meshRenderer.GetPropertyBlock(matBlock); matBlock.SetFloat(<span class="hljs-string"><span class="hljs-string">"_Fill"</span></span>, damageable.CurrentHealth / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)damageable.MaxHealth); meshRenderer.SetPropertyBlock(matBlock); }</code> </pre> <br>  We turn the <code>CurrentHealth</code> class of <code>Damageable</code> into a value from 0 to 1, dividing it by <code>MaxHealth</code> .  Then we pass it the _Fill property using the <code>MaterialPropertyBlock</code> . <br><br>  If you have not used <code>MaterialPropertyBlock</code> to transfer data to shaders, even without instancing, then you need to study it.  It is not as well explained in the Unity documentation, but is the most efficient way to transfer the data of each object to shaders. <br><br>  In our case, when instancing is used, the values ‚Äã‚Äãfor all health bars are packed into a buffer of constants so that they can be transferred all together and drawn at one time. <br><br>  There is almost nothing here except a boilerplate for setting variables, and the code is pretty boring;  see <a href="https://github.com/sinbad/UnityInstancedHealthBars">the GitHub repository for</a> details. <br><br><h2>  Demo </h2><br>  In <a href="https://github.com/sinbad/UnityInstancedHealthBars">the GitHub repository</a> there is a test demo in which a bunch of evil blue cubes are destroyed by heroic red spheres (hurray!), Receiving damage displayed by the stripes described in the article.  The demo is written in Unity 2018.3.6f1. <br><br>  The effect of instancing can be observed in two ways: <br><br><h3>  Stats panel </h3><br>  After clicking Play, click on the Stats button above the Game panel.  Here you can see how many draw calls are saved thanks to instancing (batching): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/f25/204/ad0f25204bb3daf73a2c3700fd185938.png" alt="image"><br><br>  By running the game, you can click on the HealthBar material and <em>uncheck the</em> ‚ÄúEnable GPU Instancing‚Äù <em>checkbox</em> , after which the number of saved calls will drop to zero. <br><br><h3>  Frame debugger </h3><br>  When you start the game, go to Window&gt; Analysis&gt; Frame Debugger, and then click ‚ÄúEnable‚Äù in the window that appears. <br><br>  At the bottom left you will see all the rendering operations performed.  Note that while there are a lot of separate calls for enemies and shells (if you wish, you can implement instancing for them).  If you scroll to the bottom, then you will see the item "Draw Mesh (instanced) Healthbar". <br><br>  This single call renders all stripes.  If you click on this operation and then on the operation on it, then you will see that all the bars will disappear, because they are drawn in one call.  If you are in the Frame Debugger, you uncheck the box ‚ÄúEnable GPU Instancing‚Äù from the material, you will see that one line has turned into several, and after checking this box - again into one. <br><br><h2>  How can I expand this system </h2><br>  As I said before, since these health strips are real objects, nothing prevents you from turning simple 2D strips into something more complex.  They can be semicircles under enemies that diminish in an arc, or rotating diamonds over their heads.  Using the same approach, you can still render them all in one call. </div><p>Source: <a href="https://habr.com/ru/post/447716/">https://habr.com/ru/post/447716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447704/index.html">Climbing Elbrus - Reconnaissance. Technical Part 1. Registers, stacks and other technical details</a></li>
<li><a href="../447706/index.html">Not ORM single</a></li>
<li><a href="../447708/index.html">Yandex presented the first Ilya Segalovich awards to young scientists and supervisors</a></li>
<li><a href="../447712/index.html">Hi, SaaS | Russian SaaS 2018 - results</a></li>
<li><a href="../447714/index.html">On the application of the theory of ARMA-processes in engineering practice</a></li>
<li><a href="../447718/index.html">Everything will go according to plan</a></li>
<li><a href="../447720/index.html">IoT security. Issue 2. Smart home</a></li>
<li><a href="../447728/index.html">Calculate the energy budget of the radio link for the satellite format CubeSat</a></li>
<li><a href="../447730/index.html">The evolution of email marketing: from QWERTYUIOP to GDPR</a></li>
<li><a href="../447734/index.html">Why the front-end should understand the principles of UI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>