<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ES6 humanly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: 
 I bring to your attention the translation of a brief (really brief) guide to ES6. It is possible to familiarize with the basic ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ES6 humanly</h1><div class="post__text post__text-html js-mediator-article"><p> <em>From the translator:</em> <br>  <em>I bring to your attention the translation of a brief (really brief) guide to ES6.</em>  <em>It is possible to familiarize with the basic concepts of the standard.</em> <br>  <em>In some cases, the original text was supplemented or replaced with a more suitable source.</em>  <em>For example, part of the definition of the keyword <code>const</code> is a translation of documentation from <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const">MDN</a> .</em> <br>  <em>To better understand some of the concepts (for high-quality translation), the standard description on the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">MDN</a> website, the <a href="">‚ÄúYou Don't Know JS: ES6 &amp; Beyond‚Äù</a> <a href="https://learn.javascript.ru/es-modern">manual</a> and the <a href="https://learn.javascript.ru/es-modern">textbook by Ilya Kantor were used</a> .</em> </p><br><p>  <em>Translation posted on Gitkhab: <a href="https://github.com/etnolover/ES6-for-humans-translation">https://github.com/etnolover/ES6-for-humans-translation</a> .</em>  <em>If errors are found, write, correct.</em> <br>  <em>Link to the original text: <a href="https://github.com/metagrover/ES6-for-humans">https://github.com/metagrover/ES6-for-humans</a></em> </p><br><p>  <em>Update 07/22/2016: added <a href="https://habrahabr.ru/post/305900/">poll about <code>const</code></a></em> <br><br></p><br><h3>  Content </h3><br><ul><li>  <a href="https://habrahabr.ru/post/305900/"><code>let</code> , <code>const</code> and block scope</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">Arrow functions</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">Default settings</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">Spread / Rest operator</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">Empowering Object Literals</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">Octal and binary literals</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">Destructuring arrays and objects</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">The super keyword for objects</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">String patterns and delimiters</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">for ... of against for ... in</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">Map and WeakMap</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">Set and WeakSet</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">Classes in ES6</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">Symbol data type</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">Iterators</a> </li><li>  <a href="https://habrahabr.ru/post/305900/">Generators</a> </li><li><p>  <a href="https://habrahabr.ru/post/305900/">Promises</a> </p><br></li><li>  <a href="https://habrahabr.ru/post/305900/">Poll: in which case to write <code>const</code> ?</a> </li></ul><br><a name="habracut"></a><br><br><a name="1"></a><br><h3>  1. let, const and block scope </h3><br><p>  The <code>let</code> keyword allows declaring variables with a limited scope - only for the {...} block in which the declaration occurs.  This is called a block scope.  Instead of the <code>var</code> keyword, which provides a scope within a function, the ES6 standard recommends using <code>let</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">// 3 } console.log(a); // 2</span></span></code> </pre> <br><p>  Another form of declaring a variable with block scope is the keyword <code>const</code> .  It is intended to declare variables (constants) whose values ‚Äã‚Äãare read-only.  This means not that the value of the constant is constant, but that the variable identifier cannot be reassigned. <br>  Here is a simple example: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ARR = [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; ARR.push(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ARR); <span class="hljs-comment"><span class="hljs-comment">// [5,6,7] ARR = 10; // TypeError ARR[0] = 3; //    console.log(ARR); // [3,6,7] }</span></span></code> </pre> <br><p>  What is worth remembering: </p><br><ul><li>  When it comes to raising the variables <code>let</code> and <code>const</code> , their behavior is different from the traditional behavior of <code>var</code> and <code>function</code> .  Both <code>let</code> and <code>const</code> do not exist before their announcement ( <em>from translator: for details, the author of the original manual refers to the <a href="http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified/">Temporal Dead Zone</a> article</em> ) </li><li>  The scope of the <code>let</code> and <code>const</code> is the nearest block. </li><li>  When using <code>const</code> it is recommended to use CURRENTS. </li><li>  In <code>const</code> , a value must be assigned simultaneously with the declaration of the variable. </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="2"></a><br><h3>  2. Arrow functions </h3><br><p>  Arrow functions are abbreviated functions in ES6.  The arrow function consists of a list of parameters <code>( ... )</code> , followed by the <code>=&gt;</code> sign and the function body. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    let addition = function(a, b) { return a + b; }; //   let addition = (a, b) =&gt; a + b;</span></span></code> </pre> <br><p>  Note that in the example above, the function body is a brief entry that does not require an explicit indication that we want to return the result. </p><br><p>  Here is an example using a block of curly braces: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'apple'</span></span>, <span class="hljs-string"><span class="hljs-string">'banana'</span></span>, <span class="hljs-string"><span class="hljs-string">'orange'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> breakfast = arr.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fruit</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fruit + <span class="hljs-string"><span class="hljs-string">'s'</span></span>; }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(breakfast); <span class="hljs-comment"><span class="hljs-comment">// ['apples', 'bananas', 'oranges']</span></span></code> </pre> <br><p>  <strong>That's not all!...</strong> </p><br><p>  Arrow functions don't just make the code shorter.  They are closely related to the <code>this</code> and context binding. </p><br><p>  The behavior of the switch functions with the keyword <code>this</code> is different from the behavior of ordinary functions with <code>this</code> .  Each function in JavaScript defines its own <code>this</code> context, but inside the arrow functions the value of <code>this</code> the same as the outside (the arrow functions do not have <code>this</code> ).  Look at the following code: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Person()  `this`    . this.age = 0; setInterval(function growUp() { //   `use strict`,  growUp()  `this` //   ,    `this`, //   Person(). this.age++; }, 1000); } var p = new Person();</span></span></code> </pre> <br><p>  In ECMAScript 3/5, this behavior can be changed by assigning <code>this</code> value to another variable. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; self.age = <span class="hljs-number"><span class="hljs-number">0</span></span>; setInterval(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">growUp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     `self`, //     . self.age++; }, 1000); }</span></span></code> </pre> <br><p>  As mentioned above, inside the switch functions, the value of <code>this</code> the same as outside, so the following code works as expected from it: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = <span class="hljs-number"><span class="hljs-number">0</span></span>; setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age++; <span class="hljs-comment"><span class="hljs-comment">// `this`    person }, 1000); } var p = new Person();</span></span></code> </pre> <br><p>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Learn more about 'Lexical this' in the switch functions on the MDN website</a> </p><br><br><a name="3"></a><br><h3>  3. Default Settings </h3><br><p>  ES6 allows you to set default parameters when declaring a function.  Here is a simple example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> getFinalPrice = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">price, tax = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.7</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> price + price * tax; getFinalPrice(<span class="hljs-number"><span class="hljs-number">500</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 850,    tax   getFinalPrice(500, 0.2); // 600,  tax -   0.2</span></span></code> </pre> <br><br><a name="4"></a><br><h3>  4. Spread / Rest operator </h3><br><p>  <code>...</code> operator is referred to as spread or rest, depending on how and where it is used. </p><br><p>  When used in any iterable object (iterable), this operator "splits" ("spread") it into individual elements: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, z</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x, y, z); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; foo(...arr); <span class="hljs-comment"><span class="hljs-comment">// 1 2 3</span></span></code> </pre> <br><p>  Another common use of the <code>...</code> operator is to combine a set of values ‚Äã‚Äãinto one array.  In this case, the operator works as "rest" <em>( <strong>from the translator</strong> : I did not find a suitable translation into Russian, from the example below everything will become clear)</em> </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(args); } foo(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5]</span></span></code> </pre> <br><br><a name="5"></a><br><h3>  5. Empowering Object Literals </h3><br><p>  ES6 allows object literals to be declared using a short syntax for initializing properties from variables and defining functional methods.  Also, the standard provides the ability to calculate properties directly in an object literal. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">make, model, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      //   ,   //    ,  //     make, //  make: make model, //  model: model value, //  value: value //      //   ['make' + make]: true, //      //   `function`  .  // "depreciate: function() {}"  : depreciate() { this.value -= 2500; } }; } let car = getCar('Kia', 'Sorento', 40000); console.log(car); // { // make: 'Kia', // model:'Sorento', // value: 40000, // makeKia: true, // depreciate: function() // }</span></span></code> </pre> <br><br><a name="6"></a><br><h3>  6. Octal and Binary Literals </h3><br><p>  ES6 introduces new support for octal and binary literals. <br>  Adding to the beginning of the number <code>0o</code> or <code>0O</code> converts it into an octal number system (similarly, <code>0b</code> or <code>0B</code> converts it into a binary number system).  Look at the following code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> oValue = <span class="hljs-number"><span class="hljs-number">0o10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(oValue); <span class="hljs-comment"><span class="hljs-comment">// 8 let bValue = 0b10; console.log(bValue); // 2</span></span></code> </pre> <br><br><a name="7"></a><br><h3>  7. Destructuring of arrays and objects </h3><br><p>  Destructuring helps to avoid the use of auxiliary variables when interacting with objects and arrays. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = foo(); <span class="hljs-comment"><span class="hljs-comment">// [1,2,3] let [a, b, c] = foo(); console.log(a, b, c); // 1 2 3 function bar() { return { x: 4, y: 5, z: 6 }; } let { x: a, y: b, z: c } = bar(); console.log(a, b, c); // 4 5 6</span></span></code> </pre> <br><br><a name="8"></a><br><h3>  8. The super keyword for objects </h3><br><p>  ES6 allows you to use the <code>super</code> method in (classless) objects with prototypes.  Here is a simple example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parent = { foo() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> child = { foo() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.foo(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>); } } <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.setPrototypeOf(child, parent); child.foo(); <span class="hljs-comment"><span class="hljs-comment">//   ! //   !</span></span></code> </pre> <br><br><a name="9"></a><br><h3>  9. String patterns and delimiters </h3><br><p>  ES6 provides a simpler way to insert the value of a variable or an expression result (the so-called "interpolation"), which are calculated automatically. </p><br><ul><li>  <code>${ ... }</code> used to calculate the value of a variable / expression. </li><li>  `` Backquotes are used as a delimiter for such cases. </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${user}</span></span></span><span class="hljs-string">!`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// , !</span></span></code> </pre> <br><br><a name="10"></a><br><h3>  10. for ... of against for ... in </h3><br><ul><li>  <code>for...of</code> used to iterate through a loop of iterable objects, for example, arrays. </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nicknames = [<span class="hljs-string"><span class="hljs-string">'di'</span></span>, <span class="hljs-string"><span class="hljs-string">'boo'</span></span>, <span class="hljs-string"><span class="hljs-string">'punkeye'</span></span>]; nicknames.size = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nickname <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> nicknames) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(nickname); } <span class="hljs-comment"><span class="hljs-comment">// di // boo // punkeye</span></span></code> </pre> <br><ul><li>  <code>for...in</code> used to iterate through the loop of all the object properties available for iteration (enumerable). </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nicknames = [<span class="hljs-string"><span class="hljs-string">'di'</span></span>, <span class="hljs-string"><span class="hljs-string">'boo'</span></span>, <span class="hljs-string"><span class="hljs-string">'punkeye'</span></span>]; nicknames.size = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nickname <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nicknames) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(nickname); } <span class="hljs-comment"><span class="hljs-comment">// 0 // 1 // 2 // size</span></span></code> </pre> <br><br><a name="11"></a><br><h3>  11. Map and WeakMap </h3><br><p>  ES6 introduces new data structures - <code>Map</code> and <code>WeakMap</code> .  In fact, we use "Map" in javascript all the time.  Each object can be represented as a special case of <code>Map</code> . </p><br><p>  A classic object consists of keys (always in string form) and values, whereas in <code>Map</code> any value (both objects and primitives) can be used for a key and value.  Let's look at this code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyString = <span class="hljs-string"><span class="hljs-string">""</span></span>, keyObj = {}, keyFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-comment"><span class="hljs-comment">//   myMap.set(keyString, ",   ''"); myMap.set(keyObj, ",   keyObj"); myMap.set(keyFunc, ",   keyFunc"); myMap.size; // 3 //   myMap.get(keyString); // ",   ''" myMap.get(keyObj); // ",   keyObj" myMap.get(keyFunc); // ",   keyFunc"</span></span></code> </pre> <br><p>  <strong>Weakmap</strong> </p><br><p>  <code>WeakMap</code> is a <code>Map</code> in which keys have unstable links, which allows not to interfere with the garbage collector to delete <code>WeakMap</code> elements.  This means you don‚Äôt have to worry about memory leaks. </p><br><p>  It is worth noting that in <code>WeakMap</code> , unlike <code>Map</code> , <em>each key must be an object</em> . </p><br><p>  For <code>WeakMap</code> there are only four methods: <code>delete()</code> , <code>has()</code> , <code>get()</code> and <code>set(, )</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> w = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); w.set(<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Uncaught TypeError: Invalid value used as weak map key var o1 = {}, o2 = function(){}, o3 = window; w.set(o1, 37); w.set(o2, "azerty"); w.set(o3, undefined); w.get(o3); // undefined,      w.has(o1); // true w.delete(o1); w.has(o1); // false</span></span></code> </pre> <br><br><a name="12"></a><br><h3>  12. Set and WeakSet </h3><br><p>  Set objects are collections of unique values.  Duplicate values ‚Äã‚Äãare ignored because  The collection must contain only unique values.  Values ‚Äã‚Äãcan be primitives or object references. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mySet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]); mySet.size; <span class="hljs-comment"><span class="hljs-comment">// 3 mySet.has(1); // true mySet.add(''); mySet.add({ a: 1, b:2 });</span></span></code> </pre> <br><p>  You can loop through <code>Set</code> in a loop using <code>forEach</code> or <code>for...of</code> .  The iteration occurs in the same order as the insert. </p><br><pre> <code class="javascript hljs">mySet.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(item); <span class="hljs-comment"><span class="hljs-comment">// 1 // 2 // 3 // '' // Object { a: 1, b: 2 } }); for (let value of mySet) { console.log(value); // 1 // 2 // 3 // '' // Object { a: 1, b: 2 } }</span></span></code> </pre> <br><p>  <code>Set</code> also has <code>delete()</code> and <code>clear()</code> methods. </p><br><p>  <strong>Weakset</strong> </p><br><p>  Similar to <code>WeakMap</code> , the <code>WeakSet</code> object allows <code>WeakSet</code> to store <em>objects</em> with unstable links in a collection.  The object in <code>WeakSet</code> is unique. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ws = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakSet</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = {}; ws.add(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>); ws.add(obj); ws.has(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true ws.has(foo); // false, foo      ws.delete(window); //  window   ws.has(window); // false, window  </span></span></code> </pre> <br><br><a name="13"></a><br><h3>  13. Classes in ES6 </h3><br><p>  In ES6 introduced a new syntax for classes.  It is worth noting here that the ES6 class is not a new object-oriented model of inheritance.  This is just syntactic sugar for prototype inheritance in JavaScript. </p><br><p>  The class in ES6 is simply a new syntax for working with prototypes and constructor functions that we are used to using in ES5. </p><br><p>  Functions written with the <code>static</code> are used to declare static class properties. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  task!"</span></span>); } showId() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">23</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> loadAll() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  tasks..."</span></span>); } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> Task); <span class="hljs-comment"><span class="hljs-comment">// function let task = new Task(); // "  task!" task.showId(); // 23 Task.loadAll(); // "  tasks..."</span></span></code> </pre> <br><p>  <strong>extends and super in classes</strong> </p><br><p>  Look at the following code: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Porsche</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" Porsche"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Porsche(); <span class="hljs-comment"><span class="hljs-comment">//    //  Porsche</span></span></code> </pre> <br><p>  In ES6, the <code>extends</code> allows a descendant class to inherit from the parent class.  It is important to note that the constructor of the descendant class must call super (). </p><br><p>  Also, in the descendant class, you can call the method of the parent class with the help of <code>super.()</code> . </p><br><p>  <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">Learn more about classes on the MDN website.</a> </p><br><p>  What is worth remembering: </p><br><ul><li>  Class declarations do not go up (not hoisted).  First you need to declare the class and only then use it, otherwise there will be a Reference Error error. </li><li>  There is no need to use the <code>function</code> keyword when defining functions within a class definition. </li></ul><br><br><a name="14"></a><br><h3>  14. Symbol data type </h3><br><p>  Symbol is a unique and immutable data type introduced in ES6.  The purpose of <code>Symbol</code> is to create a unique identifier that cannot be accessed. </p><br><p>  Here's how to create a <code>Symbol</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sym = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">" "</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> sym); <span class="hljs-comment"><span class="hljs-comment">// symbol</span></span></code> </pre> <br><p>  Note that you cannot use <code>new</code> with <code>Symbol(‚Ä¶)</code> . </p><br><p>  If <code>Symbol</code> used as a property / key of an object, it is preserved in such a special way that the property will not be shown when a normal enumeration of object properties is displayed. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">val</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>)]: <span class="hljs-string"><span class="hljs-string">" - "</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(o)); <span class="hljs-comment"><span class="hljs-comment">// val</span></span></code> </pre> <br><p>  To retrieve the object's character properties, use <code>Object.getOwnPropertySymbols(o)</code> </p><br><br><a name="15"></a><br><h3>  15. Iterators </h3><br><p>  The iterator refers to the elements of the collection one by one, at the same time preserving the memory of its current position in this collection.  The iterator has a <code>next()</code> method, which returns the next element in the sequence.  This method returns an object with two properties: done (if the search is over) and value (value). </p><br><p>  In ES6, there is a <code>Symbol.iterator</code> method that defines an iterator for an object by default.  Each time a loop is iterated over an object (for example, at the beginning of a for..of loop), its iterator method is called with no arguments, and the returned iterator is used to get the values ‚Äã‚Äãfor the iteration. </p><br><p>  Let's look at the array that is iterable and at the iterator that the array has to handle its values: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = [<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itr = arr[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator](); itr.next(); <span class="hljs-comment"><span class="hljs-comment">// { value: 11, done: false } itr.next(); // { value: 12, done: false } itr.next(); // { value: 13, done: false } itr.next(); // { value: undefined, done: true }</span></span></code> </pre> <br><p>  Note that you can write your own iterator through the definition of <code>obj[Symbol.iterator]()</code> with the description of the object. </p><br><p>  More about iterators: <br>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">On the MDN website</a> </p><br><br><a name="16"></a><br><h3>  16. Generators </h3><br><p>  The generator functions are a new feature of ES6 that allows functions to create many values ‚Äã‚Äãover a period of time, returning an object (called a generator) that can be iterated to emit values ‚Äã‚Äãfrom a function one at a time. </p><br><p>  The generator function returns the <strong>object to be iterated</strong> when it is called. <br>  The generator function is written using the <code>*</code> sign after the <code>function</code> keyword, and the function keyword must contain the <code>yield</code> keyword. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">infiniteNumbers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> n++; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numbers = infiniteNumbers(); <span class="hljs-comment"><span class="hljs-comment">//    numbers.next(); // { value: 1, done: false } numbers.next(); // { value: 2, done: false } numbers.next(); // { value: 3, done: false }</span></span></code> </pre> <br><p>  Each time you call <code>yield</code> return value becomes the next value in the sequence. </p><br><p>  Also note that generators calculate their return values ‚Äã‚Äãon demand, which allows them to efficiently represent sequences that are computationally expensive, or even infinite sequences. </p><br><br><a name="17"></a><br><h3>  17. Promises </h3><br><p>  ES6 has built-in support for promises.  A promise is an object that is waiting for an asynchronous operation to be performed, after which (ie, after it has been executed), the promis takes one of two states: fulfilled (resolved) or rejected (completed with an error). </p><br><p>  The standard way to create promises is the <code>new Promise()</code> constructor, which accepts a handler with two functions as parameters.  The first handler (usually referred to as <code>resolve</code> ) is the function to call along with the future value when it is ready;  The second handler (usually referred to as <code>reject</code> ) is a function that is called to refuse to perform the promise if it cannot determine the future value. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>) { resolve(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// fulfilled successfully ( ) } else { reject(/* reason */); // rejected () } });</span></span></code> </pre> <br><p>  Each promis has a <code>then</code> method in which there are two callbacks.  The first callback is called if the promise is successfully completed (resolved), while the second callback is called if the promise is completed with an error (rejected). </p><br><pre> <code class="javascript hljs">p.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  "</span></span>, val), (err) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   "</span></span>, err));</code> </pre> <br><p>  When returning a value from <code>then</code> callback will pass the value to the next <code>then</code> callback. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve(<span class="hljs-string"><span class="hljs-string">""</span></span>); }); hello.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string"> `</span></span>) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">!`</span></span>) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(str)) <span class="hljs-comment"><span class="hljs-comment">//  !</span></span></code> </pre> <br><p>  When promise returns, the successfully processed promise value will pass to the next callback, in order to effectively join them together. <br>  This simple technique helps to avoid hell with callbacks ("callback hell"). </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventuallyAdd1 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">)</span></span>{ resolve(val + <span class="hljs-number"><span class="hljs-number">1</span></span>); }); } p.then(eventuallyAdd1) .then(eventuallyAdd1) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(val)) <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre> <br><a name="18"></a></div><p>Source: <a href="https://habr.com/ru/post/305900/">https://habr.com/ru/post/305900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305888/index.html">Agile API - is it possible?</a></li>
<li><a href="../305890/index.html">The digest of interesting events from the world of Java, and around it # 6 (07/04/2016 - 07/17/2016)</a></li>
<li><a href="../305892/index.html">Modal windows on Angular, Angular 2 and ReactJS</a></li>
<li><a href="../305894/index.html">JIT compiler optimizes not cool, but very cool</a></li>
<li><a href="../305898/index.html">Cache, Hash and Nyash Mesh</a></li>
<li><a href="../305904/index.html">Haordic Organization Visa (Part 4)</a></li>
<li><a href="../305906/index.html">Increment in php</a></li>
<li><a href="../305908/index.html">"Closer to the people": Does the manager need to understand programming</a></li>
<li><a href="../305910/index.html">The evolution of mobile payments</a></li>
<li><a href="../305912/index.html">We prove the correctness of the search for the diameter of the tree</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>