<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mustached shooter of twenty-three polygons</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="And let's digress a bit and write a game in google play? And not such a huge and heavy garbage, about which I usually write articles, but something si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mustached shooter of twenty-three polygons</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ac1/587/3db/ac15873dbf4745fd8d6c39cd7ec8bc09.png"><br><p>  And let's digress a bit and write a game in google play?  And not such a huge and heavy garbage, about which I usually write articles, but something simple and sweet to the heart? </p><br><p>  In fact, everything is very simple: I finally registered a developer account and really want to try it out.  At the time of writing these lines, I do not have a single written class and not a single drawn pixel.  In essence, this article is a real devlog. </p><a name="habracut"></a><br><h2 id="stati">  Articles </h2><br><ul><li>  First part.  Mustached shooter of twenty-three polygons. </li><li>  <a href="https://habrahabr.ru/post/326840/">The second part of.</a>  <a href="https://habrahabr.ru/post/326840/">Mustached shooter with a polygonal belly.</a> </li></ul><br><h2 id="oglavlenie">  Table of contents </h2><br><ul><li>  <a href="&amp;xid=17259,15700019,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgay_3Qyy8Ruyy3SJRdD0IVnWhSHw#img-width40-height44-src">Idea</a> </li><li>  <a href="&amp;xid=17259,15700019,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgay_3Qyy8Ruyy3SJRdD0IVnWhSHw#img-width40-height44-src">Microprototype</a> </li><li>  <a href="&amp;xid=17259,15700019,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgay_3Qyy8Ruyy3SJRdD0IVnWhSHw#img-width40-height44-src">First map</a> </li><li>  <a href="&amp;xid=17259,15700019,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgay_3Qyy8Ruyy3SJRdD0IVnWhSHw#img-width40-height44-src">The choice of setting and visual style</a> </li><li>  <a href="&amp;xid=17259,15700019,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgay_3Qyy8Ruyy3SJRdD0IVnWhSHw#img-width40-height44-src">Transition to 3D</a> </li><li>  <a href="&amp;xid=17259,15700019,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgay_3Qyy8Ruyy3SJRdD0IVnWhSHw#img-width40-height44-src">Procedural generation</a> </li><li>  <a href="&amp;xid=17259,15700019,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgay_3Qyy8Ruyy3SJRdD0IVnWhSHw#img-width40-height44-src">Regular polygons in 2D</a> </li><li>  <a href="&amp;xid=17259,15700019,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgay_3Qyy8Ruyy3SJRdD0IVnWhSHw#img-width40-height44-src">Regular polygons in 3D</a> </li><li>  <a href="&amp;xid=17259,15700019,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgay_3Qyy8Ruyy3SJRdD0IVnWhSHw#img-width40-height44-src">Shadows</a> </li><li>  <a href="&amp;xid=17259,15700019,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgay_3Qyy8Ruyy3SJRdD0IVnWhSHw#img-width40-height44-src">Shadows in the Vertex Shader</a> </li><li>  <a href="&amp;xid=17259,15700019,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgay_3Qyy8Ruyy3SJRdD0IVnWhSHw#img-width40-height44-src">Generate shadows on cpu</a> </li><li>  <a href="&amp;xid=17259,15700019,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgay_3Qyy8Ruyy3SJRdD0IVnWhSHw#img-width40-height44-src">Shadow Optimization</a> </li><li>  <a href="https://habrahabr.ru/post/322262/">Conclusion of the first part</a> </li></ul><br><h2 id="img-width40-height44-srchttpshabrastorageorgfiles52aee038452aee0384d7344cf82b93ed1f9d12198pnglevel-11-ideya"><img width="40" height="44" src="https://habrastorage.org/files/52a/ee0/384/52aee0384d7344cf82b93ed1f9d12198.png">  Level 1.1.  Idea </h2><br><p><img src="https://habrastorage.org/files/077/20f/c8b/07720fc8b88e44f6a9dfdd6fc40eb1fc.jpg" alt="The first kalyaki-Malyaki"><br>  <em>The first kalyaki-malyaki.</em> </p><br><p>  See this circle on paper?  From him and begin.  It seems to me that any game (oh well, any piece) can be started with a similar circle.  What will he be in a few seconds?  Wheel?  Hat?  Planet?  I draw doodles, trying to imagine what this circle means.  Hat! </p><br><p>  A certain stern uncle walks along the roads, and we look at him from above.  Severe - because he knows how to shoot with a pistol.  Stomping around the city, blowing into his mustache, shooting bullets at the bandits. <br>  This blank is just an image that has long been spinning in my head.  That's just to make the game on the likeness of <a href="https://ru.wikipedia.org/wiki/Crimsonland">Crimsonland</a> absolutely do not want to do.  And I always disliked gui with two joysticks.  We cut off all unnecessary with the Occam's razor and get the following concept at the output: </p><br><blockquote>  Level: a small town with houses, drawers and barrels. <br>  Characters: the main character (shooter), gangsters and pedestrians. <br>  The game is paused and waiting for the player to act.  The player makes a swipe in any direction.  In this moment: <br>  1. Time in the game starts to go; <br>  2. The main character shoots in the direction indicated by the player; <br>  3. The main character begins to move in the indicated direction. <br><br>  It takes half a second and the time in the game stops again.  The player needs to defeat all the bandits, injuring as few passers as possible. <br></blockquote><p>  This combination of automatic shooting and stopping time I really liked: </p><br><ul><li>  Automatic shooting: <br><ul><li>  Simplifies control (one svayp instead of two joysticks); </li><li>  Adds an interesting mechanic (you have to look where you are going, so as not to shoot at a passerby). </li></ul></li><li>  Stop time: <br><ul><li>  Adds variability to the gameplay (you can do different levels: slow, thoughtful puzzles or a smart shooter); </li><li>  Softens the complexity of automatic firing; </li><li>  It allows you to control the dynamics of both me (through level design) and the player. </li></ul></li></ul><br><p>  Gradually, the idea is visualized and overgrown with details.  Mark one after another, enough for today. </p><br><p>  <em>Todo: make a tiny prototype and check how far the fan will move / shoot with the time stop.</em> </p><br><h2 id="img-width40-height44-srchttpshabrastorageorgfiles53bbd318153bbd31818d7419e8bdcacd4d21d822cpnglevel-12-mikroprototip"><img width="40" height="44" src="https://habrastorage.org/files/53b/bd3/181/53bbd31818d7419e8bdcacd4d21d822c.png">  Level 1.2.  Microprototype </h2><br><p>  Thanks Unity3D, prototyping on it is very simple.  I <a href="https://docs.unity3d.com/ScriptReference/BoxCollider2D.html">add a</a> couple of walls with <a href="https://docs.unity3d.com/ScriptReference/BoxCollider2D.html">BoxCollider2D</a> , round sprites with <a href="https://docs.unity3d.com/ScriptReference/Rigidbody2D.html">RigidBody2D</a> and <a href="https://docs.unity3d.com/ScriptReference/CircleCollider2D.html">CircleCollider2D</a> (player, passers-by and bandits).  Bullets - the same sprite, only small, red, with <a href="https://docs.unity3d.com/ScriptReference/Rigidbody2D.html">RigidBody2D</a> , <a href="https://docs.unity3d.com/ScriptReference/CircleCollider2D.html">CircleCollider2D</a> and <a href="https://docs.unity3d.com/ScriptReference/TrailRenderer.html">TrailRenderer</a> for the flight path. </p><br><p>  Time management I do through my <em>Clock</em> class, all other classes (player, bullet, etc.) use the time delta from it, not Time.DeltaTime. </p><br><div class="spoiler">  <b class="spoiler_title">One of the first versions of Clock.cs, for those interested</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Clock</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stepDuration; [SerializeField] AnimationCurve stepCurve; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> time = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeRatio = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> defaultFixedDeltaTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Clock instance; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Clock Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; defaultFixedDeltaTime = Time.fixedDeltaTime; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instance == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) instance = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Paused { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> timeRatio * Time.deltaTime; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> FixedDeltaTime { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> timeRatio * Time.fixedDeltaTime; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Play</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Paused) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; time = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeRatio = Mathf.Max(<span class="hljs-number"><span class="hljs-number">0</span></span>, stepCurve.Evaluate(<span class="hljs-number"><span class="hljs-number">0</span></span>)); UpdatePhysicSpeed(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Paused) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; time = Mathf.Min(time + Time.unscaledDeltaTime, stepDuration); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time &gt;= stepDuration) { timeRatio = <span class="hljs-number"><span class="hljs-number">0</span></span>; time = <span class="hljs-number"><span class="hljs-number">-1</span></span>; UpdatePhysicSpeed(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } timeRatio = Mathf.Max(<span class="hljs-number"><span class="hljs-number">0</span></span>, stepCurve.Evaluate(time / stepDuration)); UpdatePhysicSpeed(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePhysicSpeed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Time.timeScale = timeRatio; Time.fixedDeltaTime = defaultFixedDeltaTime * timeRatio; } }</code> </pre> </div></div><br><p>  The most basic prototype is ready in an hour and a half, full of bugs: </p><br><ol><li>  The movement of the player and the bullet is done through the transform.position, not the velocity, so the player sausages when he presses against the walls; </li><li>  Stopping time does not stop physics (fixedDeltaTime does not change), so in the pause mode, the characters move slightly (pushed out of each other). </li></ol><br><p>  But even in this version it is already interesting to move and shoot.  The first prototype looks, of course, quite unpresentable: </p><br><p><img src="https://habrastorage.org/files/083/055/b5b/083055b5b2a34411a426cd04a8abbab8.png" alt="The first playable prototype"><br>  <em>The first playable prototype</em> </p><br><p>  But the next day the hailstorm appears: <br>  Chips: </p><br><ol><li>  Add "reflective" walls, from which the bullet will bounce; </li><li>  Add the destruction of bots in a collision with a bullet (as long as they do not know how); </li><li>  Add flexible time management (now there is a duration and a curve for the ‚Äútime flow rate‚Äù, but this is inconvenient). </li></ol><br><p>  Fixes: </p><br><ol><li>  Transform motion to change velocity, not transform.position; </li><li>  Prohibit the creation of bullets in the walls (the player rests against the wall, shoots, the bullet immediately kills the player). </li></ol><br><p>  <em>Todo: make a test learning level with invented chips.</em> </p><br><h2 id="img-width40-height44-srchttpshabrastorageorgfilesbb28403e6bb28403e645448af934d27f0d82fb1e8pnglevel-13-pervaya-karta"><img width="40" height="44" src="https://habrastorage.org/files/bb2/840/3e6/bb28403e645448af934d27f0d82fb1e8.png">  Level 1.3.  First map </h2><br><p>  While walking down the street, I came up with a test level plan: </p><br><ol><li>  Safe zone.  The player learns to walk, all the bullets go to the walls; </li><li>  Narrow corridor with an inactive enemy.  The player goes along the corridor and understands how to attack; </li><li>  Expansion of the corridor with an inactive gangster and a couple of passers-by.  Expansion - after turning, so the player can not accidentally get into a passerby; </li><li>  Turn in the form of a <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B8%25D1%2581%25D0%25BA%25D0%25BE%25D0%25BF">periscope</a> , instead of a mirror - a reflecting wall, around the turn - an inactive enemy.  The player shoots the wall, sees how the rebound works; </li><li>  Corridor with mirrored walls, enemies and pedestrians.  The player passes neatly along the corridor, trying not to get into the passers-by (or shoots them if he wants); </li><li>  Sandbox. </li></ol><br><p>  Throwing objects onto the stage, repainting the reflective walls in yellow.  It turns out something like this: <br><img src="https://habrastorage.org/files/b78/eb5/68a/b78eb568ab654204a9d8eb7de07a4733.png" alt="Type of training level"><br>  <em>Type of training level</em> </p><br><p>  I make reflective walls through a separate layer, the code of the collision of a bullet with an obstacle becomes: </p><br><div class="spoiler">  <b class="spoiler_title">OnCollisionEnter2D</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCollisionEnter2D</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collision2D coll</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> layer = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; coll.gameObject.layer; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layer == wall.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) Destroy(gameObject); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layer == human.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { Destroy(gameObject); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> humanBody = coll.gameObject.GetComponent&lt;Human&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (humanBody != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) humanBody.Kill(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layer == wallMirror.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { Vector2 normal = Vector2.zero; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contact <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> coll.contacts) normal += contact.normal; direction = Vector2.Reflect(direction, normal); } }</code> </pre> </div></div><br><p>  I fix bugs, add chips thought up last day.  I <em>am redoing the</em> class Clock: earlier the course lasted <em>stepDuration of</em> real seconds, and the coefficient of the speed of time was determined by the curve <em>stepCurve</em> .  The curve is needed for a smooth start and completion of the course. </p><br><p><img src="https://habrastorage.org/files/d6e/435/32c/d6e43532cbcc4f6bb910a76e1531423a.png" alt="Old settings in Clock.cs"><br>  <em>Old settings in Clock.cs</em> </p><br><p>  That's only if you change the duration of the stroke, the duration of the start / end will also change (where the value of the ordinate on the curve is not equal to 1).  And if the turn-on time is too short, the ‚Äúon‚Äù time seems too sharp, and when it is on the order of a second, it is too slow (because the curve is ‚Äústretched‚Äù for the entire duration of the turn).  I add separate curves for the start and end of the turn, as well as the duration of the start / end. </p><br><p>  Add a camera that monitors the player and the visualization of the player's trajectory. </p><br><p>  I silently show the prototype to several acquaintances, explaining neither the goal, nor the control.  Everyone was able to deal with the management, but there are problems that I did not notice.  For myself, I recorded the conclusions of the playtest: </p><br><ol><li>  Difficult to aim.  I use the delta between the last two positions of the finger, I would need to take more values; </li><li>  Finger gets tired to swipe across the screen.  It is solved by the duration of the course, level design; </li><li>  Sometimes lost swipe made.  People start to make svayp, when the turn is not over yet and often release the finger while the current turn stops.  Since  during the course it is impossible to change the direction, the gesture is wasted.  It is solved with a tricky code (I don‚Äôt know how) </li><li>  It would be cool to make collected objects that are destroyed by bullets.  They need to be approached, but not in a straight line; </li><li>  Ricochets add interest: you can arrange a mad bullet storm; </li><li>  Players do not distinguish between passers-by and enemies.  It is treated by art; </li></ol><br><p>  The prototype is ready so that you can show the gameplay! </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZZ1LBMOgwkc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Todo: decide on the setting, graphics.</em> </p><br><h2 id="img-width40-height44-srchttpshabrastorageorgfiles58531aca458531aca4da34f9f92039ff291e43af8pnglevel-1boss-100hp-vybor-settinga-i-vizualnogo-stilya"><img width="40" height="44" src="https://habrastorage.org/files/585/31a/ca4/58531aca4da34f9f92039ff291e43af8.png">  Level 1.boss [100hp].  The choice of setting and visual style </h2><br><p>  My first ‚Äúboss‚Äù was precisely this stage, I never thought.  I planned the following: surf the Internet on popular gaming settings, search references and art for inspiration, and start drawing levels in pixel art. </p><br><p>  After some googling, I decided to dwell on the entourage of Victorian England.  Ferns, the cult of death, gloomy docks.  Wood, metal, steam and oil. </p><br><p>  I try to draw the first sprites and discover the problem.  All objects in the game can rotate.  And the pixels, as you know, no. </p><br><p>  Drawing 360 variants of each sprite is obviously not an option.  Fortunately, now the fashion is not the "dishonest pixelart", when the sprites rotate freely around its axis.  In this case, you need to do something with the aliasing ladders, which inevitably appear, predatory angular faces will stick out and will flicker here and there.  You can put up with it and say: ‚ÄúThis is my style!‚Äù, As the creators of Hotline miami did (and in fact it turned out!).  You can connect anti-aliasing: "Long live fragrant soap!". </p><br><p>  In any case, I did it: either aliasing and ladders, or fuzzy edges after anti-aliasing. </p><br><img src="https://habrastorage.org/files/a38/264/152/a38264152a8548df97628250c5d306ab.png"><br><p>  <em>Test pixelart</em> </p><br><p>  I mark the pixelart (sorry, friend!) And simplify, simplify! </p><br><p>  <em>Todo: choose the appropriate visual style.</em> </p><br><h2 id="img-width40-height44-srchttpshabrastorageorgfiles0000a927c0000a927c5b34ba789755690a1d97117pnglevel-1boss-75hp-perehod-k-3d"><img width="40" height="44" src="https://habrastorage.org/files/000/0a9/27c/0000a927c5b34ba789755690a1d97117.png">  Level 1.boss [75hp].  Transition to 3D </h2><br><p>  City of paper!  Looks a bit like <a href="http://wildfireworlds.com/">Wildfire worlds</a> , only easier.  Noble white faces of rough paper, spots of paint on the floor, these are the characters in funny hats: </p><br><img src="https://habrastorage.org/files/7a4/84c/2c7/7a484c2c74544e699d2c0767d904c40d.png"><br><p>  <em>Cylindrical pax</em> </p><br><p>  In truth, I never worked with 3d in game dev, and 3d editors last opened a few years ago.  But I know that much is solved by lighting and shadows.  Especially if the texture is white paper, where you really can‚Äôt hide the disadvantages of bad light. </p><br><p>  I spend the evening on the simulation of the first object: a package of milk.  Understand with standard shaders, lighting. </p><br><p>  The conclusion is simple: I will not pull.  I spend a lot of time on modeling and I can not get a beautiful picture by standard means.  Baking lighting helps, but I wanted to make a small toy with many levels, so baking is in flight.  Looks like the boss is not defeated yet ... </p><br><img src="https://habrastorage.org/files/55c/cd7/437/55ccd7437c3f4ffab40ec6ad832fa7d8.png"><br><p>  <em>Milk pack with simple lighting</em> </p><br><h2 id="img-width40-height44-srchttpshabrastorageorgfiles6128294e76128294e7287427bb6eccd34cfedbdc2pnglevel-1boss-15hp-procedural-generation"><img width="40" height="44" src="https://habrastorage.org/files/612/829/4e7/6128294e7287427bb6eccd34cfedbdc2.png">  Level 1.boss [15hp].  Procedural generation. </h2><br><p>  I remember my strengths and weaknesses.  Usually, if I can't draw any art for my project, I write a script that will do it for me.  Than 3d is worse?  So procedural generation!  Base primitives are, in fact, low poly.  Bright, contrasting colors, visually encoding gameplay differences. </p><br><p>  I need to decide what primitives I need to create levels.  Cylinders and cubes, perhaps pentagons ... Hmm, this is all you can generate with one code.  For the work! </p><br><p>  <em>Todo: implement simple primitive generation.</em> </p><br><h2 id="img-width40-height44-srchttpshabrastorageorgfilesfb97b6997fb97b69975934e1e9f34c2e0b69a84afpnglevel-21-pravilnye-mnogougolniki-v-2d"><img width="40" height="44" src="https://habrastorage.org/files/fb9/7b6/997/fb97b69975934e1e9f34c2e0b69a84af.png">  Level 2.1.  Regular polygons in 2D </h2><br><p>  For now the level will be enough regular polygons.  To begin with, I decided to try 2D, turned the camera into an orthogonal mode and created elements of two pieces: </p><br><ul><li>  The body (just a regular polygon) is white; </li><li>  A colored ring around, indicating in color the type of object (how the bullet will behave if it collides). </li></ul><br><div class="spoiler">  <b class="spoiler_title">Do not forget about the geometry!</b> <div class="spoiler_text"><p>  If we use the constant radius of the ring for all polygons, we get such unsuited outlines: </p><br><img src="https://habrastorage.org/files/ac2/14d/428/ac214d428138485a9cd2901ca537826e.png"><br><p>  <em>Contours of different thickness</em> <br>  The fact is that you need to get the same distance between the sides of the outer and inner parts of the "ring", and I work with corners, not sides.  The smaller the angles in the polygon, the more radii of the circumscribed and inscribed circle will differ, and, accordingly, the distances between the sides and the distances between the corners will differ. <br><math> </math> $ inline $ 1 - cos \ frac {\ pi} {edges} $ inline $   - solves the problem. <br>  Now the smaller the angles, the wider the contour will be: </p><br><img src="https://habrastorage.org/files/e3b/08c/696/e3b08c6969354d54a82a0cfd056a5651.png"><br><p>  <em>Contours of the same thickness</em> </p></div></div><br><p>  A little stencil magic, so that the rings inside other polygons are not visible and we get such a hare: </p><br><img src="https://habrastorage.org/files/eac/d5e/675/eacd5e675e0f483ba2dcbe858a684f44.png"><br><p>  <em>Bunny</em> </p><br><p>  And then spun! </p><br><p>  I added a standard cellular texture to the body, picked up colors and finally could not resist and plugged in my favorite shadows (I <a href="https://habrahabr.ru/post/305252/">wrote</a> about them already). </p><br><img src="https://habrastorage.org/files/0a7/a44/e57/0a7a44e57933490e80686a6aec539bd2.png"><br><p>  <em>Simple and neat.</em> </p><br><p>  I share the screen with a girl and get a reasonable feedback: the shadow falling from a high object to a lower one has distortions, breaks.  I agree, I see it all the time in the real world.  I try to draw on paper and understand how these distortions should look like.  And here I understand: what kind of distortion, if the camera is orthogonal? </p><br><img src="https://habrastorage.org/files/597/9a5/269/5979a5269f724ea6b297291c085e07cd.png"><br><p>  <em>Left shadows with a perspective camera, right with orthogonal</em> </p><br><p>  It turns out that my beautiful shadows only emphasize the flat view of the map.  Time to return to 3D. </p><br><h2 id="img-width40-height44-srchttpshabrastorageorgfiles3f89635673f8963567c104582ab977a9538a4846dpnglevel-22-pravilnye-mnogougolniki-v-3d"><img width="40" height="44" src="https://habrastorage.org/files/3f8/963/567/3f8963567c104582ab977a9538a4846d.png">  Level 2.2.  Regular polygons in 3D </h2><br><p>  To be honest, procedural generation in 3D is a completely new experience for me.  On the other hand, it should not differ from 2D. </p><br><p>  First, I decided on the settings of a particular polygon: </p><br><ol><li>  <em>height</em> - Height; </li><li>  <em>edges</em> - the number of faces; </li><li>  <em>size</em> - Vector2D, allows you to set the size of the polygon or stretch it along one of the axes; </li><li>  <em>isCircle</em> - Is it a cylinder?  If yes, the number of faces is set automatically, based on the radius, and size.y becomes equal to size.x. </li></ol><br><p>  And with general settings that will be the same for one type of game objects: </p><br><ol><li>  Color "ceiling"; </li><li>  Border color; </li><li>  Border width; </li><li>  The minimum number of faces in the cylinder; </li><li>  The ratio of the number of faces in the cylinder to 1 perimeter unit. </li></ol><br><p>  Now is the time to create these polygons.  I broke each into 3 mesh: </p><br><ol><li>  Body - the upper base; </li><li>  Border - color ring on the upper base; </li><li>  Side - side surface; </li></ol><br><p>  It makes no sense to generate the lower base, since  Objects cannot rotate along the x or y axis, and the camera is always above the map. </p><br><img src="https://habrastorage.org/files/30e/964/b08/30e964b089c442d4b9200cfa231718f4.png"><br><p>  <em>We get these polygons</em> </p><br><p>  Time for optimizations: </p><br><p>  Firstly, I constantly calculate single vectors rotated at certain angles. <br>  We get the class AnglesCache with one public method: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ObstacleGenerators</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AnglesCache</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Vector3[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAngles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sides</span></span></span><span class="hljs-function">)</span></span>; } }</code> </pre> <br><p>  Next, I cache all 3 types of meshes, using significant parameters as keys (number of sides, color, circle, etc.).  I save the color to the vertices, this will allow using one material for the meshes and, as a result, dynamic batching. </p><br><p>  True, now there was a problem with borders and stencil: I used to unite borders with stencil, now that the volume has appeared, this approach gives bad results: </p><br><img src="https://habrastorage.org/files/d9f/191/439/d9f191439f474e50adf2b9bb10463f6e.png"><br><p>  <em>The boundaries of higher cylinders are not drawn, since</em>  <em>under them draw the base of low cylinders</em> </p><br><p>  I stop using stencil buffer.  Now all borders must be drawn: </p><br><img src="https://habrastorage.org/files/4b6/862/960/4b686296061643148b3e50ebdd856cf8.png"><br><p>  <em>No stencil buffer</em> </p><br><p>  And finally, I change the ZTest settings in the shader from <em>On</em> ( <em>LEqual</em> ) to <em>Less</em> .  Now the borders will not be drawn over the bases of the cylinders with the same height.  As a result, I get a neat border association that correctly works with objects of different heights: </p><br><img src="https://habrastorage.org/files/611/d92/98d/611d9298dd494fd3a844bb39ab870970.png"><br><p>  <em>Combining boundaries through ZTest settings</em> </p><br><p>  Finally, the final touches: </p><br><ol><li>  As uv coordinates for the bases of the cylinders I use world coordinates.  All objects have a common texture without seams; </li><li>  I paint the side surface in the bleached border color; </li><li>  I add to the shader side surface _fixed3 _LightPosition, slightly illuminate the side surfaces (the classic <a href="https://en.wikipedia.org/wiki/Gouraud_shading">method of rendering Guro</a> ).  Here, by the way, the isCircle flag in the objects came in handy: if it is not set, each triangle has unique vertices, if it is installed, the vertices are common.  As a result, the normals are interpolated and a smooth surface is obtained for isCircle. </li></ol><br><iframe width="560" height="315" src="https://www.youtube.com/embed/11DulnmhG4s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Lighting, anti-aliasing, shaders and world uv coordinates.</em>  <em>(Lighting twisted harder for clarity)</em> </p><br><p>  The final touch is to generate PolygonCollider2D polygons of the desired shape. <br>  Total: three-dimensional polygons with physics and neat lowpoly style. </p><br><p>  <em>Todo: the shadows.</em> </p><br><h2 id="img-width40-height44-srchttpshabrastorageorgfilesc6e40ff4fc6e40ff4f6024af9bc828a0741d53f6cpnglevel-31-teni"><img width="40" height="44" src="https://habrastorage.org/files/c6e/40f/f4f/c6e40ff4f6024af9bc828a0741d53f6c.png">  Level 3.1.  Shadows </h2><br><p>  Of course, now the former two-dimensional shadows will not work: </p><br><img src="https://habrastorage.org/files/027/dfb/2b2/027dfb2b2d1646ef8136798dab995a10.png"><br><p>  <em>Flat shadows look weird, because</em>  <em>do not take into account the volume of the object</em> </p><br><p>  And they should look something like this: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/888/4d4/eab/8884d4eab85642378dc5942221668e49.png"></div><br><p>  <em>More realistic shadows</em> </p><br><p>  "Well, what's the problem?"  - You ask.  "There are great shadows in Unity3D!" </p><br><p>  Indeed there is.  Here is the <a href="https://en.wikipedia.org/wiki/Shadow_mapping">Shadow mapping</a> algorithm that is used to build shadows.  In a nutshell: If we look at the scene <em>from</em> a light source, then all the objects that are visible to us are lit, and those that are somehow closed are in the shadow.  We can create a shadow map by placing the camera in the coordinates of the light source and rendering the scene (the z-buffer will contain the distance to the light source).  The problem is in perspective distortion.  The farther objects are from the light source, the more screen pixels correspond to the texels from the shadow map. </p><br><p>  Those.  The shadows are not "pixel perfect", this is not their thing, much more important that they are very fast.  Usually, there is no problem with distortion, since shadows are superimposed on complex objects with a texture; as a result, a slight loss of quality is not noticeable.  But I have very light textures, very few polygons, so the low quality of the shadows is perfectly visible. </p><br><p>  However, there is a good solution.  The algorithm is called " <a href="https://en.wikipedia.org/wiki/Shadow_volume">Shadow volume</a> " and it is very similar to those two-dimensional shadows that I have done in previous articles. </p><br><p>  Suppose we have a certain mesh, which should cast shadows from the light source. </p><br><ol><li>  We find its silhouette edges (those edges that separate the lighted part of the mesh and the unlighted part); </li><li>  "Pull" them from the light source (each face turns into 2 triangles). </li><li>  We draw all these extended faces (in the color buffer we do not write anything, we only read from z-buffer, but we write to the stencil): <br>  3.1.  If the normal of the triangle is directed to the camera (front): add a unit to the stencil buffer; <br>  3.1.  If the normal of the triangle is directed away from the camera (back): subtract one from the stencil buffer. </li></ol><br><p>  It turns out that if we "entered" one time in the shadow (crossed the front triangle) and one - "left" (crossed the triangle back) - the value in stensile will be equal to <math> </math> $ inline $ -1 + 1 = 0 $ inline $   and the pixel is lit.  If we entered the shadow more than the number of times we left (when there is a triangle in front of the front and back that was drawn and recorded the data in the z-buffer), the pixel is in the shadow and it is not necessary to light it. </p><br><p>  So, you need to get the shadow meshes from the objects, go through the shader, add the necessary data to the stencil, and then draw the shadow where there is a nonzero value in the stencil.  Sounds like a problem solved on shaders! </p><br><p>  <em>Todo: generate shadows on shaders.</em> </p><br><h2 id="img-width40-height44-srchttpshabrastorageorgfilesb4457ecb7b4457ecb7f0f4290a3483b1e7834874apnglevel-32-teni-v-verteksnom-sheydere"><img width="40" height="44" src="https://habrastorage.org/files/b44/57e/cb7/b4457ecb7f0f4290a3483b1e7834874a.png">  Level 3.2.  Shadows in the Vertex Shader </h2><br><p>  I didn‚Äôt use a geometric shader, I don‚Äôt want to lose some devices due to the fact that the GL version is old.  Accordingly, all potential edges will have to be baked in advance for each polygon. </p><br><div class="spoiler">  <b class="spoiler_title">Minute arithmetic</b> <div class="spoiler_text"><p>  Let there be a cylinder with 32 angles.  Each face turns into two triangles and 4 vertices, total: <br>  Total faces - 32 side, and 32 on each of two bases, 96 in total. <br>  So, 96 * 2 = 192 triangles and 384 vertices per cylinder.  Quite a bit of. </p><br><p>  In fact, even more: initially we do not know which of the side faces will be the transition from light to shadow (front), and which one - from shadow to light (back).  Therefore, for each side face, it is necessary to make not 2 triangles, but 4 (2 of them with the opposite direction of the normal), so that later you can correctly cut off the ones you need using Cull Back or Cull Front. </p><br><p>  Therefore, 32 * 4 = 128 faces, 256 triangles and 512 vertices.  Really a lot. </p></div></div><br><p>  Creating the desired mesh is quite simple; I will not focus on this. <br>  But the shader is very curious. </p><br><p>  Judge for yourself: we do not need to draw all the faces, only the silhouette ones (those that separate light and shadow).  So, we need for each vertex in the vertex shader: </p><br><ol><li>  Find the position of the previous face; </li><li>  Calculate the values ‚Äã‚Äãof A, B, C for a straight line passing through the current and previous face; </li><li>  Determine which side of the line is the center of the polygon; </li><li>  Determine which side of the line is the source of light; </li><li>  Repeat steps 1-4 for the next facet; </li><li>  Compare values ‚Äã‚Äã- if one of the faces is in the light (center and source in different half-planes), and the other is in the shadow - this vertex is silhouette and it needs to be drawn; </li><li>  Find out whether to pull the current vertex, or it lies on the cylinder itself; </li><li>  If you need to stretch, find the position of the vertex in world coordinates, get the direction from the light source and move it in this direction for some distance (for example, 100 units); </li></ol><br><p>  For all these calculations, you have to store a large amount of data at the top: <br>  coordinates (or offset) to the previous and next vertices, the flag ‚Äî whether the current vertex should be shifted. </p><br><p>  Imagine working! <br>  However, this method of creating shadows contains so many fatal flaws that it becomes sad: </p><br><ol><li>  <strong>A huge number of vertices and triangles.</strong>  Most often, a shadow consists of two side faces, half of the lower and half of the upper edges.  For a 32x carbon cylinder and an infinitely distant light source <math> </math> $ inline $ 16 * 4 = 64 $ inline $   points and <math> </math> $ inline $ (16 * 2 + 2) * 2 = 68 $ inline $   triangles.  Instead, I give 256 graphics triangles and 512 vertices to the video card. </li><li>  <strong>Does not work batching.</strong>  To calculate the shadows in the vertices must be in one way or another stored information about neighboring vertices (positions and normals).  Accordingly, the data are tied to local coordinates in the mesh space.  When batching, many meshes are combined (this changes the coordinate system to the world one) and now the vertices no longer have information about the position of neighboring points. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Looks like a broken batching like this.</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/rxqRxz1jcY8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><p>  A large number of vertices turned out to be an unpleasant consequence of the chosen method, but a broken batching scored the last nail: 100-200 draw call on a shadow for a mobile device is an unacceptable result.  Apparently, it is necessary to transfer the shadow calculations to the CPU.  However, is it as bad as it seems?  :) </p><br><p> <em>Todo:     CPU.</em> </p><br><h2 id="img-width40-height44-srchttpshabrastorageorgfiles10bdd472b10bdd472b8cf40e98975e1fed1789f36pnglevel-32-generaciya-teney-na-cpu"><img width="40" height="44" src="https://habrastorage.org/files/10b/dd4/72b/10bdd472b8cf40e98975e1fed1789f36.png"> Level 3.2.    cpu </h2><br><p>     . </p><br><ol><li><p>   : <br>  1.1.         ; <br>  1.2.           ; <br>  1.3.         ; <br>  1.4.    ,   ‚Äî ,     (lightToShadowIndex); <br> 1.5.1     ,    ,     (shadowToLightIndex); </p><br></li><li><p>   : <br>  2.1.      lightToShadowIndex   shadowToLightIndex      2  (,      4-,  2    ,  2 ‚Äî ,  ); </p><br></li><li><p>   : <br> 3.1      shadowToLightIndex   lightToShadowIndex      2 ; </p><br></li><li>   : <br> 4.1         shadowToLightIndex  lightToShadowIndex; </li></ol><br><blockquote>  : <br>     ,       (      ). <br>       :     ,   . </blockquote><p>  ,    .   ,   60fps  10 ,   600   . (   ‚Äî 6  10 ). </p><br><p> <em>Todo:  , 60fps      nexus 5.</em> </p><br><h2 id="img-width40-height44-srchttpshabrastorageorgfiles10bdd472b10bdd472b8cf40e98975e1fed1789f36pnglevel-33-optimizacii-teney"><img width="40" height="44" src="https://habrastorage.org/files/10b/dd4/72b/10bdd472b8cf40e98975e1fed1789f36.png"> Level 3.3.   </h2><br><p> <strong> :</strong> <br>   ‚Äî     ,      .      ,      . </p><br><p> <strong> :</strong> <br>      .   AnglesCache,  .      : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ObstacleGenerators</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AnglesCache</span></span> { List&lt;Vector2[]&gt; cache; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX_CACHE_SIZE = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnglesCache</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector2[]&gt;(MAX_CACHE_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MAX_CACHE_SIZE; ++i) cache.Add(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Vector2[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAngles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sides</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sides &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sides &gt; MAX_CACHE_SIZE) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GenerateAngles(sides); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache[sides] == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) cache[sides] = GenerateAngles(sides); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache[sides]; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> AngleOffset { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } } <span class="hljs-function"><span class="hljs-function">Vector2[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateAngles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sides</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2[sides]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaAngle = <span class="hljs-number"><span class="hljs-number">360.0f</span></span> / sides; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> firstAngle = AngleOffset; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = Matrix4x4.TRS(Vector2.zero, Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, deltaAngle), Vector2.one); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> direction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(Mathf.Cos(firstAngle), Mathf.Sin(firstAngle)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sides; ++i) { result[i] = direction; direction = matrix.MultiplyPoint3x4(direction); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } } }</code> </pre> </div></div><br><p> <strong> :</strong> <br>    (   ).              ,     c  . </p><br><p> <strong>  :</strong> <br>   Transform.TransformPoint     transform.localToWorldMatrix  MultiplyPoint3x4. </p><br><p>      Vector3  Vector2 (    ,     ),       ,    : </p><br><pre> <code class="cs hljs">Vector2 v2; Vector3 v3; <span class="hljs-comment"><span class="hljs-comment">//    , v2.x = v3.x; v2.y = v3.y; //    v2.Set(v3.x, v3.y); //    ,    v2 = v3;</span></span></code> </pre> <br><blockquote> ,     ,      ,    . </blockquote><p> <strong>  :</strong> <br>    .        , ,        : </p><br><ol><li>   (size.x == size.y); </li><li>      . </li></ol><br><p>  ,   ‚Äî   .       ‚Äî . </p><br><p>  : </p><br><ol><li><p> ,      : size.x == size.y        ; </p><br></li><li>        : </li></ol><br><pre> <code class="cs hljs">direction = lightPosition - obstacleCenter;</code> </pre> <br><ol><li>    LCT (L ‚Äî  , C ‚Äî  , T ‚Äî    ,   L)    LC, CT ().  <em>deltaAngle</em> ‚Äî   LC  CT; </li><li>  <em>directionAngle</em> ‚Äî  (  OX)  LC; </li><li>  <em>firstAngle</em> , <em>secondAngle</em> ‚Äî        LT: </li></ol><br><pre> <code class="cs hljs">firstAngle = directionAngle - deltaAngle; secondAngle = directionAngle + deltaAngle;</code> </pre> <br><ol><li>   ,  ‚Äî 360¬∞ / edges,  ‚Äî     z: <br><pre> <code class="cs hljs">fromLightToShadow = Mathf.FloorToInt(firstAngle / pi2 * edges + edges) % edges; fromShadowToLight = Mathf.FloorToInt(secondAngle / pi2 * edges + edges) % edges;</code> </pre> </li><li>           ,     .    ,  firstAngle     :      ,          .  ,   ,     (fromLightToShadow  fromShadowToLight),       : </li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (linesCache[fromLightToShadow].HalfPlainSign(lightPosition) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) fromLightToShadow = (fromLightToShadow + <span class="hljs-number"><span class="hljs-number">1</span></span>) % edges; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (linesCache[fromShadowToLight].HalfPlainSign(lightPosition) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) fromShadowToLight = (fromShadowToLight + <span class="hljs-number"><span class="hljs-number">1</span></span>) % edges;</code> </pre> <br><p>      .    ‚Äî    (Acos, Atan2)    .  ‚Äî   .   ,   .  ,             : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0wWr_i-7uF8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <em>     .</em> </p><br><div class="spoiler"> <b class="spoiler_title">       </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanUseFastSilhouette</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 lightPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size.x != size.y || edgesList != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (lightPosition - (Vector2)transform.position).sqrMagnitude &gt; size.x * size.x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindSilhouetteEdges</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 lightPosition, Vector3[] angles, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromLightToShadow, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromShadowToLight</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanUseFastSilhouette(lightPosition)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FindSilhouetteEdgesFast(lightPosition, angles, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> fromLightToShadow, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> fromShadowToLight); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FindSilhouetteEdges(lightPosition, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> fromLightToShadow, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> fromShadowToLight); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindSilhouetteEdgesFast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 lightPosition, Vector3[] angles, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromLightToShadow, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromShadowToLight</span></span></span><span class="hljs-function">)</span></span> { Vector2 center = transform.position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius = size.x; Vector2 delta = center - lightPosition; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaMagnitude = delta.magnitude; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sin = radius / deltaMagnitude; Vector2 direction = delta / deltaMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pi2 = Mathf.PI * <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> directionAngle = Mathf.Atan2(-direction.y, -direction.x) - anglesCache.AngleOffset - transform.rotation.eulerAngles.z * Mathf.Deg2Rad; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaAngle = Mathf.Acos(sin); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> firstAngle = ((directionAngle - deltaAngle) % pi2 + pi2) % pi2; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> secondAngle = ((directionAngle + deltaAngle) % pi2 + pi2) % pi2; fromLightToShadow = Mathf.RoundToInt(firstAngle / pi2 * edges - <span class="hljs-number"><span class="hljs-number">1</span></span> + edges) % edges; fromShadowToLight = Mathf.RoundToInt(secondAngle / pi2 * edges - <span class="hljs-number"><span class="hljs-number">1</span></span> + edges) % edges; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> </div></div><br><p> <em> :</em> </p><br><p>        cpu,       . , ,    32     ,    ,  42   36  (  512   256     gpu). </p><br><p> <em>  :</em> </p><br><p>     ,     .       ‚Äî           "" .            ,     . </p><br><p> <em>    :</em> </p><br><p>    <em>x</em>  <em>y</em>     (      )    ‚Äî  c  ,   . </p><br><p> <em> bounding box:</em> </p><br><p>  Mesh.RecalculateBounds     ‚Äî      .   AABB   . </p><br><p>   : </p><br><ol><li>  4    :     circleCenter ‚Äî lightPosition,       ; </li><li>   4  ‚Äî   4-,    z    ( 8    ‚Äî  ,    ); </li><li>           . </li><li>        (  ,   z == 0) </li><li>         16  ‚Äî ,        ; </li><li>      AABB . </li></ol><br><blockquote>   ,      ,   . </blockquote><br><img src="https://habrastorage.org/files/075/84d/784/07584d784910475e935faf65abab1e13.png"><br><p> <em>  (  )</em> </p><br><img src="https://habrastorage.org/files/7f6/250/f93/7f6250f9395342928912a427f4e599cd.png"><br><p> <em>  (  )</em> </p><br><img src="https://habrastorage.org/files/00f/19f/9a8/00f19f9a827c4b0a9bf7d9444360351a.png"><br><p> <em>Bounding box    (   ) </em> </p><br><p>   ,     ,  . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>       ,     ,  .  ) </p><br><p>   ,        ,   ,       . ,    ,   : </p><br><ol><li>           ; </li><li>         ; </li><li>    . </li></ol><br><p>     : </p><br><ol><li>         ,       ,   ; </li><li>      ‚Äî     ; </li><li>  3 ‚Äî     ,   ; </li><li>    ‚Äî   . </li><li>     (,  Gizmos),       . </li></ol><br><p>   ,      !  ) </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322262/">https://habr.com/ru/post/322262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322250/index.html">Model of Actors and C ++: What, Why and How?</a></li>
<li><a href="../322252/index.html">What questions to ask at the interview</a></li>
<li><a href="../322254/index.html">Examples of how partners lose money when collaborating with CPA networks</a></li>
<li><a href="../322256/index.html">Why Kotlin sucks</a></li>
<li><a href="../322258/index.html">We write game logic in C #. Part 1/2</a></li>
<li><a href="../322266/index.html">Tarantool: load testing</a></li>
<li><a href="../322268/index.html">We write game logic in C #. Part 2/2</a></li>
<li><a href="../322270/index.html">In defense, Zuckerberg takes Evan Spiegel "by the throat"</a></li>
<li><a href="../322272/index.html">How to wind 40k views on Habrahabr. Bug or feature?</a></li>
<li><a href="../322274/index.html">Business rule repositories and corresponding code blocks that are embedded in production</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>