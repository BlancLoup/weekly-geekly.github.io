<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dynamic programming. Classic tasks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habrahabr. At the moment I am working on a tutorial on Olympiad programming, one of the paragraphs of which is devoted to dynamic programming. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dynamic programming. Classic tasks</h1><div class="post__text post__text-html js-mediator-article">  Hello, Habrahabr.  At the moment I am working on a tutorial on Olympiad programming, one of the paragraphs of which is devoted to dynamic programming.  The following is an excerpt from this paragraph.  Trying to explain this topic as simply as possible, I tried to accompany the difficult moments with illustrations.  I am interested in your opinion on how understandable this material has turned out.  Also I will be glad to advice what other tasks should be included in this section. <br><br>  In many programming olympiad problems, solving using recursion or full enumeration requires performing a very large number of operations.  Attempting to solve such problems, for example, by exhaustive search, leads to exceeding the execution time. <br><br>  However, among the enumerated and some other tasks, we can distinguish a class of problems that have one good property: having solutions of some subtasks (for example, for a smaller number <i>n</i> ), one can find the solution to the original problem almost without searching. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Such tasks are solved by dynamic programming, and dynamic programming itself means reducing a task to subtasks. <br><a name="habracut"></a><br><h3>  Sequences </h3><br>  The classic task on the sequence is the following. <br><br>  The Fibonacci sequence <i>F</i> <sub><i>n</i></sub> is given by the formulas: <i>F</i> <sub>1</sub> = 1, <i>F</i> <sub>2</sub> = 1, <br>  <i>F <sub>n</sub></i> = <i>F</i> <sub><i>n</i> - 1</sub> + <i>F</i> <sub><i>n</i> - 2</sub> for <i>n</i> &gt; 1. It is necessary to find <i>F</i> <sub><i>n</i></sub> by the number <i>n</i> . <br><br>  One solution that may seem logical and effective is to solve using recursion: <br><br><pre> int F (int n) {
  if (n &lt;2) return 1;
  else return F (n - 1) + F (n - 2);
 } </pre><br>  Using such a function, we will solve the problem ‚Äúfrom the end‚Äù - we will decrease <i>n</i> step by step until we reach the known values. <br><br>  But as you can see, such a seemingly simple program already with <i>n</i> = 40 runs noticeably for a long time.  This is due to the fact that the same intermediate data are calculated several times - the number of operations grows at the same rate as the Fibonacci numbers grow exponentially. <br><br>  One of the ways out of this situation is to save the intermediate results already found for the purpose of their reuse: <br><br><pre> int F (int n) {
  if (A [n]! = -1) return A [n];
  if (n &lt;2) return 1;
  else {
   A [n] = F (n - 1) + F (n - 2);
   return A [n];
  }
 }
</pre><br>  The above solution is correct and effective.  But for this problem a simpler solution is applicable: <br><br><pre> F [0] = 1;
 F [1] = 1;
 for (i = 2; i &lt;n; i ++) F [i] = F [i - 1] + F [i - 2];
</pre><br>  Such a solution can be called a solution "from the beginning" - we first fill in the known values, then we find the first unknown value ( <i>F</i> <sub>3</sub> ), then the next one, etc., until we reach the desired one. <br><br>  It is this solution that is classical for dynamic programming: we first solved all the subtasks (found all <i>F</i> <sub><i>i</i></sub> for <i>i</i> &lt; <i>n</i> ), then, knowing the solutions of the subtasks, we found the answer ( <i>F</i> <sub><i>n</i></sub> = <i>F</i> <sub><i>n</i> - 1</sub> + <i>F</i> <sub><i>n</i> - 2</sub> , <i>F</i> <sub><i>n</i> - 1</sub> and <i>F</i> <sub><i>n</i> - 2</sub> have already been found). <br><br><h3>  One-dimensional dynamic programming </h3><br>  To better understand the essence of dynamic programming, we first define the concepts of tasks and subtasks more formally. <br><br>  Let the original problem be to find some number <i>T</i> with the initial data <i>n</i> <sub>1</sub> , <i>n</i> <sub>2</sub> , ..., <i>n</i> <sub><i>k</i></sub> .  That is, we can talk about the function <i>T</i> ( <i>n</i> <sub>1</sub> , <i>n</i> <sub>2</sub> , ..., <i>n</i> <sub><i>k</i></sub> ), the value of which is the answer we need.  Then we will consider tasks as subtasks. <br>  <i>T</i> ( <i>i</i> <sub>1</sub> , <i>i</i> <sub>2</sub> , ..., <i>i</i> <sub><i>k</i></sub> ) for <i>i</i> <sub>1</sub> &lt; <i>n</i> <sub>1</sub> , <i>i</i> <sub>2</sub> &lt; <i>n</i> <sub>2</sub> , ..., <i>i</i> <sub><i>k</i></sub> &lt; <i>n</i> <sub><i>k</i></sub> . <br><br>  Further we will talk about one-dimensional, two-dimensional and multidimensional dynamic programming with <i>k</i> = 1, <i>k</i> = 2, <i>k</i> &gt; 2, respectively. <br><br>  The following problem of one-dimensional dynamic programming is found in various variations. <br><br>  <b>Task 1.</b> Calculate the number of sequences of zeros and units of length <i>n</i> in which two consecutive units are not found. <br><br>  For <i>n</i> &lt;32, a full search will take several seconds, and for <i>n</i> = 64, a full search will not be possible in principle.  To solve the problem using dynamic programming, we reduce the original problem to subtasks. <br><br>  When <i>n</i> = 1, <i>n</i> = 2, the answer is obvious.  Suppose that we have already found <i>K</i> <sub><i>n</i> - 1</sub> , <i>K</i> <sub><i>n</i> - 2</sub> - the number of such sequences of length <i>n</i> - 1 and <i>n</i> - 2. <br><br>  Let us see what a sequence of length <i>n</i> can be.  If its last character is 0, then the first <i>n</i> - 1 is any valid sequence of length. <br>  <i>n</i> - 1 (it doesn't matter if it ends with zero or one ‚Äî 0 goes next).  Such sequences of all <i>K</i> <sub><i>n</i> - 1</sub> .  If the last character is 1, then the penultimate character must be equal to 0 (otherwise there will be two units in a row), and the first <br>  <i>n</i> - 2 characters - any correct sequence of length <i>n</i> - 2, the number of such sequences is equal to <i>K</i> <sub><i>n</i> - 2</sub> . <br><br><img src="https://habrastorage.org/storage/e76e58eb/90b30949/64ba6a7d/2edde0ff.png"><br><br>  Thus, <i>K</i> <sub>1</sub> = 2, <i>K</i> <sub>2</sub> = 3, <i>K</i> <sub><i>n</i></sub> = <i>K</i> <sub><i>n</i> - 1</sub> + <i>K</i> <sub><i>n</i> - 2</sub> for <i>n</i> &gt; 2. That is, this task actually boils down to finding Fibonacci numbers. <br><br><h3>  2D dynamic programming </h3><br>  The classical problem of two-dimensional dynamic programming is the problem of routes on a rectangular field. <br>  In different formulations, it is necessary to count the number of routes or find a route that is the best in a sense. <br><br>  We give a couple of formulations of such problems: <br><br>  <b>Task 2.</b> Given a rectangular field of size <i>n</i> * <i>m</i> cells.  You can make steps a single cell to the right or down.  Calculate how many ways you can get from the left upper cell to the lower right one. <br><br>  <b>Task 3.</b> Given a rectangular field of size <i>n</i> * <i>m</i> cells.  You can make steps a single cell to the right, down or diagonally to the right down.  Each cell contains a certain natural number.  It is necessary to get from the upper left cell to the right lower one.  The route weight is calculated as the sum of the numbers from all the visited cells.  It is necessary to find a route with a minimum weight. <br><br>  For all such tasks, it is characteristic that each individual route cannot pass two or more times in the same cell. <br><br>  Let us consider problem 2 in more detail. In a certain cell with coordinates ( <i>i</i> , <i>j</i> ) one can come only from above or from the left, that is, from cells with coordinates ( <i>i</i> - 1, <i>j</i> ) and ( <i>i</i> , <i>j</i> - 1): <br><br><img src="https://habrastorage.org/storage/55c62abf/e53d0ec2/5499cda3/b98eb044.png"><br><br>  Thus, for the cell ( <i>i</i> , <i>j</i> ) the number of routes A [i] [j] will be equal to <br>  A [i - 1] [j] + A [i] [j - 1], that is, the task is reduced to two subtasks.  In this implementation, two parameters are used - <i>i</i> and <i>j</i> - therefore, with reference to this task, we are talking about two-dimensional dynamic programming. <br><br>  Now we can go sequentially through the rows (or columns) of the array A, finding the number of routes for the current cell using the above formula.  You must first put the number 1 in A [0] [0]. <br><br>  In task 3, we can get into the cell with coordinates ( <i>i</i> , <i>j</i> ) from the cells with coordinates <br>  ( <i>i</i> - 1, j), ( <i>i</i> , <i>j</i> - 1) and ( <i>i</i> - 1, <i>j</i> - 1).  Suppose that for each of these three cells we have already found the route of the minimum weight, and weights were placed in W [i - 1] [j], W [i] [j - 1], <br>  W [i - 1] [j - 1].  To find the minimum weight for ( <i>i</i> , <i>j</i> ), you must select the minimum of the weights W [i - 1] [j], W [i] [j - 1], W [i - 1] [j - 1] and add to there is a number written in the current cell: <br><br>  W [i] [j] = min (W [i ‚Äì 1] [j], W [i] [j - 1], W [i - 1] [j - 1]) + A [i] [j] ; <br><br>  This task is complicated by the fact that it is necessary to find not only the minimum weight, but also the route itself.  Therefore, in addition to each cell, we will write to another array, from which side we should get into it. <br><br>  The following figure shows an example of the source data and one of the steps of the algorithm. <br><br><img src="https://habrastorage.org/storage/172825c2/1d41516f/f67352c8/af77b987.png"><br><br>  In each of the already passed cells exactly one arrow leads.  This arrow shows which side needs to come into this cell in order to get the minimum weight recorded in the cell. <br><br>  After passing through the entire array, it will be necessary to trace the route itself from the last cell, following the arrows in the opposite direction. <br><br><h3>  Tasks on subsequences </h3><br>  Consider the problem of increasing subsequence. <br><br>  <b>Task 4.</b> Given a sequence of integers.  It is necessary to find its longest strictly increasing subsequence. <br><br>  Let's start solving the problem from the beginning - we will look for the answer, starting with the first members of this sequence.  For each number <i>i,</i> we will look for the largest ascending subsequence ending with an element in position <i>i</i> .  Let the original sequence be stored in array A. In the array L, we write the lengths of the maximal subsequences ending in the current element.  Let we find all L [i] for 1 &lt;= <i>i</i> &lt;= <i>k</i> - 1. Now we can find L [k] as follows.  We look through all elements A [i] for 1 &lt;= <i>i</i> &lt; <i>k</i> - 1. If <br>  A [i] &lt;A [k], then the <i>k</i> -th element can be a continuation of a subsequence terminated by the element A [i].  The length of the obtained subsequence will be 1 greater than L [i].  To find L [k], you need to iterate through all <i>i</i> from 1 to k - 1: <br>  L [k] = max (L [i]) + 1, where the maximum is taken over all <i>i</i> such that A [i] &lt;A [k] and <br>  1 &lt;= <i>i</i> &lt; <i>k</i> . <br><br>  Here, the maximum of the empty set will be considered equal to 0. In this case, the current element will be the only one in the selected sequence, and will not be a continuation of one of the previous ones.  After filling the array L, the length of the largest increasing subsequence will be equal to the maximum element L. <br><br>  To restore the subsequence itself, you can also save the number of the previous selected element for each element, for example, in the array N. <br><br>  Consider the solution of this problem on the example of the sequence 2, 8, 5, 9, 12, 6. Since up to 2 there is not a single element, the maximum subsequence contains only one element - L [1] = 1, and there is not one before it - N [1] = 0. Next, <br>  2 &lt;8, so 8 can be a continuation of the sequence with the previous element.  Then L [2] = 2, N [2] = 1. <br><br><img src="https://habrastorage.org/storage/52ef5559/3fdd0d31/fda76b96/81409ba7.png"><br><br>  Less than A [3] = 5, only the element A [1] = 2, so 5 can be the continuation of only one subsequence - the one that contains 2. Then <br>  L [3] = L [1] + 1 = 2, N [3] = 1, since 2 is in position number 1. Similarly, we perform three more steps of the algorithm and get the final result. <br><br><img src="https://habrastorage.org/storage/ef52fe00/e63f448e/56aa00ee/6c4207f9.png"><br><br>  Now choose the maximum element in the array L and restore the subsequence 2, 5, 9, 12 by the array N. <br><br>  Another classic dynamic programming problem is the palindrome task. <br><br>  <b>Task 5.</b> Given a string of capital letters of the Latin alphabet.  It is necessary to find the length of the longest palindrome, which can be obtained by crossing out some letters from this string. <br><br>  Denote this string by S, and its characters by S [i], 1 &lt;= <i>i</i> &lt;= <i>n</i> .  We will consider the possible substrings of this string from the <i>i</i> -th to <i>jth</i> character, denote them by <i>S</i> ( <i>i</i> , <i>j</i> ).  The lengths of the maximum palindromes for substrings will be written into a square array L: L [i] [j] - the length of the maximum palindrome, which can be obtained from the substring <i>S</i> ( <i>i</i> , <i>j</i> ). <br><br>  Let's start solving the problem with the simplest substrings.  For a string of one character (that is, substrings of the form <i>S</i> ( <i>i</i> , <i>i</i> )), the answer is obvious - no need to cross out anything, such a string will be a palindrome.  For a string of two characters <i>S</i> ( <i>i</i> , <i>i</i> + 1), two options are possible: if the characters are equal, then we have a palindrome, nothing needs to be crossed out.  If the characters are not equal, then delete any. <br><br>  Suppose now that we are given a substring <i>S</i> ( <i>i</i> , <i>j</i> ).  If the first (S [i]) and last (S [j]) characters of the substring do not match, then one of them just needs to be crossed out.  Then we will have a substring of <i>S</i> ( <i>i</i> , <i>j</i> - 1) or <i>S</i> ( <i>i</i> + 1, <i>j</i> ) - that is, we will reduce the task to a subtask: L [i] [j] = max (L [i] [j - 1] , L [i + 1] [j]).  If the first and last symbols are equal, then we can leave both, but it is necessary to know the solution to the problem <i>S</i> ( <i>i</i> + 1, <i>j</i> - 1): <br>  L [i] [j] = L [i + 1] [j - 1] + 2. <br><br>  Consider the decision on the example of the string ABACCBA.  First of all, fill in the diagonal of the array with units; they will correspond to the substrings <i>S</i> ( <i>i</i> , <i>i</i> ) of one character.  Then we begin to consider substrings of length two.  In all substrings, except <i>S</i> (4, 5), the characters are different, therefore, we write 1 in the corresponding cells, and 2 in L [4] [5]. <br><br>  It turns out that we will fill the array along the diagonals, starting with the main diagonal leading from the upper left corner to the lower right corner.  For substrings of length 3, the following values ‚Äã‚Äãare obtained: in the ABA substring, the first and last letters are equal, therefore <br>  L [1] [3] = L [2] [2] + 2. In the remaining substrik the first and the last letters are different. <br><br>  BAC: L [2] [4] = max (L [2] [3], L [3] [4]) = 1. <br>  ACC: L [3] [5] = max (L [3] [4], L [4] [5]) = 2. <br>  CCB: L [4] [6] = max (L [4] [5], L [5] [6]) = 2. <br>  CBA: L [5] [7] = max (L [5] [6], L [6] [7]) = 1. <br><br>  Continuing further similar reasoning, we will fill all the cells under the diagonal and in the cell L [1] [7] = 6 we will get the answer. <br><br><img src="https://habrastorage.org/storage/30432524/8af4c179/e5eca219/0254c267.png"><br><br>  If in the task it is necessary to output not the length, but the palindrome itself, then in addition to the length array we need to build an array of transitions - for each cell, remember which of the cases was implemented (in the figure for clarity, instead of numeric values ‚Äã‚Äãthat encode the transitions, the corresponding arrows are drawn) . <br><br><img src="https://habrastorage.org/storage/7f6efda0/0cb4014f/33914c16/be6a4cf7.png"></div><p>Source: <a href="https://habr.com/ru/post/113108/">https://habr.com/ru/post/113108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../113100/index.html">Wired UK with personalized covers</a></li>
<li><a href="../113101/index.html">Installation and configuration: Nginx + php5-fpm</a></li>
<li><a href="../113102/index.html">We direct corporate order in Outlook: signatures, names, Plain Text</a></li>
<li><a href="../113104/index.html">Convenient rescue DIY</a></li>
<li><a href="../113106/index.html">Time Lapse Photo Motion on Samsung NX100</a></li>
<li><a href="../113109/index.html">Blocking the Internet cost Egypt at least $ 90 million</a></li>
<li><a href="../113112/index.html">Pwn2Own 2011</a></li>
<li><a href="../113114/index.html">Magic layer</a></li>
<li><a href="../113117/index.html">Scaling web applications with HMVC</a></li>
<li><a href="../113118/index.html">C # problem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>