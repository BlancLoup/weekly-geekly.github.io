<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>I study Rust: How I made UDP chat with Azul</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue to study Rust. I still do not know much, therefore I make many mistakes. Last time I tried to make a snake game. I tried cycles, collection...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>I study Rust: How I made UDP chat with Azul</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/zl/na/ih/zlnaihhfzb9dcso-bkwp_extqd4.jpeg"><br><br>  I continue to study Rust.  I still do not know much, therefore I make many mistakes.  Last time I tried to make a <a href="https://habr.com/post/428830/">snake</a> game.  I tried cycles, collections, working with 3D <a href="https://github.com/three-rs/three">Three.rs</a> .  I learned about <a href="https://github.com/ggez/ggez">ggez</a> and <a href="https://github.com/amethyst/amethyst">Amethyst</a> .  This time I tried to make the client and server for a chat.  For GUI used <a href="https://github.com/maps4print/azul">Azul</a> .  Just watched <a href="https://github.com/PistonDevelopers/conrod/">Conrod</a> , <a href="https://github.com/DenisKolodin/yew">Yew</a> and <a href="https://github.com/redox-os/orbtk">Orbtk</a> .  I tried multithreading, channels and working with the network.  I took into account the mistakes of the previous article and tried to make this more detailed.  For details, welcome under cat. <a name="habracut"></a><br><br>  ‚Üí <a href="https://github.com/VictoremWinbringer/UdpClientServerChat">Sources running on Windows 10 x64</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For network communication, I used UDP because I want to make my next project using this protocol and wanted to practice with it here.  For the GUI, I quickly googled the projects on Rust, looked at the basic examples for them, and I was hooked on Azul because it uses the Document Object Model and a style engine similar to CSS, and I was engaged in web development for a long time.  In general, I chose the Framework subjectively.  He, so far, in deep alpha: scrolling does not work, input focus does not work, there is no cursor.  In order to enter data into the text field, you need to hover the mouse on it and hold it right above it while typing.  <a href="https://github.com/maps4print/azul/issues/75">Read more ...</a> <br><br>  Actually, most of the article - this is the comments to the code. <br><br><h2>  Azul </h2><br>  GUI framework using functional style, DOM, CSS.  Your interface consists of a root element, which has many descendants, which may have their own descendants such as, for example, in HTML and XML.  The entire interface is created based on data from a single DataModel.  In it all the data is transferred to the view in general.  If anyone is familiar with ASP.NET, then Azul and its DataModel are like Razor and its ViewModel.  Like HTML, you can bind functions to DOM element events.  You can stylize elements using the CSS framework.  This is not the same CSS as in HTML, but very similar to it.  There is also a two-way binding like in Angular or MVVM in WPF, UWP.  Read more <a href="https://azul.rs/">on the site</a> . <br><br><h2>  Overview of the rest of the frameworks </h2><br><ul><li>  <a href="https://github.com/redox-os/orbtk">Orbtk</a> - Almost the same as Azul and also in deep alpha </li><li>  <a href="https://github.com/PistonDevelopers/conrod/">Conrod</a> - <a href="https://www.youtube.com/watch%3Fv%3Dn2UrjogA0j0">Video</a> You can create cross-platform desktop applications. </li><li>  <a href="https://github.com/DenisKolodin/yew">Yew</a> - WebAssembly and is similar to React.  For web development. </li></ul><br><h2>  Customer </h2><br><h3>  A structure in which helper functions are grouped to read and write to a socket. </h3><br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatService</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ChatService { <span class="hljs-comment"><span class="hljs-comment">//1 fn read_data(socket: &amp;Option&lt;UdpSocket&gt;) -&gt; Option&lt;String&gt; { //2 let mut buf = [0u8; 4096]; match socket { Some(s) =&gt; { //3 match s.recv(&amp;mut buf) { //4 Ok(count) =&gt; Some(String::from_utf8(buf[..count].into()) .expect("can't parse to String")), Err(e) =&gt; { //5 println!("Error {}", e); None } } } _ =&gt; None, } } //6 fn send_to_socket(message: String, socket: &amp;Option&lt;UdpSocket&gt;) { match socket { //7 Some(s) =&gt; { s.send(message.as_bytes()).expect("can't send"); } _ =&gt; return, } } }</span></span></code> </pre> <br><ol><li>  We read data from a socket </li><li>  A buffer for data that will be read from the socket. </li><li>  Blocking call  Here, the thread of execution stops until the data is read or timeout occurs. </li><li>  Get the string from the byte array in UTF8. </li><li>  We get here if the connection is broken by timeout or another error has occurred. </li><li>  Sends a string to the socket. </li><li>  We convert the string to bytes in UTF8 encoding and send data to the socket.  Writing data to a socket is not blocking, i.e.  The execution thread will continue its work.  If the data could not be sent, then we stop the program with the message ‚Äúcan't send‚Äù. </li></ol><br><h3>  A structure that groups functions to handle user-generated events and changes to our DataModel. </h3><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span></span> {} <span class="hljs-comment"><span class="hljs-comment">//1 const TIMEOUT_IN_MILLIS: u64 = 2000; impl Controller { //2 fn send_pressed(app_state: &amp;mut azul::prelude::AppState&lt;ChatDataModel&gt;, _event: azul::prelude::WindowEvent&lt;ChatDataModel&gt;) -&gt; azul::prelude::UpdateScreen { //3 let data = app_state.data.lock().unwrap(); //4 let message = data.messaging_model.text_input_state.text.clone(); data.messaging_model.text_input_state.text = "".into(); //5 ChatService::send_to_socket(message, &amp;data.messaging_model.socket); //6 azul::prelude::UpdateScreen::Redraw } //7 fn login_pressed(app_state: &amp;mut azul::prelude::AppState&lt;ChatDataModel&gt;, _event: azul::prelude::WindowEvent&lt;ChatDataModel&gt;) -&gt; azul::prelude::UpdateScreen { //8 use std::time::Duration; //9 if let Some(ref _s) = app_state.data.clone().lock().unwrap().messaging_model.socket { return azul::prelude::UpdateScreen::DontRedraw; } //10 app_state.add_task(Controller::read_from_socket_async, &amp;[]); //11 app_state.add_daemon(azul::prelude::Daemon::unique(azul::prelude::DaemonCallback(Controller::redraw_daemon))); //12 let mut data = app_state.data.lock().unwrap(); //13 let local_address = format!("127.0.0.1:{}", data.login_model.port_input.text.clone().trim()); //14 let socket = UdpSocket::bind(&amp;local_address) .expect(format!("can't bind socket to {}", local_address).as_str()); //15 let remote_address = data.login_model.address_input.text.clone().trim().to_string(); //16 socket.connect(&amp;remote_address) .expect(format!("can't connect to {}", &amp;remote_address).as_str()); //17 socket.set_read_timeout(Some(Duration::from_millis(TIMEOUT_IN_MILLIS))) .expect("can't set time out to read"); // 18 data.logged_in = true; // 19 data.messaging_model.socket = Option::Some(socket); //20 azul::prelude::UpdateScreen::Redraw } //21 fn read_from_socket_async(app_data: Arc&lt;Mutex&lt;ChatDataModel&gt;&gt;, _: Arc&lt;()&gt;) { //22 let socket = Controller::get_socket(app_data.clone()); loop { //23 if let Some(message) = ChatService::read_data(&amp;socket) { //24 app_data.modify(|state| { //25 state.messaging_model.has_new_message = true; //26 state.messaging_model.messages.push(message); }); } } } //27 fn redraw_daemon(state: &amp;mut ChatDataModel, _repres: &amp;mut azul::prelude::Apprepres) -&gt; (azul::prelude::UpdateScreen, azul::prelude::TerminateDaemon) { //28 if state.messaging_model.has_new_message { state.messaging_model.has_new_message = false; (azul::prelude::UpdateScreen::Redraw, azul::prelude::TerminateDaemon::Continue) } else { (azul::prelude::UpdateScreen::DontRedraw, azul::prelude::TerminateDaemon::Continue) } } //29 fn get_socket(app_data: Arc&lt;Mutex&lt;ChatDataModel&gt;&gt;) -&gt; Option&lt;UdpSocket&gt; { //30 let ref_model = &amp;(app_data.lock().unwrap().messaging_model.socket); //31 match ref_model { Some(s) =&gt; Some(s.try_clone().unwrap()), _ =&gt; None } } }</span></span></code> </pre><br><ol><li>  Timeout in milliseconds, after which a blocking read operation from the socket will be interrupted. </li><li>  The function works when the user wants to send a new message to the server. </li><li>  We get possession of mutex with our data model.  This blocks the interface redraw stream until the mutex is released. </li><li>  We make a copy of the text entered by the user to pass it on and clear the text entry field. </li><li>  We send the message. </li><li>  We inform the Framework that after processing this event you need to redraw the interface. </li><li>  The function works when the user wants to connect to the server. </li><li>  We connect the structure to represent the length of time from the standard library. </li><li>  If we are already connected to the server, then we stop the execution of the function by telling the Framework that there is no need to redraw the interface. </li><li>  Add a task that will be executed asynchronously in a stream from the thread pool of the Azul Framework.  Accessing the mutex with the data model blocks updating the UI until the mutex is released. </li><li>  Add a recurring task that runs in the main thread.  Any lengthy computation in this daemon blocks interface updates. </li><li>  We get in possession muteks. </li><li>  We read the port entered by the user and create a local address based on it, we will listen. </li><li>  We create a UDP socket that reads packets arriving at the local address. </li><li>  We read the server address entered by the user. </li><li>  We tell our UDP socket to read packets only from this server. </li><li>  Set the timeout for a read operation from the socket.  Writing to the socket occurs without waiting, i.e., we simply write data and do not wait for anything, and a read operation from the socket blocks the stream and waits until data can be read.  If you do not set the timeout, the read operation from the socket will wait indefinitely. </li><li>  We set the flag indicating that the user has already connected to the server. </li><li>  We transfer to the data model the created socket. </li><li>  We inform the Framework that after processing this event you need to redraw the interface. </li><li>  An asynchronous operation that runs in the thread pool of the Azul Framework. </li><li>  Get a copy of the socket from our data model. </li><li>  We are trying to read data from the socket.  If you do not make a copy of the socket and directly wait here, until a message comes from the socket, which is in the mutex in our data model, then the entire interface will stop updating until we release the mutex. </li><li>  If we receive a message, then we change our data model. The modification does the same as lock (). Unwrap (), passing the result to the lambda and releasing the mutex after the lambda code ends. </li><li>  Set the flag, indicating that we have a new message. </li><li>  Add a message to the array of all chat messages. </li><li>  Repeated synchronous operation running in the main thread. </li><li>  If we have a new message, then we inform the Framework that we need to redraw the interface from scratch and continue the work of this daemon; otherwise, we will not draw the interface from the beginning, but we still call this Function in the next cycle. </li><li>  Creates a copy of our socket in order not to keep the mutex locked with our data model. </li><li>  We get ownership of the mutex and get a reference to the socket. </li><li>  Create a copy of the socket.  Mutex will be released automatically when exiting the Function. </li></ol><br><h3>  Asynchronous data processing and daemons in Azul </h3><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Problem - blocks UI :( fn start_connection(app_state: &amp;mut AppState&lt;MyDataModel&gt;, _event: WindowEvent&lt;MyDataModel&gt;) -&gt; UpdateScreen { //   app_state.add_task(start_async_task, &amp;[]); //  app_state.add_daemon(Daemon::unique(DaemonCallback(start_daemon))); UpdateScreen::Redraw } fn start_daemon(state: &amp;mut MyDataModel, _repres: &amp;mut Apprepres) -&gt; (UpdateScreen, TerminateDaemon) { // UI    thread::sleep(Duration::from_secs(10)); state.counter += 10000; (UpdateScreen::Redraw, TerminateDaemon::Continue) } fn start_async_task(app_data: Arc&lt;Mutex&lt;MyDataModel&gt;&gt;, _: Arc&lt;()&gt;) { // simulate slow load app_data.modify(|state| { // UI    thread::sleep(Duration::from_secs(10)); state.counter += 10000; }); }</span></span></code> </pre><br>  The daemon is always executed in the main thread, so blocking is inevitable there.  With an asynchronous task, if you do, for example, there will be no lock for 10 seconds. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_async_task</span></span></span></span>(app_data: Arc&lt;Mutex&lt;MyDataModel&gt;&gt;, _: Arc&lt;()&gt;) { <span class="hljs-comment"><span class="hljs-comment">//  UI.  . thread::sleep(Duration::from_secs(10)); app_data.modify(|state| { state.counter += 10000; }); }</span></span></code> </pre><br>  The modify function calls lock () on the mutex with the data model, therefore it blocks the update of the interface during its execution. <br><br><h3>  Our styles </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CUSTOM_CSS: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">" .row { height: 50px; } .orange { background: linear-gradient(to bottom, #f69135, #f37335); font-color: white; border-bottom: 1px solid #8d8d8d; }"</span></span>;</code> </pre><br><h3>  Actually, the functions for creating our DOM for displaying it to the user </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> azul::prelude::Layout <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ChatDataModel { <span class="hljs-comment"><span class="hljs-comment">//1 fn layout(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //2 if self.logged_in { self.chat_form(info) } else { self.login_form(info) } } } impl ChatDataModel { //3 fn login_form(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //4 let button = azul::widgets::button::Button::with_label("Login") //5 .dom() //6 .with_class("row") //7 .with_class("orange") //8 .with_callback( azul::prelude::On::MouseUp, azul::prelude::Callback(Controller::login_pressed)); //9 let port_label = azul::widgets::label::Label::new("Enter port to listen:") .dom() .with_class("row"); //10 let port = azul::widgets::text_input::TextInput::new() //11 .bind(info.window, &amp;self.login_model.port_input, &amp;self) .dom(&amp;self.login_model.port_input) .with_class("row"); // 9 let address_label = azul::widgets::label::Label::new("Enter server address:") .dom() .with_class("row"); //10 let address = azul::widgets::text_input::TextInput::new() //11 .bind(info.window, &amp;self.login_model.address_input, &amp;self) .dom(&amp;self.login_model.address_input) .with_class("row"); //12 azul::prelude::Dom::new(azul::prelude::NodeType::Div) .with_child(port_label) .with_child(port) .with_child(address_label) .with_child(address) .with_child(button) } //13 fn chat_form(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //14 let button = azul::widgets::button::Button::with_label("Send") .dom() .with_class("row") .with_class("orange") .with_callback(azul::prelude::On::MouseUp, azul::prelude::Callback(Controller::send_pressed)); //15 let text = azul::widgets::text_input::TextInput::new() .bind(info.window, &amp;self.messaging_model.text_input_state, &amp;self) .dom(&amp;self.messaging_model.text_input_state) .with_class("row"); //12 let mut dom = azul::prelude::Dom::new(azul::prelude::NodeType::Div) .with_child(text) .with_child(button); //16 for i in &amp;self.messaging_model.messages { dom.add_child(azul::widgets::label::Label::new(i.clone()).dom().with_class("row")); } dom } }</span></span></code> </pre><br><ol><li>  The function that creates the final DOM, and is called whenever the interface needs to be redrawn. </li><li>  If we are already connected to the server, then we show the form for sending and reading messages, otherwise we display the form for connecting to the server. </li><li>  Creates a form to enter data required to connect to the server. </li><li>  Create a button labeled Login. </li><li>  Convert it to a DOM object. </li><li>  Add a row class to it. </li><li>  Add css class orange to it. </li><li>  Add an event handler to click on the button. </li><li>  Create a text label with the text to display to the user and the css class row. </li><li>  Create a text field for entering text with text from the properties of our model and the css class row. </li><li>  Bind the text field to the property of our DataModel.  This is a two-way binding.  Now editing TextInput automatically changes the text in the property of our model and the reverse is also true.  If we change the text in our model, the text in TextInput will change. </li><li>  Create a root DOM element in which we put our UI elements. </li><li>  Creates a form for sending and reading messages. </li><li>  Create a button with the text "Send" and css classes "row", "orange" and an event handler when it is clicked. </li><li>  Create a text entry field with two-way binding with the property of the model self.messaging_model.text_input_state and the css class ‚Äúrow‚Äù. </li><li>  Add text labels that display messages that were written in the chat. </li></ol><br><h3>  Our model, which stores the state of our interface </h3><br>  The Azul documentation says that it should store all application data, including the connection to the database, so I put a UDP socket in it. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//1 #[derive(Debug)] //2 struct ChatDataModel { //3 logged_in: bool, //4 messaging_model: MessagingDataModel, //5 login_model: LoginDataModel, } #[derive(Debug, Default)] struct LoginDataModel { //6 port_input: azul::widgets::text_input::TextInputState, //7 address_input: azul::widgets::text_input::TextInputState, } #[derive(Debug)] struct MessagingDataModel { //8 text_input_state: azul::widgets::text_input::TextInputState, //9 messages: Vec&lt;String&gt;, //10 socket: Option&lt;UdpSocket&gt;, //11 has_new_message: bool, }</span></span></code> </pre><br><ol><li>  This will allow us to display our structure as a string in a pattern like {:?} </li><li>  Our data model.  In order to be able to use it in Azul.  She must implement the treyt layout. </li><li>  Flag to check if the user is connected to the server or not. </li><li>  Model for displaying the form for sending messages to the server and saving messages received from the server. </li><li>  Model to display the form to connect to the server. </li><li>  The port that the user entered.  We will listen to it with our socket. </li><li>  The address of the server that the user entered.  We will connect to it. </li><li>  User message.  We will send it to the server. </li><li>  The message array that came from the server. </li><li>  The socket through which we communicate with the server. </li><li>  Flag to check if we received a new message from the server. </li></ol><br><h3>  And finally, the main entry point into the application.  Runs a loop from GUI drawing and user input processing. </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//1 let app = azul::prelude::App::new(ChatDataModel { logged_in: false, messaging_model: MessagingDataModel { text_input_state: azul::widgets::text_input::TextInputState::new(""), messages: Vec::new(), socket: None, has_new_message: false, }, login_model: LoginDataModel::default(), }, azul::prelude::AppConfig::default()); // 2 let mut style = azul::prelude::css::native(); //3 style.merge(azul::prelude::css::from_str(CUSTOM_CSS).unwrap()); //4 let window = azul::prelude::Window::new(azul::prelude::WindowCreateOptions::default(), style).unwrap(); //5 app.run(window).unwrap(); }</span></span></code> </pre><br><ol><li>  Create an application with starting data. </li><li>  Styles used by the application by default. </li><li>  Add our own styles to them. </li><li>  Create a window that will display our application. </li><li>  Run the application in this window. </li></ol><br><h2>  Server </h2><br><h3>  Main entry point to the application </h3><br>  Here we usually have a console application. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//1 let socket = create_socket(); //2 let (sx, rx) = mpsc::channel(); //3 start_sender_thread(rx, socket.try_clone().unwrap()); loop { //4 sx.send(read_data(&amp;socket)).unwrap(); } }</span></span></code> </pre><br><ol><li>  Create a socket. </li><li>  Create a one-way channel with one sx message sender and multiple rx recipients. </li><li>  We start the distribution of messages to all recipients in a separate thread. </li><li>  We read data from the socket and send it to the stream that sends messages to clients connected to the server. </li></ol><br><h3>  Function to create a stream for sending messages to clients </h3><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_sender_thread</span></span></span></span>(rx: mpsc::Receiver&lt;(<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;, SocketAddr)&gt;, socket: UdpSocket) { <span class="hljs-comment"><span class="hljs-comment">//1 thread::spawn(move || { //2 let mut addresses = Vec::&lt;SocketAddr&gt;::new(); //3 loop { //4 let (bytes, pre) = rx.recv().unwrap(); // 5 if !addresses.contains(&amp;pre) { println!(" {} connected to server", pre); addresses.push(pre.clone()); } //6 let result = String::from_utf8(bytes) .expect("can't parse to String") .trim() .to_string(); println!("received {} from {}", result, pre); //7 let message = format!("FROM: {} MESSAGE: {}", pre, result); let data_to_send = message.as_bytes(); //8 addresses .iter() .for_each(|s| { //9 socket.send_to(data_to_send, s) //10 .expect(format!("can't send to {}", pre).as_str()); }); } }); }</span></span></code> </pre><br><ol><li>  Launch a new thread.  move means that variables are taken over by lambda and flow, respectively.  More specifically, our new thread will ‚Äúswallow‚Äù the rx and socket variables. </li><li>  A collection of addresses connected to our customers.  We will send all our messages to all of them.  In general, in a real project, it would be necessary to do the processing of disconnecting the client from us and removing its address from this array. </li><li>  Run an infinite loop. </li><li>  We read data from the channel.  Here the stream will be blocked until new data arrives. </li><li>  If this address is not in our array, then add it there. </li><li>  We decode the UTF8 string from the byte array. </li><li>  We create an array of bytes that we are going to send to all our clients. </li><li>  We pass through the collection of addresses and send the data to each. </li><li>  The write operation in the UDP socket is non-blocking, so here the Function will not wait until the message arrives at the receiver and is executed almost instantly. </li><li>  expect in case of an error will make an emergency exit from the program with the specified message. </li></ol><br><h3>  The function creates a socket based on user input. </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIMEOUT_IN_MILLIS: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span> = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_socket</span></span></span></span>() -&gt; UdpSocket { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Enter port to listen"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1 let local_port: String = read!("{}\n"); let local_address = format!("127.0.0.1:{}", local_port.trim()); println!("server address {}", &amp;local_address); //2 let socket = UdpSocket::bind(&amp;local_address.trim()) .expect(format!("can't bind socket to {}", &amp;local_address).as_str()); //3 socket.set_read_timeout(Some(Duration::from_millis(TIMEOUT_IN_MILLIS))) .expect("can't set time out to read"); //4 socket }</span></span></code> </pre><br><ol><li>  We read the port that our server will listen to and create a local server address based on it. </li><li>  Create a UDP socket listening on this address. </li><li>  Set the timeout for the read operation.  The read operation is blocking and it will block the stream until new data arrives or timeout occurs. </li><li>  We return the created socket from the function. </li><li>  The function reads data from the socket and returns it along with the sender's address. </li></ol><br><h3>  Function to read data from socket </h3><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_data</span></span></span></span>(socket: &amp;UdpSocket) -&gt; (<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;, SocketAddr) { <span class="hljs-comment"><span class="hljs-comment">//1 let mut buf = [0u8; 4096]; //2 loop { match socket.recv_from(&amp;mut buf) { //3 Ok((count, address)) =&gt; { //4 return (buf[..count].into(), address); } //5 Err(e) =&gt; { println!("Error {}", e); continue; } }; } }</span></span></code> </pre><br><ol><li>  Buffer - a place where we will read the data. </li><li>  Starts a loop that will run until valid data is read. </li><li>  We get the number of bytes read and the sender's address. </li><li>  We make a slice of the array from its beginning to the quantities read bytes and convert it into a vector of bytes. </li><li>  If there is a timeout or other error, then go to the next iteration of the cycle. </li></ol><br><h2>  About layers in the application </h2><br><div class="spoiler">  <b class="spoiler_title">Oftop: A small educational program for the two Junas at work.</b>  <b class="spoiler_title">I decided to post here, can someone come in handy.</b>  <b class="spoiler_title">Joona Sharpisty poet examples in C # and we are talking about ASP.NET</b> <div class="spoiler_text">  So, there was nothing to do, it was in the evening, and I decided to write a small educational program for Artyom and Victor.  Here we go. <br><br>  Actually, I added it here because I can only write articles once a week, but I already have the material and next week I wanted to fill something else with Habr. <br><br>  Usually, the application is divided into layers.  In each layer there are objects that implement the behavior characteristic of the layer in which they are located.  So.  Here are the layers. <br><br><ol><li>  Presentation layer </li><li>  Business logic layer. </li><li>  Data access layer </li><li>  Entities (User, Animal, etc.) </li></ol><br><br>  Each layer can contain its DTO and completely arbitrary classes with arbitrary methods.  The main thing is that they perform the functionality associated with the layer in which they are located.  In simple applications, some of the layers may be missing.  For example, the presentation layer can be implemented through the MVC, MVP, MVVM pattern.  That is absolutely not necessary.  The main thing is that the classes that are in this layer implement the functionality assigned to the layer.  Remember, patterns and architecture are only guidelines, not guidelines.  Pattern and architecture is not law, it is advice. <br><br>  And so, we will consider each layer on the example of a standard ASP.NET application using the standard Entity Framework. <br><br><h3>  Presentation layer </h3><br>  We have MVC here.  This is the layer that provides user interaction.  Commands come here and these users get from here.  Not necessarily people, if we have an API, then our user is another program.  Machines communicate with machines. <br><br><h3>  Business logic layer </h3><br>  Here, usually, classes call Service, for example, UserService, although there may be anything at all.  Just a set of classes with methods.  The main thing is to make calculations and calculations of our application.  This is the thickest and most bulky layer.  Here most of the code and the various classes.  This, in fact, is our application. <br><br><h3>  Data access layer </h3><br>  Usually we have here EF implements the patterns Unit Of Work and Repository.  Yes, DbContext is, one might say, Unit Of Work, and DB sets it is Repository.  This is, in fact, the place where we put the data and where we get it from.  Regardless of whether the data source is a database, an API of another application, a cache in Memory, or just some random number generator.  Any data source. <br><br><h3>  Entities </h3><br>  Yes, just any User, Animal and so on.  One important note - they may have some behavior characteristic only for them.  For example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LastName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FullName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FirstName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + LastName; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">User user</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FullName == user.FullName; } }</code> </pre> <br><h3>  Well, quite a simple example.  Shoby was </h3><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-comment"><span class="hljs-comment">//Entities class User { public int Id { get; set; } public string Name { get; set; } } //Data Access Layer class UserRepository { private readonly Dictionary&lt;int, User&gt; _db; public UserRepository() { _db = new Dictionary&lt;int, User&gt;(); } public User Get(int id) { return _db[id]; } public void Save(User user) { _db[user.Id] = user; } } //Business Logic Layer class UserService { private readonly UserRepository _repo; private int _currentId = 0; public UserService() { _repo = new UserRepository(); } public void AddNew() { _currentId++; var user = new User { Id = _currentId, Name = _currentId.ToString() }; _repo.Save(user); } public string GetAll() { StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= _currentId; i++) { sb.AppendLine($"Id: {i} Name: {_repo.Get(i).Name}"); } return sb.ToString(); } } //presentation Layer aka Application Layer class UserController { private readonly UserService _service; public UserController() { _service = new UserService(); } public string RunExample() { _service.AddNew(); _service.AddNew(); return _service.GetAll(); } } namespace ConsoleApp1 { class Program { static void Main(string[] args) { var controller = new UserController(); Console.WriteLine(controller.RunExample()); Console.ReadLine(); } } }</span></span></code> </pre> <br></div></div><br><h2>  PS </h2><br>  ,              .  ,          .   &lt;3. </div><p>Source: <a href="https://habr.com/ru/post/433624/">https://habr.com/ru/post/433624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433612/index.html">FCC: SpaceX satellites in orbit - a source of debris dangerous to Earth‚Äôs inhabitants</a></li>
<li><a href="../433614/index.html">How to take control of network infrastructure. Part one. Hold</a></li>
<li><a href="../433616/index.html">Apple recognized problems with SSD in MacBook Pro 13</a></li>
<li><a href="../433618/index.html">"Warm lamp" sound with your own hands. What if you cross the store, club and workshop?</a></li>
<li><a href="../433620/index.html">How SystemUI in Android works</a></li>
<li><a href="../433628/index.html">Culture feedback: how not to slide to the charges</a></li>
<li><a href="../433630/index.html">A step closer to the HIV vaccine: a study of titers of serum neutralizing antibodies in monkeys</a></li>
<li><a href="../433632/index.html">Another mobile application ‚Äúmerged‚Äù data of its users</a></li>
<li><a href="../433634/index.html">Beehive Monitoring | I Dadan and Paul Ukrainian | Data redundancy</a></li>
<li><a href="../433636/index.html">Flashlight-kubotan: a good idea or dummy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>