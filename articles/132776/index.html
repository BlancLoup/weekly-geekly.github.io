<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AI Challenge: Ants AI Challenge: liven up the "ants"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post I will tell you how to write a pretty good bot for Google AI Challenge . It is noteworthy that complex technologies associated with AI wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>AI Challenge: Ants AI Challenge: liven up the "ants"</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/storage1/9cf5e474/5b3b8110/a2e81e7c/ca76d540.png">  In this post I will tell you how to write a pretty good bot for <a href="http://habrahabr.ru/blogs/sport_programming/130979/">Google AI Challenge</a> .  It is noteworthy that complex technologies associated with AI will not be needed, and the basic implementation fits into a thousand lines of C ++ code.  The methods themselves can be considered as a Generic algorithm, and on the basis of them you can build a bot that takes into account some strategic features that may be even better to play.  In any case, a good ‚Äúquick start‚Äù for those who haven‚Äôt succeeded yet. <br><a name="habracut"></a><br><h5>  1. Some experience of participation in the AI ‚Äã‚ÄãChallenge </h5><br>  Judging by the comments to other topics about AI Challenge, many have questions regarding the "local" rating system.  Actually comments. <br><br>  1. The rating of a bot is evaluated relative to its success in games against other bots, i.e.  the Skill figure is a relative value, and after each download the version on the server is reset to zero (since it is not known whether the new version will be better than the previous one). <br>  2. Each successful game adds to Skill a certain amount, depending on the place (remember, the goal of the game is not to collect food, to grow a huge colony, but to capture enemy anthills) and from the skill of other players - and the larger the game number, the smaller this increment;  Thus, casual loss (at first) to a weak player will slow down the increase in Skill for a long time. <br>  3. For approximate stabilization of the rating in the current situation it takes about 5-7 days (‚Äúmatches‚Äù are held quite rarely). <br><br>  It follows from the above that it is already too late to try to ‚Äúiteratively‚Äù adjust the algorithm to other players, therefore, it is highly desirable to test the bot locally, and especially not to waste time on the Starter Package. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The time limit for the execution of the algorithm is one turn: 500 ms, and can vary with the turntime parameter.  However, it is highly desirable to complete the execution of the algorithm faster than this threshold by at least 50 ms, otherwise there is a high probability of getting a timeout due to input / output buffering (all game data transfer is done through pipes), and sometimes funny things happen: <br><br><img src="https://habrastorage.org/storage1/140e3391/4e4913fd/fd759111/eb7eb05c.png"><br><br>  The memory limit is 2GB (32bit platform limit), guaranteed (rather, it reads as ‚Äúpromised‚Äù) of the order of 1.5GB of memory, which will not be spread over the swap file.  This is a fairly large number (for cards 200 per 200 cells), which directly prompts caching intermediate results, which we will do to get a good algorithm for finding paths to objects. <br><br><h5>  2. Algorithm for finding the path </h5><br>  It is difficult to argue about how good ‚Äúthis or that‚Äù strategy would be, while the ants do not know how to walk ‚Äúon their own‚Äù through the maze.  According to experience, a qualitative implementation of finding a path is always better than a good strategy, if using ‚Äúexclusive OR‚Äù;  better of course "both that and that". <br><br>  Suppose that we already know where to go (we will discuss this a little later), and what ant should do it.  It remains to calculate the initial direction of motion (N, E, S, W) and command the system.  For this, it is necessary to calculate the shortest path to the target object (of course, we can cover the entire map with ‚Äúrandom movements‚Äù, in theory, but the enemy will have destroyed us for a long time, in practice). <br><br><img align="right" src="https://habrastorage.org/storage1/d0122378/930069b2/d669022b/c2c02d73.png">  If the map did not contain impassable areas of "water" (dark blue cells), then the task would be trivial;  Consider the red line connecting the "ant" and "water."  Because  the ant can walk only one cell in four directions, then the distance to the object (without taking into account obstacles) coincides with the <a href="http://en.wikipedia.org/wiki/Manhattan_distance">Manhattan distance</a> .  The path to the object will always occupy the same number of cells if we use the increments in the right direction.  Subtract from the coordinates of the target (x1, y1) coordinates of the ant (x0, y0) and get the number of steps (| x1-x0 |) with an increment of X: sign (x1-x0) and the number (| y1-y0 |) of Y: sign (y1-y0) leading to the goal. <br><br><img align="left" src="https://habrastorage.org/storage1/15311089/3b92d2e5/9847321e/6267beab.png">  Here is a clear illustration of the fact that the length of the path in any case will be the same (the number of cells in the path for all three lines is the same).  Thus, we write down such heuristics as ‚Äúuseful‚Äù and first of all do not disdain to check whether it is possible to reach the target object by moving with the correct increment (you can call this function <i>getSimplePath ()</i> , for example).  What for?  Sometimes it saves time (and quite substantial).  But, of course, it will not cope with situations where water cells will lie on the path, or even more so, the initial direction of motion does not correspond to the final one due to obstacles (the case with a greenish line in the first picture). <br><br><img align="right" src="https://habrastorage.org/storage1/535a68f0/dcb7da34/ed83b340/5aaabc80.png">  How to be with obstacles?  Here the wave algorithm will help us: we take a matrix the size of the original field, fix the target cell (writing 0 there) and recursively fill the matrix with values ‚Äã‚Äãin accordance with the image on the right (we go around only those cells that do not (or have not been found) "water" ).  The meaning of these values ‚Äã‚Äãis in the number of moves needed to reach the target cell.  That's right, as soon as we reach recursively to the cage in which our ant is located, we will be able to find a way to the goal - moving in cages for which the values ‚Äã‚Äãof the number of steps decrease.  The algorithm works in O time (cols * rows). <br><br>  Is it a lot or a little?  In our case | cols |, | rows |  &lt;= 200, all you need to build routes for up to 1000 ants (in real games they are never more), and each can have up to hundreds of potential targets.  Total 200 ^ 2 * 1000 * 100, it is 4 billion iterations, mostly records in memory.  Common sense dictates that this will not work in 500ms. <br><br>  Why, then, is such an algorithm chosen at all?  To begin with, it should be noted that theoretically, in fewer actions without any intermediate information, there is no way and no paving, at least you can construct an example costing O (cols * rows) steps (‚Äúspiral‚Äù into the whole field).  Therefore, our task is to construct a method that works well while taking into account the presence of intermediate information (the state of the field changes little from transition from one move to another).  In addition, there is no point in worrying that in the first moves he works slowly, for we have ants and everything is nothing. <br><br>  What will we memorize?  The whole matrix of steps of the wave algorithm for each target cell: <br><blockquote><code><font color="black"><font color="#0000ff">char</font> * WaveMaps[MAX_X][MAX_Y]; <font color="#008000">//     </font> <br> WaveMaps[x][y] = <font color="#0000ff">new</font> <font color="#0000ff">char</font> [MAX_X*MAX_Y]; <font color="#008000">//   </font></font></code> </blockquote> <br>  I recall that WaveMaps [x] [y] are considered for the target object with coordinates (x, y);  in fact, these are all possible routes to this object.  Thus, it is clear that the targets will not be cells with water (there is no sense in them, and you simply cannot go), and most of the cells that are not filled with anything (food, ants, anthills) are not interesting to us - they will not be initialized. <br><br>  Thus, in one move, we can calculate the paths from each ant to a given point, having determined which of them will reach faster (for the first time we count the map, then look in the cache). <br><br>  What will happen next?  During the game, the ants wander around the field, ‚Äúdiscovering‚Äù new cells - initially we are aware of filling only a small part of the maze, but as we move we find food, water, enemy ants, anthills.  In this case, we will be interested in what to do with the cards when a new ‚Äúwater‚Äù cell is detected. <br><br>  To begin, find out how to detect the "water".  To do this, it is enough to keep a local copy of the field status, and on each new move, check whether the received game state differs from the saved one.  Well, found the water in position (x1, y1).  Then you need to recalculate all the cards in which the value at position (x1, y1) is filled with the step number (and not the default value). <br><br>  Taking into account the fact that all the maps are available in the tools package, we can estimate what percentage of the re-initialization (re-calculation) of the matrices for the wave algorithm we should expect.  The result: 100%.  It‚Äôs not great at all, but all because we built maps covering the whole playing field, but this makes no sense, because all the routes can be divided into ‚Äúlong‚Äù and ‚Äúshort‚Äù.  The short ones require precise determination of the cells of the route, and the long ones are made up of blocks of short ones. <br><br>  Thus, a reasonable idea would be to keep a hierarchical map of the reachability of objects.  In the case of my implementation, only two levels were enough (100ms for planning all routes for all ants in the worst case scenario). <br><br>  Then the above algorithm is modified as follows: <br>  1. When each wave algorithm map is filled, we check if the distance from the initial point to the current point is not greater than MAP_RANGE (if we get more, we exit); <br>  2. Build a complete wave map for a low-resolution field (MAX_X / SCALE, MAX_Y / SCALE).  Such a map will help to find the way between points with a distance greater than MAP_RANGE. <br><br><img align="right" src="https://habrastorage.org/storage1/7639eedc/85d16d40/2c51738a/9e3aae32.png"><br>  When requesting paths for fairly distant points (x1, y1) and (x0, y0), we first look at the low resolution map, get an intermediate point (x2, y2) and combine the paths (x1, y1) -&gt; (x2, y2) and ( x2, y2) -&gt; (x0, y0), recursion, aha. <br><br>  The entered parameter MAP_RANGE on the one hand determines how often the wave algorithm maps will be completely recalculated, on the other - the final accuracy of very long paths.  With MAP_RANGE&gt; 2 * viewRadius, there are practically no errors, and time (routes for all ants) hardly goes beyond 100ms. <br><br>  Let me remind you that this trick with MAP_RANGE and a low-resolution map was needed in order to successfully use results caching, updating the cache as rarely as possible (when the cell is examined within the MAP_RANGE radius, its update will stop altogether). <br><br>  As for the memory: in the worst case, the fill will be: 200 ^ 2 * (200/2) ^ 2 (full cards) + (200 / SCALE) ^ 4 (low resolution) bytes, which does not exceed the 500 MB threshold with a reasonable SCALE value (more than 5). <br><br><h5>  3. Goals </h5><br>  A good way to win is not to make meaningless moves, and not to miss meaningful opportunities.  Let's try to analyze what it means. <br><br>  The goals may be: <br>  1. Enemy anthills <br>  2. Food (only if you have your own anthill) <br>  3. Their anthills (for protection) <br>  4. Own ants (to protect or enhance an attack) - support <br>  5. Enemy ants <br>  6. Uninvestigated cells <br><br>  The game has no more objects, respectively, and there are no other goals. <br><br>  I wrote out the goals in order of their priority (let's call them <i>programList</i> ), from the most important to the least important (but still necessary).  Capturing anthills is the point of the game, therefore, all other things being equal, it is better to try to capture an anthill (except for some reservations which follow further) than to chase after food.  I would not like to lose their anthills, and their ants.  If you can just "kill" (without loss from your side) enemy ants - it is better to do it.  Well, if absolutely nothing to do, you can wander around the field. <br><br>  In order to find the target objects, it is necessary to bypass all the received field by checking whether they satisfy the criteria of the target: <br><br><blockquote> <code><font color="black"><font color="#0000ff">foreach</font> <font color="#0000ff">int</font> program <font color="#0000ff">in</font> |ProgramList| <br> <font color="#0000ff">foreach</font> Location loc <font color="#0000ff">in</font> map <br> <font color="#0000ff">if</font> (MatchingProgram(loc, program)) <br> ProgramList[program].push_back(loc);</font></code> </blockquote> <br>  Where the <i>MatchingProgram</i> determines if a given cell is suitable for a program: <br>  1. if the program == enemy anthills, then the cell must contain an enemy anthill; <br>  2. food, the cell contains food; <br>  3. its anthills, the cell contains its anthill and there is an indirect threat to it (the presence of an enemy ant is closer than ours); <br>  4. its ants, the cell contains its ant and there is an indirect threat to it (the presence of enemy ants in viewRadius); <br>  5. the presence of an enemy ant, and its enemies are more or less than ‚Äúallies‚Äù; <br>  6. unexplored cells (cells in which we have not yet been, more on this below). <br><br>  Next, you need to assign each goal of the ant, which will deal with its implementation.  For each goal we review the list of ants;  choose the closest one for which the previous target (set on the last move) is worse than the current one (ie, goes under the big number in the list), or not worse than &amp;&amp; the distance to the previous target is greater (with a margin of 1 step).  This, on the one hand, eliminates the ant jerking back and forth between equivalent goals (a frequent error among the participants), on the other hand, it allows using updated information (in search of food, got to the enemy anthill). <br><br><h5>  4. Locks </h5><br>  As you know, two or more ants that fall on one cell die.  We want to prevent the senseless loss of "composition". <br><br><img align="right" src="https://habrastorage.org/storage1/03b99d8f/9dbe661c/5ff2fcc0/5f21c673.png">  The trivial way would be to check if the cell is not busy assigning another ant, so most of the simplest bots work.  But in this case, blocking is not excluded, when ants prevent each other from reaching their goals, and, as it often happens, the basement is senselessly crowded and the situation is not excluded when some ants have no progress at all. <br><br>  Therefore, it is necessary to separate those ants that have already moved during the course, and those that have not moved yet.  When you try to stand on an already occupied cell, two options arise: <br>  1. Choose a different direction for the current ant; <br>  2. Move the one who interferes ( <i>blocker</i> ) to another cell. <br><br><blockquote> <code><font color="black">programAnt(MyAnt *ant): <br> <font color="#0000ff">if</font> (ant-&gt;alreadyMoved) <font color="#0000ff">return</font> ; <br> repeat: <br> direction = getDirectionByProgramList(program) <br> <font color="#0000ff">if</font> (moveResult(ant, direction) == mrBlockerNotMoved) <br> { <br> programAnt(blocker); <br> program++; <br> <font color="#0000ff">goto</font> repeat; <br> }</font></code> </blockquote> <br>  It is important that the ‚Äúinterfering‚Äù ants move not anyhow as, but in accordance with the best possible program.  Thus, the function of the ‚Äúprogramming‚Äù of the ant as a result can shift even several neighboring ants to the challenge ‚Äî all that is needed is to avoid mutual recursion with the same parameters. <br><br>  Another reason for the useless death of an ant is an attempt to wander in an area with more than the number of opponents.  To detect such situations will have to work hard and write a battleResolution. <br><br>  This is not a problem, however, if you use the C ++ starter package, you will have to use a state.grid, and not an enemyAnts, because  in the list they are not distinguishable by type (if this is not corrected already, of course).  Anyway ... <br><br><h5>  5. Why the starter package is not so good. </h5><br>  1. Ants received in myAnts do not store their parameters.  I have already mentioned that it is a good idea to keep his latest program and path for each ant, however, using State.h, this is not done - the myAnts vector is created on each turn.  Therefore, the correct way to store the parameters of ants is to create a map of the form MyAnt * antMap [MAX_X] [MAX_Y], which you will update manually (this is not so difficult to do in the function <i>makeMove</i> for a specific ant). <br><br>  2. The updateVisibility function works unacceptably long.  For a thousand ants, perhaps even longer than laying paths, because  for each ant a lot of cells are checked for inequality, which determines the distance.  It would be much faster (which I did) to save for each cell a list of directly visible (viewRadius) and attacked (attackRadius), initialized when the cell was first examined.  Then updateVisibility can mark the cells visible for each ant using the ready list, but not by enumeration. <br><br>  3. std :: vector &lt;std :: vector&gt; grid.  Here we lose both in speed and in some cases we increase memory usage even against the Square grid [MAX_X] [MAX_Y].  The loss of speed is not a joke, since the object is very poorly cached, being scattered in different memory addresses. <br><br><h5>  6. Research and control of territories </h5><br>  Since we now know how to reach a specific object, how to implicitly prevent the loss of ants and implicitly organize attacks on enemy ants (except for obvious attempts to collect food, seize an anthill), it remains to learn how to master the territory. <br><br>  The study involves the detection of static objects in those places where we have not been (anthills, water). <br><br>  Control - check if something useful (food) or harmful (enemy ants) has appeared. <br><br>  Both that and another, an essence one and the same - cells in which we for a <i>long time</i> were not.  And this concept is fairly easily formalized. <br><br>  After we assign the goals (programs one through five) of ants, there are a number of ants who still do not know where to go, they should be sent for a walk.  So they should go to those cells that no one sees (visibility == 0).  Of those ‚Äúinvisible‚Äù cells, priority is given to those that were never visible (lastSeen == NEVER) - research.  Of the rest - those that were visible on the earliest turns (max lastSeen) - control.  Among equal in the lastSeen parameter, cells should be chosen nearest. <br><br>  Such an algorithm will quickly bypass the entire field, and at the same time will not allow for a long time to lose sight of the territory where food will appear. <br><br><h5>  7. Reason to ponder </h5><br>  Now our ants are quite viable and know what to do, however, the above algorithm does not guarantee victory. <br><br>  Firstly, because it is impossible to construct always winning algorithms in the game.  A simple example of a possible situation - on the first moves, all opponents attack you, from different sides, and so as not to attack each other.  No arrangement of even a large number of ants around the base will allow it to be protected. <br><br>  Secondly, the order of goals, which I defined by myself is correct (let's say, makes sense), but does not take into account the strategic features of the opponents.  In some cases, quickly enough to reach the enemy anthill and capture it (because it is not guarded), and sometimes it is the right way to suicide.  The priority of the objectives will depend on the level of the enemy.  With a weak opponent it is even useful to ‚Äúexchange‚Äù ants, and from strong ones it is sometimes better to ‚Äúrun‚Äù and wait for the moment of almost complete ‚Äúexchange‚Äù of other players.  On the first moves, we don‚Äôt know anything about opponents at all, and to live to the middle of the game with equal levels is luck (well, or lack of ‚Äúbad luck‚Äù).  Thus, the very priority of goals implicitly contains the concept of strategy (for example, I did not say anything about a group attack, but it is done thanks to goal 4 - support), on which you can work hard. <br><br>  I hope the foregoing will help someone to solve some issues, or at least show that, in general, the subject matter of the competition is not that complicated.  Good luck! </div><p>Source: <a href="https://habr.com/ru/post/132776/">https://habr.com/ru/post/132776/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../132768/index.html">Level ten cow</a></li>
<li><a href="../132769/index.html">Bicycle with USB recharge</a></li>
<li><a href="../132772/index.html">ICQ for BlackBerry - November Gift for MTS Users</a></li>
<li><a href="../132774/index.html">Regular fundraising</a></li>
<li><a href="../132775/index.html">Google introduced Verbatim option in advanced search settings</a></li>
<li><a href="../132777/index.html">We implement namespace in the existing php-code</a></li>
<li><a href="../132778/index.html">Another way of blowing money, a recipe from Kyivstar</a></li>
<li><a href="../132779/index.html">Bash script for sparkles</a></li>
<li><a href="../132780/index.html">OPC DA 2 cheat sheet in .NET</a></li>
<li><a href="../132781/index.html">Release of the openSUSE 12.1 Linux distribution</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>