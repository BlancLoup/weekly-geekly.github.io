<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C # math expression parser - amateur experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Computer and man - how difficult it is for us to understand each other. In essence, the programming process is an explanation to the machine that you ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C # math expression parser - amateur experience</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  Computer and man - how difficult it is for us to understand each other.  In essence, the programming process is an explanation to the machine that you want from it in the language it understands. </blockquote><br><h1>  As an introduction </h1><br>  In my work, and as a hobby, I am associated with the process of writing code related to mathematical calculations.  One of the last tasks was writing software, in which the user would be able to independently enter and use when calculating, visualizing data and optimizing some mathematical expressions.  And taking into account his natural laziness and unwillingness to constantly supplement the library of special mathematical functions code, the thought came to mind - why not realize the delusional student idea, and not reinvent the mathematical expression parser's bicycle. <br><br>  Of course, before taking up the inventive process (again, in view of universal laziness), there was a long enough rape of Yandex and Google for the already existing implementations.  And they found, of course, not enough.  But unfortunately, what we wanted to achieve from the concrete implementation was not found.  And the search criteria were as follows: <br><br><ul><li>  The parser should be implemented under .NET not older than 4.0; </li><li>  It must handle all the basic mathematical operators (+, -, *, /, ^, etc.), taking into account their priorities and brackets of different types; </li><li>  It must recognize the basic functions (like sin, cos), be able to add its functions to the created object of the parser, indicating the delegates of the methods that calculate their value (for any number of input variables); </li><li>  It must be possible to use the constants known to the parser, and add them to the list used when parsing the expression; </li><li>  There should be a mechanism for working with parameters and variables.  This requires variables of different types: simply storing a numeric value, or causing an event in which the external code determines their value at the time of their call; </li><li>  The mechanism of functionals must be implemented (minimum ‚Äî integration, sum of series, and differentiation) </li><li>  The result of parsing a string expression must be represented in the object model of the binary tree; </li><li>  The most important thing is that the binary tree should be able to map to the Linq.Expression tree and then compile it into a delegate that performs the computation at the speed of the .NET platform itself. </li></ul><br><a name="habracut"></a><br><h1>  The purpose of cycling </h1><br>  Actually, the main objective of the invention of the bicycle was the ability to compile a string of mat.expressions into a delegate with a high speed of the process of calculating the value. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Unfortunately, my poor ability to work with search engines, lack of time, effort and laziness did not give a positive result in the search for a prototype and it was decided to embark on a journey on a rake. <br><br><h2>  Model and main idea </h2><br>  The object model consists of two classes: the parser class and the mathematical expression class.  Inside, three additional classes are used: the class of the tree of a mathematical expression, the abstract class of the node of the tree of the mathematical expression, and the class of the logical element of the string of the expression.  In addition, the classes of the function, variable, functional and, accordingly, collections of functions, variables and functionals (they are nested in the class of the mathematics expression) are implemented. <br><br>  The idea that does not pretend to discovery, or the optimal solution, but was an attempt to approach the solution of the problem, was to split the initial sequence of characters in the string of the expression into some logical components.  Form a hierarchical sequence of typed logical blocks of mathematical expression.  And on its basis to build a tree mat.expressions. <br><br>  The design started with the idea - ‚Äúhow would I like it to look like it is complete, and what would it be easy and convenient to use?‚Äù.  I wanted to implement the following usage scenario: <br><br>  A parser object is created, which is fixed somewhere at the level of the presentation model, or in business logic.  It is configured: the necessary constants are added to it, the functions with which it must subsequently work are determined.  Event subscribers are added to handle unknown functions and variables.  And the parser is waiting for the Parce (string) method call. <br><br>  In the main Parce () method, a string expression is passed as input, and its result is an object of a mat expression that contains a tree of a mat expression. <br><br>  The object of the expression must be represented by the collection of functions, variables and constants that are in it.  It should be possible to change the values ‚Äã‚Äãof these objects, as well as the possibility of affecting the expression tree with a view to its modifications.  The object of the expression must have a method for calculating the value (by traversing the tree of the expression), receiving as parameters a set of input variables and issuing a numerical value as the result. <br><br>  The Math object must have a method for converting a Math tree to a System.Linq.Expression object.  And a method that allows you to get a compiled delegate right away based on the use of Linq.Expression mechanisms. <br><br>  Unfortunately, neither the ready-made implementations of something like this, nor the techniques describing, in one way or another, the creation of such a parser are not described anywhere. <br><br><h1>  Object Model Description </h1><br><div class="spoiler">  <b class="spoiler_title">Parser class</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/532/9c9/763/5329c9763232428783a22ad1c9d3f0fe"><br></div></div><br>  Life in the object (after creation) begins with a call to the Parse method. <br><br><div class="spoiler">  <b class="spoiler_title">public MathExpression Parse (string StrExpression)</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="StrExpression"&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> [NotNull] public MathExpression Parse([NotNull] string StrExpression) { Contract.Requires(!string.IsNullOrWhiteSpace(StrExpression)); Contract.Ensures(Contract.Result</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;MathExpression&gt;</span></span></span><span class="hljs-comment">() != null); StrPreprocessing(ref StrExpression); OnStringPreprocessing(ref StrExpression); var expression = new MathExpression(StrExpression, this); ProcessVariables(expression); ProcessFunctions(expression); return expression; }</span></span></code> </pre> <br>  Omitting contracts, the meaning of his work comes down to preprocessing a string, calling the constructor of a mat.expression, and post-processing this expression to analyze its variables and functions. <br></div></div><br>  Pre-processing includes two stages: <br><br>  The private StrPreprocessing method, which removes extra characters from a string: <br><br><div class="spoiler">  <b class="spoiler_title">protected void StrPreprocessing (ref string Str)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Str"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> //     ,     protected virtual void StrPreprocessing([NotNull] ref string Str) { Contract.Requires(!string.IsNullOrEmpty(Str)); Contract.Ensures(!string.IsNullOrEmpty(Contract.ValueAtReturn(out Str))); Str = new string(Str.Where(f_ExcludeCharsSet.NotContains).ToArray()); }</span></span></code> </pre><br></div></div><br>  and a method for generating a string preprocessing event, so that the user of the parser could independently prepare the string for analysis: <br><br><div class="spoiler">  <b class="spoiler_title">public event EventHandler &lt;EventArgs &lt;string &gt;&gt; StringPreprocessing</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public event EventHandler</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;EventArgs&lt;string&gt;</span></span></span><span class="hljs-comment">&gt; StringPreprocessing; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="args"&gt;</span></span></span><span class="hljs-comment"> ,   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> protected virtual void OnStringPreprocessing([NotNull] EventArgs</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment"> args) { Contract.Requires(args != null); Contract.Requires(args.Argument != null); Contract.Requires(args.Argument != string.Empty); Contract.Ensures(args.Argument != null); Contract.Ensures(args.Argument != string.Empty); StringPreprocessing?.Invoke(this, args); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="StrExpression"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private void OnStringPreprocessing([NotNull] ref string StrExpression) { Contract.Requires(!string.IsNullOrEmpty(StrExpression)); Contract.Ensures(Contract.ValueAtReturn(out StrExpression) != null); Contract.Ensures(Contract.ValueAtReturn(out StrExpression) != string.Empty); var args = new EventArgs</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">(StrExpression); OnStringPreprocessing(args); StrExpression = args.Argument; }</span></span></code> </pre><br></div></div><br>  After the line is cleared of garbage and prepared for parsing, it is passed to the constructor of the matte expression.  It also passes the parser itself, which is responsible for determining the functions, constants, and variables. <br><br>  We will still return to the parser class as its members are mentioned, and now ... Mathematical expression class: <br><br><div class="spoiler">  <b class="spoiler_title">Diagram</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/869/4c1/760/8694c1760b074b7ebca19ce7e7cb2653"><br></div></div><br>  The constructor to which the call is passed from the Parse method: <br><br><div class="spoiler">  <b class="spoiler_title">internal MathExpression (string StrExpression, ExpressionParser Parser)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="StrExpression"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Parser"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> internal MathExpression([NotNull] string StrExpression, [NotNull] ExpressionParser Parser) : this() { Contract.Requires(!string.IsNullOrEmpty(StrExpression)); Contract.Requires(Parser != null); Contract.Ensures(Tree != null); var terms = new BlockTerm(StrExpression); //     var root = terms.GetSubTree(Parser, this); //       f_ExpressionTree = new ExpressionTree(root); //      }</span></span></code> </pre><br></div></div><br>  Again, by omitting the block of contracts, first a hierarchical object structure of the terms of a mat expression is created on the basis of a string.  Then, from the very first block of it, the method for obtaining the root of the tree of the mat expression is called.  And on its basis the constructor of the tree works. <br><br>  At the first stage of the analysis of the mathematics expression, it is necessary to combine the string representation (sequence of characters) into a sequence of logical blocks.  Some of them may be recurrently nested. <br><br><div class="spoiler">  <b class="spoiler_title">Class Hierarchy of Expression Terms</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/be7/a7d/5d6/be7a7d5d67b745249f9e6cb86aea804f"><br></div></div><br>  The line is divided into 4 types of terms: <br><br><ul><li>  BlockTerm - term containing an array of terms; </li><li>  StringTerm - a term containing a string value </li><li>  CharTerm - a term containing one character that cannot be associated with regular strings; </li><li>  NumberTerm is a term containing an integer. </li></ul><br>  Thus, the entire line is initially represented as one block term, within which the constituent elements lie. <br><br><div class="spoiler">  <b class="spoiler_title">public BlockTerm (string Str)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Str"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public BlockTerm(string Str) : this("", Str, "") { } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="OpenBracket"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Str"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="CloseBracket"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public BlockTerm([NotNull] string OpenBracket, [NotNull] string Str, [NotNull] string CloseBracket) : base(string.Format("{0}{2}{1}", OpenBracket ?? "", CloseBracket ?? "", Str)) { Contract.Requires(!string.IsNullOrEmpty(Str)); f_OpenBracket = OpenBracket; f_CloseBracket = CloseBracket; f_Terms = GetTerms(Str); }</span></span></code> </pre><br></div></div><br>  Well, the base class of the term: <br><br><div class="spoiler">  <b class="spoiler_title">abstract class Term {...}</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> abstract class Term { </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> protected string f_Value; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Value"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> protected Term(string Value) { f_Value = Value; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">       </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Parser"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Expression"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">  .,     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> [NotNull] public abstract ExpressionTreeNode GetSubTree([NotNull] ExpressionParser Parser, [NotNull] MathExpression Expression); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">   .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">   .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public override string ToString() =&gt; f_Value; }</span></span></code> </pre><br></div></div><br>  The breakdown of the substring into its constituent elements is carried out by the GetTerms method: <br><br><div class="spoiler">  <b class="spoiler_title">private static Term [] GetTerms (string Str)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">      </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Str"&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> [CanBeNull] private static Term[] GetTerms([CanBeNull] string Str) { if(Str == null) return null; if(Str.Length == 0) return new Term[0]; var pos = 0; var len = Str.Length; var result = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Term&gt;</span></span></span><span class="hljs-comment">(); while(pos </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; len) { var c = Str[pos]; if(char.IsLetter(c) || c == '‚à´') { Term value = new StringTerm(GetNameString(Str, ref pos)); if(pos &lt; len) switch(Str[pos]) { case '(': { var blokStr = Str.GetBracketText(ref pos); var block = new BlockTerm("(", blokStr, ")"); value = new FunctionTerm((StringTerm)value, block); } break; case '[': { var blokStr = Str.GetBracketText(ref pos, "[", "]"); var block = new BlockTerm("[", blokStr, "]"); value = new FunctionTerm((StringTerm)value, block); } break; case '{': { var blokStr = Str.GetBracketText(ref pos, "{", "}"); var block = new BlockTerm("{", blokStr, "}"); value = new FunctionTerm((StringTerm)value, block); } break; } if(pos &lt; len &amp;&amp; Str[pos] == '{') value = new FunctionalTerm ( (FunctionTerm)value, new BlockTerm("{", Str.GetBracketText(ref pos, "{", "}"), "}") ); result.Add(value); } else if(char.IsDigit(c)) result.Add(new NumberTerm(GetNumberString(Str, ref pos))); else switch(c) { case '(': { var blokStr = Str.GetBracketText(ref pos); var block = new BlockTerm("(", blokStr, ")"); result.Add(block); } break; case '[': { var blokStr = Str.GetBracketText(ref pos, "[", "]"); var block = new BlockTerm("[", blokStr, "]"); result.Add(block); } break; case '{': { var blokStr = Str.GetBracketText(ref pos, "{", "}"); var block = new BlockTerm("{", blokStr, "}"); result.Add(block); } break; default: result.Add(new CharTerm(Str[pos++])); break; } } return result.ToArray(); }</span></span></span></span></code> </pre><br></div></div><br>  The method starts with checks for the void of the input string and zero length.  After that, the current position of the character being analyzed in the string and its length are recorded, after which the symbol at the current position is considered in a loop until reaching the end of the line: <br><br>  - If it is a letter or an integral symbol, then an attempt is made to capture the name using the GetNameString method. <br><br><div class="spoiler">  <b class="spoiler_title">private static string GetNameString (string Str, ref int pos)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Str"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="pos"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> private static string GetNameString([NotNull] string Str, ref int pos) { Contract.Requires(!string.IsNullOrEmpty(Str)); Contract.Ensures(Contract.ValueAtReturn(out pos) &gt;= 0); Contract.Ensures(Contract.ValueAtReturn(out pos) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; Str.Length); var result = ""; var L = Str.Length; var i = pos; while(i &lt; L &amp;&amp; (char.IsLetter(Str[i]) || Str[i] == '‚à´')) result += Str[i++]; if(i == L || !char.IsDigit(Str[i])) { pos = i; return result; } while(i &lt; L &amp;&amp; char.IsDigit(Str[i])) result += Str[i++]; pos += result.Length; return result; }</span></span></span></span></code> </pre><br></div></div><br>  After that, the current character is checked for the presence of an opening bracket.  If one of the brackets is found, the nested block is extracted from the string, limited by the opening and corresponding closing brackets.  The block term created in such a way is placed into the constructor of the functional turma with the indication of the function name set earlier. <br><br>  A substring delimited by opening and closing parentheses is allocated from a string by an extension method: <br><br><div class="spoiler">  <b class="spoiler_title">public static string GetBracketText (this string Str, ref int Offset, string Open, string Close)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  ,            </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Str"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Offset"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">       -         </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Open"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Close"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">,       </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;exception cref="FormatException"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">      ,        </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">       </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/exception&gt;</span></span></span><span class="hljs-comment"> public static string GetBracketText(this string Str, ref int Offset, string Open = "(", string Close = ")") { var Start = Str.IndexOf(Open, Offset, StringComparison.Ordinal); if(Start == -1) return null; var Stop = Str.IndexOf(Close, Start + 1, StringComparison.Ordinal); if(Stop == -1) throw new FormatException(); var start = Start; do { start = Str.IndexOf(Open, start + 1, StringComparison.Ordinal); if(start != -1 &amp;&amp; start </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; Stop) Stop = Str.IndexOf(Close, Stop + 1, StringComparison.Ordinal); } while(start != -1 &amp;&amp; start &lt; Stop); if(Stop == -1 || Stop &lt; Start) throw new FormatException(); Offset = Stop + Close.Length; Start += Open.Length; return Str.Substring(Start, Stop - Start); }</span></span></span></span></code> </pre><br></div></div><br>  First, the indices of the first occurrences of the beginning and end characters are determined.  If the initial character is not found, then return void.  If not found the final character, then this is a format error. <br><br>  The idea of ‚Äã‚Äãthe method in the sequential cyclic search patterns start and end of the line.  We are trying to find the next opening symbol.  If it is found, and it stands before the closing one, then the index of the closing character must be updated.  The cycle continues until there is such a closing character that is not preceded by the opening character. <br><br>  The result of the method is a substring between the opening and closing characters. <br><br>  If after the formed functional torm there is an opening brace, then the body of the functional begins.  Select the contents of the curly brackets in the block and create a term-functional, pointing to it a term-function, which in this context will contain the name of the functional and its parameters, and the body will be a block in curly brackets. <br><br>  If no brackets were found, the name found is a literal (the future variable ... or a constant). <br><br>  - If the next character of the string was a digit, then an integer begins.  Select the substring containing only numbers. <br><br><div class="spoiler">  <b class="spoiler_title">private static string GetNumberString (string Str, ref int pos)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Str"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="pos"&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> private static string GetNumberString([NotNull] string Str, ref int pos) { Contract.Requires(!string.IsNullOrEmpty(Str)); Contract.Ensures(Contract.ValueAtReturn(out pos) &gt;= 0); Contract.Ensures(Contract.ValueAtReturn(out pos) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; Str.Length); var p = pos; var l = Str.Length; while(p &lt; l &amp;&amp; !char.IsDigit(Str, p)) p++; if(p &gt;</span></span></span><span class="hljs-comment">= l) return null; var start = p; while(p </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; l &amp;&amp; char.IsDigit(Str, p)) p++; pos = p; return Str.Substring(start, p - start); }</span></span></span></span></code> </pre><br></div></div><br>  The result of this method - a string with numbers - falls into the constructor of an integer jerk. <br><br>  - If the next character in the string is an opening bracket, then the block begins.  Select its substring with the GetBracketText extension method. <br>  - If the next character is not a bracket, then it is an indefinite character that turns into a character torm. <br><br>  All created terms are first collected from the list, and then returned as an array. <br><br>  Constructors of all other terms are less interesting.  They simply store the resulting parameters in internal fields (possibly with type conversion). <br><br>  After that, the string will be transformed into a logical hierarchical structure of nested sequences of terms of different types.  From this sequence, a binary tree of a mat expression is built recursively. <br><br>  The basis of the tree is the base class of the node of the tree mat. <br><br><div class="spoiler">  <b class="spoiler_title">Class hierarchy</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/2b2/9f9/02a/2b29f902adfd40438a768a210eaec0e7"><br></div></div><br>  Each node is a class that stores references to the node-root of the left subtree and the node-root of the right subtree, as well as a link to its ancestor.  The abstract tree node class provides an interface for accessing ancestor / descendant nodes, traversal methods, functional indexers that allow to get enumerations of nodes associated with the current, recursive methods for obtaining variables, functions, etc., as the root of its subtree.  The base class of the node also provides a number of computable properties: attributes - whether the node is a left / right subtree, whether the node is a root, a link to the root of the tree, a symbolic path to the current node from the root of the tree, and an ancestor iterator. <br><br><div class="spoiler">  <b class="spoiler_title">Tree node</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/c99/2b2/906/c992b29063c9433ca42fd55662d1af0b"><br></div></div><br>  The code of this class allows you to perform basic manipulations with elements of the tree for their replacement, permutation, traversal and access.  I will give separate methods as required.  Full text takes up a lot of space.  It can be viewed / copied from project sources. <br><br>  All tree nodes can be either computable or used in parsing. <br><br>  The parse nodes include a string node, a character node, and an interval value node.  They are needed to supplement certain metostructures in the tree, such as the integration functional, where the interval must be specified. <br><br>  Computable nodes are essential in the resulting tree structure.  They represent all the elements that can be described in the expression. <br><br>  These include: <br><br><ul><li>  ComputedBracketNode - represents a block of brackets </li><li>  ValueNode is an abstract class representing a value node.  His heirs are: <br>  - ConstValueNode - numeric value node <br>  - VariableValueNode is a variable node (which can be a constant like pi, e, ...) <br><br></li><li>  FunctionNode - the node representing the function object </li><li>  FunctionalNode - a node representing a functional object </li><li>  Operator Node is an abstract class of operator node.  His heirs <br>  - The simplest mathematical operators +, -, *, /, ^; <br>  - Boolean operators ==,!,&gt;, &lt;, &amp;&amp;, ||; <br>  - Condition operator "&lt;result_of_logical operator&gt;?"  and in conjunction with it is used the choice operator "&lt;option_1&gt;: &lt;option_2&gt;" <br>  - The operator that implements access to the argument of the function and used in conjunction with it the operator access to the name of the argument of the function. <br><br></li></ul><br><h2>  Tree building process </h2><br>  The term class declares the abstract method GetSubTree, which allows you to get a subtree described by it from any term.  The process of building a tree begins with calling this method on the block term formed from the source line. <br><br><div class="spoiler">  <b class="spoiler_title">public override ExpressionTreeNode GetSubTree (ExpressionParser Parser, MathExpression Expression)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Parser"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Expression"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public override ExpressionTreeNode GetSubTree(ExpressionParser Parser, MathExpression Expression) { Contract.Requires(Parser != null); Contract.Requires(Expression != null); Contract.Ensures(Contract.Result</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;ExpressionTreeNode&gt;</span></span></span><span class="hljs-comment">() != null); var separator = Parser.ExpressionSeparator; //  -  //      ,  - //             var roots = Terms .Split(t =&gt; t is CharTerm &amp;&amp; ((CharTerm)t).Value == separator) .Select(g =&gt; Parser.GetRoot(g, Expression)).ToArray(); if(roots.Length == 1) return roots[0]; //     ,    //     ExpressionTreeNode argument = null; //     for(var i = 0; i </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; roots.Length; i++) //      { var root = roots[i]; ExpressionTreeNode arg; //     if(root is FunctionArgumentNode) // -   arg = root; // --     else if(root is FunctionArgumentNameNode) // -    // --      arg = new FunctionArgumentNode(root as FunctionArgumentNameNode); else if(root is VariantOperatorNode &amp;&amp; root.Left is VariableValueNode) arg = new FunctionArgumentNode(((VariableValueNode)root.Left).Name, root.Right); else // -     arg = new FunctionArgumentNode("", root); // --      if(argument == null) argument = arg; //     ,    ,   else //  argument = argument.Right = arg; //        } //     ,  -    -   if(argument == null) throw new FormatException("   "); return argument.Root; //    }</span></span></span></span></code> </pre><br></div></div><br>  The method extracts a symbol from the object of the expression mat that is passed to it, which separates the expressions in the block.  The default delimiter is ';'  - semicolon. <br><br>  Then, in the Linq-sequence, the entire array of nested terms is divided into subarrays by a separator - a symbolic term containing an expression separator character.  The Split extension method is responsible for this. <br><br><div class="spoiler">  <b class="spoiler_title">public static T [] [] Split &lt;T&gt; (this T [] array, Func &lt;T, bool&gt; Splitter)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">      </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;typeparam name="T"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/typeparam&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="array"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Splitter"&gt;</span></span></span><span class="hljs-comment">,  ,     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">     ,     . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">      . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> [NotNull] public static T[][] Split</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">([NotNull] this T[] array, [NotNull] Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T, bool&gt;</span></span></span><span class="hljs-comment"> Splitter) { Contract.Requires(array != null); Contract.Requires(Splitter != null); Contract.Ensures(Contract.Result</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T[][]&gt;</span></span></span><span class="hljs-comment">() != null); var result = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T[]&gt;</span></span></span><span class="hljs-comment">(array.Length); var aggregator = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">(array.Length); for(var i = 0; i </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; array.Length; i++) { var value = array[i]; if(Splitter(value) &amp;&amp; aggregator.Count != 0) { result.Add(aggregator.ToArray()); aggregator.Clear(); } else aggregator.Add(value); } if(aggregator.Count != 0) result.Add(aggregator.ToArray()); return result.ToArray(); }</span></span></span></span></code> </pre><br></div></div><br>  For each of the subarray of terms, the GetRoot parser method is called, which is designed to determine the root of the tree of this group of terms.  Then all found roots are combined into an array. <br><br>  GetRoot method: <br><br><div class="spoiler">  <b class="spoiler_title">internal ExpressionTreeNode GetRoot (Term [] Group, MathExpression MathExpression)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">        </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Group"&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="MathExpression"&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">  .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> internal ExpressionTreeNode GetRoot([NotNull] Term[] Group, [NotNull] MathExpression MathExpression) { Contract.Requires(Group != null); Contract.Requires(MathExpression != null); Contract.Ensures(Contract.Result</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;ExpressionTreeNode&gt;</span></span></span><span class="hljs-comment">() != null); //       ExpressionTreeNode Last = null; for(var i = 0; i </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; Group.Length; i++) //       { var node = Group[i].GetSubTree(this, MathExpression); //       //    ... if(Group[i] is NumberTerm) // ...  ,  { //...                if(i + 2 &lt; Group.Length &amp;&amp; NumberTerm.TryAddFractionPart(ref node, Group[i + 1], DecimalSeparator, Group[i + 2])) i += 2; //...      . } else if(Group[i] is BlockTerm) //...   ( ) node = new ComputedBracketNode( //    -    new Bracket( // : (((BlockTerm)Group[i]).OpenBracket), //     ((BlockTerm)Group[i]).CloseBracket), //     node); //   //       Combine(Last, Last = node); //       if(Last.IsRoot &amp;&amp; Last is VariantOperatorNode &amp;&amp; Last.Left is VariableValueNode) Last = new FunctionArgumentNameNode(((VariableValueNode)Last.Left).Name); OnNewNodeAdded(ref Last); } //      ,     if(Last == null) throw new FormatException(); return Last.Root; //      }</span></span></span></span></code> </pre><br></div></div><br>       .           (  ).    : <br><br> ‚Äî            ,        . <br><br><div class="spoiler"> <b class="spoiler_title">public static bool TryAddFractionPart(ref ExpressionTreeNode node, Term SeparatorTerm, char DecimalSeparator, Term FrationPartTerm)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="node"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="SeparatorTerm"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="DecimalSeparator"&gt;</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="FrationPartTerm"&gt;</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">,    . ,        </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public static bool TryAddFractionPart(ref ExpressionTreeNode node, Term SeparatorTerm, char DecimalSeparator, Term FrationPartTerm) { var value = node as ConstValueNode; if(value == null) throw new ArgumentException("   "); var separator = SeparatorTerm as CharTerm; if(separator == null || separator.Value != DecimalSeparator) return false; var fraction = FrationPartTerm as NumberTerm; if(fraction == null) return false; var v_value = fraction.Value; if(v_value == 0) return true; node = new ConstValueNode(value.Value + v_value / Math.Pow(10, Math.Truncate(Math.Log10(v_value)) + 1)); return true; }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method specifies the separator character of the integer and fractional part of the decimal number, as well as the two following terms. </font><font style="vertical-align: inherit;">If the second term is a symbolic one and contains a separator character, and the third is a numeric one, then the node is replaced with a new node-constant value </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äî the Second check ‚Äî if the current term is block, then the node-block-box is formed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Upon completion of checks, the method combining the node created on the previous cycle with the current one is executed:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">public virtual void Combine (ExpressionTreeNode Last, ExpressionTreeNode Node)</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Last"&gt;</span></span></span><span class="hljs-comment">   (   )</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Node"&gt;</span></span></span><span class="hljs-comment"> ,     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> // ReSharper disable once CyclomaticComplexity public virtual void Combine([CanBeNull] ExpressionTreeNode Last, [NotNull] ExpressionTreeNode Node) { Contract.Requires(Node != null); if(Last == null) return; //      ,  if(Node is CharNode) //    -  ,  { Last.LastRightChild = Node; //       return; } var operator_node = Node as OperatorNode; //      - if(operator_node != null) //     ... { //    : //         //            var parent_operator = Last as OperatorNode ?? Last.Parent as OperatorNode; if(parent_operator != null) //      - (   )...  { //           -   // op </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;-     // | // op // / \ // null ? if(parent_operator.Left == null &amp;&amp; parent_operator.Parent is OperatorNode) parent_operator = (OperatorNode)parent_operator.Parent; if(parent_operator.Left == null) //      ... operator_node.Left = parent_operator; //         else if(parent_operator.Right == null) //      parent_operator.Right = Node; //       else //     { var priority = operator_node.Priority; //     //     ,     if(priority &lt;= parent_operator.Priority) { //          parent_operator = (OperatorNode)parent_operator.Parents //            .TakeWhile(n =&gt;</span></span></span><span class="hljs-comment"> n is OperatorNode &amp;&amp; priority </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;= ((OperatorNode)n).Priority) //     .LastOrDefault() ?? parent_operator; //    ,     //            if(parent_operator.IsRoot) //    -   //       ,      if(priority &lt;= parent_operator.Priority) //       operator_node.Left = parent_operator; else //       { var parent = parent_operator.Parent; //       parent.Right = Node; //        operator_node.Left = parent_operator;//       } } else //       { //          parent_operator = (OperatorNode)parent_operator.RightNodes //              .TakeWhile(n =&gt;</span></span></span><span class="hljs-comment"> n is OperatorNode &amp;&amp; n.Left != null &amp;&amp; ((OperatorNode)n).Priority </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; priority) //     .LastOrDefault() ?? parent_operator; //    ,     //            var right = parent_operator.Right; //      parent_operator.Right = Node; //        operator_node.Left = right; //         } } } else //       { var parent = Last.Parent; var is_left = Last.IsLeftSubtree; var is_right = Last.IsRightSubtree; operator_node.Left = Last; //       if(is_left) parent.Left = operator_node; else if(is_right) parent.Right = operator_node; } return; //  } //       if(Last is OperatorNode) //      { Last.Right = Node; //       return; //  } //          //    ,        -  if(Last is ConstValueNode || (Last is ComputedBracketNode &amp;&amp; Node is ComputedBracketNode)) { //      var parent = Last.Parent; if(parent != null) //    //            parent.Right = new MultiplicationOperatorNode(Last, Node); else //       //   -     ,      new MultiplicationOperatorNode(Last, Node); return; // . } Last.Right = Node; }</span></span></span></span></code> </pre><br></div></div><br>     . ,       .,      ,  - ( ). ,          .        . <br><br>        :    ‚Äî        ,        - &lt;&gt;:&lt;_2&gt;,         &lt;_&gt;:&lt;_&gt;.       . <br><br>     -   NewNodeAdded,          .      ,        . <br><br>  ,            GetSubTree          ,  : <br><br><ul><li>      ,        (  ) </li><li>   ,          FunctionArgumentNode (    ),       . </li></ul><br><h3>    </h3><br>       : <br><br><ul><li>           </li><li>   (,  )     (  ) </li><li>         </li><li>      .       . </li><li>           ,    .         ; </li><li>    ‚Äî         -,      -. </li><li>    .      (        ). </li></ul><br>        . <br><br>  .            .              : <br><br><div class="spoiler"> <b class="spoiler_title">class StringTerm : Term {...}</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> class StringTerm : Term { </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> [NotNull] public string Name =&gt; f_Value; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Name"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public StringTerm([NotNull] string Name) : base(Name) { Contract.Requires(!string.IsNullOrEmpty(Name)); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> ,   -</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Parser"&gt;</span></span></span><span class="hljs-comment"></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Expression"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">   ,   Expression.Variable[Name]</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public override ExpressionTreeNode GetSubTree(ExpressionParser Parser, MathExpression Expression) =&gt; new VariableValueNode(Expression.Variable[Name]); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> sealed class FunctionalTerm : FunctionTerm { </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> [NotNull] public BlockTerm Parameters { get; set; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Header"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Body"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public FunctionalTerm([NotNull] FunctionTerm Header, [NotNull] BlockTerm Body) : base(Header.Name, Body) { Contract.Requires(Header != null); Contract.Requires(Body != null); Parameters = Header.Block; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Parser"&gt;</span></span></span><span class="hljs-comment"></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Expression"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public override ExpressionTreeNode GetSubTree(ExpressionParser Parser, MathExpression Expression) =&gt; new FunctionalNode(this, Parser, Expression); public override string ToString() =&gt; $"{Name}{Parameters}{Block}"; }</span></span></code> </pre><br></div></div><br>  ,        /         -/. <br><br><div class="spoiler"> <b class="spoiler_title">internal FunctionNode(FunctionTerm Term, ExpressionParser Parser, MathExpression Expression)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Term"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Parser"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Expression"&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> internal FunctionNode(FunctionTerm Term, ExpressionParser Parser, MathExpression Expression) : this(Term.Name) { var arg = Term.Block.GetSubTree(Parser, Expression); if(!(arg is FunctionArgumentNode)) if(arg is FunctionArgumentNameNode) arg = new FunctionArgumentNode((FunctionArgumentNameNode)arg); else if(arg is VariableValueNode) arg = new FunctionArgumentNode(null, arg); else if(arg is VariantOperatorNode &amp;&amp; arg.Left is VariableValueNode) arg = new FunctionArgumentNode(((VariableValueNode)arg.Left).Name, arg.Right); else arg = new FunctionArgumentNode(null, arg); Right = arg; // -   Function = Expression.Functions[Name, ArgumentsNames]; }</span></span></code> </pre><br></div></div><br>      .         .     .    ,     (    , -     . <br><br><h3>   </h3><br>   ¬´¬ª  .       .  Parse      ProcessVariables  ProcessFunctions     ¬´¬ª . <br><br>   : <br><br><div class="spoiler"> <b class="spoiler_title">internal void ProcessVariables(MathExpression Expression)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Expression"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> internal void ProcessVariables([NotNull] MathExpression Expression) { Contract.Requires(Expression != null); var tree_vars = Expression.Tree.Root.GetVariables().ToArray(); Expression.Variable .Where(v =&gt; !tree_vars.Contains(v)) .ToArray() .Foreach(v =&gt; Expression.Variable.Remove(v)); foreach(var variable in Expression.Variable.ToArray()) { if(f_Constans.ContainsKey(variable.Name)) { Expression.Variable.MoveToConstCollection(variable); variable.Value = f_Constans[variable.Name]; } OnVariableProcessing(variable); } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Its task is to bypass the tree, find all the variable nodes and extract the variable objects used in them. After that, it is necessary to remove everything that is not used in the tree from the collection of variables of the mathematics expression. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, for each variable in the tree it is checked whether its name is in the collection of known parser constants. If yes, then it is removed from the collection of variables of the expression, entered into the collection of constants of the expression, initialized to the value known to the parser, and the flag is set in it that it is a constant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, a new variable detection event is called for it in the parser. When processing this event, the user of the parser can override the value of this variable, or change the object of the variable itself.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The second Method ProcessFunctions method fills in functions known to the expression expression: </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">internal void ProcessFunctions (MathExpression Expression)</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="Expression"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> [SuppressMessage("ReSharper", "CyclomaticComplexity")] internal void ProcessFunctions([NotNull] MathExpression Expression) { Contract.Requires(Expression != null); foreach(var function in Expression.Functions) switch(function.Name) { case "Sin": case "SIN": case "sin": if(function.Arguments.Length != 1) goto default; function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double&gt;</span></span></span><span class="hljs-comment">(Math.Sin); break; case "COS": case "Cos": case "cos": if(function.Arguments.Length != 1) goto default; function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double&gt;</span></span></span><span class="hljs-comment">(Math.Cos); break; case "TAN": case "Tan": case "tan": case "tn": if(function.Arguments.Length != 1) goto default; function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double&gt;</span></span></span><span class="hljs-comment">(Math.Tan); break; case "ATAN": case "ATan": case "Atan": case "atan": case "atn": case "Atn": if(function.Arguments.Length == 1) function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double&gt;</span></span></span><span class="hljs-comment">(Math.Atan); else if(function.Arguments.Length == 2) function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double, double&gt;</span></span></span><span class="hljs-comment">(Math.Atan2); else goto default; break; case "Atan2": case "atan2": if(function.Arguments.Length != 2) goto default; function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double, double&gt;</span></span></span><span class="hljs-comment">(Math.Atan2); break; case "CTG": case "Ctg": case "ctg": if(function.Arguments.Length != 1) goto default; function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double&gt;</span></span></span><span class="hljs-comment">(x =&gt; 1 / Math.Tan(x)); break; case "Sign": case "sign": if(function.Arguments.Length != 1) goto default; function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double&gt;</span></span></span><span class="hljs-comment">(x =&gt; Math.Sign(x)); break; case "Abs": case "abs": if(function.Arguments.Length != 1) goto default; function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double&gt;</span></span></span><span class="hljs-comment">(Math.Abs); break; case "Exp": case "EXP": case "exp": if(function.Arguments.Length != 1) goto default; function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double&gt;</span></span></span><span class="hljs-comment">(Math.Exp); break; case "Sqrt": case "SQRT": case "‚àö": case "sqrt": if(function.Arguments.Length != 1) goto default; function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double&gt;</span></span></span><span class="hljs-comment">(Math.Sqrt); break; case "log10": case "Log10": case "LOG10": case "lg": case "Lg": case "LG": if(function.Arguments.Length != 1) goto default; function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double&gt;</span></span></span><span class="hljs-comment">(Math.Log10); break; case "loge": case "Loge": case "LOGe": case "ln": case "Ln": case "LN": if(function.Arguments.Length != 1) goto default; function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double&gt;</span></span></span><span class="hljs-comment">(Math.Log); break; case "log": case "Log": case "LOG": if(function.Arguments.Length != 2) goto default; function.Delegate = new Func</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;double, double, double&gt;</span></span></span><span class="hljs-comment">(Math.Log); break; default: var f = OnFunctionFind(function.Name, function.Arguments); if(f == null) throw new NotSupportedException($"  {function.Name}  "); function.Delegate = f; break; } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the function name is among the variants of the case statement, then if the required function matches the number of arguments, it is assigned a delegate who will calculate its value. </font><font style="vertical-align: inherit;">If the function is not defined, the delegate is defined as the result of generating an unknown function detection event. </font><font style="vertical-align: inherit;">In this case, the user can determine in the response to this event the desired delegate by the name and the number (and names) of the arguments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This completes the generation of mathematical expressions.</font></font><br><br><h3>  Using </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose we have a task to calculate the integral of the function A * cos (2 * x) / pi + G (x / 2) divided by A and + 1, where G (x) = 2cos (x). </font><font style="vertical-align: inherit;">When A, say, equal to 5. And the integral must be taken in increments of 0.05.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExpressionParser(); parser .FindFunction += (s, e) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(e.SignatureEqual(name: <span class="hljs-string"><span class="hljs-string">"G"</span></span>, ArgumentsCount: <span class="hljs-number"><span class="hljs-number">1</span></span>)) e.Function = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(x =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> * Math.Cos(x)); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expr = parser.Parse(<span class="hljs-string"><span class="hljs-string">@"Int[x=-10..10;dx=0.05]{A*cos(2x) + G(x/2)}/A + 1"</span></span>); expr.Variable[<span class="hljs-string"><span class="hljs-string">"A"</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = expr.Compute(); <span class="hljs-comment"><span class="hljs-comment">//y = 0.30928806858920344 var f = expr.Compile(); var y2 = f(); //y = 0.30928806858920344</span></span></code> </pre><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Given the resulting volume of the article, I put here ... not a full point, but a semicolon. </font><font style="vertical-align: inherit;">As a result of the above, it was possible:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Get a general idea of ‚Äã‚Äãthe method of solving the problem; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To form an object model of the parser of the mat expression, the mat expression itself and its tree; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To create an effective method for parsing the string of mathematical expressions into logical components; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create an effective method for constructing a tree of mathematical expressions, taking into account the peculiarities of using brackets, operator priorities and special constructions (functionals); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Provide control over different stages of input data processing by the parser based on the event system; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add the ability to expand functionality. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What could not be described in this article: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The logic of the variables (their types and methods for their production and subsequent replacement); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The structure of collections of variables, constants, functions involved in the work of mathematical expression; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The method of calculating the value of a mat expression by traversing its tree; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The method of compiling the tree of mathematics in the delegate. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What has not been possible so far in the implementation of the parser itself: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement methods for optimizing the tree of mat expression; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remove crutches from a number of places; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add checks for compliance of the input data with the format of the matte expression; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actually, outline the boundaries of this format; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Increase code coverage with unit tests; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To conduct comparative studies of the speed of both the parsing stages and the computation steps. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, the work on this code unfortunately is of a background character and has been going on for a couple of years already, but at this stage it is already solving the tasks assigned to it. </font><font style="vertical-align: inherit;">Although in the present form it is impossible to let it go in production. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full source codes can be found </font></font><a href="https://bitbucket.org/Infarh/mathservice.net/src/fe7e46426521a6b9759de1c297986bb22b80abe7/MathService/MathParser/%3Fat%3DMathParser"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/281495/">https://habr.com/ru/post/281495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281483/index.html">Cloud-as-a-Tier, or How to build an IT infrastructure using a hybrid cloud</a></li>
<li><a href="../281485/index.html">Methods to optimize the reception / transmission in Wi-Fi networks</a></li>
<li><a href="../281487/index.html">Competition "Admin 80 level" from RUVDS</a></li>
<li><a href="../281491/index.html">About extended support and maintenance of IT infrastructures</a></li>
<li><a href="../281493/index.html">From love to hate - one step, or how I stopped loving magic in ActiveRecord</a></li>
<li><a href="../281497/index.html">Experiments with malloc</a></li>
<li><a href="../281499/index.html">Macros in Emacs: form teams for processing</a></li>
<li><a href="../281501/index.html">Project Tofino - the new Mozilla browser</a></li>
<li><a href="../281503/index.html">Interfaces: How not to do the option of unsubscribing from the email-list</a></li>
<li><a href="../281505/index.html">How we implemented DevOps: infrastructure-as-code using Microsoft Azure and Azure Resource Manager</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>