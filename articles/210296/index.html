<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Splay trees</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A balanced search tree is the foundation for many modern algorithms. On the pages of books on Computer Science, you will find descriptions of red-blac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Splay trees</h1><div class="post__text post__text-html js-mediator-article">  A balanced search tree is the foundation for many modern algorithms.  On the pages of books on Computer Science, you will find descriptions of red-black, AVL-, B-, and many other balanced trees.  But is the permanent balance the Holy Grail to be followed? <br><br>  Imagine that we have already built a tree on <img src="https://habrastorage.org/getpro/habr/post_images/c7f/092/d48/c7f092d481acb49c8a0f96178ceb3119.gif">  keys and now we need to respond to requests whether the given key lies in the tree.  It may well turn out that the user is mainly interested in one key, and he only requests the rest from time to time.  If the key is far from the root, then <img src="https://tex.s2cms.ru/svg/m">  requests can take away <img src="https://habrastorage.org/getpro/habr/post_images/076/63d/c3c/07663dc3c790b8c5e111597f71b68abc.gif">  of time.  Common sense suggests that the assessment can be optimized to <img src="https://habrastorage.org/getpro/habr/post_images/7be/274/948/7be27494810106e7a26b615c21f37527.gif">  by adding a cache over the tree.  But this approach has some lack of flexibility and elegance. <br><br>  Today I will talk about splay trees.  These trees are not permanently balanced and even linear time can work on individual queries.  However, after each request, they change their structure, which allows to process frequently repeated requests very effectively.  Moreover, the depreciation cost of processing a single request from them <img src="http://habrastorage.org/getpro/habr/post_images/84c/07b/cc9/84c07bcc99d5fc8ab9086ace521ed96a.gif">  , which makes splay-trees a good alternative for permanently balanced counterparts. <br><a name="habracut"></a><br><h4>  Splay trees </h4><br>  In the mid-eighties, Robert Taryan and Daniel Slaytor proposed some beautiful and effective data structures.  All of them have a simple basic structure and one or two heuristics, which they constantly locally correct.  A splay tree is one such structure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A splay tree is a self-balancing binary search tree.  The tree does not need to store any additional information, which makes it efficient in memory.  After each conversion, even a search, the splay tree changes its structure. <br><br>  Below I will describe the algorithm of how a tree works on a set of pairs of different keys, and then I will give its analysis. <br><br><h4>  Algorithm </h4><br>  To describe the structure of the tree, we need a simple class that describes a single vertex, <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key, left = None, right = None, parent = None)</span></span></span><span class="hljs-function">:</span></span> self.left = left self.right = right self.parent = parent self.key = key</code> </pre> <br>  and two supporting procedures for working with parent signs. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_parent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(child, parent)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> child != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: child.parent = parent <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keep_parent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span><span class="hljs-function">:</span></span> set_parent(v.left, v) set_parent(v.right, v)</code> </pre><br>  The basic heuristic of a splay tree is move-to-root.  After referring to any vertex, it rises to the root.  The ascent is realized through the turns of the peaks.  In one turn, you can swap the parent with the child, as shown in the figure below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/58b/97d/c8b/58b97dc8bf8293538e48a34716f4e1f5.png"><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent, child)</span></span></span><span class="hljs-function">:</span></span> gparent = parent.parent <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gparent != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gparent.left == parent: gparent.left = child <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: gparent.right = child <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> parent.left == child: parent.left, child.right = child.right, parent <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: parent.right, child.left = child.left, parent keep_parent(child) keep_parent(parent) child.parent = gparent</code> </pre><br>  But simply turning the top until it becomes a root is not enough.  The trick of a splay tree is that as the vertex moves up, the distance to the root is reduced not only for the lifted vertex, but also for all its descendants in the current subtrees.  To do this, use the technique of zig-zig and zig-zag turns. <br><br>  The main idea of ‚Äã‚Äãzig-zig and zig-zag turns, to consider the path from grandfather to child.  If the path goes only on the left children or only on the right, then this situation is called zig-zig.  How to handle it is shown in the figure below.  First turn the parent, then the child. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13c/2ec/397/13c2ec39790be792f792fe393db53be5.png"><br><br>  Otherwise, we first change the child with the current parent, then with the new one. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ccf/9f3/f52/ccf9f3f52fea0caa23df9070d4833bc3.png"><br><br>  If the top of the grandfather is not, we make the usual turn: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/36e/527/090/36e527090c0e49bf48ba45d20fb780f7.png"><br><br>  The above procedure for raising vertices using zig-zig and zig-zag turns is key for a splay-tree. <br><br>  <b>Note</b>  In Russian, the term "splay" was translated as "expand."  I think this is not a very good translation.  You take the top and pull it up.  At this time, all the other peaks go down, turning around it.  Something similar happens when you twist the T-shirt.  So the word "turn out" seems more appropriate here. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">splay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v.parent == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v parent = v.parent gparent = parent.parent <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gparent == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: rotate(parent, v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: zigzig = (gparent.left == parent) == (parent.left == v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> zigzig: rotate(gparent, parent) rotate(parent, v) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: rotate(parent, v) rotate(gparent, v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> splay(v)</code> </pre><br>  The search procedure in the splay-tree differs from the usual one only at the last stage: after the vertex is found, we pull it up and root it through the <code>splay</code> procedure. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v, key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key == v.key: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> splay(v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key &lt; v.key <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> v.left != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> find(v.left, key) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key &gt; v.key <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> v.right != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> find(v.right, key) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> splay(v)</code> </pre><br>  To implement the insertion and deletion of the key, we need two procedures: <code>split</code> and <code>merge</code> (cut and merge). <br><br>  The <code>split</code> procedure receives the key <code>key</code> as input and divides the tree into two.  In one tree, all values ‚Äã‚Äãare less than the key <code>key</code> , and in the other - more.  It is implemented simply.  It is necessary through <code>find</code> find the top nearest to the key, pull it up and then cut off either the left or right subtree (or both). <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(root, key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> root == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> root = find(root, key) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> root.key == key: set_parent(root.left, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) set_parent(root.right, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root.left, root.right <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> root.key &lt; key: right, root.right = root.right, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> set_parent(right, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root, right <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: left, root.left = root.left, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> set_parent(left, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left, root</code> </pre><br>  To insert the next key, it is enough to call <code>split</code> on it, and then make a new vertex-root, which has the result <code>split</code> subtrees. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(root, key)</span></span></span><span class="hljs-function">:</span></span> left, right = split(root, key) root = Node(key, left, right) keep_parent(root) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root</code> </pre><br>  The <code>merge</code> procedure receives two trees as input: the left is <code>left</code> and the right is <code>right</code> .  To work correctly, the keys of the <code>left</code> tree must be smaller than the keys of the <code>right</code> tree.  Here we take the top with the smallest key of the right tree <code>right</code> and pull it up.  After that, as the left subtree we join the tree <code>left</code> . <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(left, right)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> right == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> left == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right right = find(right, left.key) right.left, left.parent = left, right <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right</code> </pre><br>  To remove a vertex, you need to lift it up, and then merge its left and right subtrees. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(root, key)</span></span></span><span class="hljs-function">:</span></span> root = find(root, key) set_parent(root.left, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) set_parent(root.right, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> merge(root.left, root.right)</code> </pre><br>  In order for a splay tree to support duplicate keys, you can proceed in two ways.  It is necessary either to match each key with a list that stores the required add.  information, or implement the find procedure so that it returns the first vertex in the LUR traversal order with the key greater or equal to the specified one. <br><br><h4>  Analysis </h4><br>  Note that the procedures for deleting, inserting, merging and splitting trees work for <img src="http://habrastorage.org/getpro/habr/post_images/ec7/176/ecf/ec7176ecffb2f187d5ef0d0d24ffdbd4.gif">  + time of the <code>find</code> procedure. <br><br>  The <code>find</code> procedure works in proportion to the depth of the desired vertex in the tree.  When the search is <code>splay</code> , the <code>splay</code> procedure <code>splay</code> , which also works in proportion to the depth of the vertex.  Thus, it is sufficient to estimate the time of the <code>splay</code> procedure. <br><br>  For the analysis we will use the method of the physicist, about which I told in the article about the <a href="http://habrahabr.ru/post/208624">depreciation analysis</a> .  Let be <img src="http://habrastorage.org/getpro/habr/post_images/2c4/55f/6c3/2c455f6c331507d8415d138c126d5cd1.gif">  - subtree size <img src="http://habrastorage.org/getpro/habr/post_images/801/e91/678/801e916781182638bdd30f434f6dd79f.gif">  with root at the top <img src="http://tex.s2cms.ru/svg/v">  .  Rank tops <img src="http://tex.s2cms.ru/svg/v">  let's call the value <img src="http://habrastorage.org/getpro/habr/post_images/2a4/a15/263/2a4a15263185920396d9b74a66fda10e.gif">  .  Our potential will be <img src="http://habrastorage.org/getpro/habr/post_images/01e/fed/dbf/01efeddbf29cf53eddad0eb121c3865c.gif">  . <br><br>  We assume that the actual time of the <code>splay(v)</code> procedure is equal to the depth <img src="http://tex.s2cms.ru/svg/h">  tops <img src="http://tex.s2cms.ru/svg/v">  .  Note that this is also equal to the number of elementary turns that will be performed during the procedure. <br><br>  <b>Approval</b>  The depreciation value of the <code>splay</code> operation from the top <img src="http://tex.s2cms.ru/svg/v">  in a tree <img src="http://habrastorage.org/getpro/habr/post_images/b94/550/354/b94550354872977b0f0aad8cda86789e.gif">  with root <img src="http://tex.s2cms.ru/svg/r">  is up <img src="http://habrastorage.org/getpro/habr/post_images/bac/598/191/bac5981912a4b3785f398a37163010ec.gif">  . <br><br>  <b>Proof</b> . <br>  If a <img src="http://tex.s2cms.ru/svg/v">  - root, the statement is obvious.  Otherwise, we divide the <code>splay(v)</code> procedure into stages.  During each stage, one of three turns is performed: zig, zig-zig or zig-zag.  A unit of time goes to a simple turn, and two units to zig-zig and zig-zag. <br><br>  After each stage the rank of the top <img src="http://tex.s2cms.ru/svg/v">  will change.  Let the rank initially be <img src="http://habrastorage.org/getpro/habr/post_images/bd2/e8c/4de/bd2e8c4deee380873258074067f47a79.gif">  , and then <img src="http://tex.s2cms.ru/svg/i">  -th stage - <img src="http://habrastorage.org/getpro/habr/post_images/45a/141/2de/45a1412deeddf95d0291a61419916399.gif">  .  For each stage, except, perhaps, the last, we show that the amortization time for its execution can be limited from above by <img src="http://habrastorage.org/getpro/habr/post_images/514/7e6/520/5147e652057fc82f5cc918ad29f95543.gif">  .  For the last stage, the upper estimate will be <img src="http://habrastorage.org/getpro/habr/post_images/3a7/c5a/d43/3a7c5ad43334e60bfd005218c4a6cf67.gif">  .  Summing the upper estimates and reducing the intermediate values ‚Äã‚Äãof the ranks, we obtain the required <br><br><div style="text-align:center;"><img src="http://habrastorage.org/getpro/habr/post_images/72d/3e4/837/72d3e4837c9cbdce557c78e41a136e51.gif"></div><br><br>  It only needs to be noted that <img src="http://habrastorage.org/getpro/habr/post_images/3d4/903/c4a/3d4903c4a6ab562fa149407b12cbdd95.gif">  , but <img src="http://habrastorage.org/getpro/habr/post_images/a10/2e6/672/a102e6672264a72c4d01f4c1ef352345.gif">  . <br><br>  Now we will analyze each type of rotation separately. <br><br>  Zig.  It can be performed only once, at the last stage.  Actual time <img src="http://habrastorage.org/getpro/habr/post_images/26f/ff1/377/26fff1377fd5ee7a18d590a322203e05.gif">  .  Let's look at the picture and understand that only vertices change ranks. <img src="http://tex.s2cms.ru/svg/v">  and <img src="http://tex.s2cms.ru/svg/r">  . <br><br><img src="http://habrastorage.org/files/bd9/d53/7e5/bd9d537e58a24dfb94445b704a903153.png"><br><br>  So, the depreciation value will be <img src="http://habrastorage.org/getpro/habr/post_images/e61/061/e90/e61061e90cf933cf6ec28f8d25e905d7.gif">  .  Ranks <img src="http://habrastorage.org/getpro/habr/post_images/155/bde/9f5/155bde9f50a1332adbefa9c833ae068f.gif">  and <img src="http://habrastorage.org/getpro/habr/post_images/ad2/d15/a8d/ad2d15a8df39e0b455d90f44a350d356.gif">  are shrinking.  Based on the size of the respective subtrees, apply to the formula <img src="http://habrastorage.org/getpro/habr/post_images/270/cbb/bb6/270cbbbb6cb0b4c0634e86f443bd3ab6.gif">  inequality: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/getpro/habr/post_images/0ca/37d/0b1/0ca37d0b18e353c266d5b324d89a156f.gif"></div><br><br>  So <img src="http://habrastorage.org/getpro/habr/post_images/e8e/aea/72f/e8eaea72f1417fc4e5e0d7a0cc887ef1.gif">  . <br><br>  Zig-zig  Actual time <img src="http://habrastorage.org/getpro/habr/post_images/95c/007/330/95c0073302d8e83f0658373bf031d628.gif">  .  Note that the ranks change only at the vertices. <img src="http://habrastorage.org/getpro/habr/post_images/778/167/ba0/778167ba0bfe8d797c1444241533f806.gif">  , <img src="http://habrastorage.org/getpro/habr/post_images/4f9/ca1/b1c/4f9ca1b1c8029535c88032fbe0b24b60.gif">  and <img src="http://habrastorage.org/getpro/habr/post_images/8ca/ebe/078/8caebe078b8f5a33590e85caea5439cd.gif">  . <br><br><img src="//habrastorage.org/files/566/742/2e5/5667422e5f6a4b17b1936349921a2a62.png"><br><br>  Then the depreciation value <img src="http://habrastorage.org/getpro/habr/post_images/f88/07b/f37/f8807bf37fe6b7b3233fef522b691a4a.gif">  .  Ranks <img src="http://habrastorage.org/getpro/habr/post_images/155/bde/9f5/155bde9f50a1332adbefa9c833ae068f.gif">  and <img src="http://habrastorage.org/getpro/habr/post_images/8ca/ebe/078/8caebe078b8f5a33590e85caea5439cd.gif">  can be cut.  We get that <img src="http://habrastorage.org/getpro/habr/post_images/9e6/f72/cc4/9e6f72cc4496cad479eee6dfb081b61c.gif">  .  Based on the size of the subtrees applicable to the formula <img src="http://habrastorage.org/getpro/habr/post_images/270/cbb/bb6/270cbbbb6cb0b4c0634e86f443bd3ab6.gif">  two inequalities: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/getpro/habr/post_images/008/61a/f75/00861af757b1c0f16fdd2a82525d278e.gif"></div><br><br>  and get that <img src="http://habrastorage.org/getpro/habr/post_images/e75/31c/f9f/e7531cf9f42d16323412064c7f4f5fe6.gif">  . <br><br>  Our goal is to show that <img src="http://habrastorage.org/getpro/habr/post_images/d52/059/7a0/d520597a0b03a29b8c707e8c848c0c3c.gif">  .  To do this, it is enough to show that <img src="http://habrastorage.org/getpro/habr/post_images/da2/0bd/041/da20bd0413ddd7abb2c6a1124a70ed1f.gif">  : <br><br><img src="http://habrastorage.org/getpro/habr/post_images/385/49c/6e6/38549c6e67f5913b05c03db9e23f0966.gif"><br><br>  For convenience, we transfer the ranks to the left-hand side and prove <img src="http://habrastorage.org/getpro/habr/post_images/8d1/be0/29f/8d1be029f449db8442cfb9b5e81cd7f6.gif">  .  By definition rank <img src="http://habrastorage.org/getpro/habr/post_images/ab1/b92/dcc/ab1b92dcc990d3ac0f39df4e4ece7ec0.gif">  .  The last equality is divided by the sum <img src="http://habrastorage.org/getpro/habr/post_images/269/10c/32f/26910c32f49a0473c0bf8b9aea4d6158.gif">  .  Let's look at the picture and understand that <img src="http://habrastorage.org/getpro/habr/post_images/f8f/dbd/a6d/f8fdbda6d98e4b55cef1518928558774.gif">  . <br><br>  <b>Fact</b> <img src="http://habrastorage.org/getpro/habr/post_images/cb8/e8e/c07/cb8e8ec07a4a7872b6acaf707d6e673f.gif">  for any positive <img src="http://habrastorage.org/getpro/habr/post_images/c80/d13/d58/c80d13d587a00fca58b429e785e3c06a.gif">  such that <img src="http://habrastorage.org/getpro/habr/post_images/76b/3b1/ea4/76b3b1ea4f0c87f8fc93e7f66faf333b.gif">  . <br><br>  So <img src="http://habrastorage.org/getpro/habr/post_images/a93/276/f12/a93276f12dd9474eb7fef7a83748cebf.gif">  .  Got the required. <br><br>  Zig-zag. <br><br><img src="//habrastorage.org/files/fd0/b05/323/fd0b0532300a4e98b6089883319524c8.png"><br><br>  Similar to the previous case, we write down the depreciation estimate: <img src="http://habrastorage.org/getpro/habr/post_images/f88/07b/f37/f8807bf37fe6b7b3233fef522b691a4a.gif">  . <br><br>  Ranks <img src="http://habrastorage.org/getpro/habr/post_images/155/bde/9f5/155bde9f50a1332adbefa9c833ae068f.gif">  and <img src="http://habrastorage.org/getpro/habr/post_images/8ca/ebe/078/8caebe078b8f5a33590e85caea5439cd.gif">  are shrinking.  To formula <img src="http://habrastorage.org/getpro/habr/post_images/270/cbb/bb6/270cbbbb6cb0b4c0634e86f443bd3ab6.gif">  the following inequalities apply: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/getpro/habr/post_images/0c5/232/69d/0c523269dbad8d147f278380b9d4cb76.gif"></div><br><br>  So <img src="http://habrastorage.org/getpro/habr/post_images/11e/019/6f0/11e0196f041a65b9712d2128d106eeaf.gif">  .  This inequality is proved in the same way as in the previous case. <br><br>  Thus, we have analyzed all three cases and obtained the upper estimate for the amortized time through the ranks. <img src="http://habrastorage.org/getpro/habr/post_images/a8e/bdf/07e/a8ebdf07e1219a23c6f51afadcf2d768.gif"><br><br>  It remains to note that the rank of any vertex is limited by the logarithm of the size of the tree.  Which implies the following theorem. <br><br>  <b>Theorem</b> .  The <code>splay</code> depreciation operation is performed for <img src="http://habrastorage.org/getpro/habr/post_images/84c/07b/cc9/84c07bcc99d5fc8ab9086ace521ed96a.gif">  . <br><br><h4>  Other metrics and properties </h4><br>  For dessert, I would like to refer to <a href="http://en.wikipedia.org/wiki/Splay_tree">Wikipedia</a> and present here some interesting facts about <code>splay</code> trees. <br><br>  <b>Static optimality theorem</b> .  Let be <img src="http://habrastorage.org/getpro/habr/post_images/cad/4e8/f95/cad4e8f9585700a0a979e4d098851bb4.gif">  - the number of times the item was requested <img src="http://habrastorage.org/getpro/habr/post_images/882/839/fd0/882839fd0d8c0796ef0f881d89ac3705.gif">  .  Then doing <img src="http://habrastorage.org/getpro/habr/post_images/601/5f7/e7e/6015f7e7e19971bf1372e01171eaadcb.gif">  search queries on the <code>splay</code> tree is done in <img src="http://habrastorage.org/getpro/habr/post_images/4e4/afc/38a/4e4afc38a83dfc386be50875ee0dd12f.gif">  . <br><br>  In fact, this fact reports the following.  Let us know in advance how many queries will be set for various elements.  We build some specific binary tree to respond to these requests as quickly as possible.  The statement says that, up to a constant <code>splay</code> tree will depreciate to work no worse than the most optimal fixed tree we can come up with. <br><br>  <b>The current set theorem</b> .  Let be <img src="http://habrastorage.org/getpro/habr/post_images/41c/9fd/590/41c9fd5903fa785884a1325457399279.gif">  Is the number of requests that we have already made since the last request to the element <img src="http://habrastorage.org/getpro/habr/post_images/12f/ee3/928/12fee3928922dbe461d4bd49abc7df24.gif">  ;  if not already accessed, then just the number of requests from the beginning.  Then the processing time <img src="http://habrastorage.org/getpro/habr/post_images/601/5f7/e7e/6015f7e7e19971bf1372e01171eaadcb.gif">  requests will be <img src="http://habrastorage.org/getpro/habr/post_images/65d/250/85a/65d25085aec30c33ef47e960ff608e05.gif">  . <br><br>  This fact formalizes my reasoning about the cache at the beginning of the article.  In fact, he says that, on average, the recently requested element does not float far from the root. <br><br>  <b>Scanning theorem</b> Sequential access (LUR) to the elements of a <code>splay</code> tree is performed in <img src="http://habrastorage.org/getpro/habr/post_images/39a/ed9/498/39aed9498a90431e37a7b32ffe2338cd.gif">  . <br><br>  This fact has a great practical implication.  Together with the split and merge operations, it makes <code>splay</code> trees an excellent basis for the <code>rope</code> data structure.  Read more about it you can read the posts Habr <a href="http://habrahabr.ru/post/144736/">Ropes - quick lines</a> and <a href="http://habrahabr.ru/post/112394/">Monoids and their applications ....</a> <br><br>  Thanks for attention! <br><br><h4>  Literature </h4><br><ul><li>  Tarjan "Data Structures and Networks Algorithms" </li><li>  Sleator, Daniel D .;  Tarjan, Robert E. (1985), "Self-Adjusting Binary Search Trees" </li></ul><br><br>  <b>UPD</b> . <h4>  Pragmatics note </h4><br>  In the comments there is a reasonable question about the applicability of this algorithm in practice.  Before answering it, I want to note that this post first of all introduces the reader to the algorithm itself and its theoretical foundations.  For this reason, questions about effective implementation, details and optimization tricks, of which there are quite a lot, I left outside the article. <br><br>  A study of the performance and scope of splay-trees turned out to be a topic for a dozen articles.  The review <a href="http://benpfaff.org/papers/libavl.pdf">‚ÄúPerformance Analysis of BSTs in System Software‚Äù Pfaff</a> , which compares 20 balanced trees with different internal representations of nodes, looks very optimistic.  Testing is performed on real data for the tasks of managing virtual memory, caching IP packets and resolving cross-references.  On virtual memory and cross-references, splay trees have performed their best;  on the IP packets, AVL- and red-black trees gave way.  High performance due to the feature of real data.  Details of the study is better to read in the article itself. <br><br>  You can also read in detail the report on the performance of splay-trees and the issue of reducing the number of turns in the article <a href="http://koti.kapsi.fi/~jukujala/papers/wea08.pdf">‚ÄúReducing Splaying by Working Advantage of Working Sets‚Äù by Timi Aho and etc.</a>  The reference list at the end of the article contains several more performance reports. </div><p>Source: <a href="https://habr.com/ru/post/210296/">https://habr.com/ru/post/210296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210284/index.html">13 hacks for your Nokia Lumia</a></li>
<li><a href="../210286/index.html">Spatio-temporal image processing on GPU</a></li>
<li><a href="../210288/index.html">Cheat Sheet by Design Patterns</a></li>
<li><a href="../210290/index.html">Bill Gates lost to Magnus Carlsen in chess in 9 moves</a></li>
<li><a href="../210294/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ93 (January 19 - 25, 2014)</a></li>
<li><a href="../210298/index.html">Why do I bet on Julia</a></li>
<li><a href="../210300/index.html">Because of the glitch of Google, thousands of emails went to one Hotmail inbox</a></li>
<li><a href="../210304/index.html">PyQt. Manage memory, collect garbage</a></li>
<li><a href="../210306/index.html">Size matters. Choosing a medium format camera</a></li>
<li><a href="../210308/index.html">MegaFon subscribers owning iPhone 5S and 5C now have access to LTE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>