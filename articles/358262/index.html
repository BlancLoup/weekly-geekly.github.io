<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unreal Engine 4 Tutorial: Paint Filter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Over time, the appearance of games is getting better and better. In an era of stunning graphics, it is difficult to make your own game stand out from ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unreal Engine 4 Tutorial: Paint Filter</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25b/b5d/a1d/25bb5da1d9956ec4a2d08208b7ecd4b1.gif" alt="image"></div><br>  Over time, the appearance of games is getting better and better.  In an era of stunning graphics, it is difficult to make your own game stand out from the rest.  One of the ways to make the game more graphically unique is to use non-photorealistic rendering. <br><br>  Non-realistic rendering includes many rendering techniques.  They include cel shading, toon-contours and shading.  You can even make the game look like a picture!  One way to get this effect is to blur the Kawahara filter. <br><br>  To implement Kawahara filtering, we will learn the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Calculate the mean and variance for several cores. </li><li>  Show the average value for the kernel with the lowest variance </li><li>  Use the Sobel operator to find the local orientation of a pixel. </li><li>  Rotate sampling cores based on pixel local orientation </li></ul><a name="habracut"></a><br><blockquote>  <em>Note:</em> this tutorial assumes that you are already familiar with the basics of the Unreal Engine.  If you only master the Unreal Engine, then study our series of tutorials <a href="https://habr.com/post/344394/">Unreal Engine for beginners</a> from ten parts. <br><br>  Since HLSL is used in this tutorial, you should be familiar with it or a language similar to it, for example, C #. </blockquote><br><blockquote>  <em>Note:</em> this tutorial is the fourth part of the shader tutorial series: <br><br><ul><li>  <a href="https://habr.com/post/350172/">Part 1: Cel Shading</a> </li><li>  <a href="https://habr.com/post/352814/">Part 2: Toon-contours</a> </li><li>  <a href="https://habr.com/post/353722/">Part 3: HLSL native shaders</a> </li><li>  Part 4: Paint Filter </li></ul></blockquote><br><h2>  Getting Started </h2><br>  Start by downloading tutorial <a href="">content</a> .  Unzip them, go to <em>PaintFilterStarter</em> and open <em>PaintFilter.uproject</em> .  You will see the following scene: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/767/570/549/7675705491c369d3c46fd2743c0cd3c5.jpg"></div><br>  To save time, the scene already has a Post Process Volume with <em>PP_Kuwahara</em> .  This is the material (and shader files) that we will modify. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a8/dc4/d34/9a8dc4d345ad851b57b3bcca7b786175.jpg"></div><br>  First, let's understand what the Kawahara filter is and how it works. <br><br><h2>  Filter Kawahara </h2><br>  When shooting photos, you may notice a grainy texture on the image.  This is a <em>noise</em> that we absolutely do not need. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f2/463/e20/3f2463e2018f92576216db32dbfa92af.png"></div><br>  Usually get rid of the noise using a low pass filter, such as blur.  Below is a noisy image after applying a box blur to it with a radius of 5. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/464/97c/388/46497c3886fe284f19d700fc180d85d4.jpg"></div><br>  Most of the noise has disappeared, but all borders have lost their sharpness.  That would exist a filter that could smooth the image <i>and</i> preserve the borders of objects! <br><br>  As you might have guessed, the Kawahara filter meets all these requirements.  Let's see how it works. <br><br><h3>  How Kawahara Filtering Works </h3><br>  As in convolutions, kernels are used in filtering Kawahars, but four are used instead of one.  The cores are arranged in such a way that they overlap in one pixel (in the current).  Below is an example of kernels for the Kawahara filter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ad/cf5/a47/9adcf5a476810e4d6d0c964322a23ed7.gif"></div><br>  First, we calculate the <em>average</em> (average color) for each core.  So we erode the core, that is, we smooth the noise. <br><br>  We also calculate the <em>variance</em> for each core.  In fact, it is a measure of how much color varies in the core.  For example, a core with similar colors will have a <em>low</em> variance.  If the colors are different, then the dispersion of the core will be <em>high</em> . <br><br><blockquote>  <em>Note:</em> If you are not familiar with the concept of variance or do not know how to calculate it, then read the article <a href="https://www.mathsisfun.com/data/standard-deviation.html">Standard Deviation and Variance</a> on Math is Fun. </blockquote><br>  Finally, we find the core with the smallest variance and derive its average value.  It is thanks to the selection on the basis of the dispersion that the Kawahara filter allows you to maintain boundaries.  Let's look at a few examples. <br><br><h3>  Kawahara filtering examples </h3><br>  Below is a 10 √ó 10 image in grayscale.  It can be seen that it has a border that goes from the lower left to the upper right corner.  You may also notice that in some areas of the image there is noise. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bde/8a5/b4a/bde8a5b4af46c261dba35fe4ae2f17e7.jpg"></div><br>  First we select a pixel and determine which core has the smallest variance.  Here is the pixel near the border and its associated cores: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a4/60e/4c8/6a460e4c87d7e80ae5add1cbc75d7460.gif"></div><br>  As you can see, the nuclei lying on the border vary greatly in color.  This tells us about high dispersion and means that the filter will not select them.  Avoiding the choice of kernels lying on the border, the filter eliminates the problem of blurred borders. <br><br>  For this pixel, the filter will choose the green core, because it is the most homogeneous.  The output value will then be the average value for the green core, that is, the color close to black. <br><br>  Here is another pixel of the border and its core: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e56/978/1ff/e569781ff716ba7f59eba0a21065202a.gif"></div><br>  This time the yellow core has the smallest dispersion, because it is the only one that is not on the border.  Therefore, the output value will be the average of the yellow core, that is, a color close to white. <br><br>  Below is a comparison between box blur and Kawahara filtering with a radius of 5. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/12c/aa8/53912caa85b23e710d00dc9bc6974026.gif"></div><br>  As you can see, the filtering of Kawahara perfectly copes with smoothing and preserving borders.  In our case, the filter even made the border sharper! <br><br>  Coincidentally, this anti-aliasing function with the preservation of borders can give the image the appearance of a painted picture.  Since brush strokes usually have sharp edges and low noise, the Kawahara filter turns out to be a convenient choice for converting realistic images to artistic style. <br><br>  Here is the result of performing a Kawahara filter for photos with variable size: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ae/9f5/39c/5ae9f539c7585c3a59ca43ff31590191.gif"></div><br>  Looks pretty nice, right?  Let's start creating the Kawahara filter. <br><br><h2>  Creating a Kawahara filter </h2><br>  In this tutorial, the filter is split into two shader files: <em>Global.usf</em> and <em>Kuwahara.usf</em> .  The first file will store the function for calculating the mean and the variance of the kernel.  The second file is the input point of the filter, which will call the above function for each core. <br><br>  First we will create a function to calculate the mean and variance.  Open the project folder in the OS and go to the <em>Shaders</em> folder.  Then open <em>Global.usf</em> .  Inside you will find the <code>GetKernelMeanAndVariance()</code> function. <br><br>  Before we start creating a function, we need an additional parameter.  Change the function signature as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetKernelMeanAndVariance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 UV, float4 Range)</span></span></span></span></code> </pre> <br>  To sample the mesh, we need two <code>for</code> : one for horizontal offsets.  the second is for vertical.  The first two channels of the <em>Range</em> will contain the boundaries of the horizontal loop.  The second two will contain the boundaries of the vertical cycle.  For example, if we sample the upper left core and the filter has a radius of <em>2</em> , then the <em>Range</em> will have the values: <br><br><pre> <code class="cpp hljs">Range = float4(<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Now it's time to start sampling. <br><br><h3>  Pixel sampling </h3><br>  First we need to create two <code>for</code> .  Add the following code to <code>GetKernelMeanAndVariance()</code> (under variables): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = Range.x; x &lt;= Range.y; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = Range.z; y &lt;= Range.w; y++) { } }</code> </pre> <br>  This will give us all the core offsets.  For example, if we sample the upper left core and the filter has a radius of <em>2</em> , then the offsets will be in the range from <em>(0, 0)</em> to <em>(-2, -2)</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbf/78c/32b/cbf78c32b15ed43063474d176d91786d.jpg"></div><br>  Now we need to get the pixel color of the sample.  Add the following code to the internal <code>for</code> loop: <br><br><pre> <code class="cpp hljs">float2 Offset = float2(x, y) * TexelSize; float3 PixelColor = SceneTextureLookup(UV + Offset, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>).rgb;</code> </pre> <br>  The first line gets the offset of the sample pixel and converts it into UV space.  The second line uses the offset to get the color of the sample pixel. <br><br>  Now we need to calculate the mean and variance. <br><br><h3>  Calculate the mean and variance </h3><br>  Calculating the average is a fairly simple task.  We simply sum up all the colors and divide them by the number of pixels in the sample.  For variance, we use the formula below, where <em>x</em> is the color of the sample pixel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c6/9c2/5c5/6c69c25c5aabdcb0584fef20da7634a5.jpg"></div><br>  The first thing we need to do is calculate the amounts.  To get an average, we just need to add the colors in the variable <em>Mean</em> .  To obtain a dispersion, we need to square the color, and then add it to the <em>Variance</em> .  Add the following code below: <br><br><pre> <code class="cpp hljs">Mean += PixelColor; Variance += PixelColor * PixelColor; Samples++;</code> </pre> <br>  Next, add the following after <code>for</code> loops: <br><br><pre> <code class="cpp hljs">Mean /= Samples; Variance = Variance / Samples - Mean * Mean; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> TotalVariance = Variance.r + Variance.g + Variance.b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(Mean.r, Mean.g, Mean.b, TotalVariance);</code> </pre> <br>  The first two lines calculate the mean and variance.  However, a problem arises: dispersion is distributed between <em>RGB</em> channels.  To solve it, in the third line we summarize the channels to get the <em>total</em> variance. <br><br>  At the end, the function returns the mean and variance in the form <em>float4</em> .  The average value is in the <em>RGB</em> channels, and the variance is in channel <em>A.</em> <br><br>  Now that we have a function to calculate the mean and variance, we need to call it for each core.  Return to the <em>Shaders</em> folder and open <em>Kuwahara.usf</em> .  First we need to create some variables.  Replace the code inside with the following: <br><br><pre> <code class="cpp hljs">float2 UV = GetDefaultSceneTextureUV(Parameters, <span class="hljs-number"><span class="hljs-number">14</span></span>); float4 MeanAndVariance[<span class="hljs-number"><span class="hljs-number">4</span></span>]; float4 Range;</code> </pre> <br>  Here is what each variable is used for: <br><br><ul><li>  <em>UV:</em> UV coordinates of the current pixel. </li><li>  <em>MeanAndVariance: an</em> array to store the average and variance of each core </li><li>  <em>Range:</em> used to store the boundaries of the <code>for</code> loops of the current kernel </li></ul><br>  Now we need to call for each kernel <code>GetKernelMeanAndVariance()</code> .  To do this, add the following: <br><br><pre> <code class="cpp hljs">Range = float4(-XRadius, <span class="hljs-number"><span class="hljs-number">0</span></span>, -YRadius, <span class="hljs-number"><span class="hljs-number">0</span></span>); MeanAndVariance[<span class="hljs-number"><span class="hljs-number">0</span></span>] = GetKernelMeanAndVariance(UV, Range); Range = float4(<span class="hljs-number"><span class="hljs-number">0</span></span>, XRadius, -YRadius, <span class="hljs-number"><span class="hljs-number">0</span></span>); MeanAndVariance[<span class="hljs-number"><span class="hljs-number">1</span></span>] = GetKernelMeanAndVariance(UV, Range); Range = float4(-XRadius, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, YRadius); MeanAndVariance[<span class="hljs-number"><span class="hljs-number">2</span></span>] = GetKernelMeanAndVariance(UV, Range); Range = float4(<span class="hljs-number"><span class="hljs-number">0</span></span>, XRadius, <span class="hljs-number"><span class="hljs-number">0</span></span>, YRadius); MeanAndVariance[<span class="hljs-number"><span class="hljs-number">3</span></span>] = GetKernelMeanAndVariance(UV, Range);</code> </pre> <br>  So we get the average and variance of each core in the following order: upper left, upper right, lower left and lower right. <br><br>  Next, we need to choose a kernel with the smallest variance and derive its average value. <br><br><h3>  Selection of a kernel with the lowest variance </h3><br>  To select the core with the least variance, add the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 float3 FinalColor = MeanAndVariance[0].rgb; float MinimumVariance = MeanAndVariance[0].a; // 2 for (int i = 1; i &lt; 4; i++) { if (MeanAndVariance[i].a &lt; MinimumVariance) { FinalColor = MeanAndVariance[i].rgb; MinimumVariance = MeanAndVariance[i].a; } } return FinalColor;</span></span></code> </pre> <br>  Here is what each part does: <br><br><ol><li>  Creates two variables for storing the final color and least variance.  Initializes them both with the mean and variance values ‚Äã‚Äãof the first core. </li><li>  Loops around the remaining three cores.  If the dispersion of the current core is lower than the smallest, then its average and dispersion become new <em>FinalColor</em> and <em>MinimumVariance</em> .  After executing the cycles, <em>FinalColor</em> is <em>displayed,</em> which will be the average value of the kernel with the least variance. </li></ol><br>  Go back to Unreal and go to <em>Materials \ PostProcess</em> .  Open <em>PP_Kuwahara</em> , make no impact changes, and click <em>Apply</em> .  Go back to the main editor and look at the results! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/791/59c/86e/79159c86e6d7a40b9cff8155b0a6457a.gif"></div><br>  It looks pretty good, but if you look closely, you can see that there are strange block areas in the image.  I highlighted some of them: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e10/53c/fd2/e1053cfd29d64a17a975b541972d071f.jpg"></div><br>  This is a side effect of using core-aligned cores.  We can reduce this effect by applying an improved version of the filter, which I call the <em>Kawahara directional filter</em> . <br><br><h2>  Directional Filter Kawahara </h2><br>  This filter is similar to the original one, but now the cores will be aligned relative to the local orientation of the pixels.  Here is an example of a kernel in the directional filter of Kawahara: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dde/8fb/3b6/dde8fb3b618f93ef8ee10eb1fd837107.jpg"></div><br><blockquote>  <em>Note:</em> since we can represent the core in the form of a matrix, we write the measurements in the form <em>height x width</em> instead of the usual <em>width x height</em> .  We will talk more about matrices below. </blockquote><br>  Here the filter determines the orientation of the pixel so that it is located along the border.  Then you can rotate the entire core accordingly. <br><br>  To calculate the local orientation, the filter performs a convolution pass using <em>the Sobel operator</em> .  If the term ‚ÄúSobel operator‚Äù sounds familiar to you, it is because it is a popular border recognition technique.  But if this is a method of recognizing boundaries, how can it be used to obtain a local orientation?  To answer this question, we need to understand how the Sobel operator works. <br><br><h3>  How does the operator Sobel </h3><br>  Instead of one core, two are used in the Sobel operator. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d53/168/c78/d53168c780083be035e0bb5c93320c4d.jpg"></div><br>  <em>Gx</em> gives us a <a href="https://www.mathsisfun.com/gradient.html">gradient</a> in the <em>horizontal</em> direction.  <em>Gy</em> gives us a gradient in the <em>vertical</em> direction.  Let‚Äôs use this 3 √ó 3 gray scale image as an example: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/023/770/fa8/023770fa8c4423b35df046f3a3662956.jpg"></div><br>  First, we perform the convolution of the average pixel for each core. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4f/347/752/b4f3477526d196f0aeea0d4b5de9943f.jpg"></div><br>  If each value is plotted on a 2D plane, we will see that the resulting vector points in the same direction as the border. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/fc3/9be/65cfc39be9dde8f1f5db7b1a8038b8b5.jpg"></div><br>  To find the angle between the vector and the X axis, we substitute the values ‚Äã‚Äãof the gradients into the arctangent function (atan).  After that we can use the resulting angle to rotate the core. <br><br>  This is how we can use the Sobel operator to get the local orientation of a pixel.  Let's try to do it. <br><br><h3>  Finding a local orientation </h3><br>  Open <em>Global.usf</em> and add the following code inside <code>GetPixelAngle()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> GradientX = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> GradientY = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SobelX[<span class="hljs-number"><span class="hljs-number">9</span></span>] = {<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SobelY[<span class="hljs-number"><span class="hljs-number">9</span></span>] = {<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  <em>Note:</em> Notice that the last bracket in <code>GetPixelAngle()</code> missing.  This is intentional!  If you want to know why to do this, read our <a href="https://habr.com/post/353722/">HLSL</a> tutorial on <a href="https://habr.com/post/353722/">shaders</a> . <br><br>  Here is what each variable is used for: <br><br><ul><li>  <em>GradientX:</em> stores gradient for horizontal direction </li><li>  <em>GradientY:</em> stores gradient for vertical direction </li><li>  <em>SobelX: the</em> core of the horizontal Sobel operator as an array </li><li>  <em>SobelY: the</em> core of the vertical Sobel operator as an array </li><li>  <em>i:</em> used to access each element in <em>SobelX</em> and <em>SobelY</em> </li></ul><br>  Next, we need to perform convolution using <em>SobelX</em> and <em>SobelY cores</em> .  Add the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">-1</span></span>; x &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">-1</span></span>; y &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; y++) { <span class="hljs-comment"><span class="hljs-comment">// 1 float2 Offset = float2(x, y) * TexelSize; float3 PixelColor = SceneTextureLookup(UV + Offset, 14, false).rgb; float PixelValue = dot(PixelColor, float3(0.3,0.59,0.11)); // 2 GradientX += PixelValue * SobelX[i]; GradientY += PixelValue * SobelY[i]; i++; } }</span></span></code> </pre> <br>  Here is what happens in each part: <br><br><ol><li>  The first two lines get the pixel color of the sample.  The third line reduces color saturation by converting it to a grayscale value.  This simplifies the calculation of the gradients of the image as a whole, instead of obtaining gradients for each color channel. </li><li>  For both cores, multiply the pixel value in shades of gray by the corresponding core element.  Then we add the result to the corresponding gradient variable.  Then increment <em>i</em> occurs so that it contains the index of the next kernel element. </li></ol><br>  To get the angle, we use the <code>atan()</code> function and substitute our gradient values.  Under the <code>for</code> loops, add the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">atan</span></span>(GradientY / GradientX);</code> </pre> <br>  Now that we have a function for obtaining the pixel angle, we need to somehow apply it to rotate the core.  We can do this with a <em>matrix</em> . <br><br><h2>  What is a matrix? </h2><br>  A matrix is ‚Äã‚Äãa two-dimensional array of numbers.  For example, here‚Äôs a 2 √ó 3 matrix (with two rows and three columns): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/202/387/6e0/2023876e01ab8bc3822396f49799acfa.jpg"></div><br>  By itself, the matrix does not look particularly interesting.  But the true power of matrices is manifested when we multiply it with a vector.  This allows us to perform actions such as rotation and scaling (depending on the type of matrix).  But how do we create a matrix for the rotation? <br><br>  In the coordinate system, we have a vector for each dimension.  These are the <em>basic vectors</em> defining the positive directions of the axes. <br><br>  Below are some examples of different basis vectors for a two-dimensional coordinate system.  The red arrow shows the positive direction in X. The green arrow indicates the positive direction in Y. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e99/4ce/e52/e994cee521d8e70acdea4ecebf472d4b.jpg"></div><br>  To rotate a vector, we can use these basis vectors to construct <em>a rotation matrix</em> .  It is simply a matrix containing the positions of the basis vectors <em>after</em> rotation.  For example, imagine that we have a vector (orange arrow) in coordinates <em>(1, 1)</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/482/9aa/ab0/4829aaab099b3413959a75edf273a9cd.jpg"></div><br>  Suppose we want to rotate it 90 degrees clockwise.  First, we rotate the basis vectors by the same amount. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a45/9d5/a83/a459d5a839ff23f1ef5a6bebb25d38c4.jpg"></div><br>  Then we build a 2 √ó 2 matrix, applying the new positions of the basis vectors.  The first column is the position of the red arrow, and the second is the position of the green arrow.  This is our rotation matrix. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd4/9f4/35b/cd49f435bf72ec1fd131244b911b27be.jpg"></div><br>  Finally, we perform matrix multiplication using an orange vector and a rotation matrix.  The result will be the new position of the orange vector. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26c/efd/306/26cefd30680da1035bd38abf51c69967.jpg"></div><br><blockquote>  <em>Note:</em> you do not need to know how matrix multiplication is performed, because HLSL has a built-in function for this.  But if you want to know, then study the article <a href="https://www.mathsisfun.com/algebra/matrix-multiplying.html">How to Multiply Matrices</a> on Math is Fun. </blockquote><br>  Is not that great?  But even better, we can use the matrix shown above to rotate <i>any</i> 2D vector 90 degrees clockwise.  If we talk about our filter, it means that we need only once to create a rotation matrix for each pixel and use it for the entire core. <br><br>  Now it's time to rotate the core using the rotation matrix. <br><br><h2>  Core rotation </h2><br>  First we need to change <code>GetKernelMeanAndVariance()</code> to get a 2 √ó 2 matrix.  This is necessary because we will create a rotation matrix in <em>Kuwahara.usf</em> and transmit it.  Change the <code>GetKernelMeanAndVariance()</code> signature as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetKernelMeanAndVariance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 UV, float4 Range, float2x2 RotationMatrix)</span></span></span></span></code> </pre> <br>  Next, replace the first line of the inner <code>for</code> loop with the following code: <br><br><pre> <code class="cpp hljs">float2 Offset = mul(float2(x, y) * TexelSize, RotationMatrix);</code> </pre> <br>  <code>mul()</code> will perform matrix multiplication using offset and <em>RotationMatrix</em> .  So we will rotate the offset around the current pixel. <br><br>  Next, we need to create a rotation matrix. <br><br><h3>  Creating a rotation matrix </h3><br>  To create the rotation matrix, we apply the sine and cosine functions as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/207/8c5/0e7/2078c50e7f0b0c031ff247acfb53c617.jpg"></div><br>  Close <em>Global.usf</em> and open <em>Kuwahara.usf</em> .  Then add the following below the list of variables: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Angle = GetPixelAngle(UV); float2x2 RotationMatrix = float2x2(<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(Angle), -<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(Angle), <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(Angle), <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(Angle));</code> </pre> <br>  The first line calculates the angle of the current pixel.  The second line creates a rotation matrix using an angle. <br><br>  Finally, we need to pass for each <em>RotationMatrix</em> core.  Change each call to <code>GetKernelMeanAndVariance()</code> as follows: <br><br><pre> <code class="cpp hljs">GetKernelMeanAndVariance(UV, Range, RotationMatrix)</code> </pre> <br>  And on this we have completed the creation of the directional filter Kawahara!  Close <em>Kuwahara.usf</em> and return to <em>PP_Kuwahara</em> .  Make no impact changes, click <em>Apply</em> and close it. <br><br>  The image below shows a comparison of the conventional and directional Kawahara filters.  Note that the directional filter does not create blockiness. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25b/b5d/a1d/25bb5da1d9956ec4a2d08208b7ecd4b1.gif"></div><br><blockquote>  <em>Note: You</em> can use <em>PPI_Kuwahara</em> to resize the filter.  I recommend changing the filter size so that the radius of <em>X is</em> greater than the radius of <em>Y.</em>  This will increase the size of the core along the border and will help in creating directivity. </blockquote><br><h2>  Where to go next? </h2><br>  Download the finished project at the <a href="">link</a> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to know more about the Kawahara filter, then you can read the article about the </font></font><a href="http://www.kyprianidis.com/p/pg2009/jkyprian-pg2009.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kawahara anisotropic filtering</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In fact, the Kawahara directional filter is a simplified version of the filter presented in this article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I recommend that you experiment with the matrices in order to use them to create new effects. </font><font style="vertical-align: inherit;">For example, you can use a combination of rotation and blur matrices to create a radial or circular blur. </font><font style="vertical-align: inherit;">If you want to know more about matrices and how they work, then learn the 3Blue1Brown video series </font></font><a href="https://www.youtube.com/watch%3Fv%3DkYB8IZa5AuE%26vl%3Den"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essence of Linear Algebra</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/358262/">https://habr.com/ru/post/358262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358250/index.html">UI components on pixel shaders: write your first shader</a></li>
<li><a href="../358252/index.html">What I learned from personal experience over the years of freelancing</a></li>
<li><a href="../358256/index.html">What's New in PostgreSQL 11: Improved Casting</a></li>
<li><a href="../358258/index.html">How tickets in support turn into tickets in Jira</a></li>
<li><a href="../358260/index.html">Four ways to work with text UI in Unity</a></li>
<li><a href="../358264/index.html">Kubernetes-ha. Deploy Kubernetes failover cluster with 5 masters</a></li>
<li><a href="../358268/index.html">New trend at IT interviews: whole days of unpaid homework</a></li>
<li><a href="../358274/index.html">Patch Tuesday: critical patches you might have missed</a></li>
<li><a href="../358276/index.html">Survey from Veeam Academy. Do you want to go through intensive C # in the summer?</a></li>
<li><a href="../358278/index.html">Guice Almighty: assistedinject, multibindings, generics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>