<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Robot-car team AURORA on ‚ÄúRobokross-2013‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 
 It is becoming a tradition to publish team reports after performing at RoboCross competitions. 
 Last season there were reports from the N...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Robot-car team AURORA on ‚ÄúRobokross-2013‚Äù</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage3/940/beb/6c9/940beb6c9c6b99f406cc7a130b47c37c.png"><br>  Hi, Habr! <br>  It is becoming a tradition to publish team reports after performing at RoboCross competitions. <br>  Last season there were reports from the <a href="http://habrahabr.ru/post/154017/">NAMT</a> and <a href="http://habrahabr.ru/post/150667/">MobRob teams</a> , and now, I would like to tell you about the work of our team. <br><br>  I will talk about how we did the robot, and why we did it that way.  I hope it will be interesting to members of other teams, or just interested in similar subjects. <br><a name="habracut"></a><br>  My name is Vladimir, I am a graduate student, a member of the Autonomous Robots RadioUniversity (AURORA) Ryazan team.  My main interests are artificial intelligence, a team activity is software development.  The team represents the student design bureau (SKB) of our uni. <br><br><a name="challenge"></a><h4>  Task description </h4><br>  Competitions ‚ÄúRobokross-2013‚Äù ‚Äã‚Äãwere held at the avtogonigone ‚ÄúBirch Forest‚Äù of the GAZ plant (Nizhny Novgorod) from July 17 to 20.  Under the race, a section of the ‚Äúsports circle‚Äù was allocated, about 100m long. <br>  The essence of the task: the robot-car autonomously moves behind a man at a slow speed (about 5-7 km / h), and remembers the route.  Then it turns around (in manual or offline mode) and, at the command of the operator, must autonomously return to the starting point.  At the same time, on the way back, the judges set several obstacles on the road, which were not there when moving forward (plastic barrels). <br>  The task is similar to the behavior of a mule - if he is brought into the mountains and released, he will find the way and return to the herd.  The task was taken by analogy with one of the tasks ELROB-2012 (European competition of robot-cars). <br>  When performing the task, the time spent on the movement from start to finish, as well as the number of knocked down obstacles, was estimated.  The winner could only be a robot with fully autonomous control. <br>  Despite the apparent simplicity, only a few teams coped with the task (successfully reached the finish line). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="hardware"></a><h4>  Description of mechanics and electronics </h4><br>  Several people work on the robot car.  About three each - above the mechanics, electronics, and top-level programming.  There are no clear posts - everyone should be able to understand several areas.  The team worked on the creation of the robot for 2 months, working even on Sundays, and leaving the laboratory not earlier than 21.00. <br><br>  Mechanics and electronics are the ‚Äúmuscles‚Äù and ‚Äúperipheral nervous system‚Äù of the robot. <br><br><h5>  Mechanics </h5><br>  Mechanics are a set of actuators that drive a vehicle‚Äôs controls.  When developing mechanics, the main requirement was to make an easily removable structure, so that you can quickly disassemble everything, and the car turned into a regular Gazelle. <br>  The actuator unit that controls the gas / brake / clutch pedals and the gear selector is located under the driver‚Äôs seat on the seat mounting.  Those.  you can sit in the driver's seat (legs, however, is not very comfortable). <br><img src="https://habrastorage.org/storage3/106/ed2/817/106ed281757ff2f0fe68bd1f54ad7bfb.png"><br>  <i>Pedal unit</i> <br><br>  To connect the pedals used special levers, brackets, which are thrown on the pedals. <br>  The wheel is set in motion by a motor that is connected through a chain to the steering gimbal (it was necessary to cut it and weld the gear, but this was done several years ago, so it was decided to leave it as it is). <br><img src="https://habrastorage.org/storage3/ea6/48b/46d/ea648b46d44ceb1bc1b09db0aee71970.png"><br>  <i>Here the blue encoder on the same shaft with the motor is connected by a chain with the steering cardan (under the hood)</i> <br><br>  The ignition circuit is in two modes - when the car starts with a key (as usual), or it is connected via a relay and safety buttons so that you can start autonomously.  Once we paid for this switching method, having forgotten to switch the mode - the car cannot be stopped in case of loss of control.  But everything worked out. <br><br><h5>  Electronics </h5><br>  We use our own electronics for all of our robotic projects.  And develop it from scratch.  It seems you can buy Arduino, NI RIO, and some kind of motor controller, or something like that, it will turn out cheaper and faster.  But there are a few but.  Learning how to tweak something, or even more to improve it, can only be known how it all works.  What is called a "feel" system.  And to do this, you can only try to repeat it yourself, taking steps, figuring out what, why, and how.  We have already had development experience, and for several years we have developed this area.  And if in the first seasons we lagged behind the teams that use ready-made solutions, now we have experienced circuitry developers, well-established solutions and can fully adapt them to any needs. <br><img src="https://habrastorage.org/storage3/bae/af8/392/baeaf83925b0b9da38f5eda8260e77a9.png"><br>  <i>Motor control board</i> <br><br>  Electronics and ‚Äúlow level‚Äù software are represented entirely by our solution - <a href="http://www.kb-avrora.ru/unimoto_ru">motor control cards</a> .  The firmware of each board is adapted for a specific task - clutch / brake or steering control.  The corresponding algorithm is ‚Äúwired up‚Äù in each.  Feedback on absolute and relative encoders, as well as limit switches and engine speed. <br><img src="https://habrastorage.org/storage3/3b6/ebf/2c9/3b6ebf2c9bc8f13283296eaf8d53ec01.png"><br>  <i>The control boards are mounted on a retractable rack, and can be easily removed under the driver's seat of the Gazelle.</i> <br><br>  Additionally, the boards are equipped with ‚Äúdry contacts‚Äù or relays, for programmatically switching on the ignition or light / sound alarm and switching on other actuators. <br><br>  Interesting is the problem of starting the car, which is especially evident when driving uphill.  It is necessary to monitor the engine speed and play the clutch / gas pedals so that the car does not stall.  The driver performs it on an intuitive level, but it is not very easy to do it automatically. <br><br>  The ‚Äúlow level‚Äù controller (using LPC NXP controllers with ARM7 architecture) controls the actuators based on the commands received from the ‚Äúhigh level‚Äù program (i386 arch).  Communication interface - RS232, normal COM-port.  A control command is a set of parameters {steering angle, speed, brake, auxiliary relays}.  The controller also sends the ‚Äútop level‚Äù the current engine speed and some other parameters necessary for making decisions. <br><br><a name="software"></a><h4>  Description of the program architecture and algorithms </h4><br>  Finally, I moved to the part I was working on directly. <br>  Many years ago, when everything was just beginning, all universities bought NI controllers for their teams.  We did not have the funds for them at that time, so it was decided to make the ‚Äúbrains‚Äù of the robot on i386 architecture, i.e.  normal laptop or desktop pc.  But I would hardly have gained development experience under Linux and embedded-linux, as well as well-known OpenCV image processing libraries, etc.  (I do not want to offend NI, we also recently appeared RIO - a curious thing). <br><br><h5>  Sensor Kit </h5><br>  A set of sensors used for these competitions: <br><ul><li>  encoders for steering and propeller shaft positioning (for positioning) </li><li>  weatherproof IP camera (for tag detection) </li><li>  SICK Line Laser Scanner (for building a cross-country map) </li><li>  orientation board (gyros + accelerometers) (for positioning) </li><li>  GPS receiver (for positioning) </li></ul><br>  Sensors are connected to the PC via RS232 and Ethernet. <br>  To handle the sensory data in the back of the Gazelle, an ordinary PC is installed.  The computer is powered by a gasoline generator, mounted outside under the body (symmetrically with the gas tank, on the opposite side). <br><br><h5>  Used libraries </h5><br>  The operating system we use is Ubuntu, the development environment is QtCreator, the language is C ++, the library for gui is Qt, the acquisition and processing of images is OpenCV, the processing of laser scanner data is PCL, and also the Boost for working with files and the network.  The result was a cross-platform solution.  However, we still use Ubuntu, since the system is more predictable, the antivirus or file indexing does not accidentally start working in the background, slowing down all other processes ... Yes, and the overall performance is slightly higher. <br><br><h5>  Following the label </h5><br>  The task of the competition involves the implementation of 2 elements - following the label and following the route.  Therefore, the program provided for two main modes of operation - for each element of the task, respectively. <br>  In the mode of following the label, the general algorithm of the program is extremely simple - you need to move behind the label and remember the points of the route until the operator removes the label.  The position of the steering wheel during movement is proportional to the position of the mark relative to the center of the frame. <br>  If the tag is lost, the robot beeps and after a while (0.5 seconds) starts to slow down.  This is done for security reasons, and logically it turns out quite well - when it is necessary for the car to stop, the label is removed (turned over by the back side). <br>  A label is a sign located on a pole (also for safety).  We used a pink circle with a black contour, as this color is rarely found in nature. <br><img src="https://habrastorage.org/storage3/0cc/e84/bcc/0cce84bcca0cdfe8ac8959708b8f4398.png"><br>  <i>Check the algorithm for the movement behind the label</i> <br><br>  To search for tags, several libraries were tried, but in the end a custom solution was implemented - search by form + color analysis.  This allows rejection of traffic signs and other circular objects that differ in color from the mark. <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/ASC7_gGj3IU%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700253,15700256&amp;usg=ALkJrhj1gWWwXbxX6iVMSMspagAfhAjTpQ" frameborder="0" allowfullscreen=""></iframe><br>  <i>Demonstration of the tag search algorithm</i> <br><br>  The coordinates of the route are described by the list {GPS point, orientation (angle of rotation), radius (when hit at which this point is considered to be reached)}.  At the end of the movement, the points are reversed and the route is saved. <br><br><h5>  Return to the starting point </h5><br>  At the stopping point, the operator removes the mark - and the robot stops.  The problem is that he must somehow turn around.  There were no restrictions on the way the robot turned around in the competition rules, so we chose the manual method - when the operator himself turns the car.  The trajectory planning algorithm, hypothetically, could have planned a reversal, but we decided to spend time debugging more necessary functions at that time. <br>  We immediately abandoned the ‚Äúsimple algorithms‚Äù of the type ‚ÄúIf the barrel on the left is the steering wheel to the right, if the target on the right is the steering wheel to the right,‚Äù etc.  I call it the "cattle method."  Obviously, with the appearance of a second barrel, or additional conditions, cattle-methods are not consistent. <br>  The autonomous movement algorithm can be represented as a consistent solution of the following questions: <br><img src="https://habrastorage.org/storage3/aea/9b1/82d/aea9b182d9dc5085fdc431a54f2eac7a.png" width="300"><br><br><h6>  Where I am? </h6><br>  In order to decide where the robot should go, what amendment to make to the trajectory, the robot must know where it is, i.e.  answer the question ‚Äúwhere am I?‚Äù.  For this purpose, you cannot use only data from a GPS receiver, since the GPS error is tens of meters, not to mention the movement near buildings or in a tunnel.  Moreover, if you stand in the field with a GPS receiver and remove the coordinates, then after a certain, having come to the same place, the coordinates will be significantly different.  Also, the problem is the low rate of issuance of coordinates - from 1 to 5 times per second, which is not enough to control the car even at a speed of 5 km / h - the system simply will not have time to react to the situation, and the robot will move like a drunk driver, or overshoot will occur. <br><br>  The way out of this situation is the use of several sensors of different nature, based on different physical phenomena.  In our robot, in addition to GPS, we use wheel encoders - determining the linear and angular velocity of the vehicle based on the data on how much the propeller shaft spins, and how the steering wheel was oriented.  As an additional channel, an orientation determination board based on gyroscopes, accelerometers and a magnetic compass is also used. <br>  Each sensor has a different rate of information output (for example, encoders - 70Hz, orientation board - 10 Hz).  They are also characterized by a different nature of errors.  Due to the inaccuracy of determining the size of the wheels and the length of the wheelbase of the car, navigation, based only on encoders, is characteristic of the accumulation of errors with time.  Gyroscopes are subject to thermal drift and vibration of the car body.  The compass reacts strongly to large metal objects (bridges, arches, etc.), respectively, the use of each sensor separately is also impossible. <br>  To combine the indications of various sensors, various techniques are used, we chose to use a variety of non-linear Kalman filter - Unscented Kalman Filter.  On the fingers, the principle of operation can be explained as follows: on the basis of the model of vehicle movement (it cannot teleport or move sideways), the readings of each sensor are predicted.  Then, the predicted value is compared with the actual (measured) and each sensor, in accordance with the probability that it shows the truth, put its weight (the closer to the predicted, the greater the confidence).  Based on the weights obtained, an estimate of the current position and orientation of the vehicle is formed. <br><br>  Using D-GPS, of course, would make the task easier, but it requires a subscription fee - you can not buy and forget (consumables are very problematic). <br>  Nevertheless, the obtained position estimate is acceptable for control - there are no marked jumps in coordinates, therefore, the trajectory control regulator behaves predictably. <br><br><h6>  Where to go? </h6><br>  When the position of the robot is known, it can be determined where the target point is relative to the robot.  The problem at this stage is that, as noted earlier, GPS is subject to slow drift - the coordinates ‚Äúfloat‚Äù during the day.  This can be explained by the inhomogeneities of the atmosphere, clouds, clouds - all of this affects the signal transit time. <br>  This is manifested as follows. <br><img src="https://habrastorage.org/storage3/1bb/6b7/1d9/1bb6b71d9baa9d2185ed24f97fbe4112.png"><br>  <i>GPS drift</i> <br><br>  As the robot waits at the pivot point, its current position begins to ‚Äúfloat‚Äù to the side.  Those.  if we launch it using the GPS-only method, it will move at a certain offset relative to the original trajectory, and the sensors will show that we are moving normally - they don‚Äôt know that all coordinates have moved.  This will lead to the fact that the robot will go along the side (well, or on the tree, or concrete blocks).  So, of course, no good. <br><br>  The solution to this problem is to use road position data when planning a path.  It is convenient to present this data in the form of a two-dimensional image - a cross-country map.  In fact, this picture is a top view, where the car is in the center, and passable areas are marked with one color (green), and impassable with another (white). <br><img src="https://habrastorage.org/storage3/78a/a0c/914/78aa0c91422afd297fe5d3626007e8fa.png"><br>  <i>The figure shows a real cross-country map during test runs at the stadium.</i> <br><br>  Competition conditions imply a road enclosed by concrete blocks and high vegetation - bushes and trees.  Therefore, it was decided to use only a linear laser scanner to obtain information about the obstacles that we fixed on the bumper of the car (see the first photo). <br><br>  The principle of operation of the laser scanner is similar to a laser range finder, only the more complex optical system rotates continuously, providing a viewing angle of 180 degrees with an angular resolution of 0.5 degrees and a maximum range of 80 meters with a measurement accuracy of 2 cm.  These parameters were enough for these competitions, and installing it at a certain height allowed us to see all possible obstacles on the track and the contour of the road. <br>  The scanner returns an array of ranges, which is then filtered from single attacks (from grass or just noise), leaving obstacles with an angular width of at least 2 degrees.  Then the array is drawn on the terrain map in polar coordinates relative to the center.  Before each update, the terrain map is filled with impassable color, and only passable areas are drawn on it.  This eliminates the algorithm for selecting a target point from the temptation to choose a point beyond the scanner's scope (in the shadow of concrete blocks or a fence).  If this happened, the trajectory planning algorithm could not build it, since the target point is not reachable. <br>  It is also important that the laser scanner is rigidly attached to the body.  As a consequence, the patency map is constructed in local coordinates, i.e.  we can not be mistaken with the location of the road in space. <br><br>  So, we have a map of the terrain, the current position of the robot and the current point of the route to be reached.  This is where the target point selection algorithm comes into play.  It combines these data to obtain a valid (correct) target point to which the car can be guaranteed to reach. <br>  The principle of its operation is quite simple - a randomized selection of a set of points on the terrain map, next to the ideal target.  Then the point nearest to the target is selected.  The geometrical dimensions of the car are also taken into account - there must be free space around a point so that movement in the chosen area is safe.  If the original target goes beyond the size of the permeability map, then the point shifts the distance Rmax (in our case, the map size is 40 * 40 meters, Rmax = 15m) so that it lies on the map, and then the search is performed. <br><img src="https://habrastorage.org/storage3/cef/19d/62c/cef19d62ca0d7bbbb518dd156a043a00.png"><br>  <i>Schematic image of the cross-country map</i>  <i>The white square symbolizes an impassable area.</i> <br><br><h6>  How to go? </h6><br>  At the moment, the management task is reduced to the fact that we need to get from the center of the cross-country map to the target point.  Again, the problem is that the classic shortest path search algorithms (A *, etc.) do not work here.  Why? <br><br>  Firstly, the space in which the robot-car moves is continuous.  The coordinates (x, y) are real numbers.  Classical algorithms are designed for discrete state space.  Here, the set of transitions is infinite, and they will not work out. <br><br>  Secondly, the car is a nonholonomic system.  This means that the car cannot instantly change its position or orientation in space.  Moreover, his next position is rather ‚Äúrigidly‚Äù connected with the previous one - the restriction on the derivative of speed, the inability to instantly stop or change the direction of motion.  Therefore, even if we construct the shortest path using a discrete algorithm (for example, rounding the coordinates to integers), then it will not be possible to drive along such a trajectory. <br><br>  From all this it follows that it is not possible to obtain the shortest trajectory by the search method.  In this case, we can only talk about the ‚Äúnear-optimal‚Äù trajectory.  Such a trajectory is not the shortest.  It is more important for us that the robot at the end point of the trajectory has the required orientation - if the robot arrives at the intermediate vertex perpendicular to the road - this will end badly.  (Although in the background it is still important that the robot loop as little as possible). <br><img src="https://habrastorage.org/storage3/3f3/28d/116/3f328d1162c9166c27449fef8d64f752.png"><br>  <i>You can come to the same point in different ways.</i> <br><br>  Various algorithms are used to find the path in the continuous state space.  One of the most popular are the Rapidly exploring Random Tree (RRT) species.  When the RRT works, the enumeration of all possible states is not performed.  Instead, the entire space (in the general case) of states is covered by uniformly distributed vertices, which are then used as reference points for constructing the decision tree. <br>  However, in its pure form, the RRT is not suitable for planning the trajectory of the car, since, again, it does not take into account the kinematic constraints.  Therefore, in our work we used the algorithm proposed by Kuwata, Y and others [1]. <br>  The general idea remains the same as in the RRT.  On the way of the car, N intermediate states are randomly selected. <br><img src="https://habrastorage.org/storage3/370/3df/5cf/3703df5cf69509725ba6eec1d05edacb.png"><br>  <i>Black circles indicate intermediate states.</i>  <i>Red circle - the purpose and orientation of the car in it</i> <br><br>  Then a tree of trajectories is built from the source vertex.  The process of checking the reachability of neighboring points is modified according to the model of movement of the car. <br><img src="https://habrastorage.org/storage3/9a2/068/643/9a20686439f88c6a393ae97364964e9e.png"><br><img src="https://habrastorage.org/storage3/ac5/6c5/ca5/ac56c5ca587e3d60019102d3bf454834.png"><br>  <i>Demonstration of the trajectory planning algorithm.</i>  <i>Depending on the orientation of the target, the resulting trajectory will pass in different ways.</i> <br><br>  When the limit of iterations is exhausted (the algorithm must have time to work in real time - the machine is moving!), Or the number of branches that have reached the target exceeds the threshold M, then the shortest path from the many available is selected. <br>  The resulting trajectory is a set of Dubin's trajectories (Dubins path) - a set of segments and arcs of a certain minimum turning radius of the car.  This kind of trajectories was designed specifically to represent the movement of the car and is the shortest path for movement from a point (x, y, theta) to (x ', y', theta '), taking into account the initial and final orientation. <br><img src="https://habrastorage.org/storage3/45a/5f2/0ad/45a5f20ad7fb48cf56d40cab21105bfd.png"><br>  <i>An example of Dyubins paths</i> <br><br>  The difficulty with the implementation of this algorithm lies in the fact that the method itself is computationally expensive (in fact it is a brute force).  It was necessary to seriously optimize his work.  The trajectory must be updated periodically to respond to changes in road conditions.  Due to the presence of intermediate peaks, the maneuvers of the car were quite complicated (in a good way). <br>  The trajectory is sent to the execution of the motion controller, which controls the steering and speed.  The controller algorithm is taken similar to that proposed in [1]. <br><br>  I would also like to note that this algorithm is a ‚Äúscheduling algorithm for the general case‚Äù.  Those.  when a priori information about the form of the road and obstacles is not known (traffic in the parking lot, in garages, traffic congestion).  It is computationally complex, but it can generate complex trajectories.  When driving on the highway, difficult maneuvers are not desirable, are not optimal, and even dangerous.  Therefore, there are ‚Äúlightweight‚Äù traffic planners focused on planning when driving only in a traffic flow (we have not yet implemented it). <br><img src="https://habrastorage.org/storage3/a9b/342/1bc/a9b3421bc8e5a029c55dfd2cb39330a5.png"><br>  <i>Highway Traffic Planner</i> <br><br><h4>  Program mode switching </h4><br>  We didn‚Äôt think about the way of switching the program modes.  In a hurry, we had to mount the Gozeli (we call a robot) outside the board with a small keyboard block with numbers - the right combination of numbers determined what the robot would do next: <br><img src="https://habrastorage.org/storage3/64b/d72/1a7/64bd721a76a7c07d6916da88a0701c1b.png"><br>  <i>Keyboard for switching the program mode (inside the jar).</i>  <i>Next memo operator - so as not to forget</i> <br><br>  In general, with the choice of mode, we did not work very well.  Since in order to deploy Gozel it was necessary to release the pedals, and for this to happen, the program must ‚Äúrelease‚Äù them.  As a result, you had to enter a lot of intermediate commands on the keyboard.  In a nervous environment, they are easily confused.  It is also curious that turning the car took more time than autonomous driving in both directions. <br><br><h5>  Common architecture </h5><br>  Based on the algorithms described above, you can make the following pattern of interaction between program components: <br><img src="https://habrastorage.org/storage3/e11/dd8/bc4/e11dd8bc4fa4d88f906fbf31f71793cd.png"><br><br><h4>  Debugging </h4><br>  Debugging is the most important stage in the development of any software product, especially when it comes to software for controlling a robot car.  But here there are some difficulties. <br>  The cost of the error is a damaged car or infrastructure.  Not to mention the danger to team members.  Here bugs are expensive. <br>  Also an important problem is the cost of testing.  Debugging the entire system is desirable in a deserted place, away from objects that can be damaged if something goes wrong.  For this you need to deliver a car there.  And the cost of towing services is not compensated by anything. <br><br>  Therefore, we created a simulator on which it was possible to check the overall operation of the algorithm and the logic of the assignment.  Irrlicht was used as a graphic engine, and BulletPhysics physical.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The robot software is a client-server interaction, where the server is a software interface between the algorithm (client) and the hardware of the robot (sensors, actuators). It turned out that in order to switch from the simulator to a real robot, it was necessary to specify a different ip address in the client - very conveniently - no code modifications. </font></font><br><img src="https://habrastorage.org/storage3/723/d9c/cef/723d9ccefefe83fe72e6d2256db2604b.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our simulator The</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simulator allowed us to simulate the signals of all sensors (encoders, GPS, SICK), so most of the time debugging took place in the simulator. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the simulator simulator, and the robot will travel in the real world, which, as a rule, differs from the model. Therefore it is necessary to check everything in practice.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first (and only) field tests before the competition were held literally - in the field. </font></font><br><img src="https://habrastorage.org/storage3/9f5/135/670/9f513567012c69aed321d6ee97b69a69.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The motor overheated</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The uppermost part of the algorithm worked well, but the low level was not very good - we had to reconfigure the coefficients of the steering and pedal control knobs (which is logical). </font><font style="vertical-align: inherit;">By the end of the day we achieved acceptable results. </font><font style="vertical-align: inherit;">It seems everything turned out.</font></font><br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/aLCPHqyWl2o&amp;xid=17259,15700021,15700186,15700191,15700253,15700256&amp;usg=ALkJrhiY0UR0RdD-noZZEEnOStIZhkPk6A" frameborder="0" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A small preview of the competition and the final race</font></font></i> <br><br><h4>  Conclusion and conclusions </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At RoboCross 2013, our team won first place. We traveled all the barrels and returned safely to the launch area. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A conclusion that suggests itself - a robot car is a complex system. Creating each component is a challenge that developers must accept and overcome, especially in our country. Naturally - the creation of such a device is impossible alone, so I would like to express my gratitude to my team. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I didn‚Äôt tell the details when developing electronics, but there they were, it was even more than in software.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The question is what's next? Develop. The system is a fairly holistic view. Improving each of the components should improve the quality of the entire robot. Adding traffic rules logic will only affect the local target selection algorithm. Also, the trend in the global autonomous auto industry is to minimize the cost of the sensors used - expensive laser scanners try not to use, but to focus on cheaper vision systems. It is necessary to move in this direction.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In a classic car, the swivel wheels are the front wheels - it is easier for a person to drive this way. And if you make all the wheels turning? This will make it possible to perform more complex maneuvers, ranging from parallel parking to row-to-row adjustment without sacrificing speed. A person with such control is unlikely to cope, but the robot can: </font></font><br><img src="https://habrastorage.org/storage3/1e4/a08/0d3/1e4a080d3fbdc4751f98fad574a93982.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Robot "Maracay". In development</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Other laboratory projects and robots can be found </font></font><a href="http://www.kb-avrora.ru/production"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ps</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The purpose of this material is also a search for like-minded people - we are starting the opensource software project for robotic vehicles. If you are interested in this topic, you have experience in development (or are a member of other teams) write me -</font></font><img src="https://habrastorage.org/storage3/37b/2d2/f3b/37b2d2f3b5e205c4d5856f99d0efca5c.png">  . <br><br><h4>  Sources </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Yoshiaki Kuwata, Gaston A. Firore, et al, ‚ÄúMotion Planning for Urban Driving using RRT,‚Äù 2008 IEEE RSJ International Conference on Intelligent Robots and System, September, 2008. </font></font></div><p>Source: <a href="https://habr.com/ru/post/195358/">https://habr.com/ru/post/195358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195342/index.html">We work with documents in the browser with the help of jDoc</a></li>
<li><a href="../195346/index.html">What if you are a little SharePoint, and how to live with it?</a></li>
<li><a href="../195352/index.html">RETN fell</a></li>
<li><a href="../195354/index.html">Diary analysts note</a></li>
<li><a href="../195356/index.html">"As we did game hosting" or "Our first Hackathon"</a></li>
<li><a href="../195360/index.html">Report and all videos from the conference RuHaxe 3</a></li>
<li><a href="../195362/index.html">Because of a crash in Google Talk, messages go to the wrong users.</a></li>
<li><a href="../195364/index.html">Expansion of local infrastructure to the cloud</a></li>
<li><a href="../195368/index.html">STM32 and Bluetooth or remote control of PC do it yourself</a></li>
<li><a href="../195370/index.html">Why I (so far) do not believe in "smart watches"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>