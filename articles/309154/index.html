<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Some examples of the practical use of RxJava</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RxJava is a ReactiveX implementation for Java - a library for asynchronous processing of data streams. The pattern is observable on steroids, as they ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Some examples of the practical use of RxJava</h1><div class="post__text post__text-html js-mediator-article">  RxJava is a ReactiveX implementation for Java - a library for asynchronous processing of data streams.  The pattern is observable on steroids, as they themselves write.  On the Internet, including on Habr√©, there are many "introductions in RxJava".  I want to give a few examples of real problems.  They are not very complex, but maybe someone will see some similarities with their own and will think. <br><br>  Actually, the tasks: <br><br>  <b>1.</b> Simple client TCP connection.  There is a protocol over TCP / IP, you need to form a message, connect to a remote host, if you have not connected yet, send a message and read the response.  Plus error handling, timeout checking, retry sending in case of failure.  There are no strict performance requirements, the traffic is not large. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>2.</b> There is a motor and some sensor.  It is necessary to make a scan - go through the engine along a predetermined path: send the engine to a point, wait for it to arrive, take a sensor reading, display a point on the graph (in the GUI stream), go to the next point ... <br><br>  <b>3.</b> The data obtained after scanning must be processed (conditionally long computing process) and shoved into a pdf report (conditionally lengthy input-output process) along with a graphic image and data entered by the user (GUI stream). <br><a name="habracut"></a><br><h4>  1. Simple client TCP connection </h4><br>  Suppose there is some messaging protocol.  Messages can contain a header, checksum or anything else.  For each message must be a response from the server.  In its simplest form, the solution might look something like this: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isConnected()) { connect(); } <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = command.getBytes(); bytes = addHeader(bytes); sendBytes(bytes); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readAnswer(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-comment"><span class="hljs-comment">//  } }</span></span></code> </pre> <br>  I do not describe the implementation details, but in brief: connect () creates java.net.Socket and connects to the server, sendBytes () writes to the output stream of the socket, readAnswer () reads from the input stream of the socket.  In addition to addHeader (), there may be methods that add a checksum, coding, and so on. <br><br>  The problems of this code: blocking the read / write and inconvenient error handling - it is not clear what to do with the exception: either to forward to the top, or to do something here (repeat the sending recursively?).  Just these two problems and solves RxJava.  Rewrite: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Observable&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.just(command) .doOnNext(cmd -&gt; checkConnection()) .map(cmd -&gt; cmd.getBytes()) .map(bytes -&gt; addHeader(bytes)) .map(bytes -&gt; sendBytes(bytes)) .map(result -&gt; readAnswer()); }</code> </pre><br>  Application: <br><br><pre> <code class="java hljs"> connection.send(<span class="hljs-string"><span class="hljs-string">"echo 123"</span></span>) .subscribe( answer -&gt; { <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> }, throwable -&gt; { <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> } );</code> </pre><br>  In general, it turned out the same thing, only in the form of a monad, a set of operators and with a number of nuances. <br><br>  First, the sendBytes () method now returns a boolean.  RxJava works with data streams, and if someone returns void instead of data, then there is no flow anymore.  Therefore, you must either add the return result to the method (at least return true), or use doOnNext instead of map ‚Äî this operator returns the same as it received. <br><br>  Secondly, the send () method now returns Observable, and not the String itself.  Therefore, we need a separate response handler (or lambda, as in the example).  The exception is the same.  Here it is necessary, as they say, to start thinking asynchronously.  Instead of the result itself, we get an object, which then someday will provide us with a result, and we must provide it with what this result will receive.  But this code is still blocking, so this asynchronous thinking does not make sense.  You can, however, make a wrapper for the String and pull the result out of the monad through the closure of this wrapper, but these are already dirty hacks that violate the principles of functional programming. <br><br>  Improve this code.  Let's start with error handling.  RxJava catches exceptions that occur in operators, and passes them to the subscriber.  The second argument of the subscribe () method is the functional interface of Action1 ‚Äî it‚Äôs responsible for handling the exception.  If any of the methods previously could throw an IOException or some other checked exception, then now it is no longer possible.  Such exceptions need to catch hands and do something with them.  For example, wrap in a RuntimeException to provide further RxJava solutions.  But Action1 is not much different from the usual try-catch approach.  RxJava has operators for handling errors: doOnError (), onErrorReturn (), onErrorResumeNext () and onExceptionResumeNext ().  And then there is the banal retry (), which is exactly what is needed here.  If there is any connection error, you can simply repeat the sending n-time. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Observable&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.just(command) .doOnNext(cmd -&gt; checkConnection()) .map(cmd -&gt; cmd.getBytes()) .map(bytes -&gt; addHeader(bytes)) .map(bytes -&gt; sendBytes(bytes)) .map(result -&gt; readAnswer()) .doOnError(throwable -&gt; disconnect()) .retry(MAX_RETRY_COUNT); }</code> </pre><br>  The exception handler passed to subscribe () will only be called if all repetitions end with an error.  For reliability, we also call disconnect () before retrying to close and zero the socket.  Otherwise, in checkConnection () inside, when isConnected () is called, we can get a false positive response, and all repeated attempts will again lead to an error.  For example, if the server killed the connection by timeout, then the Socket.isConnected () method on the client side will still return true - on the client side, the socket is connected, all the rules. <br><br>  You can also add a timeout in case the server poplohelo and the client is blocked from writing to the socket: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Observable&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.just(command) .doOnNext(cmd -&gt; checkConnection()) .map(cmd -&gt; cmd.getBytes()) .map(bytes -&gt; addHeader(bytes)) .map(bytes -&gt; sendBytes(bytes)) .timeout(MAX_SEND_TIMEOUT_MS, TimeUnit.MILLISECONDS) .map(result -&gt; readAnswer()) .doOnError(throwable -&gt; disconnect()) .retry(MAX_RETRY_COUNT); }</code> </pre><br>  The timeout operator throws an exception if no items have been received from the Observable within the specified time.  And we are already able to process exceptions. <br><br>  Now the second problem is that we still have blocking operations, so if we call send () from the GUI thread, we can get interface hangs.  You just need to say RxJava, so that all these actions are performed in another thread. <br><br>  To do this, there are observeOn () and subscribeOn () statements.  Many people have problems understanding how these operators differ - there are a lot of articles on this topic and questions on stackoverflow.  Let's raise this topic again and think together what we need to use now.  Here is what is written in the official documentation: <br><br><blockquote>  <a href="http://reactivex.io/documentation/operators/subscribeon.html">SubscribeOn</a> - specify the Scheduler on which an Observable will operate. <br>  <a href="http://reactivex.io/documentation/operators/observeon.html">ObserveOn</a> - observe the Observable. </blockquote><br>  An observable is one who supplies data.  An observer is someone who receives data and does something with it.  We need everything to be done in a different thread.  Rather, we need our Observable to deliver data initially in another stream.  And once the data is delivered in another stream, then all observers will process them in another stream.  This is by definition subscribeOn () - it defines the scheduler for Observable, which we created at the very beginning: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Observable&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.just(command) .doOnNext(cmd -&gt; checkConnection()) .map(cmd -&gt; cmd.getBytes()) .map(bytes -&gt; addHeader(bytes)) .map(bytes -&gt; sendBytes(bytes)) .timeout(MAX_SEND_TIMEOUT_MS, TimeUnit.MILLISECONDS) .map(result -&gt; readAnswer()) .doOnError(throwable -&gt; disconnect()) .retry(MAX_RETRY_COUNT) .subscribeOn(Schedulers.io()); }</code> </pre><br>  Now the operators will be executed in the stream that the io scheduler provides them.  If you call send () several times in a row without waiting for an answer, then synchronization problems may arise.  In an amicable way, the functions passed to the operators should be clean (without side effects), but in the case of a socket, this is problematic.  Pure functions are generally not very friendly with I / O.  You need to synchronize calls to the socket or implement something like a ConnectionPool - here you need to proceed from the task. <br><br>  It should be borne in mind that then the processing of the response by the subscriber (he is also an observer) will be carried out in another stream, and this is not always good.  For example, if we want to display the answer in the graphical interface, we will most likely get an exception that we are not doing this in the main thread.  To do this, put the handler in the event queue of the framework responsible for the graphical interface.  In different frameworks, this is done differently.  JavaFX has a Platform.runLater (runnable) method for this.  You can call it directly in the response handler, or you can write your scheduler: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FxScheduler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scheduler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> FxScheduler m_instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FxScheduler(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FxScheduler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FxScheduler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_instance; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Worker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createWorker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CompositeSubscription m_subscription = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositeSubscription(); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Subscription </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Action0 action0)</span></span></span><span class="hljs-function"> </span></span>{ Platform.runLater(action0::call); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_subscription; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Subscription </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Action0 action0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delay, TimeUnit timeUnit)</span></span></span><span class="hljs-function"> </span></span>{ Timer timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(); timer.schedule(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerTask() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Platform.runLater(action0::call); } }, timeUnit.toMillis(delay)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_subscription; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_subscription.unsubscribe(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isUnsubscribed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_subscription.isUnsubscribed(); } }; } }</code> </pre><br>  By the way, for Android there is AndroidSchedulers.mainThread () in RxAndroid - add-on for RxJava.  An example of sending a command is then: <br><br><pre> <code class="java hljs"> send(<span class="hljs-string"><span class="hljs-string">"echo 123"</span></span>) .observeOn(FxScheduler.getInstance()) .subscribe( answer -&gt; { <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> }, throwable -&gt; { <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> } );</code> </pre><br>  Here we use already observeOn () - we need to inform RxJava that ‚Äúthe next observer should be performed through such a scheduler‚Äù. <br><br>  RxJava provides convenient control of the operator pipeline.  Next to .map (bytes -&gt; sendBytes (bytes)), you can add a checksum calculation, then run the bytes through encoding.  You can add logging of the outgoing command at the beginning, and at the end - the received response.  In general, you get the idea. <br><br><h4>  2. Scan using engine and sensor </h4><br>  There is a set of points - it can be the angles of rotation of the engine in degrees or the position of the device, which is driven by the engine.  In general, there is some kind of actuator.  And there is also an external sensor from which you can get values.  It is necessary to drive the engine on a set of points, at each point to get the value from the sensor, to build a curve on the graph.  Repeat the procedure n times (n curves on the graph).  In this case, the engine does not work instantly, you need to wait when it comes to the position. <br><br>  So, we have a set of points, for each you need to do something (preferably in another thread), and the result is processed in the GUI stream (add a point to LineChart, for example).  It looks like a typical task for RxJava. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Observable&lt;Point&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startScan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Double&gt; trajectory, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iterationCount)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.from(trajectory) .subscribeOn(Schedulers.io()) .doOnNext(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::moveMotor) .doOnNext(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::blockUntilTargetReached) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::createResultPoint) .repeat(iterationCount); }</code> </pre><br>  We use Schedulers.io (): control of the engine and sensor is still input-output operations.  moveMotor () sends a command to the engine (via the previously written Connection, for example). <br><br>  blockUntilTargetReached () queries the engine for its position, compares it with the target, and puts the stream to sleep for a few milliseconds if the engine has not reached it yet.  createResultPoint () queries the sensor for a value in returns a Point object containing a pair of numbers ‚Äî the target position and the value from the sensor.  Repeat () works almost like retry () - it repeats the entire stream from the very beginning every time, and retry () only after an error. <br><br>  The original Observable will output points one by one.  It will issue the next point only when the previous one passes all the operators up to the subscriber.  This corresponds to the functional approach with its lazy calculations and stream processing.  StreamAPI and LINQ work in the same way.  Due to this, the scan will go on the points in turn, not forEach (this :: moveMotor), then forEach (this :: blockUntilTargetReached) and so on. <br><br>  Application: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Double&gt; trajectory = ...; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = ...; startScan(trajectory, n) .observeOn(FxScheduler.getInstance()) .subscribe( point -&gt; processPoint(point), throwable -&gt; processError(throwable), () -&gt; processData() );</code> </pre><br>  The problem is that the subscriber does not distinguish at which repetition point was obtained.  That is, instead of n curves, we get one curve n times longer.  Somehow you need to manually keep track of what has begun a new scan.  For example, count the number of points and start a new curve if the counter value exceeded the number of points in the path.  Or compare the arrived point with the first point of the trajectory. <br><br>  The third argument appeared in subscribe () - this is the onComplete () handler, which is called when the Observable has run out of elements. <br><br>  subscribe () returns an object that has a Subscription interface.  If you call the unsubscribe () method, then the Observable will no longer have a subscriber accepting data, so it will simply stop issuing it.  The principle of lazy calculations - if the data is not needed by anyone, then you do not need to transfer them.  Operators should still not have side effects in accordance with the functional programming paradigm, so Observable doesn‚Äôt make sense to simply execute operators without a subscriber.  With unsubscribe (), you can implement a cancellation scan.  Unless the engine needs to send a command to stop the movement - unsubscribe () is not responsible for this. <br><br><h4>  3. Data Processing and Report </h4><br>  After scanning, we received a lot of useful data, now we need to process them, calculate the necessary values ‚Äã‚Äãand generate a pdf report. <br><br>  The report should also include the values ‚Äã‚Äãof some fields from the interface (for example, the user's full name) and a drawing of the graphs received.  In the case of JavaFX, a drawing can be obtained using the snapshot () method that each graphic object has.  Since these are actions with JavaFX objects, they must be executed in the GUI thread.  For this, we already have FxScheduler. <br><br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReportMetaInfo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String fileName; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WritableImage image; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Observable&lt;ReportMetaInfo&gt; reportGuiData = Observable.just(m_reportInfoProvider) .subscribeOn(FxScheduler.getInstance()) .map(provider -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ReportMetaInfo info = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReportMetaInfo(); info.fileName = m_reportInfoProvider.getFileName(); info.name = m_reportInfoProvider.getName(); info.image = m_reportInfoProvider.getChartSnapshot(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> info; });</code> </pre><br>  m_reportInfoProvider is an implementation of the ReportInfoProvider interface - the layer between the model and the view.  In essence, this is a call to the getters from TextView, but the models don't care - it just has an interface. <br><br>  For calculations, there is Schedulers.computation (). <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Observable&lt;ScanResult&gt; reportComputationalData = Observable.just(scanData) .subscribeOn(Schedulers.computation()) .map(data -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ResultProcessor(data).calculateAll());</code> </pre><br>  Now we want to combine the data from the form and the data from the calculations and put it all into a heavy pdf-file.  There is a zip () operator and Schedulers.io () for this: <br><br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReportData</span></span></span><span class="hljs-class"> </span></span>{ ReportMetaInfo metaInfo; ScanResult result; ReportData(ReportMetaInfo metaInfo, ScanResult result) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.metaInfo = metaInfo; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.result = result; } } Observable.zip( reportGuiData, reportComputationalData, (reportInfo, scanResult) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReportData(reportInfo, scanResult) ) .observeOn(Schedulers.io()) .map(reportData -&gt; ReportGenerator.createPdf( reportData.metaInfo.fileName, reportData.metaInfo.name, reportData.metaInfo.image, reportData.result )).subscribe( isOk -&gt; { <span class="hljs-comment"><span class="hljs-comment">/* ,  -,   */</span></span> }, throwable -&gt; { <span class="hljs-comment"><span class="hljs-comment">/* -    */</span></span> }, () -&gt; { <span class="hljs-comment"><span class="hljs-comment">/*   ,     */</span></span> } );</code> </pre><br>  zip () accepts up to nine different Observables and connects elements from them into tuples.  The function for the connection must be provided by yourself as well as the resulting type for the tuples.  As a result, the data acquisition from the interface (including the image of the graph) and the processing of the scan results are parallel.  Whether it is necessary to parallelize such actions depends on specific tasks and data volumes - I gave a somewhat simplified example. <br><br>  It should be borne in mind that when we have multiple data streams, backpressure can occur.  These are various problems associated with different thread performance and different performance of the Observable and Observer.  In general, this is a situation where someone is idle, and someone already overflows through the buffer.  So you need to be careful. <br><br><h4>  Conclusion </h4><br>  Most likely, there are other solutions for these tasks (and more effective ones) - if someone specifies them to me, I will be happy to take note of this and take it into account in my work.  Using these tasks as an example, I tried to show some features of RxJava: error handling, the difference between subscribeOn () and observeOn (), custom schedulers and getting results in a GUI stream, the principle of lazy calculations and its use for controlling external devices, interruption of Observable operation, parallel operation several observable and their union.  So even if these tasks are not entirely successful for RxJava, the principles themselves considered may be useful for others. </div><p>Source: <a href="https://habr.com/ru/post/309154/">https://habr.com/ru/post/309154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309138/index.html">Learning OpenGL ES2 for Android Lesson ‚Ññ4. Textures</a></li>
<li><a href="../309142/index.html">Private unstructured types and type reuse</a></li>
<li><a href="../309144/index.html">About alignment of memory on ARM processors on a simple example</a></li>
<li><a href="../309150/index.html">Constants do not change: a small excursion into the depths of dotNet</a></li>
<li><a href="../309152/index.html">Review of computer vision problems in medicine</a></li>
<li><a href="../309156/index.html">Testing IVR on Asterisk with ... Asterisk</a></li>
<li><a href="../309158/index.html">Survey: Programmer and Salary</a></li>
<li><a href="../309160/index.html">Russian Post for Dummies</a></li>
<li><a href="../309162/index.html">Implementing a finite state machine in VHDL</a></li>
<li><a href="../309164/index.html">The digest of interesting materials for the mobile developer # 169 (August 29 - September 4)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>