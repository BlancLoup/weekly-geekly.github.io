<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a platformer for a virtual console TIC-80</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="8 Bit Panda, a game for the fictional console TIC-80. 

 This is a post about how I wrote an 8-bit panda, a simple classic-style platformer for the fi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a platformer for a virtual console TIC-80</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d4/579/787/9d4579787e58b62d45606ac707104072.png"></div><br>  <i>8 Bit Panda, a game for the fictional console TIC-80.</i> <br><br>  <em>This is a post about how I wrote an 8-bit panda, a simple classic-style platformer for the fictional</em> <a href="http://tic.computer/" rel="noopener nofollow"><em>TIC-80</em></a> <em>console</em> <em>.</em> <br><br>  <em>Play in the finished game</em> <a href="https://tic.computer/play%3Fcart%3D188" rel="noopener nofollow"><strong><em>here</em></strong></a> <strong><em>.</em></strong> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you are a fan of retro games and you like programming, then there is a chance that you are already familiar with the latest trend: fictional consoles.  If not, then you should look at their most famous representatives: <a href="https://www.lexaloffle.com/pico-8.php" rel="nofollow noopener">PICO-8</a> and <a href="http://tic.computer/" rel="nofollow noopener">TIC-80</a> . <br><br>  I chose TIC-80 because it is free and actively developed, has a wider screen ratio (240x136) than PICO-8 and can export to many platforms, including HTML, Android and binary files for PC. <br><br>  In this article I will tell you how I wrote a simple 8 bit Panda platformer for the TIC-80. <br><a name="habracut"></a><br><h3>  The main character </h3><br>  First I needed a player character.  I didn‚Äôt think much about it: the design process basically consisted in the question: ‚Äúwhy not a panda?‚Äù, The answer to which was: ‚Äúof course, why not?‚Äù So I started drawing my first sprite in the TIC sprites editor. 80: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/06e/319/c39/06e319c394f35d1d4ed23a695d3d52a1.png" alt="image"></div><br><br>  Let me enjoy the impressive lack of artistic skills, but it‚Äôs worth considering that there are only <sup>2,256</sup> combinations of 16-color 8x8 sprites.  Only some of them will be pandas.  If you do not come to the conclusion that this <em>is the</em> worst combination, then I will feel flattered. <br><br>  Taking it as a basis, I drew a few more sprites representing the main character in other poses: walking, jumping, attacking, etc. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/817/435/250/817435250fe527214155dd33fe392b46.gif" alt="image"></div><br><br>  Now, when all the readers who were expecting to find lessons on drawing pandas here, turned away from me, let's turn to the code. <br><br>  If you find the source useful, you can study my <a href="" rel="nofollow noopener">source code</a> .  But this is not necessary, because I will try to tell as much of the context as possible on each topic.  Of course, we will not study <em>all the</em> source code, I‚Äôll just tell you about interesting points that we encountered while developing. <br><br><h3>  Creating levels </h3><br>  TIC-80 has a built-in map editor that you can (and should) use to create levels.  It is quite simple to use it: this is a common matrix of tiles, each of which can be any of the 256 sprites at the bottom of the sprites table (the upper part, with indices from 256 to 511, can be drawn during the execution of the game, but they cannot be on the map, because it takes 9 bits to display). <br><br>  <strong><em>Sprite vs. Tile:</em></strong> <em>in TIC-80, ‚Äúsprite‚Äù means one of 512 predefined images in an 8x8 pixel cartridge.</em>  <em>Map tiles are simply sprites (each card tile can be one of 256 sprites in the bottom half of the sprite table).</em>  <em>Therefore, we will say ‚Äúsprite‚Äù when it comes to a graphic element, and ‚Äútile‚Äù when we keep in mind the cell of the map, even though technically the cell contains a sprite.</em>  <em>To summarize: all this does not matter, tiles and sprites are one and the same.</em> <br><br>  Using the map editor, I first created a fairly simple ‚Äúlevel‚Äù: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca8/abb/56a/ca8abb56ac4ccc021efb80f59fadfdcd.gif" alt="image"></div><br><br>  First, it is worth noting that there are two main types of tiles: <br><br><ul><li>  <strong>Solid tiles</strong> (tiles of earth and earth + grass) on which the player can stand and which block the player‚Äôs movement. </li><li>  <strong>Decorative tiles</strong> (trees, grass, lantern, stone, etc.).  They are needed only for beauty and do not affect anything in the game. </li></ul><br>  Later we will get acquainted with tile-entities, but for now let's not talk about them.  In the code you need to somehow tell whether the tile is solid or not.  I chose a simple approach and decided to limit myself to the sprite index (80): if the sprite index is &lt;80, then the tile is solid.  If it is ‚â• 80, then the tile is used for decoration.  Therefore, in the table of sprites, I just drew all the solid tiles up to index 80, and all the decorative ones after 80: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e59/b35/ec2/e59b35ec24f2477ca18b3c576ac666be.gif" alt="image"></div><br><br>  But wait, the water is not solid!  What does she do with hard sprites?  I did not tell you about overrides: there is a list of overriding the hardness of sprites, which can replace the default hardness.  He tells us that, for example, the water tile is actually not solid, even though it is in the table of sprites in the part with solid tiles.  But it is not decorative, because it affects the game. <br><br><h3>  Player status </h3><br>  If I learned something in my career as a programmer, it‚Äôs because global variables are bad, but you can use them if you come up with some interesting name, for example, Singleton.  Therefore, I have identified several "singletons" that define the state of the game.  I use this term quite arbitrarily, because it is not OOP, and in fact they are rather a high-level struct, rather than real singltons. <br><br>  Well, okay, no matter how they are called.  Let's start with <strong>Plr</strong> , which sets the player‚Äôs state at a specific point in time: <br><br><pre><code class="lua hljs">Plr={ lives=<span class="hljs-number"><span class="hljs-number">3</span></span>, x=<span class="hljs-number"><span class="hljs-number">0</span></span>,y=<span class="hljs-number"><span class="hljs-number">0</span></span>, grounded=<span class="hljs-literal"><span class="hljs-literal">false</span></span>, ... }</code> </pre> <br>  It has many other fields, but the most important thing here is to notice that this object keeps the player‚Äôs entire state at the current level: where the player is at the level of whether he jumps, stands on solid ground, floats, returns to the surface, dies, flying on an airplane (yes, this is one of those pandas that fly on planes), points, active bonuses, etc. <br><br>  There is also a game state, separate from the player state.  For example, <br><br><pre> <code class="lua hljs">Game={ m=M.BOOT, <span class="hljs-comment"><span class="hljs-comment">--   lvlNo=0, -- ,     ... }</span></span></code> </pre> <br>  It stores such values ‚Äã‚Äãas the current mode (we will tell about it in more detail), the current level, as well as the data for the whole game, calculated in the process of execution. <br><br>  It is useful to separate the <strong>state of the game</strong> and the <strong>state of the player</strong> , because then it‚Äôs enough to start / restart the levels: you just need to reset and delete the player‚Äôs state, without touching the state of the game. <br><br><h3>  Rendering level and player </h3><br>  Rendering the level and player on the TIC-80 is incredibly easy.  The only thing you need to do is call <strong>map ()</strong> to draw (part of) the map and <strong>spr ()</strong> to draw sprites in any place you want.  Since I was drawing my level from the top left corner of the map, I can just draw it like this: <br><br><pre> <code class="lua hljs">COLS=<span class="hljs-number"><span class="hljs-number">30</span></span> ROWS=<span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> map(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,COLS,ROWS) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Then I add a player: <br><br><pre> <code class="lua hljs">PLAYER_SPRITE=<span class="hljs-number"><span class="hljs-number">257</span></span> spr(PLAYER_SPRITE, Plr.x, Plr.y)</code> </pre> <br>  And we get the following: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/168/c49/753/168c49753ac9019c424de6a6c176533c.gif" alt="image"></div><br><br>  And, of course, the panda stays in the corner, doing nothing.  So far this is not very similar to the game, but we have not finished yet. <br><br>  Of course, everything becomes more complicated when we want to implement a side-scroller, in which the camera accompanies the player as it moves forward.  I did the following: I created a <strong>Game.scr</strong> variable that determines how much the screen is scrolled to the right.  Then when I draw the screen, I move the map to the left by this number of pixels, and when I draw everything, I always subtract <strong>Game.scr</strong> to draw in the right place on the screen, like this: <br><br><pre> <code class="lua hljs">spr(S.PLR.STAND, Plr.x - Game.scr, Plr.y)</code> </pre> <br>  In addition, for efficiency, I determine which part of the level is visible from any point and draw only this map rectangle on the screen, and not its entirety.  Ugly details can be found in the <strong>RendMap ()</strong> function. <br><br>  Now we need to write logic that moves the panda in response to the player‚Äôs actions. <br><br><h3>  Move the panda </h3><br>  I never thought that I would write an article with such a subtitle, but life is full of surprises.  Panda is our main character, and in the game of platformer everything moves and jumps, so you can reasonably say that the ‚Äúpanda movement‚Äù is the core of the game. <br><br>  The ‚Äúmovement‚Äù part is pretty simple: we just change <strong>Plr.x</strong> and <strong>Plr.y</strong> , after which the panda <strong>appears</strong> elsewhere.  Therefore, the most simple motion implementation can be written like this: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> btn(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Plr.x = Plr.x - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> btn(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Plr.x = Plr.x + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Remember that in TIC-80 <strong>btn (2)</strong> is the left key, and <strong>btn (3)</strong> is the right key.  But this way we can only move horizontally and not be able to collide with the walls.  We need something more complex, taking into account gravity and obstacles. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePlr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> IsOnGround() <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">--  Plr.y = Plr.y + 1 end if btn(2) then Plr.x = Plr.x - 1 elseif btn(3) then Plr.x = Plr.x + 1 end end</span></span></code> </pre> <br>  If we implemented <strong>IsOnGround ()</strong> correctly, it will be a big improvement: the player will be able to move left and right, and fall when not on solid ground.  So, we can already walk and fall from the cliffs.  Amazing! <br><br>  But at the same time, obstacles are not taken into account: what happens if we enter (horizontally) a solid tile standing in the way?  We should not be able to enter there.  That is, in general, we have such a scheme - in motion there are two stages: <br><br><ol><li>  We decide where the hero wants to go (taking into account such external factors as gravity). </li><li>  We decide whether to allow the hero to move there (due to obstacles). </li></ol><br>  The concept of ‚Äúdesire to go‚Äù has a broad definition and sets intentional and unintentional displacement: standing on solid ground, the hero ‚Äúwants‚Äù to move down (due to gravity), but cannot because he will face the ground when moving down. <br><br>  Therefore, it makes sense for us to write a function that encodes all the logic ‚Äúcan the hero move to a given position x, y‚Äù.  But we will also need it when realizing the enemies, because we will also have to ask ‚Äúcan this enemy move to the x, y position?‚Äù.  That is, to summarize, it would be best to write a function that receives at the input x, y and an arbitrary collision rectangle (so we can correctly convey the correct x, y and the collision rectangle to the essence of the hero or the enemy): <br><br><pre> <code class="lua hljs">C=<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-comment"><span class="hljs-comment">--    ( TIC-80  8) -- ,       -- cr={x,y,w,h}     x,y function CanMove(x,y,cr) local x1 = x + cr.x local y1 = y + cr.y local x2 = x1 + cr.w -1 local y2 = y1 + cr.h - 1 --   ,    local startC = x1 // C local endC = x2 // C local startR = y1 // C local endR = y2 // C for c = startC, endC do for r = startR, endR do if IsTileSolid(mget(c, r)) then return false end end end end</span></span></code> </pre> <br>  The logic is quite simple: we just find the boundaries of the rectangle, iteratively go through all the tiles that the rectangle touches, and check if there are any among them solid ( <strong>IsTileSolid ()</strong> just performs our check "‚â• 80", plus overrides).  If we do not find on the path of a solid tile, then we return <strong>true</strong> , meaning <strong>"well, you can move here</strong> . <strong>"</strong>  If we find such a tile, then we return <strong>false</strong> , meaning <strong>‚Äúno, we can't move here‚Äù</strong> .  Two situations are illustrated below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a09/a77/0cc/a09a770cc5cced38e0df922368557a4a.gif" alt="image"></div><br><br>  Let's write another life-simplifying function that tries to move a certain offset.  if possible: <br><br><pre> <code class="lua hljs">PLAYER_CR = {x=<span class="hljs-number"><span class="hljs-number">2</span></span>,y=<span class="hljs-number"><span class="hljs-number">2</span></span>,w=<span class="hljs-number"><span class="hljs-number">5</span></span>,h=<span class="hljs-number"><span class="hljs-number">5</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryMoveBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dx,dy)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CanMoveEx(Plr.x + dx, Plr.y + dy, PLAYER_CR) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Plr.x = Plr.x + dx Plr.y = Plr.y + dy <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Now our implementation of the transfer function becomes much cleaner: first we decide where we want to go, then we check whether it is possible.  If possible, we move there. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePlr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">--  " "  "    " Plr.grounded = not CanMove(Plr.x, Ply.y + 1) if not Plr.grounded then --    ,  . Plr.y = Plr.y + 1 end local dx = btn(2) and -1 or (btn(3) and 1 or 0) local dy = 0 --     TryMoveBy(dx,dy) end</span></span></code> </pre> <br>  Well, now we have a movement in view of the obstacles.  Later, when we add hard entities (mobile platforms and others), we will have to complicate the function a little to check for collisions with entities, but the principle will remain the same. <br><br><h3>  Panda animations </h3><br>  If we always use one sprite (number 257), the game will seem boring, because the panda will always be in the same standing pose.  Therefore, we need to panda walked / jumped / attacked, etc.  We want the sprite to change based on the player‚Äôs state.  To simplify reference to the numbers of sprites, we will declare constants: <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- S -     S={ -- S.PLR -      PLR={ STAND=257, WALK1=258, WALK2=259, JUMP=273, SWING=276, SWING_C=260, HIT=277, HIT_C=278, DIE=274, SWIM1=267, SWIM2=268, } }</span></span></code> </pre> <br>  They correspond to several panda sprites in the sprite table: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/117/cda/55b/117cda55b7654ee9826664b97018955f.gif" alt="image"></div><br><br>  So, in our rendering function, we decide which sprite we will use.  This is the <strong>RendPlr ()</strong> function, which contains the following: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> spid <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Plr.grounded <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> btn(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> btn(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> spid = S.PLR.WALK1 + <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>()%<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> spid = S.PLR.STAND <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> spid = S.PLR.JUMP <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... spr(spid, Plr.x, Plr.y)</code> </pre> <br>  Which means: if a player is on hard ground and goes, then perform a walk animation, alternately drawing sprites S.PLR.WALK1 and S.PLR.WALK2.  If the player is on hard ground and does not walk, use S.PLR.STAND.  If not on hard ground (falls or jumps), then use S.PLR.JUMP. <br><br>  There is also additional logic to determine the side to which the hero is looking, to perform animation sequences for attacks and jumps, and to add sprite overlays when creating bonuses. <br><br><h3>  Jumps </h3><br>  People expect a strange thing: when we jump in real life, we actually can do little to change the trajectory in the jump, but when playing platformers we want (or rather <em>we demand</em> ) that the character can arbitrarily change the trajectory of the jump in the air.  Therefore, like the characters of many other games, our panda will have the ability to move freely in the air, contrary to physics. <br><br>  In fact, this greatly simplifies the implementation of jumps.  A jump is, in essence, a sequence of changes in the hero's Y coordinate.  The X coordinate is freely changed with the arrow keys, as if the player is on the ground. <br><br>  We will present the jump as an iteration of the "jump sequence": <br><br><pre> <code class="lua hljs">JUMP_DY={<span class="hljs-number"><span class="hljs-number">-3</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre> <br>  When a player jumps, his position on Y changes in each frame by the value specified in the sequence.  The variable that tracks our current place in the jump sequence is called <strong>Pl.jmp</strong> . <br><br>  The logic of the start / end of the jump will be something like this: <br><br><ul><li>  If we are on solid ground and press the jump button ( <strong>btn (4)</strong> ), start the jump (set <strong>Plr.jmp = 1</strong> ). </li><li>  If the jump is already in <strong>progress</strong> ( <strong>Plr.jmp</strong> &gt; 0), then continue the jump, trying to change the player's position on Y to <strong>JUMP_DY [Plr.jmp]</strong> , if possible (in accordance with the <strong>CanMove ()</strong> function). </li><li>  At some point of the jump, something prevents the player from <strong>moving</strong> ( <strong>CanMove ()</strong> returns false), then we interrupt the jump (set <strong>Plr.jmp = 0</strong> and begin to fall). </li></ul><br>  The resulting trajectory of the jump will not be far like a perfect parabola, but it is quite suitable for our purposes.  Fall after a jump is a straight line, because on the way down we do not apply acceleration.  I tried to add it, but it looked weird, so I decided to do without acceleration.  In addition, the rate of decline of 1 pixel / cycle gives us the opportunity to use rather tricky tricks when recognizing collisions. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f2/6eb/3ea/7f26eb3ea664117d43acf501e42d140b.gif" alt="image"></div><br>  <i>Jump trajectory.</i> <br><br><h3>  Entities </h3><br>  Tiles are good, but they are static.  The only thing you can enjoy - jumping through the fixed blocks of the earth.  To revive our platformer, we need enemies, bonuses, etc.  All of these ‚Äúmoving or interactive objects‚Äù are called entities. <br><br>  For starters, I drew some frightening enemies.  Mostly they are terrified by the quality of drawing, and not by the fact that they are terrible: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/9a8/d8c/8d29a8d8c2812795fe7033866d35058e.gif" alt="image"></div><br><br>  I just added them to the sprites table and created animations for everyone.  I also installed a new split point: sprites with indices ‚â• 128 are <strong>entities</strong> , not static tiles.  So I can just add enemies to the level using the map editor, and I will know that they are enemies thanks to their sprite index: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/646/310/e03/646310e03e02fcf3e9f9f15e83524aab.gif" alt="image"></div><br><br>  Similarly, many other objects are entities: chests, destructible blocks, temporary platforms, elevators, portals, etc. <br><br>  When loading a level, I check every tile on the map.  If it is ‚â• 128, I delete the tile card and create an entity in this place.  An entity ID (EID) defines what it is.  What do we use as an EID?  Yes, just take the sprite number again!  That is, if the enemy of the "green slug" has a sprite 180, then the EID of the green slug will be equal to 180. It's simple. <br><br>  All enemies are stored in the global structure <strong>Ents</strong> . <br><br><h3>  Entity Animations </h3><br>  Entities can be animated.  Instead of manually encoding the animation for each type of enemy, I simply created a large table of animations indexed by EID, which determines which sprites to cycle through: <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--     EID. ANIM={ [EID.EN.SLIME]={S.EN.SLIME,295}, [EID.EN.DEMON]={S.EN.DEMON,292}, [EID.EN.BAT]={S.EN.BAT,296}, [EID.FIREBALL]={S.FIREBALL,294}, [EID.FOOD.LEAF]={S.FOOD.LEAF,288,289}, [EID.PFIRE]={S.PFIRE,264}, ... }</span></span></code> </pre> <br>  Notice that some of them are character constants (for example, S.EN.DEMON), when they also coincide with the sprite of the entity, and some are hard-coded integers (292), because in the second case it is just a secondary frame of the animation, which is nowhere else to refer. <br><br>  When rendering, we can simply find the desired animation in this table and render the correct sprite for each entity. <br><br><h3>  Meta Tags: map annotations </h3><br>  Sometimes we need to add annotations to the maps used during the execution of the game.  For example, if there is a treasure chest, then we need to somehow identify what is inside and how many of these objects.  In these cases, we use map annotation markers, these are special tiles with numbers 0‚Äì12 that are never displayed (they are removed from the map at runtime): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/6a6/54f/5af6a654fdbc5f3446fccf94e6bfe0b7.gif" alt="image"></div><br><br>  When the level loader sees the chest, he looks at the tile above the chest to find out its contents, and searches for a special numerical marker indicating the quantity.  objects to create.  Therefore, when a player hits the chest, all items are created: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/e85/785/73ce85785187faccd4c861449e8962ae.gif" alt="image"></div><br><br>  Meta tags can also determine, for example, where elevators should begin and end movement, where the starting position of the level is, phase information for temporary platforms and so on. <br><br>  They are also used for level compression.  We will talk about this below. <br><br><h3>  Levels </h3><br>  The game has 17 levels.  Where are they stored?  Well, if you look at the memory cards, you will see the following picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b70/2f7/55e/b702f755eb5ba4410677455d8d1edbe1.gif" alt="image"></div><br><br>  TIC-80 has 64 ‚Äúpages‚Äù of maps, each of which is a single ‚Äúscreen‚Äù of content (30x17 tiles).  Pages numbered from 0 to 63. <br><br>  In our scheme, we reserved the top 8 for use during the execution of the game.  There we will store the level after unpacking (more on this later).  Then each level is a sequence of 2 or 3 pages in the memory card.  We can also create pages for the study screen, victory screen, world map, and start screen.  Here is the annotated version of the map: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/e0b/5dc/90fe0b5dc4c8f2e05b0f17f0a73f9314.png" alt="image"></div><br><br>  If you play a game, you may notice that the levels are actually much <strong>longer</strong> than they could fit on 2 or 3 screens.  But in the memory of cartridge cards, they are much smaller.  What is going on here? <br><br>  You guessed it (and I gave a hint): the levels are compressed!  In the memory of the cards, each column stores in the top line a <strong>meta tag</strong> , indicating how many times <strong>the</strong> column <strong>repeats</strong> .  In other words, we implemented a simple form of RLE compression: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/513/685/754/513685754d0732682b3c3d23c0584564.gif" alt="image"></div><br><br>  Therefore, when this page is unpacked, it actually defines a much longer part of the level (almost twice as much, and on some levels even more). <br><br>  But for what we use the top 8 pages of cards at runtime: when we are ready to play a level, we unpack it for gameplay on pages 0‚Äì7.  Here is the logic used to run the level: <br><br><ol><li>  We read the packed level from the right place in the memory of the cards. </li><li>  Unpack it into the top 8 pages in accordance with the number of repetitions in each column of the packed level. </li><li>  We are looking for entities (sprites ‚â• 128) and create their instances. </li><li>  We look for the initial position of the player (metamarker "A") and put the player there. </li><li>  We start to play. </li></ol><br><h3>  Entity behaviors </h3><br>  What makes the enemy behave in a certain way?  Take for example the red demon from the game.  Where does his craving for fireball come to the player?  Why don't they just become friends? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c81/4eb/d78/c814ebd78c96de7d44be6e297b0ca688.gif" alt="image"></div><br><br>  Each entity has its own behavior.  Demons throw fireballs and jump.  Green slugs roam back and forth.  Blue monsters periodically jump.  Icicles fall when the player is fast enough.  Destructible blocks are destroyed.  Lifts are rising.  Chests remain chests until the player hits them, after which they open and create their contents. <br><br>  A simple way to create all of this logic will be the following: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> enemy.eid == EID.DEMON <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ThrowFireballAtPlayer() <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> enemy.eid == EID_SLIME <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">--  -  elseif enemy.eid == EID_ELEVATOR then --  -  -- ...     ...</span></span></code> </pre> <br>  At first, everything seems simple.  But then the work becomes difficult and monotonous.  Take for example the movement: when the enemy is moving, we need to perform a bunch of checks - to make sure that the enemy can pass into a given position, check whether he will fall, etc.  But some enemies do not fall, they fly (for example, bats).  And some swim (fish).  Some enemies want to look at the player, others do not.  Some enemies want to chase the player.  Some simply go about their business, not knowing where the player is.  What about the shells?  Fireballs, plasma balls, snowballs.  Some are affected by gravity, some are not.  Some encounter hard objects, others do not.  What happens when each of the shells hits the player?  What happens when a player hits them?  So many variables and combinations! <br><br>  Writing <strong>if</strong> / <strong>else</strong> blocks for each of these cases turns into a burden after some time.  Therefore, instead, we will create a <em>behavior</em> system that is a fairly common and useful pattern in game development.  First, we will determine all the possible behaviors that the entity may have, and the necessary parameters.  For example, it may: <br><br><ul><li>  Move (How much? How does she handle the edges of the ledges? What happens when she faces something solid?) </li><li>  Fall </li><li>  Change direction (How often? Always looking at the player?) </li><li>  Jump (How often? How high?) </li><li>  Shoot (What? In which direction? Aim at the player?) </li><li>  Be vulnerable (take damage from the player). </li><li>  Inflict damage to the player during a collision </li><li>  Collapse at collision (How long?) </li><li>  Automatically collapse after a predetermined period of time (How long?) </li><li>  Give Bonus (What?) </li><li>  etc... </li></ul><br>  Having defined all possible behaviors, we simply assign them with the necessary parameters to the right entities, in which we call EBT (Entity-Behavior Table, entity behavior table).  Here is an example entry for a red demon: <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--    EBT={ ... [EID.EN.DEMON]={ -- : beh={BE.JUMP,BE.FALL,BE.SHOOT, BE.HURT,BE.FACEPLR,BE.VULN}, --  : data={hp=1,moveDen=5,clr=7, aim=AIM.HORIZ, shootEid=EID.FIREBALL, shootSpr=S.EN.DEMON_THROW, lootp=60, loot={EID.FOOD.C,EID.FOOD.D}}, }, ... }</span></span></code> </pre> <br>  It reports that the demons have the following behaviors: jump, fall, shooting, damage, turn to the player, vulnerability.  In addition, the parameters indicate that the entity has one point of damage, moves every 5 cycles, has a base color of 7 (red), shoots fireballs (EID.FIREBALL), targets the player in the horizontal plane (AIM.HORIZ), has a chance of falling out rewards of 60%, can throw away food C and D (sushi).  See, now we can define the whole behavior of this enemy in just a few lines with a combination of different behaviors! <br><br><h3>  What about these mountains in the background? </h3><br>  Oh, you noticed the mountains in the background!  If you look at the memory cards, then there you will not find them.        :       ,   ,   ,     . <br><br>    ?         .      (     )        ,     ,   (   300    ). <br><br>       ,      (       ),    ,       .   ,      ,     (  ,   <strong>Game.scr</strong>     ). <br><br><h3>   </h3><br>     TIC-80   ,     ,       .  ,        ¬´ ¬ª,     : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(overrides)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c=<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> clr=PAL[c] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> overrides <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> overrides[c] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> clr=overrides[c] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> poke(<span class="hljs-number"><span class="hljs-number">0x3fc0</span></span>+c*<span class="hljs-number"><span class="hljs-number">3</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span>,(clr&gt;&gt;<span class="hljs-number"><span class="hljs-number">16</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">255</span></span>) poke(<span class="hljs-number"><span class="hljs-number">0x3fc0</span></span>+c*<span class="hljs-number"><span class="hljs-number">3</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>,(clr&gt;&gt;<span class="hljs-number"><span class="hljs-number">8</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">255</span></span>) poke(<span class="hljs-number"><span class="hljs-number">0x3fc0</span></span>+c*<span class="hljs-number"><span class="hljs-number">3</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>,clr&amp;<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>   0x3fc0   ,   TIC-80   ,           . <br><br><h3>   </h3><br>        .    ,      .    17  ,   6 : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/1b3/b50/b201b3b504321d8b257f37cc49dd7d0f.gif" alt="image"></div><br><br>               Z.       : <strong></strong>  <strong></strong> . <br><br>   ( 62   )     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a0/575/cdc/4a0575cdcfe0b2535081d7bbfba0f6cb.gif" alt="image"></div><br><br>         ( 61): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3be/aac/1e3/3beaac1e3f89d4d39b4b0794ed535723.gif" alt="image"></div><br><br>   ,   .  ¬´1¬ª, ¬´2¬ª  ¬´3¬ª  .  ,     ,    (1‚Äì6)  .  , ,      ¬´2¬ª   3 (   ),  ,       ¬´3¬ª,    ,    3‚Äì2. <br><br>  ¬´A¬ª    ,   ¬´B¬ª ‚Äî        . <br><br><h3>     </h3><br>            TIC-80.    ,         ,             ,    .  ,       -. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/926/0f0/56c/9260f056c8bc2e718cab5bd097cd6e79.gif" alt="image"></div><br><br>         ,   ,        . ,         ,    (        ,        ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/902/0b9/94b9020b9083293d63e25c5be1385cf9.gif" alt="image"></div><br><br>   8  (  TIC-80): <br><br><ol><li>  A  ,    1‚Äì5. </li><li>  B  ,    1‚Äì5. </li><li>    (). </li><li>  C  ,    1‚Äì5. </li><li>   . </li><li>   . </li><li>     6 ( 2 ) </li><li>    ( ¬´The End¬ª) </li></ol><br><h3>  Conclusion </h3><br>        ,      TIC-80 ( <a href="https://github.com/nesbox" rel="nofollow noopener"> </a> )     . ,        (    ,  !),     ! <br><br>          TIC-80     . </div><p>Source: <a href="https://habr.com/ru/post/340502/">https://habr.com/ru/post/340502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340488/index.html">Vdi as art</a></li>
<li><a href="../340492/index.html">Hackathon Budget tools: create a project for the Ministry of Finance of Russia</a></li>
<li><a href="../340494/index.html">5 reasons why Python is powerful enough for Google</a></li>
<li><a href="../340496/index.html">Burn-out or burnout</a></li>
<li><a href="../340500/index.html">Interview with Mikhail Trutnev (Ultimate Guitar) about business, team and strategy</a></li>
<li><a href="../340504/index.html">Issue price - 10 million. Softline Venture Partners accepts applications in the IT business accelerator</a></li>
<li><a href="../340508/index.html">How JS works: event loop, asynchrony, and five ways to improve code with async / await</a></li>
<li><a href="../340510/index.html">How we created Raiffeisen Online ...</a></li>
<li><a href="../340514/index.html">Testing React-Redux Applications</a></li>
<li><a href="../340516/index.html">Search memory leaks in applications on .NET Core under Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>