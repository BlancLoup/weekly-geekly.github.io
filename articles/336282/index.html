<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Trafaret as a parser. JSON Schema implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Intro 


 There is such a step in the development of a language when its compiler is written in it. 
 To prove the coolness of the trafaret library I ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Trafaret as a parser. JSON Schema implementation</h1><div class="post__text post__text-html js-mediator-article"><h1>  Intro </h1><br><p>  There is such a step in the development of a language when its compiler is written in it. <br>  To prove the coolness of the trafaret library I also decided to do something the same. <br>  recursive where you have to go deeper. </p><br><p>  We write on the stencil parser Json Schema, which will return <br>  ready stencil for checking documents in accordance with this description. </p><br><p>  That is a certain object of type Trafaret, if you feed it a valid json schema document <br>  returns Trafaret object at the output to which you can feed documents <br>  matching the description. </p><br><p>  How do you do this with a validation library?  Well, the validation library does, but the universal transformer is easy.  Trafaret is a data parser, more precisely a combinatorial parser.  Only those parsers about which you have heard, such as parsec and funcparserlib, parse the lines, and Trafaret will parse everything that comes to hand and what the author of talents will do is encode. </p><br><p>  Json Schema is described as a pack of documents, of which the closest to the people is probably this one - <a href="http://json-schema.org/latest/json-schema-validation.html">http://json-schema.org/latest/json-schema-validation.html</a> <br>  There is a description of a set of keywords with the help of which you can describe the criteria for correctness of a document, but a wonderful and subtle in implementing $ ref just in one place in passing. </p><a name="habracut"></a><br><h1>  Part one </h1><br><p> In the json scheme in the base case, the implementation is quite simple - all keywords, such as <code>maximum</code> (maximum value for a number), <code>pattern</code> (the regular schedule by which the string should be checked), <code>items</code> (child scheme or an array of schemes for checking array elements). <br>  So, all these keywords should be used separately.  We met the maximum, we will immediately check this number for compliance with the upper limit.  That is, you can take the scheme, for example: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maximum"</span></span>: <span class="hljs-number"><span class="hljs-number">45</span></span>, }</code> </pre> <br><p>  and disassemble it into components, just a list of checks all of which must pass. </p><br><pre> <code class="hljs pgsql">validations = [] <span class="hljs-keyword"><span class="hljs-keyword">for key</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key == <span class="hljs-string"><span class="hljs-string">'type'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == <span class="hljs-string"><span class="hljs-string">'number'</span></span>: validations.append(is_a_number)</code> </pre> <br><p>  What the hell, and another scheme would be to check.  Perhaps we‚Äôll finish with kneaded examples, let's start writing a parser.  Json Schema is a dictionary, object, map, shorter keys and values ‚Äã‚Äãin curly brackets <code>{}</code> .  So we will check the dictionary, try: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> trafaret <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t #     trafaret     json_schema_type = t.Enum(<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>, <span class="hljs-string"><span class="hljs-string">'object'</span></span>, <span class="hljs-string"><span class="hljs-string">'array'</span></span>, <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'integer'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>) json_schema_keys = t.Dict( t.Key(<span class="hljs-string"><span class="hljs-string">'type'</span></span>, optional=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, trafaret=json_schema_type), t.Key(<span class="hljs-string"><span class="hljs-string">'maximum'</span></span>, optional=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, trafaret=t.Int()), )</code> </pre> <br><p>  We took only a couple of keywords in order not to bore the reader with scrolling.  Validation will work, but as a result we need not only to check the schema, but also to get validators.  And this is exactly what trafaret, unlike many, does two times, but you have to think a little. </p><br><p>  There is an operation <code>&amp;</code> , takes two stencils and applies the second one to the output of the first one if not <br>  validation errors, that is, of the type: </p><br><pre> <code class="hljs lisp">check_password = ( <span class="hljs-name"><span class="hljs-name">t</span></span>.String() &amp; (<span class="hljs-name"><span class="hljs-name">lambda</span></span> value: value if value == 'secret' else <span class="hljs-literal"><span class="hljs-literal">t</span></span>.DataError('Wrong password')) )</code> </pre> <br><p>  If the input does not pass the <code>check_password(123)</code> , then at the output we will immediately receive a message stating that the value is not a string and will not be checked for compliance with the string 'secret'. <br>  To check any python values ‚Äã‚Äãfor equality in the stencil there is an Atom. </p><br><p>  And it would be possible to describe types like: </p><br><pre> <code class="hljs lisp">json_schema_type = ( <span class="hljs-name"><span class="hljs-name">t</span></span>.Atom('null') &amp; <span class="hljs-literal"><span class="hljs-literal">t</span></span>.Null() | <span class="hljs-literal"><span class="hljs-literal">t</span></span>.Atom('boolean') &amp; <span class="hljs-literal"><span class="hljs-literal">t</span></span>.Bool() )</code> </pre> <br><p>  But this is not what we want.  We want to return the stencil and not to apply it immediately <br>  with the obviously erroneous variant - the string 'null' is definitely not None. </p><br><p>  We write a helper, which is also a stencil, and returns the specified stencil: </p><br><pre> <code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">just</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(trafaret)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Returns trafaret and ignoring values"""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> trafaret <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create</code> </pre> <br><p>  And apply: </p><br><pre> <code class="hljs lisp">json_schema_type = ( <span class="hljs-name"><span class="hljs-name">t</span></span>.Atom('null') &amp; just(<span class="hljs-name"><span class="hljs-name">t</span></span>.Null()) | t.Atom('boolean') &amp; just(t.Bool()) | <span class="hljs-literal"><span class="hljs-literal">t</span></span>.Atom('object') &amp; just(<span class="hljs-name"><span class="hljs-name">t</span></span>.Type(<span class="hljs-name"><span class="hljs-name">dict</span></span>)) | t.Atom('array') &amp; just(t.Type(list)) | <span class="hljs-literal"><span class="hljs-literal">t</span></span>.Atom('number') &amp; just(<span class="hljs-name"><span class="hljs-name">t</span></span>.Float()) | t.Atom('integer') &amp; just(t.Int()) | <span class="hljs-literal"><span class="hljs-literal">t</span></span>.Atom('string') &amp; just(<span class="hljs-name"><span class="hljs-name">t</span></span>.String()) )</code> </pre> <br><p>  Now the <code>json_schema_type('null')</code> call will return an instance of <code>t.Null()</code> .  Parser began to spawn <br>  final result. </p><br><p>  The first difficulty level is passed, we implemented <code>type</code> .  With joy, we do the same way <code>enum</code> , <code>const</code> , <code>multipleOf</code> , <code>maximum</code> etc. </p><br><h1>  Go to the second level of difficulty. </h1><br><p>  Almost all keywords in the json scheme are independent, but some of them all depend on each other.  These are keywords for arrays and objects.  <code>additionalItems</code> is a child schema for checking array elements that are not described in <code>items</code> .  That is, for example, <code>"items": [{"type":"string"}, {"type":"bool"}]</code> checks the first two elements, but if there are 3 or more of them in the checked document, then they should be checked via <code>additionalItems</code> , if specified, or <br>  this is a mistake in itself. </p><br><p>  The second case is <code>additionalProperties</code> .  For checking objects in the json scheme, <code>properties</code> and <code>patternProperties</code> , and for everything that is not described in the first two, <code>additionalProperties</code> used. </p><br><p>  This is, in principle, a long-resolved topic in stencil making, special keys are used, but not 100% of the population are still engaged in stencil making, so let's stop a little more. </p><br><p>  To check the dictionaries in the stencil is not quite a standard approach.  In fact <br>  the dictionaries in the stencil are dealt with by the keys, in particular, the <code>Key</code> , and the <code>Dict</code> itself <br>  This is a binding around which collects the results of the execution of all keys on the given object. </p><br><p>  The key type in terms of mypy looks like this: </p><br><pre> <code class="hljs 1c">KeyT = Callable[ <span class="hljs-meta"><span class="hljs-meta">#   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   __call__ [Mapping], #      Mapping (.. dict ) Sequence[ #  ,       Tuple[ #       </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   str, #         ‚Äì   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   Union[Any, t.DataError], #  </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> -  </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   DataError Sequence[str] #             ] ] ]</span></span></code> </pre> <br><p>  We look carefully three times and pay attention to the last line before the bracket - the key reports about all the keys of the dictionary that he pulled.  That is, the key can pull a bunch of keys, as well as return any number of keys.  To know which keys of the dictionary yanked the key is necessary to find out if there are extra or additional elements in the dictionary. </p><br><p>  It follows that the key can immediately take a bunch of keys and check them at once.  It was generally a decision what to do with <code>password</code> &amp; <code>password_confirmation</code> when the keys themselves are so independent.  But in our case, the task is somewhat more cunning than comparing the two keys for equality, and the inherent flexibility still does not allow it. </p><br><p>  Meet the <code>subdict</code> : </p><br><pre> <code class="hljs pgsql">def subdict(<span class="hljs-type"><span class="hljs-type">name</span></span>, *keys, **kw): trafaret = kw.pop(<span class="hljs-string"><span class="hljs-string">'trafaret'</span></span>) # coz py2k def <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>(data, context=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>): errors = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> preserve_output = [] #   ,      touched = <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>() collect = {} <span class="hljs-keyword"><span class="hljs-keyword">for key</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> keys: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v, names <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> key(data, context=context): touched.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(names) preserve_output.append((k, v, names)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(v, t.DataError): errors = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: collect[k] = v <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> preserve_output: yield <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> elif collect: #              yield <span class="hljs-type"><span class="hljs-type">name</span></span>, t.catch(trafaret, **collect), touched <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span></code> </pre> <br><p>  And something like this is applied in the depths of <code>trafaret_schema</code> : </p><br><pre> <code class="hljs pgsql">subdict( <span class="hljs-string"><span class="hljs-string">'array'</span></span>, t.Key(<span class="hljs-string"><span class="hljs-string">'items'</span></span>, optional=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, trafaret=ensure_list(json_schema)), t.Key(<span class="hljs-string"><span class="hljs-string">'additionalItems'</span></span>, optional=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, trafaret=json_schema), trafaret=check_array, ),</code> </pre> <br><h1>  The third figure, we need a state </h1><br><p>  Well, the state is not the state, but since birth the stencil was completely functional in its soul.  Everything that gets on the conveyor does not affect the neighbors.  And this is great!  Our good-natured and never elite adherents of the functionals chewed it in terms of mathematics many times. </p><br><p>  But at the next level of json scheme we are met by a mega boss - <code>$ref</code> .  A very reasonable thing, allows you to refer to another scheme already defined somewhere.  For example, the schema may be defined in <code>definitions</code> or in general in another document. </p><br><p>  So in the process of parsing the scheme, all the definitions of the scheme with their addresses we need to be collected in one place.  Then check that all $ ref met in the document have definitions.  And in the process of execution it is already clear - the stencil for $ ref just pulls the stencil from the registry. </p><br><p>  Well, write the registry once to spit: </p><br><pre> <code class="hljs python"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"  "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  But then I had to refine the stencil and, in addition to the standard <code>value</code> argument, you can now also chain up the standard stencils with <code>context=Any</code> .  And actually our just-written <code>Register</code> is this very context. </p><br><p>  We use something like this to define a stencil for <code>$ref</code> : </p><br><pre> <code class="hljs vhdl">def ref_field(reference, <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>=None): <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">context</span></span> #     <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>.reg_reference(reference) #    $ref,       def inner(value, <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>=None): #    ,     schema = <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>.get_schema(reference) #        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schema(value, <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">context</span></span>) #      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inner</code> </pre> <br><p>  Of course the most confusion is to collect references to the utmost subcircuits. <br>  Here is an example for a child scheme, the link to which I want to save: </p><br><pre> <code class="hljs kotlin">def deep_schema(key): #   def <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, context=None): register = context register.push(key) #   key        #      ‚Äî      push,     #     <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: schema = json_schema(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, context=register) register.save_schema(schema) #   ,        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schema <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: register.pop() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t.Call(<span class="hljs-keyword"><span class="hljs-keyword">inner</span></span>)</code> </pre> <br><h1>  What for </h1><br><p>  The best of two worlds - json scheme is widespread and supported by any languages.  A stencil is the best transformation library with checks under python.  More precisely the only one.  And most importantly, for the keyword <code>format</code> you can slip any stencil like this: </p><br><pre> <code class="hljs haskell"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> trafaret <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t from trafaret_schema <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json_schema, Register my_reg = Register() my_reg.reg_format('<span class="hljs-title"><span class="hljs-title">any_ip'</span></span>, <span class="hljs-title"><span class="hljs-title">t</span></span>.<span class="hljs-type"><span class="hljs-type">IPv4</span></span> | <span class="hljs-title"><span class="hljs-title">t</span></span>.<span class="hljs-type"><span class="hljs-type">IPv6</span></span>) check_address = json_schema(<span class="hljs-title"><span class="hljs-title">open</span></span>('<span class="hljs-title"><span class="hljs-title">address</span></span>.<span class="hljs-title"><span class="hljs-title">rjson'</span></span>).read(), context=register) check_person = json_schema(<span class="hljs-title"><span class="hljs-title">open</span></span>('<span class="hljs-title"><span class="hljs-title">person</span></span>.<span class="hljs-title"><span class="hljs-title">json'</span></span>).read(), context=register)</code> </pre> <br><h1>  Results </h1><br><ul><li>  <code>trafaret_schema</code> working, ready to use, write if something <code>trafaret_schema</code> wrong, we will rule.  Look at <a href="https://github.com/Deepwalker/trafaret_schema">https://github.com/Deepwalker/trafaret_schema</a> or <code>pip install trafaret_schema</code> . </li><li>  In the process, <code>Trafaret</code> received context support, and at the same time, <code>async/await</code> , to <br>  in the case of asyncio, there was something to do with this context. </li><li>  We got this wonderful text on stencils to do anything, including other stencils. </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/336282/">https://habr.com/ru/post/336282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336270/index.html">Brief reaction to Xored material</a></li>
<li><a href="../336272/index.html">Types of models</a></li>
<li><a href="../336276/index.html">How I created a monitoring system for computers at work and moved the service to Amazon AWS</a></li>
<li><a href="../336278/index.html">Using the system API in Sailfish OS</a></li>
<li><a href="../336280/index.html">Angular Basics: HttpClient</a></li>
<li><a href="../336284/index.html">Blockchain: The Future of IT Professionals</a></li>
<li><a href="../336286/index.html">Reed-Solomon codes. Part 1 - the theory of simple language</a></li>
<li><a href="../336288/index.html">What is known about the possible IPO Dropbox: rumors, difficulties and numbers</a></li>
<li><a href="../336290/index.html">How to scratch a panda</a></li>
<li><a href="../336292/index.html">Not all CT pancake week, or CT does not walk by itself</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>