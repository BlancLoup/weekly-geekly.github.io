<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Base on programming languages: syntactic sugar or history of language development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue to lay out excerpts from the introductory course of our company on industrial programming. 

 Part Three: Syntactic Sugar or the History of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Base on programming languages: syntactic sugar or history of language development</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/post/147617/">I continue to</a> lay out excerpts from the introductory course of our <a href="http://wikimart.ru/">company</a> on industrial programming. <br><br><h4>  Part Three: Syntactic Sugar or the History of the Development of Languages </h4><br><br>  This part describes the history of the development of programming languages, as well as explains what OOP and functional programming are.  Other parts can be found <a href="http://habrahabr.ru/post/147617/">here</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  Syntactic sugar (syntactic sugar) - a general designation of additions to the syntax of the PL, which make using the language more convenient, but do not add new features to it. <br><br>  The whole history of the development of PL is a history of increasing the sweetness of syntactic sugar. <br><br><h4>  Machine Languages </h4><br>  It all started with machine-dependent languages ‚Äã‚Äã- languages, taking into account the structure and characteristics of certain computer platforms.  Those who programmed on calculators remember how programs were compiled on them. <br><br>  A dozen registers where the results of the calculations were recorded (where are these gigabytes of RAM?), A couple of shift registers (remember the Turing machine, yes, the registers used the data register to take the next command!), And the register of the command where it was necessary to write another operation (read value, write value, add value of two memory registers, etc.). <br><br><h5>  Architecture Neumann Background </h5><br>  Even the architecture of these devices did not always correspond to the von Neumann architecture ‚Äî standard for modern computers. <br>  Actually, the von Neumann architecture implies the separation of memory from the processor and the storage of mutable programs.  Calculators are usually devices with a fixed set of programs being executed. <br><br>  Actually, the transition to the von Neumann architecture gave rise to the ability to set automatically running programs from an external source - first from punched tapes and punched cards. <br>  People programmed this way, punching a hole in the card corresponding to a specific register, thus, bit-wisely setting values ‚Äã‚Äãin them.  A lot of stories are connected with the way a program full of hundreds of punch cards in the literal sense of the word crumbled when clumsy technicians dropped these stacks of cardboard onto the floor. <br><br><h5>  Assembler </h5><br>  It was not very convenient to program machine codes, so an assembler appeared at the first opportunity ‚Äî a language that repeats machine operations, but with human-readable commands and the ability to handle on paper to describe the algorithm not as a set of bits, but as some more meaningful text. <br><br>  The assembler is also tied to the architecture of the machine (since its commands repeat the instructions of the processor), but the step into the abyss was already made and the languages ‚Äã‚Äãbegan to overgrow more and more sugar crystals. <br><br><h5>  Stack languages </h5><br><br>  The first sign was the use of data stacks.  The stack appeared to solve the problem of temporary storage of arbitrary data.  Of course, the data can be stored in the register, but in this case you need to remember the name of each register from which you want to receive data. <br><br>  The character of the stack is a special order of getting data from it: at any time in the stack, only the top element is available, i.e.  last item pushed onto stack  Unloading the top element from the stack makes the next element available, by analogy with the automatic horn - the first cartridge inserted into it can only be reached by the last one. <br><br>  Now it may seem wildly inconvenient, but it allowed to create subroutines. <br><br>  Before calling the subroutine, we populate a specially named stack with data.  The subroutine, knowing in which order the parameters are put on the stack, can take them from there and use them when they are executed, and when done, put the results of their work into the same or a different stack.  In addition, the main program has the ability to keep its data on the stack before transferring control to the subroutine.  After returning control, the program simply restores its values ‚Äã‚Äãfrom the stack and does not pay attention to the fact that the data in the processor's registers could be overwritten by the subroutine. <br><br><h5>  Macroassembler </h5><br><br>  The next step was a macro assembler.  A macro assembler is a program for a macro processor, which in turn was a translator from a higher level language (macro assembler) into machine code.  It became possible to create your own teams for, for example, using the stack. <br><br>  Commands for working with the stack (push, pop), commands for copying stacks of data are born. <br><br>  A macro assembler spawns higher-level languages, with teams that have dozens or even hundreds of processor commands.  FORT, ALGOL, BASIC begin their journey ... <br><br><h5>  Modular languages </h5><br><br>  Having tasted the forbidden fruit of the extended syntax, the programmers did not stop and desired modularity: it‚Äôs so convenient to call a separately written module of the program and not go into its algorithm.  The main thing is to know how it takes the input data and how it returns the result. <br><br>  The assembler is replenished with commands that facilitate the naming and connection of modules, the transfer and return of control when calling various subroutines.  Data exchange interfaces are evolving.  The concept of a data structure arises. <br><br><h4>  Procedural languages </h4><br>  The logical addition to the modular language was the concept of a procedure or subroutine.  The subroutine has two important features: <br><br>  1. it is named, i.e.  we can call a subroutine by name <br>  2. having called a subroutine, we know for sure that it will return control to the same place it was called from <br><br>  For example, in BASIC, the subroutine was called as GOSUB: Label :. <br><br><h5>  Function </h5><br>  Only one thing was missing: I wanted the variables of the parent program (from which the subroutine was called) not to be corrupted.  But how was it?  All variables in the global space, you will begin to use them in the subroutine - it overwrites them. <br><br>  Thus, the concept of a function and local variables was invented: we call a named subroutine and pass some values ‚Äã‚Äãthere.  The subroutine treats the passed values ‚Äã‚Äãas local named variables. <br><br>  With the development of the function has acquired the ability to return the result: before that, because, as it was - the return value was recorded in one of the global variables. <br><br>  The function has the following features: <br><br>  1. it is named <br>  2. parameters are passed there <br>  3. passed parameters are available as named parameters only inside the function, they are not visible outside the function <br>  4. The function can use its local named parameters that are not visible outside this function. <br>  5. function can return the result of work <br><br>  An introduction to the syntax of a function harmoniously complements procedural programming languages. <br><br><h4>  Functional languages </h4><br>  The natural desire was to supplement functions with the opportunity to observe the local variables of the parent function in the called function when called. <br><br>  To solve this, the genius of the twilight mind engenders the notion of execution context: this is the domain of named variables that functions can access at run time.  This data area is made inheritance-expandable: when a child function is called, it creates its own context, populated with variables declared inside the daughter function.  At the same time, outside the function-daughter these variables are not visible.  But it will be available when calling granddaughter function, great-granddaughter function, and so on. <br><br>  The ability to inherit the execution context is called closure. <br><br>  The ability to fully work with the execution context generates functional programming languages. <br><br>  Finally, they are created by adding the ability to pass a function as a parameter to call another function, as well as return the function as the result of the subroutine execution. <br><br><h4>  Data types </h4><br>  At the same time, the thought of programmers did not stand still.  Programmers invented data types. <br>  Initially, because as it was, the data were available exclusively in binary form - zero, and one. <br><br>  People, to solve practical problems, it is more convenient to operate with abstractions of higher levels.  Thus, integer data types appear without the possibility to indicate whether they are negative or not (byte, unsigned integer, unsigned long integer, etc.). <br><br>  Then, as their development - data types with the ability to record a negative number (encoded by the first bit, in connection with which there were funny inco cases of inequality +0 and -0).  Finally, for more convenient work with floating point, float and double float types emerged (as you might guess, double float is the same float, but with the ability to record more characters both before and after the comma). <br><br>  Interesting is the byte representation of the float type - in principle, in order to transfer the number we need the same integer with the ability to specify a negative number and or not and indicating how many digits from the beginning of the number it is necessary to put a period. <br><br>  For logical operations, in principle, the same zero and one were enough, but for the most kuziavosti they were wrapped in a boolean type with two true and false values ‚Äã‚Äã(for which, in other matters, the same one and zero were standing). <br><br>  The next type of programmers that was badly needed was an array.  The data array was fundamentally different from the stack by the possibility of free access not only to the last stuck element, but in general to any number.  The array was presented to programmers as glued cells, inside of which the data lay, for this initially the array was set at once of a certain size and this size could not be changed. <br><br>  But, in fact, the cells are not necessarily filled?  So it took the designation of an empty cell and the type null appears.  In fact, at first he was a symbol with the code 0x0, which led to funny incidents, when this cell needed to write a zero value, and then read it and interpret it as null, and not as an unsigned integer with a value of 0. <br><br>  To declare an array, a fragment of memory (buffer) was reserved, indicating how many cells will be located in this fragment, as well as which elements will be placed in it.  And do not let Richie write to you in an array of type int an element of the form long!  At best, subsequent elements were damaged, at worst, there was a buffer overflow and other non-array data could be damaged, located immediately behind the allocated memory buffer. <br><br>  Strings, by the way, first appeared exactly as arrays of characters (I had to enter another data type - char, which essentially corresponded to byte).  Because of this, the length of the lines had to be announced in advance. <br><br>  In order to cope with strings of variable length, they invented to mark the end of the line with a null-marker.  Ie, as before, the line was an array, but the length of this array was set at once large enough to hold any line (640kb of memory is enough for any program, yeah).  The string started at the beginning of the array, and the end of it was marked as null-byte, what followed the null was not considered a string. <br><br>  A good idea on paper to mark the end of the line with a null marker on closer inspection turned out to be terrible: nothing prevented you from adding a null in the middle of the line and having a bunch of lulz from it.  So began the era of C-strings. <br><br><h4>  Links </h4><br><br>  The organization of work with data as with a memory buffer created an interesting opportunity when calling a function to transfer there not the data itself, but a link to it. <br><br>  Previously, how was it?  The values ‚Äã‚Äãof the variables were transferred to the functions, these values ‚Äã‚Äãwere copied into the named variables of the functions in order to avoid damage to the original data. <br><br>  But after all, just the value of the address of the selected memory fragment can be passed inside the function and then read out the variable of any available data type from it!  So another type of data appeared - the link. <br><br>  A link is a shortcut (link) to some variable for which a memory block is allocated.  In the PL, methods of working with variables appear both by value (directly with this memory block) and by reference (we read the pointer from a variable, then we go through it and change the value in the memory there). <br><br><h4>  Data structures </h4><br>  It would seem that they fought for it and ran into it: isolated-isolated variables inside the functions, so as not to spoil them, and now we give a gun in our hands from which you can also shoot a leg! <br><br>  But it was not there: passing variables by reference gave a unique opportunity to construct entire structures from simple data types - data structures! <br><br>  For example, it became possible to organize a link to an array of links to arrays from ... So this same whole tree can be built! <br><br>  Naturally, such an array in itself does not carry any practical value, since all this can be organized using simple data types, but if you add functions like addNode, removeNode working with a tree to the program, and pass a reference to the data structure to these functions, it turns out working and very seductive design. <br><br><h4>  Structural Languages </h4><br>  So it turns out that the programmer himself can create his own data types, convenient for his program - it is enough just to create a data structure and describe the functions of working with them! <br><br>  This is how structural programming languages ‚Äã‚Äãappear.  They immediately add the ability to describe a new data type, the ability to somehow name this type and set some operations for it. <br>  For example, a string can be represented not just as an array, but as a two-linked list with concatenation functions through the + operator and access to an arbitrary character through the [] operator. <br><br>  Immediate rapid growth of structural languages ‚Äã‚Äã(Pascal, C) begins, with the following features: <br><br>  1. they have a formal language for describing data structures (* .h files in C) <br>  2. they have the opportunity to give the described structure a name (BTree) <br>  3. they have the ability to denote operations of work with this data structure <br><br><h5>  An object </h5><br>  The ability to create your own data types excites a desire among programmers to have functions within this data type to work with it. <br><br>  As a response to the aspirations of these bright minds, the concept of the Object is born.  An object is no longer just a data type, not just a link by which structured information is stored, but also functions for processing this information that are accessible via the same link. <br><br>  Under this universal philosophy is brought: <br><br>  ‚ÄúAn object is an entity in virtual space, possessing a certain state and behavior, having specified values ‚Äã‚Äãof properties (attributes) and operations on them (methods).‚Äù <br><br><h5>  Encapsulation </h5><br>  Deep philosophical studies make it possible to realize that an object has such a property as encapsulation, which is defined as the property of an object to combine data and methods of working with this data.  Philosophers generally love recursive definitions. <br><br>  The essence of encapsulation is simple: an object is not an object, if its state (that is, the data it contains) can be changed without applying the methods of the object.  At the same time, it is considered that public variables of an object, accessible to everyone and everything for change, are also methods for changing the internal state of this object itself. <br><br>  Actually, $ object-&gt; property = 12345;  It is considered equivalent to the $ object-&gt; setProperty (12345); method, because without specifying the name of the $ object access to the $ property variable in the operation directly, you cannot get directly. <br><br><h5>  Inheritance </h5><br>  Even before the philosophers of the Object, programmers, when working with data structures, very much wanted and invented how to expand data structures, inherit the scheme of the parent structure in the child structure. <br><br>  Creating the same Object that combines data with functions has created an interesting engineering problem, how to twist it: inherit the structure, inherit the functions, and add new features to the heir. <br><br>  And the thing is that you have a function in the Parent Object, there is a function in the Heir Object, they do different things, but so that they have the same names - oops.  The solution to this problem was called polymorphism. <br><br><h5>  Polymorphism </h5><br>  Philosophers and then jumped on their heels, giving the definition: ‚ÄúPolymorphism is the possibility of objects with the same specification having a different implementation.‚Äù  The specification here refers to the names-signatures of methods for working with an object (including public variables). <br><br>  There are many implementations of polymorphism, here are some of them: <br>  - pure polymorphism (signature polymorphism) <br>  - parametric polymorphism (polymorphism by method name) <br>  - redefinition (abstraction, abstract classes) <br>  - overload (incomplete replacement of the ancestor method by the descendant method) <br><br><h5>  Abstraction </h5><br>  Philosophical thought also did not stand still.  After studying the properties of inheritance, philosophers realized that it can be replaced by abstraction. <br><br>  Abstracting is such a thing ... How to explain?  Here you have an Object - great, this is something material.  And there is also an idea of ‚Äã‚Äãhow this object can be: what methods it should exhibit, what these methods should do, but without specifics, so abstractly (reminds customers, isn't it?).  Actually, we have just described the interface of an object or an abstract ancestor whose covenants can be cast into the reality of code. <br><br><h4>  OOP </h4><br><br>  Actually, OOP is Object Oriented Programming.  This is the ability of some programmers to work with objects within all three concepts: encapsulation, inheritance, and polymorphism.  Well or encapsulation, abstraction and polymorphism. <br><br>  The OOP paradigm has nothing to do with the MVC model (unlike the opinions of some PHP programmers).  OOP is just working with data and data processing methods as with inherited objects. <br><br>  Unlike procedural and structured programming paradigms, where if there are objects, they are not inheritable.  Well, or there are no objects, all data is transferred in arrays, structures, allocated memory buffers. <br><br><h5>  Class-oriented programming </h5><br>  Object programming requires the creation of multiple objects (oddly enough).  Accordingly, it is required to somehow organize the hierarchy of objects, to somehow miss them. <br><br>  In response to these aspirations, the concept of a class instance was developed.  What is a class?  A class is a set of methods and functions without data.  The class itself is something non-working, data is needed for work.  Actually, in order to get a working object, you need to instantiate a class ‚Äî say ‚Äúcreate an object for me with the functions described in this class and the data that I will tell you now‚Äù. <br><br>  In fact, a class is such a syntactic piece of sugar, which makes it possible not only to describe the object's API (as the interface does), but also to specify data processing functions. <br><br>  The class system allows you to formally describe the properties of an object, the rules for inheriting properties of objects, the rules for accessing object data.  The use of classes defines the class-oriented programming paradigm. <br><br>  A class is a cool thing, but not necessary for OOP, since there are object-oriented languages ‚Äã‚Äãthat can be well managed without classes. <br><br><h5>  Prototype programming </h5><br>  Another way to set inheritance is a prototype.  With prototype programming there are no instances of objects, the object exists in a unique form.  But for each object you can set a prototype or prototypes - a list of objects, properties and methods of which it will inherit. <br><br>  Historically, the model of inheritance through prototypes, which is shared by a language such as JavaScript, is older than through the description of classes.  But class-oriented programming turned out to be more convenient for describing APIs and frameworks (and as you know, every mature Java programmer is required to write his own framework, as well as the maturity of a PHP programmer is determined using a self-written CMS), which is why it has become more common. </div><p>Source: <a href="https://habr.com/ru/post/147619/">https://habr.com/ru/post/147619/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../147613/index.html">Amazon Announces Game Center - GameCircle</a></li>
<li><a href="../147615/index.html">The project of the game console in less than 2 days collected $ 3 million on Kickstarter</a></li>
<li><a href="../147616/index.html">Save time on connecting fonts to the project</a></li>
<li><a href="../147617/index.html">Base on programming languages: How did languages ‚Äã‚Äãappear and why</a></li>
<li><a href="../147618/index.html">Base on programming languages: The principle of preserving functionality</a></li>
<li><a href="../147620/index.html">Using PHP Closures</a></li>
<li><a href="../147621/index.html">The cost of Google Nexus 7 was estimated by independent experts.</a></li>
<li><a href="../147622/index.html">Google spoke out against law No. 89417-6</a></li>
<li><a href="../147623/index.html">German operator opposes paid roaming</a></li>
<li><a href="../147625/index.html">New law threatens free internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>