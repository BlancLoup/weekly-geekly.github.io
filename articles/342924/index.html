<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming under ARM TrustZone. Secure monitor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue our series of articles on the centenary of the Great October ... ARM TrustZone. 

 Today we will understand what Secure World, Normal Worl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming under ARM TrustZone. Secure monitor</h1><div class="post__text post__text-html js-mediator-article">  We continue our series of articles on the <s>centenary of the Great October ...</s> ARM TrustZone. <br><br>  Today we will understand what Secure World, Normal World, and how two operating systems interact at the program level - trusted (TEE) and guest.  We learn what we need and how Secure Monitor works, how interrupts from devices are handled. <br><br>  If ready - welcome under cat. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the <a href="https://habrahabr.ru/company/aladdinrd/blog/340912/">last article</a> I talked about the hardware implementation.  There is everything about the hardware separation of worlds, how to prevent the guest OS from trusted memory and peripherals, and so on.  Take from there one thought as a binder: <br><br><ul><li>  Secure / Non-Secure is a processor mode.  It is specified by the NS (Non-Secure) bit in the SCR (Secure Configuration Register).  If NS = 1, we are in Non-Secure mode, if NS = 0, we are trusted, that is, Secure-mode. </li></ul><br>  In terms of software implementation, this is all we need.  The hardware is located on the other side of the abstraction, watching only NS, and the software is not only executed differently with NS = 0 and 1, but it can also change this bit. <br><br>  In both modes (NS = 0 and NS = 1), the processor can fully function, so much so that each mode can have its own OS: <br><br><ul><li>  NS = 0: trusted OS or Trusted OS, or Trusted Execution Environment (TEE); <br></li><li>  NS = 1: Guest OS, or Rich OS, or Normal World OS. </li></ul><br>  Each OS will have its own virtual memory card, its own applications, interrupts, drivers, and so on. <br><br>  Of course, we don‚Äôt always have two operating systems running on ARM.  A trusted code may not be a full-fledged OS, but some sort of small security monitor.  Or may be completely absent.  But in smartphones and tablets, the absence of a trusted OS is a rarity, there are mostly TEE (trusted OS) and a normal OS (for example, Android). <br><br>  Just don‚Äôt take the name TEE, Trusted Execution Environment at face value.  If TEE is called trusted, it means that someone trusts its code, because the code leads to the achievement of its goals.  Maybe his goal - to destroy the universe, how to know?  You do not see the source. <br><br><h2>  Boot process </h2><br>  Processors always run in secure mode.  There are many ARMv7A processors where Security Extensions are disabled.  And then they always work as Secure.  For example, everyone's favorite Sitara. <br><br>  But in any case - the processors always start in Secure mode. <br><br>  The loader participates first in the boot process, and in the case of TrustZone, one of the implementations of the Trusted Boot idea is used - the mechanism that verifies the signature of the image before launching it.  The general algorithm here is as follows: <br><br><ul><li>  read the boot image from external media into memory, for example, SD, eMMC, NAND, QSPI; <br></li><li>  check his signature with the public key stitched in the processor during the production phase of the product; <br></li><li>  if the signature is correct, transfer control to the loader. </li></ul><br>  The public key to verify the signature in the processor is flashed once, and after that only the primary loader, signed by the closed part of this key, can be launched.  There is also a field for abuse by major manufacturers. <br><br>  More information about downloading ARM - <a href="https://habrahabr.ru/company/aladdinrd/blog/338806/">in this article</a> . <br><br>  Next, the bootloader will check the signature of the trusted OS (TEE) and launch TEE.  Ta initializes everything that is needed in TrustZone, leaves Secure mode and transfers control to the guest OS (for example, Linux). <br><br><div style="text-align:center;"><img width="600" hspace="5" src="https://habrastorage.org/webt/be/ty/n9/betyn9zgou_m1fqgdzhr0ozx3py.png"></div><br>  If no TEE is used, and control directly from the bootloader is transferred to Linux, then Linux works in Secure mode.  This, however, does not make it a secure OS: there is no barrier between Secure World and Normal World and no trusted OS. <br><br>  Note that without Trusted Boot, TEE security would be compromised, since it could be replaced by changing the bootloader.  What matters is the whole authentication chain provided by binary signatures. <br><br><h2>  What we want to understand in this article </h2><br>  The picture shows the two operating systems that we just downloaded.  The guest OS can call TEE functions, for this it uses Secure Monitor. <br><br><div style="text-align:center;"><img width="600" hspace="5" src="https://habrastorage.org/webt/2h/lp/-j/2hlp-j_hcvj3i1wvckvqy_dmwuy.png"></div><br>  In this article, we will understand what the Secure Monitor is, how it is used and how it works. <br><br><h2>  CPU Modes </h2><br>  In ARMv7A there are quite a few modes of operation.  In the picture, they are divided into PL0, PL1, PL2 levels and some of the Secure levels, and some are Non-secure. <br><br><div style="text-align:center;"><img width="600" hspace="5" src="https://habrastorage.org/webt/47/hs/9k/47hs9keuonnrckyj80qxhzojh-u.png"></div><br>  PL0 is the unprivileged mode in which normal programs are executed in the OS.  Each program is launched with its own memory card configured via the MMU, so it cannot get to other programs like this.  But she also cannot climb into the OS, because the OS itself has set it up this way.  To access the OS, the application makes a system call (Supervisor Call, SVC command), and the processor jumps to Supervisor mode, PL1. <br><br>  All the main OS code is executed in Supervisor mode (SVC), at the level of PL1.  Here, the OS kernel also has its own MMU table, and the kernel sees memory differently from applications.  By the way, the kernel does not have to see all the memory pages of the application, it will be less secure. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  Imagine that some driver will turn on the wrong pointer - the drivers are written by people, so anything is possible.  If the entire application memory is visible to the kernel, the driver can spoil some application.  If not, it is also bad, but there is a chance that it will fall into the milk and simply cause an exception. <br></div></div><br>  Another important kernel mode is IRQ.  Get there when the interrupt is triggered.  The IRQ is at the PL1 level, and therefore all the normal Linux device drivers work at the kernel level.  The FIQ paired IRQ mode is a quick interrupt.  In Linux, it is not used at all, but in the implementation of TrustZone, it has found application - we'll talk about this later. <br><br>  There are still modes Undef, Abort - these are exceptions when the program is running.  If an OS application (or kernel code) tries to execute an invalid command, Undef will occur, and if it turns to prohibited memory, it will be Abort.  I already wrote about this in the <a href="https://habrahabr.ru/company/aladdinrd/blog/340912/">last article</a> .  In the TrustZone implementation, we can choose whether Abort will be processed in the guest OS (Linux) or redirected to the trusted OS (TEE).  In the latter case, we can, for example, record the attempt of the guest OS to get into the area of ‚Äã‚Äãa trusted OS. <br><br>  System mode is rarely, if ever, used by everyone. <br><br>  All of the above modes are in both Secure and Non-Secure modes of operation.  In this case, for example, Secure Supervisor and Non-Secure Supervisor are separate modes.  They have different MMU tables, different access rights (due to the NS-bit), their data is stored in different cache lines, etc. <br><br>  <i>It is precisely because of the duplication of the Secure and Non-Secure modes on one core that you can run two OSes.</i> <br><br><h2>  Special processor modes </h2><br>  In the picture above there were a couple of modes: <br><br><ul><li>  Non-Secure Hypervisor (HYP), PL2; <br></li><li>  Secure Monitor (SMC), PL1. </li></ul><br>  HYP mode is used for hardware virtualization, as in VMWare.  It is at the level of PL2, it is even more important than the core of the guest OS and it can allow and forbid everything there, just like TEE.  But we are not going to talk about virtualization in this article for two reasons: firstly, there are few ARMv7 processors and software with its support, and secondly, everything from the ARM Virtualization Extensions becomes even more confusing.  So it is better to leave virtualization aside. <br><br>  But we really need the Secure Monitor mode, it is made to switch between Secure and Non-Secure OC.  Let's look at it from all sides. <br><br><h2>  Secure monitor </h2><br>  We have two full-fledged OSes, and they are globally different only in the NS bit: <br><br><ul><li>  Secure OS (TEE), NS = 0; <br></li><li>  Non-Secure OS (guestbook, for example, Linux), NS = 1. </li></ul><br>  After all, it is logical that the guest OS can not change the NS bit and get the privileges of Secure?  Absolutely logical.  It is less expected that Secure OS cannot take over and switch to Non-Secure mode by changing NS to 1. But this is also true. <br><br>  The fact is that switching between modes turned out to be somewhat more difficult than changing one bit: <br><ul><li>  To switch between modes, you also need to save / restore context.  Almost all the registers for Secure and Non-secure are shared, and they need to be saved and restored. <br></li><li>  In addition, a call from Normal World to Secure World is needed to perform some kind of operation, and the operation usually has parameters and a return value.  This also needs to be taken into account. </li></ul><br>  This is what the Secure Monitor mode came up with.  They get there by calling ‚ÄúSMC # 0‚Äú, which stands for Secure Monitor call.  Moreover, Secure code must call ‚ÄúSMC # 0‚Äú to switch to Non-Secure.  And Non-Secure to Secure jumps also. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  # 0 is just an atavism: at first ARM wanted to transmit the call code through this parameter, but then abandoned the idea and use R0 as the call number. </div></div><br>  In general, an SMC call is similar to an operating system (SVC) system call: <br><ul><li>  The SVC system call allows an OS application from an unprivileged mode (PL0) to call an OS function (PL1); <br></li><li>  calling the SMC monitor allows the guest OS code (Non-Secure PL1) to call the TEE function (Secure PL1). </li></ul><br>  The difference is that the return from the system call is not the same as the call itself, but the transition between Secure and Non-Secure is symmetrical, via SMC # 0. <br><br>  Three features of the Secure Monitor mode allow it to perform the Secure / Non-Secure context switch. <br><br><ul><li>  It has its own stack related to the Secure storage area.  The stack is available immediately upon entering Secure Monitor mode, and you can immediately save all the registers (context) of the caller, no matter which one. <br></li><li>  In Secure Monitor mode, we can change the NS bit as we please. <br></li><li>  Changing the NS bit in the Secure Monitor mode, we can see the registers and peripherals from the Secure mode, then from the Non-Secure mode.  At the same time, the NS will actually change, and this will affect the operation of the entire hardware binding.  However, all this will be in the framework of the implementation of one sequential subprogramme.  Because of this, Secure Monitor can prepare everything you need for context switching. </li></ul><br><h2>  TEE call example </h2><br>  For example, we want TEE to sign a document to us.  Data about the document we put in the registers of the processor, for example, like this: <br><br><ul><li>  R0 - opcode: sign the document in memory; <br></li><li>  R1 - the starting address of the document in Normal World memory (remember that the memory representation in Secure and Non-Secure is different); <br></li><li>  R2 is the length of the document; <br></li><li>  R3 is the starting address of the buffer where the signature will fall.  We assume that if the buffer is not enough, this is not a TEE problem. </li></ul><br>  We call SMC # 0 to call TEE.  In response, we expect from the TEE the signature in the specified buffer and the result code in the register R0, in order to understand whether the operation was successful or not. <br><br>  That is, there is a certain exchange protocol between the guest OS and TEE.  In ARM, in general, you can behave as you please and come up with any exchange concept, but there is an accepted exchange mechanism described in <a href="http://infocenter.arm.com/help/topic/com.arm.doc.den0028b/ARM_DEN0028B_SMC_Calling_Convention.pdf">ARM SMC calling convention</a> .  It describes which registers are used to transmit the command code, data, return values, and so on. <br><br><h2>  What does Secure Monitor do? </h2><br>  To begin with, the TEE initialization code writes the address of the entry point to the Secure Monitor (subroutine address) in the Monitor mode exception vector table, which is indicated by the MVBAR register. <br><br>  The MVBAR register is available only in Secure mode and indicates a special table of exception vectors used only when switching to Secure Monitor mode. <br><br>  ARM also has a regular vector table, which contains entry points for SVC, IRQ, FIQ, and so on.  This table is located by default at address 0x00000000, but the address can be configured by VBAR register. <br><br>  Of course, there are two registers for the operation of two OSs: Secure VBAR and Non-secure VBAR.  Which one is available depends on the NS bit. <br><br>  So, MVBAR is not used for SVC, IRQ, and so on, but only for SMC and a pair of exceptions that can be configured to get into Monitor Mode.  For example, we can configure Abort and FIQ to get into Secure Monitor, and due to this, intercept these exceptions. <br><br>  When initializing, TEE also sets the stack head address for the Secure Monitor, and you're all set, as they say overseas. <br><br>  An example of the implementation of Secure Monitor can be viewed in the OP-TEE sources, the code is really simple: <a href="">https://github.com/OP-TEE/optee_os/blob/master/core/arch/arm/sm/sm_a32.S</a> . <br><br>  Now let's see what happens when invoking the SMC # 0 command from the guest OS. <br><br><ul><li>  Management will transfer to the address specified in the MVBAR table - the Secure Monitor subroutine.  Wherein <br><ul><li>  the execution mode will be SMC; <br></li><li>  The CPSR (Current Program Status Register) of the calling code, including the mode in which it was: SVC, IRQ, or something else, is written to the SPSR (Saved Program Status Register) register; <br></li><li>  the LR (Link Register) registers the address from which the call originated. </li></ul></li><li> SPSR and LR come in handy for later return from the call, so they are recorded in the caller's context.  For now, this can only be done in the Secure Monitor stack. <pre>  srsdb sp! #CPSR_MODE_MON // Write LR and SPSR onto the stack </pre></li><li>  Then you need to figure out which side is <s>growing on the stumps of the moss</s> called SMC - Secure or Non-Secure.  To do this, read the SCR and check the NS bit.  If NS = 1, then we were called from Non-Secure.  In our example, this is the case, and we switch to Secure.  We set NS = 0. <br></li><li>  Save the context: <br><ul><li>  save all the remaining registers to the stack, and r0-r7 are already there; <br></li><li>  CPSR registers of other processor modes (IRQ, FIQ, etc.) are also saved there; <br></li><li>  Copy the contents of the stack into the Non-Secure context. </li></ul></li><li>  Restore the secure context: <br><ul><li>  restore the CPSR registers of all modes; <br></li><li>  load the contents of the registers from the secure context; <br></li><li>  load the entry point (future PC and CPSR) onto the Secure Monitor stack. </li></ul></li><li>  We jump out of the Secure Monitor mode, reading the PC and CPSR from the stack: <br><pre>  rfefd sp!  // rfe = return from exception </pre></li></ul><br>  Here is a very simplified description of what you will see in the code above.  There, operations are not even all performed in the same manner.  The goal was to convey a general meaning, nothing more. <br><br>  In fact, this is almost all that Secure Monitor does ‚Äî it transfers control to the Secure OS.  When Secure OS ends up with a call, it will also call SMC # 0.  Secure Monitor will understand by NS = 0 that it is now Secure, and you need to return to Non-Secure, and will do the same commands, but a little vice versa. <br><br>  If you got to deal with the code, then here's another hint under the spoiler: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  Secure Monitor identifies the caller's R0 register for the call.  There may be two options described in the <a href="http://infocenter.arm.com/help/topic/com.arm.doc.den0028b/ARM_DEN0028B_SMC_Calling_Convention.pdf">ARM SMC calling convention</a> . <br><br><ul><li>  Standard Call - a call that requires the creation of a stream in TEE to process it.  For example, accessing the function of a trusted application, or launching in general any TEE function that requires waiting, locks, semaphores, etc. <br></li><li>  Fast Call is a fast TEE call that does not require all of the above.  For example, we ask TEE to enable for us a couple more processor cores. </li></ul><br>  Fast Call is like an interrupt, it will return control quickly enough.  Standard Call - like RPC, after its call TEE starts working to its fullest, perform various operations, switch contexts, and maybe wait for the results of the operation. <br><br>  In principle, Secure Monitor could leave this test to TEE and immediately switch there, but there is such an implementation.  It is important not to get lost in this code and see that both calls are executed in the Secure Supervisor mode, and not in the Secure Monitor. </div></div><br><br>  If you are considering OP-TEE code, all calls from Non-Secure World go to Secure for processing, and Secure Monitor does not handle anything.  In OP-TEE, it works as a gatekeeper. <br><br>  UPDATE: Dear <a href="https://habr.com/users/lorc/" class="user_link">lorc</a> clarifies that in ARM Trusted Firmware, the implementation of Secure Monitor not only switches modes, it also performs a number of system functions, for example, power management.  See his comment. <br><br><h2>  Interrupt and Exception Handling </h2><br>  The guest OS, as a rule, does not really know that it is a guest.  Adjusts his memory, interrupts, performs tasks.  Everything works as it should, until it hits some kind of constraint imposed on it by TEE.  If it hits, Abort will happen, as we wrote in the last article. <br><br>  In this case, the guest OS will load a bunch of drivers, will assign interrupts and interrupts to these devices will be sent to the guest OS.  And why, one wonders, into her?  It may well be that the TEE wants to control some devices in monopoly mode and receive its interrupts from them.  Now we will understand how two OSes share interruptions. <br><br>  In the ARM processor, the main interrupt controller is one (let it be GICv2), there are no separate controllers for Secure and Non-Secure. <br><br>  If an interrupt occurs, GICv2 defaults to delivering it to Secure mode.  Then, if an interrupt has occurred, a vector will be loaded from Secure VBAR. <br><br>  But if we run TEE and Linux in parallel, then we need to somehow divide the interrupts.  It doesn‚Äôt matter if all interrupts are sent only to TEE (Secure) or Linux (Non-secure). <br><br>  Therefore, in GICv2, within the framework of Security Extensions support, it was thought up to make an interrupt grouping (GICD_IGROUP register): <br><br><ul><li>  Group 0 is Secure Interrupt, generates IRQ or FIQ, it can be configured; <br></li><li>  Group 1 - Non-Secure interrupt, generates only IRQ. </li></ul><br>  With this implementation, you can start Linux without any TEE - and then it will be launched in Secure mode by default, set up Secure VBAR for itself, all interrupts will go to it (we wrote about VBAR above).  And if Linux is running in guest mode, then TEE will preset all unnecessary interrupts for it to Group 1, and Linux will start in Non-Secure mode.  Linux will set up a Non-Secure VBAR for itself, and all its interrupts will go to it.  <i>Idyll and software compatibility</i> , the GIC driver in Linux and should not know, it works in Secure or guest mode. <br><br>  Well, it would seem, everything is good and clear.  If Secure Interrupt occurs, the vector will be loaded from Secure VBAR, otherwise Non-Secure VBAR. <br><br>  But no!  We remember that you cannot simply switch from Secure-mode to Non-Secure, for this we have Secure Monitor. <br><br>  Therefore: <br><br><ul><li>  if the interruption occurred in Non-Secure mode, and it is Non-Secure, executed as usual, via Non-Secure VBAR; <br></li><li>  if the interruption occurred in Secure mode, and it is Secure, also executed as usual, via Secure VBAR; <br></li><li>  but if the Secure interrupt occurred in Non-Secure mode, then the Secure Monitor is called in order to switch to the Secure mode first; <br></li><li>  about what happens in a pair of Non-Secure-&gt; Secure, you can guess. </li></ul><br>  The dry residue - Secure-interrupt can occur in Non-Secure mode, and then it will go through the Secure Monitor.  The mechanism of its work, described above, now has to figure out whether it is not to interrupt if it was sent, and accordingly handle everything.  And there everything in the code for OP-TEE is, look. <br><br>  A very useful table on this is here: <a href="http://infocenter.arm.com/help/topic/com.arm.doc.faqs/ka16352.html">http://infocenter.arm.com/help/topic/com.arm.doc.faqs/ka16352.html</a> <br><br>  But that's not all!  In fact, for this to work, there is still something to be done.  In the SCR register, which is already familiar to us, there are bits that configure which interrupts and exceptions to be sent to Secure Monitor, and which ones to process through VBAR. <br><br><div style="text-align:center;"> <a href=""><img width="600" hspace="5" src="https://habrastorage.org/webt/zk/tf/o0/zktfo0unj5z3qn3c3rne1unk-m8.jpeg"></a> </div><br>  In the picture - SCR from ARM Cortex-A5.  The EA, FIQ, and IRQ bits affect routing, respectively, External Abort, and FIQ, and IRQ. <br><br>  Unfortunately, there is no IRQ Group 0 and IRQ Group 1, and you can only send all IRQs to Secure Monitor, or leave it as it is, via VBAR.  As it is - we are not satisfied.  Therefore, all developers from filing ARM use this scheme: <br><br><ul><li>  in the GIC, Group 0 is configured for all Secure interrupts; <br></li><li>  for Group 0, FIQ generation is configured, not IRQ; <br></li><li>  in the SCR register, FIQ routing is selected in Secure Monitor, and IRQ is selected via VBAR. </li></ul><br>  All these settings guest OS will not be able to change.  As a result, Secure Interrupt always generates FIQ, and FIQ always enters Secure Monitor from Non-Secure mode. <br><br>  So, ARMv7 stuff is complicated and sometimes confusing. <br><br>  In the same way (via the SCR register), you can configure and catch External Abort from Non-Secure mode in Secure Monitor.  This can be useful, because  External Abort can occur, for example, when trying to access non-secure mode to secure peripherals. <br><br><h2>  Conclusion </h2><br>  Describe all the programming TrustZone in one review article did not work, and will be continued. <br><br>  This time we looked at the separation between Secure and Normal World, looked at Secure Monitor, and learned how to catch interrupts in a trusted environment. <br><br>  The next article will be about TEE: what does it do, how much is it in fact an independent OS, what are the need for trusts, and what is their life cycle. </div><p>Source: <a href="https://habr.com/ru/post/342924/">https://habr.com/ru/post/342924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342906/index.html">Perlin's noise</a></li>
<li><a href="../342914/index.html">Using buildSrc to implement additional logic in Gradle</a></li>
<li><a href="../342916/index.html">Biorobots of our time - we get rid of the routine with Telegram. Real case without fantasies</a></li>
<li><a href="../342918/index.html">Three, seven, joker - analysis of the solution of problems from the GridGain booklet at the Joker 2017 conference</a></li>
<li><a href="../342922/index.html">Stupid js. Make filters "beauty"</a></li>
<li><a href="../342928/index.html">Vivaldi 1.13 - everything is at hand</a></li>
<li><a href="../342930/index.html">Wireless Fiber Siklu</a></li>
<li><a href="../342932/index.html">HPE ProLiant for Microsoft Azure Stack: a piece of Azure cloud under your complete control</a></li>
<li><a href="../342934/index.html">Visualization of the neural network learning process using TensorFlowKit</a></li>
<li><a href="../342936/index.html">App for CarPrice Inspectors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>