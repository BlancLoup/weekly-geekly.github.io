<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Notes on the Python object system part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The third part of the notes about the python object system (the first and second parts). The article tells why c .__ call __ () is not the same as c (...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Notes on the Python object system part 3</h1><div class="post__text post__text-html js-mediator-article">  The third part of the notes about the python object system (the <a href="http://habrahabr.ru/blogs/python/114576/">first</a> and <a href="http://habrahabr.ru/blogs/python/114585/">second</a> parts).  The article tells why c .__ call __ () is not the same as c (), how to implement singleton using metaclasses, what name mangling is and how it works. <br><br><a name="habracut"></a><br><br><h4>  c .__ call__ vs c (), c .__ setattr__ vs setattr </h4><br>  It is easy to verify that x (arg1, arg2) is not equivalent to x .__ call __ (arg1, arg2) for new classes, although this is true for old classes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>C</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>pass</strong></font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> c <font color="#666666">=</font> C() <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> c <font color="#666666">.</font> __call__ <font color="#666666">=</font> <font color="#008000"><strong>lambda</strong></font> : <font color="#666666">42</font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> c() <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> <font color="#0000FF"><strong>TypeError</strong></font> : 'C' object is not callable <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> C <font color="#666666">.</font> __call__ <font color="#666666">=</font> <font color="#008000"><strong>lambda</strong></font> <font color="#008000">self</font> : <font color="#666666">42</font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> c() <br> <font color="#000000">42</font></code> <br> <br>  Actually correct: <br><br>  c () <font color="#666666">&lt;=&gt;</font> <font color="#008000">type</font> ¬© <font color="#666666">.</font>  __call __ (s) <br><br>  Absolutely the same situation with __setattr __ / setattr and many other magic (and special) methods and corresponding built-in functions that are defined for all objects, including for objects of type - classes. <br><br>  Why this was done can be seen on the example of setattr [1]. <br>  <font color="#008000">First</font> , make sure that <font color="#008000">setattr</font> (a, <font color="#BA2121">'x'</font> , <font color="#666666">1</font> ) <font color="#666666">&lt;==&gt;</font> <font color="#008000">type</font> (a) <font color="#666666">.</font>  __setattr __ (a, <font color="#BA2121">'x'</font> , <font color="#666666">1</font> ). <br><br>  a <font color="#666666">.</font>  x <font color="#666666">=</font> <font color="#666666">1</font> <font color="#666666">&lt;=&gt;</font> <font color="#008000">setattr</font> (a, <font color="#BA2121">'x'</font> , <font color="#666666">1</font> ) <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <font color="#008000"><strong>pass</strong></font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">=</font> A() <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> x <font color="#666666">=</font> <font color="#666666">1</font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <br> <font color="#000000">&lt;__main__.A object at 0x7fafa9b26f90&gt; <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">setattr</font> (a, <font color="#BA2121">'y'</font> , <font color="#666666">2</font> ) <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> __dict__ <br> <font color="#000000">{'y': 2, 'x': 1}</font></code> <br> <br>  Using the __setattr__ method, we set a new attribute that will go to __dict__ <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> __setattr__( <font color="#BA2121">'z'</font> , <font color="#666666">3</font> )</code> <br> <br>  everything seems to be correct: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> __dict__ <br> <font color="#000000">{'y': 2, 'x': 1, 'z': 3}</font></code> <br> <br>  But: <br><br>  Set a deliberately wrong method in a .__ setattr__: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> __setattr__ <font color="#666666">=</font> <font color="#008000"><strong>lambda</strong></font> <font color="#008000">self</font> : <font color="#666666">42</font></code> <br> <br>  The call that leads to the error: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> __setattr__( <font color="#BA2121">'z'</font> , <font color="#666666">4</font> ) <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> <font color="#0000FF"><strong>TypeError</strong></font> : &lt;lambda&gt;() takes exactly 1 argument (2 given)</code> <br> <br>  However, despite this, setattr works: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">setattr</font> (a, <font color="#BA2121">'foo'</font> , <font color="#BA2121">'bar'</font> ) <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> __dict__ <br> <font color="#000000">{'y': 2, 'x': 1, '__setattr__': &lt;function &lt;lambda&gt; at 0x7fafa9b3a140&gt;, 'z': 3, 'foo': 'bar'}</font></code> <br> <br>  But if you override the class method: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> __setattr__ <font color="#666666">=</font> <font color="#008000"><strong>lambda</strong></font> <font color="#008000">self</font> : <font color="#666666">42</font></code> <br> <br>  then setattr for the class instance will generate an error: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">setattr</font> (a, <font color="#BA2121">'baz'</font> , <font color="#BA2121">'quux'</font> ) <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> <font color="#0000FF"><strong>TypeError</strong></font> : &lt;lambda&gt;() takes exactly 1 argument (3 given)</code> <br> <br>  Why was this done? <br>  Let setattr (a, 'x', 1) be the same as a .__ setattr __ ('x', 1), then <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">__setattr__</font> ( <font color="#008000">self</font> , attr, value): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>print</strong></font> <font color="#BA2121">'for instances'</font> , attr, value <br> <font color="#000080"><strong>...</strong></font> <font color="#008000">object</font> <font color="#666666">.</font> __setattr__( <font color="#008000">self</font> , attr, value) <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">=</font> A()</code> <br> <br>  Set a new attribute for aax = 1 &lt;==&gt; a .__ setattr __ ('x', 1) <br>  Everything is normal: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> __setattr__( <font color="#BA2121">'x'</font> , <font color="#666666">1</font> ) <br> <font color="#000000">for instances x 1 <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> __dict__ <br> <font color="#000000">{'x': 1}</font></code> <br> <br>  Now let's try to set a new attribute for the class itself, it‚Äôs also an object: A.foo = 'bar' &lt;==&gt; A .__ setattr __ ('foo', 'bar') <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> __setattr__( <font color="#BA2121">'foo'</font> , <font color="#BA2121">'bar'</font> ) <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> <font color="#0000FF"><strong>TypeError</strong></font> : unbound method __setattr__() must be called with A instance as first argument (got str instance instead)</code> <br> <br>  Everything is logical, according to the attribute search algorithm in classes (types), first the attribute is searched in __dict__ class (type): <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> __dict__[ <font color="#BA2121">'__setattr__'</font> ] <br> <font color="#000000">&lt;function __setattr__ at 0x7f699d22fa28&gt;</font></code> <br> <br>  But the fact is that it is intended for instances of a class, and not for the class itself.  Therefore, calling A .__ setattr __ ('foo', 'bar') will be incorrect.  And that is why setattr () should do an explicit search in the class (type) of the object.  Actually, for the same reason, this was done for other magic methods __add__, __len__, __getattr__, etc. <br><br><h4>  Class, as callable type </h4><br>  The class (type) is the callable type, and its call is the object constructor. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>C</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>pass</strong></font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> () <br> <font color="#000000">&lt;__main__.C object at 0x1121e10&gt;</font></code> <br> <br>  Equivalent to: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">type</font> (C) <font color="#666666">.</font> __call__(C) <br> <font color="#000000">&lt;__main__.C object at 0x1121ed0&gt;</font></code> <br> <br>  Because  C is a normal class, then its metaclass is type, so the call type (C) .__ call __ (C) &lt;==&gt; type .__ call __ (C) will be used.  Inside type .__ call __ (C), a call to C .__ new __ (cls, ...) and C .__ init __ (self, ...) is already in progress. <br><br>  The important thing is that both __new__ and __init__ are searched for using the usual attribute search algorithm in the class.  And in the absence of them in C .__ dict__, methods from the parent class object: object .__ new__ and object .__ init__ will be called, while the __call__ method is a method of the class (type) of the object - type: type .__ call __ (C). <br><br><h4>  Singleton v.2 </h4><br>  Knowing this, we will create a metaclass implementation of a singleton. <br><br>  What do we need from singleton?  To call A () return the same object. <br><br>  A () &lt;=&gt; type (A) .__ call __ (A) <br><br>  So, we need to change the behavior of the __call__ method, which is defined in the metaclass.  We will do this, without forgetting that, in general, in __call__, any parameters can be transmitted. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>SingletonMeta</strong></font> ( <font color="#008000">type</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">__call__</font> (cls, <font color="#666666">*</font> args, <font color="#666666">**</font> kw): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>return</strong></font> <font color="#008000">super</font> (SingletonMeta, cls) <font color="#666666">.</font> __call__( <font color="#666666">*</font> args, <font color="#666666">**</font> kw) <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font></code> <br> <br>  The cap is ready. <br>  Let the single object be stored in the instance class attribute.  To do this, initialize in cls.instance in __init__. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>SingletonMeta</strong></font> ( <font color="#008000">type</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">__init__</font> (cls, <font color="#666666">*</font> args, <font color="#666666">**</font> kw): <br> <font color="#000080"><strong>...</strong></font> cls <font color="#666666">.</font> instance <font color="#666666">=</font> <font color="#008000">None</font> <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">__call__</font> (cls, <font color="#666666">*</font> args, <font color="#666666">**</font> kw): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>return</strong></font> <font color="#008000">super</font> (SingletonMeta, cls) <font color="#666666">.</font> __call__( <font color="#666666">*</font> args, <font color="#666666">**</font> kw) <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <br> <br> <br>     __call__: <br> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>SingletonMeta</strong></font> ( <font color="#008000">type</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">__init__</font> (cls, <font color="#666666">*</font> args, <font color="#666666">**</font> kw): <br> <font color="#000080"><strong>...</strong></font> cls <font color="#666666">.</font> instance <font color="#666666">=</font> <font color="#008000">None</font> <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">__call__</font> (cls, <font color="#666666">*</font> args, <font color="#666666">**</font> kw): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>if</strong></font> cls <font color="#666666">.</font> instance <font color="#AA22FF"><strong>is</strong></font> <font color="#008000">None</font> : <br> <font color="#000080"><strong>...</strong></font> cls <font color="#666666">.</font> instance <font color="#666666">=</font> <font color="#008000">super</font> (SingletonMeta, cls) <font color="#666666">.</font> __call__( <font color="#666666">*</font> args, <font color="#666666">**</font> kw) <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>return</strong></font> cls <font color="#666666">.</font> instance <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>C</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> __metaclass__ <font color="#666666">=</font> SingletonMeta <br> <font color="#000080"><strong>...</strong></font></code> <br> <br>  We check that everything works as it should. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> C() <font color="#AA22FF"><strong>is</strong></font> C() <br> <font color="#000000">True <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">=</font> C() <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> b <font color="#666666">=</font> C() <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> x <font color="#666666">=</font> <font color="#666666">42</font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> b <font color="#666666">.</font> x <br> <font color="#000000">42 <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font></code> <br> <br><h4>  Callable type as a metaclass </h4><br>  A metaclass can be not only an object of type type, but generally any callable type. <br><br>  It is enough just to create a function in which a class is created using the type metaclass. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">mymeta</font> (name, bases, attrs): <br> <font color="#000080"><strong>...</strong></font> attrs[ <font color="#BA2121">'foo'</font> ] <font color="#666666">=</font> <font color="#BA2121">'bar'</font> <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>return</strong></font> <font color="#008000">type</font> (name, bases, attrs) <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>D</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> __metaclass__ <font color="#666666">=</font> mymeta <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> D() <br> <font color="#000000">&lt;__main__.D object at 0x7fafa9abc090&gt; <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> d <font color="#666666">=</font> D() <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> d <font color="#666666">.</font> foo <br> <font color="#000000">'bar' <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> d <font color="#666666">.</font> __dict__ <br> <font color="#000000">{} <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> D <font color="#666666">.</font> __dict__ <br> <font color="#000000">&lt;dictproxy object at 0x7fafa9b297f8&gt; <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">dict</font> (D <font color="#666666">.</font> __dict__) <br> <font color="#000000">{'__module__': '__main__', '__metaclass__': &lt;function mymeta at 0x7fafa9b3a9b0&gt;, '__dict__': &lt;attribute '__dict__' of 'D' objects&gt;, 'foo': 'bar', '__weakref__': &lt;attribute '__weakref__' of 'D' objects&gt;, '__doc__': None}</font></code> <br> <br><h4>  Class definitions </h4><br>  The construction statement of a class definition is simply a construction.  Like any statement, it can appear anywhere in the program code. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>if</strong></font> <font color="#008000">True</font> : <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">foo</font> ( <font color="#008000">self</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>print</strong></font> <font color="#666666">42</font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <br> <font color="#000000">&lt;class '__main__.A'&gt; <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A() <font color="#666666">.</font> foo() <br> <font color="#000000">42 <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font></code> <br> <br>  In the 'class' construction, any defined ‚Äúinside‚Äù variables, functions, classes are accumulated in __dict__.  And in the definition you can use any other constructions - cycles, if'y :. <br><br>  Therefore, you can do this: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>if</strong></font> <font color="#666666">1</font> <font color="#666666">&gt;</font> <font color="#666666">2</font> : <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">foo</font> ( <font color="#008000">self</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>print</strong></font> <font color="#BA2121">'1&gt;2'</font> <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>else</strong></font> : <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">bar</font> ( <font color="#008000">self</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>print</strong></font> <font color="#BA2121">'else'</font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A() <br> <font color="#000000">&lt;__main__.A object at 0x7fafa9abc150&gt; <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A() <font color="#666666">.</font> foo() <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> <font color="#0000FF"><strong>AttributeError</strong></font> : 'A' object has no attribute 'foo' <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A() <font color="#666666">.</font> bar() <br> <font color="#000000">else</font></code> <br> <br>  or so <br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>if</strong></font> <font color="#666666">1</font> <font color="#666666">&gt;</font> <font color="#666666">2</font> : <br> <font color="#000080"><strong>...</strong></font> x <font color="#666666">=</font> <font color="#666666">1</font> <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">foo</font> ( <font color="#008000">self</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>print</strong></font> <font color="#BA2121">'if'</font> <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>else</strong></font> : <br> <font color="#000080"><strong>...</strong></font> y <font color="#666666">=</font> <font color="#666666">1</font> <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">bar</font> ( <font color="#008000">self</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>print</strong></font> <font color="#BA2121">'else'</font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> x <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> <font color="#0000FF"><strong>AttributeError</strong></font> : type object 'A' has no attribute 'x' <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> y <br> <font color="#000000">1 <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> foo <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> <font color="#0000FF"><strong>AttributeError</strong></font> : type object 'A' has no attribute 'foo' <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> bar <br> <font color="#000000">&lt;unbound method A.bar&gt; <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> bar() <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> <font color="#0000FF"><strong>TypeError</strong></font> : unbound method bar() must be called with A instance as first argument (got nothing instead) <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A() <font color="#666666">.</font> bar() <br> <font color="#000000">else <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font></code> <br> <br>  You can put one definition into another. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>B</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>pass</strong></font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A() <br> <font color="#000000">&lt;__main__.A object at 0x7fafa9abc2d0&gt; <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> __dict__ <br> <font color="#000000">&lt;dictproxy object at 0x7fafa9b340f8&gt; <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">dict</font> (A <font color="#666666">.</font> __dict__) <br> <font color="#000000">{'__dict__': &lt;attribute '__dict__' of 'A' objects&gt;, '__module__': '__main__', 'B': &lt;class '__main__.B'&gt;, '__weakref__': &lt;attribute '__weakref__' of 'A' objects&gt;, '__doc__': None} <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> B() <br> <font color="#000000">&lt;__main__.B object at 0x7fafa9abc310&gt;</font> <br></code> <br><br>  Or dynamically create class methods: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> FIELDS <font color="#666666">=</font> [ <font color="#BA2121">'a'</font> , <font color="#BA2121">'b'</font> , <font color="#BA2121">'c'</font> ] <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>for</strong></font> f <font color="#AA22FF"><strong>in</strong></font> FIELDS: <br> <font color="#000080"><strong>...</strong></font> <font color="#008000">locals</font> ()[f] <font color="#666666">=</font> <font color="#008000"><strong>lambda</strong></font> <font color="#008000">self</font> : <font color="#666666">42</font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">=</font> A() <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> a() <br> <font color="#000000">42 <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> b() <br> <font color="#000000">42 <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> c() <br> <font color="#000000">42 <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> a <font color="#666666">.</font> d() <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> <font color="#0000FF"><strong>AttributeError</strong></font> : 'A' object has no attribute 'd' <br> <font color="#000000">&gt;&gt;&gt;</font></code> <br> <br>  Although of course this is certainly not recommended to do in normal practice, and it is better to use more idiomatic means. <br><br><h4>  Name mangling </h4><br>  And about class definitions.  About name mangling. <br><br>  Any attribute inside a classname class definition of the form ".__ {attr}" (attr has no more than one _ at the end) is replaced by "_ {classname} __ {attr}".  Thus, inside classes you can have ‚Äúhidden‚Äù private attributes that are not ‚Äúvisible‚Äù to the heirs and instances of the class. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>A</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> __private_foo <font color="#666666">=1</font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> __private_foo <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> <font color="#0000FF"><strong>AttributeError</strong></font> : type object 'A' has no attribute '__private_foo'</code> <br> <br>  You can see the variable like this: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> A <font color="#666666">.</font> _A__private_foo <br> <font color="#000000">1</font></code> <br> <br>  Well, it is stored in __dict__ class: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000">dict</font> (A <font color="#666666">.</font> __dict__) <br> <font color="#000000">{'__dict__': &lt;attribute '__dict__' of 'A' objects&gt;, '_A__private_foo': 1, '__module__': '__main__', '__weakref__': &lt;attribute '__weakref__' of 'A' objects&gt;, '__doc__': None} <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font></code> <br> <br>  Access heirs do not have: <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>B</strong></font> (A): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">foo</font> ( <font color="#008000">self</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>print</strong></font> <font color="#008000">self</font> <font color="#666666">.</font> __private_foo <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> B() <font color="#666666">.</font> foo() <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">3</font> , in foo <br> <font color="#0000FF"><strong>AttributeError</strong></font> : 'B' object has no attribute '_B__private_foo'</code> <br> <br>  In principle, to provide access external access to the attributes of the type __ {attr} inside the class definition, i.e.  bypass name_mangling, you can use __dict__. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>C</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">__init__</font> ( <font color="#008000">self</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000">self</font> <font color="#666666">.</font> __dict__[ <font color="#BA2121">'__value'</font> ] <font color="#666666">=</font> <font color="#666666">1</font> <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> C() <font color="#666666">.</font> __value <br> <font color="#000000">1 <br></font> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font></code> <br> <br>  However, such things are highly discouraged due to the fact that access to such attributes will not be possible within the definition of any <b>other</b> class due to the substitution of ".__ {attr}" for "._ {classname} __ {attr}" regardless which object or class they belong to, i.e. <br><br> <code><font color="#000080"><strong>&gt;&gt;&gt;</strong></font> <font color="#008000"><strong>class</strong></font> <font color="#0000FF"><strong>D</strong></font> ( <font color="#008000">object</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000"><strong>def</strong></font> <font color="#0000FF">__init__</font> ( <font color="#008000">self</font> ): <br> <font color="#000080"><strong>...</strong></font> <font color="#008000">self</font> <font color="#666666">.</font> c <font color="#666666">=</font> C() <font color="#666666">.</font> __value <br> <font color="#000080"><strong>...</strong></font> <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> D() <br> <font color="#0040D0">Traceback (most recent call last): <br></font> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">1</font> , in &lt;module&gt; <br> File <font color="#008000">"&lt;stdin&gt;"</font> , line <font color="#666666">3</font> , in __init__ <br> <font color="#0000FF"><strong>AttributeError</strong></font> : 'C' object has no attribute '_D__value' <br> <font color="#000080"><strong>&gt;&gt;&gt;</strong></font> C() <font color="#666666">.</font> __value <br> <font color="#000000">1 <br> &gt;&gt;&gt;</font></code> <br> <br>  Although C () .__ value will work fine outside the class definition.  To get around also have to use __dict __ ['__ value']. <br><br><h4>  Links </h4><ul><li>  <a href="http://www.python.org/download/releases/2.2.3/descrintro/">Unifying types and classes in Python</a> is the main document explaining what, how and why in new classes. </li><li>  <a href="http://www.python.org/dev/peps/pep-0252/">Making Types Look More Like Classes</a> - PEP 252, describing the difference between the old classes and the new ones. </li><li>  <a href="http://docs.python.org/library/functions.html">Built-in functions</a> - a detailed description of the work of all built-in functions. </li><li>  <a href="http://docs.python.org/reference/datamodel.html">Data model</a> - a detailed description of the python data model. </li><li>  <a href="http://www.cafepy.com/article/python_types_and_objects/python_types_and_objects.html">Python types and objects</a> - an explanation of the python object model on simple examples with pictures. </li></ul><h4>  Notes </h4><br>  [1] The official documentation gives <a href="http://docs.python.org/reference/datamodel.html">an example of</a> __len __ / len and __hash __ / hash. </div><p>Source: <a href="https://habr.com/ru/post/114587/">https://habr.com/ru/post/114587/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114581/index.html">STOR.E ART4: with USB 3.0 and beyond</a></li>
<li><a href="../114582/index.html">Desire HD, Desire Z, Desire and Incredible S will get Gingerbread in the second quarter</a></li>
<li><a href="../114583/index.html">Microsoft has allowed employees to make money on applications for Windows Phone 7</a></li>
<li><a href="../114585/index.html">Notes on the Python object system part 2</a></li>
<li><a href="../114586/index.html">Meet AIR and Flash Player Incubator (including Molehill 3D APIs)</a></li>
<li><a href="../114588/index.html">History of C language</a></li>
<li><a href="../114589/index.html">Canny Boundary Detector</a></li>
<li><a href="../114590/index.html">Is DWG format or trademark?</a></li>
<li><a href="../114592/index.html">The idea of ‚Äã‚Äãa new type of legal content store</a></li>
<li><a href="../114593/index.html">[Translation] 7 deadly sins in software development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>