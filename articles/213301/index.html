<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cross-platform server with non-blocking sockets. Part 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article continues my previous ones: 
 The easiest cross-platform server with ssl support 
 Cross-platform https server with non-blocking sockets ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cross-platform server with non-blocking sockets. Part 4</h1><div class="post__text post__text-html js-mediator-article">  This article continues my previous ones: <br>  <a href="http://habrahabr.ru/post/211474/">The easiest cross-platform server with ssl support</a> <br>  <a href="http://habrahabr.ru/post/211661/">Cross-platform https server with non-blocking sockets</a> <br>  <a href="http://habrahabr.ru/post/211853/">Cross-platform https server with non-blocking sockets.</a>  <a href="http://habrahabr.ru/post/211853/">Part 2</a> <br>  <a href="http://habrahabr.ru/post/212101/">Cross-platform https server with non-blocking sockets.</a>  <a href="http://habrahabr.ru/post/212101/">Part 3</a> <br><br>  In my articles, I gradually describe the process of creating a single-threaded cross-platform server on non-blocking sockets. <br>  In all previous articles, the server received and sent messages only via the ssl protocol.  In this article I will describe the addition to the server of support for the usual unencrypted tcp protocol and teach the server to send a graphic file to the browser. <br>  But first, a little walk through the comments on previous articles. <br><a name="habracut"></a><br><br>  1. I listened to tips to get rid of the printf function in favor of std :: cout. <br>  2. Smart people have proven to me that std :: memcpy and std :: copy are the same for the compiler. <br>  Memcpy is more convenient for me, so I will continue to use it. <br>  3. <a href="https://github.com/3s3s/simple_server/">I transferred all early releases and will transfer future ones to GitHub</a> , although in my opinion the client for Windows is terrible. <br>  4. Who believes the lines <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> on = <span class="hljs-number"><span class="hljs-number">1</span></span>; setsockopt(listen_sd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(on) );</code> </pre> <br>  will help to avoid the ‚ÄúAddress already in use‚Äù error in case of emergency restart of the server - they are cruelly mistaken.  Will not help. <br>  5. For those who believe that different classes always need to be spread across different files, I'll add some oil: I want to transfer the CClient class to the private section of the CServer class! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It was: <br><pre> <code class="cpp hljs">CClient { *** }; CServer { *** };</code> </pre><br>  It became: <br><pre> <code class="cpp hljs">CServer { CClient { *** }; *** };</code> </pre><br><br>  Now, if the server becomes a library, no one should have thought about using the CClient class: this is a utility class, designed exclusively for interacting with the CServer class. <br><br>  6. And in my opinion, the function main () is an atavism, inherited by programmers from SI.  In C ++, it is superfluous.  But compilers do not yet know this unfortunately. <br>  But I decided to ‚Äúpunish‚Äù this unnecessary function, taking away from her the ability to do something - changed the serv.cpp file as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"server.h"</span></span></span><span class="hljs-meta"> const server::CServer s(8085, 1111); int main() {return 0;}</span></span></code> </pre><br><br>  Now the main thing ... <br><br><h4>  Adding non-encrypted tcp connections to the server </h4><br>  Unencrypted and encrypted connections in servers are usually accepted on different ports, so the first thing to do is to change the server constructor and add variables for another listening socket. <br><br>  Instead <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">epoll_event</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_ListenEvent</span></span></span><span class="hljs-class">;</span></span></code> </pre><br><br>  write in server class <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">epoll_event</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_ListenEventTCP</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_ListenEventSSL</span></span></span><span class="hljs-class">;</span></span></code> </pre><br><br>  In the server constructor, we add port numbers and code for Linux, which will not allow the server to crash if there is an error in TCP operations: <br><pre> <code class="cpp hljs"> CServer(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nPortTCP, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nPortSSL) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> WIN32 struct sigaction sa; memset(&amp;sa, 0, sizeof(sa)); sa.sa_handler = SIG_IGN; sigaction(SIGPIPE, &amp;sa, NULL); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> WSADATA wsaData; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( WSAStartup( MAKEWORD( 2, 2 ), &amp;wsaData ) != 0 ) { cout &lt;&lt; </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Could not to find usable WinSock in WSAStartup\n"</span></span></span><span class="hljs-meta">; return; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  Let's write separate functions to initiate listening sockets and to add a new client: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitListenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nPort, struct epoll_event &amp;eventListen)</span></span></span><span class="hljs-function"> </span></span>{ SOCKET listen_sd = socket (AF_INET, SOCK_STREAM, <span class="hljs-number"><span class="hljs-number">0</span></span>); SET_NONBLOCK(listen_sd); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> on = <span class="hljs-number"><span class="hljs-number">1</span></span>; setsockopt(listen_sd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(on) ); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sa_serv</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span> (&amp;sa_serv, <span class="hljs-string"><span class="hljs-string">'\0'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sa_serv)); sa_serv.sin_family = AF_INET; sa_serv.sin_addr.s_addr = INADDR_ANY; sa_serv.sin_port = htons (nPort); <span class="hljs-comment"><span class="hljs-comment">/* Server Port number */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err = ::bind(listen_sd, (struct sockaddr*) &amp;sa_serv, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (sa_serv)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"bind error = "</span></span> &lt;&lt; errno &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Receive a TCP connection. */</span></span> err = listen (listen_sd, SOMAXCONN); eventListen.data.fd = listen_sd; eventListen.events = EPOLLIN | EPOLLET; epoll_ctl (m_epoll, EPOLL_CTL_ADD, listen_sd, &amp;eventListen); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SOCKET hSocketIn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bIsSSL)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"AcceptClient"</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sa_cli</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> client_len = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sa_cli); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> WIN32 const SOCKET sd = accept (hSocketIn, (struct sockaddr*) &amp;sa_cli, (int *)&amp;client_len); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> const SOCKET sd = accept (hSocketIn, (struct sockaddr*) &amp;sa_cli, (socklen_t *)&amp;client_len); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sd != INVALID_SOCKET) { cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "Accepted\n"; //      m_mapClients[sd] = shared_ptr&lt;CClient&gt;(new CClient(sd, bIsSSL)); auto it = m_mapClients.find(sd); if (it == m_mapClients.end()) return; //    epoll struct epoll_event ev = it-&gt;second-&gt;GetEvent(); epoll_ctl (m_epoll, EPOLL_CTL_ADD, it-&gt;first, &amp;ev); } }</span></span></span></span></code> </pre><br><br>  Now, in the client, we will add the m_bIsSSL variable, which we will initiate in the constructor, and then we will change the callback functions so that they can work with TCP connections: <br>  Instead <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> RETCODES </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_pSSLContext) <span class="hljs-comment"><span class="hljs-comment">//     SSL return RET_ERROR;</span></span></code> </pre><br>  The time will be: <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> RETCODES </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"AcceptSSL\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_bIsSSL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_READY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_pSSLContext) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_ERROR;</code> </pre><br><br>  As you can see, there is no place to be easier: the TCP accept function does not require any additional gestures in order to begin receiving and sending data. <br>  No TCP certificates are needed, so the beginning of the corresponding function will now look like this: <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> RETCODES </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSertificate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"GetSertificate\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_bIsSSL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_READY;</code> </pre><br><br>  In a function that reads data from the ContinueRead () client, you need instead <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> szBuffer[<span class="hljs-number"><span class="hljs-number">4096</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err = SSL_read (m_pSSL, szBuffer, <span class="hljs-number"><span class="hljs-number">4096</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre><br><br>  write code: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> szBuffer[<span class="hljs-number"><span class="hljs-number">4096</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//      int err; if (m_bIsSSL) err = SSL_read (m_pSSL, szBuffer, 4096); else { errno = 0; err = recv(m_hSocket, szBuffer, 4096, 0); } m_nLastSocketError = GetLastError(err);</span></span></code> </pre><br><br>  In the same function, you now need to add error handling code for TCP connections.  As with SSL, the error will be <br>  if the message receive function returns a negative or zero value.  But since we have non-blocking sockets, <br>  then the WSAEWOULDBLOCK error on Windows and EWOULDBLOCK on Linux means that everything is fine, you just have to wait. <br>  Add these macros: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _WIN32 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> S_OK 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WSAEWOULDBLOCK EWOULDBLOCK #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WSAGetLastError() errno #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  And such code in the ContinueRead function: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_bIsSSL) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err == <span class="hljs-number"><span class="hljs-number">0</span></span>) || ((m_nLastSocketError != WSAEWOULDBLOCK) &amp;&amp; (m_nLastSocketError != S_OK))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_ERROR; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err == <span class="hljs-number"><span class="hljs-number">0</span></span>) || ((m_nLastSocketError != SSL_ERROR_WANT_READ) &amp;&amp; (m_nLastSocketError != SSL_ERROR_WANT_WRITE))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_ERROR; }</code> </pre><br><br>  and we define the CClient :: GetLastError function as <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLastError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> err)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_bIsSSL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SSL_get_error(m_pSSL, err); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WSAGetLastError(); }</code> </pre><br><br>  In a completely similar way, we will correct the function of sending messages to ContinueWrite and our single-threaded cross-platform server is ready to accept tcp and ssl connections from clients to give them request headers. <br>  Let's also teach our server today to give files to clients. <br>  In principle, there is nothing special about this, except that in Linux there is a faster way to send a file than on other systems: the sendfile function. <br>  To make the code uniform, I suggest that you do the same with sendfile as you did with epoll: write an emulator of this function for all systems except Linux. <br><br><h5>  Emulate sendfile function </h5><br>  1. Create empty files ‚Äúsendfile.h‚Äù, ‚Äúsendfile.cpp‚Äù and add them to the Visual Studio project. <br>  2. In sendfile.h we place such code: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __linux__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _SENDFILE_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SENDFILE_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/types.h&gt; unsigned long long sendfile(int out_fd, int in_fd, off_t *offset, size_t count); #endif #endif</span></span></span></span></code> </pre><br>  3. In sendfile.cpp we place this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;io.h&gt; #include &lt;Winsock2.h&gt; #pragma comment(lib, "ws2_32.lib") #endif unsigned long long sendfile(int out_fd, int in_fd, off_t *offset, size_t count) { static unsigned char buffer[4096]; if (count &gt; 4096) count = 4096; off_t lPos = _lseek(in_fd, *offset, SEEK_SET); if (lPos == -1) return -1; const int nReaded = _read(in_fd, buffer, count); if (nReaded == 0) return nReaded; if (nReaded == -1) return -1; *offset += nReaded; errno = 0; const int nSended = send(out_fd, (const char *)buffer, nReaded, 0); if (nSended != SOCKET_ERROR) return nSended; if (WSAGetLastError() != WSAEWOULDBLOCK) return -1; return 0; } #endif</span></span></span></span></code> </pre><br><br>  4. Add the necessary inclusions to the server class so that standard functions are used in Linux, and ours are used in other systems. <br>  In addition, we will add an inclusion for working with files and define the path to the file that we will send to the client: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __linux__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/epoll.h&gt; #include &lt;sys/sendfile.h&gt; #define O_BINARY 0 #else #include "epoll.h" #include "sendfile.h" #endif #include &lt;sys/stat.h&gt; #define SEND_FILE "./wwwroot/festooningloops.jpg"</span></span></span></span></code> </pre><br><br>  With emulation sendfile finished. <br><br><h5>  Sending a file </h5><br>  5. Add a file descriptor and current position to the client class. <br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CClient</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_nSendFile; <span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> m_nFilePos; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> m_nFileSize;</code> </pre><br><br>  6. Change the InitRead () function <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> RETCODES </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_bIsSSL &amp;&amp; (!m_pSSLContext || !m_pSSL)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_ERROR; m_nSendFile = _open(SEND_FILE, O_RDONLY|O_BINARY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_nSendFile == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_ERROR; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stat</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stat_buf</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fstat(m_nSendFile, &amp;stat_buf) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_ERROR; m_nFileSize = stat_buf.st_size; <span class="hljs-comment"><span class="hljs-comment">//    http  std::ostringstream strStream; strStream &lt;&lt; "HTTP/1.1 200 OK\r\n" &lt;&lt; "Content-Type: image/jpeg\r\n" &lt;&lt; "Content-Length: " &lt;&lt; m_nFileSize &lt;&lt; "\r\n" &lt;&lt; "\r\n"; //  m_vSendBuffer.resize(strStream.str().length()); memcpy(&amp;m_vSendBuffer[0], strStream.str().c_str(), strStream.str().length()); return RET_READY; }</span></span></code> </pre><br><br>  7. Add functions to send a file using the tcp and ssl protocols: <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> RETCODES </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendFileSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nFile, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">off_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *offset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nFile == <span class="hljs-number"><span class="hljs-number">-1</span></span> || m_vSendBuffer.size()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ContinueWrite(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_bIsSSL || !m_pSSLContext || !m_pSSL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_ERROR; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">4096</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> lPos = _lseek(nFile, *offset, SEEK_SET); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lPos == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_ERROR; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nReaded = _read(nFile, buffer, <span class="hljs-number"><span class="hljs-number">4096</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nReaded == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_ERROR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nReaded &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { *offset += nReaded; m_vSendBuffer.resize(nReaded); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;m_vSendBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>], buffer, nReaded); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_WAIT; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> RETCODES </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendFileTCP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nFile, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">off_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *offset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nFile == <span class="hljs-number"><span class="hljs-number">-1</span></span> || m_vSendBuffer.size()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ContinueWrite(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nSended = sendfile(m_hSocket, nFile, offset, <span class="hljs-number"><span class="hljs-number">4096</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nSended == (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_ERROR; m_nLastSocketError = WSAEWOULDBLOCK; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RET_WAIT; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsAllWrited</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_nSendFile == <span class="hljs-number"><span class="hljs-number">-1</span></span> &amp;&amp; m_vSendBuffer.size()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_nFileSize == (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)m_nFilePos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br><br>  8. Change the logic of the client‚Äôs callback function: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> S_WRITING: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_bIsSSL &amp;&amp; (SendFileTCP(m_nSendFile, &amp;m_nFilePos) == RET_ERROR)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_bIsSSL &amp;&amp; (SendFileSSL(m_nSendFile, &amp;m_nFilePos) == RET_ERROR)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsAllWrited()) SetState(S_ALL_WRITED, pCurrentEvent); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><br>  Our server is ready! <br>  Now he can send not only a buffer, but also files.  Maybe someone noticed that the variable ‚Äúm_nLastSocketError‚Äù was added to the client class ... <br>  The fact is that in previous versions of the server, we always waited for any events from the sockets, now the m_nLastSocketError variable will help us modify the CClient :: SetState function so that the epoll function <br>  From sockets I waited only for those events that are needed at the moment. <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> STATES state, struct epoll_event *pCurrentEvent)</span></span></span><span class="hljs-function"> </span></span>{ m_stateCurrent = state; pCurrentEvent-&gt;events = EPOLLERR | EPOLLHUP; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_bIsSSL) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_nLastSocketError == SSL_ERROR_WANT_READ) pCurrentEvent-&gt;events |= EPOLLIN; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_nLastSocketError == SSL_ERROR_WANT_WRITE) pCurrentEvent-&gt;events |= EPOLLOUT; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_nLastSocketError == WSAEWOULDBLOCK) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_stateCurrent == S_READING) pCurrentEvent-&gt;events |= EPOLLIN; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_stateCurrent == S_WRITING) pCurrentEvent-&gt;events |= EPOLLOUT; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } pCurrentEvent-&gt;events |= EPOLLIN | EPOLLOUT; }</code> </pre><br><br>  All is ready! <br>  <u><i>To compile with Visual Studio 2012</i></u> , open the ssl_test.sln file and compile. <br>  <u><i>The</i></u> epoll.h, epoll.cpp, sendfile.h and sendfile.cpp files are <b>not needed</b> <u><i>for compiling Linux</i></u> , so that everything works, just copy the files to one directory: serv.cpp, server.h, ca-cert.pem, create a wwwroot directory and copy the ./wwwroot/festooningloops.jpg file there, then type in the command line: "g ++ -std = c ++ 0x -L / usr / lib -lssl -lcrypto serv.cpp" Someone who wants to see the compiler warnings, add the -Wall option to it. <br><br>  You can check the server on the local computer by starting the server and typing in the address bar of the browser <br> <code><a href="https://localhost/"></a> localhost:1111</code> <br>  or <br> <code><a href="http://localhost/"></a> localhost:8085</code> </div><p>Source: <a href="https://habr.com/ru/post/213301/">https://habr.com/ru/post/213301/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213291/index.html">Generate and scan QR / BAR codes</a></li>
<li><a href="../213293/index.html">ADCSpb # 11. Meeting iOS developers in St. Petersburg</a></li>
<li><a href="../213295/index.html">Custom events in action</a></li>
<li><a href="../213297/index.html">Kegbot: Beer Bottling System for Arduino and Android</a></li>
<li><a href="../213299/index.html">Promotional website for a mobile application. Part 2</a></li>
<li><a href="../213303/index.html">State expenditures: public expenditure monitoring, API and competition for developers</a></li>
<li><a href="../213305/index.html">Samsung Galaxy Win Duos: what is a middle class smartphone from a market leader?</a></li>
<li><a href="../213307/index.html">Evaluation of electricity theft detection sensors in intelligent networks</a></li>
<li><a href="../213309/index.html">Hooks are easy (part 2)</a></li>
<li><a href="../213311/index.html">‚ÄúThe worse the better‚Äù, or the Startup in 6 hours</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>