<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Badoo PHP Code Formatter. Now in open source!</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few years ago, Badoo began to grow significantly in the number of employees, from 20 to 100 and more. This required a major overhaul of many develop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Badoo PHP Code Formatter. Now in open source!</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/fd3/b38/ee5/fd3b38ee53304292bc85c3a47d9221cc.jpg" align="right">  A few years ago, Badoo began to grow significantly in the number of employees, from 20 to 100 and more.  This required a major overhaul of many development processes.  One of the problems we are facing is how to make all developers follow a single coding standard so that all our code looks uniform and is easily maintained? <br><br>  To solve this problem, we decided to implement a code formatting tool that could do the following: <br><br><ol><li>  display messages about non-compliance with the formatting standard in the form of a list, without touching the file itself; </li><li>  automatically fix all formatting problems found; </li><li>  to be able to format only part of the file (we do not need to reformat the repository as a whole at once, so as not to lose history). </li></ol><br>  We considered two projects that could be taken as the basis for writing such a tool - PHP Beautifier and PHP Code Sniffer.  The first was able to format the code, but could not print the diagnostics, and the second - on the contrary, knew how to print the diagnostics, but could not format the files.  Unfortunately, both of these projects, according to our estimates, were not too suitable to add the missing functionality to them, so a new utility, phpcf (PHP Code Formatter), was written.  For two years now, it has been working as a git pre-receive hook, configured to reject (!) Changes that are not designed according to our coding standard. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Finally it is time to open the source code of our utility to the general public: <a href="https://github.com/badoo/phpcf/">github.com/badoo/phpcf</a> <br><a name="habracut"></a><br><h3>  Functionality </h3><br>  The formatter was created in order to basically change the whitespace: line breaks, indents, spaces around operators, etc.  Thus, phpcf does not replace other similar utilities, such as the aforementioned PHP Code Sniffer and <a href="http://cs.sensiolabs.org/">PHP Coding Standards Fixer from Fabien Potenzer</a> .  It complements them by doing ‚Äúdirty work‚Äù in properly arranging spaces and line breaks in the file.  It is important to note that our utility takes into account the initial formatting in the file and changes only those spaces that do not meet the selected standard (unlike some other solutions that first remove all whitespace tokens, and then begin formatting). <br><br>  The utility is extensible and supports arbitrary sets of styles.  You can quite easily define your formatting style, which will implement a different standard different from ours (the coding standard in our company is very close to PSR). <br><br>  Example of use (the command ‚Äúphpcf apply &lt;filename&gt;‚Äù formats the specified file, and ‚Äúphpcf check &lt;filename&gt;‚Äù checks the formatting and returns a non-zero exit code if there are unformatted fragments): <br><br><blockquote><pre><code class="php hljs">$ cat minifier.php <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $tokens=token_get_all(file_get_contents($argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]));$contents=<span class="hljs-string"><span class="hljs-string">''</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $tok){<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($tok[<span class="hljs-number"><span class="hljs-number">0</span></span>]===T_WHITESPACE||$tok[<span class="hljs-number"><span class="hljs-number">0</span></span>]===T_COMMENT)<span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($tok[<span class="hljs-number"><span class="hljs-number">0</span></span>]===T_AS||$tok[<span class="hljs-number"><span class="hljs-number">0</span></span>]===T_ELSE)$contents.=<span class="hljs-string"><span class="hljs-string">' '</span></span>.$tok[<span class="hljs-number"><span class="hljs-number">1</span></span>].<span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> $contents.=is_array($tok)?$tok[<span class="hljs-number"><span class="hljs-number">1</span></span>]:$tok;}<span class="hljs-keyword"><span class="hljs-keyword">echo</span></span>$contents.<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $ phpcf apply minifier.php minifier.php formatted successfully $ cat minifier.php <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $tokens = token_get_all(file_get_contents($argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])); $contents = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $tok) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($tok[<span class="hljs-number"><span class="hljs-number">0</span></span>] === T_WHITESPACE || $tok[<span class="hljs-number"><span class="hljs-number">0</span></span>] === T_COMMENT) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($tok[<span class="hljs-number"><span class="hljs-number">0</span></span>] === T_AS || $tok[<span class="hljs-number"><span class="hljs-number">0</span></span>] === T_ELSE) $contents .= <span class="hljs-string"><span class="hljs-string">' '</span></span> . $tok[<span class="hljs-number"><span class="hljs-number">1</span></span>] . <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> $contents .= is_array($tok) ? $tok[<span class="hljs-number"><span class="hljs-number">1</span></span>] : $tok; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $contents . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $ phpcf check minifier.php; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $? minifier.php does not need formatting <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br></blockquote><br>  In addition to formatting the entire file, our utility can also format part of the file.  To do this, specify the ranges of line numbers separated by a colon: <br><br><blockquote><pre> <code class="php hljs">$ cat zebra.php <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"White "</span></span>.<span class="hljs-string"><span class="hljs-string">"strip"</span></span>.PHP_EOL; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Black "</span></span>.<span class="hljs-string"><span class="hljs-string">"strip"</span></span>.PHP_EOL; <span class="hljs-comment"><span class="hljs-comment">// not formatted echo "Arse".PHP_EOL; $ phpcf apply zebra.php:1-2,4 zebra.php formatted successfully $ cat zebra.php </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?php</span></span></span><span class="hljs-comment"> echo "White " . "strip" . PHP_EOL; echo "Black "."strip".PHP_EOL; // not formatted echo "Arse" . PHP_EOL; $ phpcf check zebra.php zebra.php issues: Expected one space before binary operators (= &lt; &gt; * . etc) on line 3 column 14 Expected one space after binary operators (= &lt; &gt; * . etc) on line 3 column 15 ... $ echo $? 1</span></span></code> </pre><br></blockquote><br>  Even though the utility is written in PHP, most files are formatted in a split second.  But we have a large repository and a lot of code, so we wrote an extension that, when connected, increases the productivity of work a hundred times: our entire repository of 2 million lines is formatted in 8 seconds on a notebook Core i7.  To use the extension, you need to collect it from the ‚Äúext /‚Äù directory, set it, enable ‚Äúenable_dl = On‚Äù in php.ini, or set it as an extension. <br><br>  I would like to emphasize once again that phpcf first of all changes whitespace and can only do simple transformations on the code: for example, replace the short opening tag with a long one or remove the last closing tag from the file.  In addition, phpcf can automatically correct the Cyrillic alphabet in the names of functions in English characters.  Also do not touch the expression, manually aligned using spaces.  This is due to the architecture ‚Äî the formatter works as a state machine with the rules that the user sets, and not as a set of hard-coded replacements (the formatter comes with a default config that conforms to our formatting rules).  Therefore, if you want to automatically replace ‚Äúvar‚Äù with ‚Äúpublic‚Äù or similar things, we recommend paying attention to the PHP-CS-Fixer - it pays little attention to whitespace characters (as opposed to phpcf), but it can rewrite tokens. <br><br><h3>  PHP version support </h3><br>  Initially, our formatter worked on PHP 5.3 and only supported it.  At the moment, we fully support the PHP 5.4 and 5.5 syntax, and the formatter requires PHP version 5.4 or higher.  If you want to format the code intended for earlier versions of PHP, then you can do it, but phpcf itself should be run using PHP 5.4+. <br><br>  I would like to separately note that phpcf does not know how to format "unfinished" files containing, for example, unbalanced brackets: in this case an error message will be displayed and the file will not be formatted.  At the same time, in some cases you can format the ‚Äúinvalid‚Äù code from the point of view of the PHP interpreter, because the formatter by itself does not check the syntax of the file. <br><br>  As for the support of the next versions of PHP, the phpcf architecture is such that when adding or meeting ‚Äúunfamiliar‚Äù keywords and tokens in the file, they will simply be ignored and left as is.  Thus, phpcf now supports future versions of PHP, but with the proviso that formatting rules will not be applied to unknown tokens. <br><br><h3>  Git integration support </h3><br>  When you download our utility, you will most likely notice that there are not only ‚Äúcheck‚Äù, ‚Äúpreview‚Äù and ‚Äúapply‚Äù actions, but also the same actions with the suffix ‚Äú-git‚Äù.  In Badoo, we use Git as the version control system, and by default only modified strings are checked and formatted.  In order not to force the developers to remember the numbers of the modified lines, we made ‚Äú* -git‚Äù commands that work as follows: <br><br><ol><li>  See ‚Äúnon-committed‚Äù and added changes to the index. </li><li>  View changes that are made in the current branch, but are not in origin / master and origin / &lt;current-branch&gt; (corresponding branches are updated with git push / git pull), or, in other words, have not yet been sent to the repository. </li><li>  Apply formatting only to the lines found in (1) and (2). </li></ol><br>  We use the development in feature branches, and at the same time in the master branch we have the production-code, so the ‚Äú-git‚Äù commands are sharpened under this flow and determine the modified lines by the above algorithm. <br><br>  Usage example: <br><blockquote><pre> <code class="bash hljs">(master) $ git checkout -b some_feature (some_feature) $ vim test.php <span class="hljs-comment"><span class="hljs-comment">#  test.php (some_feature) $ phpcf apply-git #    ,     test.php formatted successfully</span></span></code> </pre><br></blockquote><br><br><h3>  Using the phpcf classes directly </h3><br>  In addition to using phpcf as a utility, it is also possible to use the phpcf classes directly, including with connecting extensions.  This feature can be useful for different tasks, for example, to create a web service for formatting PHP files.  For our needs, we use it in the code review process: when viewing changes made in a branch, we cannot skip the changes that are exclusively related to formatting (for this, two versions of the file, the old and the new, are fully formatted, after which the diff between them is considered ). <br><br>  An example of using phpcf classes directly: <br><blockquote><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//     require_once __PHPCF_SRC . '/src/init.php'; //    $Options = new \Phpcf\Options(); //   (    ) $Options-&gt;setTabSequence(' '); //  3-4   Tab $Options-&gt;setMaxLineLength(130); // 120   $Options-&gt;setCustomStyle('style'); //       $Options-&gt;toggleCyrillicFilter(true|false); //     $Options-&gt;usePure(true); //     extension $Formatter = new \Phpcf\Formatter($Options); //   $Formatter-&gt;formatFile('file.php'); //   $Formatter-&gt;formatFile('file.php:1-40,65'); //   //   $Formatter-&gt;format('</span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?php</span></span></span><span class="hljs-comment"> phpinfo()'); //     $Formatter-&gt;format($code, [1, 2, 10]); //     //       \Phpcf\FormattingResult $Result-&gt;getContent(); //     $Result-&gt;wasFormatted(); // bool,     $Result-&gt;getIssues(); // array,      $Result-&gt;getError(); // \Exception|null    </span></span></code> </pre><br></blockquote><br><br><h3>  IDE integration using PHPStorm as an example </h3><br>  If you want to be able to format the PHP code using our formatter while using PHPStorm, you can do the following steps: <br><br><blockquote>  1. git clone <a href="">https://github.com/badoo/phpcf.git</a> <br>  2. In PHPStorm go to the settings and find the section "External Tools". <br>  3. Click "Add ..." and fill in the fields: <br><br>  Name: format whole file <br>  Group: phpcf <br>  Remove the tick "open console" (so as not to bother) <br>  Program: php <br>  Parameters: path_to_phpcf.git / phpcf apply $ FilePath $ <br>  Working directory: any <br><br>  Name: format selection <br>  Group: phpcf <br>  Remove the tick "open console" (so as not to bother) <br>  Program: php <br>  Parameters: path_to_phpcf.git / phpcf apply $ FilePath $: $ SelectionStartLine $ - $ SelectionEndLine $ <br>  Working directory: any <br></blockquote><br><br>  After that, you can bind the hotkeys to the corresponding actions and format either the entire file or just the selected fragments. <br><br>  In addition, you can configure phpcf check-git --emacs in the same way: in this mode, phpcf will print emacs-style file names with lines, and due to this you can go to the line indicated in the output by clicking on the link. <br><br><h3>  Implementation </h3><br>  In the course of its work, the formatter goes through the following stages: <br><br><ol><li>  Prepare a list of file names and line numbers to be formatted. </li><li>  Get a list of tokens for a file by calling token_get_all (prepareTokens). </li><li>  Converting tokens into a single format with the ability to perform hooks, allowing you to replace some tokens with others. </li><li>  Calling the process () method that runs through all the tokens using the Phpcf \ Impl \ Fsm state machine and compiles an array of formatting actions (exec). </li><li>  Calling the exec () method, in which the generated array of actions is processed and turned into the final string. </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">More details</b> <div class="spoiler_text"><h4>  Description class Phpcf \ Impl \ Fsm - a finite state machine for parsing tokens </h4><br>  The class Phpcf \ Impl \ Fsm is a finite state machine, in which the state is represented in the form of a stack (array).  The top stack element is used for state transition rules: <br><br><blockquote><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $fsm_context_rules = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'CTX_SOMETHING'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-comment"><span class="hljs-comment">//  ,    = CTX_SOMETHING 'T_1' =&gt; 'CTX_OTHER_THING', //   T_1     CTX_OTHER_THING 'T_2' =&gt; array('CTX_OTHER_THING'), //   T_2  push(CTX_OTHER_THING) 'T_3' =&gt; -2, //   T_3  pop()   2  //   N     M     // ,        'T_4' =&gt; array(PHPCF_CTX_NOW =&gt; N, PHPCF_CTX_NEXT =&gt; M), // c        'T_5' =&gt; array('REPLACE' =&gt; array(-2, array('CTX_OTHER_THING')), //      ,     ,    ), );</span></span></code> </pre><br></blockquote><br><br>  In general, the rules for the state machine are as follows: <br><br><blockquote><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $fsm_context_rules = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'&lt;context_name&gt;[ ... &lt;context_name&gt;]'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'&lt;token_code&gt;[ ... &lt;token_code&gt;]'</span></span> =&gt; &lt;context_rule&gt;, ), ); $context_rule = <span class="hljs-string"><span class="hljs-string">'&lt;context_name&gt;'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    &lt;context_name&gt;     $context_rule = array('&lt;context_name&gt;'); //    &lt;context_name&gt;,  &lt;context_name&gt;   $context_rule = -N; //   N  , N ‚Äî   //  ,    PHPCF_CTX_NOW,       , //   PHPCF_CTX_NEXT ( debug        "delayed rule") $context_rule = array(PHPCF_CTX_NOW =&gt; &lt;context_rule&gt;, PHPCF_CTX_NEXT =&gt; &lt;context_rule&gt;);</span></span></code> </pre><br></blockquote><br><br><h4>  Array of formatting rules: $ controls </h4><br>  The formatter is basically designed in such a way that it only regulates the contents of whitespace tokens (with the exception of hooks).  All formatting rules are defined in the $ controls array, which is represented as follows: <br><br><blockquote><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $controls = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'&lt;token_code&gt;[ ... &lt;token_code&gt;]'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-comment"><span class="hljs-comment">//    ,       ['&lt;context&gt;' =&gt; &lt;formatting_rule&gt;,] //  &lt;formatting_rule&gt;    PHPCF_KEY_ALL =&gt; &lt;formatting_rule&gt;, //  &lt;formatting_rule&gt;,         ), ); $formatting_rule = array( PHPCF_KEY_DESCR_LEFT =&gt; '&lt;description&gt;', //  ,        PHPCF_KEY_LEFT =&gt; PHPCF_EX_&lt;action&gt;, // ,         PHPCF_KEY_DESCR_RIGHT =&gt; '&lt;description&gt;', //      PHPCF_KEY_RIGHT =&gt; PHPCF_EX_&lt;action&gt;, // ,     ); // : 'T_AS T_ELSEIF T_ELSE T_CATCH' =&gt; array( //   "as", "elseif", "else"  "catch" PHPCF_KEY_ALL =&gt; array( //    PHPCF_KEY_DESCR_LEFT =&gt; 'One space before as, elseif, else, catch', PHPCF_KEY_LEFT =&gt; PHPCF_EX_SHRINK_SPACES_STRONG, //       ( ) PHPCF_KEY_DESCR_RIGHT =&gt; 'One space after as, elseif, else, catch', //    PHPCF_KEY_RIGHT =&gt; PHPCF_EX_SHRINK_SPACES_STRONG, //   ) ),</span></span></code> </pre><br></blockquote><br><br>  In case different rules are defined for the same spaces, for example in "$ a = $ b;"  after "=" you need to put 1 space, and before $ b - remove all spaces, then the order of application of the rules depends on their priority.  The priority of operations is described in the ‚ÄúPHPCF_EX-constants‚Äù section: the higher the rule, the higher its priority. <br><br><h4>  Hooks on tokens </h4><br>  The $ token_hook_names property defines the names of the methods that should be called when the prepareTokens method comes across this token.  Hooks are defined as follows: <br><br><blockquote><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Phpcf</span></span>\<span class="hljs-title"><span class="hljs-title">Impl</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pure</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phpcf</span></span></span><span class="hljs-class">\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFormatter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* *  $idx_tokens      array(T_SOMETHING =&gt; 'T_SOMETHING'), *       * *  $i_value       ,  token_get_all * *           $this-&gt;tokens   each() *   : tokenHookStr * *     ,     *        * *   ,      : */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tokenHookDoNothing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($idx_tokens, $i_value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($i_value)) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;current_line = $i_value[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( PHPCF_KEY_CODE =&gt; $idx_tokens[$i_value[<span class="hljs-number"><span class="hljs-number">0</span></span>]], PHPCF_KEY_TEXT =&gt; $i_value[<span class="hljs-number"><span class="hljs-number">1</span></span>], PHPCF_KEY_LINE =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;current_line, ) ); <span class="hljs-comment"><span class="hljs-comment">// set correct current line for next token if it does not have line number $this-&gt;current_line += substr_count($i_value[1], "\n"); } return array( array( PHPCF_KEY_CODE =&gt; $i_value, PHPCF_KEY_TEXT =&gt; $i_value, PHPCF_KEY_LINE =&gt; $this-&gt;current_line, ) ); } }</span></span></code> </pre><br></blockquote><br><br><h4>  Description of hooks for tokens </h4><br>  A brief description of hooks for tokens with a description of the cause of the hook and its actions: <br><br><ul><li>  <b>tokenHookHeredoc, tokenHookStr:</b> by default, PHP ‚Äútokens‚Äù text inside HEREDOCs, double and oblique quotes, and highlights variables there.  Since the formatter should not touch lines, the contents are merged into one token; </li><li>  <b>tokenHookOpenBrace</b> turns the token "(" to "(_LONG) if the expression in brackets is long (120 characters by default) or is a line break in the expression. It is used to distinguish between" long "and" short "arrays, and also calls and definitions of functions; </li><li>  <b>tokenHookCheckUnary</b> determines whether the operator is unary (for example, "+", "-", and &amp;).  Used to reduce the number of transitions between contexts in the rules; </li><li>  <b>tokenHookStatic</b> separates calls like "static :: HELLO" from use in the form of "public static function".  It also serves to simplify the state transition logic; </li><li>  <b>tokenHookClassdef</b> determines that there is a line <b>break</b> after the keyword (for example, "const \ n"), it is used to correctly format constructions of the form "const \ n var1 = 1, \ n var2 = 2;"; </li><li>  <b>tokenHookOpenTag</b> checks that the opening tag is long and also separates the whitespace from the opening tag (turning "&lt;? php \ n" into two tokens: "&lt;? php" and "\ n"); </li><li>  <b>tokenHookCloseTag</b> verifies that there is no closing tag at the end of the file; </li><li>  <b>tokenHookIncrement</b> determines which side of the variable is the "++" or "-" operator.  Made to simplify the logic of transition between contexts; </li><li>  <b>tokenHookWhiteSpace</b> determines that expressions are <b>justified</b> using spaces, and replaces T_WHITESPACE with T_WHITESPACE_ALIGNED, which does not move when formatted; </li><li>  <b>tokenHookElse</b> determines whether else is single line or contains blocks.  Made to simplify logic; </li><li>  <b>tokenHookComment</b> checks that single-line comments begin with "//", and also separates the line break from the token ("// something \ n" turns into "// something" and "\ n"); </li><li>  <b>tokenHookTString</b> renames T_STRING to T_FUNCTION_NAME when this T_STRING is the name of a method or function.  Made to simplify the logic of transition between contexts; </li><li>  <b>tokenHookBinary</b> serves to handle the situation with moving the statement to the next line; </li><li>  <b>tokenHookComma</b> turns "," into ", _LONG" for commas, which can be transferred to a new line in a long array; </li><li>  <b>tokenHookFunction</b> separates anonymous and non-anonymous functions from each other. </li></ul><br><br>  If the hook changes the contents of the token, then it must check whether it has the right to do this <code>($can_change_tokens = !isset($this-&gt;lines) || isset($this-&gt;lines[$this-&gt;current_line]))</code> .  If it does not, then the hook should not change the contents of the tokens, but can change their number and divide the tokens into their constituent parts.  As an example, tokenHookOpenTag: it does not check the contents of the opening tag if the user requested formatting only part of the file, but still separates whitespace from the opening tag.  The separation of whitespace is required in order to correctly take into account the number of lines (and indentation) after the opening tag and single-line comments. <br></div></div><br><br><h3>  Links </h3><br>  PHP Beautifier - <a href="http://pear.php.net/package/PHP_Beautifier">pear.php.net/package/PHP_Beautifier</a> <br>  PHP Code Sniffer - <a href="http://pear.php.net/package/PHP_CodeSniffer">pear.php.net/package/PHP_CodeSniffer</a> <br>  PHP CS Fixer - <a href="https://github.com/fabpot/PHP-CS-Fixer">github.com/fabpot/PHP-CS-Fixer</a> <br><br>  Our phpcf utility - <a href="https://github.com/badoo/phpcf/">github.com/badoo/phpcf</a> <br><br>  Thanks for reading our article, we are ready to listen to your suggestions and comments.  We hope you enjoy using our utility. <br><br><blockquote>  <i>Yuri <a href="https://habrahabr.ru/users/yourock/" class="user_link">youROCK,</a> Nasretdinov, PHP developer Badoo</i> <i><br></i>  <i>Alexander <a href="https://habrahabr.ru/users/alexkrash/" class="user_link">alexkrash</a> Krasheninnikov, PHP developer Badoo</i> <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/232133/">https://habr.com/ru/post/232133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../232117/index.html">10 most popular video reports from 404fest 2013</a></li>
<li><a href="../232119/index.html">Epson sublimation printing turns shopping into a print reality show</a></li>
<li><a href="../232121/index.html">In a dark, dark room there is a dark, dark computer, and in it ... black lists!</a></li>
<li><a href="../232123/index.html">Runtastic Orbit: fitness tracker from the manufacturer of fitness applications</a></li>
<li><a href="../232129/index.html">And again the attack on Wordpress sites - brute force + XMLRPC</a></li>
<li><a href="../232135/index.html">The path of a freelancer. Part 1. Tips for beginners</a></li>
<li><a href="../232137/index.html">New "Authors' Market" on Habr√©</a></li>
<li><a href="../232139/index.html">MegaIndex: a technology leader in the field of automated website promotion</a></li>
<li><a href="../232149/index.html">EtherCalc: Spreadsheets on Node.js</a></li>
<li><a href="../232151/index.html">Mini-printer for screenshots from a smartphone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>