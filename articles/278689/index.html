<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>iBeacon. Myths and Reality</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(picture from developer.apple.com ) 

 What it is? 
 In mid-2013, Apple at a conference for developers suddenly said that they had prepared a new tech...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>iBeacon. Myths and Reality</h1><div class="post__text post__text-html js-mediator-article"><img src="https://developer.apple.com/ibeacon/images/ibeacon-logo.svg" width="150"><br>  (picture from <a href="https://developer.apple.com/ibeacon/">developer.apple.com</a> ) <br><br><h2>  What it is? </h2><br>  In mid-2013, Apple at a conference for developers suddenly said that they had prepared a new technology for indoor navigation, that they began to create maps of museums, shopping centers and other interesting places, and in general, everything is cool.  Believing in the word of a large company, many began to offer ‚Äúsolutions‚Äù for indoor navigation, but few of them got something workable.  It turned out that in reality it is quite difficult to apply this technology. <br><br>  I also took an active part in technology research.  It was possible to deploy a network of beacons at GeekPicnic events in Moscow and in St. Petersburg, testing the capabilities of the technology.  After that, I wrote a library that, using a small number of lighthouses, makes it possible to determine the location inside the premises quite well. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the article I will briefly describe what iBeacon is, what tasks I had to solve with this technology, what was possible, what was not very. <br><a name="habracut"></a><br>  What is <a href="https://developer.apple.com/ibeacon/">iBeacon</a> ?  This is a protocol subset of Bluetooth Low Energy, which allows you to find out: <br><br><ul><li>  UUID, Major, Minor for beacon </li><li>  beacon signal strength </li></ul><br>  It looks like this: <br><br><pre><code class="hljs dos">fb0b57a2-<span class="hljs-number"><span class="hljs-number">8228</span></span>-<span class="hljs-number"><span class="hljs-number">44</span></span> <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span>-<span class="hljs-number"><span class="hljs-number">913</span></span>a-<span class="hljs-number"><span class="hljs-number">94</span></span>a122ba1206 Major <span class="hljs-number"><span class="hljs-number">1</span></span> Minor <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  You can use iBeacons on iPhones, starting with 4S, Aipads, starting with the third generation, iPad Mini, iPod Touch (fifth generation), Android support should be found in specific devices, and the OS version should be 4.3 or higher.  You can also use Macintosh computers. <br><br><h2>  Real-life experience </h2><br>  When we considered the possible uses of technology, it turned out very nicely: <br><br><ul><li>  navigation, </li><li>  tracking of movements (goods, employees), </li><li>  checkpoints, </li><li>  advertising. </li></ul><br>  In practice, it turned out that everything is not so simple. <br><br>  The main disappointment is that the navigation is extremely inaccurate.  In the next section, I will show how you can make adequate navigation on beacons, but generally beacons are poorly designed for navigation. <br><br>  In general, the basic algorithm for working with beacons - when a user device approaches it, a notification appears.  Immediately you want to catch all beacons in a row.  But, unfortunately, in order to process a notification, you need to write the appropriate application and enter the parameters of a specific beacon (or a specific type of beacons, for this purpose, the UUID is usually used, which are the same for all the desired beacons).  That is, you can not just take and hang up, for example, an advertising beacon, so that it hangs and cuts to all who pass.  It is necessary to force to put an application that listens only to those beacons to which it is configured (it cannot be configured for everything, because startMonitorForRegion will not allow adding an infinite number of regions): <br><br><pre> <code class="hljs objectivec"><span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *uuid = <span class="hljs-string"><span class="hljs-string">@"B9407F30-F5F8-466E-AFF9-25556B57FE6D"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">CLBeaconRegion</span></span> *region = [[<span class="hljs-built_in"><span class="hljs-built_in">CLBeaconRegion</span></span> alloc] initWithProximityUUID:[[<span class="hljs-built_in"><span class="hljs-built_in">NSUUID</span></span> alloc] initWithUUIDString:uuid] identifier:[<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> stringWithFormat:<span class="hljs-string"><span class="hljs-string">@"beacon_%@"</span></span>, uuid]]; region.notifyEntryStateOnDisplay = <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; _locationManager startMonitoringForRegion:region]; [_locationManager startRangingBeaconsInRegion:region];</code> </pre> <br>  Chop is also not easy.  The reaction rate of the device (smartphone) is from a second to a couple of minutes.  That is, the user can walk past the beacon, walk a few more minutes, only after that a notification will appear. <br><br>  Beacons themselves - break.  If you buy a lot of them (and this is more or less necessary for almost all use cases), then you have to save, therefore, the beacons fail and need to be replaced.  Nothing could be simpler, but after replacing you need to re-match the correspondence to a specific data bicon (advertising text, or coordinates).  As a result, in the development you can not do only the application and the Beacons.  We have to create a server that must keep the information consistent with the beacons, and the application needs to regularly update the data. <br><br>  Returning to real use.  In 2015, two GeekPicnic events took place in Moscow and St. Petersburg.  These are outdoor events where many different speakers, interesting artifacts, cars, and art objects gather.  In two days, the event is attended by 25,000 people. <br><br>  At each event (which takes place in the open air and in several pavilions) dozens of interesting objects.  It‚Äôs not very convenient to search for them on the map, so it was decided to use beacons for their designation and notifications when the user approaches them.  I wrote an application for iPhone, colleagues then repeated it for Android. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e68/663/d1e/e68663d1e2bb46678708e49a4f72e648.png" width="200"></div><br>  The scheme itself turned out to be about the following: <br><br><ul><li>  there are beacons throughout the event </li><li>  mobile application acts as a scanner, notifying the visitor that he came to an interesting place </li><li>  data about the connection of beacons and texts of interesting places is stored on the server and updated in the mobile application when they can (there are a lot of visitors and the connection with the server directly at the event is not very) </li></ul><br>  In order to avoid ‚Äúbounce‚Äù and a large number of notifications, data on all the beacons around and the closest one was kept, and it should be ‚Äúsubstantially closest‚Äù, while several beacons are approximately at the same distance, the notification does not pass. <br><br>  Also had to solve the problem of energy consumption.  To ensure that navigation is not turned on immediately after installing the application, firstly, scanning of beacons was turned on only on certain days, and secondly, only in a certain area (within a radius of several kilometers from the venue of the event).  It was fun to test both of these conditions, I had to drive a car with debugging turned on, watching the smartphone's activity (and, in different states, active, sleep mode). <br><br>  As a result, everything turned out well, and my colleagues and I got invaluable experience in implementing a large project using beacons. <br><br><h2>  Indoor Navigation </h2><br>  Let us turn to the technique.  When they talk about navigation, they usually mean finding a location by distance to several points (this is how GPS works, triangulation of location along cell towers, and this is exactly what they usually talk about in movies).  The algorithm is simple: <br><br><ul><li>  we know where there are several reference lighthouses.  Satellites are, towers or beacons - it does not matter.  Most importantly, the points must be determined, and fairly accurately. </li><li>  somehow we determine the distance to at least three points.  In the real world, three is not enough, try to use more.  The accuracy of these calculations also depends on the accuracy of these distances. </li><li>  from these distances, the location of the receiver (user) is calculated. </li></ul><br>  Anyone who tried to do this with beacons, quickly realized the futility of the idea.  The location of beacons can be measured accurately, but the distance to them is measured by the power of the beacon signal.  This power is very dependent on air pressure, humidity, the presence of various obstacles (including people and other living creatures).  Very - this means several times.  Of course, the software tries to smooth it out by applying filters and different algorithms, but this is not important.  The algorithm in such conditions, in fact, does not work (produces extremely inaccurate results). <br><br>  Thinking a little, I remembered that there is another option.  Unlike the "normal" algorithm, it does not give the exact location of the user, but rather shows what area he is in.  But for an indoor location, this is often enough. <br><br>  The algorithm is called fingerprinting, the location imprint.  In general, it looks like this: <br><br><ul><li>  we arrange beacons somehow "adequately", </li><li>  we run around the room, remembering how the picture looks by beacons (which are stronger, which are weaker), taking ‚Äúprints‚Äù of the picture of beacons in different places. </li><li>  after the fingerprints are taken, the user moves and the smartphone compares the current fingerprint with those in his memory.  Having picked up the closest one, we understand the area in which the user is located. <br>  In order for the algorithm to work successfully, I had to tinker.  But the result was very good. </li></ul><br>  Incomprehensible moment was exactly how to save prints.  Power can not be directly (they swim very much).  I tried the relative power, it turned out much better. <br><br>  Swimming capacity is noticeable even if just spinning in one place.  We stand, we turn, and the picture changes dramatically.  Therefore, I began to take several prints, standing in one place.  The prints themselves turned out like this: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *uuid; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CLBeaconMajorValue</span></span> major; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CLBeaconMajorValue</span></span> minor; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> relativeDistance; <span class="hljs-comment"><span class="hljs-comment">// 0-1 (normalized by the powerful) @property (nonatomic) CGFloat relativePowerDispersion; // 0-1 (normalized by the most powerful)</span></span></code> </pre> <br>  I took these parameters for each visible beacon at a given point, and all the parameters for all beacons ‚Äî and became an imprint. <br><br>  I also wanted, of course, that the point on the map would not just jump, but move around the map.  To do this, we had to interpolate the footprint, realizing what the user is between which areas / points, and, of course, filter the result that was very strong.  The distance between the current fingerprint and the footprints of the regions was calculated like this: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">Fingerprint</span></span> *f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _regions[regionName].fingerprints) { <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> newDistance = [f normalizedDistanceToFingerprint:aBeaconsFingerprint]; <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> <span class="hljs-built_in"><span class="hljs-built_in">distance</span></span> = (<span class="hljs-type"><span class="hljs-type">CGFloat</span></span>) (result[regionName] == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ? <span class="hljs-type"><span class="hljs-type">FLT_MAX</span></span> : [result[regionName] doubleValue]); <span class="hljs-built_in"><span class="hljs-built_in">distance</span></span> = <span class="hljs-type"><span class="hljs-type">MIN</span></span>(newDistance, <span class="hljs-built_in"><span class="hljs-built_in">distance</span></span>); result[regionName] = @(<span class="hljs-built_in"><span class="hljs-built_in">distance</span></span>); }</code> </pre> <br>  And, in fact, the very distance between the prints, so: <br><br><pre> <code class="hljs pgsql">- (CGFloat)normalizedDistanceToFingerprint:(NSMutableDictionary *)aBeaconsFingerprint { // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> have a beacon <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> region fingerprint ‚Äî <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> DISTANCE_PENALTY_FOR_ABSENT_BEACON // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> have <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> beacons, result <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> "FLT_MAX" CGFloat result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">BOOL</span></span> resultIsNotInfinite = <span class="hljs-keyword"><span class="hljs-keyword">NO</span></span>; NSArray *regionBeaconIds = [_beaconsFingerprint allKeys]; NSArray *testingBeaconIds = [aBeaconsFingerprint allKeys]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (NSString *beaconId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> regionBeaconIds) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![testingBeaconIds containsObject:beaconId]) { result += DISTANCE_PENALTY_FOR_ABSENT_BEACON; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result += fabs( fabs(((Fingerprint *) _beaconsFingerprint[beaconId]).relativeDistance) - fabs([aBeaconsFingerprint[beaconId] doubleValue])); resultIsNotInfinite = YES; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (NSString *testingBeaconId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> testingBeaconIds) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![regionBeaconIds containsObject:testingBeaconId]) { result += DISTANCE_PENALTY_FOR_ABSENT_BEACON; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resultIsNotInfinite ? result : FLT_MAX; }</code> </pre> <br>  It turned out very well.  This solution will require you to think up a replacement system for a failed beacon (to retake all prints is a bad decision, it can take a lot of time).  And if there are a sufficient number of well-placed beacons (it is best to hang them closer to the ceiling, for example, but this is not the only recommendation) - and the accuracy is good (¬± a few meters). <br><br><h2>  findings </h2><br>  Now the buzz around iBeacon technology has subsided.  But the tasks have not gone away.  Indoor navigation is still required.  Still need the opportunity to inform visitors of the store about new products.  And now it can be done not only with advertising banners, but also with such beacons. <br><br>  Of course, their actual use is not so straightforward, and many tasks need to be solved in order for it to work as it should.  The main conclusion of more than a year of working with technology is, with certain reservations, viable.  And then you need to look whether it is suitable for a particular application or not.  Alas, the silver bullet has not happened yet. <br></div><p>Source: <a href="https://habr.com/ru/post/278689/">https://habr.com/ru/post/278689/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278677/index.html">AudioCodes Routers</a></li>
<li><a href="../278679/index.html">Own "Who called?" On the basis of Multifon</a></li>
<li><a href="../278681/index.html">How to parse text with bare hardware, without a processor and without software</a></li>
<li><a href="../278683/index.html">iTrace. How are the letters written?</a></li>
<li><a href="../278685/index.html">Overview of synchronization primitives - spinlock and secrets of the processor core</a></li>
<li><a href="../278691/index.html">PowerShell Remoting - setup and remote management</a></li>
<li><a href="../278693/index.html">turn string into scriptblock</a></li>
<li><a href="../278695/index.html">Angstrom. A bunch of difficulties in a simple wrapper</a></li>
<li><a href="../278697/index.html">libuniset2 is a library for creating ACS. It‚Äôs better to see once ... Part 6 (Final)</a></li>
<li><a href="../278699/index.html">QA: Conference. We tell about the reports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>