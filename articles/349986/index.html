<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous HTTP requests in C ++: incoming through RESTinio, outgoing through libcurl. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, we sorted out the implementation of a two-threaded bridge_server. On a single thread, incoming HTTP requests are asynchronous...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous HTTP requests in C ++: incoming through RESTinio, outgoing through libcurl. Part 3</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habrahabr.ru/post/349818/">In the previous article,</a> we sorted out the implementation of a two-threaded bridge_server.  On a single thread, incoming HTTP requests are asynchronously processed via <a href="">RESTinio</a> .  On the second thread, asynchronous requests are made to delay_server via <a href="https://curl.haxx.se/libcurl">libcurl</a> in the form of <a href="https://curl.haxx.se/libcurl/c/libcurl-multi.html">curl_multi</a> using the functions <a href="https://curl.haxx.se/libcurl/c/curl_multi_perform.html">curl_multi_perform</a> and <a href="https://curl.haxx.se/libcurl/c/curl_multi_wait.html">curl_multi_wait</a> . <br><br>  Today we will examine another implementation of bridge_server, which asynchronously serves both incoming and outgoing HTTP requests on the same thread pool.  From libcurl, the <a href="https://curl.haxx.se/libcurl/c/curl_multi_socket_action.html">curl_multi_socket_action</a> function is used for this purpose. <br><br>  This implementation took us the most time.  It has long been not necessary to smoke as much bamboo as happened during the proceedings with the documentation for this function and examples of its use.  At first, all of this was generally perceived as some kind of black magic, but then the light at the end of the tunnel still appeared, and the code earned.  How exactly did it work?  But about this today and talk. <br><a name="habracut"></a><br><h1>  What and how does bridge_server_2 do? </h1><br>  The bridge_server_2 considered in this article does the same thing as the bridge_server_1 considered earlier.  Only he does it differently.  Instead of dividing the functionality into two different threads, as it was in bridge_server_1, where RESTinio worked on a separate stream and curl_multi on another stream, in bridge_server_2 all operations are performed on the same thread pool. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To do this, we ourselves undertake the creation of sockets, which libcurl needs, and we track the moments of readiness of these sockets for read / write operations. <br><br><h1>  The structure of this article </h1><br>  The material in this article is structured as follows: <br><br><ul><li>  First, it will be discussed that bridge_server_2 is reused from bridge_server_1.  In order not to increase the volume of the article by repeating what has already been explained earlier; </li><li>  then we will tell you how the RESTinio-part of bridge_server_2 differs from the RESTinio-part of bridge_server_1; </li><li>  then we move on to the story of how the curl part is implemented in bridge_server_2. </li></ul><br>  So in this part of the article there will be no analysis of the bridge_server_2 code from the beginning to the end.  Therefore, if you have not read the <a href="https://habrahabr.ru/post/349818/">previous article with the analysis of bridge_server_1</a> , then it may make sense to do it.  For example, so that you understand what the check_curl_op_completion () function is, what it does and how it works. <br><br><h1>  What is common between bridge_server_1 and bridge_server_2? </h1><br>  In bridge_server_2, the following fragments are reused (using the copy &amp; paste method): <br><br><ul><li>  configuring and parsing command line arguments (config_t structure and parse_cmd_line_args () function); </li><li>  the request_info_t structure to send information about the received incoming request from the RESTinio part to the curl part, as well as the complete_request_processing () function to send a response to the received incoming HTTP request; </li><li>  the write_callback () and check_curl_op_completion () functions.  This also means that the control over the lifetime of request_info_t instances during the processing of an outgoing HTTP request is constructed in the same way: the bare pointer to request_info_t is stored in the curl_easy instance, and then retrieved from there and deleted. </li></ul><br><h1>  Differences in RESTinio-part from bridge_server_1 </h1><br>  In the RESTinio part of bridge_server_2 there are two main differences from bridge_server_1. <br><br>  First, in bridge_server_1, a separate working thread was involved in processing outgoing HTTP requests.  Therefore, to exchange information between the RESTinio thread and the curl thread, a special thread-safe container was used, into which the request_info_t instances were placed. <br><br>  But in bridge_server_2, RESTinio- and curl-parts of the application have a common working context (a pool of worker threads).  Therefore, to transfer information between the RESTinio and curl parts, a separate container is not needed.  But the curl part is represented by an object of the curl_multi_processor_t class, which is fed all received incoming HTTP requests.  Therefore, the handler () function, which is the real handler of incoming HTTP requests, is now passed a reference to curl_multi_processor_t: <br><br><pre><code class="hljs pgsql">//   . restinio::request_handling_status_t <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>( const config_t &amp; config, curl_multi_processor_t &amp; req_processor, restinio::request_handle_t req) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(restinio::http_method_get() == req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().<span class="hljs-keyword"><span class="hljs-keyword">method</span></span>() &amp;&amp; "/data" == req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().path()) { //    . const auto qp = restinio::parse_query(req-&gt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>().query()); //          //      curl_multi. auto url = fmt::format("http://{}:{}/{}/{}/{}", config.target_address_, config.target_port_, qp["year"], qp["month"], qp["day"]); auto <span class="hljs-keyword"><span class="hljs-keyword">info</span></span> = std::make_unique&lt;request_info_t&gt;( std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(url), std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(req)); req_processor.perform_request(std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>)); // ,         - //   . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } //       . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }</code> </pre> <br>  Secondly, now RESTinio runs on a pool of worker threads.  Therefore, the code in the run_server function has changed, instead of on_this_thread, on_thread_pool is now used there: <br><br><pre> <code class="hljs pgsql">//  ,       . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typename Server_Traits, typename <span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span>&gt; <span class="hljs-type"><span class="hljs-type">void</span></span> run_server( const config_t &amp; config, restinio::asio_ns::io_context &amp; ioctx, <span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) { restinio::run( ioctx, restinio::on_thread_pool&lt;Server_Traits&gt;(std::thread::hardware_concurrency()) .address(config.address_) .port(config.port_) .request_handler(std::forward&lt;<span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>))); }</code> </pre> <br>  Well, actually, the main () function has changed a bit.  Although it does not matter. <br><br><div class="spoiler">  <b class="spoiler_title">The code of the main () function from bridge_server_2</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> main(<span class="hljs-type"><span class="hljs-type">int</span></span> argc, <span class="hljs-type"><span class="hljs-type">char</span></span> ** argv) { try { const auto cfg = parse_cmd_line_args(argc, argv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cfg.help_requested_) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; //   curl. curl_global_init(CURL_GLOBAL_ALL); auto curl_global_deinitializer = cpp_util_3::at_scope_exit([]{ curl_global_cleanup(); }); //   Asio- io_context, ..    //  curl_multi_processor-,   HTTP-. restinio::asio_ns::io_context ioctx; //     . curl_multi_processor_t curl_multi{ioctx}; //    HTTP-. auto actual_handler = [&amp;cfg, &amp;curl_multi](auto req) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(cfg.config_, curl_multi, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(req)); }; //     HTTP-. //     ,   //    . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cfg.config_.tracing_) { //  ,    ,   //     . struct traceable_server_traits_t : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> restinio::default_traits_t { //     . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> logger_t = restinio::shared_ostream_logger_t; }; //         . run_server&lt;traceable_server_traits_t&gt;( cfg.config_, ioctx, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(actual_handler)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   ,     . run_server&lt;restinio::default_traits_t&gt;( cfg.config_, ioctx, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(actual_handler)); } // ,     . } catch( const std::<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br></div></div><br><h1>  Implementing the curl part of bridge_server_2 </h1><br>  Before we proceed to the analysis of the curl-part, you need to repeat the archival disclimer from the previous article, which is even more relevant in the case of bridge_server_2: in <i>order to simplify and shorten the code of the demo applications as much as possible, we didn‚Äôt do any error control at all.</i>  <i>If we properly controlled the return codes of curl functions, then the code would be three times swollen, significantly losing clarity, but not gaining anything in functionality.</i>  <i>Therefore, in our demonstration, we expect that the calls to libcurl will always succeed.</i>  <i>This is our conscious decision for this particular experiment, but we would never do that in a real production code.</i> <br><br><h2>  The general idea of ‚Äã‚Äãthe curl part </h2><br>  The bridge_server_2 curl part is built around the use of the <a href="https://curl.haxx.se/libcurl/c/curl_multi_socket_action.html">curl_multi_socket_action</a> function.  And, we admit honestly, all this looks unclear and leaves a feeling of some magic: ( <br><br>  Perhaps the cause is not the most responsible <a href="https://curl.haxx.se/libcurl/c/curl_multi_socket_action.html">documentation for the curl_multi_socket_action function itself on the official website</a> .  After reading it, many questions remain.  Even more confusing matter is a regular libcurl example called <a href="">asiohiper.cpp</a> .  Which would have to demonstrate exactly how Asio and curl_multi can be integrated through curl_multi_socket_action.  But which is written so that you can not figure it out for sober head.  If someone can read the source code of this example as an open book, then we frankly envy you :) <br><br>  Plus, we wanted to make our demonstration as quickly and as easily as possible.  Therefore, to spend extra hours on a detailed investigation with curl_multi_socket_action simply could not.  As a result, the option we got is quite a working one.  But we are not sure that we did everything completely correctly and didn‚Äôt make a mistake somewhere.  So for sure you can do better.  And if someone starts from our decision in his code, then this should be taken into account. <br><br>  So, here we come to what understanding of using curl_multi_socket_action on the basis of smoking out official information, an example of an asiohiper and fragmentary information from the Internet: <br><br><ul><li>  for the curl_multi instance, you need to set the <a href="https://curl.haxx.se/libcurl/c/CURLMOPT_TIMERFUNCTION.html">CURLMOPT_TIMERFUNCTION</a> property.  This should be the callback provided by us, which libcurl will jerk when it needs to count timeouts associated with processing requests.  Accordingly, we need to implement service timers; </li><li>  For the curl_multi instance, you need to set the <a href="https://curl.haxx.se/libcurl/c/CURLMOPT_SOCKETFUNCTION.html">CURLMOPT_SOCKETFUNCTION</a> property.  This will be the callback we provided, which libcurl will pull (possibly several times) inside curl_multi_socket_action; </li><li>  we have to somehow monitor the status of I / O operations, <br>  which are executed on the sockets created by libcurl.  When a socket is ready to be read and / or written, we need to call curl_multi_socket_action for that socket.  Then the question arises: how do we know exactly what sockets libcurl creates when processing our requests?  We will discuss the very correct question and the answer to it below; </li><li>  periodically we have to pull the curl_multi_socket_action function with the CURL_SOCKET_TIMEOUT parameter.  This call causes libcurl to check the expiration of timeouts for expired requests.  Basically, the time when we have to call curl_multi_socket_action with the value CURL_SOCKET_TIMEOUT is set to us by libcurl itself via the callback, which we set via the CURLMOPT_TIMERFUNCTION property; </li><li>  periodically we have to pull the <a href="https://curl.haxx.se/libcurl/c/curl_multi_info_read.html">curl_multi_info_read</a> function in order <br>  to determine which HTTP requests have ended (here we just reuse check_curl_op_completion () from bridge_server_1). </li></ul><br>  Sounds not very clear?  Well, that's the way it is, so let's go further.  Now there will be some more incomprehensibility.  But then we move on to parsing the code and, there is hope, when we look at the code, everything will fall into place. <br><br>  But first you need to close an important question with how to find out exactly which sockets libcurl creates to serve our requests.  Indeed, without these sockets, we cannot control their accessibility for read-write operations. <br><br><h3>  Putting libcurl into your own sockets </h3><br>  Extremely important in the context of our story, the feature of libcurl is that libcurl has separate curl_easy instances and there are separate sockets that libcurl creates to serve requests initiated through curl_easy instances.  Moreover, curl_easy instances and sockets are not at all related to the 1: 1 relationship.  Those.  several curl_easy instances may well be served by the same socket if all requests go to the same server (especially if keep-alive is also specified). <br><br>  When working with curl_multi it turns out generally interesting.  We push a bundle of curl_easy instances into one instance of curl_multi.  And curl_multi decides for itself at what point and how many sockets it needs to create in order to service the HTTP requests that are inside the curl_multi instance.  And we need to know that these sockets are created, we need to get their descriptors, and we have to push the descriptors of these sockets into some kind of our own event-loop mechanism (be it select, epoll, kqueue, IOCP). <br><br>  Basically, learning a socket descriptor is easy.  Libcurl itself sends it to us in callback, which we registered through the CURLMOPT_SOCKETFUNCTION property.  Plus, calling this callback <a href="https://curl.haxx.se/libcurl/c/CURLMOPT_SOCKETFUNCTION.html">libcurl tells us which operations on the socket we need to monitor (for this we use the values ‚Äã‚ÄãCURL_POLL_IN, CURL_POLL_OUT, CURL_POLL_INOUT, CURL_POLL_REMOVE)</a> .  And if we ourselves performed the event-loop, then that would be enough for us. <br><br>  But the problem is that the real event-loop is inside Asio.  And we need to be able to somehow make friends the sockets created by libcurl with our io_context instance.  And how to do it? <br><br>  We saw the solution in the asiohiper example.  This moment there was probably the most understandable and obvious.  The point is to create sockets in the form of asio :: io :: tcp :: socket.  Thus, we can make io_context monitor their readiness to read / write.  And in libcurl we will give the real descriptors of our sockets so that libcurl can read and write. <br><br>  It is done this way: for curl_easy, we assign additional properties <a href="https://curl.haxx.se/libcurl/c/CURLOPT_OPENSOCKETFUNCTION.html">CURLOPT_OPENSOCKETFUNCTION</a> and <a href="https://curl.haxx.se/libcurl/c/CURLOPT_CLOSESOCKETFUNCTION.html">CURLOPT_CLOSESOCKETFUNCTION</a> .  These are two callbacks.  The first is called by libcurl when it wants to create a new socket.  And this callback, accordingly, must return a handle to the new socket.  The second callback is called when libcurl no longer needs a socket and wants to close it.  Accordingly, we provide the libcurl with these same callbacks that create and destroy objects of type asio :: ip :: tcp :: socket. <br><br><h2>  Parsing the curl part code </h2><br>  In addition to the functions already familiar to us, which were reused from bridge_server_1, the curl part in bridge_server_2 is represented by two classes described below. <br><br><h3>  Class active_socket_t </h3><br>  The class active_socket_t is auxiliary and we need it because we ourselves create sockets for libcurl.  Created sockets need to be stored somewhere.  Active_socket_t helps us to do just that.  Here is its definition: <br><br><pre> <code class="hljs pgsql">//      . <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> active_socket_t final { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> status_t = std::int_fast8_t; static constexpr status_t poll_in = <span class="hljs-number"><span class="hljs-number">1</span></span>u; static constexpr status_t poll_out = <span class="hljs-number"><span class="hljs-number">2</span></span>u; private: restinio::asio_ns::ip::tcp::socket socket_; status_t status_{<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: active_socket_t(restinio::asio_ns::io_service &amp; io_service) : socket_{io_service, restinio::asio_ns::ip::tcp::v4()} {} auto &amp; socket() noexcept { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> socket_; } auto handle() noexcept { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> socket_.native_handle(); } <span class="hljs-type"><span class="hljs-type">void</span></span> clear_status() noexcept { status_ = <span class="hljs-number"><span class="hljs-number">0</span></span>; } auto status() noexcept { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status_; } <span class="hljs-type"><span class="hljs-type">void</span></span> update_status( status_t flag ) noexcept { status_ |= flag; } };</code> </pre> <br>  The class active_socket_t encapsulates a socket and a set of flags defining the status of the operations that we want to monitor for this socket.  For example, if we need to wait for readiness to read, then the active_socket_t :: poll_in flag will be set in the status.  The statuses are updated inside callbacks that are called when working with libcurl. <br><br>  Just the presence of active_socket_t with the status inside is the main simplification of our implementation in comparison with the code of the asiohiper.  There, an additional int is allocated for storing flags for each socket.  These are extra overheads, and an extra headache (this int must be removed), and extra complexity in implementation.  The latter is especially important, since the most difficult part of the asiohiper is to figure out what is the actual flag for the next operation on the socket, and what is the old flags from this additional int. <br><br><h3>  Class curl_multi_processor_t </h3><br>  The curl_multi_processor_t class is the main element of the implementation of working with curl_multi.  This is where all the magic related to the maintenance of an instance of curl_multi and calls to curl_multi_socket_action, as well as almost all the associated callbacks, is executed. <br><br>  To begin with, we will give a complete definition of the class, and then we will go through all its parts in more detail.  So, this is how the class itself looks like: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> curl_multi_processor_t { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: curl_multi_processor_t(restinio::asio_ns::io_context &amp; ioctx); ~curl_multi_processor_t(); //   Copyable   Moveable . curl_multi_processor_t(const curl_multi_processor_t &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; curl_multi_processor_t(curl_multi_processor_t &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; //   ,     // ,       . <span class="hljs-type"><span class="hljs-type">void</span></span> perform_request(std::unique_ptr&lt;request_info_t&gt; <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>); private: //  curl_multi,       . CURLM * curlm_; // Asio- ,     . restinio::asio_ns::io_context &amp; ioctx_; //        . restinio::asio_ns::strand&lt;restinio::asio_ns::executor&gt; strand_{ioctx_.get_executor()}; // ,     timer_function-. restinio::asio_ns::steady_timer timer_{ioctx_}; //    ,     //   . std::unordered_map&lt;curl_socket_t, std::unique_ptr&lt;active_socket_t&gt;&gt; active_sockets_; //  ,    reinterpret_cast . static auto cast_to(<span class="hljs-type"><span class="hljs-type">void</span></span> * ptr) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reinterpret_cast&lt;curl_multi_processor_t *&gt;(ptr); } //   CURLMOPT_SOCKETFUNCTION. static <span class="hljs-type"><span class="hljs-type">int</span></span> socket_function( CURL *, curl_socket_t s, <span class="hljs-type"><span class="hljs-type">int</span></span> what, <span class="hljs-type"><span class="hljs-type">void</span></span> * userp, <span class="hljs-type"><span class="hljs-type">void</span></span> *); //   CURLMOPT_TIMERFUNCTION. static <span class="hljs-type"><span class="hljs-type">int</span></span> timer_function(CURLM *, long timeout_ms, <span class="hljs-type"><span class="hljs-type">void</span></span> * userp); //      . <span class="hljs-type"><span class="hljs-type">void</span></span> check_timeouts(); //  ,   ,  - //       . <span class="hljs-type"><span class="hljs-type">void</span></span> event_cb( curl_socket_t socket, <span class="hljs-type"><span class="hljs-type">int</span></span> what, const restinio::asio_ns::error_code &amp; ec); //   CURLOPT_OPENSOCKETFUNCTION. static curl_socket_t open_socket_function( <span class="hljs-type"><span class="hljs-type">void</span></span> * cbp, curlsocktype <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, curl_sockaddr * addr); //   CURLOPT_CLOSESOCKETFUNCTION. static <span class="hljs-type"><span class="hljs-type">int</span></span> close_socket_function(<span class="hljs-type"><span class="hljs-type">void</span></span> * cbp, curl_socket_t socket); //    ,   Asio  //       . <span class="hljs-type"><span class="hljs-type">void</span></span> schedule_wait_read_for(active_socket_t &amp; act_socket); <span class="hljs-type"><span class="hljs-type">void</span></span> schedule_wait_write_for(active_socket_t &amp; act_socket); };</code> </pre> <br>  And that's how it all works ... <br><br><h4>  Class data curl_multi_performer_t </h4><br>  There are several members inside curl_multi_performer_t, without which we will not be able to service requests.  It: <br><br><ul><li>  <i>curlm_</i> : a curl_multi instance in which individual curl_easy instances will be placed for outgoing requests; </li><li>  <i>ioctx_</i> : Asio context on which all work is performed; </li><li>  <i>strand_</i> : a special Asio object that acts as a synchronization primitive.  Does not allow Asio to run curl_multi_performer_t class event handlers in parallel on several threads; </li><li>  <i>timer_</i> : Asio-shny timer, which we will use to count timeouts, <br>  about which libcurl tells us; </li><li>  <i>active_sockets_</i> : dictionary of all created active_socket_t objects.  The key in this dictionary is a socket descriptor.  We need this dictionary because in some of the callbacks libcurl passes only the socket descriptor, and we need to find the active_socket_t object by descriptor.  So we are looking for sockets in this dictionary. </li></ul><br><h4>  Constructor and destructor </h4><br>  In the constructor, we need to create an instance of curl_multi and configure it.  And in the destructor, respectively, you need to remove curl_multi: <br><br><pre> <code class="hljs ruby">curl_multi_processor_t::curl_multi_processor_t( restinio::asio_ns::io_context &amp; ioctx) : curlm<span class="hljs-number"><span class="hljs-number">_</span></span>{curl_multi_init()} , ioctx<span class="hljs-number"><span class="hljs-number">_</span></span>{ioctx} { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    curl_multi. /<span class="hljs-regexp"><span class="hljs-regexp">/       . curl_multi_setopt(curlm_, CURLMOPT_SOCKETFUNCTION, &amp;curl_multi_processor_t::socket_function); curl_multi_setopt(curlm_, CURLMOPT_SOCKETDATA, this); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . curl_multi_setopt(curlm_, CURLMOPT_TIMERFUNCTION, &amp;curl_multi_processor_t::timer_function); curl_multi_setopt(curlm_, CURLMOPT_TIMERDATA, this); } curl_multi_processor_t::~curl_multi_processor_t() { curl_multi_cleanup(curlm_); }</span></span></code> </pre> <br>  Since  Since libcurl is a purely library library, we can only use static class methods as callbacks.  And in order to access curl_multi_performer_t data from a static method, we pass this as an additional parameter to the corresponding callbacks.  This is <a href="https://curl.haxx.se/libcurl/c/CURLMOPT_SOCKETDATA.html">what the CURLMOPT_SOCKETDATA</a> and <a href="https://curl.haxx.se/libcurl/c/CURLMOPT_TIMERDATA.html">CURLMOPT_TIMERDATA</a> properties are used <a href="https://curl.haxx.se/libcurl/c/CURLMOPT_TIMERDATA.html">for</a> . <br><br><h4>  The only public method is perform_request </h4><br>  The curl_multi_performer_t class has only one public method, perform_request, which is designed so that the RESTinio-part can transmit the received incoming processing request to the curl-part. <br><br>  Here is its implementation: <br><br><pre> <code class="hljs ruby">void curl_multi_processor_t::perform_request( std::unique_ptr&lt;request_info_t&gt; info) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      curl_multi  /<span class="hljs-regexp"><span class="hljs-regexp">/ callback  Asio. restinio::asio_ns::post(strand_, [this, info = std::move(info)]() mutable { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       curl_easy-  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . auto handle = curl_easy_init(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   curl_easy ,  URL  writefunction. curl_easy_setopt(handle, CURLOPT_URL, info-&gt;url_.c_str()); curl_easy_setopt(handle, CURLOPT_PRIVATE, info.get()); curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, write_callback); curl_easy_setopt(handle, CURLOPT_WRITEDATA, info.get()); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . curl_easy_setopt(handle, CURLOPT_OPENSOCKETFUNCTION, &amp;curl_multi_processor_t::open_socket_function); curl_easy_setopt(handle, CURLOPT_OPENSOCKETDATA, this); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,      . curl_easy_setopt(handle, CURLOPT_CLOSESOCKETFUNCTION, &amp;curl_multi_processor_t::close_socket_function); curl_easy_setopt(handle, CURLOPT_CLOSESOCKETDATA, this); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  curl_easy ,     curl_multi. curl_multi_add_handle(curlm_, handle); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ unique_ptr       . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        . info.release(); }); }</span></span></code> </pre> <br>  In general, this code is very similar to what we have already seen in bridge_server_1.  But there are several important differences. <br><br>  First, all actions on a new request are collected in lambda, which is sent to processing via asio :: io_context :: post ().  This is necessary because curl_multi is not a thread-safe object.  And we should avoid working with him from different threads at the same time.  Just the fact that we post-them lambda through the strand and protects us.  If at the moment some part of the curl_multi_performer_t is already working on another thread, then the lambda will be executed only when the other thread has finished working with curl_multi_performer_t. <br><br>  Secondly, we are setting the CURLOPT_OPENSOCKETFUNCTION and CURLOPT_CLOSESOCKETFUNCTION properties, which were discussed above.  It is through these properties that we can create and push libcurl our own sockets. <br><br><h4>  First tricky callback: socket_function </h4><br>  So we got to the first tricky callback that is used in bridge_server_2 - this is the static method socket_function, which we register through the CURLMOPT_SOCKETFUNCTION property in the designer curl_multi_performer_t.  This callback is called (possibly several times in a row) from curl_multi_socket_action so that we can force our event-loop to control the readiness of sockets for a particular I / O operation. <br><br>  Here is the socket_function code: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> curl_multi_processor_t::socket_function( CURL *, curl_socket_t s, <span class="hljs-type"><span class="hljs-type">int</span></span> what, <span class="hljs-type"><span class="hljs-type">void</span></span> * userp, <span class="hljs-type"><span class="hljs-type">void</span></span> *) { auto self = cast_to(userp); // ,     ,    . //    ,    . const auto it = self-&gt;active_sockets_.find(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(it != self-&gt;active_sockets_.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>()) { auto &amp; act_socket = *(it-&gt;second); //     .     //     what. act_socket.clear_status(); //     . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CURL_POLL_IN == what || CURL_POLL_INOUT == what) { //      . act_socket.update_status(active_socket_t::poll_in); self-&gt;schedule_wait_read_for(act_socket); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CURL_POLL_OUT == what || CURL_POLL_INOUT == what) { //      . act_socket.update_status(active_socket_t::poll_out); self-&gt;schedule_wait_write_for(act_socket); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Here it is necessary to note a few points. <br><br>  The moment the first.  We are given a socket handle with which we need to do something.  But, in principle, not the fact that this socket will still be in our dictionary of active sockets.  Therefore, we perform operations on the socket only if it is found in our dictionary. <br><br>  The second moment.  We first forcibly reset all flags for a particular active socket.  And then we calculate their new values ‚Äã‚Äãand save the new flags.  We then need them inside the event_cb (). <br><br>  Well, the third point: depending on what we need to wait (read, write or read-write), we ask Asio to start monitoring the readiness of our socket for the corresponding operation.  This is done by calling the helper methods: <br><br><pre> <code class="hljs php">void curl_multi_processor_t::schedule_wait_read_for( active_socket_t &amp; act_socket) { act_socket.socket().async_wait( restinio::asio_ns::ip::tcp::socket::wait_read, restinio::asio_ns::bind_executor(strand_, [this, s = act_socket.handle()]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> auto &amp; ec ){ this-&gt;event_cb(s, CURL_POLL_IN, ec); })); } void curl_multi_processor_t::schedule_wait_write_for( active_socket_t &amp; act_socket) { act_socket.socket().async_wait( restinio::asio_ns::ip::tcp::socket::wait_write, restinio::asio_ns::bind_executor(strand_, [this, s = act_socket.handle()]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> auto &amp; ec ){ this-&gt;event_cb(s, CURL_POLL_OUT, ec); })); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, in the schedule_wait _ * _ for methods, we specify lambda functions that Asio will call when the socket is ready for the corresponding operation. </font><font style="vertical-align: inherit;">Here we see the first call to event_cb. </font><font style="vertical-align: inherit;">This is another tricky callback, which will be discussed below.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Not very tricky callback: timer_function </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the curl_multi_performer_t constructor, another callback is set for the curl_multi instance: the static timer_function method of the following form: </font></font><br><br><pre> <code class="hljs ruby">int curl_multi_processor_t::timer_function( CURLM *, long timeout_ms, void * userp) { auto <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = cast_to(userp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(timeout_ms &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   . <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>-&gt;timer<span class="hljs-number"><span class="hljs-number">_</span></span>.cancel(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span> == timeout_ms) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     -   . <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>-&gt;check_timeouts(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    . <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>-&gt;timer<span class="hljs-number"><span class="hljs-number">_</span></span>.cancel(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>-&gt;timer<span class="hljs-number"><span class="hljs-number">_</span></span>.expires_after(std::chrono::milliseconds{timeout_ms}); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>-&gt;timer<span class="hljs-number"><span class="hljs-number">_</span></span>.async_wait( restinio::asio_ns::bind_executor(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>-&gt;strand<span class="hljs-number"><span class="hljs-number">_</span></span>, [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>](const auto &amp; ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !ec ) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>-&gt;check_timeouts(); })); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With him, everything is more or less simple. </font><font style="vertical-align: inherit;">libcurl-in during the processing of requests need to control the time-outs of its operations.</font></font> But since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libcurl in our case does not have its own event-loop, then it needs our help. To do this, we set a timer callback, and libcurl calls it when it needs to control the times of its operations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The actions performed by timer callbacks depend entirely on the value of the timeout_ms argument. If there is -1, then the current timer must be canceled. If the value is 0, then you need to call curl_multi_socket_action with the CURL_SOCK_TIMEOUT parameter as quickly as possible (we immediately make this call). If timeout_ms is greater than 0, then you need to reset the timer for a new time. And when that time comes, you need to call curl_multi_socket_action. What we are doing in the lambda, which is passed to the Asio-shny timer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's also look at the helper function that we call when the timer is triggered:</font></font><br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">curl_multi_processor_t</span></span>::check_timeouts() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running_handles_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  curl    . curl_multi_socket_action(curlm_, CURL_SOCKET_TIMEOUT, 0, &amp;running_handles_count); //      -. check_curl_op_completion(curlm_); }</span></span></code> </pre> <br>    :   curl_multi_socket_action  CURL_SOCKET_TIMEOUT,    check_curl_op_completion() ,    - . <br><br><h4>   callback: event_cb </h4><br>        callback-  .    event_cb(),   Asio,  Asio ,      /,       - . <br><br>       event_cb,    ,    : <br><br><pre> <code class="hljs perl">void curl_multi_processor_t::event_cb( curl_socket_t <span class="hljs-keyword"><span class="hljs-keyword">socket</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> what, const restinio::asio_ns::error_code &amp; ec) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       .  ,   //   .       . auto it = active_sockets<span class="hljs-number"><span class="hljs-number">_</span></span>.find(<span class="hljs-keyword"><span class="hljs-keyword">socket</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(it != active_sockets<span class="hljs-number"><span class="hljs-number">_</span></span>.end()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ec ) what = CURL_CSELECT_ERR; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> running_handles_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  curl    . curl_multi_socket_action(curlm<span class="hljs-number"><span class="hljs-number">_</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">socket</span></span>, what, &amp;running_handles_count ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      -. check_curl_op_completion(curlm<span class="hljs-number"><span class="hljs-number">_</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(running_handles_count &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) //    .    . timer<span class="hljs-number"><span class="hljs-number">_</span></span>.cancel(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      , ..     //  curl_multi_socket_action  check_active_sockets. it = active_sockets<span class="hljs-number"><span class="hljs-number">_</span></span>.find(<span class="hljs-keyword"><span class="hljs-keyword">socket</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec &amp;&amp; it != active_sockets<span class="hljs-number"><span class="hljs-number">_</span></span>.end()) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       . auto &amp; act_socket = *(it-&gt;second); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,        //  . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CURL_POLL_IN == what &amp;&amp; <span class="hljs-number"><span class="hljs-number">0</span></span> != (active_socket_t::poll_in &amp; act_socket.status())) { schedule_wait_read_for(act_socket); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CURL_POLL_OUT == what &amp;&amp; <span class="hljs-number"><span class="hljs-number">0</span></span> != (active_socket_t::poll_out &amp; act_socket.status())) { schedule_wait_write_for(act_socket); } } } }</code> </pre> <br>      ,    event_cb.          . , libcurl    -  -.          . <br><br>     curl_multi_socket_action.    ,      what.      ,     ,   event_cb (..  CURL_POLL_IN,  CURL_POLL_OUT,      schedule_wait_*_for).    Asio  -     (    ec    ),     what    CURL_CSELECT_ERR. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we pull curl_multi_socket_action so that libcurl can perform all the operations it needs for the socket. And, after leaving curl_multi_socket_action, we traditionally check to see if any requests have completed. Well, one more thing: if, after exiting curl_multi_socket_action, we find that there are no more current operations, then cancel the timer. He's not needed anymore. Although, in principle, it is not necessary to do this. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But then begins some kind of obvious magic ... :)</font></font><br><br>   curl_multi_socket_action()  check_curl_op_completion()     , curl_easy-,    ,   .     ?      .    ,    libcurl.        ,  libcurl     . <br><br>     curl_multi_socket_action()  ,           .       Asio,         -. <br><br>     ,      . - -    -.    . <br><br>    ,     curl_multi_socket_action()  check_curl_op_completion()       active_sockets_   ,    ‚Äî  .   curl_multi_socket_action()   callback-,    callback-      ,       active_sockets_. <br><br>     curl_multi_socket_action()       .  ,  ,          schedule_wait_*_for.    ,   ,  libcurl    curl_multi_socket_action()       (  socket_function   CURL_PULL_IN),     . , libcurl             .           ,   ,     event_cb. <br><br><h4>    callback-: open_socket_function  close_socket_function </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains to parse the two callbacks, which are used to create and destroy sockets for libcurl. </font><font style="vertical-align: inherit;">It is these callbacks that are registered in each new curl_easy instance through the CURLOPT_OPENSOCKETFUNCTION and CURLOPT_CLOSESOCKETFUNCTION properties. </font><font style="vertical-align: inherit;">Here is the code for these functions:</font></font><br><br><pre> <code class="hljs pgsql">curl_socket_t curl_multi_processor_t::open_socket_function( <span class="hljs-type"><span class="hljs-type">void</span></span> * cbp, curlsocktype <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, curl_sockaddr * addr) { auto self = cast_to(cbp); curl_socket_t sockfd = CURL_SOCKET_BAD; //       IPv4. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CURLSOCKTYPE_IPCXN == <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> &amp;&amp; AF_INET == addr-&gt;<span class="hljs-keyword"><span class="hljs-keyword">family</span></span>) { //  ,       //   . auto act_socket = std::make_unique&lt;active_socket_t&gt;(self-&gt;ioctx_); const auto native_handle = act_socket-&gt;handle(); //         . self-&gt;active_sockets_.emplace( native_handle, std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(act_socket) ); sockfd = native_handle; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sockfd; } <span class="hljs-type"><span class="hljs-type">int</span></span> curl_multi_processor_t::close_socket_function( <span class="hljs-type"><span class="hljs-type">void</span></span> * cbp, curl_socket_t socket) { auto self = cast_to(cbp); //        . //      active_socket_t. self-&gt;active_sockets_.erase(socket); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We hope that in this case there will be no difficulties with understanding. </font><font style="vertical-align: inherit;">At least in close_socket_function, everything is more than trivial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But on the open_socket_function you need to give an explanation. </font><font style="vertical-align: inherit;">The schematic diagram of this function was taken from the already mentioned </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asiohiper.cpp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> example </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">There was a restriction on working only with IPv4, which is why we left it at home. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, adding support for IPv6 should not be difficult. </font><font style="vertical-align: inherit;">To do this, we need to slightly modify the constructor active_socket_t:</font></font><br><br><pre> <code class="hljs ruby">active_socket_t( restinio::asio_ns::io_service &amp; io_service, restinio::asio_ns::ip::tcp tcp) : socket<span class="hljs-number"><span class="hljs-number">_</span></span>{io_service, tcp} {}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And to alter the open_socket_function part, for example, in this way: </font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CURLSOCKTYPE_IPCXN == <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> &amp;&amp; (AF_INET == addr-&gt;<span class="hljs-keyword"><span class="hljs-keyword">family</span></span> || AF_INET6 == addr-&gt;<span class="hljs-keyword"><span class="hljs-keyword">family</span></span>)) { //  ,       //   . auto act_socket = std::make_unique&lt;active_socket_t&gt;(self-&gt;ioctx_, AF_INET == addr-&gt;<span class="hljs-keyword"><span class="hljs-keyword">family</span></span> ? restinio::asio_ns::ip::tcp::v4() : restinio::asio_ns::ip::tcp::v6());</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So how does it still work? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we will try to do the most difficult thing: to combine the general description of the principles of work from the beginning of the article and the explanations made when parsing the code. To try again to explain how the whole kitchen works. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, there is a pool of workflows. Asio-shny io_context works on this pool. This io_context serves both RESTinio and libcurl. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When RESTinio receives an incoming request, this request is converted to request_info_t and sent to curl_multi_performer_t. There for this request_info_t a new instance of curl_easy is created. And this curl_easy is added to a single curl_multi instance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libcurl asks us to create a new socket for curl_easy. We create it in open_socket_function and save it in the dictionary of active sockets.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, libcurl jerks for a new socket, a socket_function, in which it says, what kind of operation is it willing to wait for the new socket. At this point, the value of CURL_POLL_OUT or CURL_POLL_INOUT is passed to the socket_function. We update the status for the socket and make Asio wait for the socket to write.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When Asio detects that the socket is ready to write, we call event_cb. In which we pull curl_multi_socket_action. There, inside curl_multi_socket_action, libcurl can send an HTTP request to a remote server. And call the socket_function in order to ask us to wait until the socket is ready to read (in this case, CURL_POLL_IN or CURL_POLL_INOUT is passed to the socket_function). We again update the status for the socket and make it wait for the readiness of the socket to read. At the same time, we are still inside the curl_multi_socket_action, which is called inside the event_cb :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When Asio detects that the socket is ready for reading, then we again call event_cb. In which we again pull curl_multi_socket_action ...</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And all this continues until we find that the HTTP request is complete. Then we form the answer to the incoming HTTP request, we withdraw the corresponding curl_eary from curl_multi, and then we destroy both curl_easy and request_info_t. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what about the socket? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the socket continues to live inside libcurl. It can be reused by libcurl to handle other requests. And the code will be deleted sometime in the future. If at all required.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That, in general, is all that we wanted to tell. </font><font style="vertical-align: inherit;">Thanks to everyone who was able to master all three articles. </font><font style="vertical-align: inherit;">We hope you find something interesting for yourself. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The demos described in this series can be found </font></font><a href="https://bitbucket.org/sobjectizerteam/async_restinio_async_libcurl_ru"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in this repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integration with a pure C-shny code, of course, delivered. </font><font style="vertical-align: inherit;">It was, we can safely say, the confirmation of popular wisdom: if you want to write in C without pain - write in C ++;) And it remains only to regret that there is no native C ++ equivalent of libcurl. </font><font style="vertical-align: inherit;">For with all due respect to libcurl, it should be noted that its use requires very serious attention to details.</font></font></div><p>Source: <a href="https://habr.com/ru/post/349986/">https://habr.com/ru/post/349986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349972/index.html">Disabling PowerShell and other ways to combat Malware, Part II</a></li>
<li><a href="../349974/index.html">3 interesting spring ICOs: gold-backed cryptocurrency, a cure for HIV and earnings on hedge funds</a></li>
<li><a href="../349978/index.html">Wrong understanding of the principle of DRY</a></li>
<li><a href="../349980/index.html">Benjamin Franklin method for reading programming books</a></li>
<li><a href="../349982/index.html">The dark side of the serverless architecture or the complexity of estimating the real cost of serverless computing</a></li>
<li><a href="../349988/index.html">Dot wow effects: magic with simple words</a></li>
<li><a href="../349990/index.html">How to use response compression in ASP.Net Core</a></li>
<li><a href="../349992/index.html">Wi-Fi in law</a></li>
<li><a href="../349994/index.html">Fear of public speaking</a></li>
<li><a href="../349996/index.html">Binary ternary bit magic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>