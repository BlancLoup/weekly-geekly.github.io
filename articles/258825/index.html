<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Œª-calculus and LISP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A typical lover of Œª-calculus. 

 One day, surfing the internet, I came across news of a lis-like, embedded programming language Shen . Previously, th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Œª-calculus and LISP</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/648/2fb/2ef/6482fb2efdee4059a8bf33db92ec567f.jpg"><br>  <i>A typical lover of Œª-calculus.</i> <br><br>  One day, surfing the internet, I came across news of a lis-like, embedded programming language <a href="http://www.shenlanguage.org/">Shen</a> .  Previously, they had a Lisp code on their home page.  In the example, the authors describe the abstract collection and functions of working with them. <br><br>  It just so happened that I am a secret admirer of functional programming, which means, to some extent, lambda calculus, which consists almost entirely of abstractions.  I wanted to write something as abstract as possible and, in order to complicate my task, I decided that the built-in data types are for weak applicationists, and everything must be implemented in terms of Church coding. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I was familiar with the lambda calculus very superficially, since almost always the articles on this branch of mathematics consist entirely of formulas that cannot be tried in practice in any way.  Therefore, the idea came to deal with him in practice, and it is possible to attract the adherents <s>of the Turing machine of the</s> PLO to the dark side. <br><br>  If you're not afraid of Lisp, a lot of lambdas and y-combinator (not the one with the news), <br><a name="habracut"></a><br><h3>  Introduction </h3><br>  The article does not claim to be complete coverage of the material or to replace the <a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">SICP</a> .  I am not a mathematician, much less am I an expert on lambda calculus.  The only thing she claims is linearity of presentation.  In the text, the task is to acquaint readers with the functions as <a href="https://en.wikipedia.org/wiki/First-class_citizen">first-class citizens</a> and make it as interesting as possible for the lambda calculus.  In the process of writing code, I will try to explain what is happening in a simple language understandable to engineers. <br><br>  Today, there is a strong tendency to borrow concepts from functional programming with imperative languages ‚Äã‚Äã(even in C ++, after 30 years, the committee went to such an adventurous act. And yes, Java8), so there is hope that this article will be useful to someone.  Naturally, if there are lambda calculator lovers on Habr√© that can correct me, add comments. <br><br>  So, ‚Äúwhy was Lisp chosen?‚Äù You ask.  There are several reasons for this.  The first is that all examples in articles on functional programming are written in Haskell.  The second is the already mentioned book: Structure and Interpretation of Computer Programs, which is one of my favorite books and which I recommended reading to anyone who has not done so yet.  Third, because Lisp is for real hackers. <br><br><img src="https://habrastorage.org/files/02b/503/efb/02b503efbc214a4d85ded27fe5ca599e.png"><br>  <i>Good old joke</i> <br><br>  On Habr√© there are several articles on lambda calculus.  For example, <a href="http://habrahabr.ru/post/176233/">here</a> and <a href="http://habrahabr.ru/post/215807/">here</a> .  Some of them reveal the theory more widely than I try to do, so I would advise you to read at least one of them to understand what we will do.  I will not give here the whole theory in order not to complicate the article.  To write our abstractions, we will have enough articles on Wikipedia (all real programmers write programs like this).  English-language articles broader topics, so you can use articles about <a href="http://en.wikipedia.org/wiki/Lambda_calculus">Lambda Calculus</a> and a more detailed article describing <a href="http://en.wikipedia.org/wiki/Church_encoding">Church Encoding</a> types of coding. <br><br>  We also need to know the programming language LISP.  But do not worry if you do not know him, because the whole syntax of it consists of brackets, we will quickly learn it.  All we need to know is how lambda terms are written in Lisp and, a little later, to shorten the record, several functions.  It is enough to know that in Lisp, to execute a function, you need to enclose its call in brackets, in which the first argument will be the name of the function, followed by parameters (very similar to <a href="http://en.wikipedia.org/wiki/Polish_notation">Polish notation</a> ).  That is, to find the amount you need to write (+ 2 3), to merge strings (string-append "Hello" "world!").  It is also worth saying that there are a myriad of Lisp dialects.  We will use <a href="http://racket-lang.org/">Racket</a> due to a convenient development environment, but almost all of the code will work with most dialects (you may need to use other functions to manipulate strings, etc.).  All download links and installation instructions can be found on the site language. <br><br><h3>  Œª-calculus </h3><br>  If you followed my advice, read about lambda calculus, you already know that there are three rules for a term in it: <br><ul><li>  variable <b>x</b> , in Lisp is written in the same way, using the variable name; </li><li>  Lambda abstraction <b>(Œªx.t)</b> , can be written as a normal function, known to us from all programming languages: (define (fun x) t);  or as a nameless lambda (lambda (x) t). </li><li>  the application <b>(ts)</b> is a normal function call, and this is what is recorded in the Racket (ts). </li></ul><br>  So, by declaring a function and calling it, we will try to write a type system and help us with the encoding of Church (you should have the Wikipedia tab open where it is written about it).  As the author of the English-language article wrote, this encoding allows you to represent data types and operators in terms of lambda calculus.  We will check it out. <br><br>  The slight disadvantage of Lisp being chosen is that the function always requires you to give it all the arguments, rather than <a href="http://en.wikipedia.org/wiki/Currying">curry</a> , as Haskell or ML, for example, does.  Therefore, we will need to explicitly use lisp-lambda, or use the curry function.  I will try to talk about it as needed. <br><br>  Also in Racket some names we need are already reserved, so all our functions will be written with a capital letter. <br>  We start development environment of DrRacket and go. <br><br><h3>  Boolean values </h3><br>  We start from Boolean values, they are <i>True</i> and <i>False</i> .  In the beginning, their implementation may seem a bit strange - in lambda terms everything looks strange.  In the future we will make sure that it works. <br><br>  The Boolean data type for is of value to us only if we can distinguish them from each other.  This can be done using the <i>If</i> operator (function).  This type is already described on Wikipedia (all types are described there), and using Lisp we will transfer them to the editor. <br><br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">True</span></span> ab) a) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">False</span></span> ab) b) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">If</span></span> cab) (<span class="hljs-name"><span class="hljs-name">cab</span></span>))</code> </pre> <br>  Using the interactive interpreter Racket (located below in our IDE), we can test the performance of our boolean logic.  Types are functions that take two arguments and return either the first (in the case of True) or the second (False).  The If statement simply calls them with the correct branches: <br><br><pre> <code class="python hljs">&gt; (If <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-string"><span class="hljs-string">"first"</span></span> <span class="hljs-string"><span class="hljs-string">"second"</span></span>) <span class="hljs-string"><span class="hljs-string">"first"</span></span> &gt; (If <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-string"><span class="hljs-string">"first"</span></span> <span class="hljs-string"><span class="hljs-string">"second"</span></span>) <span class="hljs-string"><span class="hljs-string">"second"</span></span></code> </pre><br>  But that is not all.  We are used to checking several conditions at the same time.  Therefore, we need to expand our Boolean logic and introduce operators (we‚Äôre looking at Wikipedia again).  Functions are not complicated.  We write: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">And</span></span> pq) (<span class="hljs-name"><span class="hljs-name">pqp</span></span>)) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Or</span></span> pq) (<span class="hljs-name"><span class="hljs-name">ppq</span></span>)) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Not</span></span> p) (<span class="hljs-name"><span class="hljs-name">p</span></span> False True))</code> </pre><br>  Everything is simple: <i>And the</i> function, in case of successful completion of the first condition, checks the second;  <i>Or</i> , if successful, returns itself; if unsuccessful, checks the second value;  <i>Not</i> swaps predicates.  Be sure to check: <br><br><pre> <code class="python hljs">&gt; (If (And <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-string"><span class="hljs-string">"first"</span></span> <span class="hljs-string"><span class="hljs-string">"second"</span></span>) <span class="hljs-string"><span class="hljs-string">"second"</span></span> &gt; (If (And <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-string"><span class="hljs-string">"first"</span></span> <span class="hljs-string"><span class="hljs-string">"second"</span></span>) <span class="hljs-string"><span class="hljs-string">"first"</span></span> &gt; (If (Or <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-string"><span class="hljs-string">"first"</span></span> <span class="hljs-string"><span class="hljs-string">"second"</span></span>) <span class="hljs-string"><span class="hljs-string">"first"</span></span> &gt; (If (Or <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-string"><span class="hljs-string">"first"</span></span> <span class="hljs-string"><span class="hljs-string">"second"</span></span>) <span class="hljs-string"><span class="hljs-string">"second"</span></span> &gt; (If (Or <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> (Not <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)) <span class="hljs-string"><span class="hljs-string">"first"</span></span> <span class="hljs-string"><span class="hljs-string">"second"</span></span>) <span class="hljs-string"><span class="hljs-string">"first"</span></span></code> </pre><br>  All, you can consider yourself experts lambda calculus.  But we will not stop there.  It is worth noting here that I will use the types we are used to for simplicity.  Further, when we have enough of our types, we will operate with them.  For now, we will use strings and numbers for illustration. <br><br><h3>  Integers </h3><br>  Natural numbers are numbers that are used for counting.  We use Arabic numerals and decimal notation.  But in fact, natural numbers themselves are a very interesting abstraction and are often cited as an example of using <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a> . <br><br>  To represent numbers, we implement the so-called Church numerals (Church numbers).  The number in this encoding is a function that takes the current value and the growth function.  For example, in the case of ordinary arithmetic, it can be 3 and +1.  In the end, applying the growth function N times to the initial value, we obtain the natural number that represents it.  I do not want to use ordinary arithmetic to describe it.  I'll show you why later. <br><br>  We have already been sufficiently savvy in technical terms.  It's time to start implementation.  For illustration, we will use the usual representations of natural numbers: Arabic numerals and strings.  For numbers, the growth function will be a function that adds a number to a unit ( <i>PlusOne</i> ), for strings - a concatenation function with another string, where as the other string we will have sticks "|", like in school ( <i>Concat</i> ): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Nil</span></span> fx) x) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">One</span></span> fx) (<span class="hljs-name"><span class="hljs-name">fx</span></span>)) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Two</span></span> fx) (<span class="hljs-name"><span class="hljs-name">f</span></span> (<span class="hljs-name"><span class="hljs-name">fx</span></span>))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">PlusOne</span></span> x) (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> x)) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Concat</span></span> x) (<span class="hljs-name"><span class="hljs-name">string-append</span></span> x <span class="hljs-string"><span class="hljs-string">"|"</span></span>))</code> </pre><br>  Here it becomes clear why I deliberately avoided using numbers when describing natural numbers.  This is because the Church digits are self-contained values.  If you try to enter 'Two' in the interpreter, you will see that the interpreter returns the lambda # &lt;procedure: Two&gt;.  But, if you do not want to define with your hands the whole set of natural numbers, but you want to get a visual representation of the natural number, you need to pass in the parameters the function of increasing the value and the initial value.  The proof for this is our interpreter: <br><br><pre> <code class="python hljs">&gt; Two <span class="hljs-comment"><span class="hljs-comment">#&lt;procedure:Two&gt; &gt; (Two Concat "") "||" &gt; (Two PlusOne 0) 2</span></span></code> </pre><br>  We declared 3 natural numbers in which the execution of the function is nested into each other.  But it would be nice to use for example the number 99 to define 100, and not to write a hundred nested function calls.  In this case, we are in a hurry to help the functions of the next and previous elements.  We implement the functions and immediately rewrite our numbers: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Succ</span></span> nfx) (<span class="hljs-name"><span class="hljs-name">f</span></span> (<span class="hljs-name"><span class="hljs-name">nfx</span></span>))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Pred</span></span> nfx) ((<span class="hljs-name"><span class="hljs-name">n</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">g</span></span>) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">h</span></span>) (<span class="hljs-name"><span class="hljs-name">h</span></span> (<span class="hljs-name"><span class="hljs-name">gf</span></span>)))) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">u</span></span>) x)) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">u</span></span>) u))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Null</span></span> fx) x) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">One</span></span> fx) (<span class="hljs-name"><span class="hljs-name">Succ</span></span> Null fx)) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Two</span></span> fx) (<span class="hljs-name"><span class="hljs-name">Succ</span></span> One fx)) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Three</span></span> fx) (<span class="hljs-name"><span class="hljs-name">Succ</span></span> Two fx)) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Four</span></span> fx) (<span class="hljs-name"><span class="hljs-name">Succ</span></span> Three fx)) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Five</span></span> fx) (<span class="hljs-name"><span class="hljs-name">Succ</span></span> Four fx))</code> </pre><br>  The function of increasing the number is quite simple, but the reduction is more difficult.  For the next in order number, we simply wrap the source with another function call.  To take a predecessor, a function is used that skips the first use of the growth function in the chain of application of the function <i>f</i> . <br><br>  It is obvious that in lambda calculus there should be arithmetic operations with natural numbers, otherwise they would not be numbers at all.  See the Wikipedia page and rewrite: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Plus</span></span> mn) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">fx</span></span>) (<span class="hljs-name"><span class="hljs-name">mf</span></span> (<span class="hljs-name"><span class="hljs-name">nfx</span></span>)))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Minus</span></span> mn) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">fx</span></span>) ((<span class="hljs-name"><span class="hljs-name">n</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">t</span></span>) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">rs</span></span>) (<span class="hljs-name"><span class="hljs-name">Pred</span></span> trs))) m) fx))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">MinusC</span></span> mn) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">fx</span></span>) ((<span class="hljs-name"><span class="hljs-name">n</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">t</span></span>) (<span class="hljs-name"><span class="hljs-name">curry</span></span> Pred <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) m) fx))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Mul</span></span> mn) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">fx</span></span>) (<span class="hljs-name"><span class="hljs-name">m</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">y</span></span>) (<span class="hljs-name"><span class="hljs-name">nfy</span></span>)) x))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">IsZero</span></span> n) (<span class="hljs-name"><span class="hljs-name">n</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">x</span></span>) False) True)) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Eq</span></span> mn) (<span class="hljs-name"><span class="hljs-name">IsZero</span></span> (<span class="hljs-name"><span class="hljs-name">Minus</span></span> mn)))</code> </pre><br>  <i>Plus</i> applies the function first n times, then another m.  <i>Minus</i> applies the function of the previous element to the number to be reduced (you can use currying to get a more readable entry: <i>MinusC</i> ).  The multiplication function m repeats n applications of the function.  Check for zero: as is known <i>IsZero</i> returns its argument without using functions, then we get True, and all the numbers ignore their argument more and return False.  The equality test makes subtraction and checks for zero (since we do not have negative numbers, we also need to check the other way).  There is division and raising to a power too, but we will not implement them.  They are on the page, try to write yourself.  Now, with the help of operations, we can determine more numbers: tens and hundreds: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Ten</span></span> fx) (<span class="hljs-name"><span class="hljs-name">Mul</span></span> Five Two)) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Hundred</span></span> fx) (<span class="hljs-name"><span class="hljs-name">Mul</span></span> Ten Ten))</code> </pre><br>  And draw a hundred sticks: <br><br><pre> <code class="python hljs">&gt; (Hundred Concat <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-string"><span class="hljs-string">"||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||"</span></span> &gt; ((Plus Two (Mul Four Ten)) PlusOne <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-number"><span class="hljs-number">42</span></span> &gt; (IsZero Null) <span class="hljs-comment"><span class="hljs-comment">#&lt;procedure:True&gt; &gt; (IsZero Two) #&lt;procedure:False&gt; &gt; (Eq Two Two) #&lt;procedure:True&gt; &gt; (Eq Two One) #&lt;procedure:False&gt;</span></span></code> </pre><br><br><h3>  Couple </h3><br>  Let's continue with a couple of values.  In lambda calculus, a pair is a function that closes two arguments and ‚Äúwaits‚Äù for a function, which can then be applied to these values.  Obvious candidates for such functions are taking the first or second element: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Pair</span></span> ab) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">f</span></span>) (<span class="hljs-name"><span class="hljs-name">fab</span></span>))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">First</span></span> p) (<span class="hljs-name"><span class="hljs-name">p</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">ab</span></span>) a))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Second</span></span> p) (<span class="hljs-name"><span class="hljs-name">p</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">ab</span></span>) b)))</code> </pre><br>  The access functions to the element take a pair and ‚Äúfeed‚Äù it a lambda, which returns the first or second argument, respectively.  Checking: <br><br><pre> <code class="python hljs">&gt; (First (Pair <span class="hljs-string"><span class="hljs-string">"first"</span></span> <span class="hljs-string"><span class="hljs-string">"second"</span></span>)) <span class="hljs-string"><span class="hljs-string">"first"</span></span> &gt; (Second (Pair <span class="hljs-string"><span class="hljs-string">"first"</span></span> <span class="hljs-string"><span class="hljs-string">"second"</span></span>)) <span class="hljs-string"><span class="hljs-string">"second"</span></span></code> </pre><br>  With the help of the pair, we can implement many abstractions: for example lists and tuples. <br><br><h3>  Lists </h3><br>  Lists are the most frequently used and often studied collection in functional programming.  In the already mentioned SICP booklet, the lists are reviewed in great detail.  Actually ‚ÄúLISP‚Äù itself stands for <b>Lis</b> t <b>P</b> rocessing Language.  Therefore, we will approach them with full responsibility and enthusiasm.  On the Internet, you can often stumble upon a description of the lists in the style of lambda calculus. <br><br>  Actually, the list is nothing more than a pair of values ‚Äã‚Äã(we already have a pair): the head element and the tail, which is a continuation of the list.  Wikipedia describes 3 ways to encode lists: <br><ul><li>  using a pair as an element.  This allows the first element of the pair to store an indicator that the list is empty.  This option is good because the function with elements is very simple - depending on the void indicator, you can perform the first or second function; </li><li>  using one element, and in the empty list store false.  In this case, the list view has a shorter record, but the work is a bit more complicated than in the first case; </li><li>  define a list using <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">the right convolution function</a> .  It does not suit us, because it is difficult. </li></ul><br>  We will choose the first option, so it is the most obvious.  To output the elements of the list, use the Lisp function 'display', which outputs its argument to the terminal.  Additionally, we define the output function for numbers and sticks.  Let me remind you that each item in our list is another pair, where the first item is True if the list is empty and False if it contains a meaningful item.  Rewrite: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">NatToNumber</span></span> m) (<span class="hljs-name"><span class="hljs-name">display</span></span> (<span class="hljs-name"><span class="hljs-name">m</span></span> PlusOne <span class="hljs-number"><span class="hljs-number">0</span></span>))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">NatToString</span></span> m) (<span class="hljs-name"><span class="hljs-name">display</span></span> (<span class="hljs-name"><span class="hljs-name">m</span></span> Concat <span class="hljs-string"><span class="hljs-string">""</span></span>))) <span class="hljs-comment"><span class="hljs-comment">; ... (define (Nil) (Pair True True)) (define (IsNil) First) (define (Cons ht) (Pair False (Pair ht))) (define (Head l) (First (Second l))) (define (Tail l) (Second (Second l))) (define (ProcessList lf) ((If (IsNil l) (lambda ()(void)) (lambda ()(f (Head l)))))) (define (ConsZeroList n) (n (lambda (l) (Cons Null l)) (Nil))) (define (ConsRangeList n) (Second (n (lambda (p) (Pair (Minus (First p) One) (Cons (First p) (Second p)))) (Pair n (Nil)))))</span></span></code> </pre><br>  While we do not know how to iterate through the list, because we do not know how to do recursion.  Therefore, all we have to do is manually sort through the elements and work with them.  The <i>ProcessList</i> function applies the passed argument function to the current head element, or does nothing if the list is empty.  It is worth noting that the <a href="http://en.wikipedia.org/wiki/Evaluation_strategy">normal order is</a> used in the lambda calculus.  This means that the functions first wrap their arguments, and then they are executed.  In Lisp, the <a href="http://en.wikipedia.org/wiki/Evaluation_strategy">applicative order</a> is used ‚Äî the function arguments are evaluated before being passed.  In the body of the <i>ProcessList</i> function when checking with If, we don‚Äôt want to execute both branches at the same time, so we have to transfer lambdas to the execution branches and call the one that comes back after the check.  <i>ConsZeroList</i> creates a list of zeros, the required length, and ConsRangeList creates a list from a sequence of numbers.  They are based on the repeated use by the natural number of a function over an element.  Check in the interpreter: <br><br><pre> <code class="python hljs">&gt; (define L1 (Cons One (Cons Two (Cons Three (Nil))))) &gt; (ProcessList L1 NatToNumber) <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; (ProcessList (Tail (Tail L1)) NatToNumber) <span class="hljs-number"><span class="hljs-number">3</span></span> &gt; (ProcessList (Tail (Tail (Tail L1))) NatToNumber) &gt;</code> </pre><br><br><h3>  Y-combinator </h3><br>  So, we have reached the apogee of our article.  In order to process the entire list, we need to be iterated on it.  At the moment we do not know how to do it.  And this can be done using <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">Y-combinator</a> , aka Fixed-point combinator, aka fixed point combinator.  To understand why it is so called, you need to read a lot of text.  It is enough for us to know that if to transfer the function to it, it will transfer itself to the first argument of the function.  With this we can recursively perform operations on objects (for example, lists). <br><br>  The Y-combinator is very well explained in <a href="http://mvanier.livejournal.com/2897.html">Mike Venier's article</a> .  Wikipedia has a precise definition of a combinator.  In the above article, there is a Lisp code.  We need a function for applicative order.  Just rewriting.  In the same place, we look at the factorial calculation function, which we can rewrite for our natural numbers: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Y</span></span> f) ((<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">x</span></span>) (<span class="hljs-name"><span class="hljs-name">xx</span></span>)) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">x</span></span>) (<span class="hljs-name"><span class="hljs-name">f</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">y</span></span>) ((<span class="hljs-name"><span class="hljs-name">xx</span></span>) y)))))) (<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">Fac</span></span> n) ((<span class="hljs-name"><span class="hljs-name">Y</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">f</span></span>) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">m</span></span>) ((<span class="hljs-name"><span class="hljs-name">If</span></span> (<span class="hljs-name"><span class="hljs-name">Eq</span></span> m Null) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> () One) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> () (<span class="hljs-name"><span class="hljs-name">Mul</span></span> m (<span class="hljs-name"><span class="hljs-name">f</span></span> (<span class="hljs-name"><span class="hljs-name">Minus</span></span> m One))))))))) n))</code> </pre><br>  Check the result.  The factorial of ten, due to the fact that our function creates almost 4 million lambdas, and then executes them, is calculated for a rather long time: <br><br><pre> <code class="python hljs">&gt; (NatToNumber (Fac Five)) <span class="hljs-number"><span class="hljs-number">120</span></span> &gt; (NatToNumber (Fac Ten)) <span class="hljs-number"><span class="hljs-number">3628800</span></span></code> </pre><br>  Now take up the lists.  With the help of the Y-combinator, we implement the favorite trinity of functions for list processing: Map, Filter, Reduce;  and a function for output: <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;Lists (define (PrintList l) (display "[") ((Y (lambda (r) (lambda (m) ((If (IsNil m) void (lambda () (NatToNumber (Head m)) (display ", ") (r (Tail m)))))))) l) (display "]")) (define (Map lf) ((Y (lambda (r) (lambda (m) ((If (IsNil m) Nil (lambda () (Cons (f (Head m)) (r (Tail m))))))))) l)) (define (Filter lf) ((Y (lambda (r) (lambda (m) ((If (IsNil m) Nil (lambda () ((If (f (Head m)) (lambda () (Cons (Head m) (r (Tail m) f))) (lambda () (r (Tail m) f)))))))))) l)) (define (Reduce lfz) ((Y (lambda (r) (lambda (m) ((If (IsNil m) z (lambda () (f (Head m) (r (Tail m) fz)))))))) l))</span></span></code> </pre><br>  The implementation of these functions is described in many articles, so I will not talk a lot about them.  Better apply them in practice: <br><br><pre> <code class="python hljs">&gt; (PrintList (ConsRangeList Ten)) [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, ] &gt; (PrintList (Map (ConsRangeList Ten) (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> (x) (Plus x One)))) [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, ] &gt; (PrintList (ConsZeroList Ten)) [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ] &gt; (PrintList (Map (ConsZeroList Ten) (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> (x) (Plus x Hundred)))) [<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, ] &gt; (PrintList (Filter (ConsRangeList Ten) (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> (x) (Not (Eq x Five))))) [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, ] &gt; (NatToNumber (Reduce (ConsRangeList Ten) (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> (xy) (Plus xy)) Null)) <span class="hljs-number"><span class="hljs-number">55</span></span> &gt; (NatToNumber (Reduce (ConsZeroList Ten) (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> (xy) (Plus xy)) Null)) <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><br><h3>  Epilogue </h3><br>  So, using only the functions we were able to implement everything that a regular functionary needs for programming.  I hope you liked the material.  Lambda calculus deserves to be at least familiar with it.  For 30 years, functional languages ‚Äã‚Äãhave been predicted to kill the PLO and imperative languages.  But today more and more is created by the multi-programming language.  Perhaps that is why Haskell never became widespread. <br><br>  Nevertheless, the mathematical beauty of the lambda calculus will attract programmers of all specialties for many decades. <br><br>  All code can be viewed / downloaded on <a href="https://github.com/alexander-smoktal/lambda-calculus">github</a> . <br><br>  UPD: In the comments <a href="http://habrahabr.ru/users/mapron/" class="user_link">mapron</a> remembered a <a href="http://habrahabr.ru/post/248331/">similar publication</a> with a code in Javascript. </div><p>Source: <a href="https://habr.com/ru/post/258825/">https://habr.com/ru/post/258825/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258811/index.html">New experimental C ++ operators</a></li>
<li><a href="../258815/index.html">Docker workflow</a></li>
<li><a href="../258817/index.html">Simulation of aircraft flap fault scenarios using Wolfram SystemModeler</a></li>
<li><a href="../258819/index.html">Fungi hunting is a suspicious hobby</a></li>
<li><a href="../258823/index.html">How Yandex built a data center from scratch</a></li>
<li><a href="../258827/index.html">Moving KodiCMS from the Kohana Framework to Laravel 5</a></li>
<li><a href="../258831/index.html">HP Helion Rack - a solution for the rapid deployment of a private cloud based on OpenStack</a></li>
<li><a href="../258833/index.html">Displaying the content of iOS applications in Google Search results and other good news</a></li>
<li><a href="../258841/index.html">Criteria for the quality of video analytics. Part 4</a></li>
<li><a href="../258845/index.html">SAN soup. We build virtual SAN on the Windows Server 2012 R2 platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>