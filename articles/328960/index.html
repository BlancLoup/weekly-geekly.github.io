<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ionic 2 vs React Native: a comparison of frameworks for creating corporate mobile applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mobile data access speeds up the company's business processes. Mobile coordination of memos or approval of vacations is a familiar component of work i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ionic 2 vs React Native: a comparison of frameworks for creating corporate mobile applications</h1><div class="post__text post__text-html js-mediator-article">  Mobile data access speeds up the company's business processes.  Mobile coordination of memos or approval of vacations is a familiar component of work in corporations.  Every employee has mobile devices, so the company can use these devices without investing in them.  A large zoo of mobile devices must be considered when developing a corporate mobile application: it should work and have the same appearance on all devices. <br><br>  In this publication, we consider the creation of such corporate mobile applications using various JavaScript frameworks. <br><a name="habracut"></a><br>  Corporate mobile apps are usually distributed through the company's internal app stores.  This makes it possible to control access to applications within the company, as well as forcibly install application updates centrally.  For the development and delivery of corporate mobile applications, an appropriate infrastructure, known as the Mobile Enterprise Application Platform (MEAP), is required. <br><br>  For MEAP, an analyst from leading companies Gartner and Forrester was conducted and a comparison of existing platforms and vendors was made ( <a href="https://www.gartner.com/doc/3099221/magic-quadrant-mobile-application-development">Gartner Magic Quandrant</a> and <a href="https://www.forrester.com/report/The%2BForrester%2BWave%2BMobile%2BDevelopment%2BPlatforms%2BQ4%2B2016/-/E-RES133266">Forrester Wave,</a> respectively).  All the leaders of these comparisons are considering the possibility of creating native and hybrid applications.  Native applications are written using specific platform programming languages ‚Äã‚Äã(swift or Objective C for iOS, Java for Android).  Hybrid mobile applications are written in JavaScript using various libraries and frameworks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Using JavaScript frameworks allows you to create new mobile applications by the existing front-end development team.  For the company, this means that the same team can perform different tasks - website development, mobile application development. <br><br>  Among the leading frameworks, there are two of the most popular frameworks: Ionic 2 and React Native.  Then each of them is considered separately, and their comparison is also performed.  The comparison was performed for only two operating systems: iOS and Android. <br><br>  Most corporate applications that are used on mobile are very simple.  The employee is provided with the minimum amount of data necessary for making a decision.  Another aspect of such applications is the need to enter data during operation.  Given the limitations of mobile devices (form factor), data entry forms will also not be large.  These nuances were taken into account when evaluating the created mobile applications (and comparing them with native mobile applications written in the languages ‚Äã‚Äãnative to each platform).  The corporate mobile application does not require super-high performance (such as in applications with millions of users from Facebook), it is necessary that such an application does not ‚Äúslow down‚Äù on relatively simple forms. <br><br><h1>  Ionic 2 </h1><br>  <a href="http://ionicframework.com/">Ionic Framework</a> is a framework for creating hybrid mobile applications.  It includes a set of JavaScript and CSS components created on the basis of Angular 2, SASS and Apache Cordova.  The history of this SDK begins in 2013, when the company Drifty Co.  decided to create its own infrastructure for writing hybrid applications, which will be focused on performance and will be built using modern web standards.  Release Ionic 1 - held in May 2015.  Version 2 was released in 2016. The main difference between the second release and the first one is the transition from Angular 1.x to Angular 2.x. <br><br>  At its core, the Ionic Framework is an addition to the very popular Apache Cordova framework, but with its powerful CLI (Command Line Interface) and extensive documentation.  Following the principles of Apache Cordova, applications on the Ionic Framework are hybrid HTML applications.  Such applications on the phone run in a special shell (UIWebView for iOS and WebView for Android), which allows you to display HTML and execute JavaScript.  Accordingly, when working in the application, the user works as if in a web browser. <br><br><img src="https://habrastorage.org/web/250/212/58c/25021258cfe9471783d8ae651203592b.png"><br>  <font color="#999999"><i>Apache Cordova application architecture ( <a href="https://cordova.apache.org/docs/en/latest/guide/overview/index.html">source</a> )</i></font> <br><br>  Apache Cordova is a kind of layer between the user interface and device resources.  Any user interface widgets or MV * (Model-View) frameworks are not included.  If you need to use UI widgets and / or MV * framework, then you need to select and include them in the application yourself, as third-party resources.  Ionic 2 is one of the frameworks that provides UI widgets.  The MVC model for it provides the Angular 2. <br><br>  Native phone features (for example, camera, key storage, GPS coordinates) are not accessible from a web browser.  Therefore, <a href="https://cordova.apache.org/docs/en/latest/guide/support/index.html">Apache Cordova plugins</a> are used to work with them.  In addition to the official plug-ins, there are a number of third-party open plug-ins. <br><br><h1>  React native </h1><br>  <a href="https://facebook.github.io/react-native/">React Native</a> is a JavaScript framework developed by Facebook to create native mobile applications using JavaScript.  The history of React Native began in 2013 with Facebook‚Äôs internal hackathon project.  React Native was first publicly told at React.js Conf in January 2015, in March 2015 at F8 it was announced that React Native is available on GitHub.  The framework is built on the basis of the ReactJS library.  React Native uses JavaScript API on top of native components.  When creating an application, it writes JavaScript code that works with the native components of the operating system.  That is, React Native uses the same fundamental standard UI blocks as regular iOS and Android applications without using either the browser or WebView / UIWebView. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/e31/deb/d0b/e31debd0b7b442bdac71287e3b1963e5.png"></div><br>  <font color="#999999"><i>React Native application architecture ( <a href="http://moduscreate.com/leverage-existing-ios-views-react-native-app/">source</a> )</i></font> <br><br>  An application on React Native uses a separate thread to execute javascript in the device.  This thread interacts with the native code.  It is important to note that native components (including user interface elements) are different for different operating systems.  And, accordingly, for each operating system it is necessary to create its own ‚Äúbridges‚Äù between the JavaScript code and these components.  A number of such components are provided by Facebook, and there are also many freely available components developed by the community. <br><br><h1>  Ionic 2 vs React Native </h1><br>  Ionic 2 and React Native allow you to create mobile applications.  The fundamental difference between these frameworks lies in the type of mobile application that is created using one or another framework.  Ionic 2 allows you to create a hybrid mobile application that renders in WebView / UIWebView; if you need to use the platform API, you need to use additional plugins.  React Native allows you to create a native mobile application using the fundamental UI building blocks (like regular iOS and Android applications written in the native language Objective-C / Swift and Java, respectively).  The application on React Native uses certain templates defined by the platform itself. <br><br><img src="https://habrastorage.org/web/64e/479/79c/64e47979cc2e4d9ab8cab99c6ebcab8c.png" width="45%"><img src="https://habrastorage.org/web/f91/9da/b51/f919dab51e134a00aa92fc5d4a6e0541.png" width="45%"><br>  <font color="#999999"><i>Code execution and communication with the native API in applications written in Ionic 2 (left) and React Native (right)</i></font> <br><br>  The diagram shows the components of the application code and the call to the native API from the applications.  In the case of Ionic 2, the user interface is rendered by the browser, and for React Native, the operating system itself.  This difference manifests itself in more familiar component rendering and smoother application animations on React Native.  The user interface of React Native applications will be closer to other applications of the platform.  Since an application written in React Native is compiled into a platform native language, it is not necessary to use additional intermediate components (for example, Cordova), often this gives better application performance.  Performance issues are one of the problems with Ionic 2. <br><br>  When a native event occurs, the frameworks handle it differently.  Ionic 2 blocks the stream and transfers control to the JavaScript code, waiting for its instructions.  React Native runs JavaScript in a separate background thread, interacting with the main thread asynchronously. <br><br><h2>  Code </h2><br>  For creating an application on Ionic 2, the frameworks Angular 2 and Apache Cordova are used.  The application can be written in JavaScript or any other language that is broadcast in JavaScript.  The most popular typed JS superset is TypeScript, introduced by Microsoft in 2012 and positioned as a web application development tool that extends JavaScript capabilities, and most of the examples in the Angular 2 documentation are implemented in it. Angular 2 implements the dependency injection design pattern Dependency Injection), which consists of 3 elements: <br><br><ul><li>  Injector - provides API access for dependency injection </li><li>  Provider - describes how to create a dependency instance;  has a marker pointing to the factory function that creates the object </li><li>  Dependency - the type to which the created object belongs. </li></ul><br>  In addition, Angular 2 uses a component approach that allows you to share business logic, work with the front.  In addition, the separation is also used at the level of the project elements: HTML, JavaScript and CSS are saved in separate files. <br><br>  In order to start writing an application on React Native, you need to get acquainted with ReactJS, JSX.  It is also recommended to work with Redux and EcmaScript 2015 to speed up development, but knowledge of these components is optional. <br><br>  You can also use Flow - this is a static code analyzer and a set of syntactic structures to directly indicate the type of variable.  Flow can calculate the type of a variable, without making changes to the code (unlike TypeScript), which allows you to start using it now in any project.  It is possible to independently specify types in the TypeScript style. <br><br>  In the process of writing an application on React Native, you create components that are self-sufficient, each component is responsible for changes in its state.  There are stateless and stateful components.  Components that do not have a state can transmit properties (props are set by the parent component and are fixed during the entire <a href="https://facebook.github.io/react-native/docs/state.html">life cycle of the component</a> ). <br><br><h2>  Debug </h2><br>  Debugging applications in Ionic 2 is standard for front-end developers.  After running the application on the emulator / device, it is possible to debug applications using Safari web inspector (iOS only) or Chrome Developer tools.  These tools provide access to HTML, CSS, and JavaScript.  During debugging, you can quickly edit styles, search for nodes in html, execute and watch the result of JavaScript functions, as well as network requests.  In addition to running on a device or an emulator, in the case of Ionic 2, it is also possible to launch the application directly in the browser ( <code>ionic serve</code> ).  This can speed up development, and with the help of the <code>ionic serve --lab</code> testing applications on different diagonals of screens and platforms is simplified. <br><br>  Ionic 2 has a Live Reload option.  It allows you to make changes to the code and see these changes on the device / emulator without rebuilding.  However, it is not always possible to use it.  After starting due to working in a web browser when using http requests, we encounter a <a href="https://en.wikipedia.org/wiki/Cross-Origin_Resource_Sharing">CORS</a> problem. <br><br>  To debug applications on React Native, it is possible to use Chrome Developer Tools.  If development is carried out on devices from Apple, then it is possible to use the Safari web inspector for an emulator or an iOS device.  To view the view items, you can select the ‚ÄúShow inspector‚Äù option in the Emulator / Device Developer Menu.  At the same time, you can see the styles of elements, but changing them is possible only in the IDE (the method for quickly editing styles in developer tools does not work here).  But using LiveReload or HotReload options within a few seconds, the saved changes will be visible on the emulator / device.  If global changes are made to the code, it is better to rebuild the project.  Also in the Developer Menu is the Network tab, which allows you to track HTTP requests.  Here you can see the type of request, method, url, and more.  After debugging in the browser it is unusual.  For debugging, you can also use IDE for each of the platforms - Android Studio and Xcode, with which you can examine in detail all the logs and operation of the application (resource consumption, speed, etc.). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/3f8/e4f/650/3f8e4f6505c043b190cd454b0791af65.png" width="50%"></div><br>  <font color="#999999"><i>An example of debugging an application created with React Native on an iPhone 6 smartphone (iOS 10.2)</i></font> <br><br>  Building a debug application written in Ionic 2, in a browser, is faster than building an application on an emulator using React Native.  It is also worth noting that the start of the finished application Ionic 2 on the device, slower than in a similar application on React Native. <br><br>  Thus, debugging applications on Ionic 2 is faster and more familiar to front-end developers. <br><br><h2>  Styles </h2><br>  Ionic 2 is written HTML5 code and uses the familiar front-end developer SASS.  There are no restrictions on dimensional units, the SASS preprocessor is used, flex marking can also be applied.  I often had to redefine Ionic 2 variables. But sometimes this was not enough, it was necessary to study the final html in the browser, see what additional elements were generated and what styles they had to understand what and where to redefine or add.  Also, a significant difference was in the display of elements on different platforms.  What looked good on iOS devices sometimes broke styles on Android devices, it was necessary to find compromises. <br><br>  In React Native, the creation of styles is different from the usual for frontend developer.  Here css-detailed syntax is used, which is written as a js object.  Then this object with ‚Äústyles‚Äù is transformed into understandable platform instructions for the location and coloring of elements. <br><br>  Imposition is performed by absolute values, no relative values.  A big plus is the use of flex-like markup when styling components, which allows you to resize the component depending on the size of the container.  If you specify " <code>flex: 1</code> ", then the component will occupy all the available space.  If there are several components, they evenly distribute among themselves all the available space.  This minimizes the time spent on styles, since this approach will allow you to display elements in proportion to the size of the screen.  Both on the phone and on the tablet, the result is the same, nothing ‚Äúdoes not leave‚Äù and ‚Äúdoes not crawl‚Äù.  Almost always for applications on RN styles are valid for both platforms.  If the styles are still interrupted, the binding to the platform is used.  For example, in our application there was a situation when it was necessary to use zIndex - everything worked perfectly on iOS, but on Android this property (which was applied to the Header component) contributed to incorrect display of other interface elements (Tabs). <br><br>  Styling in Ionic 2 took longer than in React Native.  But the design of our application was fairly simple and minimalist.  Perhaps, when developing complex design solutions, having access to a full-featured css, Ionic 2 would have won in time and convenience. <br><br><h2>  Sizes of applications </h2><br>  For both frameworks, there are "empty" applications - these are application frameworks with minimal code.  Such applications are generated using the CLI: <br><br><ul><li>  Ionic 2: <code>ionic start myApp blank --v2</code> </li><li>  React Native: <code>react-native init AwesomeProject</code> </li></ul><br>  Empty applications were going in two modes: debug and release.  The first mode is designed for debugging the application, the second - for the direct delivery of ready-made applications to end users. <br><br><table><tbody><tr><th></th><th colspan="2">  Ionic 2 </th><th colspan="2">  React native </th></tr><tr><th></th><th>  Debug application </th><th>  Application in release mode </th><th>  Debug application </th><th>  Application in release mode </th></tr><tr><td>  <nobr>iOS</nobr> </td><td>  18.3 Mb </td><td>  17.9 Mb </td><td>  4.8 Mb </td><td>  4.6 Mb </td></tr><tr><td>  <nobr>Android</nobr> </td><td>  5.54 Mb </td><td>  4.0 Mb </td><td>  32.38 Mb </td><td>  16.35 Mb </td></tr></tbody></table><br>  Applications on different frameworks have different sizes on different platforms.  Ionic 2 wins on Android, and React Native wins on iOS. <br><br><h2>  The popularity and activity of frameworks </h2><br>  When comparing the popularity of frameworks, you need to consider that React Native is a younger technology.  Initially, React Native had only iOS support.  Android support in React Native appeared only in August 2015, and the Ionic Framework at that time was developing for more than two years (although it had version 1.0) and had the support of all popular platforms. <br><br>  Popularity and activity were compared by the two most popular resources: stackoverflow and github. <br><br>  For the Ionic Framework on stackoverflow, there are about 60000 results for Ionic and Ionic 2. When reviewing the statistics on <a href="https://github.com/driftyco/ionic/">the Github repository,</a> it is important to note that in mid-2016, <a href="https://github.com/driftyco/ionic2">the Ionic 2 code</a> migrated to the Ionic repository.  In the Ionic repository, more than 200 participants made about 6000 commits in 15 branches with 88 releases.  The project repository contains ~ 700 open questions and ~ 9000 closed. <br><br>  For React Native on stackoverflow, there are about 25,000 results for react-native.  Statistics on the <a href="https://github.com/facebook/react-native">Github React Native</a> repository show that this framework is more active than Ionic 2: more than 1200 participants made about 10,000 commits in 60 branches with 160 releases.  There are ~ 1100 open questions and ~ 7000 closed questions in the repository of the project. <br><br>  It is possible to look at statistics of use of frameworks on open resources (for example, on <a href="https://stackshare.io/stackups/ionic-vs-react-native">stackshare.io</a> ).  According to the <a href="http://www.npmtrends.com/react-native-vs-ionic">statistics of NPMTrends</a> (statistics on downloading npm packages), you can see that over the past year Ionic 2 has been leading the downloads with confidence, but in the past few months React Native takes the lead. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/74e/637/d63/74e637d6321944919d48b71c6799d7db.png"></div><br>  <font color="#999999"><i>Download statistics for npm packages</i></font> <br><br>  The framework sites also have examples of ready-made applications: <a href="http://showcase.ionicframework.com/apps/top">applications on Ionic 2</a> , <a href="https://facebook.github.io/react-native/showcase.html">applications on React Native</a> .  For both frameworks, there are a large number of third-party Starter Kit that will help create an application with a ready-made structure ( <a href="https://market.ionic.io/starters">Starter Kits Ionic Framework</a> , <a href="https://strapmobile.com/">Starter Kits React Native</a> ). <br><br>  The development and use of the React Native framework has recently become more active. <br><br><h1>  Ionic 2 vs React Native: a comparison by example </h1><br>  The task of comparing Ionic 2 and React Native in practice was set for the front-end developers team. <br><br><h2>  Business Process Applications on Camunda BPM </h2><br>  To select the framework, which we will later use to write mobile applications, we wrote a mobile client for <a href="https://camunda.org/">Camunda BPM</a> .  Camunda BPM is a BPMS (Business Process Management System) in which our team of backend developers implemented a number of business processes. <br><br>  For implementation in the mobile client, we chose one business process - the process ‚ÄúApplication for equipment‚Äù.  This business process consists of several steps: creating an application, approving various roles (head of department, system administrator, technical department, accounting, deputy general director), directly issuing equipment.  During the business process, the application may be returned to the initiator for editing.  Some of the approval steps are assigned to a team of specialists. <br><br><img src="https://habrastorage.org/web/fd1/018/09b/fd101809bab54afea393b393d4d17516.png"><br>  <font color="#999999"><i>Business Process Chart ‚ÄúApplication for Equipment‚Äù</i></font> <br><br>  The form with which the user works depends on the status of the application and the rights of the user.  In the form it was possible to enter only text data.  Some forms are dynamic, for example, the ‚Äúcomment‚Äù field is displayed depending on the action selected by the user (Approve / Decline). <br><br>  In the application, the user works in this way: <br><br><ol><li>  To create a new task, the user selects the required process from the list of available ones.  After selecting the user displays a screen with a form for registration of the application. </li><li>  After creating the Application, the user returns to the task list, which is presented on three tabs: <br><br><ul><li>  tasks created by the user; </li><li>  tasks awaiting user decision; </li><li>  tasks that are assigned to a group of people where the user can take on their decision; <br></li></ul></li><li>  If the user has access to the Application, then for each task he can review the information in the application in detail and view the history of its completion. </li><li>  If the user makes a decision on the application, then part of the Application form becomes available for editing with options for making a decision. </li><li>  When working with applications, a task search is also available, which displays the results at the user's request. </li><li>  The application has user authentication functions. </li></ol><br>  A mobile client that performs the functions described above was implemented on each of the frameworks we compared. <br><br><h2>  Comparisons of Ready Applications </h2><br>  While testing our application, we compared the rendering speed of the page depending on the framework and platform.  For this, an additional test page was created in each project.  The data for the drawing was generated in a loop without accessing the server.  From these data, 1000 ‚ÄúCard‚Äù elements were created, the rendering time of which was measured.  The ‚ÄúCard‚Äù component eforgively it can be represented by such html: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">header</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span>Task Name<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">header</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span><span class="hljs-tag">&gt;</span></span>Subscribe<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>date<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Each component (relevant for both the framework) has a life cycle: the component will be mounted, the component will be drawn, the component will be deleted, and so on.  All of these phases have methods, the so-called lifecycle-methods, and that is what we used to conduct the tests.  Testing was conducted using the <code>time()</code> and <code>timeEnd()</code> methods of the Console object. <br><br>  For a React Native project, the <code>time()</code> method was called in <code>componentWillMount</code> (this method is called only once before rendering is the first time), and the <code>timeEnd()</code> method is called in componentDidMount (this method is called only once, after the first rendering). <br><br>  For a project on Ionic 2, the <code>time()</code> method was called in the <code>constructor</code> (the first life cycle event that runs when the page was created), and the <code>timeEnd()</code> method was called in <code>ionViewDidEnter</code> (reports that everything is fine and that the page is fully loaded and fully entered into field of view, the transition animation with any internal setup is completed). <br><br>  Testing was conducted on the emulator and on the device.  Testing for iOS devices - on the iPhone SE emulator (iOS 10.2), on the device - iPhone SE (iOS 10.2.1);  for Android devices - on the Asus Nexus 7 emulator (Android 6), on the device - Asus Nexus 7 (Android 6.0.1).  The table shows the average drawing time of 1000 ‚ÄúCard‚Äù elements in milliseconds. <br><table><tbody><tr><th></th><th>  IPhone SE Simulator </th><th>  iPhone SE </th><th>  Simulator Nexus 7 </th><th>  Asus nexus 7 </th></tr><tr><td>  <nobr>Ionic 2</nobr> </td><td>  5354.6 - 5272.5 </td><td>  5663.1 - 5859.5 </td><td>  1401.3 - 1750.6 </td><td>  7040.3 - 9385.4 </td></tr><tr><td>  <nobr>React native</nobr> </td><td>  36.1 - 47.6 </td><td>  32.5 - 35.2 </td><td>  45.4 - 56.1 </td><td>  44.1 - 52.3 </td></tr></tbody></table><br>  Directly for our application, we compared CPU and memory usage for iPhone SE (iOS 10.2.1) and Moto Z Play (Android 7.0) devices. <br><br><img src="https://habrastorage.org/web/e74/2f8/3ef/e742f83ef5ad4c99b694b7331b9db404.png"><br>  <font color="#999999"><i>CPU usage</i></font> <br><br><img src="https://habrastorage.org/web/3fa/5d3/c08/3fa5d3c08765404e9bec2fd6ceeec110.png"><br>  <font color="#999999"><i>Memory usage</i></font> <br><br>  Ionic 2 is inferior to React Native in almost all tested parameters, except for the use of memory on Android (the <a href="https://www.youtube.com/watch%3Fv%3DjuWhxCz1Wmg">application load time test is</a> especially interesting). <br><br>  As in the case of "empty" mobile applications, ready-made mobile applications on different platforms differ several times. <br><table><tbody><tr><th></th><th colspan="2">  Ionic 2 </th><th colspan="2">  React native </th></tr><tr><th></th><th>  Debug application </th><th>  Application in release mode </th><th>  Debug application </th><th>  Application in release mode </th></tr><tr><td>  <nobr>iOS</nobr> </td><td>  17.5 Mb </td><td>  17.4 Mb </td><td>  6.6 Mb </td><td>  6 Mb </td></tr><tr><td>  <nobr>Android</nobr> </td><td>  6.78 Mb </td><td>  4.6 Mb </td><td>  33.64 Mb </td><td>  16.79 Mb </td></tr></tbody></table><br>  Ionic 2 wins on the use of CPU and application size on Android.  React Native on the same parameters - on iOS. <br><br><h1>  findings </h1><br>  Corporate applications for mobile devices, created using JavaScript, have occupied their niche.  The speed of such applications is sufficient compared to applications written in native platform languages.  In general, one cannot say that some kind of framework is better, and some kind is worse.  They are just different.  The choice depends on the tasks, the ultimate goal and many other factors.  In general, we can recommend using Ionic 2 for the rapid development of prototypes of mobile applications, and React Native - for the full development of ready-made solutions.  Below is a list of the advantages and disadvantages of each framework, based on our impressions of using Ionic 2 and React Native. <br><br>  Advantages of Ionic 2: <br><br><ul><li>  a well-known set of tools - for a frontend developer, the set of technologies used is familiar, it significantly reduces the time for the task </li><li>  quick start - using the application templates provided to us by Ionic, you can create a prototype in a short time to show to the customer (we are talking only about the methods of the frameworks described on the official websites, we have not considered third-party Starter Kit) </li><li>  "Write once, run anywhere" - the written application works on all popular platforms, it gives cross-platform with minor code changes </li></ul><br>  Disadvantages of Ionic 2: <br><br><ul><li>  stylization - changing the default styles to bring them in accordance with the layout significantly increases the time spent on creating and testing applications on different platforms and devices </li><li>  Browser use - longer application load and poor responsiveness when the CPU is loaded due to using the browser shell to simulate the behavior of components of each platform </li><li>  native functions - when a native event occurs, the main thread is blocked and control is passed to the JavaScript code, waiting for its instructions, which can lead to unpredictable operation of native functions </li></ul><br>  Benefits of React Native: <br><br><ul><li>  standard native UI blocks ‚Äî the use of the fundamental standard UI blocks, like regular iOS and Android applications, familiar to the user from other native applications, facilitates user interaction with the application </li><li>  non-blocking javascript execution - javascript runs in a separate background thread, interacting with the main thread asynchronously </li><li>  styling - the application looks equally good on different platforms and devices </li><li>  load on the CPU - tests carried out by the application using the CPU and memory show better results compared to Ionic 2 </li></ul><br>  Disadvantages of React Native: <br><br><ul><li>  the need to work with native platform code - it may be necessary to understand the components written in ObjectiveC / Swift or Java </li><li>  complexity of the start (without experience with ReactJS) - additional time is needed for getting to know React, JSX and a different writing approach (components as separate interface units that are responsible for their own state and behavior) </li></ul><br><h1>  useful links </h1><br>  <strong>Ionic 2</strong> <br><br><ul><li>  <a href="http://ionicframework.com/">Ionic Framework official site</a> </li><li>  Article on Habrahabr <a href="https://habrahabr.ru/post/302084/">"Ionic: comments on myths after a year of use"</a> </li><li>  <a href="http://docs.usecreator.com/">Ionic creator</a> </li><li>  <a href="http://www.gajotres.net/must-have-plugins-for-ionic-framework/">Must-have plugins for Ionic Must-have plugins for Ionic Framework</a> </li></ul><br>  <strong>React native</strong> <br><br><ul><li>  <a href="https://facebook.github.io/react-native">The official website of React Native</a> </li><li>  A set of useful links <a href="https://github.com/jondot/awesome-react-native">Awesome React Native</a> </li><li>  <a href="https://habrahabr.ru/post/249393/">Announcement React Native</a> (Habrahabr) </li><li>  Tutorial <a href="https://habrahabr.ru/post/323214/">"React Native - one JS is not enough"</a> </li><li>  <a href="https://tadeuzagallo.com/blog/react-native-bridge/">In Depth description of React Native and its interaction with the mobile platform</a> </li><li>  <a href="https://medium.com/the-react-native-log/comparing-the-performance-between-native-ios-swift-and-react-native-7b5490d363e2">Comparison of iOS performance on swift and React Native</a> </li><li>  <a href="https://snack.expo.io/">Sandbox for running React Native in the browser</a> </li><li>  <a href="http://www.gajotres.net/must-have-plugins-for-react-native/">React Native Plugins</a> </li><li>  <a href="https://blog.expo.io/using-react-devtools-with-react-native-6c59e636a03b">Using react-devtools with React Native</a> </li></ul><br>  <strong>Comparing Ionic (2) and React Native</strong> <br><br><ul><li>  <a href="http://www.techexceed.com/react-native-vs-ionic-2-framework/">React Native vs Ionic 2 framework: Side-by-Side Comparison</a> </li><li>  <a href="https://www.codementor.io/fmcorz/react-native-vs-ionic-du1087rsw">React Native vs Ionic: A Side-by-Side Comparison</a> </li><li>  <a href="https://medium.com/react-id/ionic-framework-hybrid-app-vs-react-native-4facdd93f690">Ionic Framework vs React Native</a> (medium) </li></ul></div><p>Source: <a href="https://habr.com/ru/post/328960/">https://habr.com/ru/post/328960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328946/index.html">Kotlin is the official development language for Android. We understand the intricacies of the language on Stepik</a></li>
<li><a href="../328952/index.html">Implementing drag & drop functionality in an iOS application</a></li>
<li><a href="../328954/index.html">Creating a Web API application using. NET Core + MongoDB. NET Driver</a></li>
<li><a href="../328956/index.html">Register for the webinar "From WannaCry to WannaSaveU". Attack visibility and recovery</a></li>
<li><a href="../328958/index.html">Network microsegmentation in examples: how this cleverly twisted thing reacts to different attacks</a></li>
<li><a href="../328962/index.html">Android and architecture</a></li>
<li><a href="../328964/index.html">Analysis of errors in the seller</a></li>
<li><a href="../328966/index.html">How are developed industry and specialized solutions for 1C: ERP</a></li>
<li><a href="../328970/index.html">Building a modular architecture of the application on Forwarding decorators (author's translation)</a></li>
<li><a href="../328972/index.html">Nice to meet you. LANIT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>