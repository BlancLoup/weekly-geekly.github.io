<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write LR (0) -analyzer. Simple words about the difficult</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 Good day. 
 I did not find a simple and clear description of this algorithm in Russian. I decided to fill this gap. First of all what ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write LR (0) -analyzer. Simple words about the difficult</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br><br>  Good day. <br>  I did not find a simple and clear description of this algorithm in Russian.  I decided to fill this gap.  First of all what is it?  LR (0) -analyzer is primarily a parser.  The purpose of the parser is to process the input stream of tokens (basic elements of the language that the lexical analyzer produces based on the input stream of characters, examples of tokens - number, comma, symbol) and compare it with the description of the language specified in a specific format.  The mapping is to build a specific data structure, most often a tree.  Then this structure will go to the next stage - semantic analysis, where the compiler is already trying to understand the meaning contained in the tree. <br><br>  There are 2 classes of parsers - ascending and descending analyzers.  The first build a tree starting from the leaves, which are input tokens, the second, respectively, on the contrary, start from the root of the tree.  Actually LR means that the analyzer will read the flow from left to right (L - 'Left') and build a tree from the bottom up (let the letter R, which means Right, do not confuse, explanations are given just below).  Index 0 means that we do not preview the following lexemes, but work only with the current one.  What advantages does the choice of this type of analyzers give us? <br><ul><li>  He is fast. </li><li>  Covers many languages.  That is, if you invented a language and described it, then most likely the LR analyzer will be able to process it. </li><li>  Syntax errors are detected as quickly as possible.  As soon as the character that does not correspond to the previous input stream is encountered, we can output an error about it. </li></ul><br>  There are disadvantages: <br><ul><li>  Relative complexity of construction. </li><li>  You can drive the analyzer into a stupor with the ambiguity of the language description. </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  Terminology </h4><br><br>  <b>Terminal symbol</b> ( <b>terminal</b> , <b>terminal</b> ) is a symbol that can be given to the analyzer as a user, in our case these are lexemes. <br>  <b>A non-terminal symbol</b> ( <b>non-terminal</b> , <b>nonterminal</b> ) is a symbol that denotes an object of a language.  For example, let us specify that the symbol A is a term.  Of course, we can choose multi-character names - term instead of A. <br>  <b>Context-free grammar</b> ( <b>CFG</b> ) - a set of rules of the form <img src="http://imagepost.ru/images/843/rule.gif" alt="image">  , where A is a non-terminal, w is an arbitrary set of terminals and non-terminals.  In the article, I will use just grammar, meaning by this precisely context-free. <br>  A small example of grammar for which we will build an analyzer: <br><img src="http://www.imagepost.ru/images/843/rules.gif" alt="image"><br>  This grammar describes an incomplete set of arithmetic operations on two numbers - 0 and 1. The grammar is a description of the language.  In order to check if the input stream belongs to our language, or somewhere we made a syntax error (wrote 1+, instead of 1 + 1), we are looking for a possible way of obtaining this input stream following the rules starting from the starting terminal (we have this E).  For 1 + 1, the path will be E, apply rule 2, E + F, rule 1, F + F, rule 4, T + F, rule 8, 1 + F, again 4, 1 + T, and at the end the eighth, 1 + 1. As we see, we were able to get the input string, which means that it is syntactically correct. <br>  Now we can explain the letter R in the name of the analyzer.  It means that we go from the extreme right parts of the rules to the axiom, that is, from the more simple rules (7 and 8) we collect the original (1).  L-analyzers (LL) try to select the following direction of analysis on the left-hand sides of the rules. <br><br>  We should also mention the <b>state machines</b> ( <b>Final-state machine</b> , <b>FSM</b> ).  This is a model that has a set of states and an input stream.  The machine starts from the initial state and changes its state based on the current and input symbol.  That is, we start with state 0, if a is received at the input, then the automaton goes to state 1, and if b goes to state 2. The transition mechanics is given by the table, where the columns are the current state, and the columns are the input symbol. <br><br><h4>  Algorithm </h4><br><br>  The analyzer needs several things to work with it: <br><ul><li>  The input stream itself, which will be analyzed. </li><li>  The stack (the data structure that meets the LIFO (Last In First Out) rule) is easiest to imagine as a stack of sheets - put the sheet in the stack last, and take it first when you need an element from the stack for the parser states. </li><li>  Action table  It tells us what to do in the current state and with the current character at the input. </li><li>  Conversion table  Auxiliary table that is used in one of the actions. </li></ul><br><br>  Here it is necessary to clarify how the analyzer will work.  The current state is the state at the top of the stack.  We look at the table of actions (indexes are the current input symbol and the current state).  There are 4 types of entries in this table: <br><ul><li>  success (accepted) - means that the input string belongs to this grammar. </li><li>  void (error) - there are no actions, we are at a dead end, the user was mistaken with the current symbol. </li><li>  carry (shift) - put the state that corresponds to the input symbol on the top of the stack, read the following </li><li>  convolution (reduce) - we have a stack of states that we can replace with one, using the grammar rule, here we take the value in the transition table.  The first index is the current state.  The second is the left side of the rule.  That is, in what we turned the sequence of states. </li></ul><br><br>  As code, it looks like this: <br><blockquote><ol><li>  stack.  <font color="#007788">push</font> <font color="#008000">(</font> states <font color="#008000">[</font> <font color="#0000dd">0</font> <font color="#008000">]</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#000040">!</font> accepted <font color="#008000">)</font> </li><li>  <font color="#008000">{</font> </li><li>  State <font color="#000040">*</font> st <font color="#000080">=</font> stack.  <font color="#007788">top</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  Terminal term <font color="#000080">=</font> s <font color="#008000">[</font> inp_pos <font color="#008000">]</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">if</font> <font color="#008000">(</font> <font color="#000040">!</font> terms. <font color="#007788">IsTerm</font> <font color="#008000">(</font> term <font color="#008000">)</font> <font color="#008000">)</font> </li><li>  error <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  Action <font color="#000040">*</font> action <font color="#000080">=</font> actionTable.  <font color="#007788">Get</font> <font color="#008000">(</font> st, term <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">if</font> <font color="#008000">(</font> <font color="#000040">!</font> action <font color="#008000">)</font> </li><li>  error <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">switch</font> <font color="#008000">(</font> action <font color="#000040">-</font> <font color="#000080">&gt;</font> Type <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> </li><li>  <font color="#008000">{</font> </li><li>  <font color="#0000ff">case</font> ActionAccept <font color="#008080">:</font> </li><li>  accepted <font color="#000080">=</font> <font color="#0000ff">true</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">break</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">case</font> ActionShift <font color="#008080">:</font> </li><li>  inp_pos <font color="#000040">++</font> <font color="#008080">;</font> </li><li>  stack.  <font color="#007788">push</font> <font color="#008000">(</font> action <font color="#000040">-</font> <font color="#000080">&gt;</font> State <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">break</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">case</font> ActionReduce <font color="#008080">:</font> </li><li>  Rule <font color="#000040">*</font> rule <font color="#000080">=</font> action <font color="#000040">-</font> <font color="#000080">&gt;</font> Rule <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  stack.  <font color="#007788">pop</font> <font color="#008000">(</font> rule <font color="#000040">-</font> <font color="#000080">&gt;</font> Size <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  State <font color="#000040">*</font> transferState <font color="#000080">=</font> transferTable.  <font color="#007788">Get</font> <font color="#008000">(</font> stack. <font color="#007788">Top</font> <font color="#008000">(</font> <font color="#008000">)</font> , rule <font color="#000040">-</font> <font color="#000080">&gt;</font> Left <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">if</font> <font color="#008000">(</font> <font color="#000040">!</font> transferState <font color="#008000">)</font> </li><li>  error <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  stack.  <font color="#007788">push</font> <font color="#008000">(</font> transferState <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">break</font> <font color="#008080">;</font> </li><li>  <font color="#008000">}</font> </li><li>  <font color="#008000">}</font> </li></ol></blockquote><br><br>  As you can see, there is nothing difficult in the analysis itself.  However, the whole trick lies in the construction of these tricky tables.  For a start, let's see what the state of the parser is.  This is a rather nontrivial part of the algorithm.  And no, it's not just a number.  We will have to introduce a number of new concepts. <br>  First of all, these are items.  This is a rule with a new property - a marker.  The marker indicates which item we are currently waiting for.  Accordingly, each rule generates n + 1 markers, where n is the number of characters in the right part of the rule.  For example, take rule 3. Plus in the circle indicates the place of the marker. <br><img src="http://www.imagepost.ru/images/843/items_example.gif" alt="image"><br>  The marker in the second paragraph, for example, indicates that we expect to see a minus sign in the current character.  Combining multiple items is a item set.  Actually, the state is a set of items gathered together in a certain way. <br><br>  But to work with states, we first need to close the set.  This means that we want to get a full-fledged analyzer branch.  That is, if there is a point in the set in which the marker points to a non-terminal (and all of our non-terminals are left parts), then the corresponding non-terminal must be ‚Äúexpanded‚Äù.  This happens by simply adding points, the left parts of which are this non-terminal, and the marker points to the first character.  By itself, we expand recursively, if in the newly added paragraph the first character is a non-terminal, then we also close it.  Until we get a full set.  Close the set in which only one item (number 3 in the previous example): <br><img src="http://www.imagepost.ru/images/843/closure.gif" alt="image"><br>  Deploying F, we get points 2, 3, 4. In 3 and 4 again we are offered to deploy F, however we already have these rules in the set, so we skip it.  But T is not deployed, having done this, we get 5 and 6. Everything, the closure is ready. <br><br><blockquote><ol><li>  <font color="#0000ff">for</font> <font color="#008000">(</font> closed_item in itemset <font color="#008000">)</font> </li><li>  <font color="#008000">{</font> </li><li>  <font color="#0000ff">if</font> <font color="#008000">(</font> closed_item. <font color="#007788">isClose</font> <font color="#008000">)</font> </li><li>  <font color="#0000ff">continue</font> <font color="#008080">;</font> </li><li>  Element marker <font color="#000080">=</font> closed_item.  <font color="#007788">Marker</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">if</font> <font color="#008000">(</font> marker. <font color="#007788">Type</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000040">!</font> <font color="#000080">=</font> ElementNonTerm <font color="#008000">)</font> </li><li>  <font color="#008000">{</font> </li><li>  closed_item  <font color="#007788">isClose</font> <font color="#000080">=</font> <font color="#0000ff">true</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">continue</font> <font color="#008080">;</font> </li><li>  <font color="#008000">}</font> </li><li>  NonTerminal nonTerm <font color="#000080">=</font> marker.  <font color="#007788">NonTerm</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  item <font color="#000080">=</font> allitems <font color="#000040">-</font> <font color="#000080">&gt;</font> First <font color="#008000">(</font> <font color="#0000dd">0</font> , nonTerm <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#000040">!</font> item. <font color="#007788">isend</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> </li><li>  <font color="#008000">{</font> </li><li>  <font color="#0000ff">if</font> <font color="#008000">(</font> <font color="#000040">!</font> itemset. <font color="#007788">exists</font> <font color="#008000">(</font> item <font color="#008000">)</font> <font color="#008000">)</font> </li><li>  itemset.  <font color="#007788">add</font> <font color="#008000">(</font> item <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  item.  <font color="#007788">next</font> <font color="#008000">(</font> <font color="#0000dd">0</font> , nonTerm <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#008000">}</font> </li><li>  closed_item  <font color="#007788">isClose</font> <font color="#000080">=</font> <font color="#0000ff">true</font> <font color="#008080">;</font> </li><li>  <font color="#008000">}</font> </li></ol></blockquote><br>  Having understood what the states are, we can begin to build them.  To begin with, we introduce a new rule, which is the basis of the conclusion and to which we must come at the end. <br><img src="http://www.imagepost.ru/images/843/s_rule.gif" alt="image"><br><br>  The first state, of course, will be the closure of an item based on this rule and with a marker pointing to E. Now we begin to build a temporary state machine table, which will serve as the basis for transition tables and actions.  We divide the state into groups according to the criterion of the symbol indicated by the marker.  For the closure of the example there will be 4 groups - F-group, T-group, 0-group and 1-group.  Each group is a transition to a new state.  The first index from the transition is the symbol by which we actually group (F, T, 0, 1).  The second index is the current state.  And the value in the table is the state to which we proceed.  So we have 4 new states.  It is quite simple to construct them - in the group at each point we shift the marker by one position to the right and close the resulting set.  This will be the new state. <br><br><blockquote><ol><li>  firstState.  <font color="#007788">Add</font> <font color="#008000">(</font> items. <font color="#007788">First</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  firstState.  <font color="#007788">MakeClosure</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  states.  <font color="#007788">add</font> <font color="#008000">(</font> firstState <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">size_t</font> state_idx <font color="#000080">=</font> <font color="#0000dd">0</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">while</font> <font color="#008000">(</font> state_idx <font color="#000080">&lt;</font> states. <font color="#007788">size</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> </li><li>  <font color="#008000">{</font> </li><li>  State <font color="#000040">*</font> st <font color="#000080">=</font> states <font color="#008000">[</font> state_idx <font color="#008000">]</font> <font color="#008080">;</font> </li><li>  GroupedItems group <font color="#000080">=</font> st <font color="#000040">-</font> <font color="#000080">&gt;</font> Group <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">for</font> <font color="#008000">(</font> group_class in group <font color="#008000">)</font> </li><li>  <font color="#008000">{</font> </li><li>  <font color="#0000ff">if</font> <font color="#008000">(</font> group_class <font color="#000040">-</font> <font color="#000080">&gt;</font> first. <font color="#007788">Type</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">==</font> ElementEnd <font color="#008000">)</font> </li><li>  <font color="#0000ff">continue</font> <font color="#008080">;</font> </li><li> State newState <font color="#008000">(</font> <font color="#000040">&amp;</font> items, states. <font color="#007788">Size</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">for</font> <font color="#008000">(</font> group_item in group_class <font color="#008000">)</font> </li><li>  newState.  <font color="#007788">Add</font> <font color="#008000">(</font> group_item, group_item. <font color="#007788">MarkerInt</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000040">+</font> <font color="#0000dd">1</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  newState.  <font color="#007788">MakeClosure</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  State oldState <font color="#000080">=</font> states.  <font color="#007788">find</font> <font color="#008000">(</font> newState <font color="#008000">)</font> </li><li>  <font color="#0000ff">if</font> <font color="#008000">(</font> <font color="#000040">!</font> oldState <font color="#008000">)</font> </li><li>  <font color="#008000">{</font> </li><li>  states.  <font color="#007788">add</font> <font color="#008000">(</font> newState <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  fsmTable.  <font color="#007788">Add</font> <font color="#008000">(</font> st, group_class <font color="#000040">-</font> <font color="#000080">&gt;</font> first, newState <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#008000">}</font> </li><li>  <font color="#0000ff">else</font> </li><li>  fsmTable.  <font color="#007788">Add</font> <font color="#008000">(</font> st, group_class <font color="#000040">-</font> <font color="#000080">&gt;</font> first, oldState <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#008000">}</font> </li><li>  state_idx <font color="#000040">++</font> <font color="#008080">;</font> </li><li>  <font color="#008000">}</font> </li></ol></blockquote><br><br>  The transition table is built very simply - we transfer the columns from the FSM table, whose indices are non-terminals. <br><br>  The action table is a little more interesting.  The part is also transferred from the FSM, in turn, the columns with terminal indices, while the shift action with the state parameter, which was recorded in the original KA table, is recorded in the table cells.  Then we add a new column '$', which marks the end of the input line.  In this column, we enter the accepted event, which is recorded if the index-state contains the item <img src="http://www.imagepost.ru/images/843/item_end.gif" alt="image">  .  It means success, turned into the primary rule and at the same time the input stream ended.  Then come the action of convolutions.  For each state in which there is an item <img src="http://www.imagepost.ru/images/843/reduce_item.gif" alt="image">  where w is any combination of terminals and non terminals, we write the complete command (of course, only free cells not occupied by other commands) with the parameter of the corresponding rule to which this item belongs. <br><br><blockquote><ol><li>  fsmTable.  <font color="#007788">FeedTransferTable</font> <font color="#008000">(</font> transferTable <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  fsmTable.  <font color="#007788">FeedActionTable</font> <font color="#008000">(</font> actionTable <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  Item endItem <font color="#000080">=</font> items.  <font color="#007788">GetItem</font> <font color="#008000">(</font> <font color="#0000dd">1</font> , <font color="#FF0000">'S'</font> , Elements <font color="#008000">(</font> <font color="#FF0000">"E"</font> , nonTerms <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">for</font> <font color="#008000">(</font> st in states <font color="#008000">)</font> </li><li>  <font color="#0000ff">if</font> <font color="#008000">(</font> st. <font color="#007788">HaveItem</font> <font color="#008000">(</font> endItem <font color="#008000">)</font> <font color="#008000">)</font> </li><li>  actionTable.  <font color="#007788">Add</font> <font color="#008000">(</font> st, <font color="#FF0000">'$'</font> , <font color="#0000dd">new</font> Action <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">for</font> <font color="#008000">(</font> st in states <font color="#008000">)</font> </li><li>  <font color="#008000">{</font> </li><li>  ItemList list <font color="#000080">=</font> st.  <font color="#007788">GetReducable</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#0000ff">for</font> <font color="#008000">(</font> listItem in list <font color="#008000">)</font> </li><li>  actionTable.  <font color="#007788">Add</font> <font color="#008000">(</font> st, <font color="#0000dd">new</font> Action <font color="#008000">(</font> listItem. <font color="#007788">GetRule</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> </li><li>  <font color="#008000">}</font> </li></ol></blockquote><br><br><h4>  Literature </h4><br><br>  Compilers: Principles, Techniques, and Tools, 1986, Alfred V. Aho, Ravi Sethi, Jeffrey D. Ullman </div><p>Source: <a href="https://habr.com/ru/post/116732/">https://habr.com/ru/post/116732/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../116722/index.html">Ios. Versions, licenses and what to do in the Russian Federation</a></li>
<li><a href="../116724/index.html">Do you use the F1-F12 keys</a></li>
<li><a href="../116725/index.html">Simplified Boyer-Moore Algorithm</a></li>
<li><a href="../116730/index.html">The theory of anonymity in the modern network</a></li>
<li><a href="../116731/index.html">How to get to a retail network from a small site and what you need to do</a></li>
<li><a href="../116733/index.html">Supercomputers: Third World Race</a></li>
<li><a href="../116734/index.html">Files Over Miles: P2P via browser</a></li>
<li><a href="../116735/index.html">Web 2.0 Expo 2011: social networks will tell your inside story, and the "clouds" will turn the IT market</a></li>
<li><a href="../116736/index.html">Goodbye, Gnome!</a></li>
<li><a href="../116738/index.html">Script LizaMoon found already on 500 thousand sites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>