<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>React, built-in functions and performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When I have to talk about React, or when I give the first lecture of the training course, showing all sorts of interesting things, someone will certai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>React, built-in functions and performance</h1><div class="post__text post__text-html js-mediator-article">  When I have to talk about React, or when I give the first lecture of the training course, showing all sorts of interesting things, someone will certainly ask: ‚ÄúBuilt-in functions?  I heard they are slow. ‚Äù <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/340034/"><img src="https://habrastorage.org/webt/59/d2/2f/59d22f0309f6e578842023.png"></a> <br><br>  This question did not always appear, but in the past few months I, in the role of library author and teacher, have to answer it almost every day, sometimes in lectures, sometimes in twitter.  Honestly, I'm already tired of this.  Unfortunately, I did not immediately realize that it is better to present everything in the form of an article, which I hope will be useful for those who ask questions of performance.  Actually - in front of you is the fruit of my labors. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">What is a "built-in function"?</font> </h2><br>  In the context of React, what is called an inline function is a function that is defined in the rendering process.  In React, there are two meanings of the concept of rendering, which are often confused.  The first relates to getting React elements from components (calling the components <code>render</code> methods) during the update process.  The second is the actual update of the page fragments by modifying the DOM.  When I talk about ‚Äúrendering‚Äù in this article, I mean the first option. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here are some examples of built-in functions: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... render() {   return (     &lt;div&gt;             {/* 1.    " DOM" */}       &lt;button         onClick={() =&gt; {           this.setState({ clicked: true })         }}       &gt;         Click!       &lt;/button&gt;             {/* 2. " "  "" */}       &lt;Sidebar onToggle={(isOpen) =&gt; {         this.setState({ sidebarIsOpen: isOpen })       }}/&gt;             {/* 3.   render */}       &lt;Route         path="/topic/:id"         render={({ match }) =&gt; (           &lt;div&gt;             &lt;h1&gt;{match.params.id}&lt;/h1&gt;}           &lt;/div&gt;         )       /&gt;     &lt;/div&gt;   ) } }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Premature optimization is the root of all evil</font> </h2><br>  Before we continue, we need to talk about how to optimize programs.  Ask any performance professional and he will tell you that premature optimization is evil.  This applies to absolutely all programs.  Anyone who knows how to optimize can confirm this. <br><br>  I remember the speech of my friend Ralph Holzmann on <code>gzip</code> , which really strengthened this idea in me.  He talked about an experiment that he did with <code>LABjs</code> , the old library for loading scripts.  You can watch this <a href="https://vimeo.com/34164210">performance</a> .  What I‚Äôm talking about here takes about two and a half minutes, starting with the 30th minute of the video. <br><br>  At that time, something strange was done in <a href="https://github.com/getify/LABjs">LABjs</a> , aimed at optimizing the size of the finished code.  Instead of using the usual object notation ( <code>obj.foo</code> ), it used to store keys in strings and use square brackets to access the contents of objects ( <code>obj[stringForFoo]</code> ).  The reason for this was that after minifying and compressing code with <code>gzip</code> <a href="">unusually written code</a> would have to become less than code that was written in a familiar way. <br><br>  Ralph forked this code and removed the optimization, rewriting it in the usual way, without thinking about how to optimize the code for minification and gzip-compression. <br><br>  It turned out that getting rid of "optimization" has reduced the size of the final file by 5.3%!  Obviously, the author of the library wrote it immediately in an ‚Äúoptimized‚Äù form, without checking whether it would give any advantages.  Without measurements, it is impossible to know whether something improves certain optimization.  In addition, if the optimization only worsens the situation, you will not know about it either. <br><br>  Not only can premature optimization significantly increase development time, degrade the purity of the code, it can have negative consequences and lead to problems, as it was with LABjs.  If the author of the library took measurements instead of imagining performance problems, he would save development time, release a cleaner code with better performance. <br><br>  I will quote <a href="https%253A%252F%252Fcdb.reacttraining.com%252Fmedia%252Fdfe70e945f32c97d0a6cdd2f23b5e42f%253FpostId%253Dbdff784f5578">this tweet</a> here: ‚ÄúIt annoys me when people, lounging in a chair, argue that a certain code will be slow to solve their problems, without taking any measurements of performance.‚Äù  I support this point of view. <br><br>  So, I repeat - do not engage in premature optimization.  And now - back to React. <br><br><h2>  <font color="#3AC1EF">Why say built-in functions degrade performance?</font> </h2><br>  Built-in functions are considered slow for two reasons.  Firstly, this is due to concerns about memory consumption and garbage collection.  Secondly, due to <code>shouldComponentUpdate</code> .  Let's sort out these concerns. <br><br><h3>  <font color="#3AC1EF">‚ñç Memory consumption and garbage collection</font> </h3><br>  To begin with, programmers (and <a href="">estlint configurations</a> ) are concerned about memory consumption and system load from garbage collection when creating built-in functions.  This is the legacy of the days when the switch functions in JS were not yet widespread.  If in the React code, in embedded constructions, the <code>bind</code> command was often used, this, historically, led to poor performance.  For example: <br><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; {stuff.map(function(thing) {   &lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;{thing.whatever}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)} &lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;</code> </pre> <br>  Problems with <code>Function.prototype.bind</code> <a href="http://benediktmeurer.de/2015/12/25/a-new-approach-to-function-prototype-bind/">were corrected here</a> , and the switch functions were either used as built-in features of the language, or transpiled with the help of babel into normal functions.  And so and so we can assume that they are not slow. <br><br>  Remember not to make the assumption that some code will be slow.  Write the code as you always do and measure the performance.  If you can find any problems - fix them.  You do not need to prove that the switch functions work quickly - let someone else prove that they are slow.  Otherwise it is a premature optimization. <br><br>  As far as I know, no one has yet led a study of his application, indicating that the built-in functions lead to performance problems.  Up to this point it is not even worth talking about it, however, I, in any case, will share here one more idea. <br>  If the load on the system from creating the built-in function is high enough to create a special eslint rule to prevent this, why would we strive to move these heavy operations to a very important initialization unit from the point of view of the impact on the speed of the system? <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dashboard</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { handlingThings: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } constructor(props) {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props)     <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleThings = () =&gt;     <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ handlingThings: <span class="hljs-literal"><span class="hljs-literal">true</span></span> })   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleStuff = () =&gt; { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }   <span class="hljs-comment"><span class="hljs-comment">//       bind   this.handleMoreStuff = this.handleMoreStuff.bind(this) } handleMoreStuff() { /* ... */ } render() {   return (     &lt;div&gt;       {this.state.handlingThings ? (         &lt;div&gt;           &lt;button onClick={this.handleStuff}/&gt;           &lt;button onClick={this.handleMoreStuff}/&gt;         &lt;/div&gt;       ) : (         &lt;button onClick={this.handleThings}/&gt;       )}     &lt;/div&gt;   ) } }</span></span></code> </pre> <br>  Being engaged in preliminary optimization, we slowed down the initialization of the component three times.  If all event handlers were built-in functions, the original call to <code>render</code> need to create only one function.  Instead, we create three.  Moreover, no measurement of performance was not carried out, so we have no reason to consider this a problem. <br><br>  However, again, you should not get involved in the idea of ‚Äã‚Äãtransferring everything that is necessary and not necessary to the built-in functions.  If, inspired by the above idea, someone decides to create an eslint rule that will require the ubiquitous use of built-in functions to speed up the initial rendering, then we will end up with all the same harmful premature optimization. <br><br><h3>  <font color="#3AC1EF">‚ñçPureComponent and shouldComponentUpdate</font> </h3><br>  The real essence of the problem lies in <code>PureComponent</code> and <code>shouldComponentUpdate</code> .  In order to intelligently engage in performance optimization, you need to understand two things: the features of <code>shouldComponentUpdate</code> , and how the comparison for strict equality works in JavaScript.  Not understanding these concepts, you can, trying to make the code faster, only make things worse. <br><br>  When <code>setState</code> is <code>setState</code> , React compares the old element with the new one (this is called <a href="https://reactjs.org/docs/reconciliation.html">reconciliation</a> ) and then uses the resulting information to update the elements of the real DOM.  Sometimes this operation can happen rather slowly if there are too many items to check (something like a large SVG).  In such cases, React provides a workaround called <code>shouldComponentUpdate</code> . <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Avatar</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ shouldComponentUpdate(nextProps, nextState) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stuffChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, nextProps, nextState)) } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre> <br>  If a component is set to <code>shouldComponentUpdate</code> , before React compares the old and the new elements, it will turn to <code>shouldComponentUpdate</code> to find out if something has changed.  If the response returns <code>false</code> , React completely skips the element comparison operation, which saves some time.  If the component is large enough, this can lead to a noticeable effect on performance. <br><br>  The most common way to optimize a component is the <code>React.PureComponent</code> extension instead of <code>React.Component</code> .  <code>PureComponent</code> will compare the properties and state in <code>shouldComponentUpdate</code> , as a result, you will not have to do it yourself. <br> <code>class Avatar extends React.PureComponent { ... }</code> <br> <br>  The <code>Avatar</code> class now uses strict equality comparisons when working with properties and state before requesting updates.  It can be expected that this will speed up the program. <br><br><h3>  <font color="#3AC1EF">‚ñçComparison on strict equality</font> </h3><br>  There are six primitive types in JavaScript: <code>string</code> , <code>number</code> , <code>boolean</code> , <code>null</code> , <code>undefined</code> , and <code>symbol</code> .  When you make a strict comparison of two variables of primitive types that store it the same value, it turns out to be <code>true</code> .  For example: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uno = <span class="hljs-number"><span class="hljs-number">1</span></span> one === uno <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  When <code>PureComponent</code> compares properties, it uses strict comparison.  This works great for embedded primitive values ‚Äã‚Äãlike <code>&lt;Toggler isOpen={true}/&gt;</code> . <br><br>  The problem when comparing properties arises for other types, that is, sorry - the only type.  Everything else in JS is <code>Object</code> .  What about functions and arrays?  In fact, all of these are objects.  Let me quote an excerpt from the <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures">MDN documentation</a> : ‚ÄúFunctions are ordinary objects that have the additional ability to be called for execution.‚Äù <br><br>  Well what can I say - JS is JS.  In any case, a strict comparison of different objects, even if they contain the same values, returns <code>false</code> . <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = { n: <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uno = { n: <span class="hljs-number"><span class="hljs-number">1</span></span> } one === uno <span class="hljs-comment"><span class="hljs-comment">// false one === one // true</span></span></code> </pre> <br>  So, if you embed an object in JSX code, an adequate property comparison in <code>PureComponent</code> will not be possible, resulting in a more time-consuming comparison of React elements.  This comparison will only clarify that the component has not changed, as a result - the loss of time in the two comparisons. <br><br><pre> <code class="hljs xml">//   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Avatar</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">user</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{{</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id:</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ryan</span></span></span><span class="hljs-tag">' }}/&gt;</span></span> //   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Avatar</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">user</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{{</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id:</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ryan</span></span></span><span class="hljs-tag">' }}/&gt;</span></span> //   ,  - ,   {} !== {} //   () ,    </code> </pre> <br>  Since functions are objects, and <code>PureComponent</code> performs a strict check on the equality of properties, the comparison of built-in functions when analyzing properties always ends with the message that they are different, after which the transition to the comparison of elements will be made during the matching procedure. <br><br>  You may notice that this applies not only to the built-in functions.  The same can be said about ordinary objects, and about arrays. <br><br>  In order for <code>shouldComponentUpdate</code> , when comparing identical functions, what we expect from it, it is necessary to preserve the referential identity of functions.  For experienced JS developers, this is not such bad news.  But, considering that <a href="https://medium.com/%40mjackson">Michael</a> and I learned about 3,500 people after training, who have different levels of training, it can be noted that this task was not so easy for our students.  It should be noted that the ES classes do not help here, so in this situation we have to use other JS features: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dashboard</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ constructor(props) {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props)     <span class="hljs-comment"><span class="hljs-comment">//  bind?    ,     20,   //  .   //  ,    .   this.handleStuff = this.handleStuff.bind(this)   // _this -   .   var _this = this   this.handleStuff = function() {     _this.setState({})   }     //     ES, , ,       //   ( ,   babel    ).   //      ,       -     //     .   this.handleStuff = () =&gt; {     this.setState({})   } } //   ,      JavaScript, //       ,    TC39  //      . handleStuff = () =&gt; {} }</span></span></code> </pre> <br>  It should be noted here that the study of methods of maintaining the reference identity of functions leads to surprisingly long conversations.  I have no reason to call programmers for this, unless they want to fulfill the requirements of their eslint configuration.  The main thing that I wanted to show is that the built-in functions do not interfere with optimization.  And now I will share my own history of performance optimization. <br><br><h2>  <font color="#3AC1EF">How I worked with PureComponent</font> </h2><br>  When I first learned about <code>PureRenderMixin</code> (this is a design from earlier versions of React, which later became <code>PureComponent</code> ), I used many measurements and evaluated the performance of my application.  Then I added a <code>PureRenderMixin</code> to all components.  When I took the measure of the performance of the optimized version, I hoped that as a result everything would be so wonderful that I could tell about it with pride. <br><br>  However, to my great surprise, the application began to work more slowly. <br><br>  Why?  Let's think about it.  If you have a <code>Component</code> , how many comparisons do you have to do when working with it?  And what about <code>PureComponent</code> ?  The answers, respectively, are as follows: "only one," and "at least one, and sometimes two."  If the component usually changes during the update, <code>PureComponent</code> will perform two comparison operations instead of one (the properties and state in <code>shouldComponentUpdate</code> , and then the usual comparison of elements).  This means that normally the <code>PureComponen</code> t will be slower, but sometimes faster.  Obviously, most of my components were constantly changing, so, in general, the application began to work more slowly.  Sadly <br><br>  There is no universal answer to the question: "How to increase productivity?"  The answer can only be found in the performance measurements of a particular application. <br><br><h2>  <font color="#3AC1EF">About three scenarios for using inline functions</font> </h2><br>  At the beginning of the material, I showed three types of built-in functions.  Now that a base has been prepared, let's talk about each of them.  But please remember that <code>PureComponent</code> better to hold until you have measurements in order to evaluate the benefits of using this mechanism. <br><br><h3>  <font color="#3AC1EF">‚ñçDOM component event handler</font> </h3><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span><span class="hljs-tag"> =&gt;</span></span> this.setState(‚Ä¶)} &gt;click<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Normally, inside event handlers for buttons, input fields, and other DOM components, nothing is done except calling <code>setState</code> .  This usually makes the built-in functions the most pure approach.  Instead of jumping around the file looking for event handlers, you can find them in the item description code.  The React community usually welcomes this. <br><br>  The <code>button</code> component (and any other DOM component) cannot even be a <code>PureComponent</code> , so there‚Äôs no need to worry about <code>shouldComponentUpdate</code> and the reference identity. <br><br>  As a result, this can be considered slow only if one agrees that the simple definition of a function is a fairly large load on the system, which is worth worrying about.  There is no evidence that this is so.  Unreasonable disposal of the built-in event handlers is a familiar premature optimization. <br><br><h3>  <font color="#3AC1EF">‚ñç "Custom event" or "action"</font> </h3><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Sidebar</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onToggle</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{(isOpen)</span></span></span><span class="hljs-tag"> =&gt;</span></span> { this.setState({ sidebarIsOpen: isOpen }) }}/&gt;</code> </pre> <br>  If the <code>Sidebar ‚Äî</code> <code>PureComponent</code> , we will not go <code>PureComponent</code> property comparison.  Again, since the handler is simple, embedding it may be the best solution. <br><br>  Now let's talk about events like <code>onToggle</code> , and why <code>Sidebar</code> compares them.  There are only two reasons for finding differences in properties in <code>shouldComponentUpdate</code> : <br><br><ol><li>  The property is used for rendering. <br></li><li>  The property is used to achieve a side effect in <code>componentWillReceiveProps</code> , in <code>componentDidUpdate</code> , or in <code>componentWillUpdate</code> . <br></li></ol><br>  Most properties of the form <code>on&lt;whatever&gt;</code> do not meet these requirements.  Thus, most <code>PureComponent</code> use <code>PureComponent</code> lead to unnecessary comparisons, which forces developers to maintain, without need, the referential identity of the handlers. <br><br>  It is necessary to compare only those properties that may change.  Thus, handlers can be found in the item description code, and all this will work quickly, and if we are worried about performance, it can be noted that with this approach there will be less comparisons. <br><br>  For most components, I would advise you to create a <code>PureComponentMinusHandlers</code> class and inherit from it, instead of inheriting from <code>PureComponent</code> .  This will help to simply skip all feature checks.  Just what you need.  Well - almost what you need. <br><br>  If you get a function and pass this function directly to another component, it will be obsolete.  Take a look at this: <br><br><pre> <code class="hljs xml">// 1.    . // 2.     , //   ,   . // 3.    setState     // **  . // 4.     ,  //  . // 5.        //   ,     //   . class App extends React.Component { state = { val: "one" } componentDidMount() {   this.setState({ val: "two" }) } render() {   return <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Form</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{this.state.val}</span></span></span><span class="hljs-tag"> /&gt;</span></span> } } const Form = props =&gt; ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">   </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span><span class="hljs-tag"> =&gt;</span></span> {     submit(props.value)   }} /&gt; ) class Button extends React.Component { shouldComponentUpdate() {   // ,    ,  .   return false } handleClick = () =&gt; this.props.onClick() render() {   return (     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{this.props.onClick}</span></span></span><span class="hljs-tag">&gt;</span></span>This one is stale<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span><span class="hljs-tag"> =&gt;</span></span> this.props.onClick()}&gt;This one works<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span><span class="hljs-tag">&gt;</span></span>This one works too<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>   ) } }</code> </pre> <br>  ‚Üí <a href="https://codesandbox.io/s/v38y6zk8ml">Here</a> you can experiment with this code. <br><br>  So, if you like the idea of ‚Äã‚Äãinheriting from <code>PureRenderWithoutHandlers</code> , do not pass your handlers, not participating in the comparison, directly to other components - they need to be wrapped in some way. <br><br>  Now we either need to maintain a reference identity, or avoid a reference identity!  Welcome to performance optimization.  At a minimum, with this approach, the load falls on the optimized component, and not on the code that uses it. <br><br>  I must honestly say that this example application is an addition to the material that I did after publishing with <a href="https://medium.com/%40acdlite">Andrew Clarke‚Äôs</a> submission.  So it may seem that I know exactly when to maintain referential integrity, and when - no. <br><br><h3>  <font color="#3AC1EF">Render render property</font> </h3><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Route</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/topic/:id"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">render</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{({</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">match</span></span></span><span class="hljs-tag"> }) =&gt;</span></span> (   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>{match.params.id}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>}   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> ) /&gt;</code> </pre> <br>  The <code>render ‚Äî</code> a template used to create a component that exists to create and maintain a shared state ( <a href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce">you can read more about this here</a> ).  The contents of the <code>render</code> property are unknown to the component.  For example: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Welcome, {props.name}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Route</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">path</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"/"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">render</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> (     </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">       {/*         props.name    Route              ,  Route            PureComponent,              ,     .       */}       </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hey, {props.name}, let's get started!</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">     </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> )}/&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> )</span></span></code> </pre> <br>  This means that the built-in function of the <code>render</code> property will not lead to problems with <code>shouldComponentUpdate</code> .     ,        <code>PureComponent</code> . <br><br> ,  ,    <code>render</code>   .   ‚Äî  ,     . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br><ol><li>  Write the code as you are used to, realizing your ideas in it. <br></li><li>  Perform performance measurements to find bottlenecks.  <a href="https://reactjs.org/blog/2016/11/16/react-v15.4.0.html">Here</a> you can learn how to do it. <br></li><li>  Use <code>PureComponent</code> and <code>shouldComponentUpdate</code> only when necessary, skipping functions that are component properties (only if they are not used in life-cycle interceptor events to achieve side effects). <br></li></ol><br>    ,        ,      ,     .  In order to think about their optimization, you need evidence to the contrary. <br><br>  Dear readers!    React-? </div><p>Source: <a href="https://habr.com/ru/post/340034/">https://habr.com/ru/post/340034/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340024/index.html">Business wants boxed solutions for everything. Does anyone care about the law of Spring?</a></li>
<li><a href="../340026/index.html">Machine learning: where is the money?</a></li>
<li><a href="../340028/index.html">Configure two-way RSA and GOST authentication in the application on JBoss EAP 7</a></li>
<li><a href="../340030/index.html">DELL EMC Networking N1100 Switch Overview</a></li>
<li><a href="../340032/index.html">Overview of one Russian RTOS, part 8. Work with interruptions</a></li>
<li><a href="../340036/index.html">Using the advantages of TypeScript in JavaScript development</a></li>
<li><a href="../340038/index.html">10 tools for parsing information from websites, including competitors' prices + legal assessment for Russia</a></li>
<li><a href="../340040/index.html">‚ÄúInformation sciences can be taught only by young people‚Äù - Interview with A.A. Shalyto, a professor at ITMO University</a></li>
<li><a href="../340042/index.html">OSSIM + SEC</a></li>
<li><a href="../340044/index.html">7 conclusions self-taught programmer for 1 year</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>