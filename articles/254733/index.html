<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using Asterisk to receive data from security systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few years ago, we transferred a security company, in which I was then working, from the usual ‚Äúwired‚Äù telephony to IP based on Asterisk. It was a se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using Asterisk to receive data from security systems</h1><div class="post__text post__text-html js-mediator-article">  A few years ago, we transferred a security company, in which I was then working, from the usual ‚Äúwired‚Äù telephony to IP based on Asterisk.  It was a separate story, with its own samples, mistakes, epic fails and continuous knowledge of the new.  Since then, in terms of voice communication, everything has been debugged, it works without failures and is sufficiently satisfactory for all interested parties. <br><br>  Until recently, only console equipment operated on wire lines, automatically receiving events from protected objects and transmitting them for processing by dispatchers.  And finally, the time came when their own laziness and administrative golem were defeated, and the functions of these glands were also transferred to the telephone server. <br><a name="habracut"></a><br><h4>  Baseline and why it was started </h4><br><ul><li>  A SIP trunk with a capacity limitation of 15 channels arrives at the office; we have been assigned 10 numbers by the carrier; </li><li>  in the operator‚Äôs cabinet, there is an ‚Äúiron‚Äù VoIP gateway, from the FXS ports of which lines are laid to our equipment; </li><li>  The actual ‚Äúequipment‚Äù is two pieces of iron from different manufacturers that can receive messages from the object security systems in the Contact ID format and transfer them to the dispatcher's workplace program. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Contact ID</b> <div class="spoiler_text">  <i>Contact ID is a protocol developed in 1999 by the Ademco group of companies to transmit information from security systems over public telephone networks, and is the de facto standard for developers of such systems around the world.</i>  <i>Data is transmitted in the form of DTMF-sequences with checksum verification for each parcel and confirmation from the receiving party.</i>  <i>The full specification can be officially purchased on the developers website, but Google gives it out for free in the very first links.</i> </div></div><br>  Cons of the available solution: <br><ul><li>  an extra chain of conversions VoIP-gateway ‚Üí analog line ‚Üí receiver detector, which does not add quality to the incoming signal, which often suffers from bad telephone lines at the sites; </li><li>  the impossibility of receiving data from several objects at the same time, since, when transmitting information, the FXS port is naturally busy and the second call on it will not pass (and the transmission of information from a single object in some cases may take minutes) </li><li>  the impossibility of determining incoming numbers - the gateway can theoretically issue them, but the equipment is not able to determine; </li><li>  the lack of adequate logs and call recordings and, as a result, certain difficulties in diagnosing and configuring ‚Äúproblem‚Äù objects with which communication is periodically lost; </li><li>  perceptible in the scale of this organization the cost of console equipment, complicated by the need to keep a reserve in case the receiver goes down. </li></ul><br><h4>  How and what was configured </h4><br>  In the Asterisk distribution, since 2004, the app_alarmreceiver module has been present, which is intended to emulate a console receiver.  It is called as a normal dialplan command, answers an incoming call, processes events and puts them into a text file / files as specified in the path settings, after which it can call an arbitrary system command to process these files.  What had to face when setting up: <br><br>  <b>For a start</b> , when receiving data to the log, messages from channel.c of the form began to fall in batches: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs markdown">[<span class="hljs-string"><span class="hljs-string">Mar 23 22:58:35</span></span>] DTMF[<span class="hljs-string"><span class="hljs-string">636</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">C-00000009</span></span>] channel.c: DTMF begin '0' received on SIP/inbound-0000000e [<span class="hljs-string"><span class="hljs-string">Mar 23 22:58:35</span></span>] DTMF[<span class="hljs-string"><span class="hljs-string">636</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">C-00000009</span></span>] channel.c: DTMF begin ignored '0' on SIP/inbound-0000000e [<span class="hljs-string"><span class="hljs-string">Mar 23 22:58:35</span></span>] DTMF[<span class="hljs-string"><span class="hljs-string">636</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">C-00000009</span></span>] channel.c: DTMF end '0' received on SIP/inbound-0000000e, duration 51 ms [<span class="hljs-string"><span class="hljs-string">Mar 23 22:58:36</span></span>] DTMF[<span class="hljs-string"><span class="hljs-string">636</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">C-00000009</span></span>] channel.c: DTMF end emulation of '4' queued on SIP/inbound-0000000e [<span class="hljs-string"><span class="hljs-string">Mar 23 22:58:36</span></span>] DTMF[<span class="hljs-string"><span class="hljs-string">636</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">C-00000009</span></span>] channel.c: DTMF end '0' received on SIP/inbound-0000000e, duration 51 ms [<span class="hljs-string"><span class="hljs-string">Mar 23 22:58:36</span></span>] DTMF[<span class="hljs-string"><span class="hljs-string">636</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">C-00000009</span></span>] channel.c: DTMF begin emulation of '0' with duration 80 queued on SIP/inbound-0000000e [<span class="hljs-string"><span class="hljs-string">Mar 23 22:58:36</span></span>] DTMF[<span class="hljs-string"><span class="hljs-string">636</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">C-00000009</span></span>] channel.c: DTMF begin '1' received on SIP/inbound-0000000e [<span class="hljs-string"><span class="hljs-string">Mar 23 22:58:36</span></span>] DTMF[<span class="hljs-string"><span class="hljs-string">636</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">C-00000009</span></span>] channel.c: DTMF begin ignored '1' on SIP/inbound-0000000e [<span class="hljs-string"><span class="hljs-string">Mar 23 22:58:36</span></span>] DTMF[<span class="hljs-string"><span class="hljs-string">636</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">C-00000009</span></span>] channel.c: DTMF end '1' received on SIP/inbound-0000000e, duration 51 ms [<span class="hljs-string"><span class="hljs-string">Mar 23 22:58:36</span></span>] DTMF[<span class="hljs-string"><span class="hljs-string">636</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">C-00000009</span></span>] channel.c: DTMF end emulation of '0' queued on SIP/inbound-0000000e [<span class="hljs-string"><span class="hljs-string">Mar 23 22:58:36</span></span>] DTMF[<span class="hljs-string"><span class="hljs-string">636</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">C-00000009</span></span>] channel.c: DTMF end '1' received on SIP/inbound-0000000e, duration 51 ms</code> </pre> <br>  It turned out that although the DTMF standard supports ‚Äúdigits‚Äù with a duration of 40 ms, by default, Asterisk is set to 80 ms, and all parcels of shorter duration are emulated to this value.  In Contact ID, the digit duration is defined as 50-60 ms.  Fortunately, at the request of the public, since 2012, the corresponding #DEFINE in channel.c was duplicated by the mindtmfduration parameter in asterisk.conf, and after setting it to 50, this issue was resolved. <br><br>  <b>The second</b> problem turned out to be how the data obtained is stored and transmitted further.  By default, the entire transfer session from one object is written to a file of the form: <br><br><pre> <code class="hljs objectivec">[metadata] PROTOCOL=ADEMCO_CONTACT_ID <span class="hljs-built_in"><span class="hljs-built_in">CALLINGFROM</span></span>= <span class="hljs-built_in"><span class="hljs-built_in">CALLERNAME</span></span>=&lt;unknown&gt; TIMESTAMP=Mon Mar <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">2015</span></span> @ <span class="hljs-number"><span class="hljs-number">22</span></span>:<span class="hljs-number"><span class="hljs-number">59</span></span>:<span class="hljs-number"><span class="hljs-number">17</span></span> PDT [events] <span class="hljs-number"><span class="hljs-number">6238181401000042</span></span> <span class="hljs-number"><span class="hljs-number">623818340100004</span></span>C</code> </pre><br>  And then to process it, the command specified in the eventcmd parameter of the alarmreceiver.conf file is called.  It did not suit me for two reasons: <br><br>  First of all, the events will be sent to the dispatcher for processing only after the end of the communication session.  If something illegal happens at the facility and the alarm sensors are triggered one after another, each such trigger and subsequent recovery will generate new events, and the communication session will end (and as a result, the fighters will be sent by alarm) , as on the object no one else will be left (and potentially - nothing valuable). <br><br>  Secondly, the Contact ID events themselves do not provide for any timestamp, and the events appear at the dispatcher and are written to the database of the control program as it is received.  When receiving events "one big bundle" in the database, they all will have the same timestamp, which may cause confusion when communicating with the owners of the object and difficult to restore the chronology of real events. <br><br>  It would seem that to prevent such situations, the logindividualevents parameter was made, in which the alarmreceiver creates a separate file for each event.  But even here it was not without a fly in the ointment - it creates separate files, but eventcmd still calls only once at the end of the session.  As a result, they refused from the regular processing mechanism and added the inc_inosion rule IN_CLOSE_WRITE for the folder with the event files - now they began to be processed immediately after reception. <br><br>  <b>Thirdly</b> , the metadata of the event files indicates which number the incoming call came from, but it does not indicate which of our numbers it came from.  And because of some organizational features, we have several independent dispatch programs with our own databases and our own protected objects for each.  Moreover, data from different objects come to different incoming numbers.  I had to fix app_alarmreceiver.c and add there to get the DNID from ast_channel and output it along with the rest of the metadata. <br><br><h4>  Processing and transfer on </h4><br>  There were no special problems, except for the fact that the dispatching program is very proprietary and does not know how to work with third-party equipment for reasons of principle.  But she is able to receive data from her equipment via UDP, and the processing has been reduced to a simple bash script that parses the event files created by Asterisk, packages ‚Äúfrom her equipment‚Äù and sends them to the appropriate dispatch PC, depending on the DNID: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash dialednum="" exec &lt; $1 while read s do if [ "${s:0:10}" = "DIALEDNUM=" ] then dialednum=${s:10} fi if [ "$s" == "[events]" ] then break fi done while read s do if [ "$s" != "" ] then r=&lt;  hex-,    ¬´¬ª    &gt; if [ "$dialednum" == "xxxxxx" ] then echo $r | xxd -r -p &gt; /dev/udp/192.168.1.xxx/3322 fi if [ "$dialednum" == "yyyyyy" ] then echo $r | xxd -r -p &gt; /dev/udp/192.168.1.yyy/3322 fi break fi done rm -f $1</span></span></code> </pre><br><br><h4>  Profits </h4><br>  Were eliminated all the "cons" listed at the beginning of the article.  In addition, after a thoughtful smoking of logs, a problem was solved with a single object, which had previously been ‚Äúshut up‚Äù periodically.  It turned out that the ancient equipment installed there transmits the checksum "not quite" in accordance with the standard, and our honest and correct hardware receiver refused to digest it.  In the new version, everything worked after a small crutch in the checksum verification procedure in app_alarmreceiver.c. <br><br>  <b>PS</b> By applying and adding a little to the content of this article, you can make your own receiver from the existing burglar alarm and Asterisk by decoding the event codes into text and then sending them to yourself, beloved via e-mail / SMS / in any other way.  Moreover, since the overwhelming majority of the object equipment supports the transmission of events to several numbers at the same time, this can even be combined with the police / PSC guard, and use such a system to monitor the facility and monitor the work of the guard.  If anyone is interested, I will gladly share their experience. </div><p>Source: <a href="https://habr.com/ru/post/254733/">https://habr.com/ru/post/254733/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254717/index.html">On middleware</a></li>
<li><a href="../254719/index.html">The Bresenham algorithm in a soldering furnace - theory</a></li>
<li><a href="../254721/index.html">Practical use of a small vocabulary</a></li>
<li><a href="../254727/index.html">Asynchronous work with Tarantool on Python</a></li>
<li><a href="../254731/index.html">Improving xaml: Bindable Converters, Switch Converter, Sets</a></li>
<li><a href="../254737/index.html">Talking panda or what can be done with FFmpeg and OpenCV on Android</a></li>
<li><a href="../254739/index.html">Techno-Designed Alarm Clock - Arduino Based Desk Clock</a></li>
<li><a href="../254741/index.html">Traffic Inspector: full reboot</a></li>
<li><a href="../254743/index.html">Stepic seeking talents</a></li>
<li><a href="../254747/index.html">Comparison of deep learning libraries on the example of the handwriting numbers classification problem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>