<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is in ORM mine? The near-scientific approach of choosing ORM for Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The choice of tools that one way or another will be needed in the development is one of the main preparatory stages at the start of the new Android pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is in ORM mine? The near-scientific approach of choosing ORM for Android</h1><div class="post__text post__text-html js-mediator-article">  The choice of tools that one way or another will be needed in the development is one of the main preparatory stages at the start of the new Android project. <br>  If you are developing an application that needs to store a large number of entities in one form or another, you will not avoid using databases.  Unlike peers who develop for iOS, Android programmers do not have convenient tools that facilitate the storage of objects like Core Data provided by the platform (except for the Content Provider, why it doesn‚Äôt count, it will be further).  Therefore, many Android developers resort to using third-party ORM solutions in their projects.  About what you should look at when choosing a library for your project, and will be discussed in this article. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b81/778/934/b817789348e14b47966d4c9bc0b87ca1.png"></div><br><a name="habracut"></a><br>  First of all, I would like to make sure that the choice of ORM is not contrived, and we looked at all the available means for storing data that are provided by the Android SDK out of the box. <br><br>  Consider them as the complexity of writing the implementation of such a repository increases.  Note that I did not specifically consider the usual files in this comparison.  Of course, they are an ideal option for lovers of their own bicycles living in the philosophy of Not Invented Here, but in our case they will be too low-level. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Shared Preferences</b> <br>  <a href="http://developer.android.com/guide/topics/data/data-storage.html">http://developer.android.com/guide/topics/data/data-storage.html#pref</a> <br>  Key-value storage for primitive data types.  Supported <br>  Integer, Long, Float, Boolean, String and StringSet.  The main purpose is to store a certain state of the application and user settings.  At its core, it represents a wrapper over an XML file, which is located in the ‚Äúprivate‚Äù folder of your application in the subdirectory shared-prefs.  For storage of a set of the same structured data is not suitable. <br><br>  <b>SQLite databases</b> <br>  <a href="http://developer.android.com/guide/topics/data/data-storage.html">http://developer.android.com/guide/topics/data/data-storage.html#db</a> <br>  SQLite is a standard Android database.  The framework provides several helpers classes that facilitate working with the database: SQLiteOpenHelper, ContentValues, etc.  However, even the use of these helpers will not relieve you of the obligation to write a huge amount of sample code, independently monitor the creation and modification of tables, create methods for operations, methods for searching, etc.  Thus, the code for applications that use only standard SQLite tools in Android is becoming increasingly difficult to maintain when adding new and changing old entities. <br><br>  <b>Content Provider</b> <br>  <a href="http://developer.android.com/guide/topics/providers/content-providers.html">http://developer.android.com/guide/topics/providers/content-providers.html</a> <br>  Content Provider is a layer above the real data store.  It may seem that the Content Provider is a ‚Äúboxed‚Äù implementation of the ORM technology, but this is far from the case.  If you use SQLite as a repository for the Content Provider, you will have to independently implement the logic for creating, updating tables and basic CRUD operations.  In most cases, using the Content Provider without special generators will not only not save time on development and support, but, perhaps, will spend much more than writing your own SQLiteOpenHelper implementation.  However, Content Provider allows you to use some convenient platform classes - such as <a href="http://developer.android.com/reference/android/content/AsyncQueryHandler.html">AsyncQueryHandler</a> , <a href="http://developer.android.com/reference/android/content/CursorLoader.html">CursorLoader</a> , <a href="http://developer.android.com/reference/android/content/AbstractThreadedSyncAdapter.html">SyncAdapter,</a> and others. <br><br>  We are convinced that we have reviewed all the data storage tools available in the Android SDK and come to the conclusion: SQLite provides all the necessary conditions for organizing the storage of structured data of the same type (surprisingly, isn't it?).  However, as mentioned above, using SQLite in Android requires a large amount of code and constant support, so we will try to make our lives easier by resorting to a third-party solution. <br><br>  This is where the ORM technique comes to help - Object Relational Mapping.  Its implementation, in essence, creates the impression of an object database, having basically a common relational database.  ORM, providing a higher level of abstraction, is designed to save programmers from the need to convert data model objects into scalar values ‚Äã‚Äãsupported by the database, allow them to write less generic code and not worry about the structure of tables. <br><br>  Having decided on the technology, we turn to this question on the Internet and select 4 libraries: <br><ul><li>  <a href="http://www.activeandroid.com/">ActiveAndroid</a> </li><li>  <a href="http://ormlite.com/">ORMLite</a> </li><li>  <a href="http://greendao-orm.com/">GreenDao</a> </li><li>  <a href="http://satyan.github.io/sugar">Sugarorm</a> </li></ul><br>  How to choose the right library and not regret your decision if it is too late?  In similar articles, I stumbled upon only high-quality comparisons of libraries.  However, in my opinion, the ORM library should be balanced in terms of convenience and performance.  Therefore, a comparison of these solutions from an API point of view only, without a performance analysis, would be incomplete.  But first, a small digression about why you should still pay attention to the performance of ORM. <br><br><h4>  Why all this? </h4><br>  Why evaluate ORM performance?  Obviously, in the end, everything will rest on the limitation of SQLite itself, and that, in turn, will restrict the file system (this is a single-file database).  However, as it turned out, these natural limitations are still very far away. <br><br>  Before proceeding to the description of the test I conducted and its results, I would like to tell a little story about why we began to pay attention to the ORM performance, which we use in our projects and in trying to improve it. <br><br>  One day, <a href="http://sebbia.ru/">Sebbia</a> came to us to develop a kind of application that consumes a unified REST API for all clients.  Of all the existing ORMs on the market, it was decided to use the ActiveAndroid, proven by time and fully satisfying at that time.  The main essence of the application (for simplicity, let's call it the ‚ÄúEntity‚Äù) is a certain state of the set of other entities of the system, parts of which (the ‚ÄúOwners of the Entity‚Äù) were represented only by the identifiers of these entities.  It was assumed that when requesting ‚ÄúEntity‚Äù the client will load the ‚ÄúOwners of the entity‚Äù automatically if they were not found in the application cache.  In mobile devices, I would like to avoid this situation - in view of the energy costs of sending a new request.  Any changes to the API would lead to potential compatibility issues with other clients.  Therefore, we decided to load and cache the list of ‚ÄúOwners of the entity‚Äù before the need arises to load the ‚ÄúEntities‚Äù themselves.  Most logical such an operation to perform when you first start the application.  It is worth making a reservation that the list of all the ‚ÄúOwners of the entity‚Äù was given completely, not page by page.  What was our surprise when we saw how long this list is stored in the database! <br><br>  After checking the code again and making sure that the list is saved once inside the transaction, ActiveAndroid came under our suspicion.  In general, the reason for the drop in application performance while maintaining a voluminous list was reflection, namely, obtaining the values ‚Äã‚Äãof the object fields and filling them with ContentValues.  Replacing the code that uses reflection, the code generated by the handwritten plug-in for Eclipse, we received an almost two-fold increase in performance - from ~ 38 seconds to 20 seconds.  Having once again been convinced that it is worthwhile to take a closer look at how open-source libraries are designed from the inside, let us turn to the substantive part of the article. <br><br><h4>  Arms race </h4><br>  Of all the selected libraries, GreenDao stands apart - after all, it is the only one among the solutions presented who uses code generation.  In order not to make fast conclusions - <a href="https://github.com/littleinc/android-orm-benchmark">GreenDao is the fastest, and forget about the rest</a> , we decided to format the approach with code generation (used in the ActiveAndroid project described above) as a separate fork and pull request to the official repository, in addition to adding other useful functions: ‚ÄúOne to many‚Äù, ‚Äúmany to many‚Äù and automatic data migration when changing the structure of entities and, accordingly, their tables.  The resulting fork, which I will call ‚ÄúActiveAndroid.Sebbia‚Äù for simplicity, has been added to the test. <br><br>  It is time to talk about the test.  It checks how quickly a particular library can save test entities during a SQLite transaction and performs the reverse operation.  1000 test objects are added to the newly created database, which, after clearing the cache in the ORM memory, are read and checked for ‚Äúcorrectness‚Äù of the data.  Each test subject is tested 10 times, the average result time is taken as the final result.  Test objects consist of two fixed-length text fields, one date field, and one byte array, obtained from the object being serialized.  Initially it was assumed that ORM itself had to convert a Serializable object into an array of bytes, but it turned out that neither GreenDao nor SugarORM had such an opportunity, so this idea had to be abandoned. <br><br>  In order to understand the maximum possible speed of a ‚Äúrow object in a table-object‚Äù operation, which can be achieved using standard Android SDK tools, an <a href="https://github.com/Sebbia/OrmBenchmark/tree/master/src/com/sebbia/ormbenchmark/noorm">example using SQLiteOpenHelper</a> and compiled <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteStatement.html">SQLiteStatement</a> was added to the comparison.  The project itself and all the version libraries on which the comparison was made <a href="https://github.com/Sebbia/OrmBenchmark">is located on GitHub</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/767/ca0/d14/767ca0d14fc14cb7a615822080f45078.png" title="The result of the ORM comparison. The purple bars show the average time of the save operation, the orange bars show the average load time in milliseconds. (less is better)."></div><br>  The results are quite predictable, No ORM solution is the fastest, although it is not much ahead of GreenDAO.  By and large, the code for these solutions is the same, except that GreenDAO provides a more user-friendly interface. <br><br>  In turn, GreenDAO takes the second place in the overall standings, but the first among ORM.  And this is not surprising.  GreenDAO is the only ORM that fully uses code generation, compiled SQLiteStatements and other optimizations. <br>  ActiveAndroid.Sebbia - our fork ActiveAndroid, using code generation, working through Annotation Processor, and SQLiteStatement, comes in second place among ORM and third overall.  The write operation was performed almost 4 times faster than the original project, but the reading was managed to be slightly optimized. <br><br>  ActiveAndroid is ranked ORM third, then comes ORMLite-ORM, which came to the Android world from the ‚Äúbig‚Äù Java, which has several plug-ins for working with different data sources and is quite easy to use.  In last place is SugarORM - the most, in my opinion, unsuccessful of those reviewed.  Firstly, the latest available version from the master branch did not support saving an array of bytes, I had to correct this misunderstanding and rebuild the library, and on the GitHub of the project there has long been a <a href="https://github.com/satyan/sugar/pull/197">pull request that adds this function</a> .  Secondly, SugarORM creates the impression of an ActiveAndroid clone that is very severely curtailed in terms of functionality (the inability to convert objects of other classes and adapters). <br><br>  Well, we figured out the performance - code generation is fast, reflection is slow.  Calling SQliteDatabase.insert (...) is slower than calling a previously created SQLiteStatement.  But how convenient is it to use these libraries?  Let us dwell on each in more detail. <br><br><h4>  Facilities in the yard </h4><br>  I will <b>begin the</b> review of API of the presented libraries with the champion - <b>GreenDAO</b> . <br>  As mentioned above, the project is rather unusual compared to other ORMs.  Instead of creating classes of entities independently and specifying the fields stored in the table, GreenDAO proposes to compose these classes from other code, the resulting generation code must be run as a regular Java application.  Here is how it looks like: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Schema schema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Schema(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"com.sebbia.ormbenchmark.greendao"</span></span>); schema.enableKeepSectionsByDefault(); Entity entity = schema.addEntity(<span class="hljs-string"><span class="hljs-string">"GreenDaoEntity"</span></span>); entity.implementsInterface(<span class="hljs-string"><span class="hljs-string">"com.sebbia.ormbenchmark.BenchmarkEntity"</span></span>); entity.addIdProperty().autoincrement(); entity.addStringProperty(<span class="hljs-string"><span class="hljs-string">"field1"</span></span>); entity.addStringProperty(<span class="hljs-string"><span class="hljs-string">"field2"</span></span>); entity.addByteArrayProperty(<span class="hljs-string"><span class="hljs-string">"blobArray"</span></span>); entity.addDateProperty(<span class="hljs-string"><span class="hljs-string">"date"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DaoGenerator().generateAll(schema, <span class="hljs-string"><span class="hljs-string">"../src-gen/"</span></span>); }</code> </pre> <br>  If you need to add your own fields in the entity class, you need to place them in blocks marked with special comments: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// KEEP FIELDS - put your custom fields here private Blob blob; // KEEP FIELDS END</span></span></code> </pre><br>  Similar comment blocks are provided for both methods and import.  If you do not take into account the staggering performance of this approach, its convenience is extremely doubtful, especially if you use GreenDAO from the first day of development.  However, questions arise when using the already generated code.  For example, why do you need to write so much to get a DAO object: <br><br><pre> <code class="java hljs">DevOpenHelper devOpenHelper = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DaoMaster.DevOpenHelper(context, <span class="hljs-string"><span class="hljs-string">"greendao"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); DaoMaster daoMaster = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DaoMaster(devOpenHelper.getWritableDatabase()); DaoSession daoSession = daoMaster.newSession(); GreenDaoEntityDao dao = daoSession.getGreenDaoEntityDao();</code> </pre><br>  It seems to me that this is too much.  It is clear that to create DaoMaster every time is not needed, but still.  So, with GreenDAO you have to perform extra gestures to support the code and use the wrong API.  However, in return, you get speed and nice bonuses such as supporting Protobuf objects out of the box. <br><br>  Let's <b>go</b> to <b>ORMLite</b> .  ORMLite proposes to actively use annotations when declaring their entities: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@DatabaseTable</span></span>(tableName = <span class="hljs-string"><span class="hljs-string">"entity"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrmLiteEntity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BenchmarkEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@DatabaseField</span></span>(columnName = <span class="hljs-string"><span class="hljs-string">"id"</span></span>, generatedId = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> id; <span class="hljs-meta"><span class="hljs-meta">@DatabaseField</span></span>(columnName = <span class="hljs-string"><span class="hljs-string">"field1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String field1; <span class="hljs-meta"><span class="hljs-meta">@DatabaseField</span></span>(columnName = <span class="hljs-string"><span class="hljs-string">"field2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String field2; <span class="hljs-meta"><span class="hljs-meta">@DatabaseField</span></span>(columnName = <span class="hljs-string"><span class="hljs-string">"blob"</span></span>, dataType = DataType.BYTE_ARRAY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] blobArray; <span class="hljs-meta"><span class="hljs-meta">@DatabaseField</span></span>(columnName = <span class="hljs-string"><span class="hljs-string">"date"</span></span>, dataType = DataType.DATE) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Date date; }</code> </pre><br>  Through annotations, you can specify the data type of the field, which is very convenient and does not blur the code associated with the model of the project.  The project supports <a href="http://ormlite.com/javadoc/ormlite-core/com/j256/ormlite/field/DataType.html">many types of data and storage options</a> .  For example, for java.util.Date, both numeric and string versions are provided.  The disadvantages include the need to implement OrmLiteSqliteOpenHelper, through which you can get a DAO object and interact with the ORM.  Using separate DAO objects eliminates the need to inherit the classes of your entities from the objects of third-party libraries and allows you to flexibly manage the cache. <br><br>  <b>ActiveAndroid</b> uses a similar approach with annotations; however, it requires that model classes inherit from the Model class they provide.  In my opinion, such a solution is optimal for convenience only if your entities are no longer inherited from any class whose parent you cannot change.  Such inheritance allows you to have convenient methods like save () and delete () on model objects without creating additional DAO objects.  The library also provides BigDecimal date serializers and other types, and to serialize fields of non-standard types, you only need to implement your TypeSerializer and specify it during initialization. <br><br>  As mentioned above, <b>Sugar ORM</b> gives the impression of a rather weak ActiveAndroid clone.  However, Sugar ORM does not require inheritance from any abstract class and has a rather concise API: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveEntitiesInTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> List&lt;SugarOrmEntity&gt; entities)</span></span></span><span class="hljs-function"> </span></span>{ SugarRecord.saveInTx(entities); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;SugarOrmEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadEntities</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;SugarOrmEntity&gt; entities = SugarRecord.listAll(SugarOrmEntity.class); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entities; }</code> </pre><br>  <b>ActiveAndroid.Sebbia</b> is a fork of ActiveAndroid with support for code generation.  In this project, the generation of the SQLiteStatement and Cursor binding code with the entity object is performed using the Annotation Processor.  Using Annotation Processor instead of a plug-in for IDE allows you to use it both in Eclipse and IntelliJ IDEA, and when building a project using Gradle or Ant.  However, this imposes some restrictions on the visibility of the model class fields: the minimum allowable visibility in this case will be without a modifier (default).  Code generation allowed to achieve about 30% performance gain, all the rest is due to the pre-compiled SQLiteStatement.  Also, this fork contains OneToManyRelation, ManyToManyRelation, and support for automatic migrations, which is used when the SQL migration script for the current version is not found. <br><br><h4>  Conclusion </h4><br>  In conclusion, I would like to summarize our little research.  ORM is a useful tool that helps you save time when developing your applications.  And it is absolutely indispensable in the case of a model with a multitude of entities and interconnections between them. <br>  It is worth remembering that in real life, the end user most likely will not see any difference between the fastest and the slowest ORM, so whether to think about this is the choice of everyone.  It remains to add that the solution you choose should be convenient and meet your requirements.  In any case, you should follow the general rules when choosing open-source libraries in your projects, namely, to evaluate which known applications use, what quality of the source code and how it works from the inside. <br><br>  <b>Repository links:</b> <br>  <a href="https://github.com/Sebbia/OrmBenchmark">Project benchmark</a> <br>  <a href="https://github.com/Sebbia/ActiveAndroid/tree/sebbia">ActiveAndroid.Sebbia</a> <br><br><div class="spoiler">  <b class="spoiler_title">Bibliography</b> <div class="spoiler_text">  1. Android Storage Options Guide <br>  <a href="http://developer.android.com/guide/topics/data/data-storage.html">developer.android.com/guide/topics/data/data-storage.html</a> <br>  2. Object-relational mapping <br>  <a href="https://en.wikipedia.org/wiki/Object-relational_mapping">en.wikipedia.org/wiki/Object-relational_mapping</a> <br>  3. Java Reflection Performance <br>  <a href="http://stackoverflow.com/q/435553/2287859">stackoverflow.com/q/435553/2287859</a> <br>  4. Is Java Reflection Slow? <br>  <a href="http://vaskoz.wordpress.com/2013/07/15/is-java-reflection-slow/">vaskoz.wordpress.com/2013/07/15/is-java-reflection-slow</a> <br>  5. Comparing android ORM libraries - GreenDAO vs Ormlite <br>  <a href="http://software-workshop.eu/content/comparing-android-orm-libraries-greendao-vs-ormlite">software-workshop.eu/content/comparing-android-orm-libraries-greendao-vs-ormlite</a> <br>  6. 5 of the Best Android ORMs <br>  <a href="http://www.sitepoint.com/5-best-android-orms/">www.sitepoint.com/5-best-android-orms</a> <br>  7. Android Orm Benchmark <br>  <a href="https://github.com/littleinc/android-orm-benchmark">github.com/littleinc/android-orm-benchmark</a> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/245299/">https://habr.com/ru/post/245299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245289/index.html">As I increased sales of modules for CMS</a></li>
<li><a href="../245291/index.html">Training testers. Practical experience and advice</a></li>
<li><a href="../245293/index.html">Virtual hosting and php5.4, when already?</a></li>
<li><a href="../245295/index.html">How to download virtual corporate Office 2013 from Microsoft</a></li>
<li><a href="../245297/index.html">Pebble: working with static graphics on the example of creating a 7-segment watchface</a></li>
<li><a href="../245303/index.html">What the product consists of: know-how and IP inside the new electronics</a></li>
<li><a href="../245305/index.html">C ++ serialization with polymorphism and prototypes</a></li>
<li><a href="../245307/index.html">How ‚Äúdon't know‚Äù the game did</a></li>
<li><a href="../245311/index.html">Extending large missing parts of the image in photoshop: multigradient</a></li>
<li><a href="../245315/index.html">How to vote directly in PowerPoint?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>