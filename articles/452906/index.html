<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript engines: how do they work? From the call stack to the promises, (almost) everything you need to know</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you ever wondered how browsers read and execute JavaScript code? It looks mysterious, but in this post you can get an idea of ‚Äã‚Äãwhat is happening...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript engines: how do they work? From the call stack to the promises, (almost) everything you need to know</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/nm/n6/sdnmn6cuvwusvk4fysdkzvnw9rg.jpeg"></div><br>  Have you ever wondered how browsers read and execute JavaScript code?  It looks mysterious, but in this post you can get an idea of ‚Äã‚Äãwhat is happening under the hood. <br><br>  Let's start our journey into the language with an excursion into the wonderful world of JavaScript engines. <br><a name="habracut"></a><br>  Open the console in Chrome and go to the Sources tab.  You will see several sections, and one of the most interesting is called <b>Call Stack</b> (in Firefox, you will see Call Stack when you set breakpoint in the code): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d34/46f/a81/d3446fa81bf753ff80d32e39bcf5778c.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is a call stack?  It seems that a lot of things are happening here, even for the sake of executing a couple of lines of code.  In fact, JavaScript does not come in a box with every browser.  There is a large component that compiles and interprets our JavaScript code ‚Äî this is a JavaScript engine.  The most popular are V8, it is used in Google Chrome and Node.js, SpiderMonkey in Firefox, JavaScriptCore in Safari / WebKit. <br><br>  Today, JavaScript engines are great examples of software engineering, and it will be almost impossible to talk about all aspects.  However, the main work on code execution is done for us by only a few engine components: Call Stack (Call Stack), Global Memory (Global Memory) and Execution Context (execution context).  Ready to meet them? <br><br>  Content: <br><br><ol><li>  <a href="https://habr.com/ru/company/mailru/blog/452906/">JavaScript engines and global memory</a> <br></li><li>  <a href="https://habr.com/ru/company/mailru/blog/452906/">JavaScript engines: how do they work?</a>  <a href="https://habr.com/ru/company/mailru/blog/452906/">Global execution context and call stack</a> <br></li><li>  <a href="https://habr.com/ru/company/mailru/blog/452906/">Javascript is single threaded and other funny stories</a> <br></li><li>  <a href="https://habr.com/ru/company/mailru/blog/452906/">Asynchronous JavaScript, callback queue, and event loop</a> <br></li><li>  <a href="https://habr.com/ru/company/mailru/blog/452906/">Callback hell and promises ES6</a> <br></li><li>  <a href="https://habr.com/ru/company/mailru/blog/452906/">Creating and working with JavaScript promises</a> <br></li><li>  <a href="https://habr.com/ru/company/mailru/blog/452906/">Error handling in ES6 promises</a> <br></li><li>  <a href="https://habr.com/ru/company/mailru/blog/452906/">Combinators ES6 promises: Promise.all, Promise.allSettled, Promise.any and others</a> <br></li><li>  <a href="https://habr.com/ru/company/mailru/blog/452906/">ES6 promises and microtask queue</a> <br></li><li>  <a href="https://habr.com/ru/company/mailru/blog/452906/">JavaScript engines: how do they work?</a>  <a href="https://habr.com/ru/company/mailru/blog/452906/">Asynchronous evolution: from promises to async / await</a> <br></li><li>  <a href="https://habr.com/ru/company/mailru/blog/452906/">JavaScript engines: how do they work?</a>  <a href="https://habr.com/ru/company/mailru/blog/452906/">Results</a> <br></li></ol><br><a name="1"></a><h2>  1. JavaScript engines and global memory </h2><br>  I said that JavaScript is a compiled and interpreted language at the same time.  Believe it or not, JavaScript engines actually compile your code microseconds before it is executed. <br><br>  Magic some, yes?  This magic is called JIT (Just in time compilation).  It is in itself a great topic for discussion, even a book will not be enough to describe the work of JIT.  But for now we‚Äôll skip theory and focus on the execution phase, which is no less interesting. <br><br>  First look at this code: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; }</code> </pre> <br>  Suppose I ask you how this code is processed in the browser?  What will you answer?  You can say: ‚Äúbrowser reads code‚Äù or ‚Äúbrowser executes code‚Äù.  In reality, everything is not so simple.  First, the code is not read by the browser, but by the engine.  <b>The JavaScript engine reads the code</b> , and as soon as it defines the first line, it puts a couple of links in <b>global memory</b> . <br><br>  Global memory (also called a heap) is an area in which the JavaScript engine stores variables and function declarations.  And when he reads the above code, two binders will appear in the global memory: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/0a8/a90/11b0a8a904acef9ee7bde8b84cb76873.png"><br><br>  Even if the example contains only a variable and a function, imagine that your JavaScript code is executed in a larger environment: in a browser or in Node.js.  In such environments, there are many pre-defined functions and variables that are called global.  Therefore, global memory will contain much more data than just <code>num</code> and <code>pow</code> , keep in mind. <br><br>  Nothing is being performed at the moment.  Let's now try to fulfill our function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  What will happen?  And something interesting will happen.  When calling a function, the JavaScript engine will allocate two sections: <br><br><ul><li>  Global Execution Context <br></li><li>  Call Stack <br></li></ul><br>  What are they? <br><br><a name="2"></a><h2>  2. JavaScript engines: how do they work?  Global execution context and call stack </h2><br>  You've learned how the JavaScript engine reads variables and function declarations.  They fall into the global memory (a bunch). <br><br>  But now we are performing a JavaScript function, and the engine should take care of this.  How?  Each JavaScript engine has a <b>key component called a call stack</b> . <br><br>  <a href="https://en.wikibooks.org/wiki/Data_Structures/Stacks_and_Queues">This is a stack data structure</a> : elements can be added to it from above, but they cannot be excluded from the structure as long as there are other elements above them.  This is exactly how JavaScript functions are arranged.  When executed, they cannot leave the call stack if there is another function in it.  Pay attention to this, because this concept helps to understand the statement "JavaScript is single-threaded." <br><br>  But back to our example.  <b>When calling a function, the engine sends it to the call stack</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b79/118/a43/b79118a430d9daa8af3491138c0cfd2b.png"><br><br>  I like to present the call stack as a stack of Pringles chips.  We can not eat chips from the bottom of the stack, until we eat those that lie on top.  Fortunately, our function is synchronous: it is just a multiplication that is quickly calculated. <br><br>  At the same time, the engine places the <b>global execution context</b> in memory, this is the global environment in which the JavaScript code is executed.  Here's what it looks like: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea8/a33/9c1/ea8a339c120638632b57eb0fb3161254.png"><br><br>  Imagine a global execution context in the form of a sea in which global JavaScript functions float like fish.  How cute!  But this is only half the story.  What if our function has nested variables, or internal functions? <br><br>  Even in the simple case, as shown below, the JavaScript engine creates a <b>local execution context</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fixed = <span class="hljs-number"><span class="hljs-number">89</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  Notice that I added the variable <code>fixed</code> to the <code>pow</code> function.  In this case, the local execution context will contain a section for <code>fixed</code> .  I am not good at drawing small rectangles inside other small small rectangles, so use your imagination. <br><br>  Next to <code>pow</code> local execution context will appear, inside a green rectangle section located inside the global execution context.  Imagine also how for each nested function within the nested function the engine creates other local execution contexts.  All these sections-rectangles appear very quickly!  Like a matryoshka! <br><br>  Let's now go back to the single-threaded story.  What does this mean? <br><br><a name="3"></a><h2>  3. JavaScript is single-threaded, and other fun stories. </h2><br>  We say that <b>JavaScript is single-threaded because only one call stack handles our functions</b> .  Let me remind you that functions cannot leave the call stack if other functions expect execution. <br><br>  This is not a problem if we work with synchronous code.  For example, the addition of two numbers is synchronous and is calculated in microseconds.  What about network calls and other interactions with the outside world? <br><br>  Fortunately, <b>JavaScript engines are designed to work asynchronously by default</b> .  Even if they can perform only one function at a time, slower functions can be performed by an external entity ‚Äî in our case, this is a browser.  We will discuss this below. <br><br>  At the same time, you know that when the browser loads some JavaScript code, the engine reads this code line by line and performs the following steps: <br><br><ul><li>  Puts variables and function declarations into global memory (heap). <br></li><li>  Sends a call to each function to the call stack. <br></li><li>  Creates a global execution context in which global functions are executed. <br></li><li>  Creates many small local execution contexts (if there are internal variables or nested functions). <br></li></ul><br>  Now you have a general idea of ‚Äã‚Äãthe mechanics of synchronicity underlying all JavaScript engines.  In the next chapter we will talk about how asynchronous code works in JavaScript and why it works that way. <br><br><a name="4"></a><h2>  4. Asynchronous JavaScript, callback queue and event loop </h2><br>  Thanks to global memory, execution context and call stack, synchronous JavaScript code is executed in our browsers.  But we forgot something.  What happens if you need to perform some asynchronous function? <br><br>  By asynchronous function, I mean every interaction with the outside world, which may take some time to complete.  Calling a REST API or timer is asynchronous, because it can take seconds to execute them.  Thanks to the elements in the engine, we can handle such functions without blocking the call stack and the browser.  Do not forget, the call stack can execute only one function at a time, and <b>even one blocking function can literally stop the browser</b> .  Fortunately, JavaScript engines are ‚Äúsmart,‚Äù and with a little browser help can sort such things out. <br><br>  When we perform an asynchronous function, the browser takes it and executes it for us.  Take this timer: <br><br><pre> <code class="javascript hljs">setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  I am sure that even though you have already seen <code>setTimeout</code> hundreds of times, you may not know that <b>this function is not built into JavaScript</b> .  So, when JavaScript appeared, there was no <code>setTimeout</code> function in it.  In fact, it is part of the so-called browser APIs, a collection of handy tools that the browser provides us.  Wonderful!  But what does this mean in practice?  Since <code>setTimeout</code> belongs to browser APIs, this function is executed by the browser itself (for an instant it appears on the call stack, but is immediately removed from there). <br><br>  After 10 seconds, the browser takes the callback function that we passed to it, and puts it in the <b>callback queue</b> .  At the moment, two more sections-rectangles appeared in the JavaScript engine.  Take a look at this code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num); setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  Now our scheme looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00f/8e2/b33/00f8e2b33a47490117a9e8f6abad23f5.png"><br><br>  <code>setTimeout</code> is executed within the context of the browser.  After 10 seconds, the timer starts and the callback function is ready for execution.  But first, it must go through the callback queue.  It is a data structure in the form of a queue, and, as its name indicates, is an ordered queue of functions. <br><br>  Each asynchronous function must go through a callback queue before it enters the call stack.  But who sends the function further?  This makes a component called <b>the event loop</b> . <br><br>  So far, the event loop deals only with one thing: it checks if the call stack is empty.  If there is any function in the callback queue and if the call stack is free, then it's time to send the callback to the call stack. <br><br>  After that, the function is considered complete.  This is the general scheme for processing asynchronous and synchronous code by the JavaScript engine: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eba/ec9/fec/ebaec9fec5dc1931176371fd4a9f3cbd.png"><br><br>  Let's say <code>callback()</code> is ready for execution.  After the <code>pow()</code> execution is complete, <b>the call stack is released and the event loop sends a</b> <code>callback()</code> .  And that's it!  Although I have simplified everything a bit, if you understand the above scheme, you can understand all of JavaScript. <br><br>  Remember: the <b>browser APIs, the callback queue, and the event loop are pillars of asynchronous JavaScript</b> . <br><br>  And if you're interested, you can watch Philip Roberts‚Äôs curious video ‚ÄúWhat the heck is the event loop anyway‚Äù.  This is one of the best explanations of the cycle of events. <br><br>  But we have not finished with the topic of asynchronous JavaScript.  In the following chapters, we will look at ES6 promises. <br><br><a name="5"></a><h2>  5. Callback hell and ES6 promises </h2><br>  Callback functions are used in JavaScript everywhere, in both synchronous and asynchronous code.  Consider this method: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element * <span class="hljs-number"><span class="hljs-number">2</span></span>; } [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>].map(mapper);</code> </pre><br>  <code>mapper</code> is a callback function that is passed inside the <code>map</code> .  The code given is synchronous.  Now consider this interval: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runMeEvery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Ran!'</span></span>); } setInterval(runMeEvery, <span class="hljs-number"><span class="hljs-number">5000</span></span>);</code> </pre> <br>  This code is asynchronous, because inside <code>setInterval</code> we pass the runMeEvery callback.  Callbacks are used throughout JavaScript, so we have a problem for years, called ‚Äúcallback hell‚Äù - ‚Äúhell callbacks‚Äù. <br><br>  The term <b>Callback hell</b> in JavaScript is applied to the ‚Äústyle‚Äù of programming, in which callbacks are invested in other callbacks that are embedded in other callbacks ... Because of the asynchronous nature, JavaScript programmers have long been trapped. <br><br>  To be honest, I have never created a large pyramid of callbacks.  Perhaps because I appreciate the readable code and always try to adhere to its principles.  If you hit the callback hell, it means that your function does too much. <br><br>  I will not speak in detail about callback hell, if you are interested, then go to the site <a href="http://callbackhell.com/">callbackhell.com</a> , where this problem is investigated in detail and various solutions are proposed.  And we will talk about <b>ES6 promises</b> .  This is a JavaScript addon designed to solve the hell callback problem.  But what are ‚Äúpromises‚Äù? <br><br>  <b>Promis in JavaScript is a representation of a future event</b> .  A promis can be completed successfully, or in the jargon of programmers a promis will be ‚Äúresolved‚Äù (resolved).  But if the promise finishes with an error, then we say that it is in the ‚Äúrejected‚Äù state.  Also, promises have a default state: each new promise starts in the ‚Äúpending‚Äù state.  Is it possible to create your own promise?  Yes.  We will discuss this in the next chapter. <br><br><a name="6"></a><h2>  6. Creating and working with JavaScript promises </h2><br>  To create a new promise, call the constructor, passing the callback function to it.  It can take only two parameters: <code>resolve</code> and <code>reject</code> .  Let's create a new promise that will be resolved in 5 seconds (you can test the examples in the browser console): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ resolve() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  As you can see, <code>resolve</code> is a function that we call for the promise to succeed.  And the <code>reject</code> will create a rejected promise: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ reject() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  Note that you can ignore <code>reject</code> , because this is the second parameter.  But if you intend to use <code>reject</code> , you <b>cannot ignore <code>resolve</code></b> .  That is, the following code will not work and will end with the allowed promis: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Can't omit resolve ! const myPromise = new Promise(function(reject){ setTimeout(function(){ reject() }, 5000) });</span></span></code> </pre> <br>  Now the promises don't look so useful, right?  These examples do not output anything to the user.  Let's add something.  Both allowed, rejected promises can return data.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); });</code> </pre> <br>  But we still see nothing.  <b>To extract data from the promise, you need to associate the promise with the <code>then</code> method</b> .  He takes a callback (which is irony!), Which receives actual data: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br>  As a JavaScript developer and consumer of someone else's code, you mostly interact with external promises.  The creators of the libraries most often wrap the legacy code in the constructor of promises, thus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shinyNewUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// do stuff and resolve // or reject });</span></span></code> </pre> <br>  And if necessary, we can also create and resolve a promise by calling <code>Promise.resolve()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({ <span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Resolve!'</span></span>}) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(msg));</code> </pre> <br>  So let me remind you that promises in javascript are a bookmark for an event that will occur in the future.  The event starts in a ‚Äúpending decision‚Äù state, and may be successful (allowed, executed) or unsuccessful (rejected).  Promis can return data that can be retrieved by attaching to the <code>then</code> promis.  In the next chapter, we will discuss how to deal with errors coming from promises. <br><br><a name="7"></a><h2>  7. Error Handling in ES6 Promises </h2><br>  Processing errors in JavaScript has always been easy, at least in synchronous code.  Take a look at an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeAnError(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  The result will be: <br><br><pre> <code class="javascript hljs">Catching the error! <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate!</code> </pre> <br>  As expected, the error got into the <code>catch</code> .  Now let's try the asynchronous function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setTimeout(makeAnError, <span class="hljs-number"><span class="hljs-number">5000</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  This code is asynchronous due to <code>setTimeout</code> .  What happens if we do it? <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); ^ <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate! at Timeout.makeAnError [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _onTimeout] (<span class="hljs-regexp"><span class="hljs-regexp">/home/</span></span>valentino/Code/piccolo-javascript/<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.js:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br>  Now the result is different.  The error was not caught by the <code>catch</code> , but rose freely up the stack.  The reason is that <code>try/catch</code> works only with synchronous code.  If you want to know more, then this problem is discussed in detail <a href="https://www.joyent.com/node-js/production/design/errors">here</a> . <br><br>  Fortunately, with promises, we can handle asynchronous errors as if they were synchronous.  In the last chapter, I said that calling <code>reject</code> leads to rejection of promise: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); });</code> </pre> <br>  In this case, we can handle errors with the help of the <code>catch</code> handler, pulling (again) the callback: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  In addition, you can call <code>Promise.reject()</code> to create and discard the promise in the right place: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject({<span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Rejected!'</span></span>}).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  I recall: the <code>then</code> handler is executed when the promise is executed, and the <code>catch</code> handler is executed for rejected promises.  But this is not the end of the story.  Below we will see how <code>async/await</code> works great with <code>try/catch</code> . <br><br><a name="8"></a><h2>  8. Combinators of ES6 promises: Promise.all, Promise.allSettled, Promise.any and others </h2><br>  Promises are not designed to work alone.  Promise API offers a number of methods for <b>combining promises</b> .  One of the most useful <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">is Promise.all</a> , it takes an array of promises and returns one promise.  The only problem is that Promise.all is rejected if at least one promise is rejected in the array. <br><br>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">Promise.race</a> allows or rejects as soon as one of the promises in the array receives the corresponding status. <br><br>  In more recent versions of the V8, two new combinators will also be introduced: <code>Promise.allSettled</code> and <code>Promise.any</code> .  <a href="https://github.com/tc39/proposal-promise-any">Promise.any</a> is still at the early stage of the proposed functionality, at the time of this writing is not supported.  However, in theory, he will be able to signal whether any promise has been performed.  The difference from <code>Promise.race</code> is that <b>Promise.any does not deviate, even if one of the promises is rejected</b> . <br><br>  <code>Promise.allSettled</code> even more interesting.  He also takes an array of promises, but does not ‚Äúshort,‚Äù if one of the promises is rejected.  It is useful when you need to check whether all the promises in the array passed into some stage, regardless of the presence of rejected promises.  It can be considered the opposite of <code>Promise.all</code> . <br><br><a name="9"></a><h2>  9. ES6 promises and microtask queue </h2><br>  If you remember from the previous chapter, each asynchronous callback function in JavaScript is placed in a callback queue before it enters the call stack.  But callback functions passed to promis have a different fate: they are processed by a microtask queue (Microtask Queue), and not by a task queue. <br><br>  And here you need to be careful: the <b>microtask queue precedes the call queue</b> .  Callbacks from the microtask queue take precedence when the event loop checks to see if new callbacks are ready and go to the call stack. <br><br>  This mechanic is described in more detail by Jake Archibald in <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a> , a wonderful <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">read</a> . <br><br><a name="10"></a><h2>  10. JavaScript engines: how do they work?  Asynchronous evolution: from promises to async / await </h2><br>  JavaScript is developing rapidly and we get constant improvements every year.  Promises looked like a final, but <b>with ECMAScript 2017 (ES8) a new syntax appeared: <code>async/await</code></b> . <br><br>  <code>async/await</code> is just a stylistic improvement that we call syntactic sugar.  <code>async/await</code> does not change JavaScript at all (remember, the language should be backward compatible with old browsers and should not break existing code).  This is just a new way of writing asynchronous code based on premiums.  Consider an example.  Above we have already saved the prom with the appropriate <code>then</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data))</code> </pre> <br>  Now <b>, using <code>async/await</code> we can process asynchronous code so that the code looks synchronous to the reader of our listing</b> .  Instead of using <code>then</code> we can wrap the promise in a function labeled <code>async</code> , and then we will expect ( <code>await</code> ) the result: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); } getData();</code> </pre> <br>  Looks right, right?  It's funny that the async function always returns a promise, and no one can stop it: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } getData().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br>  What about mistakes?  One of the advantages of <code>async/await</code> is that this construct can allow us to use <code><b>try/catch</b></code> .  Read the <a href="https://www.valentinog.com/blog/throw-async/">introduction to error handling in async functions and their testing</a> . <br><br>  Let's look at the promise again, in which we handle errors with the <code>catch</code> handler: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  With asynchronous functions, we can refactor like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// or return the data with return data } catch (error) { console.log(error); } } getData();</span></span></code> </pre> <br>  However, not all have switched to this style.  <code>try/catch</code> can complicate your code.  In this case, you need to consider something else.  See how the error inside the <code>try</code> block arises in this code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>));</code> </pre> <br>  What about the two lines that are displayed in the console?  Do not forget that <b><code>try/catch</code> is a synchronous construction, and our asynchronous function generates a promise</b> .  They go in two different ways, like a train.  But they will never meet!  ,   <code>throw</code> ,     <code>catch</code>  <code>getData()</code> .      ,     ¬´Catch me if you can¬ª,    ¬´I will run no matter what!¬ª. <br><br>      ,  <code>throw</code>   <code>then</code> .   , ,  <code>Promise.reject()</code>  : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } Now the error will be handled <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected: getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will NOT run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>)); <span class="hljs-string"><span class="hljs-string">"Catching err"</span></span> <span class="hljs-comment"><span class="hljs-comment">// output</span></span></code> </pre> <br>   <code>async/await</code>        JavaScript.         . <br><br>   ,       JS-  <code>async/await</code> .    .     ,       <code>async/await</code> ‚Äî   . <br><br><a name="11"></a><h2> 11. JavaScript-:   ?  Results </h2><br> JavaScript ‚Äî     ,   ,    .   JS-: V8,   Google Chrome  Node.js; SpiderMonkey,   Firefox; JavaScriptCore,   Safari. <br><br> JavaScript-   ¬´¬ª :  ,  ,  ,   .      ,      . <br><br> JavaScript-  ,         .        JavaScript:  ,     - ,     (, )    . <br><br>       ECMAScript 2015   .  ‚Äî   ,         .      .  2017-  <code>async/await</code> :    ,    ,      . </div><p>Source: <a href="https://habr.com/ru/post/452906/">https://habr.com/ru/post/452906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452890/index.html">May 23, 6:30 pm - QIWI Kitchen Live Broadcast</a></li>
<li><a href="../452892/index.html">As a non-programmer to move to the United States: step by step instructions</a></li>
<li><a href="../4529/index.html">Firefox 3 is waiting for user instructions</a></li>
<li><a href="../45290/index.html">Lecturer for RMA students</a></li>
<li><a href="../452902/index.html">Finishing the 4th year of training for a programmer, I understand that I am far from a programmer</a></li>
<li><a href="../452908/index.html">Selenium WebDriver - Real-time test metrics using Grafana and InfluxDB</a></li>
<li><a href="../45291/index.html">Prince of Persia - trailer gameplay demonstration and some screenshots.</a></li>
<li><a href="../452914/index.html">ML on Scala with a smile, for those who are not afraid of experiments</a></li>
<li><a href="../452916/index.html">Get up and go. Spinal surgery: when to do, what is dangerous</a></li>
<li><a href="../45292/index.html">PhpMathPublisher - Math Formulas in HTML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>