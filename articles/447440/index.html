<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RBKmoney Payments under the hood - the logic of the payment platform</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I continue to publish a cycle about the insides of the RBK.money payment platform, begun in this post . Today we will talk about processing ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RBKmoney Payments under the hood - the logic of the payment platform</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ao/li/cv/aolicvi50stowouvsmwppnyc7qk.jpeg"></p><br><p>  Hi, Habr!  I continue to publish a cycle about the insides of the RBK.money payment platform, begun in this <a href="https://habr.com/ru/company/rbkmoney/blog/443518/">post</a> .  Today we will talk about processing logic, specific microservices and their interrelation with each other, how services that process each piece of business logic are logically separated, why the processing core does not know anything about the numbers of your payment cards and how payments run around the platform.  Also, in a little more detail, I‚Äôll cover the topic of how we provide high availability and scaling for high load handling. </p><a name="habracut"></a><br><h2 id="obzornaya-logicheskaya-shema-i-obschie-podhody">  Overview logic and general approaches </h2><br><p>  In general, the scheme of the main elements of the processing part that is responsible for payments looks like this. </p><br><p><img src="https://habrastorage.org/webt/r8/ee/bz/r8eebzud9-g1muc_xguixpokwfc.png"></p><br><p>  Logically within ourselves, we divide areas of responsibility into 3 domains: </p><br><ul><li>  the external zone, entities that are on the Internet, such as JS applications of our payment form (this is where you enter your card details), backends of our merchant clients, as well as processing gateways of our partner banks and providers of other payment methods; </li><li>  internal high-access zone, microservices live there, which provide work directly for the payment gateway and manage the debiting of money, taking them into account within our system and other online services that are characterized by the requirement ‚Äúmust always be available, despite any failures within our business centers‚Äù; <br><ul><li>  here, the zone of services that work directly with complete cardholder data is separately distinguished; these services have separate requirements put forward by the IPS and subject to mandatory certification within the framework of the PCI-DSS standards.  In more detail, why exactly such a division will be described below; </li></ul></li><li>  The internal zone, where lower demands are placed on the availability of the services provided or the time of their response, in the classical sense is the back office.  Although, of course, here we are also trying to ensure the principle of "always available", we just spend less effort on it; </li></ul><br><p>  Within each of the zones there are microservices that perform their parts of the processing of business logic.  At the entrance, they accept RPC calls, at the output they generate data processed by the algorithms laid down, also arranged in the form of calls to other microservices along the chain. </p><br><p>  To ensure scalability, we try to store states in as few places as possible.  The stateless services on the diagram do not have connections to persistent storages, stateful, respectively, are connected to them.  In general, we use several limited services for persistent state storage ‚Äî for the main part of the processing, these are Riak KV clusters, for related services ‚Äî PostgreSQL, for asynchronous queue processing we use Kafka. </p><br><p>  To ensure high availability, we deploy services in several instances, usually from 3 to 5. </p><br><p>  It is easy to scale stateless services, just raise the number of instances we need on different virtual machines, they register with the Consul, become available for resolving the consul DNS and start receiving calls from other services, processing the received data and sending them further. </p><br><p>  Stateful services, or rather our main one, is shown on the diagram as Machinegun, they implement a highly accessible interface (the distributed architecture is based on Erlang Distribution), and to provide guarantees of priority and distributed locking, synchronization via Consul KV.  In short, a detailed description will be in a separate post. </p><br><p>  Riak out of the box provides high-available persistent masterless storage, we don‚Äôt prepare it for anything, the config is almost default.  With the current load profile, we have 5 nodes in the cluster, deployed on separate hosts.  Important note - we practically do not use indexes and large data samples, we work with specific keys. </p><br><p>  Where it is too expensive to implement a KV scheme, we use PostgeSQL databases with replication, or even single-solution solutions, because we can always pour the necessary events from the online part through Machinegun. </p><br><p>  The color separation of microservices in the diagram indicates the languages ‚Äã‚Äãin which they are written ‚Äî light green ‚Äî these are Java applications, light blue ‚Äî Erlang. </p><br><p>  All services operate in Docker containers, which are build artifacts on CI and are located in the local Docker Registry.  Deploys services in SaltStack production, the configuration of which is in a private Github repository. </p><br><p>  Developers independently make change requests to this repository, where they describe the requirements for the service - indicate the version and parameters you need, such as the size of the memory allocated for the container, transferred to environment variables and so on.  Further, after manually confirming the change request by authorized employees (we have this devops, support and information security), the CD automatically rolls out the copies of the containers with the new versions to the hosts of the product environment. </p><br><p><img src="https://habrastorage.org/webt/31/ec/iy/31eciyvgovypqogaegextoyyuf0.jpeg"></p><br><p>  Also, each service writes logs in a format understandable for Elasticsearch.  Log files are picked up by Filebeat, which writes them to the Elasticsearch cluster.  Thus, despite the fact that developers do not have access to the product environment, they always have the opportunity to debug and see what happens to their services. </p><br><h2 id="vzaimodeystvie-s-vneshnim-mirom">  Interaction with the outside world </h2><br><p><img src="https://habrastorage.org/webt/nd/wp/lw/ndwplwol-avyp6uixovsla-otfq.jpeg"></p><br><p>  Any change in the state of the platform takes place exclusively through calls to the corresponding public API methods.  We do not use classic web applications and server-side content generation; in fact, everything you see as a UI is a JS view above our public APIs.  In principle, any action in the platform can be performed by a chain of curl calls from the console, which is what we use.  In particular, for writing integration tests (they are written in JS in the form of a library), which at CI with every assembly checks all public methods. </p><br><p>  Also, this approach solves all the problems of external integration with our platform, allowing you to get a single protocol both for the end user in the form of a beautiful form of entering payment information, and host-to-host for direct integration with third-party processing using only inter-server interaction. </p><br><p>  In addition to full coverage of integration tests, we use staging update approaches, in a distributed architecture, this is fairly easy to do, for example, rolling out only one service from each group in one pass, followed by a pause and analysis of logs and graphs. </p><br><p>  This allows us to deploy almost around the clock, including Friday evenings, without much fear to roll out something unworkable or quickly roll back, making a simple revert commit with the change, while no one noticed. </p><br><h2 id="registraciya-v-platforme-i-publichnye-api">  Registration in the platform and public API </h2><br><p><img src="https://habrastorage.org/webt/tw/m4/0l/twm40lykiloaelwx8elbj6shjge.jpeg"></p><br><p>  Before any call to the public method, we need to authorize and authenticate the client.  In order for a client to appear on the platform, you need a service that will take over all the interaction with the end user, provide interfaces for registering, entering and resetting passwords, security controls, and other binding. </p><br><p>  Here we did not reinvent the wheel, but simply integrated the open source solution from Redhat - <a href="https://www.keycloak.org/">Keycloak</a> .  Before starting any interaction with us, you will need to register in the platform, which is actually happening through Keycloak. </p><br><p>  After successful authentication in the service, the client receives JWT.  We use it later for authorization - on the Keycloak side, you can specify arbitrary fields that describe the roles that will be embedded as a simple json structure in JWT and signed by the private key of the service. </p><br><p>  <em>One of the features of JWT is that this structure is signed by the server's private key; accordingly, to authorize the list of roles and its other objects, we do not need to contact the authorization service, the process is completely untied.</em>  <em>CAPI services at startup read the Keycloak public key and use it to authorize calls to public API methods.</em> </p><br><p>  <em>As we came up with a key recall scheme - the story is separate and deserves its own post.</em> </p><br><p>  So, we have received JWT, we can use it for authentication.  This is where the Common API microservice group comes into play, on the schema indicated as CAPI and CAPI-DSS, implementing the following functions: </p><br><ul><li>  authorization of received messages.  Each public API call is preceded by an Authorizaion: Bearer {JWT} HTTP header.  The services of the Common API group use it to verify the signed data with the available public key of the authorization service; </li><li>  validation of received data.  Since the schema is described as an OpenAPI specification, also known as Swagger, it is very easy to validate the data and with a small amount of probability to get control commands in the data stream.  This has a positive effect on the security of the service as a whole; </li><li>  translation of data formats from public REST JSON to internal binary Thrift; </li><li>  framing the transport binding with data such as a unique trace_id and sending the event further into the platform to the service that manages business logic and knows what payment is, for example. </li></ul><br><p>  We have a lot of such services, they are quite simple and oak, they do not store any states, respectively, for linear scaling of performance, we simply deploy them on available capacity in the quantities we need. </p><br><h3 id="pci-dss-i-otkrytye-kartochnye-dannye">  PCI-DSS and open card data </h3><br><p><img src="https://habrastorage.org/webt/ak/fh/x-/akfhx-regosuv_tbadtr-x2p6uo.jpeg"></p><br><p>  As you can see in the diagram, we have two such service groups - the main one, the Common API, is responsible for processing all data streams that do not have open cardholder data, and the second, the Common PCI-DSS API, which works directly with these cards.  Inside, they are absolutely identical, but we physically divided them and placed them on different glands. </p><br><p>  This is done in order to minimize the number of places for storing and processing card data, to reduce the risks of leakage of this data and the scope of PCI-DSS certification.  And this, believe me, is a rather laborious and costly process - as a payment company, we are required to undergo paid certification for compliance with IPU standards every year, and the fewer servers and services it takes, the faster and easier it is to go through this process.  Well, this is reflected in safety in the most positive way. </p><br><h2 id="obrabotka-platezhnyh-dannyh-i-tokenizaciya">  Billing Processing and Tokenization </h2><br><p><img src="https://habrastorage.org/webt/2y/ya/cm/2yyacmg2lhhzmvnbjv0azaei8gi.jpeg"></p><br><p>  So, we want to start the payment and write off the money from the payer's card. </p><br><p> Imagine that a request for this came in the form of a chain of calls to the methods of our public API, which was initiated by you as a payer after you went to the online store, collected a basket of goods, clicked "Buy", entered your card details into our billing form and clicked "Pay". </p><br><p>  <em>We provide different business processes for writing off money, but the process with the use of invoices seems to be the most interesting.</em>  <em>In our platform, you can create an invoice for payment, or an invoice, which will be a container for payments.</em> </p><br><p>  <em>Inside one invoice, you can alternately make attempts to pay for it, i.e., create payments until the next payment is successful.</em>  <em>For example, you can try to pay an invoice with different cards, wallets and any other payment methods.</em>  <em>If there is no money on one of the cards, you can try another one and so on.</em> </p><br><p>  <em>This has a positive effect on conversion and user experience.</em> </p><br><h3 id="konechnyy-avtomat-invoysa">  Invoice machine </h3><br><p><img src="https://habrastorage.org/webt/gh/u0/ld/ghu0ld9cimq5z13mc1blstsuycy.jpeg"></p><br><p>  Inside the platform, this chain turns into interaction along the following route: </p><br><ul><li>  Before delivering content to your browser, our merchant client integrated with our platform, registered with us and received JWT for authorization; </li><li>  the merchant called the <a href="https://developer.rbk.money/api/">createInvoice ()</a> method from his backend, that is, he created an invoice for payment in our platform.  In fact, the merchant backend sent an HTTP POST request of the following content to our endpoint: </li></ul><br><pre><code class="bash hljs">curl -X POST \ https://api.rbk.money/v2/processing/invoices \ -H <span class="hljs-string"><span class="hljs-string">'Authorization: Bearer {JWT}'</span></span> \ -H <span class="hljs-string"><span class="hljs-string">'Content-Type: application/json; charset=utf-8'</span></span> \ -H <span class="hljs-string"><span class="hljs-string">'X-Request-ID: 1554417367'</span></span> \ -H <span class="hljs-string"><span class="hljs-string">'cache-control: no-cache'</span></span> \ -d <span class="hljs-string"><span class="hljs-string">'{ "shopID": "TEST", "dueDate": "2019-03-28T17:41:32.569Z", "amount": 6000, "currency": "RUB", "product": "Order num 12345", "description": "Delicious meals", "cart": [ { "price": 5000, "product": "Sandwich", "quantity": 1, "taxMode": { "rate": "10%", "type": "InvoiceLineTaxVAT" } }, { "price": 1000, "product": "Cola", "quantity": 1, "taxMode": { "rate": "18%", "type": "InvoiceLineTaxVAT" } } ], "metadata": { "order_id": "Internal order num 13123298761" } }'</span></span></code> </pre> <br><p>  The request was balanced on one of the erlang applications of the Common API group, which checked its validity, went to the Bender service, where it received an idempotency key, translated it into a trift and sent a request to the Hellgate service group.  The Hellgate instance did business checks, for example, made sure that the owner of this JWT is not blocked in principle, can create invoices and interact with the platform in general, and started creating an invoice. </p><br><p>  <em>We can say that Hellgate is the core of our processing, since it is he who operates business entities, knows how to start a payment, who needs to be kicked, so that this payment can turn into a real write-off, how to calculate the route of this payment, who can say to make this write-off reflected on the balances, calculate the commission and other strapping.</em> </p><br><p>  <em>Which is typical, also does not store any state and also easily scaled.</em>  <em>But we would not like to lose the invoice, or receive a double debit from the card in the event of network split or Hellgate failure for any reason.</em>  <em>It is necessary to save this data persistently.</em> </p><br><p>  Here the third microservice comes into play, namely Machinegun.  Hellgate sends a ‚Äúcreate automaton‚Äù call to Machinegun with a payload in the form of request parameters.  Machinegun orders the parallel queries and uses Hellgate from the parameters to create the first event, InvoiceCreated.  Which then he himself writes to the Riak and the queue.  After that, a successful response is returned to the original request through the chain in the reverse order. </p><br><p>  <em>In short, Machinegun is such a DBMS with timers over any other DBMS, in the current version of the platform - over Riak.</em>  <em>It provides an interface that allows you to manage independent machines, and provides guarantees of idempotency and order of recording.</em>  <em>That MG will not allow to record the event in the machine out of turn, if several HGs suddenly come to him with such a request.</em> </p><br><p>  <em>An automaton is a unique entity within the platform consisting of an identifier, a data set in the form of a list of events and a timer.</em>  <em>The final state of the automaton is calculated from the processing of all its events, which initiate its transition to the corresponding state.</em>  <em>We use this approach to work with business entities, describing them as finite state machines.</em>  <em>In fact, all invoices created by our merchants, as well as payments in them, are finite automata with their own logic of transition between states.</em> </p><br><p>  <em>The interface for working with timers in Machinegun allows you to receive a request like ‚ÄúI want to continue processing this machine after 15 years‚Äù from another service along with events for recording.</em>  <em>Such pending tasks are implemented on built-in timers.</em>  <em>In practice, they are used very often - periodic calls to the bank, automatic actions with payments due to long inactivity, etc.</em> </p><br><p>  <em>By the way, the source code for Machinegun is open under the Apache 2.0 license in our <a href="https://github.com/rbkmoney/machinegun">public repository</a> .</em>  <em>We hope that this service can be useful to the community.</em> </p><br><p>  <em>A detailed description of the work of Machinegun, and in general how we prepare the distribution, pulls into a separate big post, so I will not dwell here in more detail.</em> </p><br><h3 id="nyuansy-avtorizacii-vneshnih-klientov">  Nuances of authorization of external clients </h3><br><p><img src="https://habrastorage.org/webt/-l/4v/zo/-l4vzorvyofnp2f4cb9xq6n3oky.jpeg"></p><br><p>  After successful saving, Hellgate returns the data to the CAPI, which converts the binary trift structure into beautifully designed JSON, ready to be sent to the merchant's backend: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"invoice"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"amount"</span></span>: <span class="hljs-number"><span class="hljs-number">6000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cart"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"cost"</span></span>: <span class="hljs-number"><span class="hljs-number">5000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: <span class="hljs-number"><span class="hljs-number">5000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: <span class="hljs-string"><span class="hljs-string">"Sandwich"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"taxMode"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"rate"</span></span>: <span class="hljs-string"><span class="hljs-string">"10%"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"InvoiceLineTaxVAT"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"cost"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: <span class="hljs-string"><span class="hljs-string">"Cola"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"taxMode"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"rate"</span></span>: <span class="hljs-string"><span class="hljs-string">"18%"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"InvoiceLineTaxVAT"</span></span> } } ], <span class="hljs-attr"><span class="hljs-attr">"createdAt"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-04-04T23:00:31.565518Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"currency"</span></span>: <span class="hljs-string"><span class="hljs-string">"RUB"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Delicious meals"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dueDate"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-04-05T00:00:30.889000Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"18xtygvzFaa"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"order_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"Internal order num 13123298761"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: <span class="hljs-string"><span class="hljs-string">"Order num 12345"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"shopID"</span></span>: <span class="hljs-string"><span class="hljs-string">"TEST"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"unpaid"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"invoiceAccessToken"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"payload"</span></span>: <span class="hljs-string"><span class="hljs-string">"{JWT}"</span></span> } }</code> </pre> <br><p>  It would seem that you can give content to the browser to the payer and start the payment process, but then we thought that not all merchants would be ready to independently implement authorization on the client side, therefore, they implemented it themselves.  The approach is that CAPI generates another JWT that allows you to start the process of tokenization of cards and manage a specific invoice and adds it to the returned invoice structure. </p><br><p>  An example of the roles described inside a similar JWT: </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"resource_access"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"common-api"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"roles"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"invoices.18xtygvzFaa.payments:read"</span></span>, <span class="hljs-string"><span class="hljs-string">"invoices.18xtygvzFaa.payments:write"</span></span>, <span class="hljs-string"><span class="hljs-string">"invoices.18xtygvzFaa:read"</span></span>, <span class="hljs-string"><span class="hljs-string">"payment_resources:write"</span></span> ] } }</code> </pre> <br><p>  This JWT has a limited number of usage attempts and a life span that we can customize, which allows you to publish it in the payer's browser.  Even if he is intercepted, the maximum that an attacker can do is pay for someone else's invoice or read his data.  Moreover, since the payment machine does not operate with open card data, the maximum that an attacker can see is the masked card number of the form <code>4242 42** **** 4242</code> , the amount of payment and, optionally, the basket of goods. </p><br><p>  The created invoice and its access key allow you to start the payment business process.  We give the invoice identifier and its JWT to the browser to the payer and transfer control to our JS applications. </p><br><p>  Our Checkout JS application implements the interface of interaction with you as a payer - draws a form for entering payment information, starts a payment, gets its final status, shows a funny or sad Point. </p><br><h3 id="tokenizaciya-i-kartochnye-dannye">  Tokenization and card data </h3><br><p><img src="https://habrastorage.org/webt/gq/1d/gb/gq1dgbxkq1ewsfohsytcdvnotzs.jpeg"></p><br><p>  But Checkout does not work with card data.  As mentioned above, we want to store sensitive data in the form of cardholder data in as few places as possible.  For this, we implement tokenization. </p><br><p>  This is where the Tokenizer JS library comes into play.  When you enter your card in the input fields and click "Pay", it intercepts this data and asynchronously sends it to us in processing, calling the <a href="https://developer.rbk.money/api/">createPaymentResource ()</a> method. </p><br><p>  This request is balanced by individual CAPI-DSS applications, which also authorize the request, only by checking the invoice JWT, validating the data and sending it to the card data storage service.  In the diagram, it is listed as CDS - Card Data Storage. </p><br><p>  The main objectives of this service: </p><br><ul><li>  receive sensitive data as input, in our case - your card data; </li><li>  Encrypt this data with a data encryption key </li><li>  generate some random value used as a key; </li><li>  save encrypted data with this key in your Riak cluster; </li><li>  return the key in the form of a billing token to the CAPI-DSS service. </li></ul><br><p>  Along the way, the service solves a bunch of important tasks, such as generating keys for encrypting keys, securely entering these keys, re-encrypting data, controlling the CVV overwriting after making a payment, and so on, but this is beyond the scope of this post. </p><br><p>  <em>It was not without protection from the possibility to shoot yourself in the foot.</em>  <em>There is a non-zero probability that the private JWT, which is designed to authorize requests from the backend, will be published on the web to the client‚Äôs browser.</em>  <em>To prevent this from happening, we have built in protection ‚Äî you can only call the <a href="https://developer.rbk.money/api/">createPaymentResource ()</a> method with the invoice authorization key.</em>  <em>If you try to use a private JWT platform, it returns an HTTP / 401 error.</em> </p><br><p>  After the tokenization request is completed, Tokenizer returns the received token to Checkout and finishes its work with this. </p><br><h3 id="biznes-process-platezhnogo-avtomata">  Business process of the payment machine </h3><br><p><img src="https://habrastorage.org/webt/ai/9s/7j/ai9s7jsxfzkuoume64zcw_chcks.png"></p><br><p>  Checkout starts the payment process, namely, it calls the <a href="https://developer.rbk.money/api/">createPayment ()</a> method, passing as an argument the card data token received earlier and starts the polling process of the events, actually, once per second, calling the <a href="https://developer.rbk.money/api/">getInvoiceEvents ()</a> API method. </p><br><p>  These requests through CAPI fall into Hellgate, which begins to implement the payment business process, while not using card data: </p><br><ul><li>  first of all, Hellgate goes to the configuration management service - Dominant and receives the current revision of the domain configuration.  It contains all the rules by which this payment will be made, then which bank it will go to for authorization, which transaction entries will be recorded and so on; <br><ul><li>  from the member management service, now it is part of HG, it finds out the data on the internal numbers of the merchant‚Äôs accounts for the benefit of which the payment is made, applies the amount of commissions, prepares the plan of transactions and stuffs it into the Shumway service.  This service is responsible for managing information about the movement of money in the accounts of participants in the transaction during the payment.  The posting plan contains the instruction ‚Äúto freeze the possible movement of funds in the transaction participants‚Äô accounts specified in the plan ‚Äù; </li><li>  enriches payment data by accessing additional services, for example, in Binbase, in order to find out the country of the issuing bank that issued the card and its type, for example, "gold, credit"; </li><li>  calls the inspector service, as a rule, this is Antifraud in order to get the payment scoring and decide on the choice of the terminal covering the risk level issued by the scoring.  For example, a terminal without 3D-Secure can be used for low-risk payments, and a payment that has received a fatal risk level will end its life there; </li><li>  calls the error detection service, the Faultdetector, and, based on the data received from it, chooses a payment transaction - the bank protocol adapter, which currently has the least amount of errors and the highest probability of a successful payment; </li><li>  sends a request to the selected bank protocol adapter, even if in this case it will be the YellowBank Adapter, ‚Äúauthorize the specified amount from this token‚Äù. </li></ul></li></ul><br><p>  The protocol adapter for the received token calls the CDS, receives the decrypted card data, translates it into a bank-specific protocol, and generally receives authorization ‚Äî confirmation from the acquiring bank that the specified amount is frozen in the payer's account. </p><br><p>  It is at this moment that you receive an SMS with a message about withdrawing funds from your card from your bank, although in fact the funds are in fact only frozen in your account. </p><br><p>  The adapter notifies HG of successful authorization, your CVV code is deleted from the CDS service and the interaction phase ends here.  Management returns to HG. </p><br><p><img src="https://habrastorage.org/webt/jv/mm/cu/jvmmcuhwjxslwo0rvu5w-lsfsyy.jpeg"></p><br><p>  Depending on <a href="https://developer.rbk.money/api/">what was</a> called when <a href="https://developer.rbk.money/api/">creatingPayment () was</a> called by the <a href="https://developer.rbk.money/api/">merchant of the</a> payment business process, HG expects an external API to call the authorization capture method, i.e., confirm the debit of money from your card, or does it immediately on its own, if the merchant chose the scheme single payment. </p><br><p>  <em>As a rule, most merchants use a single-stage payment, however there are business categories that, at the time of receiving authorization, do not yet know the total amount of the write-off.</em>  <em>This often happens in the tourism industry, when you book a tour for one amount, and after confirming your reservation, the amount is clarified and may differ from the one that was authorized at the beginning.</em> </p><br><p>  <em>Despite the fact that the amount of confirmation can only be equal to or less than the amount of authorization, there are pitfalls.</em>  <em>Imagine that you are paying with a card product or service in a currency other than the currency of your bank account to which the card is linked.</em> </p><br><p>  <em>At the time of authorization, your account blocks the amount based on the exchange rate on the day of authorization.</em>  <em>Since the payment may be in the status of "authorized" (despite the fact that the IPU has recommendations for the maximum period and now is 3 days) for several days, the authorization will be seized at the rate of the day on which it was made.</em> </p><br><p>  <em>Thus, you bear currency risks that can be both in your favor and against you, especially in a situation of high volatility in the currency market.</em> </p><br><p>  To capture the authorization, the same process of communication with the protocol adapter occurs as for its receipt, and if successful, HG applies the plan of posting to the accounts within Shumway, and transfers the payment to the "Paid" status.  It is at this moment that we, as a payment system, have financial obligations to the parties to the transaction. </p><br><p>  It is also worth noting that any changes in the status of the invoice machine, to which the payment process relates, are recorded by Hellgate in Machinegun, ensuring data persistence and enriching the invoice with new events. </p><br><h3 id="sinhronizaciya-sostoyaniy-avtomata-platezha-i-ui">  Synchronization of payment machine states and UI </h3><br><p><img src="https://habrastorage.org/webt/o7/hf/iz/o7hfizxfqdiyz_5xlxugdhc_fsq.jpeg"></p><br><p>  While the payment process takes place inside the platform, Checkout lightens processing by requesting events.  When receiving certain events, it draws the current status of the payment in a form understandable to the person ‚Äî draws a preloader, shows the screen ‚ÄúYour payment was successfully processed‚Äù or ‚ÄúPayment failed‚Äù or redirects the browser to the page of your issuing bank to enter the 3D-Secure password; </p><br><p>  In case of failure, Checkout will offer to choose another payment method or try again, thus launching a new payment within the invoice. </p><br><p>  Such a scheme with event polling allows you to restore the state even after the browser tab is closed - if you restart Checkout, it will receive the current list of events and draw up the current scenario of user interaction, for example, it will offer to enter the 3D-Secure code or show that the payment has already been successfully completed. </p><br><h2 id="replikaciya-sobytiy-v-offline-zone">  Offline Zone Event Replication </h2><br><p><img src="https://habrastorage.org/webt/ay/rm/sb/ayrmsbidsvdz2c9rxxkgge6easo.jpeg"></p><br><p>  Simultaneously with the machine control interfaces, Machinegun implements a service responsible for transferring the flow of events to services that are responsible for other, less online platform tasks. </p><br><p>  As a queuing broker in the finals, we settled on Kafka, although we previously implemented this functionality through the use of Machinegun itself.  In the general case, this service is the preservation of a guaranteed ordered stream of events, or the issuance of a specific list of events on request to other consumers. </p><br><p>  We also initially implemented the event deduplication scheme, providing guarantees that the same event will not be replicated twice, however, the load on Riak that generated such an approach made it refuse - after all, searching by indices is not the best that KV storage.  Now each service consumer is responsible for event deduplication. </p><br><p>  In the general case, the replication of events from Machinegun ends on the confirmation of saving data in Kafka, and consumers are already connecting to the Kafka topics and pumping out those lists of events that interest them. </p><br><h3 id="shablon-tipichnogo-prilozheniya-offline-zony">  Typical Offline Zone Application Template </h3><br><p>  For example, the Dudoser service is responsible for sending you an email notification of a successful payment.  When it starts, it downloads a list of events of successfully completed payments, takes the address and amount information from there, saves it to the local PostgreSQL instance and uses it for further processing of business logic. </p><br><p>  All other similar services operate according to the same logic as, for example, the Magista service, which is responsible for finding invoices and payments in the merchant‚Äôs personal account or the Hooker service, which sends asynchronous callbacks to the backend merchants, who for one reason or another cannot organize polling events, turning directly to the processing API. </p><br><p>  This approach allows us to unleash the processing load, allocating maximum resources and ensuring high speed and availability of payment processing, providing high conversion.  Heavy requests like "business customers want to see statistics on payments for the last year" are processed by services that do not affect the current load of the online part of the processing, and accordingly do not affect you, as payers and merchants, as our customers. </p><br><p>  Perhaps we‚Äôll stop on this in order not to turn the post into a too long longrid.  In future articles I will definitely tell you about the nuances of ensuring the atomicity of changes, guarantees and priority in a loaded distributed system using the example of Machinegun, Bender, CAPI and Hellgate. </p><br><p>  Well, about the Salt Stack next time already <code>¬Ø\_(„ÉÑ)_/¬Ø</code> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/447440/">https://habr.com/ru/post/447440/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447426/index.html">How, to whom and why go to consulting? Personal experience on the example of Big Data</a></li>
<li><a href="../447430/index.html">IntelliJ IDEA 2019.1: Customizing interface themes, switch expressions from Java 12, debugging inside Docker containers</a></li>
<li><a href="../447434/index.html">With love from Stepik: Hyperskill educational platform</a></li>
<li><a href="../447436/index.html">Webinar "Why do testers?"</a></li>
<li><a href="../447438/index.html">Unittest and abstract tests</a></li>
<li><a href="../447442/index.html">Introducing shell-operator: it's even easier to create operators for Kubernetes</a></li>
<li><a href="../447446/index.html">IBM workshops: spring-summer 2019 - artificial intelligence, development in the cloud, chat bots, blockchain and other technologies</a></li>
<li><a href="../447448/index.html">Evolution of the intellect: the beginning</a></li>
<li><a href="../447450/index.html">Breaking a simple quack with Ghidra - Part 1</a></li>
<li><a href="../447452/index.html">Supply Chain Security: "If I were a Nation State ..."</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>