<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Networks for the smallest. Part fourteen. Package path</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Forwarding entity always for packets 
 Zero, one or more of the forwarding entity's own transmit interfaces 
 and receive packets for each packet. 
 B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Networks for the smallest. Part fourteen. Package path</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <i>Forwarding entity always for packets</i> <i><br></i>  <i>Zero, one or more of the forwarding entity's own transmit interfaces</i> <i><br></i>  <i>and receive packets for each packet.</i> <i><br></i>  <i>Brian Petersen.</i>  <i>Hardware Designed Network</i> </blockquote><br>  One of the most amazing achievements of our time is how, while sitting in Norilsk, a person can chat with a friend in Thailand, at the same time buy a ticket for an evening plane to him, paying with a credit card, while somewhere in the States on his virtual machine the bot makes transactions on the exchange at the rate at which his son switches tabs when the father enters the room. <br><br>  And after 10 minutes, he will order a taxi through the application on the phone, and he will not even have to take cash on the road. <br><br>  At the airport, he would buy coffee, pay for hours, make a video call to his daughter in Berlin, and then launch a kintso online to pass the hour before landing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      During this time, thousands of MPLS tags will be hung and dropped, millions of calls to various tables will occur, base stations of cellular networks will transfer gigabytes of data, billions of packets of large and small in the form of electrons and photons with the speed of light will be sent to data centers around the world. <br><br>  Is this not electric magic? <br><br>  In our voyage to QoS, the theme promised many times, we will make another congress.  This time we will address the life of the package in the communication equipment.  Open this blue box and gut it. <br><br> <a href=""><img src="https://habrastorage.org/webt/pe/ql/0n/peql0nbkyvku4-eqlehd9yvfnyi.jpeg"></a> <br>  <i>Clickable and clickable.</i> <br><br><h4>  Today: </h4><br><ol><li>  Briefly about the fate and the path of the package </li><li>  Planes (they are also planes): Forwarding / Data, Control, Management </li><li>  Who and how handles traffic </li><li>  Chip types: from CPU to ASICs </li><li>  Network device hardware architecture </li><li>  Life's Journey </li></ol><br><a name="habracut"></a><br><hr><br>  Looking ahead, let's talk a little about the planes and introduce some definitions. <br><br>  So, there are <s>two planes, a</s> very clear division of the network device architecture into two parts: Control and Data Plane.  This is an elegant solution that years ago allowed us to abstract the traffic path from the physical topology, engendering packet switching, and which is the foundation of the entire industry today. <br><br>  <b>Data Plane</b> is the transfer of traffic from the input interfaces at the weekend - a little closer to the destination point.  Data Plane is guided by the routing / switching / tagging <b>tables</b> (hereinafter, we will refer to them as <b>forwarding tables</b> ).  There are places for delays - everything happens quickly. <br><br>  <b>Control Plane</b> is a layer of protocols that monitor network status and populate transfer tables (BGP, OSPF, LDP, STP, BFD, etc.).  You can slow down here - the main thing is to build the correct tables. <br><br>  For what this separation was necessary, read the relevant chapter. <br>  Since all the previous <a href="http://linkmeup.ru/sdsm">14 parts of the SDSM</a> were somehow about the control plane, this time we will talk about the forwarding plane. <br><br>  And first of all, we introduce the concept of transit and local packages. <br><br>  <b>Transit</b> packets are packets that are processed exclusively on the Data Plane and do not require transmission to the control plane.  They fly through the node quickly and transparently. <br><br>  These are mostly user (client) data, whose source and destination address is outside the device (and, most likely, the provider's network in general). <br>  Among the transit traffic may be protocol - internal for the provider's network, but not intended for this node. <br>  For example, BGP or Targeted LDP. <br><br>  <b>Local</b> are divided into three different types: <br><br><ul><li>  Intended for application on this device.  That is, either the destination address belongs to him (configured on him).  Either the destination address broadkastovy (ARP) or multicast (OSPF Hello), which the device should listen. <br><blockquote>  Here it is important to understand that we are talking about the address of the innermost transfer header: for example, for BGP or OSPF it is IP, for ISIS or STP it is MAC. <br>  At the same time, the packet, the <a href="http://lookmeup.linkmeup.ru/">DIP of</a> which is external, and <a href="http://lookmeup.linkmeup.ru/">DMAC</a> - local, remains transit, because the packet must be delivered to the output interface outside, not to the Control Plane. </blockquote></li><li>  Generated by this device.  That is, created on the CPU, on the Control Plane, and sent to the Data Plane. </li><li>  Transit packets requiring processing on the control plane.  Examples include packets that have expired TTL - you need to generate ICMP TTL Expired in Transit.  Or packages with IP Option installed: Router Alert or Record Route. </li></ul><br>  We in this article will talk about all.  But mostly it will be about the transit - because it is for them that the provider earns money. <br><br><hr><br><h1>  1. Briefly about the fate and the path of the package </h1><br><blockquote>  By package we mean PDUs of any level ‚Äî IP packets, frames, segments, and so on.  It is important for us that this is a package of information. <br><br>  The whole article, we will consider a modular node that forwards packets.  In order not to confuse the reader, we define that <b>it is a router</b> . <br><br>  All the arguments of this article, with amendments to the headers, protocols, and specific actions with the packet, are applicable to any network devices, be it a router, firewall, or switch ‚Äî their task: to transmit the packet to the next node closer to its destination. <br><br>  <i>In order to avoid misunderstandings and inappropriate criticism: the author is aware that the real situation depends on the specific device.</i>  <i>However, the objective of the article is to give a general understanding of the principles of operation of network equipment.</i> </blockquote><br>  We will select the following scheme as a starting point. <br><br><img src="https://habrastorage.org/webt/8y/q_/on/8yq_onbdkehkajybauuwyclbgvq.png" width="1100"><br><br>  Regardless of what kind of device, how traffic processing is implemented, a package needs to go this way. <br><br><ol><li>  The path is divided into two parts: the input and output paths. </li><li>  At the input, decapsulation occurs first - separation of the header from the payload and other inherent things in the protocol (for example, checksum calculation) </li><li>  Further, the stage of input processing (Ingress Processing) - the packet itself without a header (load) is buried in the buffer, and the header is analyzed.  Here you can apply policies to packages, search for a destination point and an output interface, create copies, etc. </li><li>  When the analysis is completed, the header is converted to metadata (temporary header), glued to the packet and transferred to the input queue.  It allows you not to send more to the output path than it can handle. </li><li>  Further, the packet can wait (or request) the explicit permission to move to the output queue, or it can simply be transferred there, and then, it seems, they will figure it out. </li><li>  There may be several output paths, so the packet then goes to the switching factory, the purpose of which is to deliver it to the correct one. </li><li>  On the output path there is also a queue - the output.  In it, packets expect output processing (Egress Processing): policies, QoS, replication, shaping.  Here are the future headers of the package.  Also, the output queue can be useful in order to not transfer more to the interfaces than they can miss. </li><li>  And the final stage is to encapsulate the packet in the prepared headers and transfer it further. </li></ol><br>  This simplified scheme is more or less universal.  Let's complicate it a bit by looking at the protocol stack.  For example, an IP router must first restore the stream of bits from an electrical impulse, further recognize which type of channel protocol is used, determine the frame boundaries, remove the Ethernet header, find out what is below it (let‚Äôs IP), transfer the IP packet for further processing. <br><br>  Then the scheme will look like this: <br><br><img src="https://habrastorage.org/webt/6_/-5/ac/6_-5accgfynpfvnygrvbfldbqsi.png" width="1100"><br><br><ol><li>  First, the module worked the <b>physical level</b> . <br><ul><li>  Using the <a href="http://lookmeup.linkmeup.ru/">ADC, it</a> restored the bitstream - in a sense, physical layer decapsulation. </li><li>  Working on a specific type of port (Ethernet), he understands that the output interface will be an Ethernet module. </li></ul></li><li>  Next comes decapsulation and input processing on the <b>Ethernet module</b> : <br><ul><li>  Frame boundaries, preambles, <a href="http://lookmeup.linkmeup.ru/">IFG</a> , <a href="http://lookmeup.linkmeup.ru/">FCS</a> </li><li>  Checksum calculation </li><li>  Removal of headings, analysis on fields </li><li>  Policing </li><li>  Determining the destination address ‚Äî it‚Äôs local ‚Äî and then the output interface ‚Äî to the IP module. </li></ul></li><li>  <b>IP</b> Inbound Processing: <br><ul><li>  Removal of headings, analysis on fields </li><li>  Policing </li><li>  Destination Address Analysis </li><li>  Search for output interface in the Forwarding Table </li><li>  Formation of temporary internal headers </li><li>  Gluing the time headers with the data and sending the packet to the output path. </li></ul><br></li><li>  <b>Processing in the input queue.</b> </li><li>  Shipment through <b>the switching factory.</b> </li><li>  <b>Processing in the output queue.</b> </li><li>  On the output path, the <b>IP</b> module performs Output Processing: <br><ul><li>  Policing, shaping </li><li>  Formation of the final header based on the metadata (time header) and its transfer to the Ethernet module. </li></ul><br></li><li>  Next Output Processing on <b>the Ethernet Module</b> <br><ul><li>  Search in the ARP table of the MAC address of the next node </li><li>  Ethernet header generation </li><li>  Checksum calculation </li><li>  Policing </li><li>  Descent to the physical module. </li></ul><br></li><li>  And the <b>physical layer module</b> in turn breaks up the bit stream into electrical impulses and transmits it to the cable. </li></ol><br>  <i>* The order of the operation is approximate and may depend on the implementation.</i> <br><br><hr><br>  All the above steps are decomposed into hundreds of smaller ones, each of which must be implemented in hardware or software. <br><br>  <b>That's the question - in hardware or software</b> .  It pursues the world of IP-networks from the moment of their foundation and, as usual, the development occurs cyclically. <br><br>  There are trivial things for which the element base exists ... mmm ... from the 60s.  For example, <a href="http://lookmeup.linkmeup.ru/">ADC</a> , hardware queues or CPU.  And there are those who have become a breakthrough relatively recently.  Some of the functions have always been and will be hardware, some will always be software, and some are torn like a monkey. <br><br><blockquote>  In this article, we will mostly talk about hardware devices, only making remarks about virtual ones. <br></blockquote><br><hr><br><h1>  2. Levels and planes </h1><br><img src="https://habrastorage.org/webt/v2/tx/q1/v2txq1ilntxxc5qbcrzu__xwhjo.png"><br><br>  We have used these concepts so many times before that it‚Äôs time to give them definitions.  There are three levels / planes in the operation of the equipment: <br><br><ul><li>  <b>Forwarding / Data Plane</b> </li><li>  <b>Control plane</b> </li><li>  <b>Management plane</b> </li></ul><br><br><img src="https://habrastorage.org/webt/zy/sq/ip/zysqipnbjnnjybnt1qxaexuiuec.png" width="1000"><br><br><hr><br><h2>  Forwarding / Data Plane </h2><br>  Shipping Plane. <br><br>  The main task of the network is to deliver traffic from one application to another.  And do it as quickly as possible, both in terms of bandwidth and delays. <br><br>  Accordingly, the main task of the node is to transfer the entered packet to the correct output interface as quickly as possible, having changed the headers and applying policies. <br><br>  Therefore, there are pre-filled packet transfer tables ‚Äî switching tables, routing tables, tags tables, neighborhood tables, and so on. <br><br>  They can be implemented on special CAM, TCAM chips operating at line speed (interface).  And there may be software. <br><br><blockquote>  Examples: <br><br><ol><li>  Accept an Ethernet frame, calculate a checksum, check if there is a <a href="http://lookmeup.linkmeup.ru/">SMAC</a> in the table of MAC addresses.  Find the <a href="http://lookmeup.linkmeup.ru/">DMAC</a> in the MAC address table, define the interface, transmit the frame. </li><li>  Accept the MPLS packet, define the input interface and the input label.  Search the label table, define the output interface and the output label.  Swear.  Transfer to. </li><li>  Came a stream of packages.  The output interface was <a href="http://lookmeup.linkmeup.ru/">LAG</a> .  The decision on which of the interfaces to send them is also made on the Forwarding Plane. </li></ol></blockquote><br><div class="spoiler">  <b class="spoiler_title">Difference between Data and Forwarding Plane</b> <div class="spoiler_text">  In the absolute majority of cases, it is considered that Data and Forwarding Plane are one and the same. <br>  However, sometimes they are separated. <br>  Then Data Plane means precisely the manipulation of the payload: the process of delivering a packet from the input interface to the output interface and processing it in buffers. <br>  And Forwarding Plane is handling the headers and making the forwarding decision. <br><br>  Like that: <br><img src="https://habrastorage.org/webt/if/c1/j3/ifc1j3de74krybbfjolg186uunq.png" width="800"><br></div></div><br><hr><br><h2>  Control plane </h2><br>  Control plane <br><br>  All over the head.  It <b>pre-</b> fills the tables on which traffic will then be transmitted. <br>  Protocols with complex algorithms that are expensive or impossible to perform in hardware work here. <br><br>  For example, <a href="http://lookmeup.linkmeup.ru/">the Dijkstra algorithm</a> can be implemented on a chip, but it is difficult.  It is also difficult to make the choice of the best BGP route or the definition of FEC and the distribution of tags.  In addition, for all this would have to make a separate chip or part of the chip, which practically can not be reused. <br>  In such a situation, it is better to sacrifice subsecond convergence in favor of convenience and price. <br><br>  Therefore, the software runs on a general purpose CPU. <br>  It turns out slowly, but flexibly - all logic is programmable.  And in fact, the speed on the Control Plane is not important.  Once the calculated route is installed in the FIB, and then everything is not the speed of the line. <br>  The speed of Control Plane arises with breaks, fluctuations on the network, but it is relatively successfully solved by the mechanisms of TE HSB, TE FRR, IP FRR, VPN FRR, when alternate routes are prepared in advance on the same Control Plane. <br><br><blockquote>  Examples: <br><br><ol><li>  We launched a network with IGP.  It is necessary to create Hello, agree on the parameters of the sessions, exchange databases, calculate the shortest routes, install them in the Routing Table, maintain contact through periodic Keepalive. </li><li>  <a href="http://linkmeup.ru/blog/65.html">BGP Update has arrived</a> .  Control Plane adds new routes to the BGP table, selects the best one, installs it in the Routing Table, and if necessary sends Update to it further. </li><li>  Admin enabled <a href="http://linkmeup.ru/blog/154.html">LDP</a> .  For each prefix, an <a href="http://lookmeup.linkmeup.ru/">FEC</a> is created, a label is assigned, placed in the label table, and announcements are sent to all LDP neighbors. </li><li>  Collected two switches per stack.  Select the main, index interfaces, update the table of shipments - the task of Control Plane. </li></ol></blockquote><br><br>  The work and implementation of Control Plane is universal: CPU + RAM: it works the same even on rack routers, even on virtual network devices. <br><br>  This system is not a thought experiment, not different functions of one program, it is really physically separated paths that interact with each other. <br>  It all started with the separation of the planes on different boards.  Then came stackable devices, where one performed intelligent operations, and the other was just an interface appendage. <br>  Yesterday is a system like the Cisco Nexus 5000 Switch + Nexus 2000 Fabric Extender, where 2000 acts as a remote interface card for 5000. <br>  SDN Spill 1.0 lives quietly somewhere in the parallel universe - with Openflow-like mechanisms, where Control Plane was brought to external controllers, and the transfer tables are poured into completely stupid switches. <br>  Our reality and the near future are overlay networks configured by SDN controllers, where services are abstracted from the physical topology at a higher level of hierarchy. <br>  And despite the fact that with each article we are more deeply immersed in the details, we learn to think freely and globally. <br><br>  The division into Control and Forwarding Plane allowed to decouple the transfer of data from the work of the protocols and the construction of the network, and this resulted in a significant increase in scalability and fault tolerance. <br>  So a single control plane module can support multiple interface modules. <br>  In the event of a failure on the control plane, the <a href="https://www.cisco.com/c/en/us/products/collateral/ios-nx-os-software/high-availability/solution_overview_c22-487228.html">GR, NSR</a> , <a href="https://www.juniper.net/documentation/en_US/junos/topics/concept/gres-overview.html">GRES</a> and <a href="https://www.juniper.net/documentation/en_US/junos/topics/concept/issu-on-qfx5100-overview.html">ISSU mechanisms</a> help the transfer plane to continue to operate as if nothing had happened. <br><br><hr><br><br><h2>  Management plane </h2><br>  Plane or demon of observation.  It is not always allocated in a separate plane, referring its tasks to the Control Plane, and sometimes, selecting, is called Monitoring. <br>  This module is responsible for the configuration and livelihoods of the site.  It monitors parameters such as: <br><ul><li>  Temperature </li><li>  Recycling </li><li>  Power supply </li><li>  Fan speed </li><li>  The efficiency of boards and modules. </li></ul><br><blockquote>  Examples: <br><br><ol><li>  Fell interface - alarm is generated, log and trap on the monitoring system </li><li>  Chip temperature rises - increases fan speed </li><li>  I found that one board stopped responding to periodic requests - it performs a restart of the boards - it suddenly rises. </li><li>  The operator connected via SSH to remove the diagonal information - the CLI is also provided with the Control Plane. </li><li>  Netconf configuration arrived - Management Plane checks and applies it.  If necessary, instructs the Control Plane about the changes that have occurred and the necessary actions. </li></ol></blockquote><br><br><hr><br>  So: <br>  <b>Forwarding Plane</b> - traffic transmission on the basis of transfer tables - actually, from which the operator derives profit. <br>  <b>Control Plane</b> is a service level necessary to create conditions for the work of Forwarding Plane. <br>  <b>Management Plane</b> - a module that monitors the overall state of the device. <br><br>  Together they make up a self-contained node in a packet switching network. <br><br><img src="https://habrastorage.org/webt/zy/sq/ip/zysqipnbjnnjybnt1qxaexuiuec.png" width="1000"><br><br>  The division into Control and Forwarding / Data Plane is not abstract - their functions are actually performed by different chips on the board. <br>  So Control Plane is usually implemented on a bunch of CPU + RAM + memory card, and Forwarding Plane on ASIC, FPGA, CAM, TCAM. <br>  <i>But in the world of virtualization of network functions, everything is mixed up - I will make this remark until the end of the article.</i> <br><hr><br><br><h1>  3. History of traffic processing </h1><br>  Now with Forwarding Plane, everything is fine: 10 Gb / s, 100 Gb / s - not difficult - pay and use.  Any policies without affecting performance.  But it was not always so. <br>  What is the difficulty? <br><br>  First of all, it is a question of organizing the paths described above: what to do with an electrical impulse from one cable and how to transfer it to another is correct. <br><br>  To do this, the network devices have a bunch of different chips. <br><br><img src="https://habrastorage.org/webt/r1/hy/uq/r1hyuqj4h8pqsbhl2gdx69ddiow.jpeg" width="1000"><br>  <i>This is an example of a Cisco interface card.</i> <br><br>  For example, microcircuits (ASIC, FPGA) perform simple operations, such as <a href="http://lookmeup.linkmeup.ru/">ADC</a> / <a href="http://lookmeup.linkmeup.ru/">DAC</a> , checksum counting, packet buffering. <br><br>  You also need a module that can parse, analyze and form packet headers. <br>  And a module that will determine where, in which interface, the packet should be transferred.  It is necessary to do this for every package of God. <br>  Someone should also monitor whether the packet can be passed at all.  That is, check it for falling under the ACL, control the flow rate and discard if it is exceeded. <br><br>  Here you can also include more complex functions of address translation, firewall, balancing, etc. <br><br>  Historically, all complex actions were performed on the CPU.  The search for a suitable route in the routing table was implemented as a program code, and a check for compliance with policies was also implemented.  The processor coped with it, but only he coped with it. <br><br>  What makes this clear is clear: the performance will fall the stronger, the more traffic the device must grind and the more functions we will hang on it.  Therefore, one after another, most of the functions were delegated to individual chips. <br>  And from the usual x86-server routers have become specialized network boxes stuffed with incomprehensible details and interfaces.  And Ethernet hubs are reborn as intelligent switches. <br><br>  ASIC, FPGA, Network Processor took on the functions of parsing the headers and analyzing them, as well as searching for the output interface. <br>  Queuing, QoS provisioning, congestion management are also specialized ASICs. <br>  Things like a stateful firewall stayed on the CPU, because the number of sessions is inedible. <br><br>  Another question: we have to store switching tables somewhere.  Something fast. <br>  The first thing that comes to mind is a classic RAM. <br>  The problem with it is that the address to it goes to the address of the cell, and it already returns its contents (or content, not in Russian if). <br>  However, the incoming packet does not carry the address of the memory cell, but only MAC, IP, MPLS. <br>  Then we would have to have a certain hash algorithm, which, using the CPU, would calculate the cell address and extract the necessary data from there. <br>  The only port bandwidth of 10 Gb / s means that the CPU should transmit 1 bit every 10 ns.  And it has about 80 ¬µs to transmit a packet of one kilobyte in size. <br><br>  However, hash calculation is very simple algorithm, and any self-respecting ASIC will cope with this.  The engineers were asked the question - what next to do with the hash? <br>  This is how <b>CAM - Content Addressable Memory appeared</b> .  Its addresses are hashes of values.  In its cell, the CAM contains either a response value (port number, for example) or, more often, a cell address in normal RAM. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, the Ethernet frame came, ASICs were torn to the headers, </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DMAC was</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pulled out </font><font style="vertical-align: inherit;">- they drove it through the CAM and received the desired outgoing interface. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Read more about CAM further.</font></font><br><hr><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What's wrong with you IP? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I knowingly took the example of an Ethernet frame. </font><font style="vertical-align: inherit;">IP is another story. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MAC switching is simple: neither you aggregate routes, nor you Longest Prefix Match - only 48 unique bits. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But in IP it's all there. </font><font style="vertical-align: inherit;">We may have several routes in the Routing Table with different mask lengths and choose the longest one. </font><font style="vertical-align: inherit;">This is the basic principle of IP routing, with which you can not argue and do not get around. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, there are complex ACLs with their wildcard masks.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For a long time there was no solution to this problem. At the dawn of packet-switched networks, IP packets were processed on the CPU. And the main problem of this is not even switching at the line speed (although it too), but the effect of additional settings on performance. Even now you can see it on some home microtic, if you configure a dozen ACLs on it - you will immediately notice how the bandwidth will drop. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Internet grew, the politician grew bigger, and the bandwidth requirements jumped up and down, and the CPU became a stumbling block. Especially considering that sometimes it was necessary to do a search for a route not once, but to recursively plunge deeper and deeper.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So in the dashing 90s MPLS was born. </font><font style="vertical-align: inherit;">What a brilliant idea - to build in advance the path to the Control Plane. </font><font style="vertical-align: inherit;">Addressing in MPLS will be a label of a fixed length, and accordingly a single entry in the table of labels is needed, what to do with the package. </font><font style="vertical-align: inherit;">At the same time, we do not lose the flexibility of IP, because it is the basis, and we can use CAM. </font><font style="vertical-align: inherit;">Plus the MPLS header is short (4 bytes versus 20 in IP) and extremely simple. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, ironically, at the same time, engineers have made a breakthrough by developing a TCAM - Ternary CAM. </font><font style="vertical-align: inherit;">And since then there have been almost no restrictions (although not without reservations). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More from TCAM further. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As for MPLS, which in view of this event was supposed to die suddenly, barely born, he cut the door to another house. </font><font style="vertical-align: inherit;">But we have already </font></font><a href="http://linkmeup.ru/blog/154.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">talked</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about this </font><font style="vertical-align: inherit;">.</font></font><br><br><hr><br><blockquote><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oh brave new world </font></font></h3><br>     SDN  NFV   .     ,   ,     ,        . <br><ul><li>           . </li><li>           ,      . </li><li>   (Service Chain),   Anti-DDoS, IDS/IPS, FW  ,       . </li></ul><br><br>        .         . CAM, TCAM, NP, ASIC     DPDK     ,     ‚Äî <a href="https://sdnblog.ru/what-is-sr-iov/">SR-IOV</a> ‚Äî         . <br><br>  ,     ,     CAM/TCAM     . <br>            Forwarding Plane. <br><br>               . <br></blockquote><br><hr><br><br><h1> 4. - </h1><br> <i>          ‚Äî  ,     .</i> <br><br><h2> CPU ‚Äî Central Processing Unit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The slowest but most flexible element of the device is the central processor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He handles protocol packets and complex behavior. </font></font><br><br><img src="https://habrastorage.org/webt/mh/9v/0d/mh9v0ddkui2dqpxac0at8hgqlna.png" width="1000"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Its charm is that it is controlled by running applications and "multitasking." The logic is easy to change, just by adjusting the program code. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Things like SPF, setting a neighborhood across all protocols, generating logs, crashes, connecting to user management interfaces ‚Äî all actions with complex logic ‚Äî occur on it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually, therefore, for example, you can observe that when the CPU is high, it becomes uncomfortable to work in the console. Although the traffic at the same time goes confidently. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The CPU assumes the functions of the Control Plane. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On devices with software forwarding, also participates in Forwarding Plane</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The CPU can be one for the whole node, or it can be separately on each board in the chassis with a distributed architecture. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The results of their work, the CPU writes in RAM ‚Üì.</font></font><br><br><hr><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RAM - Random Access Memory </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classic RAM - where without it? </font></font><br><br><img src="https://habrastorage.org/webt/rf/nh/-i/rfnh-i2fin7nwsmd015hik3olve.png" width="1000"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We give her the address of the cell - it is our content </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It stores the so-called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soft Tables</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (software tables) - routing tables, labels, MAC addresses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you run the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúshow ip route‚Äù</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">, the request goes exactly to the RAM to the Soft Tables. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The CPU works with RAM - when he calculated the route, or built the LSP - the result is recorded in it. And from there, the changes are synchronized in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hard Tables</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in CAM / TCAM ‚Üì. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, the entire contents of all tables are synchronized periodically in case suddenly for some reason the incremental changes did not come down correctly.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soft Tables cannot be directly used for data transfer, because it is too slow - accessing the RAM goes through the CPU and requires time-consuming algorithmic search. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With reservation on the NFV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, on the RAM (DRAM) chips the following queues are implemented: input, output, and interface.</font></font><br><br><hr><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CAM - Content-Addressable Memory </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a very clever kind of memory. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You are her value, and she you - the address of the cell. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content-Addressable means that the addressing is based on values ‚Äã‚Äã(content). </font></font><br><br><img src="https://habrastorage.org/webt/x2/fu/c-/x2fuc-9boi2-rn_p-kw4lfpdfh4.png" width="700"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The value, for example, may be, for example, DMAC. </font><font style="vertical-align: inherit;">CAM drives DMAC over all its records and finds a match. </font><font style="vertical-align: inherit;">As a result, CAM will issue the cell address in classic RAM, where the output interface number is stored. </font><font style="vertical-align: inherit;">Next, the device accesses this cell and sends the frame where it should be. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To achieve maximum speed, CAM and RAM are located very close to each other.</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Do not confuse this RAM with the RAM containing the Soft Tables described above - these are different components located in different places. </font></font><br></blockquote><br><br><img src="https://habrastorage.org/webt/1x/bn/3z/1xbn3zn1xmjlpupsf6k6guwtlwm.png" width="1000"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The beauty of CAM is that it returns a result in a fixed time, independent of the number and size of entries in the table ‚Äî O (1), in terms of the complexity of the algorithms. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is achieved due to the fact that the value is compared </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simultaneously</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with all records. At the same time! Not brute force. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the entrance of each storage cell in the CAM are comparing elements (I really like the term comparators), which can give out 0 (open) or 1 (closed), depending on what is received and what is recorded on them. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the comparing elements recorded just the desired value.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you need to find an entry in the table that corresponds to a particular value, this value is run simultaneously through ALL the matching elements. Literally, the electrical impulse that carries the values ‚Äã‚Äãhits all the elements, due to the fact that they are connected in parallel. Each of them performs a very simple action, issuing for each bit 1, if the bits match, and 0, if not, that is, closing and opening the contact. Thus, the cell whose address is the desired value closes the whole circuit, the electrical signal passes and feeds it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the architecture of such a memory:</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4a/19c/53b/f4a19c53b046347e97a17adb383f1d08.jpg"></div><br> <i><a href="https://www.sciencedirect.com/science/article/pii/S0141933113001348"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source of the picture</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is an example of the work</font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/694/ab9/c62/694ab9c629fe113103ff6bd86f7747a9.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Picture from the most interesting </font></font><a href="http://www.eecg.toronto.edu/~roman/teaching/1388/2004/finalProj/2004_ECE1388_FP_www/LRU_Cache/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">document</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And this is the implementation scheme:</font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/ac7/a67/42a/ac7a6742a542b9dc0659338df33da015.png"><br> <i><a href="https://www.pagiamtzis.com/cam/camintro/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Image Source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is something like a key-lock pair. Only a key with the correct geometry can put the lock pins in the correct positions and rotate the cylinder.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But we have many copies of one key and many different lock configurations. And we insert them all at the same time and try to turn, and the desired value lies behind the door, the lock of which will open the key.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For flexible use of CAM, we do not take directly the values ‚Äã‚Äãfrom the header fields, but calculate their hash.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The hash function is used for the following purposes:</font></font><br><ol><li>    ,    .   MAC-  48     16- ,    2^32    ,   ,  ,  CAM. <br>   -  ,            (,         ‚Äî     ). </li><li>         ‚Äî  ¬±  ‚Äî   .       ,      . <br>  , ,   ,    <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D1%2580%25D0%25B0%25D0%25B4%25D0%25BE%25D0%25BA%25D1%2581_%25D0%25B4%25D0%25BD%25D0%25B5%25D0%25B9_%25D1%2580%25D0%25BE%25D0%25B6%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">  </a> .   <a href="https://www.juniper.net/uk/en/training/jnbooks/distinguished-engineering/hardware-defined-networking/">Hardware Defined Networking</a>  ,          . </li><li>     ,     .         , , DMAC+EtherType,          . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is the hash that is encoded into the matching elements. </font><font style="vertical-align: inherit;">It is the hash of the desired value that will be compared with them. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the principle of CAM, it is similar to hash tables in programming, only implemented on chips. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MPLS switching also fits in well with this principle, which is why MPLS and IP matchmaking were in their time.</font></font><br><br>  For example: <br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The very first Ethernet frame arrived at the switch port. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The switch retrieved </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SMAC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , calculated its hash.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> He wrote down this hash in the comparing CAM elements, the interface number from which the frame came to RAM, and the cell address in the CAM cell itself in RAM. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I sent the initial frame to all ports. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repeated paragraphs. </font><font style="vertical-align: inherit;">1-5 ....</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The entire table of MAC addresses is full. </font></font></li><li>  Ethernet-.   ,     <a href="http://lookmeup.linkmeup.ru/">SMAC</a> (       CAM) ,  , . </li><li>  <a href="http://lookmeup.linkmeup.ru/">DMAC</a> ,   . </li><li>         CAM    . </li><li>   ,    . </li></ol><br><br> <b>:</b> <br><ul><li>  CAM  . </li><li>  CAM  ()      (RAM),      ‚Äî . </li><li>   CAM     ,      -.      CAM  ,  RAM. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verification of coincidence occurs </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simultaneously</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in all records, which is why CAM heats up, but it gives the result in constant time.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CAM + RAM store </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hard Tables</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (hardware tables) accessed by the switching chip.</font></font></li></ul><br><br><hr><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TCAM - Ternary Content-Addressable Memory </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We return to the question of what is wrong with IP. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we take the above described CAM, then on any </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DIP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it will very rarely be able to return 1 in all bits. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that DIP is always a single address, and the routes in the routing table are a subnet or even an aggregation of smaller routes. </font><font style="vertical-align: inherit;">Therefore, there can be almost no complete coincidence - except when there is a route / 32. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chip developers had two questions:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to implement it in principle? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to choose the best one (with the longest mask) from several suitable routes? </font></font></li></ul><br><br><img src="https://habrastorage.org/webt/q5/gk/qx/q5gkqx5u4xfnyuc7jrwo9xiqpei.png" width="1000"><br><br>  The answer was TCAM, in which <b>‚ÄúT‚Äù</b> means ‚Äúternary‚Äù. ‚ÄùIn addition to <b>0</b> and <b>1</b> , one more <b>X</b> value is entered -‚Äú not important ‚Äù(CAM is sometimes called BCAM - Binary, since there are two values ‚Äã‚Äã- 0 and 1). <br>  Then the search result of the desired entry in the switching table will be the contents of the cell where the longest string is 1 and the shortest is ‚Äúnot important‚Äù. <br>  For example, the packet is addressed in DIP 10.10.10.10. <br>  In the Routing Table we have the following routes: <br> <code>0.0.0.0/0 <br> 10.10.10.8/29 <br> 10.10.0.0/16 <br> 10.8.0.0/13 <br> .</code> <br>  Comparison elements TCAM recorded bits of the route, if the mask is 1, and "not important" if 0. <br>  When searching for the desired entry, TCAM, like CAM, runs the search value simultaneously across all cells.  The result will be a sequence of 0, 1 and ‚Äúnot important.‚Äù <br>  Only those entries that returned a sequence of units, followed by "not important" are involved in the next stage of selection. <br>  Further, from all the results, the one where the longest sequence of units is selected is how the Longest prefix match rule is implemented. <br>  Obviously, with our watchful eyes, we immediately saw that this would be a route on 10.10.10.8/29. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb8/2da/4fd/eb82da4fd9a0615846f863126a69a25f.png"><br>  <i><a href="http://thenetworksherpa.com/tcam-in-the-forwarding-engine/">Source of the picture</a> .</i> <br><br>  Decision on the brink of genius, for which he had to pay a big price.  Because of the very high density of transistors (each cell has its own set, and there must be millions of cells), they heat up no less than any CPU - you need to solve the issue of heat removal. <br>  In addition, their production is very expensive, and it will not be sly to say that the cost of network equipment is determined before and now by the presence and volume of TCAM. <br><br>  The attentive reader drew attention to the question of hash functions - after all, it transforms the original argument into something completely different from the source code, how do we compare 0, 1 and lengths?  Answer: the hash function is not used here.  The algorithm described above is a strong simplification of the real procedure, for details of this inquisitive reader I will send to the same book, <a href="https://www.juniper.net/uk/en/training/jnbooks/distinguished-engineering/hardware-defined-networking/">Hardware Defined Networking</a> . <br><br>  However, memory - it is memory - only stores.  She herself does not transmit traffic - someone must interact with it. <br><blockquote>  The author was unable to find generally accepted terms for the designation of certain components, therefore he took it upon himself to use his own terminological apparatus.  However, he is ready at any time to listen to the recommendations and adapt the article to universal definitions. <br></blockquote><br><br>  The component that deals with packet transmission is called a switching chip - <b>FE - Forwarding Engine</b> .  It is he who parses the headers, requests information in TCAM and redirects packets to the output interface. <br>  Work with the package is decomposed into many small steps, each of which must be performed at the line speed, and the cumulative time to complete the path must be adequate to the requirements of the network. <br>  An FE can be implemented on Network Processors (NP), FPGA, and Elementary ASICs or their sequences. <br><br>  Here with elementary ASIC and begin. <br><br><hr><br><br><h2>  ASIC - Application Specific Integrated Circuit </h2><br>  As the name implies, this is a microcircuit that solves a narrow range of specific tasks.  The operation algorithm is sewn into it and cannot be changed further. <br><br><img src="https://habrastorage.org/webt/hq/bo/ia/hqboia_avm_qxrvidxpzgzbxed4.png" width="1000"><br><br>  Accordingly, routine operations that will never change over time fall on the ASIC. <br>  ASIC deals with: <a href="http://lookmeup.linkmeup.ru/">ADC</a> , frame checksum calculation, clock recovery from Ethernet, collection of received and sent packets statistics. <br>  For example, we probably know where in the frame the <a href="http://lookmeup.linkmeup.ru/">DMAC</a> field, its length, how to distinguish between broadcasted, multicast and unicast.  These fundamental constants never change, so the functions that use them can be algorithmized by hardware, not by software. <br><br>  The development and debugging process of ASIC is quite laborious, since there is no place for errors in the final chip, but when it is completed, they can be shipped by KAMAZ vehicles. <br>  ASIC is cheap, because production is simple, massive, the probability of error is low, and the market is huge. <br><br>  According to Juniper's documentation, on the part of the devices, their PFE (Packet Forwarding Engine) is based on a sequence of ASICs and does not use more complex microcircuits. <br><br><blockquote>  A good example of using ASICs today is cryptocurrency mining farms.  Evolution has led this process from the CPU through clusters of GPUs to ASICs specialized exclusively in mining, which allowed reducing the size, power consumption and heat generation, making the process much cheaper and incredibly scalable, completely blasting away home-grown crypto-businessmen from the competitors card. <br></blockquote><br><br><h3>  Programmable ASIC </h3><br>  In recent years, there has been a tendency to implement most of the functions on the ASIC.  However, I want to leave the opportunity to program the behavior.  Therefore, the so-called Programmable ASIC, which have low cost, high performance and some fungus. <br><img src="https://habrastorage.org/webt/hq/vd/gd/hqvdgds29cqbo0tg8kmrhmco3f0.png" width="1000"><br><br><hr><br><br><h2>  FPGA - Field Programmable Gate Array </h2><br>  Not everything is up to ASICs.  All that concerns the minimum intelligence and the ability to influence the behavior of the chip - this is to the FPGA. <br><br><img src="https://habrastorage.org/webt/n0/ox/ef/n0oxefzljptqkfkvo5e74q0twl4.png" width="700"><br><br>  This is a programmable chip in which the firmware is poured, determining its role in the hardware. <br>  Like ASIC, FPGA is initially aimed at solving some problem. <br>  That is, FPGA for the packet network and for controlling the fuel supply to the engine injector are different things and you cannot turn things into one by the other. <br>  So, we have a specialized chip with the ability to control its behavior and modernize the algorithms. <br><br>  FPGA can be used for packet routing, remarking, polishing, and mirroring. <br>  For example, from the outside, we can tell the chip to catch all the BGP and LDP packets sent to the CPU in the <i>.pcap</i> file. <br><br>  Why is there flexibility and programming?  There are many examples: <br><ul><li>  The situation is higher, where you need to lay in it a new rule for polising, mirroring, marking </li><li>  introducing new functionality </li><li>  activation of the licensed option </li><li>  modernization of existing algorithms </li><li>  adding a new rule to analyze header fields, for example, to process a new protocol. </li></ul><br>  It turns out without developing new chips, soldering transistors, culling entire batches, just with new firmware, you can do all of the above and more. <br><br>  Again, if a malfunction is detected, then you can write a patch for the software that can fix it, and at the same time update only this particular chip without affecting the rest of the system. <br><br>  FPGA is significantly more expensive in design and production, mainly due to pre-built flexibility. <br><blockquote>  Due to the flexibility of the FPGA features, they are sometimes used to test a new technology, when using the firmware you can change the behavior of a component.  And when the logic is run-in, it is possible to launch ASIC into production, realizing it. <br></blockquote><br><br><hr><br><br><h2>  NP - Network Processor </h2><br>  In carrier-class equipment, where the requirements for both bandwidth and protocols running on the device are quite high, specialized chips ‚Äî network processors ‚Äî NP are often used.  In a sense, they can be considered as powerful FPGAs aimed specifically at processing and transmitting packets. <br><br><img src="https://habrastorage.org/webt/sv/in/xl/svinxl5czy1eof0brmcvjijl2nm.png" width="1000"><br><br>  Large telecom vendors are developing their own processors (Cisco, Juniper, Huawei, Nokia), for manufacturers there are offers from several giants, like Marvell, Mellanox. <br>  For example, a presentation of the new NP-chip Cisco 400Gb / s Full-duplex: <a href="https://www.nextplatform.com/2017/09/14/rare-peek-inside-400g-cisco-network-chip/">tyts</a> . <br>  And this is the description of the work of the Juniper Trio chipset, which, however, is positioned as a NISP (Network Instruction Set Processor), and not NP: <a href="https://www.juniper.net/us/en/local/pdf/whitepapers/2000331-en.pdf">tyts</a> . <br>  A little marketing and super-effective video about Nokia FP4: <a href="https://networks.nokia.com/solutions/fp4-network-processor">tyts</a> <br><br>  Tasks and capabilities are about the same as those of the FPGA.  The devil is in the details, where we will not go. <br><br><hr><br><br><h1>  5. Hardware architecture of the switching device </h1><br>  Usually, even on low-cost switches, the implementation of everything and everything on a single chip is not practiced.  Rather, it is a cascade of different types, each of which solves some part of the general problem. <br>  Next we look at the reference model, how this ‚Äúcan‚Äù work. <br><br>  For this model, we take a modular chassis consisting of interface and control modules and a switching factory. <br><div class="spoiler">  <b class="spoiler_title">Like this</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/2g/_v/c8/2g_vc8ownepow27e2spbnzi0m18.png" width="400"><br></div></div><br>  It will work with a standard bundle of IP, Ethernet. <br><br><hr><br><h2>  Common tire </h2><br>  A common bus (also known as Back Plane, also known as Midplane) of the device, connecting all modules with each other. <br>  Usually, this is just a battery of copper contacts without any microcircuits. <br><br><img src="https://habrastorage.org/webt/kv/cx/y6/kvcxy61vgosd22rmcw4wzgw7ueo.png" width="600"><br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text">  It looks like the back of the board, which is inserted into the bus <br><img src="https://habrastorage.org/webt/ko/zg/zk/kozgzkt1yxd0efcripwptbo1sds.jpeg" width="800"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">This is what a Juniper common bus looks like.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/iu/kv/j4/iukvj4wu8s52hhqkxa-fr80amo4.jpeg" width="800"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">This is the general Huawei tire.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bv/tc/2d/bvtc2di8lfy4zjdgyyfwpcwwjmi.jpeg" width="800"><br>  These two strips in the middle, filled with copper contacts, are slots for switching factories. <br></div></div><br><br><hr><br><h2>  Control module </h2><br><br><img src="https://habrastorage.org/webt/rq/xj/vy/rqxjvydkz5gr0qwxvnlsdjykzu0.png" width="700"><br><br>  It contains the CPU, RAM, permanent memory for storing software, configuration and logs, interfaces for management. <br>  He is responsible for the Management Plane and Control Plane. <br>  We work with it when we connect to the device via telnet / ssh. <br>  It loads the software into RAM and runs all other modules when power is applied. <br>  It monitors the Heart beat of other modules - special packages, the receipt of which indicates that the module is alive and working. <br>  He can also restart the module if the Heart beat is not received (either programmatically or turn off the power on the board). <br>  The protocol packets are delivered to the CPU, and after processing them, it performs some action, such as: writing updates to the switching tables, generating a response packet, requesting information about any component, and so on. <br>  The control module is engaged in the calculation of SPF, LSP, the establishment of neighbors for different protocols.  It writes switching tables in the Soft Tables of RAM. <br><br><div class="spoiler">  <b class="spoiler_title">This is how control boards of different devices look like.</b> <div class="spoiler_text">  Cisco ASR9000 RSP (Routing and Switching).  That half is closer to us.  The one closest to the bus is the switching factory. <br><img src="https://habrastorage.org/webt/q7/va/_1/q7va_1f1at7lhnutazhbzqwbfvg.jpeg" width="1000"><br><br>  Huawei NE40E-X8 MPU <br><img src="https://habrastorage.org/webt/c3/mc/ql/c3mcqlpjfm2z3fraglyzgd0rsru.png" width="1000"><br><br>  Juniper RE100 <br><img src="https://habrastorage.org/webt/v8/yf/xu/v8yfxuf0oala0bbqg6woijtov2g.jpeg" width="1000"><br><br>  RE Juniper 1800 <br><img src="https://habrastorage.org/webt/l_/-o/pa/l_-opasusnwbyl9knji2estaq5k.jpeg" width="1000"><br>  In all photos you can easily find the CPU, RAM and BIOS battery.  Some have HDD, others have Compact Flash.  Yes, you are right - this is a regular PC.  Moreover, modern control boards do have performance at the computer level of 5-6 years of age. <br></div></div><br><br><hr><br><h2>  Interface module or line card </h2><br>  This is a module that carries physical interfaces and FE (switching chip) and performs the functions of Forwarding Plane. <br><br><img src="https://habrastorage.org/webt/f0/4l/oy/f04loyek4mwbqogxwkxvuomo6ha.png" width="700"><br><br><div class="spoiler">  <b class="spoiler_title">This is what Cisco's line card looks like.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/j0/k7/6q/j0k76qe4foc99appxtoy89qjd58.jpeg" width="800"><br></div></div><br><br>  The module consists of many components that can be implemented both in a single chip (System-on-Chip) and on many individual ones depending on the class of the device and the architecture. <br><br><img src="https://habrastorage.org/webt/bd/da/lk/bddalkqpkl8dsebhhonu3j59ixe.png" width="1000"><br><br><h4>  PIC - Physical Interface Card </h4><br>  The PIC contains interfaces and a chip that performs basic traffic operations: <br><ol><li>  Recovers the bit stream from electrical pulses </li><li>  Recovers a packet from a set of bits. </li><li>  Removes overhead information (such as: preamble, <a href="http://lookmeup.linkmeup.ru/">IFG</a> ). </li><li>  Calculates the checksum and <br><ul><li>  a) if it beats with the value in the packet, skips it, removing unnecessary headers, for example <a href="http://lookmeup.linkmeup.ru/">FCS</a> . </li><li>  b) if it does not beat, discards the packet and increases the counter of discarded packets with an error. </li></ul><br></li><li>  Calculates statistics: <br><ul><li>  number of packages </li><li>  total traffic </li><li>  peak values </li><li>  port recycling </li><li>  Unicast / Broadcast / Multicast number </li></ul><br></li><li>  The PIC can also restore the SynchroEthernet signal, if necessary. </li></ol><br>  In case the line card is modular, the interface card will be removable and replaceable. <br><br><div class="spoiler">  <b class="spoiler_title">This is what Juniper MIC (Modular Interface Card) looks like, combined with a PIC chip.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jz/az/rm/jzazrm1xllwfzby4hyhuq5spgjg.jpeg" width="800"><br></div></div><br>  Typically, PIC chips are ASICs. <br><br><h4>  FE - Forwarding Engine </h4><br>  As already described above, it implements such functions as: <br><ul><li>  Requests to CAM / TCAM </li><li>  Soft Table to Hard Table Transformation </li><li>  Decision on packet transmission (ACL, polising) </li><li>  Switching / Routing </li><li>  Priority marking </li><li>  Mirroring </li><li>  Protocol packet detection </li><li>  Signal / packet processing from the CPU. </li></ul><br><br>  Further <b>ATTENTION</b> !  This is one of the most important moments of the whole article! <br><br>  First, FE is divided into <b>Ingress FE</b> and <b>Egress FE</b> .  The first processes the packets on the input path, respectively, the second - on the output. <br>  On the one hand, this division is terminological - the packet came to Ingress FE and then it should be sent to the Egress FE, possibly another board. <br>  On the other hand, the separation is often quite physical: within the same FE chip, these two entities live: Ingress and Egress.  This is logical, because the board can be both an entry point and an exit point. <br>  Secondly, it is the input FE that determines the entire fate of the packet within the node: <br><ul><li>  View future headlines </li><li>  Priority inside the node and when transferring outside </li><li>  Output FE and Interface </li><li>  Which of the physical members of the <a href="http://lookmeup.linkmeup.ru/">LAG</a> or <a href="http://lookmeup.linkmeup.ru/">ECMP</a> </li></ul><br>  <i>* with a slight reservation that the output path can still replicate the packet or kill it because of the overflowing buffer.</i> <br>  Third, the FE must identify the protocol packets in transit traffic and transmit them to the CPU. <br>  Accordingly, receiving packets (or instructions) from the CPU is also his job. <br><br>  Next to the FE are the CAM, TCAM and RAM, where FE is looking for the output interface and ACL checks. <br>  They store hard tables. <br><br>  In addition, Ingress FE replicates BUM traffic ‚Äî it sends one copy of the packet to each Egress FE.  And Egress FE already makes as many copies, how many interfaces to send <br><br><h4>  QoS or TM - Traffic Management </h4><br>  Sometimes in the FE itself, sometimes as a separate chip, further comes the QoS chip, combined with the queue, usually referred to as Traffic Management. <br>  The input queue (the queue on the input path) is needed in order not to overflow the output (the queue on the output path). <br>  The output queue is designed to avoid a phenomenon known as Back Pressure ‚Äî when packets arrive at the FE chip faster than it is able to process.  This situation is impossible with Ingress FE, because it is connected to such a number of interfaces that it is able to digest the traffic from them, or Ethernet via Flow Control will take the situation under its Control. <br>  But on Egress FE, traffic can merge from many different cards (read Ingress FE) - and it chokes on it - it's like sending two bytes. <br>  The task of the queue is not only smoothing surges of traffic, but also manageable to drop packets when it becomes inevitable.  Namely, to discard low-priority packets from the queue with a higher probability than high-priority packets.  Moreover, it is desirable to monitor overloading at the interface level - because if you need to send 13 Gb / s of traffic through a 10 Gigabit interface, 3 of them will definitely be discarded, while a 400 Gbps FE will not even be close to overload. <br><br>  The scheme is rather complicated - there are two queues, which means double buffering, moreover, you need to elaborate on the interfaces somehow, another question arises: what if one interface is overloaded, then the entire input queue will come up? <br>  These difficulties were not resolved before, but today they are addressed to the VOQ mechanism - the Virtual Output Queue.  VOQ is beautifully described <a href="https://www.juniper.net/documentation/en_US/junos/topics/concept/cos-qfx-series-voq-understanding.html">in this post</a> . <br>  In a nutshell, this is the virtualization of all the queues between different FEs.  There is one physical DRAM memory chip on the input path, which is internally divided into virtual queues.  The number of input queues - the total number of weekends.  The output queue is no longer actually located on the output module ‚Äî it is only virtual in the same DRAM. <br><br>  So (take the Juniper example), if there are 72 output interfaces with 8 queues on each, for a total of 576 input queues on each interface module (read TM).  If there are 6 modules on the device, then it should support 3456 VOQ. <br>  This elegantly removes the issue of double buffering and <a href="https://en.wikipedia.org/wiki/Head-of-line_blocking">Head of Line Blocking</a> problems, when one output queue at the moment of overload blocks all physical input - now with VOQ only the virtual one that is associated with it. <br><img src="https://habrastorage.org/getpro/habr/post_images/039/f5f/d8b/039f5fd8b7d99a828c61a2428a6783f8.gif" width="700"><br><img src="https://habrastorage.org/getpro/habr/post_images/36e/a18/a78/36ea18a78b28f7f3447a3af119d70446.gif" width="700"><br><br>  In addition, the packet is now discarded if necessary on the input queue, and it is not necessary to send it to the factory and clog the output queue. <br><br>  What else is important to know about the queue, is that even those packets that are destined for another interface of the same FE must pass through the input and output queues. <br>  This is necessary for the same struggle with Back Pressure.  Only queues can protect the FE from overloads and drop excess traffic according to priorities, so there is no direct bridge for transit traffic between Ingress FE and Egress FE. <br>  However, such ‚Äúlocal‚Äù traffic should not be sent to the factory. <br>  But about QoS, we'll talk more in the next part. <br><br><h4>  SerDes - Serializer, Deserializer </h4><br>  Another chip on the interface board is SerDes.  In the case when there are several switching chips - between them you need to organize the connectivity with each and every one.  Switching factories are used for this purpose and, as it turned out, it works best not with packets, but with cells of the same length.  The task of SerDes is to cut packages into cells before being sent to the factory and then assemble them back - Serialize and Deserialize. <br><br><h4>  Distributed Control Plane </h4><br>  In the case of a distributed Control Plane architecture, the CPU and the RAM can also be located on the interface board.  In this case, most of the work on the Control Plane can be performed by the local CPU, unloading the one located on the control board. <br><br><div class="spoiler">  <b class="spoiler_title">It looks like PFE on Juniper</b> <div class="spoiler_text">  Under the large square radiator in the center lies Forwarding ASIC (FE), under the fact that the smaller one on the left is TCAM.  Under ASIC is a 512 MB RAM block of storage for Hard Tables. <br>  The blue puck is the CPU of the distributed Control Plane.  Flash memory is slightly to the left, and RAM is below (this is not Soft Tables, but a RAM for storing temporary data). <br>  Near the same battery.  That is also quite a computer. <br><img src="https://habrastorage.org/webt/hz/ew/vf/hzewvfk6raaw-em4splpcrlfj9s.png" width="1000"><br>  This is part of the line card that implements the logic ‚Äî as you can see, there are no ports on it. <br><br>  Separately, interface cards are inserted into another slot: <br><img src="https://habrastorage.org/webt/5u/ie/ow/5uieowfbdksftm4i_jkncavbq2a.jpeg" width="1000"><br><br><img src="https://habrastorage.org/webt/hq/a3/8v/hqa38vam6nbyvhzii8tt_3vtilw.jpeg" width="1000"><br></div></div><br><br><hr><br><h2>  Switching factory </h2><br><br><img src="https://habrastorage.org/webt/nf/u9/_z/nfu9_zjo1h91vfs3gicj5ix9cp0.png" width="700"><br><br>  If we take a carrier-class Hi-End router, then usually it can have up to two dozen interface cards, each of which has at least one FE switching chip.  Each switching chip looks part of its legs towards the interfaces, and partly towards the back of the bus.  And there are plenty of legs, because the copper environment has its own limit in terms of throughput - we need one or two outputs. <br><img src="https://habrastorage.org/webt/8d/48/tu/8d48tuqoxldivpeahf6tqebubzu.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to connect with each other two switching chips? </font><font style="vertical-align: inherit;">Well, just the same: </font></font><br><img src="https://habrastorage.org/webt/jq/wb/y1/jqwby1d1zaug5nssjn3ngjgdq8m.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to connect three chips with each other? </font><font style="vertical-align: inherit;">Well, probably something like that? </font></font><br><img src="https://habrastorage.org/webt/df/pa/v-/dfpav--s8_hkn9-9wuha87g9kbo.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to tie 8?</font></font><br><img src="https://habrastorage.org/webt/kc/cd/ze/kccdzeml2g5gfo15qx4ueanhto4.png"><br><br>  Sure?  Nothing confuses? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The capacity of the system of 8 chips remains the same as that of the pair - because each time we reduce the number of legs for communication. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second point is, how do we even create a fully connected topology if there are 16 chips, for example, and each of them has 32 contacts? 16 * 15/2 bundles of cables with 32 cores in each? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This issue was addressed to Klose's non-blocking networks or networks without oversubscription. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have input switching elements (Ingress FE), output (Egress FE) and transit. The transit task is to associate input with output. Any input is associated with any output through the transit. </font></font><br><img src="https://habrastorage.org/webt/w-/g9/wn/w-g9wn1w4rbfbdwwpgpixpsbmro.png" width="600"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input and output are not directly connected to each other, transit also have no connection.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Need more input and output switching elements - add transit. Need more? Add a new cascade of transit: </font></font><br><img src="https://habrastorage.org/webt/ij/lf/q8/ijlfq8wvq-mq4aiwww5-rla6rsy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is what the switching boards in modern routers are crammed with - very stupid ASICs, which only know how to quickly shift packets from input to output. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The switching board is connected to the back bus and has connectivity with all other cards. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually they work in the N + 1 mode - that is, everyone shares the load, but when one board fails, the rest take over. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, the boards themselves can be quite called the upper cascade of the Kloz factory hierarchy. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There was only a question on the cells. Well, they would shift these ASICs and packages right away, why else would they be cut? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can draw an analogy with </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECMP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If someone has ever set up a per-pack balancing between different paths, then he will surely remember how much pain it caused. Out-of-order packet delivery, which TCP can handle in half, can break IP telephony or video, for example. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem with peer-to-peer balancing is that two packets of one stream can easily go different ways. At the same time, one of them is small and reaches the receiver very quickly, and the other accelerate overgrown gets stuck in a narrow buffer. So they are disordered. </font></font><br><img src="https://habrastorage.org/webt/nf/gb/3u/nfgb3ufvstzl93ylhhwcvnulgya.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same thing happens in the factory. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A good method of dealing with this is thread balancing - a hash is calculated from a value tuple (SMAC, DMAC, SIP, DIP, Protocol, SPort, DPort, MPLS tag, etc.) and all packets of one stream begin to be transmitted in one way.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But it works imperfectly. Often, one very oily stream can load one link while others will stand idle. And this can be put up with on the operator‚Äôs network, but not within this blue box. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An elegant solution is as follows: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Packages are cut into cells of the same small size. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cells are balanced by cell. That is, one cell here, another - there, the third - in the next link, and so on. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each cell is numbered, so when it arrives at the desired FE, it is easily assembled back into a complete package. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the distance from the input to the output is about the same, the sizes of the cells are the same, the time of their delivery is also about the same.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The idea of ‚Äã‚ÄãCharles Clos, which was first implemented at telephone exchanges, then borrowed into Ethernet switches and then routers, has now found its place in the data center networks, replacing the classic three-tier model. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is how switching factories look.</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huawei NE40E-X16: </font></font><br><img src="https://habrastorage.org/webt/pr/ir/nq/prirnqsuehzu_07tllnmzr71cgy.jpeg" width="1000"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Often the factory is combined with the control module in one slot to save space in the chassis and optimize ventilation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juniper: </font></font><br><img src="https://habrastorage.org/webt/zt/ie/dk/ztiedk80tos_jpvas5d1snthzhe.png" width="1000"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huawei NE40E-X8:</font></font><br><img src="https://habrastorage.org/webt/5k/y7/aw/5ky7awjkxlus359wp8yvvwn3ej4.png" width="1000"><br></div></div><br><br><hr><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Life's Journey </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A package exists exactly within the device. </font><font style="vertical-align: inherit;">The cable is an electromagnetic pulse. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is born on the input interface, where the PIC recovers it from the bitstream, and dies on the output, crashing back into them. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, we can consider finding a package within one device as a lifetime. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider two cases - transit packets and protocol packets.</font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transit packages </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose we are dealing with a standard Ethernet / IP packet. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The node is an IP router. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The package should be in transit from L3 port A to L3 port B.</font></font><br><br><img src="https://habrastorage.org/webt/p0/wn/9i/p0wn9i4io7_jvol74d8rgskz5ye.png" width="900"><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The optical signal comes to port. </font><font style="vertical-align: inherit;">Here it is converted into electrical impulses.</font></font></li><li>    PIC,  <a href="http://lookmeup.linkmeup.ru/"></a>     . <br>    Ethernet    Ethernet-.     ,      . <br>    Ethernet    .       FCS. <br>  ,   FCS  . <br>   ‚Äî   ,        1. <br>    PIC   : , ,     Unicast, Broadcast, Multicast. </li><li>   Ethernet        FE. </li><li> FE  <a href="http://lookmeup.linkmeup.ru/">DMAC</a>  ,   CAM  ,     . <br>    CAM    RAM. <br>  Ethernet   ,  DMAC ‚Äî  MAC-  .    RAM ,    ‚Äî       Payload  IP (     EtherType  ). <br><br>  FE   IP   (Payload).     ,         . <br>      ? <br><ul><li>   (IP   ,    MAC, MPLS- .) </li><li>  (DSCP, IEEE802.1p, EXP .) </li><li>  TTL. </li><li> <i>    ,    ,     (, , ).</i> </li></ul><br><br> ,      ,    . <br><ul><li>  TTL  1  ,     0.   ‚Äî    CPU   <a href="http://lookmeup.linkmeup.ru/">ICMP TTL Expired in Transit</a> . </li><li>   ACL ‚Äî      . </li><li>        <a href="http://lookmeup.linkmeup.ru/">DIP</a> . <br> Ingress FE    TCAM    ,   IP-.        RAM. <br> FE  RAM  Egress FE,    NextHop. <br>    Ingress FE     MAC- Next-Hop'    (Adjacenies Tables). <br>   FE          (BUM-  ,   L2VPN),         <a href="http://lookmeup.linkmeup.ru/">LAG</a>  <a href="http://lookmeup.linkmeup.ru/">ECMP</a>   . <br><blockquote>          (      Ethernet),   -   (BFD, )     CPU (BGP, OSFP .) <br></blockquote></li><li>        CoS-,           .          . </li></ul><br><br>          ,    Egress FE: <br><ul><li> Egress FE </li><li>   </li><li>  A priority </li><li>  TTL </li><li> Next Hop (MAC-) </li></ul><br><br> Egress FE   ,       ;   ‚Äî   ,   ;  ‚Äî ,        , ,      (DSCP); TTL ‚Äî    ,      ;  Next Hop MAC   ,     DMAC Ethernet-. </li><li>            .               Egress FE. </li><li>               ,       . </li><li>      ,    SerDes  . </li><li>      . <br>    ,   . <br>      (2-4),        .  ,         . <br>       ‚Äî  ,      . </li><li>        SerDes  ,         . </li><li>     . <br>     FE     (Back Pressure).       .         CoS,   .   ,      . <br>          ,    . <br><br>       QoS:    ,  ,  , . <br><br>   VOQ (Virtual Output Queue),  ,         :    10 /    13. <br>                 PIC. </li><li>         Egress FE. </li><li>      Egress FE      : <br>   ,   TTL,    Ethernet,       <a href="http://lookmeup.linkmeup.ru/">SMAC</a>  ,  <a href="http://lookmeup.linkmeup.ru/">DMAC</a>    (,  MAC     Ingress FE,   ). <br>     ,     ( , ). </li><li>      PIC,    ,    FCS,    IFG,     . </li><li>   , ,      ,    . </li></ol><br><br><img src="https://habrastorage.org/webt/wg/0r/xp/wg0rxpfifyapubhdy5evtk4orek.gif" width="700"><br><br><hr><br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most of the local packets are processed by the CPU. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let me remind you that local are those that were created on this node, which are intended for him (unicast), which are intended for all / many (Broadcast or Multicast) or that intentionally require processing on the CPU (TTL Expired, Router Alert). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inbox</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Right up to FE, the same thing happens with them as with transit ones. Further, the switching chip, turning to the CAM, sees that the DMAC is the MAC address of the local device, looks into the EtherType. If it is any BPDU or ISIS PDU, then the packet is immediately transferred to the desired protocol. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If IP - transmits it to the IP module, which, looking into the TCAM, sees that the </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DIP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also local - then you need to look in the Protocol field of the IPv4 header (or Next Header IPv6). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The protocol is determined, the decision is made on which module to forward the packet to - BFD, OSPF, TCP, UDP, etc. And so the package unfolds until the end, until the destination application is found. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When Ingress FE coped with this, the contents of the packet are transmitted to the CPU via a special communication channel. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this step, sufficiently intelligent devices apply a policy to limit the speed of protocol packets transmitted to the CPU, so that telnet alone will not block the processor. </font></font><br><br><img src="https://habrastorage.org/webt/zg/a7/2i/zga72imjmldvb3cmuweclxhkz5w.png" width="900"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If this packet brought topology change information (for example, a new OSPF, LSA), Control Plane needs to update the Soft Tables (RAM), and then the changes go down to Hard Tables (CAM / TCAM + RAM).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If a packet requires a response, the device should form it and send it back to the original source (for example, TCP Ack on the incoming BGP Update) or send it somewhere further (for example, OSPF LSA or RSVP Resv). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outgoing</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> protocol packets are formed on the CPU - it fills all the fields of all headers based on Soft Tables and then, depending on the implementation, drops it to Ingress or Egress FE.</font></font><br><blockquote> - ,     ,      <b></b> .   ,   FE,  ,  FE  Lookup   . <br>       , ,     ACL,        ,       .   <s> ,</s>     . <br>  ,     CPU , , . <br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are some Control Plane protocols that are still processed in hardware. </font><font style="vertical-align: inherit;">A prime example is the BFD. </font><font style="vertical-align: inherit;">Its timers get out up to 1 ms. </font><font style="vertical-align: inherit;">CPU, as we remember, is a flexible but clumsy thing, and while the BFD packet passes through the entire path and turns to the BFD header, until the processor reaches an interrupt, until it switches to it, reads the packet, generates a new one, sends tens, and hundreds of milliseconds - looking, and the BFD has already collapsed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, BFD packages in most cases are sorted on a chip, and the answer is being prepared on it. </font><font style="vertical-align: inherit;">And only the session itself is established via the CPU.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The big ones in this matter went even further, transferring the most routine operations to iron.</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, for example, Juniper introduced </font></font><a href="https://www.juniper.net/documentation/en_US/junos/topics/concept/routing-distributed-periodic-packet-management-ex-series.html"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPM - Periodic Packet Management</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which separates the Control Plane functions of some protocols between the control module and the interface module:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bidirectional Forwarding Detection (BFD) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connectivity Fault Management (CFM) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Link Aggregation Control Protocol (LACP) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Link Fault Management (LFM) </font></font></li><li> Multiprotocol Label Switching (MPLS) </li><li> Real-time Performance Monitoring (RPM) </li><li> Spanning Tree Protocol (STP) </li><li> Synchronous Ethernet (SYNCE) </li><li> Virtual Router Redundancy Protocol (VRRP) </li></ul><br></div></div><br><blockquote>       .    RTT         .        ,  ,   .   .  ICMP   CPU.       .      RTT   ,      CPU  . <br>       ICMP-   ICMP-   (NP, ASIC, FPGA),     CPU.        ping   . <br>  ,      ( <a href="http://blog.sbolshakov.ru/12-ethernet-oam/">OAM</a> ),  ,  <a href="https://www.cisco.com/c/en/us/td/docs/net_mgmt/prime/network/3-9/reference/guide/PrimeNetwork39_RefGuide/cfm_chapter.pdf">CFM</a> . <br></blockquote><br><br><hr><br><h1>  Conclusion </h1><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you have probably understood from the insane amount of ifs, it is impossible to describe hardware switching in a vendor-independent universal language. Worse, even if you take one vendor, its different lines of equipment and even different boards use completely different architecture. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, for example, Cisco has a platform with software routing, and there is a hardware. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Or on Huawei, the interface queue can be implemented on a TM chip, or maybe on a PIC. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Or where Cisco uses network processors, Juniper manages ASICs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For a box device, you need to remove the switching factories and search for the output chip. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The routers in the SOHO segment will most likely be missing CAM / TCAM.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Choreography around the queues, which can be done in a thousand different ways, deserves a separate 600 pages in the book The Neighboring Queue moves faster. The history of the lost RFC. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What to say about the modern world of virtualization, where they overthrow the old rulers and enthroned new ones.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In almost every paragraph, an experienced and corrosive reader will find what needs to be clarified, where to give a more detailed explanation. And it will be right ... and wrong at the same time. I had many doubts whether to put the heading ‚Äúsmall‚Äù or ‚Äúfull-grown‚Äù. And I put the ‚Äúlittle ones‚Äù, because this is only an introduction to the boundless world of hardware switching, which does not require profound knowledge of protocols or electrical engineering, and if I start to dive into the subtleties of implementations of various vendors, I‚Äôll risk never getting out of the swirling whirlpool of parts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope that this article will serve as a starting point in your life-long personal journey.</font></font><br><br><hr><br>  <b>Thanks</b> <br> <a href="https://t.me/metallicat20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Clipper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://t.me/glazgoo"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrey Glazkov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Alexey Krotov and the linkmeup team for reading the material and comments. </font></font><br> <a href="https://habrahabr.ru/users/Bormoglotx/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Marat Babayan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for providing photos of the equipment. </font></font><br> <a href="http://illustrators.ru/users/rabbits_manufactory"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artem Chernobay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the illustration. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My two employers, who, by showing patience or by virtue of their ignorance, were allowed to finish this article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All issues SDSM: </font></font><br> <a href="http://linkmeup.ru/blog/302.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13. Networks for the most experienced. Part thirteen. MPLS Traffic Engineering </font></font></a> <br> <a href="http://linkmeup.ru/blog/261.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. Networks for the harshest. Part twelfth. MPLS L2VPN</font></font></a> <br>  <a href="http://linkmeup.ru/blog/248.html">11.1.</a> <a href="http://linkmeup.ru/blog/248.html">   .  ‚Ññ6. MPLS L3VPN    </a> <br> <a href="http://linkmeup.ru/blog/204.html">11.    .  . MPLS L3VPN</a> <br> <a href="http://linkmeup.ru/blog/154.html">10.    .  .  MPLS</a> <br> <a href="http://linkmeup.ru/blog/129.html">9.    .  . </a> <br> <a href="http://linkmeup.ru/blog/92.html">8.1    .  ‚Ññ3. IBGP</a> <br> <a href="http://linkmeup.ru/blog/65.html">8.    .  . BGP  IP SLA</a> <br> <a href="http://linkmeup.ru/blog/50.html">7.    .  .</a>  <a href="http://linkmeup.ru/blog/50.html">VPN</a> <br> <a href="http://linkmeup.ru/blog/33.html">6.    .</a>  <a href="http://linkmeup.ru/blog/33.html">Part six.</a> <a href="http://linkmeup.ru/blog/33.html"> </a> <br> <a href="http://linkmeup.ru/blog/16.html">5.    :  . NAT  ACL</a> <br> <a href="http://linkmeup.ru/blog/15.html">4.    :  . STP</a> <br> <a href="http://linkmeup.ru/blog/14.html">3.    :  .  </a> <br> <a href="http://linkmeup.ru/blog/13.html">2.    .</a>  <a href="http://linkmeup.ru/blog/13.html">Part two.</a> <a href="http://linkmeup.ru/blog/13.html"></a> <br> <a href="http://linkmeup.ru/blog/12.html">1.    .</a>  <a href="http://linkmeup.ru/blog/12.html">Part one.</a> <a href="http://linkmeup.ru/blog/12.html">   cisco</a> <br> <a href="http://linkmeup.ru/blog/11.html">0.    .  .</a>  <a href="http://linkmeup.ru/blog/11.html">Planning</a> </div><p>Source: <a href="https://habr.com/ru/post/345270/">https://habr.com/ru/post/345270/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345260/index.html">Year of the bear. How Fancy Bear Spent 2017 Year</a></li>
<li><a href="../345262/index.html">How does it feel to create a game for Game Boy in 2017</a></li>
<li><a href="../345264/index.html">The effectiveness of advertising formats and networks in 2017: an analysis of 69 billion advertising hits</a></li>
<li><a href="../345266/index.html">Organization of musical accompaniment of the trading hall</a></li>
<li><a href="../345268/index.html">What to recognize on mobile platforms?</a></li>
<li><a href="../345274/index.html">How I wrote my own ERP system and what came of it</a></li>
<li><a href="../345276/index.html">One ordinary funny monday</a></li>
<li><a href="../345278/index.html">Implementing Search Using RxJava</a></li>
<li><a href="../345282/index.html">Devops in a bloody enterprise</a></li>
<li><a href="../345284/index.html">Selection of resources for a job seeker programmer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>