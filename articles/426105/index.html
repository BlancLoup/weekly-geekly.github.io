<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>My catch for the week</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The more a developer is working on an application in a team, and the better his code is, the more often he reads out the work of his comrades. Today I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>My catch for the week</h1><div class="post__text post__text-html js-mediator-article"><p>  The more a developer is working on an application in a team, and the better his code is, the more often he reads out the work of his comrades.  Today I will show you what can be caught in one week in code written by very good developers.  Under the cut is a collection of bright artifacts of our creativity (and some of my thoughts). </p><a name="habracut"></a><br><h3 id="komparatory">  Comparators </h3><br><p>  There is a code: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dto</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; } <span class="hljs-comment"><span class="hljs-comment">// another class List&lt;Long&gt; readSortedIds(List&lt;Dto&gt; list) { List&lt;Long&gt; ids = list.stream().map(Dto::getId).collect(Collectors.toList()); ids.sort(new Comparator&lt;Long&gt;() { public int compare(Long o1, Long o2) { if (o1 &lt; o2) return -1; if (o1 &gt; o2) return 1; return 0; } }); return ids; }</span></span></code> </pre> <br><p>  Someone will note that you can directly sort the stream, but I want to draw your attention to the comparator.  The <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html">documentation</a> for the <code>Comparator::compare</code> method is written in English and white: </p><br><blockquote>  Compares its two arguments for order.  Returns to a negative integer, zero or a positive integer. </blockquote><p>  This behavior is implemented in our code.  What is wrong?  The fact is that the creators of Java very far-sightedly assumed that such a comparator would be needed by many and made it for us.  We can only use it by simplifying our code: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;Long&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readSortedIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Dto&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Long&gt; ids = list.stream().map(Dto::getId).collect(Collectors.toList()); ids.sort(Comparator.naturalOrder()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ids; }</code> </pre> <br><p>  Similarly, this code </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;Dto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortDtosById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Dto&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ list.sort(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Comparator&lt;Dto&gt;() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto o1, Dto o2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o1.getId() &lt; o2.getId()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o1.getId() &gt; o2.getId()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> <br><p>  with a slight movement of the hand turns into such </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;Dto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortDtosById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Dto&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ list.sort(Comparator.comparing(Dto::getId)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> <br><p>  By the way, in the new version of "Idea" you can do this: </p><br><div class="spoiler">  <b class="spoiler_title">Go round magician</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/b_/om/ki/b_omkixybpa-jvxblirsruyvglo.gif"></p></div></div><br><h3 id="zloupotreblenie-optional-ami">  Abuse Optional </h3><br><p>  Probably each of us saw something like this: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;UserEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsersForGroup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long groupId)</span></span></span><span class="hljs-function"> </span></span>{ Optional&lt;Long&gt; optional = Optional.ofNullable(groupId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (optional.isPresent()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userRepository.findUsersByGroup(optional.get()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.emptyList(); }</code> </pre> <br><p>  Often, <code>Optional</code> used to check the presence / absence of a value, although it was not created for that.  Tie with abuse and write easier: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;UserEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsersForGroup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long groupId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groupId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.emptyList(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userRepository.findUsersByGroup(groupId); }</code> </pre> <br><p>  Remember that <code>Optional</code> is not about a method argument or a field, but about a return value.  That is why it is designed without serialization support. </p><br><h3 id="void-metody-menyayuschie-sostoyanie-argumenta">  void methods that change the state of the argument </h3><br><p>  Imagine this method: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractUpdater</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ContractRepository repository; <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateContractById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long contractId, Dto contractDto)</span></span></span><span class="hljs-function"> </span></span>{ Contract contract = repository.findOne(contractId); contract.setValue(contractDto.getValue()); repository.save(contract); } }</code> </pre> <br><p>  Surely you have seen and written many times like that.  Here I do not like that the method changes the state of the entity, but does not return it.  How do framework methods behave?  For example, <code>org.springframework.data.jpa.repository.JpaRepository::save</code> and <code>javax.persistence.EntityManager::merge</code> return a value.  Suppose after updating the contract we need to get it outside of the <code>update</code> method.  It turns out something like this: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anotherMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long contractId, Dto contractDto)</span></span></span><span class="hljs-function"> </span></span>{ updateService.updateContractById(contractId, contractDto); Contract contract = repositoroty.findOne(contractId); doSmth(contract); }</code> </pre> <br><p>  Yes, we could pass the entity directly to the <code>UpdateService::updateContract</code> , changing its signature, but it's better to do this: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractUpdater</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ContractRepository repository; <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Contract </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateContractById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long contractId, Dto contractDto)</span></span></span><span class="hljs-function"> </span></span>{ Contract contract = repository.findOne(contractId); contract.setValue(contractDto.getValue()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.save(contract); } } <span class="hljs-comment"><span class="hljs-comment">// @Transactional public void anotherMethod(Long contractId, Dto contractDto) { Contract contract = updateService.updateContractById(contractId, contractDto); doSmth(contract); }</span></span></code> </pre> <br><p>  On the one hand, it helps to simplify the code, on the other hand, it helps with testing.  In general, testing <code>void</code> methods for an unusually dreary task, which I will show using the same example: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(MockitoJUnitRunner.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractUpdaterTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractRepository repository; <span class="hljs-meta"><span class="hljs-meta">@InjectMocks</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractUpdater updater; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateContractById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Dto dto = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dto(); dto.setValue(<span class="hljs-string"><span class="hljs-string">"- "</span></span>); Long contractId = <span class="hljs-number"><span class="hljs-number">1L</span></span>; when(repository.findOne(contractId)).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Contract()); updater.updateContractById(contractId, contractDto); <span class="hljs-comment"><span class="hljs-comment">//void // ,       dto? -  : ArgumentCaptor&lt;Contract&gt; captor = ArgumentCaptor.forClass(Contract.class); verify(repository).save(captor.capture()); Contract updated = captor.getValue(); assertEquals(dto.getValue(), updated.getValue()); } }</span></span></code> </pre> <br><p>  But everything can be made easier if the method returns a value: </p><br><div class="spoiler">  <b class="spoiler_title">Make sure</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(MockitoJUnitRunner.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractUpdaterTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractRepository repository; <span class="hljs-meta"><span class="hljs-meta">@InjectMocks</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractUpdater updater; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateContractById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Dto dto = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dto(); dto.setValue(<span class="hljs-string"><span class="hljs-string">"- "</span></span>); Long contractId = <span class="hljs-number"><span class="hljs-number">1L</span></span>; when(repository.findOne(contractId)).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Contract()); Contract updated = updater.updateContractById(contractId, contractDto); assertEquals(dto.getValue(), updated.getValue()); } }</code> </pre> </div></div><br><p>  At one stroke, not only the call to <code>ContractRepository::save</code> checked, but also the correctness of the stored value. </p><br><h3 id="velosipedostroenie">  Cycling </h3><br><p>  For fun, open your project and look for this: </p><br><pre> <code class="java hljs">lastIndexOf(<span class="hljs-string"><span class="hljs-string">'.'</span></span>)</code> </pre> <br><p>  With high probability, the whole expression looks like this: </p><br><pre> <code class="java hljs">String fileExtension = fileName.subString(fileName.lastIndexOf(<span class="hljs-string"><span class="hljs-string">'.'</span></span>));</code> </pre> <br><p>  What no static analyzer can warn about is a newly invented bicycle.  Gentlemen, if you solve a certain task related to the file name / extension or the path to it, exactly like reading / writing / copying, then in 9 cases out of 10 the problem has already been solved.  So tie it up with cycling and take ready (and proven) solutions: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.commons.io.FilenameUtils; <span class="hljs-comment"><span class="hljs-comment">//... String fileExtension = FilenameUtils.getExtension(fileName);</span></span></code> </pre> <br><p>  In this case, you save the time that would be spent on checking the suitability of the bike, and also get more advanced functionality (see the <code>FilenameUtils::getExtension</code> ). </p><br><p>  Or this code, copying the contents of one file to another: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { FileChannel sc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(src).getChannel(); FileChannel dc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(targetName)).getChannel(); sc.transferTo(<span class="hljs-number"><span class="hljs-number">0</span></span>, sc.size(), dc); dc.close(); sc.close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { log.error(<span class="hljs-string"><span class="hljs-string">""</span></span>, ex); }</code> </pre> <br><p>  What circumstances can prevent us?  Thousands of them: </p><br><ul><li>  The destination can be a folder, not a file at all. </li><li>  the source may be a folder </li><li>  the source and destination can be the same file </li><li>  destination cannot be created </li><li>  etc. </li></ul><br><p>  The sadness is that using self-writing about everything we already know in the course of copying. <br>  If we do according to the mind </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.commons.io.FileUtils; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { FileUtils.copyFile(src, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(targetName)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { log.error(<span class="hljs-string"><span class="hljs-string">""</span></span>, ex); }</code> </pre> <br><p>  that part of the checks will be performed before the start of copying, and the possible exception will be more informative (see the source <code>FileUtils::copyFile</code> ). </p><br><h3 id="prenebrezhenie-nullablenotnull">  Neglecting @ Nullable / @ NotNull </h3><br><p>  Suppose we have an entity: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String email; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String petName; }</code> </pre> <br><p>  In our case, the <code>email</code> column in the table is described as <code>not null</code> , unlike petName.  That is, we can mark the fields with appropriate annotations: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.annotation.Nullable; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.annotation.NotNull; <span class="hljs-comment"><span class="hljs-comment">//... @Column @NotNull private String email; @Column @Nullable private String petName;</span></span></code> </pre> <br><p>  At first glance, this looks like a hint to the developer, and this is true.  At the same time, these annotations are a much more powerful tool than a regular label. </p><br><p>  For example, they are understood by development environments, and if after adding annotations we try to do this: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkIfPetBelongsToUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserEnity user, String lostPetName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user.getPetName().equals(lostPetName); }</code> </pre> <br><p>  then the ‚ÄúIdea‚Äù will warn us of the danger of this message: </p><br><blockquote>  Method invocation 'equals' may produce 'NullPointerException' </blockquote><p>  In code </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserEnity user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasEmail = user.getEmail() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasEmail; }</code> </pre> <br><p>  there will be another warning: </p><br><blockquote>  Condition 'user.getEmail () == null' is always 'false' </blockquote><p>  This helps the built-in censor to find possible errors and helps us better understand the execution of the code.  For the same purpose, annotations are useful to arrange over the methods that return value, and their arguments. </p><br><p>  If my arguments seem inconclusive, then look at the sources of any serious project, the same "Spring" - they are hung up with annotations like a Christmas tree.  And this is not a whim, but a harsh necessity. </p><br><p>  The only drawback, I think, is the need to constantly maintain annotations in the current state.  Although, if you look, it‚Äôs rather a blessing, because going back to the code over and over again, we understand it all the better. </p><br><h3 id="nevnimatelnost">  Inattention </h3><br><p>  There are no errors in this code, but there is a surplus: </p><br><pre> <code class="java hljs">Collection&lt;Dto&gt; dtos = getDtos(); Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) .filter(id -&gt; { List&lt;Integer&gt; ids = dtos.stream().map(Dto::getId).collect(toList()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ids.contains(id); }) .collect(toList());</code> </pre> <br><p>  It is not clear why creating a new list of keys that is being searched for, if it does not change when you walk through the stream.  Well, that the elements of all 5, and if they will be 100,500?  And if the <code>getDtos</code> method returns 100500 objects (in the list!), Then what performance will this code have?  No, so better like this: </p><br><pre> <code class="java hljs">Collection&lt;Dto&gt; dtos = getDtos(); Set&lt;Integer&gt; ids = dtos.stream().map(Dto::getId).collect(toSet()); Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) .filter(ids::contains) .collect(toList());</code> </pre> <br><p>  Also here: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, Q extends Query&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setParams</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Map&lt;String, Collection&lt;T&gt;&gt; paramMap, Set&lt;String&gt; notReplacedParams, Q query)</span></span></span><span class="hljs-function"> </span></span>{ notReplacedParams.stream() .filter(param -&gt; paramMap.keySet().contains(param)) .forEach(param -&gt; query.setParameter(param, paramMap.get(param))); }</code> </pre> <br><p>  Obviously, the value returned by the <code>inParameterMap.keySet()</code> expression is constant, so it can be put into a variable: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, Q extends Query&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setParams</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Map&lt;String, Collection&lt;T&gt;&gt; paramMap, Set&lt;String&gt; notReplacedParams, Q query)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;String&gt; params = paramMap.keySet(); notReplacedParams.stream() .filter(params::contains) .forEach(param -&gt; query.setParameter(param, paramMap.get(param))); }</code> </pre> <br><p>  By the way, such areas can be calculated using the check 'Object allocation in a loop'. </p><br><h3 id="kogda-staticheskiy-analiz-bessilen">  When static analysis is powerless </h3><br><p>  Eighth Java has died down long ago, but we all love streams.  Some of us love them so much that they use them everywhere: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;EmailAdresses&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserEmails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Stream&lt;UserEntity&gt; users = getUsers().stream(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (users.count() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Optional.empty(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> users.findAny(); }</code> </pre> <br><p>  Stream, as you know, is fresh before the call on it is completed, so a repeated call to the <code>users</code> variable in our code will result in an <code>IllegalStateException</code> . </p><br><p>  Static analyzers do not yet know how to report such errors, therefore responsibility for their timely catching falls on the reviewer. </p><br><p>  It seems to me that using variables of the <code>Stream</code> type, as well as transferring them as arguments and returning from methods, is like walking a minefield.  Maybe lucky, maybe not.  Hence the simple rule: any occurrence of <code>Stream&lt;T&gt;</code> in the code should be checked (and in an amicable way, immediately cut out). </p><br><h3 id="prostye-tipy">  Simple types </h3><br><p>  Many people believe that <code>boolean</code> , <code>int</code> , etc. is only about performance.  This is partly true, but beyond that, the default type is <code>not null</code> .  If the integer field of the entity refers to a column that is declared <code>not null</code> in the table, then it makes sense to use an <code>int</code> rather than an <code>Integer</code> .  This is a kind of combo - and memory consumption is lower, and the code is simplified due to the uselessness of checks for <code>null</code> . </p><br><p>  That's all.  Remember that all of the above is not the ultimate truth, think with your head and intelligently approach the use of any advice. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/426105/">https://habr.com/ru/post/426105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426095/index.html">Open webinar "How not to write in Python"</a></li>
<li><a href="../426097/index.html">Arduino. Project "Robot Machine RoboCar4W"</a></li>
<li><a href="../426099/index.html">Typegram news</a></li>
<li><a href="../426101/index.html">Data integrity in microservice architecture - how to ensure it without distributed transactions and rigid connectivity</a></li>
<li><a href="../426103/index.html">Webinar "Do you need Kubernetes" October 15 at 19:00</a></li>
<li><a href="../426111/index.html">Google is going to launch a censored search service in China</a></li>
<li><a href="../426113/index.html">Google News and Leo Tolstoy: Visualizing Vector Representations of Words with t-SNE</a></li>
<li><a href="../426115/index.html">Practice using the actor model in the back end platform of Quake Champions</a></li>
<li><a href="../426117/index.html">Ombudsman proposed to block ads with potentially dangerous children's products</a></li>
<li><a href="../426119/index.html">Antiquities: Cryptonomicon Iron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>