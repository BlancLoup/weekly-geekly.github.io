<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Control of integer ranges in FindBugs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FindBugs is an open source static code analyzer for Java (under the LGPL ). It contains many detectors that identify certain problems in the code. Rec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Control of integer ranges in FindBugs</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/825/895/c92/825895c9203cf34e9017a5576651ae2b.png" align="right"><br>  <a href="http://findbugs.sourceforge.net/">FindBugs</a> is an open source static code analyzer for Java (under the <a href="http://www.gnu.org/licenses/lgpl.html">LGPL</a> ).  It contains many detectors that identify certain problems in the code.  Recently, I am a participant in the project and am writing new detectors for it.  I will tell about one of them in this article.  We will also look at examples of bugs found in real projects. <br><a name="habracut"></a><br><h3>  FindBugs device </h3><br>  FindBugs does not analyze the source code, but bytecode.  This method has some drawbacks.  It is impossible to write a detector that is based only on incorrect formatting of the code (for example, it is possible that the else omitted else in else if, like <a href="http://www.viva64.com/ru/d/0265/">V646 in PVS-Studio</a> ).  It is impossible to detect some situations in which the same byte code is generated.  For example, it would be nice to detect such a strange code (which is issued with an IDEA warning and the same <a href="http://www.viva64.com/ru/d/0228/">PVS-Studio</a> ): <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(a &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { a++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  But if we replace while with if, the compilers will generate exactly the same bytecode, so FindBugs cannot see the difference.  It is important to keep this in mind when you use or plan to expand FindBugs. <br><br>  The <a href="http://commons.apache.org/proper/commons-bcel/">Byte Code Engineering Library (6.0-SNAPSHOT)</a> from Apache and sometimes <a href="http://asm.ow2.org/">ASM 5.0.2 is</a> used to work with bytecode.  Apparently, this situation happened for historical reasons: when the FindBugs project started, BCEL was the only suitable option, but now, unfortunately, it hardly develops.  In fact, the FindBugs authors themselves are refining it so that new versions of class files can be analyzed. <br><br>  The main part of the work of FindBugs is performed in detectors, which are involved in issuing warnings.  There are also special detectors that collect some information about the code (for example, build a call graph) and save it for future use by other detectors.  FindBugs works in two passes: on the first pass, these special detectors work mainly and they analyze not only the classes of the project itself, but also the classes of the libraries used.  There are also analysis factories that build a specific analysis of a class or method on the demand of a particular detector (for example, analyzing the flow of null and non-null values ‚Äã‚Äãwithin a method). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Task </h3><br>  I wanted to catch logical errors like these: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( x &gt; <span class="hljs-number"><span class="hljs-number">10</span></span> &amp;&amp; x &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  The second condition is obviously useless here, because if x is greater than 10, then it is at least as large as 5. The given example is very simple, although such errors occur in real code.  In general, the task is to find the conditions on the integers, which for any possible value of the number is always true or always false. <br><br><h3>  Control flow graph </h3><br>  In compilation theory, there is such a thing - control flow graph (CFG).  This is similar to the good old flowchart built on the program code: the vertices of the graph are the basic blocks, the code in which is executed linearly without any transitions, and the edges - the possible transition directions.  The control flow graph can be quite large even for a simple method, because most instructions can generate an exception, for which an edge is added.  The control flow graph for each method is already built in FindBugs, so it can be used.  This is how the graph for the method given above looked like: <br><img src="//habrastorage.org/files/80a/53c/988/80a53c9888d64824a5cf66e8710f40e1.png"><br><br>  For our task, we first need to select all the parameters and local variables that can participate in the analysis.  So far I have limited myself to those that never change (perhaps in the future the restriction will be relaxed).  That is, we are interested in parameters that are never assigned, and variables that are assigned exactly once.  Such a list is easy to compile by simply running over the instructions of the method in search of instructions for writing to a local variable.  For each variable, we initially set the allowable range of values.  For example, for the int type, this would be [Integer.MIN_VALUE..Integer.MAX_VALUE]. <br><br>  Next, we iterate over those CFG nodes that contain the condition.  If this is a comparison of a variable of interest with a constant, then we divide the corresponding interval according to the condition.  For example, for the condition x&gt; 5 we get [Integer.MIN_VALUE..5] + [6..Integer.MAX_VALUE], and for x! = 0 we get three intervals: [Integer.MIN_VALUE ..- 1] + {0} + [1..Integer.MAX_VALUE].  Also for each such condition, an interval is preserved that satisfies the condition. <br><br>  Then for each variable we are interested in we run through all the intervals of the definition domain and for each interval we walk along the flow graph, starting from the input node.  Moreover, if we find ourselves in a conditional node associated with a given variable, then we go only along one edge depending on whether the condition is met at a given interval, and mark which one we went through.  For all other nodes we go through all kinds of outgoing edges.  Our small method divides the domain of x into three intervals, for which the traversal of the graph will look like this: <br><img src="//habrastorage.org/files/9cc/d4c/9dd/9ccd4c9dd35647dd93ae0b7043e801ef.png"><br><br>  Note that in the first two cases the same thing happened.  In the end, it remains only to find edges that we have never reached and generate an error message on them.  If the final vertex of this edge was also not reached, this means that we have not just a useless condition, but also a code that will never be executed.  In this case, I increase the priority of the error message.  For the above example, there is an unreachable edge, but all vertices are reachable: <br><br><img src="//habrastorage.org/files/6a9/379/217/6a93792177084fbea071dbff805d2d36.png"><br><br>  And here is a simple method in which an unreachable vertex appears (the body of the if operator): <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( x &gt; <span class="hljs-number"><span class="hljs-number">10</span></span> &amp;&amp; x &lt; <span class="hljs-number"><span class="hljs-number">5</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  CFG will look like this: <br><br><img src="//habrastorage.org/files/ac5/32f/49d/ac532f49d9a2478a9d79e469c3034c25.png"><br><br><h3>  finally </h3><br>  It all worked great until I ran into finally.  Compilers duplicate finally-blocks in byte-code, which causes unattainable conditions that were not in the source.  Let's say such a simple example: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ) log.info(<span class="hljs-string"><span class="hljs-string">"x &lt;= 0!"</span></span>); } }</code> </pre><br><br>  The code is quite normal, but in the compilation process it turns into something like this (without taking into account possible exceptions): <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ) log.info(<span class="hljs-string"><span class="hljs-string">"x &lt;= 0!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ) log.info(<span class="hljs-string"><span class="hljs-string">"x &lt;= 0!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  As a result, our new detector complains that in the first case, x &lt;= 0 is always false and there is a dead code, and in the second, that x &lt;= 0 is always true.  There was no ready-made solution for analyzing such situations in FindBugs.  Only in the null analysis some assumptions are made based on the table of line numbers.  It seemed to me unreliable (especially this table may not be), and I wrote a separate analyzer, which with a small amount of heuristics finds duplicate finally-blocks in byte code and can output all its duplicates for a given CFG edge.  Actually, in the process of this work, the idea was born to write a <a href="http://habrahabr.ru/post/245333/">comic article</a> .  Now I issue an error only if the edge was not reached in all duplicates. <br><br><h3>  Bugs found </h3><br>  Now the fun part.  I usually analyze a pack of open source projects for tests, so examples will be from different projects. <br><br><h4>  Errors due to a range of type values </h4><br>  This is a side effect of the analysis, about which I did not immediately think: sometimes the condition is useless, not because the condition above contradicts it, but because the type of the variable is limited.  I made a separate message for him.  Here is an example, about which I will not even speak, from which project it is.  This method with small variations was thoughtlessly copied into a dozen projects that use XML: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isNameStartChar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (ch &gt; bA &amp;&amp; ch &lt; aZ) || (ch &gt; ba &amp;&amp; ch &lt; az) || (ch == <span class="hljs-string"><span class="hljs-string">':'</span></span>) || (ch == <span class="hljs-string"><span class="hljs-string">'_'</span></span>) || (ch &gt; <span class="hljs-number"><span class="hljs-number">0xBF</span></span> &amp;&amp; ch &lt; <span class="hljs-number"><span class="hljs-number">0xD7</span></span>) || (ch &gt; <span class="hljs-number"><span class="hljs-number">0xD7</span></span> &amp;&amp; ch &lt; <span class="hljs-number"><span class="hljs-number">0xF7</span></span>) || (ch &gt; <span class="hljs-number"><span class="hljs-number">0xF7</span></span> &amp;&amp; ch &lt; <span class="hljs-number"><span class="hljs-number">0x300</span></span>) || (ch &gt; <span class="hljs-number"><span class="hljs-number">0x36F</span></span> &amp;&amp; ch &lt; <span class="hljs-number"><span class="hljs-number">0x37E</span></span>) || (ch &gt; <span class="hljs-number"><span class="hljs-number">0x37E</span></span> &amp;&amp; ch &lt; <span class="hljs-number"><span class="hljs-number">0x2000</span></span>) || (ch &gt; <span class="hljs-number"><span class="hljs-number">0x200B</span></span> &amp;&amp; ch &lt; <span class="hljs-number"><span class="hljs-number">0x200E</span></span>) || (ch &gt; <span class="hljs-number"><span class="hljs-number">0x206F</span></span> &amp;&amp; ch &lt; <span class="hljs-number"><span class="hljs-number">0x2190</span></span>) || (ch &gt; <span class="hljs-number"><span class="hljs-number">0x2BFF</span></span> &amp;&amp; ch &lt; <span class="hljs-number"><span class="hljs-number">0x2FF0</span></span>) || (ch &gt; <span class="hljs-number"><span class="hljs-number">0x3000</span></span> &amp;&amp; ch &lt; <span class="hljs-number"><span class="hljs-number">0xD800</span></span>) || (ch &gt; <span class="hljs-number"><span class="hljs-number">0xF900</span></span> &amp;&amp; ch &lt; <span class="hljs-number"><span class="hljs-number">0xFDD0</span></span>) || (ch &gt; <span class="hljs-number"><span class="hljs-number">0xFDEF</span></span> &amp;&amp; ch &lt; <span class="hljs-number"><span class="hljs-number">0xFFFE</span></span>) || (ch &gt; <span class="hljs-number"><span class="hljs-number">0x0FFFF</span></span> &amp;&amp; ch &lt; <span class="hljs-number"><span class="hljs-number">0xF0000</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ch &gt; 0xFFFF   }</span></span></code> </pre><br>  The last pair of conditions is meaningless: the value of a char variable cannot be greater than 0xFFFF.  If the authors planned to support such characters, it is necessary to analyze the UTF-16 surrogate pairs, the analysis of a single char is not enough. <br><br>  Here is a more specific - <a href="">Utility # encodeRun</a> from the IBM ICU project: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ESCAPE = <span class="hljs-string"><span class="hljs-string">'\uA5A5'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> &lt;T extends Appendable&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encodeRun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;length; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) ESCAPE) <span class="hljs-comment"><span class="hljs-comment">// value == 0xA5A5   buffer.append(ESCAPE); buffer.append((char) value); } } .... }</span></span></code> </pre><br>  ESCAPE when converting to int is equal to 0xA5A5 (42405) and can in no way equal to a variable of type short, which takes values ‚Äã‚Äãfrom -32768 to 32767. <br><br>  Some of these errors were already caught by FindBugs (for example, comparing byte with numbers greater than 127), now it is caught more.  But in general, it is not interesting, for such a general and IDE could follow without problems. <br><br><h4>  Used &amp;&amp; instead of || </h4><br>  One of the common blunders.  Usually found in validating input parameters, which is not always properly covered by unit tests.  For example, in <a href="">SegmentArrayWithData # setElementAt</a> in IntelliJ IDEA: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setElementAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; data &gt; Short.MAX_VALUE) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IndexOutOfBoundsException(<span class="hljs-string"><span class="hljs-string">"data out of short range"</span></span> + data); ... }</code> </pre> <br>  Here data&gt; Short.MAX_VALUE is meaningless, because there can not be a number at the same time less than 0 and more than 32767. As a result, a dead code is formed: the exception will never be thrown.  A similar bug was found in various projects, but I was surprised to see it in IDEA: they themselves have a built-in serious static analyzer, which probably should catch this.  Perhaps overlooked. <br><br><h4>  Used ||  instead of &amp;&amp; </h4><br>  This is much less common.  Here again from ICU - <a href="">ULocale # parseAcceptLanguage</a> : <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>: <span class="hljs-comment"><span class="hljs-comment">// before q value fraction part if ('0' &lt;= c || c &lt;= '9') { // c &lt;= '9'   ... } else { // invalid state = -1; } break;</span></span></code> </pre> <br>  The condition c &lt;= '9' is meaningless: if it turns out that c &lt;'0', then it is certainly &lt;= '9'.  As a result, the whole if is useless, the else branch will never be executed. <br><br><h4>  The same condition in two branches </h4><br>  Example from Eclipse Mylyn - <a href="">DefaultXmlStreamWriter # printEscaped</a> : <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printEscaped</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PrintWriter writer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attribute)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ String ref = getEntityRef(ch, attribute); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ref != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { writer.write(<span class="hljs-string"><span class="hljs-string">'&amp;'</span></span>); writer.write(ref); writer.write(<span class="hljs-string"><span class="hljs-string">';'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == <span class="hljs-string"><span class="hljs-string">'\r'</span></span> || ch == <span class="hljs-number"><span class="hljs-number">0x0085</span></span> || ch == <span class="hljs-number"><span class="hljs-number">0x2028</span></span>) { printHex(writer, ch); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ch &gt;= <span class="hljs-string"><span class="hljs-string">' '</span></span> &amp;&amp; ch != <span class="hljs-number"><span class="hljs-number">160</span></span> &amp;&amp; isUtf8Printable((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) ch) &amp;&amp; XML11Char.isXML11ValidLiteral(ch)) || ch == <span class="hljs-string"><span class="hljs-string">'\t'</span></span> || ch == <span class="hljs-string"><span class="hljs-string">'\n'</span></span> || ch == <span class="hljs-string"><span class="hljs-string">'\r'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ch == '\r'   writer.write((char) ch); } else { printHex(writer, ch); } }</span></span></code> </pre> <br>  Here the condition ch == '\ r' is in two else if branches.  Of course, only the first will work.  There is no dead code, but it is unclear what the author meant. <br><br><h4>  Mutually exclusive paragraphs </h4><br>  Here's a pretty fresh code from the same Mylyn - <a href="">EscapeBlock # canStart</a> : <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String line, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lineOffset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lineOffset == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Matcher matcher = START_PATTERN.matcher(line); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lineOffset &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// lineOffset &gt; 0   matcher.region(lineOffset, line.length()); } if (matcher.matches()) { return true; } } return false; }</span></span></code> </pre> <br>  If lineOffset is 0, then it can never be greater than 0. <br><br><h4>  Forgot what happened before? </h4><br>  Example from the project Jmol - <a href="">GromacsReader # readAtoms</a> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; modelAtomCount; ++i) { rd(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = line.length(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len != <span class="hljs-number"><span class="hljs-number">44</span></span> &amp;&amp; len != <span class="hljs-number"><span class="hljs-number">68</span></span>) { Logger.warn(<span class="hljs-string"><span class="hljs-string">"line cannot be read for GROMACS atom data: "</span></span> + line); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt; <span class="hljs-number"><span class="hljs-number">69</span></span>) <span class="hljs-comment"><span class="hljs-comment">// len &lt; 69   continue; float vx = parseFloatRange(line, 44, 52) * 10; float vy = parseFloatRange(line, 52, 60) * 10; ... }</span></span></code> </pre> <br>  At the beginning of the loop, the length of the line read from the file is checked.  If it is not equal to 44 or 68, issue a warning and proceed to the next iteration of the loop.  Toward the end of the iteration is another test for len: now if (len &lt;69).  Only two len values ‚Äã‚Äãcould reach here: 44 or 68. Both are less than 69, so the condition always works and the last 6 lines of the cycle will never be fulfilled. <br><br><h4>  Entangled in comparison operators </h4><br>  Again ICU - <a href="">CollationParsedRuleBuilder # isJamo</a> : <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJamo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (ch &gt;= <span class="hljs-number"><span class="hljs-number">0x1100</span></span> &amp;&amp; ch &lt;= <span class="hljs-number"><span class="hljs-number">0x1112</span></span>) || (ch &gt;= <span class="hljs-number"><span class="hljs-number">0x1175</span></span> &amp;&amp; ch &lt;= <span class="hljs-number"><span class="hljs-number">0x1161</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ch &lt;= 0x1161   || (ch &gt;= 0x11A8 &amp;&amp; ch &lt;= 0x11C2); }</span></span></code> </pre> <br>  The average pair of conditions finds numbers in the range from 0x1175 to 0x1161.  Of course, there cannot be such numbers, since 0x1161 is less than 0x1175.  Here we issue a warning that the condition ch &lt;= 0x1161 is useless.  Dead code is not formed, but there is definitely some kind of error. <br><br><h4>  Computation overflow </h4><br>  Here, <a href="https://habrahabr.ru/users/andrey2008/" class="user_link">Andrey2008</a> constantly asks if he can show funny bugs from the PVS-Studio code, found by PVS-Studio, and he answers that all the bugs are usually fixed right away, as they use incremental verification, and they don‚Äôt even get into the repository.  In general, this is also true for FindBugs: The Eclipse project in FindBugs is configured for incremental checking, so it is difficult to find something serious in FindBugs, testing it yourself.  But everything changes when you develop a new detector.  Then he can really find a very tasty bug in the old code, which is what happened.  See the <a href="">DumbMethods # checkForCompatibleLongComparison</a> Method <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkForCompatibleLongComparison</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OpcodeStack.Item left, OpcodeStack.Item right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left.getSpecialKind() == Item.RESULT_OF_I2L &amp;&amp; right.getConstant() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> value = ((Number) right.getConstant()).longValue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (value &gt; Integer.MAX_VALUE || value &lt; Integer.MIN_VALUE)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = Priorities.HIGH_PRIORITY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == Integer.MAX_VALUE+<span class="hljs-number"><span class="hljs-number">1</span></span> || value == Integer.MIN_VALUE -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//     priority = Priorities.NORMAL_PRIORITY; } ... }</span></span></code> </pre> <br>  This code (written, by the way, more than four years ago) is executed if in the source code being analyzed the number of type int is compared with the number of type long, which does not fit into the range int.  Such a comparison is meaningless, so the INT_BAD_COMPARISON_WITH_INT_VALUE warning is generated here.  It was supposed to set the priority lower if the comparison is made with a number that is on the border of a range of integers (Integer.MAX_VALUE + 1 or Integer.MIN_VALUE-1).  But the fact is that these expressions themselves are calculated in integers and an overflow occurs: instead of Integer.MAX_VALUE + 1 we get Integer.MIN_VALUE, and instead of Integer.MIN_VALUE-1 we get Integer.MAX_VALUE.  Moreover, the compiler performs this calculation, and the resulting number is already in the bytecode.  This is where my new detector flashed: it follows from the above condition that neither Integer.MIN_VALUE nor Integer.MAX_VALUE can be in value at this point.  As a result, the condition will never be fulfilled, and the priority will never be lowered.  Of course, you should have written <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == Integer.MAX_VALUE+<span class="hljs-number"><span class="hljs-number">1L</span></span> || value == Integer.MIN_VALUE-<span class="hljs-number"><span class="hljs-number">1L</span></span>)</code> </pre> <br>  It is clear why this bug went unnoticed for years: users could not even guess about the intention of the authors to lower the priority in this case, and the tests in FindBugs usually check if there is a certain warning on a certain code or not, but do not check its priority. <br><br><h4>  Reinsurance </h4><br>  Quite a lot of messages are issued on reinsurance conditions such as: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ) { ... }</code> </pre> <br>  The second condition is obviously not necessary, although someone may argue that it additionally documents the code.  Nevertheless, I believe that if an explanation is needed, it is better to write it in a comment.  Anyway, earlier FindBugs already cursed such code: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( obj == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( obj != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ) { ... }</code> </pre> <br>  Therefore, I believe that I did not break the general concept. <br><br>  Another such code is found: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { ... <span class="hljs-comment"><span class="hljs-comment">//   if( x &gt; 0 ) { ... //   } ... }</span></span></code> </pre> <br>  Usually there is no error here, but it looks as if the author himself does not remember which branch of code he is in.  Perhaps this is a sign that the method is very complex. <br><br><h3>  Conclusion </h3><br>  Those who want to try a new detector can download the code from our <a href="https://code.google.com/p/findbugs/">repository</a> and compile it with ant.  If someone is too lazy to compile, I made unofficial assemblies from the current code - <a href="">findbugs.jar</a> and <a href="http://biorainbow.com/~lan/fb-unofficial/eclipse-daily/">Eclipse update site</a> (unfortunately, the official Eclipse daily site does not work).  The new alerts are called UC_USELESS_CONDITION and UC_USELESS_CONDITION_TYPE (category Dodgy code). <br><br>  If anyone is interested in the implementation, most of the code in the <a href="">ValueRangeAnalysisFactory</a> class, the detector itself is <a href="">RedundantConditions</a> , and the search for duplicate finally-blocks is <a href="">FinallyDuplicatesInfoFactory</a> .  The code is still inconclusive, but quite working.  There may be false drawbacks in asserts, we will deal with this. <br><br>  Errors are in any program, and static analysis is good. </div><p>Source: <a href="https://habr.com/ru/post/240121/">https://habr.com/ru/post/240121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240109/index.html">Our favorite CodeIgniter has found a new home.</a></li>
<li><a href="../240111/index.html">Birds are attacking quadrocopters: several attacks</a></li>
<li><a href="../240113/index.html">Google's beta service allows you to conduct video conferences with your doctor, directly from the results of search results for symptoms</a></li>
<li><a href="../240115/index.html">The digest of interesting materials for the mobile developer # 74 (October 6-12)</a></li>
<li><a href="../240119/index.html">How I developed a device for rocking a crib</a></li>
<li><a href="../240125/index.html">Maintenance work on the "Habrahabr"</a></li>
<li><a href="../240127/index.html">I'm afraid to make a mistake</a></li>
<li><a href="../240129/index.html">3D image of Mars based on photographs of the Indian orbiting satellite Mangalyaan + photo from Rosetta</a></li>
<li><a href="../240131/index.html">Money as a measure of trust</a></li>
<li><a href="../240135/index.html">"Habrahabr" represents Geektimes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>