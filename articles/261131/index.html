<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Internal representation of values ‚Äã‚Äãin PHP 7 (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kore Nordmann 

 In the first part, we looked at the high-level differences in the internal representation of values ‚Äã‚Äãbetween PHP 5 and PHP 7. As you...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Internal representation of values ‚Äã‚Äãin PHP 7 (part 2)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/745/f0f/957/745f0f9574b04b9f91a998e244071289.jpg" alt="image"><br>  <i>Kore Nordmann</i> <br><br>  In the <a href="http://habrahabr.ru/company/mailru/blog/257999/">first part,</a> we looked at the high-level differences in the internal representation of values ‚Äã‚Äãbetween PHP 5 and PHP 7. As you remember, the main difference is that <code>zval</code> no longer allocated separately and does not store refcount in itself.  Simple values, such as integer or floating point, can be stored directly in <code>zval</code> , while complex values ‚Äã‚Äãare represented using a pointer to a separate structure. <br><a name="habracut"></a><br>  All of these additional structures use a standard header defined using <code>zend_refcounted</code> : <br><pre> <code class="php hljs">struct _zend_refcounted { uint32_t refcount; union { struct { ZEND_ENDIAN_LOHI_3( zend_uchar type, zend_uchar flags, uint16_t gc_info) } v; uint32_t type_info; } u; };</code> </pre><br>  This header now contains the <code>refcount</code> , data type, information for the <code>gc_info</code> garbage <code>gc_info</code> , and also a cell for the type- <code>flags</code> .  Next, we look at the individual complex types and compare them with the implementation in PHP 5. In particular, we will focus on the links that have already been discussed in the first part of the article.  We will not touch the resources, since I do not find them interesting enough to be considered here. <br><br><h1>  Strings </h1><br>  In PHP 7, strings are represented using the type <code>zend_string</code> : <br><pre> <code class="php hljs">struct _zend_string { zend_refcounted gc; zend_ulong h; <span class="hljs-comment"><span class="hljs-comment">/* hash value */</span></span> size_t len; char val[<span class="hljs-number"><span class="hljs-number">1</span></span>]; };</code> </pre><br>  In addition to the <code>refcounted</code> header, the hash cache h, length <code>len</code> and <code>val</code> are also used here.  The hash cache is used to not recalculate the hash of the string each time the <code>HashTable</code> .  When first used, it is initialized as a non-zero hash. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you are not too familiar with the various hacks in C, then the definition of <code>val</code> may seem strange: it is declared as an array of characters with a single element.  But we certainly want to store strings longer than one character.  Here we use a method called ‚Äústruct hack‚Äù: although the array is declared with one element, but when creating a <code>zend_string</code> we define the possibility of storing a longer string.  In addition, it will be possible to access longer lines with <code>val</code> . <br><br>  Technically, this is an implicit feature, because we read and write a single-character array.  However, C compilers understand what's what, and successfully process the code.  C99 supports this feature as ‚Äúmembers of a dynamic array‚Äù, however, thanks to our friends from Microsoft, C99 cannot be used by developers who need cross-platform compatibility. <br><br>  The new implementation of a string variable has a number of advantages over ordinary strings in the C language. First, the length is now integrated into it, which no longer ‚Äúdangles‚Äù somewhere nearby.  Secondly, reference counting is used in the header, so it became possible to use strings in different places without using <code>zval</code> .  This is especially important for sharing hash table keys. <br><br>  But there is a big spoon of tar.  It is <code>zend_string</code> string of C language from <code>zend_string</code> (using str-&gt; val), but you can't directly get a <code>zend_string</code> from the C-string.  To do this, you have to copy the value of the string into the newly created zend_string.  Especially annoying when it comes to working with text strings (literal string), that is, constant strings (constant string), found in the original C-code. <br><br>  A string can have various flags stored in the corresponding GC field: <br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">#define IS_STR_PERSISTENT (1&lt;&lt;0) /* allocated using malloc */ #define IS_STR_INTERNED (1&lt;&lt;1) /* interned string */ #define IS_STR_PERMANENT (1&lt;&lt;2) /* interned string surviving request boundary */</span></span></code> </pre><br>  Persistent strings use the regular system allocator instead of the Zend memory manager (ZMM), and therefore there may be more than one request.  If you specify the used allocator as a flag, you can transparently use persistent strings in <code>zval</code> .  In PHP 5, this required prior copy to ZMM. <br><br>  Isolated (interned) lines are those lines that are not destroyed until the request is completed and therefore do not need to use a reference counter.  They are deduplicated, so when creating a new isolated line, the engine first checks to see if there is another one with the same value.  In general, all the lines in PHP code (including variables, function names, etc.) are usually isolated.  Immutable strings are isolated strings created prior to the start of a query.  They are not destroyed at the end of the request, as opposed to isolated. <br><br>  If OPCache is used, isolated lines will be stored in shared memory (SHM) and used by all PHP processes.  In this case, immutable lines become useless, since the isolated and so will not be destroyed. <br><br><h1>  Arrays </h1><br>  I will not go into details regarding the new implementation of arrays.  I will mention only about immutable arrays.  This is a kind of analogue of isolated lines.  They also do not use the reference counter and are not destroyed until the end of the request.  Due to some memory management features, immutable arrays are used only when OPCache is running.  What this gives can be seen from the example: <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; ++$i) { $array[] = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>]; } var_dump(memory_get_usage());</code> </pre><br>  With OPCache enabled, 32 MB of memory is used, and without it, as much as 390, since in this case each element of <code>$array</code> receives a new copy of <code>['foo']</code> .  Why make a copy instead of increasing the reference count?  The fact is that the VM string operands do not use a reference counter, so as not to break the SHM.  I hope that in the future this catastrophic situation will be corrected and it will be possible to abandon OPCache. <br><br><h1>  Objects in PHP 5 </h1><br>  Before we talk about the implementation of objects in PHP 7, let's remember how it was arranged in PHP 5 and what were the drawbacks.  <code>zval</code> used to store <code>zend_object_value</code> , defined as follows: <br><pre> <code class="php hljs">typedef struct _zend_object_value { zend_object_handle handle; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zend_object_handlers *handlers; } zend_object_value;</code> </pre><br>  <code>handle</code> is a unique object ID used to search its data.  <code>handlers</code> are VTable function pointers that implement different object behavior.  For "normal" objects, this handler table will be the same.  But objects created by PHP extensions can use custom handler sets that change the behavior of objects (for example, overriding operators). <br><br>  The object identifier is used as an index in the ‚Äúobject repository‚Äù.  It is an array: <br><pre> <code class="php hljs">typedef struct _zend_object_store_bucket { zend_bool destructor_called; zend_bool valid; zend_uchar apply_count; union _store_bucket { struct _store_object { void *object; zend_objects_store_dtor_t dtor; zend_objects_free_object_storage_t free_storage; zend_objects_store_clone_t <span class="hljs-keyword"><span class="hljs-keyword">clone</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zend_object_handlers *handlers; zend_uint refcount; gc_root_buffer *buffered; } obj; struct { int next; } free_list; } bucket; } zend_object_store_bucket;</code> </pre><br>  There are a lot of interesting things.  The first three elements are some kind of metadata (whether the object's destructor was called, whether this bucket was used at all, how many times the recursive algorithm addressed this object).  The <code>union</code> construction depends on whether the storage is currently being used or is on the free list.  The case when <code>struct_store_object</code> used is important to us. <br><br>  <code>object</code> is a pointer to a specific object.  It is not integrated into the object storage, since the objects do not have a fixed size.  The pointer is followed by three handlers responsible for the destruction, release and cloning.  Please note that in PHP, the operations of destroying and releasing objects are explicit procedures, although the first one may be skipped in some cases (unclean shutdown).  The cloning handler is virtually not used at all.  Since these store handlers do not belong to regular object handlers, instead of sharing, they are duplicated for each object. <br><br>  These storage handlers follow the pointer to normal <code>handlers</code> .  Those are saved if the object was destroyed without notifying the <code>zval</code> (in which handlers are usually stored). <br><br>  The repository also contains <code>refcount</code> , which gives certain advantages in view of the fact that in PHP 5 the reference counter is already stored in <code>zval</code> .  Why do we need two counters?  Usually <code>zval</code> ‚Äúcopied‚Äù by simply increasing the counter.  But it happens that full-fledged copies appear, that is, a completely new <code>zval</code> is created for the same <code>zend_object_value</code> .  As a result, two different <code>zval</code> use the same object storage, which requires reference counting.  This ‚Äúdouble counting‚Äù is a characteristic feature of the <code>zval</code> implementation in PHP 5. For the same reasons, the buffered pointer in the GC root buffer is duplicated. <br><br>  Consider the <code>object</code> referenced by the object repository.  Common objects in user space are defined as follows: <br><pre> <code class="php hljs">typedef struct _zend_object { zend_class_entry *ce; HashTable *properties; zval **properties_table; HashTable *guards; } zend_object;</code> </pre><br>  <code>zend_class_entry</code> is a pointer to a class whose essence is an object.  The following two elements are used to provide the storage of object properties in two different ways.  For dynamic properties (that is, those that are added at run time and are not declared in the class), the properties hash table is used, which connects the property names and their values. <br><br>  For the declared properties, optimization is used.  During compilation, each such property is written into an index, and its value is stored in the index in <code>properties_table</code> .  Relationships between names and an index are stored in a hash table in a class entry.  This prevents individual objects from overruning the hash table.  Moreover, the property index is polymorphically cached during execution. <br><br>  The <code>guards</code> hash table is used to implement the recursive behavior of "magic" methods like <code>_get</code> , but here I will not consider it. <br><br>  In addition to the aforementioned double reference counting, the representation of the object also requires a large amount of memory.  The minimum object with one property is 136 bytes (not counting zval).  Moreover, a lot of indirect addressing is used.  For example, to call a property from a <code>zval</code> object, you have to first call the object storage, then the Zend object, then the property table, and finally the property referenced by <code>zval</code> .  At least four levels of indirect addressing, and in real projects there will be at least seven. <br><br><h1>  Objects in PHP 7 </h1><br>  All the above shortcomings tried to fix in the seventh version.  In particular, they abandoned double counting of links, reduced memory consumption and the amount of indirect addressing.  This is the new <code>zend_object</code> structure: <br><pre> <code class="php hljs">struct _zend_object { zend_refcounted gc; uint32_t handle; zend_class_entry *ce; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zend_object_handlers *handlers; HashTable *properties; zval properties_table[<span class="hljs-number"><span class="hljs-number">1</span></span>]; };</code> </pre><br>  This structure is almost all that remains of the object.  <code>zend_object_value</code> , replaced by a direct pointer to the object and storage of objects, although not completely ruled out, but less often. <br><br>  In addition to the traditional header <code>zend_refcounted</code> , inside the <code>zend_object</code> <code>handle</code> and <code>handlers</code> ‚Äúmoved‚Äù.  <code>properties_table</code> now also uses a structured hack, so <code>zend_object</code> and the property table are placed in one block.  And of course, <code>zval</code> itself is now directly included in the property table, not pointers to them. <br><br>  The <code>guards</code> table is now removed from the object structure and is stored in the first <code>properties_table</code> cell, if the object uses <code>__get</code> , etc.  If these ‚Äúmagic‚Äù methods are not used, then the <code>guards</code> table is not involved. <br><br>  The <code>dtor</code> , <code>free_storage</code> and <code>clone</code> handlers that were previously stored in the object storage moved to the <code>handlers</code> table: <br><pre> <code class="php hljs">struct _zend_object_handlers { <span class="hljs-comment"><span class="hljs-comment">/* offset of real object header (usually zero) */</span></span> int offset; <span class="hljs-comment"><span class="hljs-comment">/* general object functions */</span></span> zend_object_free_obj_t free_obj; zend_object_dtor_obj_t dtor_obj; zend_object_clone_obj_t clone_obj; <span class="hljs-comment"><span class="hljs-comment">/* individual object functions */</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... rest is about the same in PHP 5 };</span></span></code> </pre><br>  The offset element is not exactly a handler.  It is related to the way objects are represented: an internal object always embeds a standard <code>zend_object</code> , but at the same time it usually adds a certain number of elements ‚Äúfrom above‚Äù.  In PHP 5, they were added after the standard object: <br><pre> <code class="php hljs">struct custom_object { zend_object std; uint32_t something; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre><br>  That is, you can simply send <code>zend_object*</code> to your custom <code>struct custom_object*</code> .  This suggests the introduction of structure inheritance in the C language. However, the approach in PHP 7 has its own peculiarities: since <code>zend_object</code> uses a structured hack to store the property table, PHP stores properties in the <code>zend_object</code> itself, overwriting additional internal elements.  Therefore, in the seventh version, additional methods are stored <b>in front of the</b> standard object: <br><pre> <code class="php hljs">struct custom_object { uint32_t something; <span class="hljs-comment"><span class="hljs-comment">// ... zend_object std; };</span></span></code> </pre><br>  This leads to the fact that it is no longer possible to directly convert between <code>zend_object*</code> and <code>struct custom_object*</code> because of the <code>offset</code> between them using a simple conversion.  It is stored in the first item in the object handler table.  At compile time, <code>offset</code> can be defined using the macro <code>offsetof()</code> . <br><br>  You probably wonder why PHP 7 still has a <code>handle</code> .  Because now a direct pointer to <code>zend_object</code> , so there is no longer any need to use a <code>handle</code> to search for an object in the storage.  However, the <code>handle</code> is still needed, because there is still a repository of objects, albeit in a substantially truncated form.  Now it is a simple array of pointers to objects.  When an object is created, the pointer is placed in the repository in the index <code>handle</code> , and is removed from there when the object is released. <br><br>  What else do you need a storage facility for?  During the completion of a request, there comes a time when the execution of a custom code may be unsafe, because the worker has partially stopped working.  To avoid this situation, PHP runs all object destructors at an early stage of completion.  For this, you need a list of all active objects. <br><br>  Also, handle is useful for debugging because it gives each object a unique ID.  This allows you to immediately understand whether the two objects are the same.  The object handler is still stored in HHVM, although it is not a repository of objects. <br><br>  Unlike PHP 5, now only one reference counter is used (it is no longer in <code>zval</code> ).  The memory consumption has significantly decreased, now 40 bytes are enough for the base object, and 16 bytes for each declared property, including <code>zval</code> .  It has become much less indirect addressing, since many intermediate structures have been excluded or merged with other structures.  Therefore, when reading a property, now only one level of indirect addressing is used instead of four. <br><br><h1>  Indirect zval </h1><br>  Let's now consider the special types of <code>zval</code> used in special cases.  One of them is <code>IS_INDIRECT</code> .  The value of indirect <code>zval</code> is stored elsewhere.  Note that this type of <code>zval</code> differs from the <code>IS_REFERENCE</code> in that it directly points to another <code>zval</code> , unlike the <code>zend_reference</code> structure in which <code>zval</code> embedded. <br><br>  When can this <code>zval</code> type be useful?  Let's first consider the implementation of variables in PHP.  All variables that are known at the compilation stage are entered into the index, and their values ‚Äã‚Äãare written into the table of compiled variables (CV) in this index.  But PHP also allows us to dynamically reference variables using variable variables or, if you are in the global scope, using <code>$GLOBALS</code> .  With this access, PHP creates a symbol table for the function / script containing a map of the names of the variables and their values. <br><br>  The question arises: how can you simultaneously support two different types of access?  To call normal variables, we need access using the CV table, and for variable variables, using the symbol table.  In PHP 5, the CV table used <code>zval**</code> twice indirect pointers.  In a normal situation, these pointers lead to the second pointer table, <code>zval*</code> , and it, in turn, refers to the <code>zval</code> : <br><pre> <code class="php hljs">+------ CV_ptr_ptr[<span class="hljs-number"><span class="hljs-number">0</span></span>] | +---- CV_ptr_ptr[<span class="hljs-number"><span class="hljs-number">1</span></span>] | | +-- CV_ptr_ptr[<span class="hljs-number"><span class="hljs-number">2</span></span>] | | | | | +-&gt; CV_ptr[<span class="hljs-number"><span class="hljs-number">0</span></span>] --&gt; some zval | +---&gt; CV_ptr[<span class="hljs-number"><span class="hljs-number">1</span></span>] --&gt; some zval +-----&gt; CV_ptr[<span class="hljs-number"><span class="hljs-number">2</span></span>] --&gt; some zval</code> </pre><br>  Now, since we are using a symbol table, the second table with single <code>zval*</code> pointers is no longer used, and <code>zval**</code> pointers refer to hash table storages.  A small illustration with three variables $ a, $ b and $ c: <br><pre> <code class="php hljs">CV_ptr_ptr[<span class="hljs-number"><span class="hljs-number">0</span></span>] --&gt; SymbolTable[<span class="hljs-string"><span class="hljs-string">"a"</span></span>].pDataPtr --&gt; some zval CV_ptr_ptr[<span class="hljs-number"><span class="hljs-number">1</span></span>] --&gt; SymbolTable[<span class="hljs-string"><span class="hljs-string">"b"</span></span>].pDataPtr --&gt; some zval CV_ptr_ptr[<span class="hljs-number"><span class="hljs-number">2</span></span>] --&gt; SymbolTable[<span class="hljs-string"><span class="hljs-string">"c"</span></span>].pDataPtr --&gt; some zval</code> </pre><br>  In PHP 7, this approach is no longer possible, because the pointer to the repository will be invalidated when the size of the hash table is changed.  Now this approach is used: for the variables stored in the CV table, the hash table of characters contains an INDIRECT entry pointing to the CV entry.  The CV table is not redistributed as long as the symbol table exists.  Therefore, there is no longer a problem with invalid pointers. <br><br>  If you take a function with CV $ a, $ b and $ c, as well as a dynamically created variable $ d, then the symbol table might look like this: <br><pre> <code class="php hljs">SymbolTable[<span class="hljs-string"><span class="hljs-string">"a"</span></span>].value = INDIRECT --&gt; CV[<span class="hljs-number"><span class="hljs-number">0</span></span>] = LONG <span class="hljs-number"><span class="hljs-number">42</span></span> SymbolTable[<span class="hljs-string"><span class="hljs-string">"b"</span></span>].value = INDIRECT --&gt; CV[<span class="hljs-number"><span class="hljs-number">1</span></span>] = DOUBLE <span class="hljs-number"><span class="hljs-number">42.0</span></span> SymbolTable[<span class="hljs-string"><span class="hljs-string">"c"</span></span>].value = INDIRECT --&gt; CV[<span class="hljs-number"><span class="hljs-number">2</span></span>] = STRING --&gt; zend_string(<span class="hljs-string"><span class="hljs-string">"42"</span></span>) SymbolTable[<span class="hljs-string"><span class="hljs-string">"d"</span></span>].value = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span> --&gt; zend_array([<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>])</code> </pre><br>  Indirect <code>zval</code> can also point to <code>zval IS_UNDEF</code> .  In this case, it is processed as if the hash table does not contain associated keys.  And if <code>unset($a)</code> writes the <code>UNDEF</code> type to <code>CV[0]</code> , it will be processed as if the character table does not have the key ‚Äúa‚Äù. <br><br><h1>  Constants and AST </h1><br>  Finally, <code>IS_CONSTANT</code> <code>IS_CONSTANT_AST</code> two special types of <code>zval</code> , available in PHP 5 and 7 - <code>IS_CONSTANT</code> and <code>IS_CONSTANT_AST</code> .  To understand their purpose, consider an example: <br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a = ANSWER, $b = ANSWER * ANSWER)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $a + $b; } define(<span class="hljs-string"><span class="hljs-string">'ANSWER'</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); var_dump(test()); <span class="hljs-comment"><span class="hljs-comment">// int(42 + 42 * 42)</span></span></code> </pre><br>  By default, the parameter ANSWER is used for the <code>test()</code> function parameter values.  But it is not yet defined at the time of the function declaration.  The value of the constant will be known only after calling <code>define()</code> .  Therefore, the default values ‚Äã‚Äãof parameters and properties, as well as constants and all elements capable of accepting a ‚Äústatic expression‚Äù, can postpone the evaluation of the expression until the first use. <br><br>  If the value is a constant (or a class constant), then an <code>zval</code> type <code>IS_CONSTANT</code> with the name of a constant is used.  If the value is an expression, then <code>zval</code> type <code>IS_CONSTANT_AST</code> , referring to an abstract syntax tree (AST). <br><br>  * * * <br><br>  At this point, let me complete such a comprehensive overview of the representation of values ‚Äã‚Äãin PHP 7. </div><p>Source: <a href="https://habr.com/ru/post/261131/">https://habr.com/ru/post/261131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261115/index.html">Porting OpenWRT to a new device on the example of ASUS DSL N12U</a></li>
<li><a href="../261117/index.html">The electronic teacher for blind on Arduino</a></li>
<li><a href="../261119/index.html">Western bestsellers in our book market. Career IT Project Manager</a></li>
<li><a href="../261123/index.html">Eat filed, sit down, please connect</a></li>
<li><a href="../261127/index.html">Delete phantom server entries from SCVMM</a></li>
<li><a href="../261133/index.html">Vulnerability iOS and OS X, the success of Bethesda, a reward from Google - and other news of the week for a mobile developer</a></li>
<li><a href="../261137/index.html">Fast filter catalog for online stores based on Redis bitmaps</a></li>
<li><a href="../261139/index.html">How we developed our DNS manager</a></li>
<li><a href="../261141/index.html">JavaScript Modules</a></li>
<li><a href="../261143/index.html">Virtual PBX 3CX Phone System v14 in 3CX company cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>