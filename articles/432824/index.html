<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accelerating the creation of ConcurrentReferenceHashMap</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings, in this post I will spread out how to speed up the creation of org.springframework.util.ConcurrentReferenceHashMap with insignificant effor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accelerating the creation of ConcurrentReferenceHashMap</h1><div class="post__text post__text-html js-mediator-article"><p> Greetings, in this post I will spread out how to speed up the creation of <code>org.springframework.util.ConcurrentReferenceHashMap</code> with insignificant efforts. </p><br><p>  Interested in pumping performance?  Welcome! </p><a name="habracut"></a><br><h4 id="razvedka">  Intelligence service </h4><br><p>  We begin, of course, with measurements and try to understand what we are going to improve.  To do this, take JMH 1.21, JDK 8 and JDK 11, as well as <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a> . </p><br><p>  To find out how much it takes to create an empty dictionary, let's put a simple experience: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">original</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentReferenceHashMap(); }</code> </pre> <br><p>  Profile looks like this: </p><br><pre> <code class="plaintext hljs">55.21% 2429743 osuConcurrentReferenceHashMap.calculateShift 20.30% 891404 osuConcurrentReferenceHashMap$Segment.&lt;init&gt; 8.79% 387198 osuConcurrentReferenceHashMap.&lt;init&gt; 3.35% 147651 java.util.concurrent.locks.ReentrantLock.&lt;init&gt; 2.34% 102804 java.lang.ref.ReferenceQueue.&lt;init&gt; 1.61% 70748 osuConcurrentReferenceHashMap.createReferenceManager 1.53% 67265 osuConcurrentReferenceHashMap$Segment.createReferenceArray 0.78% 34493 java.lang.ref.ReferenceQueue$Lock.&lt;init&gt; 0.76% 33546 osuConcurrentReferenceHashMap$ReferenceManager.&lt;init&gt; 0.36% 15948 osuAssert.isTrue</code> </pre> <br><p>  The direction is clear, you can proceed. </p><br><h4 id="matematika">  Maths </h4><br><p>  So, we spend the lion's share of the time in the method <code>calculateShift</code> .  Here he is: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateShift</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minimumValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maximumValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shift = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (value &lt; minimumValue &amp;&amp; value &lt; maximumValue) { value &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; shift++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shift; }</code> </pre> <br><p>  It‚Äôs hard to come up with something new, so let's switch to using it: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConcurrentReferenceHashMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*...*/</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> concurrencyLevel, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*...*/</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL); //... } // ConcurrentReferenceHashMap$Segment public Segment(int initialCapacity) { this.referenceManager = createReferenceManager(); this.initialSize = 1 &lt;&lt; calculateShift(initialCapacity, MAXIMUM_SEGMENT_SIZE); this.references = createReferenceArray(this.initialSize); this.resizeThreshold = (int) (this.references.length * getLoadFactor()); }</span></span></code> </pre> <br><p>  Note the use of the <code>Segment</code> constructor: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roundedUpSegmentCapacity = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) ((initialCapacity + size - <span class="hljs-number"><span class="hljs-number">1L</span></span>) / size); <span class="hljs-comment"><span class="hljs-comment">//... for (int i = 0; i &lt; this.segments.length; i++) { this.segments[i] = new Segment(roundedUpSegmentCapacity); }</span></span></code> </pre> <br><p>  The value <code>roundedUpSegmentCapacity</code> constantly in the loop, therefore the expression <code>1 &lt;&lt; calculateShift(initialCapacity, MAXIMUM_SEGMENT_SIZE)</code> , executed in the <code>Segment</code> constructor, will also always be constant.  Thus, we can move the specified expression out of the constructor and the cycle. </p><br><p>  The same statement is true for the expression <code>(int) (this.references.length * getLoadFactor())</code> , because the <code>references</code> array is created using the variable <code>initialCapacity</code> and its size is constant when creating each segment.  Bring the expression out of the constructor and the loop. </p><br><h4 id="massivy">  Arrays </h4><br><p>  Consider the <code>createReferenceArray</code> method: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Reference&lt;K, V&gt;[] createReferenceArray(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Reference&lt;K, V&gt;[]) Array.newInstance(Reference.class, size); }</code> </pre> <br><p>  Using <code>Array::newInstance</code> obviously redundant, nothing prevents us from creating an array using a constructor: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Reference&lt;K, V&gt;[] createReferenceArray(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Reference[size]; }</code> </pre> <br><p>  The constructor's performance is not inferior to the <code>Array::newInstance</code> call at the C2 level, but significantly exceeds it for small arrays in C1 modes ( <code>-XX:TieredStopAtLevel=1</code> property <code>-XX:TieredStopAtLevel=1</code> ) and interpreter ( <code>-Xint</code> property): </p><br><pre> <code class="plaintext hljs">//C2 length Mode Cnt Score Error Units constructor 10 avgt 50 5,6 ¬± 0,0 ns/op constructor 100 avgt 50 29,7 ¬± 0,1 ns/op constructor 1000 avgt 50 242,7 ¬± 1,3 ns/op newInstance 10 avgt 50 5,5 ¬± 0,0 ns/op newInstance 100 avgt 50 29,7 ¬± 0,1 ns/op newInstance 1000 avgt 50 249,3 ¬± 9,6 ns/op //C1 length Mode Cnt Score Error Units constructor 10 avgt 50 6,8 ¬± 0,1 ns/op constructor 100 avgt 50 36,3 ¬± 0,6 ns/op constructor 1000 avgt 50 358,6 ¬± 6,4 ns/op newInstance 10 avgt 50 91,0 ¬± 2,4 ns/op newInstance 100 avgt 50 127,2 ¬± 1,8 ns/op newInstance 1000 avgt 50 322,8 ¬± 7,2 ns/op //-Xint length Mode Cnt Score Error Units constructor 10 avgt 50 126,3 ¬± 5,9 ns/op constructor 100 avgt 50 154,7 ¬± 2,6 ns/op constructor 1000 avgt 50 364,2 ¬± 6,2 ns/op newInstance 10 avgt 50 251,2 ¬± 11,3 ns/op newInstance 100 avgt 50 287,5 ¬± 11,4 ns/op newInstance 1000 avgt 50 486,5 ¬± 8,5 ns/op</code> </pre> <br><p>  The replacement will not be reflected on our benchmark, but it will speed up the code when the application is started, when C2 has not yet worked.  More about this mode will be discussed at the end of the article. </p><br><h4 id="klyuchevye-melochi">  Key trivia </h4><br><p>  Refer again to the <code>ConcurrentReferenceHashMap</code> constructor. </p><br><pre> <code class="java hljs">ConcurrentReferenceHashMap(<span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>) { Assert.isTrue(initialCapacity &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Initial capacity must not be negative"</span></span>); Assert.isTrue(loadFactor &gt; <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-string"><span class="hljs-string">"Load factor must be positive"</span></span>); Assert.isTrue(concurrencyLevel &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Concurrency level must be positive"</span></span>); Assert.notNull(referenceType, <span class="hljs-string"><span class="hljs-string">"Reference type must not be null"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadFactor = loadFactor; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shift; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.referenceType = referenceType; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roundedUpSegmentCapacity = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) ((initialCapacity + size - <span class="hljs-number"><span class="hljs-number">1L</span></span>) / size); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.segments = (Segment[]) Array.newInstance(Segment.class, size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.segments.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.segments[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Segment(roundedUpSegmentCapacity); } }</code> </pre> <br><p>  From curious for us: replacing <code>Array.newInstance</code> with a constructor leads to a compilation error, we pass by.  But the cycle is very curious, more precisely, referring to the <code>segments</code> field.  To make sure how destructive (sometimes) for performance such an appeal can be, I recommend the article by Nitzan Vakarta <a href="http://psy-lob-saw.blogspot.com/2014/08/the-volatile-read-suprise.html">The volatile read suprise</a> . </p><br><p>  The case described in the article, it seems to me, corresponds with the code in question.  Focus on the segments: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.segments = (Segment[]) Array.newInstance(Segment.class, size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.segments.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.segments[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Segment(roundedUpSegmentCapacity); }</code> </pre> <br><p>  Immediately after creating an array, it is recorded in the <code>ConcurrentReferenceHashMap.segments</code> field, and it is with this field that the loop interacts.  Inside the Segment constructor, an entry occurs in the volatile <code>references</code> field: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Reference&lt;K, V&gt;[] references; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Segment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> initialCapacity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... this.references = createReferenceArray(this.initialSize); //... }</span></span></code> </pre> <br><p>  This means that it is impossible to improve the access to the <code>segments</code> field, in other words, its contents are read at each turn of the cycle.  How to check the truth of this statement?  The simplest way is to copy the code into a separate package and remove <code>volatile</code> from the declaration of the <code>Segment.references</code> field: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Segment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReentrantLock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  private volatile Reference&lt;K, V&gt;[] references; //  private Reference&lt;K, V&gt;[] references; }</span></span></code> </pre> <br><p>  Check if something has changed: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">original</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> tsypanov.map.original.ConcurrentReferenceHashMap(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nonVolatileSegmentReferences</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> tsypanov.map.nonvolatile.ConcurrentReferenceHashMap(); }</code> </pre> <br><p>  We detect significant performance gains (JDK 8): </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units original avgt 100 732,1 ¬± 15,8 ns/op nonVolatileSegmentReferences avgt 100 610,6 ¬± 15,4 ns/op</code> </pre> <br><p>  On JDK 11, the elapsed time has decreased, but the relative gap has not changed much: </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units original avgt 100 473,8 ¬± 11,2 ns/op nonVolatileSegmentReferences avgt 100 401,9 ¬± 15,5 ns/op</code> </pre><br><p>  Of course, <strong>you need to return</strong> <code>volatile</code> <strong>to its place</strong> and look for another way.  A bottleneck was found - this is an appeal to the field.  And if so, then you can create the <code>segments</code> variable, fill the array, and only then write it into the field: </p><br><pre> <code class="java hljs">Segment[] segments = (Segment[]) Array.newInstance(Segment.class, size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; segments.length; i++) { segments[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Segment(roundedUpSegmentCapacity); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.segments = segments;</code> </pre> <br><p>  As a result, with the help of even such simple improvements, we managed to achieve quite good growth: </p><br><p>  JDK 8 </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units originalConcurrentReferenceHashMap avgt 100 712,1 ¬± 7,2 ns/op patchedConcurrentReferenceHashMap avgt 100 496,5 ¬± 4,6 ns/op</code> </pre> <br><p>  JDK 11 </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units originalConcurrentReferenceHashMap avgt 100 536,0 ¬± 8,4 ns/op patchedConcurrentReferenceHashMap avgt 100 486,4 ¬± 9,3 ns/op</code> </pre> <br><h4 id="chto-dayot-zamena-arraysnewinstance-na-new-t">  What gives the replacement of 'Arrays :: newInstance' to 'new T []' </h4><br><p>  When you start Spring Booth applications from Ideas, developers often set the flag 'Enable launch optimizations', which adds <code>-XX:TieredStopAtLevel=1 -noverify</code> to the VM arguments, which accelerates the launch by turning off profiling and C2.  Let's make measurement with the specified arguments: </p><br><pre> <code class="plaintext hljs">// JDK 8 -XX:TieredStopAtLevel=1 -noverify Benchmark Mode Cnt Score Error Units originalConcurrentReferenceHashMap avgt 100 1920,9 ¬± 24,2 ns/op patchedConcurrentReferenceHashMap avgt 100 592,0 ¬± 25,4 ns/op // JDK 11 -XX:TieredStopAtLevel=1 -noverify Benchmark Mode Cnt Score Error Units originalConcurrentReferenceHashMap avgt 100 1838,9 ¬± 8,0 ns/op patchedConcurrentReferenceHashMap avgt 100 549,7 ¬± 6,7 ns/op</code> </pre> <br><p>  More than 3-fold increase! </p><br><h4 id="dlya-chego-eto-nuzhno">  What is it for? </h4><br><p>  In particular, this is needed to speed up queries that return <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/">projections</a> to Spring Data JPA. </p><br><p><img src="https://habrastorage.org/webt/ep/aw/od/epawodffdb76xr-b3oxa0a-gs14.png"></p><br><p>  The JMC profile shows that creating a <code>ConcurrentReferenceHashMap</code> takes almost a fifth of the time it takes to execute a query. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleEntityRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;HasIdAndName&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllByName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span></span>; }</code> </pre> <br><p>  where <code>HasIdAndName</code> is a view projection </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasIdAndName</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Also, <code>ConcurrentReferenceHashMap</code> several dozen times in the Spring code, so there will definitely not be superfluous. </p><br><h4 id="vyvody">  findings </h4><br><ul><li>  improve performance is not as difficult as it seems at first glance </li><li>  volatile access in the vicinity of the cycle - one of the possible bottlenecks </li><li>  look for invariants and take them out of cycles </li></ul><br><h4 id="chto-pochitat">  What to read </h4><br><p>  <a href="http://psy-lob-saw.blogspot.com/2014/08/the-volatile-read-suprise.html">Article by Nitzan Waqarta</a> </p><br><p>  <a href="https://github.com/stsypanov/concurrent-ref-hash-map-example">Code of examples</a> </p><br><p>  Changes: <br>  <a href="https://github.com/spring-projects/spring-framework/pull/1873">https://github.com/spring-projects/spring-framework/pull/1873</a> <br>  <a href="https://github.com/spring-projects/spring-framework/pull/2051">https://github.com/spring-projects/spring-framework/pull/2051</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/432824/">https://habr.com/ru/post/432824/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432814/index.html">Cake and TeamCity integration</a></li>
<li><a href="../432816/index.html">AXIS M3046-V vs IDIS DC-D3212X: Compare CCTV Cameras</a></li>
<li><a href="../432818/index.html">Homemade plotter: tips for beginners, working with grbl-firmware</a></li>
<li><a href="../432820/index.html">Dynamic testing of Android applications</a></li>
<li><a href="../432822/index.html">I spoil the development of my life with my code review and I don‚Äôt want to</a></li>
<li><a href="../432826/index.html">Modern Android development on Kotlin. Part 2</a></li>
<li><a href="../432828/index.html">Testing and debugging MapReduce</a></li>
<li><a href="../432830/index.html">Automated imposition of fines for abandoned garbage</a></li>
<li><a href="../432832/index.html">How to "glue" Intel-based server and overcome the scale-up ceiling in 8 processors</a></li>
<li><a href="../432834/index.html">Internal and external linking in C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>