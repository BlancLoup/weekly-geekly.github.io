<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blending pointlight shadows in Unity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I still have not seen analogs of similar shadows for a point source of light (Pointlight with a blur effect at a distance, imitating arealight) in com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blending pointlight shadows in Unity</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/082/9d7/ea9/0829d7ea99999e2d278bb522d0c47858.png" alt="image"><br><br>  I still have not seen analogs of similar shadows for a point source of light (Pointlight with a blur effect at a distance, imitating arealight) in computer games.  Everywhere - either fully baked shadows, or ‚Äúlight bulbs‚Äù without any shadows at all, the maximum is ordinary PCF filtering.  Although PCSS-shadows have been used for directional sunlight for a long time (GTA5, for example).  In Unreal, there is an interesting algorithm similar to raytracing, which draws beautiful arealight-shadows, but only for static geometry (additional volumes are required).  In Unity, everything is very bad - only sunlight is gently filtered, and ‚Äúspotlights‚Äù and ‚Äúlight bulbs‚Äù are in the span. <a name="habracut"></a><br><br>  If at some ‚Äúspotlight bilinear filtering‚Äù hangs on Unity, then on point ‚Äúlight bulbs‚Äù there is such a horror: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/a58/0bc/0d3/a580bc0d3995a9acb5795655949a7370.png"><br><br>  Is it really that adding ordinary PCF filtering is such a performance hit?  Even if the blow, then why not make the option of including this filtering optional? <br><br>  As it turned out, there is no impact on performance.  In Unity 5, the technology deffered lighting (deferred lighting), and the more in the frame of light sources with dynamic shadow, the worse the performance.  And what kind of filtering of these shadows is not so important.  The same number of passes is performed, the same number of pixels are processed, this moment just requires scene optimization.  And the number of samples from the cubic texture of the depth of the ‚Äúlight bulb‚Äù may affect the performance, but very little (in the area of ‚Äã‚Äãthe FPS pair). <br><br>  It should also be said that blurring the resulting shadow with the image effect will not work.  There is no interlayer between sampling from the texture of depth and the imposition of light, such is the system in Unity.  A pity, it would be possible to win something. <br><br>  <b>So, we change the algorithm</b> <br><br>  Creating special materials for the sake of soft shadows is painstaking, and making changes to existing shaders with a script (as was done in ShadowSoftener) is also somehow not very convenient.  It is much faster and more practical to apply shadows at once to all shaders in the project (built-in, handwritten, downloaded) by changing just <u>one</u> file ‚ÄúUnityShadowLibrary.cginc‚Äù, which is located in the editor's directory: "... \ Unity5 \ Editor \ Data \ CGIncludes". <br><br>  We find this piece, which is responsible for the shadow of a point source of light: <br><br><pre><code class="hljs mel">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined (SHADOWS_SOFT) <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">128.0</span></span>; float4 shadowVals; shadowVals.x = SampleCubeDistance (vec+float3( z, z, z)); shadowVals.y = SampleCubeDistance (vec+float3(-z,-z, z)); shadowVals.z = SampleCubeDistance (vec+float3(-z, z,-z)); shadowVals.w = SampleCubeDistance (vec+float3( z,-z,-z)); half4 shadows = (shadowVals &lt; mydist.xxxx) ? _LightShadowData.rrrr : <span class="hljs-number"><span class="hljs-number">1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>(shadows,<span class="hljs-number"><span class="hljs-number">0.25</span></span>); #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span></code> </pre> <br><br>  In place of it, you can put any algorithm you like, but first we analyze the input parameters: <br><br>  <b>vec</b> is a four-dimensional vector.  x, y and z is the direction from the ‚Äúlight bulb‚Äù to the pixel.  By sampling this value using SampleCubeDistance, we get the distance of the shadowed object.  If the distance is greater than the length of vec, the shadow per pixel does not fall.  <i>(mydist is the same distance, but this is not an input parameter, it is calculated higher in the same file)</i> In each sample, the coordinate is shifted by a fixed amount, creating the effect of a non-uniform border.  Do not laugh.  Professional programmers who develop Unity call it soft shadow. <br><br>  <b>_LightShadowData.r</b> - this value of the slider adjusts the brightness of the shadow.  You can use it, for example, to change the degree of blur of the shadow or to change some other parameter to debug the shader directly in the editor.  Unfortunately, I have not figured out what other _LightShadowData components are affecting.  Apparently, for a point source of light there are no more parameters. <br><br>  We return the brightness from the function (0 to 1.0), i.e.  a multiplier that acts as atten (attenuation) in all shaders, so the modified shadow will also work in all shaders that support shading. <br><br>  <i><u>To see the changes</u> , find the folder of your project, in it - the folder ¬´Library¬ª.</i>  <i>Remove the ‚ÄúShaderCache‚Äù directory from this folder and restart Unity.</i>  <i>I also restarted Unity after each shader editing, it was unnerving and complicated debugging.</i> <br><br>  That's all. <br><br>  I tried this option here, smearing the edges with an unsightly dithering: <br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined (SHADOWS_SOFT) //  ,    <span class="hljs-type"><span class="hljs-type">float</span></span> downscale = <span class="hljs-number"><span class="hljs-number">32.0</span></span>f; //   const float3 rndseed = float3(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>,<span class="hljs-number"><span class="hljs-number">45.5432</span></span>); float3 randomvec = float3( dot(vec,rndseed) , dot(vec.yzx,rndseed) , dot(vec.zxy,rndseed) ); randomvec = frac(sin(randomvec) * <span class="hljs-number"><span class="hljs-number">43758.5453</span></span>); //      float3 xvec = normalize(<span class="hljs-keyword"><span class="hljs-keyword">cross</span></span>(vec,randomvec)); float3 yvec = normalize(<span class="hljs-keyword"><span class="hljs-keyword">cross</span></span>(vec,xvec)); float3 vec1 = xvec / downscale; float3 vec2 = yvec / downscale; <span class="hljs-type"><span class="hljs-type">float4</span></span> shadowVals; //    shadowVals.x = SampleCubeDistance (vec+vec1); shadowVals.y = SampleCubeDistance (vec+vec2); shadowVals.z = SampleCubeDistance (vec-vec1); shadowVals.w = SampleCubeDistance (vec-vec2); //  half4 shadows = (shadowVals &lt; mydist.xxxx) ? _LightShadowData.rrrr : <span class="hljs-number"><span class="hljs-number">1.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot(shadows,<span class="hljs-number"><span class="hljs-number">0.25</span></span>); #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span></code> </pre><br><br>  There are as many samples as in the eerie canonical implementation, but at least the pixels do not make my eyes callous: <br><br><img src="http://i77.fastpic.ru/big/2016/0810/17/1d22b042827e1a718dfa2118b8c6d617.png"><br><br>  Without hesitation (but for a long time debugging), I made the following PCF4x4 implementation with ‚Äúmanual‚Äù bilinear filtering (of course, DirectX11 commands can be inserted into Unity shaders, among which there is bilinear filtering of the cubic shadows, but I went selections for ‚Äúmanual‚Äù smoothing, it turned out not 16 samples, but 25). <br><br><img src="http://i73.fastpic.ru/big/2016/0123/d6/63339ad81152cf21183e6a5fb94ca2d6.jpeg" alt="image"><br><br>  Or even like this: <br><br><img src="http://i77.fastpic.ru/big/2016/0810/e6/645414c255880db08f692bcb0803b8e6.png"><br><br>  This is not an honest PCSS, but a faster and simpler implementation.  The maximum blur is the same PCF4x4.  A clear shadow near the shader is achieved by increasing the sharpness.  By the way, the shapen effect is also a lot of where it applies.  Here we have a symbiosis, with which you can achieve a beautiful effect. <br><br>  The above-mentioned slider adjusts the transition angle of a soft shadow to a sharp one.  This parameter can be selected in different ways for different "light bulbs", based on the size of the premises in which they are located. <br><br>  I put the code of the last implementation under cat.  It is a bit cumbersome and untidy, because I did not use a two-dimensional cycle of samples, but I wrote them down manually to reduce the number of commands and the number of variables used, and at the same time apply operations with vectors where you can calculate several variables at once.  Plus, I basically did not use conditional transitions, replacing them with mathematics.  Therefore, look at your own risk. <br><br><div class="spoiler">  <b class="spoiler_title">Necronomicon</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> half UnitySampleShadowmap (float3 vec) { <span class="hljs-type"><span class="hljs-type">float</span></span> mydist = length(vec) * _LightPositionRange.w; mydist *= <span class="hljs-number"><span class="hljs-number">0.97</span></span>; // bias const <span class="hljs-type"><span class="hljs-type">float</span></span> downscale = <span class="hljs-number"><span class="hljs-number">128.0</span></span>f; const <span class="hljs-type"><span class="hljs-type">float</span></span> sat_mult = <span class="hljs-number"><span class="hljs-number">312.0</span></span>f; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined (SHADOWS_SOFT) #define shadow_close_scalefactor (_LightShadowData.r + <span class="hljs-number"><span class="hljs-number">0.001</span></span>f) //        #define xvec main_axis.zxy #define yvec main_axis.yzx #define VIRTUAL_COORD(x,y) (ceilvec + xvec*x + yvec*y) //   ,       // (     ) half3 main_axis = abs(vec)*<span class="hljs-number"><span class="hljs-number">1666.666</span></span>f; main_axis = normalize(clamp(main_axis.xyz - main_axis.yzx,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f)*clamp(main_axis.xyz - main_axis.zxy,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f)); //     vec /= abs(dot(vec,main_axis)); //    ,       fixed3 ceilvec = ceil(vec*downscale) / downscale; //     -     <span class="hljs-number"><span class="hljs-number">4</span></span>-  fixed4 lerp_delta; vec = (ceilvec - vec) * downscale; lerp_delta.x = dot(vec * xvec,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); lerp_delta.y = dot(vec * yvec,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); lerp_delta.z = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f - lerp_delta.x; lerp_delta.w = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f - lerp_delta.y; //    main_axis /= downscale; ceilvec -= (xvec + yvec)*<span class="hljs-number"><span class="hljs-number">0.5</span></span>f; //     <span class="hljs-type"><span class="hljs-type">float4</span></span> shadowVals, distance_sums, distancesides; fixed4 shadowsides, shadow_sums, distancesides_nums, distance_nums; #define DISTANCE_COMPARE_X4(sum,distance_sum,distance_num) shadowVals = mydist.xxxx - shadowVals; sum = dot(clamp(shadowVals *sat_mult,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f),<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); distance_sum = dot(clamp(shadowVals, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">100.0</span></span>f),<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); distance_num = dot(clamp(shadowVals *sat_mult,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f),<span class="hljs-number"><span class="hljs-number">1.0</span></span>f) #define DISTANCE_COMPARE_X3(sum,distance_sum,distance_num) shadowVals = mydist.xxxx - shadowVals; sum = dot(clamp(shadowVals.xyz*sat_mult,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f),<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); distance_sum = dot(clamp(shadowVals.xyz,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">100.0</span></span>f),<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); distance_num = dot(clamp(shadowVals.xyz*sat_mult,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f),<span class="hljs-number"><span class="hljs-number">1.0</span></span>f) #define DISTANCE_COMPARE_X1(sum,distance_sum,distance_num) shadowVals.x = mydist - shadowVals.x; sum = clamp(shadowVals.x *sat_mult,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); distance_sum = clamp(shadowVals.x, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">100.0</span></span>f); distance_num = clamp(shadowVals.x *sat_mult,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f) //      -     //  <span class="hljs-number"><span class="hljs-number">4</span></span>  shadowVals.x = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">-1.0</span></span>f,<span class="hljs-number"><span class="hljs-number">-1.0</span></span>f)); shadowVals.y = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">-1.0</span></span>f)); shadowVals.z = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">1.0</span></span>f,<span class="hljs-number"><span class="hljs-number">-1.0</span></span>f)); shadowVals.w = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">1.0</span></span>f,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f)); DISTANCE_COMPARE_X4(shadowsides.x,distancesides.x,distancesides_nums.x); //  <span class="hljs-number"><span class="hljs-number">4</span></span>  shadowVals.x = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">-1.0</span></span>f,<span class="hljs-number"><span class="hljs-number">-0.0</span></span>f)); shadowVals.y = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">-1.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f)); shadowVals.z = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f)); shadowVals.w = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">1.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f)); DISTANCE_COMPARE_X4(shadowsides.y,distancesides.y,distancesides_nums.y); //   shadowVals.x = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f)); DISTANCE_COMPARE_X1(shadowsides.z,distancesides.z,distancesides_nums.z); //    shadow_sums = dot(shadowsides.xyz,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f).xxxx; distance_sums = dot(distancesides.xyz,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f).xxxx; distance_nums = dot(distancesides_nums.xyz,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f).xxxx + fixed4(<span class="hljs-number"><span class="hljs-number">0.01</span></span>f,<span class="hljs-number"><span class="hljs-number">0.01</span></span>f,<span class="hljs-number"><span class="hljs-number">0.01</span></span>f,<span class="hljs-number"><span class="hljs-number">0.01</span></span>f); //      //  shadowVals.x = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">-2.0</span></span>f,<span class="hljs-number"><span class="hljs-number">-1.0</span></span>f)); shadowVals.y = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">-2.0</span></span>f,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f)); shadowVals.z = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">-2.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f)); DISTANCE_COMPARE_X3(shadowsides.x,distancesides.x,distancesides_nums.x); //  shadowVals.x = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">-1.0</span></span>f,<span class="hljs-number"><span class="hljs-number">-2.0</span></span>f)); shadowVals.y = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">-2.0</span></span>f)); shadowVals.z = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">1.0</span></span>f,<span class="hljs-number"><span class="hljs-number">-2.0</span></span>f)); DISTANCE_COMPARE_X3(shadowsides.y,distancesides.y,distancesides_nums.y); //  shadowVals.x = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">2.0</span></span>f,<span class="hljs-number"><span class="hljs-number">-1.0</span></span>f)); shadowVals.y = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">2.0</span></span>f,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f)); shadowVals.z = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">2.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f)); DISTANCE_COMPARE_X3(shadowsides.z,distancesides.z,distancesides_nums.z); //  shadowVals.x = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">-1.0</span></span>f,<span class="hljs-number"><span class="hljs-number">2.0</span></span>f)); shadowVals.y = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">2.0</span></span>f)); shadowVals.z = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">1.0</span></span>f,<span class="hljs-number"><span class="hljs-number">2.0</span></span>f)); DISTANCE_COMPARE_X3(shadowsides.w,distancesides.w,distancesides_nums.w); //      shadow_sums += (shadowsides.xzxz + shadowsides.yyww); distance_sums += (distancesides.xzxz + distancesides.yyww); distance_nums += distancesides_nums.xzxz + distancesides_nums.yyww; //   shadowVals.x = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">-2.0</span></span>f,<span class="hljs-number"><span class="hljs-number">-2.0</span></span>f)); shadowVals.y = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">2.0</span></span>f,<span class="hljs-number"><span class="hljs-number">-2.0</span></span>f)); shadowVals.z = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">-2.0</span></span>f,<span class="hljs-number"><span class="hljs-number">2.0</span></span>f)); shadowVals.w = SampleCubeDistance (VIRTUAL_COORD(<span class="hljs-number"><span class="hljs-number">2.0</span></span>f,<span class="hljs-number"><span class="hljs-number">2.0</span></span>f)); //  ,        shadowVals = mydist.xxxx - shadowVals; shadow_sums += clamp(shadowVals*sat_mult,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); distance_sums += clamp(shadowVals,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); distance_nums += clamp(shadowVals*sat_mult,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); //     shadow_sums.x = dot(shadow_sums * lerp_delta.xzxz * lerp_delta.yyww, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f) / <span class="hljs-number"><span class="hljs-number">16.0</span></span>f; distance_sums.x = dot(clamp((distance_sums/distance_nums),<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f) * lerp_delta.xzxz * lerp_delta.yyww, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); //      fixed contrastfactor = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f - clamp(distance_sums.x/shadow_close_scalefactor,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); shadow_sums.x = clamp((shadow_sums.x - <span class="hljs-number"><span class="hljs-number">0.5</span></span>f) * (<span class="hljs-number"><span class="hljs-number">1.0</span></span>f + contrastfactor*<span class="hljs-number"><span class="hljs-number">4.0</span></span>f)+<span class="hljs-number"><span class="hljs-number">0.5</span></span>f,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span>f - shadow_sums.x; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //     <span class="hljs-number"><span class="hljs-number">4</span></span>     vec = normalize(vec) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; //    const float3 rndseed = float3(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>,<span class="hljs-number"><span class="hljs-number">45.5432</span></span>); float3 randomvec = float3( dot(vec,rndseed) , dot(vec.yzx,rndseed) , dot(vec.zxy,rndseed) ); randomvec = frac(sin(randomvec) * <span class="hljs-number"><span class="hljs-number">43758.5453</span></span>); float3 vec1 = normalize(<span class="hljs-keyword"><span class="hljs-keyword">cross</span></span>(vec,randomvec)) / downscale; float3 vec2 = normalize(<span class="hljs-keyword"><span class="hljs-keyword">cross</span></span>(vec,vec1)) / downscale; <span class="hljs-type"><span class="hljs-type">float4</span></span> shadowVals; shadowVals.x = SampleCubeDistance (vec+vec1); shadowVals.y = SampleCubeDistance (vec+vec2); shadowVals.z = SampleCubeDistance (vec-vec1); shadowVals.w = SampleCubeDistance (vec-vec2); shadowVals = mydist.xxxx - shadowVals; fixed4 shadows = clamp(shadowVals*sat_mult,<span class="hljs-number"><span class="hljs-number">0.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot(shadows,<span class="hljs-number"><span class="hljs-number">0.25</span></span>); #endif }</code> </pre><br></div></div><br><br>  If you are not exactly satisfied with this approach, implement more suitable algorithms within Unity.  I would only be glad of such activity, because I really am depressed by the stagnation in Unity in terms of realtime shadows, which has been dragging on for many years. <br><br>  PS: Most of all I would like to hear the opinions of those who work directly with Unity and know what is possible and what is not, although there will most likely be extensive reflections on algorithms that cannot be inserted into the engine because of its closed architecture.  But I also will join the lengthy reflections with joy and explain some points. </div><p>Source: <a href="https://habr.com/ru/post/307582/">https://habr.com/ru/post/307582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307572/index.html">33 ways to deal with uncertainty and anxiety like Madonna</a></li>
<li><a href="../307574/index.html">Random User-Agent - version two</a></li>
<li><a href="../307576/index.html">Voice "prints" now officially work (and how the implementation process at Priorbank looks like)</a></li>
<li><a href="../307578/index.html">From Slides Defined to Software Defined Networking. Part 2</a></li>
<li><a href="../307580/index.html">Science funding system</a></li>
<li><a href="../307588/index.html">How trading on the exchange actually works, and how it can be improved: A simple algorithm (part 3)</a></li>
<li><a href="../307592/index.html">From Slides Defined to Software Defined Networking. Part 3</a></li>
<li><a href="../307594/index.html">Investigate the issue of penalties 2.0</a></li>
<li><a href="../307596/index.html">ONLYOFFICE Hosting Edition: how we made a cloud office for hosting providers</a></li>
<li><a href="../307598/index.html">Top 100 Machine Learning and Data Analysis Articles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>