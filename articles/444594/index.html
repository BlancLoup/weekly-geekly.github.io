<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Big o</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note. Abbreviated translation, rather retelling in your own words. 
 UPD: as noted in the comments, the examples are not perfect. The author is not lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Big o</h1><div class="post__text post__text-html js-mediator-article">  <i><u>Note.</u></i>  <i>Abbreviated translation, rather retelling in your own words.</i> <i><br></i>  <i>UPD: as noted in the comments, the examples are not perfect.</i>  <i>The author is not looking for the best solution to the problem, his goal is to explain the complexity of the algorithms "on the fingers."</i> <br><br>  Big O notation is needed to describe the complexity of the algorithms.  For this, the concept of time is used.  The topic for many is frightening, programmers who avoid talking about ‚Äútime of order N‚Äù are common. <br><br>  If you are able to evaluate the code in terms of Big O, most likely you are considered a ‚Äúsmart guy.‚Äù  And most likely you will pass your next interview.  You will not be stopped by the question whether it is possible to reduce the complexity of any piece of code to n log n versus n ^ 2. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Data structures </h2><br>  The choice of data structure depends on the specific task: on the type of data and the algorithm of their processing.  Various data structures (in .NET or Java or Elixir) were created for certain types of algorithms. <br><br>  Often, choosing this or that structure, we simply copy the generally accepted solution.  In most cases this is enough.  But in fact, without understanding the complexity of the algorithms, we cannot make an informed choice.  The topic of data structures can only be taken after the complexity of the algorithms. <br><br>  Here we will use only arrays of numbers (just like at the interview).  JavaScript examples. <br><a name="habracut"></a><br><h2>  Let's start with the simplest: O (1) </h2><br>  Take an array of 5 numbers: <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  Suppose you need to get the first element.  Use for this index: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstNumber = nums[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br>  How complex is the algorithm?  We can say: ‚Äúnot at all difficult - just take the first element of the array‚Äù.  This is true, but it is more correct to describe the complexity in terms of the number of operations performed to achieve the result, depending on the input (input <i>operations</i> ). <br><br>  In other words: how much will the number of operations increase with an increase in the number of input parameters. <br><br>  In our example, the input parameters are 5, because there are 5 elements in the array.  To get the result, you need to perform one operation (take the element by index).  How many operations are required if the array elements will be 100?  Or 1000?  Or 100,000?  All the same, only one operation is needed. <br><br>  Ie: ‚Äúone operation for all possible input data‚Äù - O (1). <br><br>  O (1) can be read as ‚Äúcomplexity of order 1‚Äù (order 1), or ‚Äúthe algorithm is executed in constant / constant time‚Äù (constant time). <br><br>  You have already guessed that O (1) algorithms are the most efficient. <br><br><h2>  Iterations and "time of order n": O (n) </h2><br>  Now let's find the sum of the elements of the array: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> nums){ sum += num; }</code> </pre> <br>  Again we ask ourselves: how many input operations will we need?  Here you need to sort through all the elements, i.e.  operation on each item.  The larger the array, the more operations. <br><br>  Using Big O notation: O (n), or "complexity of order n (order n)".  Also, this type of algorithm is called "linear" or that the algorithm is "linearly scaled." <br><br><h3>  Analysis </h3><br>  Can we make summation more efficient?  In general, no.  And if we know that the array is guaranteed to start with 1, is it sorted and does not have spaces?  Then you can apply the formula S = n (n + 1) / 2 (where n is the last element of the array): <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sumContiguousArray = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ary</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//get the last item const lastItem = ary[ary.length - 1]; //Gauss's trick return lastItem * (listItem + 1) / 2; } const nums = [1,2,3,4,5]; const sumOfArray = sumContiguousArray(nums);</span></span></code> </pre> <br>  Such an algorithm is much more efficient than O (n), moreover, it is executed in ‚Äúconstant / constant time‚Äù, i.e.  this is O (1). <br><br>  In fact, the operations are not the only one: you need to get the length of the array, get the last element, perform multiplication and division.  Isn't that O (3) or something like that?  In Bio O notation, the actual number of steps is not important, it is important that the algorithm is executed in constant time. <br><br>  Algorithms with constant time are always O (1).  Also with linear algorithms, in fact, operations can be O (n + 5), in Big O notation it is O (n). <br><br><h2>  Not the best solutions: O (n ^ 2) </h2><br>  Let's write a function that checks the array for duplicates.  Nested loop solution: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasDuplicates = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//loop the list, our O(n) op for (let i = 0; i &lt; nums.length; i++) { const thisNum = nums[i]; //loop the list again, the O(n^2) op for (let j = 0; j &lt; nums.length; j++) { //make sure we're not checking same number if (j !== i) { const otherNum = nums[j]; //if there's an equal value, return if (otherNum === thisNum) return true; } } } //if we're here, no dups return false; } const nums = [1, 2, 3, 4, 5, 5]; hasDuplicates(nums);//true</span></span></code> </pre> <br>  We already know that array iteration is O (n).  We have a nested loop, for each element we iterate again - i.e.  O (n ^ 2) or "complexity of order n square". <br><br>  Algorithms with nested loops for the same collection are always O (n ^ 2). <br><br><h2>  "The complexity of the order of log n": O (log n) </h2><br>  In the example above, a nested loop, by itself (if you do not take into account that it is nested) has complexity O (n), since  It is an enumeration of the array elements.  This cycle ends as soon as the necessary element is found, i.e.  in fact, all the elements will not necessarily be enumerated.  But in the Big O notation, the worst option is always considered - the desired element may be the most recent. <br><br>  Here, a nested loop is used to search for a given element in an array.  The search for an element in an array, under certain conditions, can be optimized ‚Äî done better than linear O (n). <br><br>  Let the array be sorted.  Then we will be able to use the binary search algorithm: divide the array into two halves, discard the unnecessary, divide the rest again into two parts, and so until we find the desired value.  This type of algorithm is called Divide and Conquer Divide and Conquer. <br><br><img src="https://habrastorage.org/webt/0p/b9/em/0pb9em6fqdkdj0dtknyxbt8kbvk.png" alt="binary search"><br><br>  This algorithm is based on logarithm. <br><br><h2>  A quick overview of logarithms </h2><br>  Consider an example of what will be x? <br><br>  x ^ 3 = 8 <br><br>  We need to take the cubic root of 8 - it will be 2. Now it is more difficult <br><br>  2 ^ x = 512 <br><br>  Using logarithm, the problem can be written as <br><br>  log2 (512) = x <br><br>  ‚ÄúThe logarithm of base 2 from 512 is x‚Äù.  Note the ‚Äúbase 2‚Äù, i.e.  we think in twos - how many times you need to multiply 2 to get 512. <br><br>  In the ‚Äúbinary search‚Äù algorithm, at each step we divide the array into two parts. <br><br>  <i><u>My addition.</u></i>  <i>Those.</i>  <i>at worst, we do as many operations as we can divide the array into two parts.</i>  <i>For example, how many times can we divide into two parts an array of 4 elements?</i>  <i>2 times.</i>  <i>And an array of 8 elements?</i>  <i>3 times.</i>  <i>Those.</i>  <i>number of divisions / operations = log2 (n) (where n is the number of array elements).</i> <i><br></i>  <i>It turns out that the dependence of the number of operations on the number of input elements is described as log2 (n)</i> <i><br></i> <br>  Thus, using the Big O notation, the ‚Äúbinary search‚Äù algorithm has O (log n) complexity. <br><br><h2>  Improve O (n ^ 2) to O (n log n) </h2><br>  Let's return to the task of checking the array for doubles.  We went through all the elements of the array and for each element we did another search.  Did O (n) inside O (n), i.e.  O (n * n) or O (n ^ 2). <br><br>  We can replace the nested loop with a binary search.  Those.  we still have to iterate over all elements of O (n), inside we do O (log n).  It turns out O (n * log n), or O (n log n). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> searchFor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items, num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//use binary search! //if found, return the number. Otherwise... //return null. We'll do this in a later chapter. } const hasDuplicates = function (nums) { for (let num of nums) { //let's go through the list again and have a look //at all the other numbers so we can compare if (searchFor(nums, num)) { return true; } } //only arrive here if there are no dups return false; }</span></span></code> </pre> <br><br><h2>  Thinking in Big O terms </h2><br><ul><li>  Receiving a collection item is O (1)  Whether it's getting by index in an array, or by key in a dictionary in Big O notation, it will be O (1) </li><li>  Search collection is O (n) </li><li>  Nested loops for the same collection are O (n ^ 2) </li><li>  Divide and Conquer always O (log n) </li><li>  Iterations that use Divide and Conquer are O (n log n) </li></ul></div><p>Source: <a href="https://habr.com/ru/post/444594/">https://habr.com/ru/post/444594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444578/index.html">Speakers Top 3D Expo 2019: Yousef Hesuani from 3dbio - 3D-printing of organs and tissues</a></li>
<li><a href="../444580/index.html">FBO Sheremetyevo infrastructure: how light aircraft are prepared for flight</a></li>
<li><a href="../444582/index.html">Palo Alto Networks NGFW Security Policy Optimizer</a></li>
<li><a href="../444584/index.html">Android will offer European users a browser and search engine to choose from</a></li>
<li><a href="../444590/index.html">Data leakage (which could have occurred, but did not occur) from the telemedicine company</a></li>
<li><a href="../444596/index.html">Iodide: Mozilla's interactive science editor.</a></li>
<li><a href="../444598/index.html">The CD is 40 years old, and is it dead (does it?)</a></li>
<li><a href="../444600/index.html">Review 14 headless cms 2019</a></li>
<li><a href="../444602/index.html">Encapsulation in C ++ and C</a></li>
<li><a href="../444606/index.html">Oculus announces Rift S, the new successor to Rift</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>