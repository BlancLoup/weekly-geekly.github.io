<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Numeric Classes of Types in Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Abstractions Rust differ from the usual in the PLO. In particular, instead of classes (classes of objects), classes of types are used, which are calle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Numeric Classes of Types in Rust</h1><div class="post__text post__text-html js-mediator-article">  Abstractions Rust differ from the usual in the PLO.  In particular, instead of classes (classes of objects), classes of types are used, which are called ‚Äútrait‚Äù (should not be confused with trait from Scala, where this term hides <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BC%25D0%25B5%25D1%2581%25D1%258C_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">impurities</a> - mixin). <br>  Type classes are not unique to Rust, they are supported in Haskell, Mercury, Go, and can be implemented in a <a href="http://habrahabr.ru/post/205482/">slightly perverted way</a> in Scala and C ++. <br><br>  I want to show how they are implemented in Rust using the example of <a href="http://habrahabr.ru/post/222789/">dual numbers</a> and to parse individual nontrivial (or poorly worked out) moments. <br><br>  Numeric type interfaces are rather cumbersome, and I will insert here only code snippets.  All code is available on <a href="">github</a> (Update: a working version is available on <a href="https://crates.io/crates/dual/">crates.io</a> ). <br>  Most of the interfaces implemented here have the status of experemental or unstable and most likely will change.  I will try to keep the code and text relevant. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Rust supports overloading operations, but, unlike C ++, operations have a synonym method with the usual letter name.  So <b>a + b</b> can be written <b>a.add (b)</b> , and to override the '+' operation, you just need to implement the add method. <br><br><a name="habracut"></a><br><h1>  What is a type class? </h1>  Class types are often compared with the interface.  Indeed, it determines what can be done with some data types, but these operations must be implemented separately.  Unlike the interface, the implementation of a type class for some type does not create a new type, but lives with the old one, although the old type may not know anything about the implemented interface.  In order for the code using this interface to work with this data type, neither the data type, nor the interface, nor the code need to be corrected - it is enough to implement an interface for the type. <br><br>  Unlike an OOP-style interface, a type class can refer to a type several times.  In Rust, this link is called <b>Self</b> , in Haskell, it can be called almost anything.  For example, in Haskell, the '+' method requires that both arguments be of exactly one type and an object of exactly the same type is expected to return (in Rust, in the <a href="http://doc.rust-lang.org/std/ops/trait.Add.html">Add</a> type class, these types can be different - in particular, Duration and Timespec can be added).  The type of the return value is also important - the arguments may not use the type from the class at all, and which implementation of the method the compiler decides to use based on what type to get.  For example, in Rust there is a class of types <a href="http://doc.rust-lang.org/std/num/trait.Zero.html">Zero</a> and code <pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> float_zero:<span class="hljs-built_in"><span class="hljs-built_in">f32</span></span> = Zero::zero(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_zero:<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = Zero::zero();</code> </pre>  assign different zeros to variables of different types. <br><br><h1>  How it is made in Rust </h1><h2>  Description </h2>  The type class is created by the trait keyword, followed by a name (possibly with parameters, like in C ++) and a list of methods.  A method may have a default implementation, but such an implementation does not have access to the internals of the type and must use other methods (for example, express inequality ( <b>! =</b> , <b>Ne</b> ) through the negation of equality). <pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PartialEq</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/// This method tests for `self` and `other` values to be equal, and is used by `==`. fn eq(&amp;self, other: &amp;Self) -&gt; bool; /// This method tests for `!=`. #[inline] fn ne(&amp;self, other: &amp;Self) -&gt; bool { !self.eq(other) } }</span></span></code> </pre>  Here is a description of the type class from the standard library, which includes types that can be compared for equality. <br>  The first argument, called <b>self</b> or <b>&amp; self of</b> each method, is an analogue of <b>this</b> from classic OOP.  The presence of an ampersend indicates the method of transferring ownership of the object and, unlike C ++, the ability to change it does not affect (passing by reference or by value).  The right to modify the object gives an explicit indication of mut. <br>  The second argument must be of the same type as the first - <b>Self</b> indicates this. <br>  Later we will come across the fact that this argument is not obligatory - something turns out like static methods, although in fact they still remain ‚Äúdynamic‚Äù - the distribution is carried out by other parameters or by the type of expected result. <br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Add</span></span></span></span>&lt;RHS,<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">/// The method for the `+` operator fn add(&amp;self, rhs: &amp;RHS) -&gt; Result; }</span></span></code> </pre>  Operation '+' in Rust is not required to require the same types of arguments and results.  For this, the type class is made template: template arguments are the types of the second argument and the result. <br>  For comparison, in Haskell, type classes are not parameterized (except by the type itself), but can contain not separate types, but pairs, triples, and other types of types (extension MultiParamTypeClasses), which allows you to do similar things.  To the release of Rust promise to add support for this feature. <br>  It is worth paying attention to the syntactic difference from C ++ - the description of an entity in Rust (in this case, a type class) is itself a template, and in C ++ the template is declared separately using a keyword.  The C ++ approach is somewhat more logical, but more difficult to understand. <br>  Consider another <a href="http://doc.rust-lang.org/std/num/trait.Zero.html">Zero</a> example: <pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Zero</span></span></span></span>: Add&lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">/// Returns the additive identity element of `Self`, `0`. /// /// # Laws /// /// ```{.text} /// a + 0 = a ‚àÄ a ‚àà Self /// 0 + a = a ‚àÄ a ‚àà Self /// ``` /// /// # Purity /// /// This function should return the same result at all times regardless of /// external mutable state, for example values stored in TLS or in /// `static mut`s. // FIXME (#5527): This should be an associated constant fn zero() -&gt; Self; /// Returns `true` if `self` is equal to the additive identity. #[inline] fn is_zero(&amp;self) -&gt; bool; }</span></span></code> </pre>  In the description of this type class, inheritance can be seen - for the implementation of Zero, you must first implement Add (parameterized by the same type).  This is the usual inheritance of interfaces without implementation.  Multiple inheritance is allowed, for this ancestor is listed through '+'. <br>  Pay attention to the <b>fn zero () -&gt; Self</b> method <b>;</b>  .  This can be considered as a static method, although we will see later that it is somewhat more dynamic than the static methods in OOP (in particular, they can be used to implement "factories"). <br><br><h2>  Implementation </h2>  Consider the implementation of Add for complex numbers: <pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span> + Num&gt; Add&lt;Complex&lt;T&gt;, Complex&lt;T&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Complex&lt;T&gt; { <span class="hljs-meta"><span class="hljs-meta">#[inline]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: &amp;Complex&lt;T&gt;) -&gt; Complex&lt;T&gt; { Complex::new(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.re + other.re, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.im + other.im) } }</code> </pre>  Complex numbers are a generic type, parameterized by the representation of a real number.  The implementation of addition is also parameterized - it is applicable to complex numbers over various valid options, if a certain interface is implemented for these valid ones.  In this case, the required interface is too rich - it assumes the existence of implementations of <a href="http://doc.rust-lang.org/std/clone/trait.Clone.html">Clone</a> (which allows you to create a copy) and <a href="http://doc.rust-lang.org/std/num/trait.Num.html">Num</a> (containing basic operations on numbers, in particular, the inheritance <a href="http://doc.rust-lang.org/std/ops/trait.Add.html">Add</a> ). <br><br><h2>  Deriving </h2>  If you are too lazy to write implementations of simple standard interfaces, this routine work can be passed to the compiler using the deriving directive. <pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[deriving(PartialEq, Clone, Hash)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Complex</span></span></span></span>&lt;T&gt; { <span class="hljs-comment"><span class="hljs-comment">/// Real portion of the complex number pub re: T, /// Imaginary portion of the complex number pub im: T }</span></span></code> </pre>  Here, library developers are asked to create an implementation of the PartialEq, Clone and Hash interfaces, if type T supports everything that is necessary. <br>  Currently, auto-generation implementations are supported for the types of Clone, Hash, Encodable, Decodable, PartialEq, Eq, PartialOrd, Ord, Rand, Show, Zero, Default, FromPrimitive, Send, Sync, and Copy types. <br><br><h1>  Numeric type classes </h1>  The <a href="http://doc.rust-lang.org/std/num/index.html">std :: num</a> module describes a large number of classes of types associated with different properties of numbers. <br>  They can refer to some other traits - for comparison and memory allocation operations (for example, <a href="http://doc.rust-lang.org/std/kinds/trait.Copy.html">Copy</a> prompts the compiler that this type can be copied byte-by-bye). <br>  I highlighted the interfaces that I implemented for dual numbers in a diagram. <img src="https://habrastorage.org/files/732/1c8/a57/7321c8a57e154641b561b0fec90db47b.png"><br><br><h1>  Implementation of dual numbers </h1>  The data type is trivial: <pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dual</span></span></span></span>&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> val:T, <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> der:T }</code> </pre> <br>  Unlike the complex numbers from the standard library, I tried to implement the interface based on minimal assumptions.  So the Add implementation from me requires only the Add interface from the source type, and the Mul only requires Mul + Add. <br>  Sometimes this led to strange code.  For example, Signed is not required to support Clone, and to return a copy of it to a positive dual number in the abs method, we had to add it to zero <pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T:Signed&gt; Signed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Dual&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">abs</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Dual&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.is_positive() || <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.is_zero() { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>+Zero::zero() <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">XXX:</span></span></span><span class="hljs-comment"> bad implementation for clone } else if self.is_negative() { -self } else { fail!("Near to zero") } } }</span></span></code> </pre>  Otherwise, the compiler cannot trace ownership of this object. <br>  Please note that the type <b>Zero :: zero ()</b> is not explicitly set.  The compiler guesses how it should be when attempting to add with <b>self</b> , which implements <b>Num</b> , and, consequently, <b>Add &lt;Self, Self&gt;</b> .  But the Self type is not known at the time of compilation - it is set by the template parameter.  So the <b>zero</b> method is dynamically located in the table of <b>Num</b> implementation methods for <b>Dual &lt;T&gt;</b> ! <br><br>  I would also note an interesting trick, as in Float integer constants are implemented, which characterize the entire type.  That is, they cannot receive an instance at the entrance (it may not be in the right context), but should be an analogue of static methods.  The same problem often arises in Haskell, and to solve it such methods add a fake parameter with the necessary type.  Haskell has a lazy language and you can always pass the <b>error "Not used"</b> as an unused argument.  In a strict Rust language, this technique does not work, and creating an object for this may be too expensive.  By this, a workaround is used - transmitted <b>None</b> type <a href="http://doc.rust-lang.org/std/option/">Option &lt;Self&gt;</a> <pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[allow(unused_variable)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T:Float&gt; Float <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Dual&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mantissa_digits</span></span></span></span>(_unused_self: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Dual&lt;T&gt;&gt;) -&gt; uint { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt; = <span class="hljs-literal"><span class="hljs-literal">None</span></span>; Float::mantissa_digits(n) } }</code> </pre>  Since the parameter is not used, by default the compiler issues a warning.  It can be suppressed in two ways - by starting the name of the parameter with the character '_' or using the directive # [allow (unused_variable)]. </div><p>Source: <a href="https://habr.com/ru/post/239151/">https://habr.com/ru/post/239151/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239139/index.html">The presentation of the new Tesla electric car will be held on October 9</a></li>
<li><a href="../239141/index.html">Mikrotik, DHCP Classless Route</a></li>
<li><a href="../239143/index.html">Create a 2D platformer using the Unreal Engine 4. Part 1.5 - Jumping</a></li>
<li><a href="../239147/index.html">Yii 2.0: Dynamic addition of validated form fields through a ‚Äújacket‚Äù (pjax) for a multi-model form</a></li>
<li><a href="../239149/index.html">Sqimitive.js - Frontend Primitive or ‚ÄúBackbone without wrappers‚Äù</a></li>
<li><a href="../239153/index.html">How to set the order of visiting new pages by a search robot based on the prediction of the popularity of a web page (Part I)</a></li>
<li><a href="../239155/index.html">How I stopped being afraid and loved Windows 10</a></li>
<li><a href="../239159/index.html">7 best tools for solving business problems from a business consultant generalist</a></li>
<li><a href="../239161/index.html">Reddit asked its remote developers to move to San Francisco or they will be fired</a></li>
<li><a href="../239163/index.html">Car audio as headset for phone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>