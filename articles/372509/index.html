<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Configurable logic cells in PIC microcontrollers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The original intent of the article was to describe the Microchip Microcontroller Independent Core Peripherals, but the topic turned out to be quite ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Configurable logic cells in PIC microcontrollers</h1><div class="post__text post__text-html js-mediator-article"><p>  The original intent of the article was to describe the Microchip Microcontroller Independent Core Peripherals, but the topic turned out to be quite extensive, so as a first step we will talk about CLC - Configurable Logic Cells (Configurable Logic Cell). </p><br><p>  The article (Using Configurable Logic Cells to Control WS2812 LED Tape [ <a href="https://geektimes.ru/post/255612/">1</a> ]) looked at how logical CLC cells of PIC controllers can significantly simplify the task of generating WS2812 driver control signals and implement hardware functions for which a simple microcontroller may miss the software solution. . <br>  The purpose of this article is to become more familiar with configurable logic cells in PIC Microchip microcontrollers, to demonstrate examples of implementations and, if possible, to push the reader to think about using CLC in their projects. </p><br><p>  In short, the CLC is one of the parts of the <abbr title="Peripherals Independent of the Core">stub</abbr> . </p><a name="habracut"></a><br><p>  Part 1. Configurable logic cells in PIC microcontrollers <br>  Part 2. <a href="https://geektimes.ru/post/279374/">I / O Ports</a> <br>  Part 3. <a href="https://geektimes.ru/post/280224/">ADC with calculator</a> </p><br><h1>  Introduction <br>  Description.  Configuration options.  What can be inputs and outputs </h1><br><p>  Configurable logical cells CLC are part of the PSI ‚Äî Core Independent Peripheral (CIP) Peripherals, i.e.  the functioning of such peripherals does not depend (almost) on the microcontroller's clock frequency and its state (RUN, IDLE, SLEEP). <br>  Of course, such peripherals are configured by the microcontroller program, but further operation can be independent. </p><br><p>  Each cell contains an input multiplexer, logic function, output control, connection to the interrupt controller. <br>  The general scheme of one logical cell is shown in Figure 1. </p><br><img src="https://habrastorage.org/files/73f/7f4/5c1/73f7f45c1dd745a7ab814db667a4e55b.png"><br><p>  Fig.1.  The structure of a single logical cell CLC </p><br><p> Each of the logical cells has 4 inputs, the signals for which are selected by the input multiplexer, each input can be direct or inverse.  Part of the inputs may not be used and connected to the level of log.0 or log.1. <br>  Inputs for cells can have external connections (input / output ports) and internal (signals from other peripherals: PWM, comparators, timers, etc., and the outputs of the CLC itself). <br>  The output of the CLC cell has a controlled polarity, it can be connected to the output port of the microcontroller, to other peripherals, to form an interrupt request by changing the state (on the front and / or decay). </p><br><p>  The logical function of each cell is selected from 8 options (see Table 1). </p><br><table><thead><tr><th>  log  cell </th><th>  log  cell </th></tr></thead><tbody><tr><td><img src="https://habrastorage.org/files/e82/81f/9f3/e8281f9f30eb410a88ecad173c30fd16.png" width="300"></td><td><img src="https://habrastorage.org/files/70f/496/d2b/70f496d2b560491f910870a4d9ae1f4b.png" width="300"></td></tr><tr><td><img src="https://habrastorage.org/files/514/25e/bc8/51425ebc82f64fc99b4df1e0b9fc8b8f.png" width="300"></td><td><img src="https://habrastorage.org/files/17b/d64/698/17bd6469846d423a9d6f78276ee43b13.png" width="300"></td></tr><tr><td><img src="https://habrastorage.org/files/257/d7f/090/257d7f090b974c168589ac93dda9e7c9.png" width="300"></td><td><img src="https://habrastorage.org/files/2f9/ca1/bb2/2f9ca1bb24cf45d592d8532743484392.png" width="300"></td></tr><tr><td><img src="https://habrastorage.org/files/c0c/925/211/c0c9252118484a81a1f3af257375bbb6.png" width="300"></td><td><img src="https://habrastorage.org/files/613/403/72d/61340372db75469cb398bc6b47134998.png" width="300"></td></tr></tbody></table><br><p>  Table 1. Options for logic cell functions. </p><br><p>  Since logical cells have a lot of settings, the easiest way to configure CLC is through the MPLAB Code Configurator plugin in the MPLAB X development environment, which creates C configuration files for the enabled peripherals. </p><br><img src="https://habrastorage.org/files/458/0f9/525/4580f95250594322b9f0ca563f87eabf.png"><br><p>  Fig.  2. Mplab X IDE development environment with the Mplab Code Configurator (MCC) plugin launched <br>  Where: <br>  1 - editable cell; <br>  2 - input multiplexer setting and input polarity; <br>  3 - logical cell function; <br>  4 - I / O port redundancy. </p><br><p>  Pay attention to the input gates at the CLC input (Fig. 2, p. 2), which are made as 4-OR elements. <br>  If necessary, in accordance with the laws of de Morgan, input gates can be converted from the base OR to AND (see Table 2). </p><br><p>  Table 2. Transformation of logical functions </p><br><table><thead><tr><th>  Logic function </th><th>  Equivalent representation in CLC </th></tr></thead><tbody><tr><td>  4-OR (OR) </td><td><img src="https://habrastorage.org/files/ee7/64d/791/ee764d7919804e01bcc026346c14a831.png"></td></tr><tr><td>  4-OR-NOT (NOR) </td><td><img src="https://habrastorage.org/files/902/5ff/d68/9025ffd68b364a64833075025fc587be.png"></td></tr><tr><td>  4-AND-NOT (NAND) </td><td><img src="https://habrastorage.org/files/062/ddf/e01/062ddfe0164d409a8e3ed89a1712590d.png"></td></tr><tr><td>  4-AND (AND) </td><td><img src="https://habrastorage.org/files/0bd/b82/587/0bdb82587333404c823160d8f94a2d7a.png"></td></tr></tbody></table><br><h1>  CLC Usage Examples </h1><br><h2>  Smooth change of LED brightness (flicker) </h2><br><p>  If the signals of two PWM with similar frequencies are connected to the inputs of a CLC configured as an XOR element (exclusive OR), then the LED blinking (periodic variation of the duty cycle) can be organized.  At the same time, the solution is completely hardware and does not require the participation of the MK kernel (program). </p><br><img src="https://habrastorage.org/files/034/5cd/32a/0345cd32a2d5423e9d079e19c35a2104.png" width="400"><br><p>  Fig.  3a.  Scheme "PWM modulator" </p><br><img src="https://habrastorage.org/files/286/268/fd1/286268fd12b5482ba15cd91af9404d19.png"><br><p>  Fig.  3b.  Diagrams showing the principle of changing the duty cycle </p><br><p>  If it‚Äôs a pity to use two PWM modules for such a simple task, then implementation options without PWM are possible: </p><br><p>  A) Use overflow signals of two timers (events), plus three CLC cells. <br>  On two JK-triggers in the counting mode, we send signals from the timers (postscaled out) - we get the meanders at the output, which are then sent to the XOR element. </p><br><img src="https://habrastorage.org/files/01b/19a/315/01b19a3153a74aa796eb6cc281fd0286.png" width="400"><br><p>  Fig.  3c.  Implementation of PWM modulator without input PWM signals </p><br><p>  B) Use overflow signals of two timers and one CLC. <br>  We send signals from the Timer (postscaled out) to the RS trigger inputs - we get ‚Äúsawtooth PWM‚Äù at the output (Fig. 3e). </p><br><img src="https://habrastorage.org/files/f5b/14f/d48/f5b14fd4819e408ebb6e60b5c9aacfe0.png" width="400"><br><p>  Fig.  3d </p><br><img src="https://habrastorage.org/files/be4/326/9aa/be43269aa20f434497d63917540e9015.png"><br><p>  Fig.  3e. </p><br><h2>  Frequency divider </h2><br><p>  The diagram of the frequency divider by 2 is shown in Fig.  4a.  One D-trigger is used in counting mode.  The input signal is fed to the clock input, input D is connected to the inverse output of the trigger.  At the moment of arrival at the clocking input, the front at input D will always have an inverse signal relative to the current state of the trigger, i.e.  the state of the trigger will change only on the front of the input signal. </p><br><img src="https://habrastorage.org/files/407/eb2/718/407eb2718f6d4e4dba322bbb56b55b37.png" width="400"><br><p>  Fig.4a.  Divider by 2. </p><br><p>  In the MPLAB Code Configurator plugin, this scheme may look like this: </p><br><img src="https://habrastorage.org/files/9a3/420/862/9a342086262c4394bdadc57e531c22aa.png"><br><p>  Fig.  4b.  Divider by 2 in MCC settings. </p><br><img src="https://habrastorage.org/files/f0c/59a/f37/f0c59af3738040b4a448c6c41bc43db5.png"><br><p>  Fig.4c.  Diagram of the input and output of the divider. </p><br><p>  The divider by 3 is shown in Fig.  4d. </p><br><img src="https://habrastorage.org/files/9ee/51d/78d/9ee51d78d2114a7facfe88db160ef3e0.png" width="400"><br><p>  Fig.  4d.  Divider by 3. </p><br><p>  The divisor by 4 is two consecutive divisors by 2 ;-) </p><br><p>  Where can dividers be used?  Where you need to divide the frequency. <br>  The following example uses frequency dividers. </p><br><h2>  Stepper motor driver </h2><br><p>  One of the easiest options for controlling a Stepper Motor (SM) is full-step control.  In this embodiment, the control signals are shifted by 90 ¬∞.  Therefore, it is possible to take a periodic signal, for one frequency divider to submit it directly, and for the other, in the inverse one. </p><br><img src="https://habrastorage.org/files/110/d04/68f/110d0468f7564aaab07efa6adb77aaf1.png" width="400"><br><p>  Fig.  5a.  Shaper control signals stepper motor. </p><br><img src="https://habrastorage.org/files/79d/4c8/718/79d4c87180b34dcfbacee3a98f464450.png"><br><p>  Fig.  5b.  The diagram at the shaper output. </p><br><p>  Changing the frequency at the CLC input will change the frequency of the stepper motor control signals.  The input frequency can be taken from the input of the microcontroller (external signal), or from an internal source - PWM or NCO generator. <br>  When controlling PWM, 2 parameters need to be changed: the period register (frequency) and the duty ratio register, since the control signal must have a 50% duty cycle. <br>  The use of NCO (Numerically Controlled Oscillator, controlled oscillator) looks more attractive, since this generator can automatically generate a meander, therefore, to change the frequency, you only need to change the values ‚Äã‚Äãin one register. <br>  To change direction, you need to invert the signals on one of the phases. </p><br><h2>  Delay.  Formation of impulse on the front, decline, changes </h2><br><p>  For some tasks it may be necessary to form a delayed pulse. <br>  To do this, you can use the D-trigger.  We feed the input signal to the counting input, or a high-frequency signal (for example, the Fosc clock frequency) to the clocking input.  Thus, the change in the trigger output will occur only on the front of the clock signal. <br>  This method will shift the front and the fall of the signal for the period of Fosc (clock frequency) only if both signals are synchronous.  Therefore, for a guaranteed shift by 1 period of Fosc, the shift signal must be formed by the microcontroller itself (PWM, NCO, etc.).  If the input signal is asynchronous, then at the input you can put the synchronizer on exactly the same D-flip-flop (i.e., first shift the asynchronous signal to the first clock pulse, and then shift by the full period of the clock signal). </p><br><img src="https://habrastorage.org/files/cb7/e84/661/cb7e8466181b439a85351230348ecb10.png" width="400"><br><p>  Fig.  6a.  Shaper delayed signal. </p><br><img src="https://habrastorage.org/files/2ba/693/729/2ba6937295214ddea4ecabbf96c4d10a.png"><br><p>  Fig.  6b.  Diagrams on the input and output of the delayed shaper. </p><br><p>  On the basis of this scheme, it is easy to implement a pulse shaper by changing the state of the input, by the front and by the decay. </p><br><h3>  Formation of impulses on the front and decline </h3><br><img src="https://habrastorage.org/files/022/c50/c37/022c50c37a0f4c5aa8e38523a41f2900.png" width="400"><br><p>  Fig.  7a.  Shaper pulse on the front and the decline </p><br><img src="https://habrastorage.org/files/173/d6d/a81/173d6da819794a7d86b6e4626d9663ca.png"><br><p>  Fig.  7b.  Diagrams on the input and output of the pulse shaper on the front and in the decay </p><br><h3>  Formation of impulses on the front </h3><br><img src="https://habrastorage.org/files/194/be9/a87/194be9a87407450b9d7712ad44029e93.png" width="400"><br><p>  Fig.  8a.  Shaper pulse on the front. </p><br><img src="https://habrastorage.org/files/04c/ee0/d8e/04cee0d8e0eb48cea7d80a8d430afaa2.png"><br><p>  Fig.  8b.  Diagrams on the input and output of the pulse former on the front </p><br><h3>  Formation of impulses by decay </h3><br><img src="https://habrastorage.org/files/547/042/c8a/547042c8aeb34fe7a813a8fe90b976ee.png" width="400"><br><p>  Fig.  9a.  Impulse Shaper </p><br><img src="https://habrastorage.org/files/cbd/a18/f31/cbda18f319d743aca4377770553a1e0c.png"><br><p>  Fig.  9b.  Diagrams on the input and output of the pulse shaper by decay </p><br><p>  Where can similar schemes be applied? <br>  You can use, for example, when building a pulsed power source for blanking the feedback signal from the comparator during the switching of the power switch (for more details, see below). </p><br><h2>  Contact bounce suppression </h2><br><p>  When closing and opening the contacts bounce is observed.  Surely, many people have come across this phenomenon when questioning the state of mechanical buttons.  Logic cells together with a timer can solve the problem in hardware. <br>  The implementation scheme is exactly the same as for the formation of a delayed pulse, only the period of the clock signal needs to be taken longer.  The essence of the method is that the trigger output does not respond to the input if there is no clocking signal, so the circuit does not respond to each input switching. </p><br><img src="https://habrastorage.org/files/062/9e5/3b2/0629e53b2009406d93e679ed51f3862d.png" width="400"><br><p>  Fig.10a.  chatter suppression. </p><br><img src="https://habrastorage.org/files/cc7/cb0/c68/cc7cb0c68c764781bab388c9c98b12d1.png"><br><p>  Fig.10b.  Diagrams of signals at the input and output of the chatter suppression circuit. </p><br><p>  Where does it apply? <br>  Actually poll buttons, preventing multiple false positives. </p><br><h3>  More options </h3><br><img src="https://habrastorage.org/files/e82/828/631/e828286312a244ac834ed46155bd4035.png"><br><p>  Fig.10c.  Delayed chatter with RC-chain </p><br><img src="https://habrastorage.org/files/ba7/496/b64/ba7496b6428c4463adc3336a1308374f.png"><br><p>  Fig.10d.  bounce suppression </p><br><p>  Unlike the previous example, the delay is determined by the parameters of the RC circuit and does not require the activation of the timer. </p><br><h2>  Quadrature encoder </h2><br><p>  A quadrature encoder is a device that, when its axis rotates, two quadrature signals are formed (out of phase).  It is used in determining the speed (angle of rotation or speed) and the direction of rotation / movement.  Perhaps the most famous application is the mouse wheel. </p><br><p>  Below are two schemes for decoding quadrature encoder signals. </p><br><img src="https://habrastorage.org/files/964/cd3/ba8/964cd3ba8b0f4731a94f6d5cfd50d99c.png" width="400"><br><p>  Fig.  11a.  Quadrature decoder with counting output and direction signal. </p><br><p>  This scheme detects the phases of the input signals (the state of output D indicates the direction of rotation of the encoder) and outputs clock signals (output C). </p><br><img src="https://habrastorage.org/files/8bc/01f/b39/8bc01fb39a384623bedc3f7aa19f7118.png" width="400"><br><p>  Figure 11b.  Quadrature decoder with two counting outputs </p><br><p>  This circuit emits pulses.  One exit at rotation clockwise, the second exit - at return rotation. </p><br><p>  When switching contacts, the encoder generates multiple false positives (contact bounce). </p><br><img src="https://habrastorage.org/files/b50/b72/73e/b50b7273ee2b4363831c2b6fba139e8b.png"><br><p>  Fig.  11c.  Signals from the outputs of a mechanical quadrature encoder </p><br><p>  Here is a larger fragment: </p><br><img src="https://habrastorage.org/files/85e/3d6/765/85e3d67651964eb29c08812e1b64fe2b.png"><br><p>  Fig.  11d.  Signals from the outputs of a mechanical quadrature encoder </p><br><p>  Therefore, both circuits need bounce-free signals.  Earlier, we considered hardware chatter suppression options on CLC cells. </p><br><img src="https://habrastorage.org/files/da6/390/c28/da6390c2831546f1ad760af6fa35fec8.png"><br><p>  Fig.  11e.  Input signals from the encoder and bounce free. </p><br><p>  For the processing of quadrature encoder signals, 4 CLC cells will be needed - two for chatter suppression and two for detection. </p><br><img src="https://habrastorage.org/files/8d3/890/290/8d389029022f4c7a9a1ce65bd8b23f8f.png"><br><p>  Fig.  11f.  Diagrams of quadrature encoder processing signals for a circuit with direction output </p><br><img src="https://habrastorage.org/files/1fa/e2c/310/1fae2c3105774e8b9fb4f372b804adb8.png"><br><p>  Fig.  11g.  Diagrams of quadrature encoder processing signals for a circuit with two counting outputs. </p><br><p>  The inputs and outputs of logic cells can be connected to the ports of the microcontroller, and can only have internal connections.  For this example, only two inputs are needed, the decoder outputs can be connected to the internal counters of the microcontroller, generate interrupts, interrogate the program, etc. ... But for testing tasks, all CLC outputs can be brought out and the correct operation of the circuit can be checked. </p><br><p>  Where does it apply? <br>  Mechanical and optical encoders, counting the number of people entering and leaving, closing the turnstile when passing in the wrong direction)) </p><br><h2>  Manchester Coder </h2><br><p>  Manchester coding is widely used in signal transmission.  Each bit is divided into two intervals, after the first interval (in the middle of the information bit) the signal level changes.  The transfer of each information bit is accompanied by a change in the level, Zeros and Units differ in phase (1 - difference from 0 to 1, "0" - from 1 to 0).  Thus, the Manchester code has the following features: </p><br><ul><li>  Self-synchronizing - there is no need to transmit special sync signals, since the level of the transmitted signal is guaranteed to change in the middle of the information bit;  high information density </li><li>  No DC component (signal changes every clock) <br></li></ul><br><p>  The coding scheme is very simple and uses one logical element EXCLUSIVE OR. </p><br><p>  At the output we get a coded stream. </p><br><img src="https://habrastorage.org/files/aa8/805/e52/aa8805e5260b4538b8e0a9d32d82df6b.png"><br><p>  Fig.  12. Diagrams shaper Manchester code </p><br><h2>  Manchester code decoder </h2><br><p>  The circuit of the Manchester decoder is much more complicated.  Its task is to isolate the sync pulses and bit stream. </p><br><p>  In the application example of <a href="http://ww1.microchip.com/downloads/en/appnotes/01470a.pdf">AN1470</a> [2], the following implementation of hardware decoding of the Minchester code based on CLC and NCO (controlled oscillator) is proposed. </p><br><img src="https://habrastorage.org/files/427/c87/a59/427c87a59e584859a9b17053f99c4744.png" width="500"><br><p>  Fig.13a.  Manchester code decoder circuit </p><br><img src="https://habrastorage.org/files/840/9e4/28c/8409e428c51d494186c72ca12b696a33.png"><br><p>  Fig.  13b.  Diagrams explaining the operation of the decoder </p><br><p>  <b>Stage 1 - D-Trigger</b> <br>  The CLC4 cell (D-flip-flop) latches the input stream on the decay of the synchronization signal.  The output from this trigger will be the decoded (recovered) data from the input stream. </p><br><p>  <b>Stage 2 - XOR Element (CLC2)</b> <br>  Since in Manchester coding, a change in the signal occurs in the middle of each information bit, it is possible to use the EXCLUSIVE OR element to provide a rising front in stage 3 in the middle of each bit, i.e.  we synchronize the decoder in the middle of each bit. </p><br><p>  <b>Stage 3 - NCO + AND-OR (CLC1)</b> <br>  NCO module, used to generate ¬æ bit interval after which the data is captured (committed).  NCO is used in active low state mode.  The duration of the pulses can be adjusted using registers.  The NCO module needs a source of clock pulses that come from the CLC1. <br>  These two blocks are most important in the decoder.  They create pulses of a fixed length after each rising edge of the signal coming out of ‚Äústage 2‚Äù.  The output of the NCO is fed back to the AND-OR element so that if the output from ‚Äústage 2‚Äù becomes zero, then the NCO will continue to be clocked until it overflows. </p><br><p>  Selected synchronization and data signals can be added to the SPI module.  Then, after receiving the code send, in the SPI buffer we get the decoded data and receive receive interrupt. </p><br><h2>  Standby Multivibrator </h2><br><p>  For the formation of a single pulse on the front or on the fall of the input signal are waiting multivibrators. </p><br><img src="https://habrastorage.org/files/ae9/425/9f1/ae94259f107a474c8ed10837ac537202.png" width="400"><br><p>  Fig.  14a.  The scheme of the waiting multivibrator on the JK-trigger. </p><br><img src="https://habrastorage.org/files/402/360/cfe/402360cfeb3949349669df632d3469ea.png"><br><p>  Fig.  14b.  The implementation of the waiting multivibrator on the JK-trigger in the PIC-controller. </p><br><img src="https://habrastorage.org/files/d7b/79d/231/d7b79d2315344fe082b8c6074454e553.png" width="500"><br><p>  Fig.  14c.  Diagrams explaining the work of the waiting multivibrator </p><br><p>  Inverting the signal at the synchronization input is implemented by a standby multivibrator with triggering by the decay of the input signal (Fig.14d). </p><br><img src="https://habrastorage.org/files/2a4/945/22d/2a494522dffb4aa591ea372ac52f9067.png" width="500"><br><p>  Fig.  14d.  Standby multivibrator charts with the launch of the decline. </p><br><p>  Unlike the pulse formers considered earlier in the front and in the decay (see Figures 8a, 9a), for this circuit, the pulse duration is not determined by the frequency of the signal at the clock input, but by the parameters of the RC-chain. </p><br><h2>  Multivibrator </h2><br><p>  The simplest generator can be made on two CLC (D-flip-flop + inverter). <br>  The disadvantage is low stability, since switching thresholds depend on log.0 and 1 levels of a particular type of microcontroller, which can ‚Äúwalk‚Äù on temperature, supply voltage, etc. Besides, it‚Äôs not very correct when the digital input signal level is for a long time between 0 and 1. </p><br><img src="https://habrastorage.org/files/1e1/58b/a82/1e158ba8211c4d279eb74b4b377aa7c3.png" width="400"><br><p>  Fig.  15a.  The simplest multivibrator on the D-trigger. </p><br><p>  The following scheme uses two built-in comparators and one CLC.  In this scheme, the thresholds of the comparators are set by the reference voltage source and an external divider (or an integrated DAC).  The circuit will be more stable and besides, the comparators have analog inputs and allow any input voltage within the supply voltage. </p><br><img src="https://habrastorage.org/files/818/61b/7f9/81861b7f99eb4e2b803e354d5fd6a384.png" width="400"><br><p>  Fig.15b.  Multivibrator on two comparators and RS-trigger. </p><br><p>  For this example, from the MOT, in addition to the CLC, we will need 2 comparators, as well as sources of reference voltage (external at the divider or internal). <br>  In the initial state, the output level of the trigger is set to log.0, the capacitor is discharged, on the comparator COMP1 output1 appears, the trigger is set to 1, the capacitor is charged through a resistor to the level of the upper threshold voltage (Vref hi), when reaching the input R trigger appears log.1.  The trigger is thrown into the opposite state, the capacitor begins to discharge through a resistor, and so on ... Thus, we got a fully software-independent generator.  But in this scheme, the microcontroller can programmatically change the frequency by changing the threshold of one of the comparators (changing the reference voltage of the built-in DAC or others). </p><br><img src="https://habrastorage.org/files/809/b13/9d3/809b139d3447404499e00f97a8d08a96.png"><br><p>  Fig.15c.  Multivibrator signal diagrams </p><br><h2>  Capacity Measurement.  Capacitive sensor.  Touch Button </h2><br><p>  The frequency of the multivibrator (Fig. 15) depends on the value of the capacitor capacitance and the resistance of the resistor.  If one of the parameters changes, the frequency changes.  Therefore, this scheme allows to measure the resistance or capacitance, for example, using a microcontroller timer. <br>  As a capacitor, a conductive pad can be used, when touched, we will add additional capacitance to the circuit, which will lead to a decrease in the generator frequency. </p><br><table><thead><tr><th>  signals </th><th>  comment </th></tr></thead><tbody><tr><td><img src="https://habrastorage.org/files/a73/19f/904/a7319f9043b042dc8deeb6ece4498a4a.png" width="500"></td><td>  Waveforms without touching the sensor </td></tr><tr><td><img src="https://habrastorage.org/files/344/0b4/901/3440b49017134371b7f11c6c62bd9d51.png" width="500"></td><td>  Waveform when the sensor is ‚Äúpressed‚Äù </td></tr></tbody></table><br><p>  Fig.16a.  Diagrams of operation of the multivibrator when the time-varying capacity changes. </p><br><p>  A similar method can detect water leakage or determine soil moisture and use it to automate flower irrigation)) </p><br><h2>  Switching power supply </h2><br><p>  Another example of using configurable logic cells in conjunction with embedded comparators. <br>  The TMR timer periodically sets the RS flip-flop and opens the power transistor.  The current begins to flow through the inductance, the voltage across the resistor R1 increases linearly.  When the voltage on R1 reaches the threshold value, the COMP1 comparator is activated and resets the trigger, the transistor closes.  The current through the inductance can not be interrupted instantly, so the current begins to flow through the diode D1 and charges the output capacitor.  When the timer is triggered, the trigger is set again and the process repeats. </p><br><img src="https://habrastorage.org/files/4af/4bd/d98/4af4bdd98d124a6d92c08086483efd42.png" width="500"><br><p>  Fig.17a.  The simplest switching power supply. </p><br><p>  The figure shows a step-up source, but for other topologies (see Fig. 17b), the operation of the circuit will be similar, so I will not draw the output stage. </p><br><table><thead><tr><th>  scheme </th><th>  description </th></tr></thead><tbody><tr><td><img src="https://habrastorage.org/files/c91/27e/d47/c9127ed470d746dcb35cc17eb26735ed.png" width="300"></td><td>  boosting </td></tr><tr><td><img src="https://habrastorage.org/files/b27/fb2/8de/b27fb28dee9545cb8709a6809d764f9a.png" width="300"></td><td>  downward </td></tr><tr><td><img src="https://habrastorage.org/files/f2b/6d8/c2c/f2b6d8c2c9e84beaa8cc6f05feec7a21.png" width="300"></td><td>  Sepic </td></tr></tbody></table><br><p>  Figure 17b.  Different topologies of switching power supplies </p><br><p>  Shown in fig.  17a the circuit performs the function of energy conversion and operates on the peak value of current in inductance.  You can also enter the control circuit output voltage.  It is easiest to make hysteresis control: when the voltage at the output is below the norm - the source is pumped, when the voltage is higher - the output of control pulses to the power transistor is blocked. </p><br><img src="https://habrastorage.org/files/d46/626/262/d46626262d9345ffb3ef2674b3342757.png" width="500"><br><p>  Fig.17c.  SMPS with hysteresis control </p><br><p>  Turning on the power transistor will generate noise, which can lead to premature operation of the COMP1 comparator.  To get rid of this, you can turn on the RC filter in the circuit between R1 and the comparator, or you can add a blocking unit considered earlier (forming a pulse at the front, see figure 8a, or fig. 14a), which, after turning on the transistor, will block the reset of the short time interval </p><br><img src="https://habrastorage.org/files/6ca/0c7/433/6ca0c7433720495c85ee1f7af122b5c9.png" width="500"><br><p>  Fig.17d.  Interference when switching power key </p><br><img src="https://habrastorage.org/files/aca/7d8/95a/aca7d895af72483daa8fd9a82cde2ee7.png"><br><p>  Fig.17e.  SMPS with hysteresis control and blanking interference switch. </p><br><p>  U1  U2            CLC1,          CLC (   Microchip  4 ). <br>         ‚Äì   ,         .   Ref  Ref1        .  ,             .                .     ,    . </p><br><p> ,         PIC16F17xx  Microchip    ( )    :    (Slope Compensation)   - (Programmable Ramp Generator, PRG),  ,      (COG), HLT .          . </p><br><p>        ,         , ..         .     ,         ‚Äì     ,       . </p><br><h2>  Literature </h2><br><ol><li> <a href="https://geektimes.ru/post/255612/">        WS2812</a> </li><li> <a href="http://ww1.microchip.com/downloads/en/appnotes/01470a.pdf">AN1470. Manchester Decoder Using the CLC and NCO</a> </li></ol><br><p>  Continued. <a href="https://geektimes.ru/post/279374/"> 2.  /.</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/372509/">https://habr.com/ru/post/372509/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../372499/index.html">Coyne for like, or why STEEM currency is popular</a></li>
<li><a href="../372501/index.html">Pool Automation with NEVOTON DMC-5.1.1-Z Data Acquisition Module</a></li>
<li><a href="../372503/index.html">Huge robotic manipulators or how we participated in the Moscow Mini Maker Faire festival</a></li>
<li><a href="../372505/index.html">Bitcoin economic news digest</a></li>
<li><a href="../372507/index.html">Why the way to the future of robozahvatov lies through tactile intelligence</a></li>
<li><a href="../372511/index.html">In Moscow and the region in –†–æk√©mon Go, more than 180,000 people play. Daily growth 30%</a></li>
<li><a href="../372513/index.html">How Facebook and Apple helped reveal the identity of the owner of KickassTorrents</a></li>
<li><a href="../372515/index.html">[Updated] Copenhagen Suborbitals today launched another suborbital rocket</a></li>
<li><a href="../372517/index.html">How to destroy the universe</a></li>
<li><a href="../372519/index.html">Windows 10 Anniversary Update: what to expect from an anniversary Windows update?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>