<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We are looking for errors in MonoDevelop</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="An important event took place in the life of the PVS-Studio analyzer - the latest version added the ability to check the code written in C #. Being on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We are looking for errors in MonoDevelop</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/c63/51c/212/c6351c2122fc4b09a9182c0d6203e574.png"></div><br>  An important event took place in the life of the PVS-Studio analyzer - the latest version added the ability to check the code written in C #.  Being one of the developers of this analyzer, I just could not pass by without checking out any project.  It is clear that very few people will be interested in reading about checking small and unknown projects, so you had to choose something known, and the choice fell on MonoDevelop. <br><a name="habracut"></a><br><h2>  Little about the project </h2><br>  <a href="http://www.monodevelop.com/">MonoDevelop</a> is a free development environment for creating C #, Java, Boo, Nemerle, Visual Basic .NET, Vala, CIL, C and C ++ applications.  Support is also planned for Oxygene from Embarcadero Technologies. <br><br><img src="https://habrastorage.org/files/d9d/3fd/c28/d9d3fdc2867e4567b752c98900db0489.png"><br><br>  Initially, it was the SharpDevelop port on Mono / GTK +, but since that time the project has gone far from its initial state. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      MonoDevelop is part of the Mono project.  Built into the distribution of Unity3D as a means of writing scripts, but the outdated version (4.0.1). <br><br>  Among the features of this development environment, syntax highlighting, code folding, code code completion, class browser, plugin support, built-in debugger, visual form designer, unit testing are highlighted. <br><br>  The source code of the project is available in the <a href="https://github.com/mono/monodevelop">corresponding repository on GitHub</a> , and <a href="http://www.monodevelop.com/developers/building-monodevelop/">the assembly instructions are</a> described on the official project website. <br><br><h2>  What was checked? </h2><br>  As mentioned above, the project was analyzed using the latest version of the <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> static code analyzer, to which the ability to analyze the C # code was added.  This is the first release of the C # analyzer, and at the moment it has implemented more than 40 diagnostic rules.  It is clear that this version is still far from being developed as much as the C ++ analyzer, but using this tool you can already find quite interesting errors (some of which will be given in this article).  The C # analyzer is not a separate product, it is part of the same PVS-Studio, which now simply knows how to analyze code written in another programming language. <br><br>  Download the latest version of the analyzer at <a href="http://www.viva64.com/en/pvs-studio-download/">this link</a> . <br><br><h2>  A few words about the analysis result </h2><br>  As a result of the analysis, 8457 files were included as part of 95 projects. <br><br>  The analyzer issued 118 warnings of the first, 128 warnings of the second and 475 warnings of the third level. <br><br>  Some may say that this is not so much for so many files.  But here it is worth taking into account the fact that at the moment a smaller number of diagnostics is implemented than in the C ++ analyzer.  Secondly, the analyzer is ineffective with one-time checks.  Although this has been <a href="http://www.viva64.com/ru/b/0105/">repeated</a> many <a href="http://www.viva64.com/ru/b/0105/">times</a> , it is worth mentioning once again - to get the full benefits of using static analysis tools, they should be used regularly, rather than once.  This will save time on finding and eliminating errors, and as a result - will make project development cheaper and easier. <br><br><h2>  Analysis results </h2><br>  The article will discuss some of the most interesting errors found, since a review of all errors found would increase the volume of this article to indecent sizes.  The article is divided into subsections containing a description of certain types of errors with examples of code from the project.  So you can go directly to viewing the most interesting mistakes for you. <br><br><h3>  Same expressions to the left and right of the operator </h3><br>  This subsection provides descriptions of errors like 'A ||  A '.  Often, such errors are the result of typos or unsuccessful 'copy-paste' and carelessness of the programmer.  Often, such errors can be difficult to find in large amounts of code, especially if the variable names are long enough and differ only in one character.  As a rule, the use of another variable is implied, but sometimes such checks are simply redundant code.  More about all this below. <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override SourceCodeLocation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSourceCodeLocation</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fixtureTypeNamespace, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fixtureTypeName, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> methodName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty (fixtureTypeName) || <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty (fixtureTypeName)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; .... }</code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0381/">V3001</a> There are identical sub-expressions 'string.IsNullOrEmpty (fixtureTypeName)'  operator.  MonoDevelop.NUnit NUnitProjectTestSuite.cs 84 <br><br>  The error can be seen with the naked eye - in the condition the same string variable is checked twice for equality 'null' or for equivalence 'String.Empty'.  Below the code (not the whole body is shown here, so as not to complicate perception, so take a word) a similar check is performed for the variable 'fixtureTypeNamespace', so it can be assumed that the second check of this condition should take the variable methodName as the method argument 'or absent altogether. <br><br>  Another example of a similar error: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryAddDocument</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName, out OpenRazorDocument currentDocument)</span></span></span><span class="hljs-function"> </span></span>{ .... var guiDoc = IdeApp.Workbench.GetDocument (fileName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (guiDoc != null &amp;&amp; guiDoc.Editor != null) .... guiDoc.Closed += (sender, args) =&gt; { var doc = sender as MonoDevelop.Ide.Gui.Document; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc.Editor != null &amp;&amp; doc.Editor != null) .... } .... }</code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0381/">V3001</a> There are identical sub-expressions 'doc.Editor! = Null' operator.  MonoDevelop.AspNet RazorCSharpParser.cs 180 <br><br>  Again 2 identical checks within the same expression.  Theoretically, after casting the 'sender' variable using the 'as' operator, the value 'null' can be written to the 'doc' variable.  As a result, an exception of the 'NullReferenceException' type will be generated when the 'doc.Editor! = Null' check is performed.  The corrected version of the code could look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc != null &amp;&amp; doc.Editor != null)</code> </pre><br>  Another piece of code with an error: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MemberCore </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLaterDefinedMember</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MemberSpec a, MemberSpec b)</span></span></span><span class="hljs-function"> </span></span>{ var mc_a = a.MemberDefinition as MemberCore; var mc_b = b.MemberDefinition as MemberCore; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mc_a == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mc_b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mc_b == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mc_a; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.DeclaringType.MemberDefinition != b.DeclaringType.MemberDefinition) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mc_b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mc_a.Location.File != mc_a.Location.File) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mc_b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mc_b.Location.Row &gt; mc_a.Location.Row ? mc_b : mc_a; }</code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0381/">V3001</a> There‚Äôs the mc_a.Location.File to the left!  ICSharpCode.NRefactory.CSharp membercache.cs 1319 <br><br>  Such an error may not be evident, but the analyzer is not a person, and does not miss such things.  The code shows that the property 'File' of the object 'mc_a' is compared with itself, but it is obvious that it should be compared with the corresponding property of the object 'mc_b'. <br><br>  Correct code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mc_a.Location.File != mc_b.Location.File)</code> </pre><br>  Redundant code: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override AppResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Property</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName, object value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resultIter != null &amp;&amp; resultIter.HasValue) { var objectToCompare = TModel.GetValue (resultIter.Value, Column); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MatchProperty (propertyName, objectToCompare, value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MatchProperty (propertyName, ParentWidget, value); } TreeIter? resultIter;</code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0381/">V3001</a> There are identical sub-expressions 'resultIter! = Null' operator.  MonoDevelop.Ide GtkTreeModelResult.cs 125 <br><br>  The variable 'resultIter' is nullable-type, therefore, checks of the form 'resultIter! = Null' and 'resultIter.HasValue' are identical and one could restrict one of them. <br><br>  Exactly the same code met once more.  Appropriate analyzer warning: <br><br>  <a href="http://www.viva64.com/ru/d/0381/">V3001</a> There are identical sub-expressions 'resultIter! = Null' operator.  MonoDevelop.Ide GtkTreeModelResult.cs 135 <br><br>  Consider the following code snippet: <br><pre> <code class="cpp hljs">Accessibility DeclaredAccessibility { get; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsStatic { get; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MembersMatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISymbol member1, ISymbol member2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (member1.Kind != member2.Kind) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (member1.DeclaredAccessibility != member1.DeclaredAccessibility || member1.IsStatic != member1.IsStatic) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (member1.ExplicitInterfaceImplementations().Any() || member2.ExplicitInterfaceImplementations().Any()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SignatureComparer .HaveSameSignatureAndConstraintsAndReturnTypeAndAccessors( member1, member2, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IsCaseSensitive); }</code> </pre> <br>  Analyzer Warnings: <ul><li>  <a href="http://www.viva64.com/ru/d/0381/">V3001</a> There are identical sub-expressions 'member1.DeclaredAccessibility' to the left and to the right of the '! =' Operator.  CSharpBinding AbstractImplementInterfaceService.CodeAction.cs 544 </li><li>  <a href="http://www.viva64.com/ru/d/0381/">V3001</a> There are identical sub-expressions of "member1.IsStatic" to the left!  CSharpBinding AbstractImplementInterfaceService.CodeAction.cs 545 </li></ul><br>  Another typo.  And not one, but two at once.  Again, the properties of the same object ('member1') are compared between themselves.  Since the properties are primitive and there is no additional logic in them, such checks also lose their meaning.  And from the code it is clear that the properties of the objects 'member1' and 'member2' should be compared.  The correct code is: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (member1.DeclaredAccessibility != member2.DeclaredAccessibility || member1.IsStatic != member2.IsStatic)</code> </pre> <br><br><h3>  Assigning a variable to itself </h3><br>  Not a common type of error, as the previous one, but no less interesting.  Often erroneous situations are when some member of a class in a method must assign the value of one of the arguments passed, and these names often differ only in the case of the first character.  It is easy to make a mistake.  There are also simple cases of assigning a variable to itself, and if these are properties, the compiler will not issue any warnings.  Such actions are understandable, if complex logic is hung on the getter / setter of properties, but if there is none, the assignment looks at least strange.  But let's not be unfounded, better take a look at examples of such errors. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViMacro</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> macroCharacter)</span></span></span><span class="hljs-function"> </span></span>{ MacroCharacter = MacroCharacter; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> MacroCharacter {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;}</code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0403/">V3005</a> The 'MacroCharacter' variable is assigned to itself.  Mono.TextEditor ViMacro.cs 57 <br><br>  What was mentioned above - because the names of the property and the constructor argument differ only in the case of the first character, the value of the property is written into itself instead of writing the value passed as an argument.  Looking at the definition of the property, you can make sure that it does not contain any additional logic. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViMark</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> markCharacter)</span></span></span><span class="hljs-function"> </span></span>{ MarkCharacter = MarkCharacter; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> MarkCharacter {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;}</code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0403/">V3005</a> The 'MarkCharacter' variable is assigned to itself.  Mono.TextEditor ViMark.cs 45 <br><br>  The error is exactly the same as the previous one.  Again, the first character in the variable name is confused, which is why the constructor does not work as expected. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WhitespaceNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> whiteSpaceText, TextLocation startLocation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.WhiteSpaceText = WhiteSpaceText; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startLocation = startLocation; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> WhiteSpaceText { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; }</code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0403/">V3005</a> The 'this. WhiteSpaceText' variable is assigned to itself.  ICSharpCode.NRefactory.CSharp WhitespaceNode.cs 65 <br><br>  The error is again similar to the previous one, but this time the code is more interesting because in one of the two assignments the programmer was not sealed.  It is easy to miss such an error during speed typing, especially if you use automatic code substitution.  However, this could have been avoided by regularly checking the new code with a static analyzer.  For example, in PVS-Studio you can automatically check the new code after compilation (see <a href="http://www.viva64.com/ru/d/0218/">incremental analysis mode</a> ). <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OptionsChanged</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object sender, EventArgs e)</span></span></span><span class="hljs-function"> </span></span>{ gutterMargin.IsVisible = Options.ShowLineNumberMargin; iconMargin.IsVisible = iconMargin.IsVisible; .... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsVisible { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; }</code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0403/">V3005</a> The 'iconMargin.IsVisible' variable is assigned to itself.  MonoDevelop.HexEditor HexEditor.cs 241 <br><br>  This is the second type of error that I described at the beginning of a subsection.  The value of the property is assigned to itself, but there are no local variables with the name similar to this property.  In this case, the property, again, is not tied to any additional logic.  Perhaps the correct code would look like this, although it is impossible to say for sure here: <br><pre> <code class="cpp hljs">iconMargin.IsVisible = gutterMargin.IsVisible;</code> </pre> <br><br><h3>  Illusion of choice </h3><br>  An interesting subtitle, isn't it?  However, he, perhaps, most accurately describes some types of errors, such as those that are detected using diagnostic messages <a href="http://www.viva64.com/ru/d/0402/">V3004</a> or <a href="http://www.viva64.com/ru/d/0383/">V3012</a> .  The essence of this type of error is that regardless of whether the condition being checked (V3004 for the 'if' operator and V3012 for the ternary) is true or false, the same actions will always be performed, or the same result will be returned.  Unfortunately, the errors diagnosed by the warning V3004 were not found in the project, but on the other hand there was a couple of warnings V3012, which will be discussed below. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> WindowCommands { NextDocument, PrevDocument, OpenDocumentList, OpenWindowList, SplitWindowVertically, SplitWindowHorizontally, UnsplitWindow, SwitchSplitWindow, SwitchNextDocument, SwitchPreviousDocument } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Switch</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IdeApp.Preferences.EnableDocumentSwitchDialog) { IdeApp.CommandService.DispatchCommand ( next ? WindowCommands.NextDocument : WindowCommands.NextDocument); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } var toplevel = Window.ListToplevels () .FirstOrDefault (w =&gt; w.HasToplevelFocus) ?? IdeApp.Workbench.RootWindow; var sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DocumentSwitcher (toplevel, next); sw.Present (); }</code> </pre> <br>  Analyzer warning: <a href="http://www.viva64.com/ru/d/0383/">V3012</a> The '?:' Operator, regardless of its conditional expression, always returns the same: WindowCommands.NextDocument.  MonoDevelop.Ide WindowCommands.cs 254 <br><br>  The ternary operator will always return the same enumeration element ('WindowCommands.NextDocument').  I suppose that in case the 'next' variable is 'false', the element 'WindowCommands.PrevDocument' should have been returned. <br><br>  Again, I suspect that such errors are made due to the use of code auto-substitution tools.  And when you work quickly, you may not notice at all that the tool that should help in writing the code has helped in writing the error.  However, these are only assumptions and arguments on this topic are beyond the scope of this article. <br><br>  I met another similar example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartTestElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ITestResult result)</span></span></span><span class="hljs-function"> </span></span>{ ITest test = result.Test; TestSuite suite = test as TestSuite; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (suite != null) { xmlWriter.WriteStartElement(<span class="hljs-string"><span class="hljs-string">"test-suite"</span></span>); xmlWriter.WriteAttributeString(<span class="hljs-string"><span class="hljs-string">"type"</span></span>, suite.TestType); xmlWriter.WriteAttributeString(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, suite.TestType == <span class="hljs-string"><span class="hljs-string">"Assembly"</span></span> ? result.Test.FullName : result.Test.FullName); } .... }</code> </pre> <br>  Analyzer warning: <a href="http://www.viva64.com/ru/d/0383/">V3012</a> The '?:' Operator, regardless of its conditional expression, always returns the same value: result.Test.FullName.  GuiUnit_NET_4_5 NUnit2XmlOutputWriter.cs 207 <br><br>  As can be seen from the code fragment, the expression 'suite.TestType == "Assembly"' or false will be true, the result of the ternary operator will be the value of the 'FullName' property. <br><br><h3>  Checking the wrong variable for equality 'null' after casting by operator 'as' </h3><br>  And this is a situation specific to C #.  And, judging by the proven projects, this is a pattern of errors, and not isolated cases.  As we all know, in case the cast failed using the 'as' operator, the result is the value 'null' (unlike the explicit cast using the syntax '(type_name) arg', when an exception of the type 'InvalidCastException' is generated ).  Often, after such a cast, a check is performed to ensure that it is successful.  However, they often make a mistake, checking inadvertently not the result of a cast, but a reducible variable.  Several such cases will be discussed below. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ SolutionItemReference sr = o as SolutionItemReference; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (path == sr.path) &amp;&amp; (id == sr.id); }</code> </pre> <br>  Analyzer warning: <a href="http://www.viva64.com/ru/d/0388/">V3019</a> Possibly incorrect variable is compared to null after type conversion using 'as' keyword.  Check variables 'o', 'sr'.  MonoDevelop.Core SolutionItemReference.cs 81 <br><br>  This code coerces the variable 'o' of type 'object' to the type of 'SolutionItemReference'.  If such a cast fails, the value 'null' will be written to the variable 'sr'.  As a result, the test 'o == null' will pass successfully (of course, if 'o' is not 'null'), and when checking 'path == sr.path', an exception of the type 'NullReferenceException' will be generated.  All of this could have been avoided by checking the correct variable in the appropriate place: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sr == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Another example of this code: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTokenSelectionChanged</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object sender, EventArgs args)</span></span></span><span class="hljs-function"> </span></span>{ TreeSelection selection = sender as TreeSelection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sender != null) { TreeIter iter; TreeModel model = (TreeModel)tokensStore; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selection.GetSelected (out model, out iter)) { entryToken.Text = (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)tokensStore.GetValue (iter, <span class="hljs-number"><span class="hljs-number">0</span></span>); comboPriority.Active = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)tokensStore.GetValue (iter, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { entryToken.Text = String.Empty; comboPriority.Active = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)TaskPriority.Normal; } } }</code> </pre> <br>  Analyzer warning: <a href="http://www.viva64.com/ru/d/0388/">V3019</a> Possibly incorrect variable is compared to null after type conversion using 'as' keyword.  Check variables 'sender', 'selection'.  MonoDevelop.Ide TasksOptionsPanel.cs 123 <br><br>  The situation is exactly the same as the previous one.  After casting 'sender' to 'TreeSelection' to 'null', the wrong variable is checked, which makes it possible to get a 'NullReferenceException'. <br><br>  Similar code examples with the same error patterns were met 2 more times: <ul><li>  <a href="http://www.viva64.com/ru/d/0388/">V3019</a> Possibly incorrectly variable conversion compared to null after type conversion using 'as' keyword.  Check variables 'data', 'urlMarker'.  MonoDevelop.SourceEditor MarkerOperationsHandler.cs 43 </li><li>  <a href="http://www.viva64.com/ru/d/0388/">V3019</a> Possibly incorrectly variable conversion compared to null after type conversion using 'as' keyword.  Check variables 'symbol', 'method'.  CSharpBinding FormatStringHelper.cs 59 </li></ul><br><br><h3>  Repetitive checks for similar conditions. </h3><br>  There are cases when the same condition is checked twice, while the variables used in these expressions do not change between them.  This mistake can lead to much more serious consequences than it seems at first glance.  Which ones are better to look at with real examples. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitIndexerExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IndexerExpression indexerExpression)</span></span></span><span class="hljs-function"> </span></span>{ .... var localResolveResult = context.Resolve(indexerExpression.Target) as LocalResolveResult; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (localResolveResult == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; var resolveResult = context.Resolve(indexerExpression); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (localResolveResult == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0390/">V3021</a> There are two 'if' statements with identical conditional expressions.  The first 'if' statement contains method return.  ICSharpCode.NRefactory.CSharp.Refactoring ParameterCanBeDeclaredWithBaseTypeIssue.cs 356 <br><br>  From this code snippet, it is clearly seen that instead of the 'resolveResult == null' check, the 'localResolveResult == null' check is performed twice.  This is clearly seen from the cut out code snippet.  Whether it would also be easy to find this error by looking at the code that includes, in addition to this fragment, the main logic to the method (it is not given here, so as not to stretch the example) - a big question.  In any case, instead of exiting the method if the 'resolveResult' is equal to 'null', we successfully continue the work, which means that all subsequent logic using the 'resolveResult' flies to Tartar. <br><br>  Here is another example of such a mistake: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryRemoveTransparentIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> nae1Name = ExtractExpressionName(ref nae1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nae1Name == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> nae2Name = ExtractExpressionName(ref nae2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nae1Name == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... }</code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0390/">V3021</a> There are two 'if' statements with identical conditional expressions.  The first 'if' statement contains method return.  ICSharpCode.NRefactory.CSharp CombineQueryExpressions.cs 114 <br><br>  Again, due to the fact that the variable was mixed up for verification, the loop will not exit and the correct value will be returned, and the subsequent logic of the method will be violated. <br><br>  But a more interesting example, however, containing the same error: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> SW.<span class="hljs-function"><span class="hljs-function">FontWeight </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToWpfFontWeight</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FontWeight value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == FontWeight.Thin) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SW.FontWeights.Thin; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == FontWeight.Ultralight) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SW.FontWeights.UltraLight; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == FontWeight.Light) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SW.FontWeights.Light; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == FontWeight.Semilight) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SW.FontWeights.Light; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == FontWeight.Book) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SW.FontWeights.Normal; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == FontWeight.Medium) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SW.FontWeights.Medium; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == FontWeight.Semibold) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SW.FontWeights.SemiBold; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == FontWeight.Bold) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SW.FontWeights.Bold; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == FontWeight.Ultrabold) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SW.FontWeights.UltraBold; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == FontWeight.Heavy) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SW.FontWeights.Black; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == FontWeight.Ultraheavy) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SW.FontWeights.UltraBlack; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SW.FontWeights.Normal; }</code> </pre> <br>  Well, found?  Just kidding, you can only poke a finger into the sky.  But for the analyzer there is no problem, and he calmly coped with the task. <br><br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0390/">V3021</a> There are two 'if' statements with identical conditional expressions.  The first 'if' statement contains method return.  If this statement is a senseless Xwt.WPF DataConverter.cs 217 <br><br>  In order to better understand what the problem is, you need to look at the FontWeight enumeration. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> FontWeight { <span class="hljs-comment"><span class="hljs-comment">/// The thin weight (100) Thin = 100, /// The ultra light weight (200) Ultralight = 200, /// The light weight (300) Light = 300, /// The semi light weight (350) Semilight = 350, /// The book weight (380) Book = 350, .... }</span></span></code> </pre> <br>  The constants 'Semilight' and 'Book' have the same values, although it is clearly seen from the comments that the 'Book' constant should be 380. <br><br>  What is more interesting - if the value of 'value' is equal to 380 - this method will still work correctly!  In this case, none of the listed conditions will be fulfilled, and therefore - just the value that would be returned if the 'value == FontWeight.Book' condition is met.  "Not a bug, but a feature" <br><br>  Well, at the end of this section: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TransferDataType type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == TransferDataType.Text) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clipboard.WaitForText (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == TransferDataType.Text) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clipboard.WaitForImage (); .... }</code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0390/">V3021</a> There are two 'if' statements with identical conditional expressions.  The first 'if' statement contains method return.  This means that the statement is a senseless Xwt.Gtk ClipboardBackend.cs 86 <br><br>  In this code snippet it is easy to notice a typo.  Instead of repeating the 'type == TransferDataType.Text' check, it was necessary to perform the 'type == TransferDataType.Image' check. <br><br><h3>  Check for conflicting conditions </h3><br>  There is a code when within the same expression the same variable is checked for equality / inequality to some value.  Such checks are at least redundant, and perhaps even contain an error related to the fact that the value of the wrong variable is checked a second time.  Such errors were also found in the project. <br><pre> <code class="cpp hljs">IEnumerable&lt;ICompletionData&gt; CreateConstructorCompletionData(IType hintType) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(hintType.Kind == TypeKind.Interface &amp;&amp; hintType.Kind != TypeKind.Array)) .... }</code> </pre> <br>  Analyzer Warning: Consider inspecting this expression <a href="http://www.viva64.com/ru/d/0411/">V3023</a> .  The expression is misprint.  ICSharpCode.NRefactory.CSharp CSharpCompletionEngine.cs 2397 <br><br>  Judging by the environment of the code, it is simply overcomplicated with checking the expression.  It is not clear what this complication is for, since all this condition could be simplified to the following code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hintType.Kind != TypeKind.Interface)</code> </pre> <br>  A similar case: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdateClicked</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object s, StatusBarIconClickedEventArgs args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.Button != Xwt.PointerButton.Right &amp;&amp; args.Button == Xwt.PointerButton.Left) { HideAlert (); AddinManagerWindow.Run (IdeApp.Workbench.RootWindow); } }</code> </pre> <br>  Analyzer Warning: Consider inspecting this expression <a href="http://www.viva64.com/ru/d/0411/">V3023</a> .  The expression is misprint.  MonoDevelop.Ide AddinsUpdateHandler.cs 97 <br><br>  This code fragment shows that it was not intended to use other variables for comparison, but, nevertheless, there is a redundant comparison.  There is no additional logic on the 'Button' property, therefore, there are no ‚Äúpitfalls‚Äù when reading it.  Again, the code is easily simplified: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.Button == Xwt.PointerButton.Left)</code> </pre> <br><br><h3>  Incorrectly formatted strings </h3><br>  Often there is a code that contains errors in the format strings.  As a rule, such errors are of two types: <ul><li>  The number of expected arguments is less than the number of actual arguments.  In this case, unused arguments will simply be ignored.  Such an error may be a sign that the string is constructed incorrectly, otherwise - why is there an unused argument in it?  It is possible that he remained as a result of refactoring. </li><li>  The number of expected arguments is greater than the actual number.  A more annoying case, since an exception of type 'FormatException' will be generated. </li></ul><br>  In this project, only errors of the first type were encountered.  An example of one of them: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ConditionExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseReferenceExpression</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prefix)</span></span></span><span class="hljs-function"> </span></span>{ StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder (); <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ref_type = prefix [<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'$'</span></span> ? <span class="hljs-string"><span class="hljs-string">"a property"</span></span> : <span class="hljs-string"><span class="hljs-string">"an item list"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> token_pos = tokenizer.Token.Position; IsAtToken (TokenType.LeftParen, String.Format ( <span class="hljs-string"><span class="hljs-string">"Expected {0} at position {1} in condition \"{2}\". Missing opening parantheses after the '{3}'."</span></span>, ref_type, token_pos, conditionStr, prefix)); .... IsAtToken (TokenType.RightParen, String.Format ( <span class="hljs-string"><span class="hljs-string">"Expected {0} at position {1} in condition \"{2}\". Missing closing parantheses'."</span></span>, ref_type, token_pos, conditionStr, prefix)); .... }</code> </pre> <br>  Analyzer warning: <a href="http://www.viva64.com/ru/d/0392/">V3025</a> Incorrect format.  A different number of formatted items is expected while calling 'Format' function.  Expected: 3. Present: 4. MonoDevelop.Core ConditionParser.cs 254 <br><br>  Most likely, this error was the result of an unsuccessful 'copy-paste', since the second call to the 'IsAtToken' method is similar to the first, the only difference is that it concerns the closing bracket.  However, the 'prefix' argument is not used in any way.  Not critical, but there is no sense from it either. <br><br>  Similar warnings: <ul><li>  V3025 Incorrect format.  A different number of formatted items is expected while calling 'Format' function.  Expected: 1. Present: 2. MonoDevelop.Xml XmlFormatterWriter.cs 1131; </li><li>  V3025 Incorrect format.  A different number of formatted items is expected while calling 'Format' function.  Expected: 4. Present: 6. ICSharpCode.NRefactory.CSharp MonoSymbolTable.cs 235 </li><li>  V3025 Incorrect format.  A different number of formatted items is expected while calling 'Format' function.  Expected: 1. Present: 2. MonoDevelop.Ide HelpOperations.cs 212 </li><li>  V3025 Incorrect format.  A different number of formatted items is expected while calling 'Format' function.  Expected: 4. Present: 6. Mono.Cecil.Mdb MonoSymbolTable.cs 235 </li><li>  V3025 Incorrect format.  A different number of formatted items is expected while calling 'Format' function.  Expected: 2. Present: 3. MonoDevelop.TextEditor.Tests ViTests.cs 255 </li></ul><br><h3>  Potential dereference of the null reference </h3><br>  Often it is necessary to check the variables for equality of 'null', especially if this variable is the argument of the method, the result of its work, was obtained using the 'as' operator.     ,        'null',   , , ,        ,     'NullReferenceException'. <br><br>   ,   -        .     . <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Replace</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RedBlackTreeNode oldNode, RedBlackTreeNode newNode)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldNode.parent.left == oldNode || oldNode == null &amp;&amp; oldNode.parent.left == null) .... }</code> </pre> <br>  : <a href="http://www.viva64.com/ru/d/0414/">V3027</a> The variable 'oldNode' was utilized in the logical expression before it was verified against null in the same logical expression. MonoDevelop.HexEditor RedBlackTree.cs 167 <br><br>    ,  -   'oldNode.parent.left'     'oldNode',          'null'.   'oldNode'     'null',         'NullReferenceException'.             'null'. <br><br><h2>  Conclusion </h2><br>      ,       .          .      ,      ,       . <br><br> -  ,            .     ,       ,                  ,         ,       . <br><br><h2>   C#- </h2><br> ,        C#-    .  ,          ,            . <ul><li> <a href="http://www.viva64.com/ru/b/0365/">  .NET Core Libraries (CoreFX)</a> ; </li><li> <a href="http://www.viva64.com/ru/b/0363/">  PVS-Studio 6.00:  Roslyn</a> ; </li><li> <a href="http://www.viva64.com/ru/b/0361/"> Microsoft Code Contracts</a> ; </li><li> <a href="http://www.viva64.com/ru/b/0359/">  PVS-Studio,  C# ( SharpDevelop)</a> ; </li><li> <a href="http://www.viva64.com/ru/b/0357/">    C#  ( Umbraco)</a> . </li></ul><br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0366/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Sergey Vasiliev. <a href="http://www.viva64.com/en/b/0366/">Looking for Bugs in MonoDevelop</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/274321/">https://habr.com/ru/post/274321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274311/index.html">Materials from Azov Developers Meetup 2015</a></li>
<li><a href="../274313/index.html">Compare incomparable: json in PostgreSQL vs Mysql vs Mongodb</a></li>
<li><a href="../274315/index.html">JOIN the dark side of the SQL</a></li>
<li><a href="../274317/index.html">Sinon.js - mock-library for JavaScript</a></li>
<li><a href="../274319/index.html">How to migrate to Oracle Java Cloud in 1.5 hours?</a></li>
<li><a href="../274323/index.html">An example of the implementation of methods for processing and recognition of images on Android</a></li>
<li><a href="../274325/index.html">Mobile Applications and PA-DSS</a></li>
<li><a href="../274327/index.html">Useful add-ons to ReSharper</a></li>
<li><a href="../274329/index.html">Printf Oriented Programming</a></li>
<li><a href="../274333/index.html">How to create a convincing mechanics of death and not screw it up</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>