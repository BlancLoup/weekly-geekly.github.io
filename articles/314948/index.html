<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lock-free data structures. Iterators: multi-level array</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous parts of the opus ( 1 , 2 , 3 ) we looked at the internal structure of the lock-free map and made sure that all the basic operations ‚Äî...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lock-free data structures. Iterators: multi-level array</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/c0f/d71/599/c0fd7159978d428b99fe8b5748e943e2.png" align="right">  In the previous parts of the opus ( <a href="https://habrahabr.ru/post/250383/">1</a> , <a href="https://habrahabr.ru/post/250523/">2</a> , <a href="https://habrahabr.ru/post/250815/">3</a> ) we looked at the internal structure of the lock-free map and made sure that all the basic operations ‚Äî finding, adding and deleting a key ‚Äî can be performed without global locks and even in a lock-free manner.  But the standard <code>std::map</code> supports another very useful abstraction - iterators.  Is it possible to implement an iterable lock-free map? <br>  The answer to this question - under the cut. <br><a name="habracut"></a><br>  A year ago, I was sure that iterators in principle are not realizable for lock-free containers.  Judge for yourself: the iterator allows you to bypass all the elements of the container;  but in the world of lock-free, the contents of the container are constantly changing, what should be considered as ‚Äúbypassing all the elements‚Äù? <br><br><img src="https://habrastorage.org/files/eef/10b/1e8/eef10b1e8bf84cf381e63a7f8678ef1d.png"><br><br>  Iteration ‚Äî traversing the elements of a container ‚Äî takes some time, during which some elements will be removed from the container, others added, but there must be some subset of stable (possibly empty) elements that are present in the container during the entire traversal period - from <code>list.begin()</code> to <code>list.end()</code> .  In addition to them, we can visit some of the added elements, like some of the deleted ones, as the map will fall.  Obviously, the task to visit <i>all the</i> elements in the lock-free map is impossible, we cannot freeze the state of our container for the whole duration of the tour;  such a freeze actually means prohibiting other threads from performing modifying operations on the container, which is tantamount to blocking. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Controversial statement</b> <div class="spoiler_text">  In fact, there are techniques of ‚Äúfreezing‚Äù the state of a competitive container that do not prevent the rest of the streams from changing the container ‚Äî adding / deleting its elements.  Perhaps the most famous of these techniques is version trees.  The bottom line is that several versions of the container are stored in the same tree.  Each addition to such a tree creates another version - a tree with its own root, which shares (shared) with the other versions (trees) unchangeable nodes.  The consumer of the version tree takes the latest version of the tree (the freshest root), and while he is working with the tree, this version remains in the tree.  As soon as no consumer thread becomes associated with a version ‚Äî the version (that is, all nodes belonging only to this version) can be safely removed. <br>  Other equipment - competitive containers with snapshot support (container snapshots).  In some ways, it is similar to version containers. <br><br>  Both of these techniques imply increased memory consumption for storing versions or snapshots, as well as additional operations to support its internal structure.  Often, this overspending is insignificant compared to the benefits that provide such technology. <br>  In this article I want to consider competitive associative containers without the use of such techniques.  That is, the question is: is it possible to build such a competitive container, which by its very internal structure allows for a safe bypass of the elements? <br></div></div><br>  So, we will consider as a bypass of a competitive container a guaranteed visit to all nodes from the stable subset. <br><br>  In addition to the question "what is considered a bypass of a competitive container," there are two problems: <br><br>  <u><b>Problem 1</b></u> .  An iterator is essentially a specialized pointer to a container element.  Using an iterator, we access the element itself.  But in a competitive container, the element on which the iterator is positioned can be deleted at any time.  That is, an iterator can become invalid at any time, pointing to a deleted item, that is, to garbage: <br><br><img src="https://habrastorage.org/files/75c/486/2ba/75c4862ba52e4e43bad900b9407eed8c.png"><br><br>  The solution to this problem in the <a href="https://habrahabr.ru/post/202190/">Hazard Pointer</a> scheme is the hazard pointer itself.  Recall that the HP schema ensures that while the pointer is declared as hazard, it (the pointer) cannot be physically removed, that is, it cannot turn into garbage.  We introduce the following useful abstraction ‚Äî the <code>guarded_ptr</code> protected pointer: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;typename T&gt; struct guarded_ptr { hp_guard hp; //   T * ptr; //   guarded_ptr(std::atomic&lt;T *&gt;&amp; p) { ptr = hp.protect( p ); } ~guarded_ptr() { hp.clear(); } T * <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -&gt;() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; } explicit <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>() const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr != nullptr; } };</code> </pre><br>  As you can see, <code>guarded_ptr</code> is just a pointer with a hazard pointer.  Hazard pointer <code>hp</code> protects the pointer to the <code>ptr</code> element, preventing its physical removal.  Now, even if a stream B deletes the element to which the iterator is positioned, this element will be excluded from the container, but not physically deleted until the iterator's hazard pointer contains a link to this element. <br><br>  Thus, in the HP schema, the iterator class will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> guarded_ptr&lt;T&gt; gp; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gp.ptr; } T&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> *() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *gp.ptr; } iterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(); };</code> </pre><br><div class="spoiler">  <b class="spoiler_title">epoch-based</b> <div class="spoiler_text">  In the epoch-based scheme (a variation of which is <a href="https://habrahabr.ru/post/206984/">user-space RCU</a> ), there is no need for <code>guarded_ptr</code> , it is enough to require that the iteration (bypassing all container elements) be performed in one epoch: <br><br><pre> <code class="cpp hljs">urcu.lock(); <span class="hljs-comment"><span class="hljs-comment">//    for ( auto it = m.begin(); it != m.end(); ++it ) { // ... } urcu.unlock(); //   </span></span></code> </pre><br></div></div><br>  <b><u>Problem 2</u></b> : move to the next item. <br><br><img src="https://habrastorage.org/files/a25/f88/7bc/a25f887bc4b0488aa47806affcd13788.png"><br><br>  If a thread B removes the element following the one on which the iterator is positioned - in this case 42, - the incrementing operation of the iterator will result in a call to the deleted element, that is, garbage. <br><br>  This problem is more complicated than the first one, since the threads do not know that we are going around the container and are free to remove / add any elements.  You can think of somehow marking the element pointed to by the iterator and analyzing such a flag when deleting an element, but this at least complicates the internal structure of the container (and as a maximum, such reasoning will not lead to anything).  There is another way that an interesting data structure tells us - the multi-level array. <br><br><h2>  Multi-level array </h2><br>  This data structure was <a href="http://samos-conference.com/Resources_Samos_Websites/Proceedings_Repository_SAMOS/2013/Files/2013-IC-20.pdf">proposed</a> in 2013 by Steve Feldman and is an associative container, that is, a hash map. <br><br><img src="https://habrastorage.org/files/ad7/377/b32/ad7377b32dce4028b06310bae4104d88.png"><br><br>  Imagine that a hash is a bit string of constant length.  We will consider the bits of this string as indices in a multilevel array: the first M bits is the index in the head array head array (in the figure M = 4, that is, the size of the head array is 2 ** 4 = 16), the next portions of N bits are indices in the underlying arrays of the node array (in the figure, N = 2 and the dimension of the node array is 2 ** 2 = 4).  The array element can be: <br><br><ul><li>  is empty </li><li>  data pointer </li><li>  pointer to the next level array </li></ul><br>  An empty multi-level array consists only of the head array, in which all cells are empty. <br><br>  Adding data <code>data</code> with the key <code>key</code> to the multi-level array occurs according to the following algorithm: <br><br><ul><li>  1. calculate the hash key <code>h = hash( key )</code> </li><li>  2. Take the first M bits of the hash <code>h</code> - this is the index <code>i</code> cell in the head array </li><li>  3a.  If the cell is empty ( <code>head_array[i] == nullptr</code> ), then put the data in it: <code>head_array[i].CAS( nullptr, &amp;data )</code> - and exit.  Since we have a lock-free container, we use atomic operations, in this case CAS (compare-and-swap, in terms of C ++ 11 is <code>std::compare_exchange</code> ). </li><li>  3b.  If the cell contains data ( <code>head_array[i] = di</code> ), you need to split it, that is, create a node array of the next level, put <code>di</code> in it and go to step 4. </li><li>  3c.  If the cell contains a pointer to the underlying node array - go to step 4. </li><li>  4. The current array is a certain node array.  Take the next N bits of the key hash <code>h</code> , these bits will be the index <code>i</code> in the current node array.  If all the bits of the hash are exhausted, this means that there is already an element in the container with the same hash and the insertion of the data <code>data</code> ends in failure. </li><li>  4a.  If the cell is empty ( <code>current_node_array[i] == nullptr</code> ), then put the data in it: <code>current_node_array[i].CAS( nullptr, &amp;data )</code> - and exit </li><li>  4b.  If the cell contains data ( <code>current_node_array[i] = di</code> ), you need to split it, that is, create the next level node array, put <code>di</code> in it and go to step 4. </li><li>  4c.  If the cell contains a pointer to the underlying node array - go to step 4. </li></ul><br>  As you can see, the insertion algorithm is very simple and intuitive - it is easier to draw than to describe it.  The deletion algorithm is even simpler: considering the hash value of the key to be deleted as a bit string, selecting bits and interpreting them as indices in arrays, we go down the links to an array whose cell is either empty or contains data.  If the cell is empty, it means that our key (more precisely, its hash) is not in the container and there is nothing to delete.  If the cell contains data and the key of this data is the required key, change the value of the cell to <code>nullptr</code> using the atomic CAS operation.  Note that when deleting, we simply reset the array cell, the node_array itself will never be deleted, this fact will be useful to us in the future. <br><br>  The question remains: how to distinguish what the cell of the array contains ‚Äî data or a pointer to the next level array.  In normal programming, we would put a boolean attribute in each slot of the array: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array_slot</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { T* data; node_array* <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_array; <span class="hljs-comment"><span class="hljs-comment">// ,    ‚Äî data  array };</span></span></code> </pre><br>  But our programming is unusual, and this approach will not suit us.  The unusual thing is that we have to operate with the atomic primitive CAS, which has a limit on the length of the data.  That is, we must be able to change the value of the cell and the <code>is_array</code> attribute atomically, with a single CAS. <br>  This is not a problem if you read the <a href="https://habrahabr.ru/post/250383/">previous</a> part of the lock-free epic and know that there is such a thing as a <i>marked pointer</i> .  We will store the <code>is_array</code> in the <code>is_array</code> bit of the array cell pointer: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> array_slot = marked_ptr&lt;T*, <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;;</code> </pre><br>  Thus, an array cell is just a pointer, in which we use the last 2 bits ( <code>marked_ptr</code> mask 3) for internal flags: one bit for the ‚Äúcell contains a pointer to the next level array‚Äù flag, plus one more bit for ... and for what ? .. <br><br>  Let's look carefully at the insertion algorithm.  Steps 3b and 4b speak of splitting a cell, that is, turning it from a cell containing data into a cell containing a pointer to the underlying array.  Such a transformation is quite long, as it requires: <br><br><ul><li>  create a new node_array; </li><li>  zeroing all its elements; </li><li>  finding a position in the new node_array for the split cell data; </li><li>  writing to the new node_array in the found position of the split cell data; </li><li>  and finally, setting a new split cell value </li></ul><br>  As long as all these actions are performed, the split cell is in an undefined state.  This is the state we encode the second low-order bit.  All operations on the multi-level array, having met the ‚Äúcell splitting‚Äù flag, wait for the end of splitting of such a cell using active waiting (spinning) on ‚Äã‚Äãthis flag: <br><br><img src="https://habrastorage.org/files/803/7c1/23f/8037c123f23041a6a44c2c0c5ef252d8.png"><br>  <i>in the figure, the black data is the added key <code>Dn</code> , the blue ones is the existing <code>D</code></i> <br><br><div class="spoiler">  <b class="spoiler_title">Field notes - quantum mechanics of lock-free containers</b> <div class="spoiler_text">  While I was writing all this about a split cell, the thought came: does this flag really need to, since it causes all other streams to spinning on it, including the search operation, which should be the fastest for containers set / map ?. . <br><br>  Consider the operations.  In general, the map supports only three operations (the rest is their types): search, insert and delete a key.  For the search, the fact that the cell is in the splitting stage is completely unimportant: the search should look at what kind of cell it is;  if the cell contains a pointer to the data - you need to compare the data key with the desired one (since we came up against the data cell, then the prefix of the bit string ‚Äî the hash of the desired key and the data in the cell ‚Äî is the same and the data in the cell can be the required one).  If the cell is a pointer to an array, we just need to go to this array and continue the search in it.  Suppose that the key you are looking for is exactly the data for which the cell splits, that is, we have a situation: one stream searches for the key K, another stream adds data with the same key K, and this happens simultaneously.  Once this happens at the same time, the search operation will be correct both in the case of ‚Äúkey found‚Äù and in the case of ‚Äúkey not found‚Äù.  It turns out that the splitting flag is not needed for the search operation. <br><br>  Insert operation  If the insert stumbles upon a split cell, then another thread adds data with the key hash value prefix the same as the current thread.  In this case, both streams (both insert operations) could ‚Äúhelp‚Äù each other by creating each node_array and trying to set it as the value of the split cell.  Since the cell value is set by the CAS primitive, and node_array are never deleted (i.e. there are no ABA problems for pointers to node_array), only one of the insertion threads wins (sets a new split cell value), the second stream will detect that the cell value changed and you need to remove the node_array, which he (this second stream) is trying to create, and use the value of the split cell that appeared.  That is, to insert a splitting flag is also not needed. <br><br>  Uninstall.  Before deleting, you need to find what you want to delete, that is, deletion in this sense is equivalent to searching and the splitting flag is not needed. <br><br>  The only operation you need to think about is update, updating data. <br><br>  If the cell splitting flag sets a low-priority flow, and then it is preempted, it can be very painful for the overall performance of the container, since the other higher-priority flows will wait until the splitting is completed, that is, wait for the low-priority flow to do its work.  In this case, getting rid of the splitting flag can be very useful. <br></div></div><br>  The multi-level array data structure is simple and interesting, but its features (I wanted to write "flaws", but these are still features) are: <br><br><ul><li>  it requires perfect hashing.  <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">The ideal hash function</a> is such a hash function <code>h</code> , which for any keys <code>k1</code> and <code>k2</code> such that <code>k1 != k2</code> , gives different hash values: <code>h(k1)!= h(k2)</code> .  That is, the multi-level array does not allow collisions. </li><li>  keys (or key hash values) of different sizes are not supported.  That is, a variable-length <code>std::string</code> key cannot be used as a bit string. </li></ul><br>  But if your key is of a constant size (or you have an ideal hash function), the multi-level array is a very good lock-free container, IMHO. <br><br>  In principle, it is possible to generalize the multi-level array so that it supports collision lists: it‚Äôs enough to use the lock-free list as a collision list instead of data.  Another generalization for keys of variable length: assume that all other bits in the bit string of a short key are zero. <br><br><div class="spoiler">  <b class="spoiler_title">Further fantasies</b> <div class="spoiler_text">  It is also interesting to replace the word ‚Äúkey‚Äù with the word ‚Äúindex‚Äù - in this case we will get something very similar to the lock-free vector.  The <code>push_back</code> and <code>pop_back</code> can be done by storing the current size of the array in a separate atomic variable.  But if two threads simultaneously <code>push_back</code> situation is possible when a hole appears in the array for a while: thread A increments the counter, gets index <code>j</code> and is pushed out, and thread B gets index <code>j+1</code> and successfully inserts at that index.  Here, the 2-CAS operation (or its generalization ‚Äî multi-CAS, MCAS), which can atomically perform CAS on two (or M) unrelated memory cells, would help us. <br></div></div><br>  But for the purposes of this article, one property of the multi-level array is important: the once-created node array is never deleted.  And this implies a powerful consequence: the <i>multi-level array supports thread-safe iterators</i> , moreover, these are bidirectional iterators.  In fact, since node arrays are not deleted, the iterator is a pointer to the node array plus an index to the node array, which is a ‚Äúpointer‚Äù to the cell: <br><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">guarded_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gp_</span></span></span><span class="hljs-class">;</span></span> node_array* node<span class="hljs-number"><span class="hljs-number">_</span></span>; int node_index<span class="hljs-number"><span class="hljs-number">_</span></span>; };</code> </pre><br>  <code>guarded_ptr</code> is required here, since the concurrent flow can delete data for which the iterator is positioned;  <code>guarded_ptr</code> prevents physical removal.  It turns out that the iterator can point to an element that is removed from the container - another unexpected property of the lock-free data structures.  But if you think well, this property is quite explicable: in an ever-changing world that competitive containers are, only one thing can be guaranteed: at the time of iterator positioning, this cell contained valid data. <br>  The <code>node_</code> pointer to node_array and its index <code>node_index_</code> necessary in the iterator to go to the next (or previous) element of the container, that is, they actually determine the current position of the iterator in the container. <br><br>  It is interesting to note that if we have keys of constant size, and not hash values, then the bypass of the multi-level array is ordered. <br><br><div class="spoiler">  <b class="spoiler_title">Commercial break</b> <div class="spoiler_text">  If you are interested in implementation details, you can see them in <a href="https://github.com/khizmax/libcds">libcds</a> , class FeldmanHashSet / Map (the main operations here are <code>cds/intrusive/impl/feldman_hashset.h</code> for HP-based SMR, <code>cds/intrusive/feldman_hashset_rcu.h</code> - for user-space RCU) . <br></div></div><br><img src="https://habrastorage.org/files/201/b28/9c4/201b289c4f6d40ca9f713a6fea6cf05e.png" align="left">  Summarizing, we can say: there are still competitive containers that support thread-safe iterators, one of such containers is a multi-level array.  Are there others? .. Is it possible to create an iterable lock-free list, which is the basis for many interesting lock-free map? .. <br><br>  The answer to this question is in the next article. <br><br><div class="spoiler">  <b class="spoiler_title">Lock-free data structures</b> <div class="spoiler_text">  <a href="http://habrahabr.ru/company/ifree/blog/195770/">Start</a> <br>  Basics: <br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/195948/">Atomicity and atomic primitives</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/196548/">Where did the memory barriers go from</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/197520/">Memory model</a> </li></ul><br>  Inside: <br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/202190/">Memory management circuits</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/206984/">RCU</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/216013/">Stack evolution</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/219201/">Another treatise</a> </li><li>  <a href="http://habrahabr.ru/post/230349/">Queue dissection</a> </li><li>  <a href="http://habrahabr.ru/post/250383/">Concurrent maps: warm up</a> </li><li>  <a href="http://habrahabr.ru/post/250523/">Concurrent maps: rehash, no rebuild</a> </li><li>  <a href="http://habrahabr.ru/post/250815/">Concurrent maps: skip list</a> </li><li>  <a href="https://habrahabr.ru/post/251267/">Concurent maps: trees</a> </li><li>  <a href="https://habrahabr.ru/post/314948/">Iterators: multi-level array</a> </li><li>  <a href="https://habrahabr.ru/post/317882/">Iterable list</a> </li></ul><br>  Outside: <br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/196834/">Introduction to libcds</a> </li></ul><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/314948/">https://habr.com/ru/post/314948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314934/index.html">Deep Learning: Transfer learning and fine tuning of deep convolutional neural networks</a></li>
<li><a href="../314938/index.html">Data Center Infrastructure Management: Choosing the Optimal DCIM Solution</a></li>
<li><a href="../314940/index.html">Donald Knut about his happy life, his death and the last two projects</a></li>
<li><a href="../314942/index.html">Welcome to Moscow Data Science Meetup November 25</a></li>
<li><a href="../314944/index.html">6 common mistakes when concluding software development contracts</a></li>
<li><a href="../314950/index.html">How to conduct the ‚ÄúHour Code‚Äù: Kazakhstan experience</a></li>
<li><a href="../314952/index.html">Why the ‚Äúmotivating‚Äù articles do not work, do not work and how the motivation really works</a></li>
<li><a href="../314954/index.html">Automated testing of Redmine plugins</a></li>
<li><a href="../314956/index.html">NIST recommends: building blocks for describing IoT</a></li>
<li><a href="../314958/index.html">Rover, Landing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>