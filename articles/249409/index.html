<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reverse engineering of Parktronic protocol. Dance of little bits</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 In an attempt to reduce all the vital performance of your car on one screen of the head unit, it was the turn to connect the parking sens...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reverse engineering of Parktronic protocol. Dance of little bits</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  In an attempt to reduce all the <s>vital</s> performance of your car on one screen of the head unit, it was the turn to connect the parking sensors.  Many will argue - even cheap PDCs have their own screen, why output the data somewhere else?  Yes, just do not want to put an extra screen in the cabin, and there is a reason to dig in the gland ... <br><br>  In this article I will try to describe the techniques and tools for reverse engineering of an undocumented protocol for the exchange of two pieces of iron between each other. <br><a name="habracut"></a><br>  From the content of <a href="http://www.mp3car.com/hardware-development/121995-custom-usb-parking-sensor-interface-formally-pdc-usb.html">some publications</a> , it seems that, firstly, it is worth choosing parking sensors with a radio channel between the main unit and the screen, and secondly, nothing complicated in the exchange protocols is expected.  Hmm ... well, yes.  It turned out to be half true. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The presence of a radio channel between the main unit and the ‚Äúdisplay unit‚Äù suggests that the exchange protocol between them will be simple and consistent with the transfer of the measured distances in an explicit form.  If the screen would cling directly, then, most likely, all the logic would be implemented in one chip and commands like ‚Äúlight this pixel / segment and go out the same‚Äù would go to the screen, without being able to get the measured distances directly.  Okay.  Inspired, we go to the ‚Äúlargest cybermarket‚Äù and buy the cheapest set of parking sensors with airplanes in the logo.  Bought, and then it began ... <br><br><h4>  Step one.  Opening and reading sent data </h4><br>  To begin, we will determine the method of data transmission over the air.  <a href="http://www.adsean.com/dl/saw5035.pdf">Having opened the</a> main unit, we find there a round chip <a href="http://www.adsean.com/dl/saw5035.pdf">R433A</a> with a completely standard strapping.  There is no receiver in the main unit, therefore, the data transmission channel is one-way, with the only possible <a href="http://en.wikipedia.org/wiki/On-off_keying">modulation</a> for R433 <a href="http://en.wikipedia.org/wiki/On-off_keying">OOK</a> .  Those.  If there is a high level of digital signal (logical ‚Äúone‚Äù), the transmitter broadcasts a carrier at 433.92 MHz.  In the absence of a high level - the transmitter is silent.  On the receiver side, decoding occurs in a similar way in the display unit: if the receiver sees the carrier, it gives a high level, if it does not, it gives a low one.  Yes, the receiver also perfectly catches all the interference <s>from the parking sensors of the neighbor</s> , so its sensitivity is greatly underestimated.  And, as a rule, a checksum is added to the transmitted data (this fact is still useful to us below). <br><br>  We will need a digital oscilloscope recorder (simple USB oscilloscopes, such as DiSco, are convenient).  We find the path that goes from the main microcontroller of the ‚Äúbrains‚Äù to the transmitter in the main unit or from the receiver to the microcontroller in the display unit, find any ‚Äúminus‚Äù track, solder wires to them, connect an oscilloscope, look: <br><br><img src="https://habrastorage.org/files/f5c/acf/513/f5cacf5137df4a23b63544dcabbbe833.png"><br><br>  This repetitive package sends the main unit immediately when power is applied.  With careful consideration, it is possible to make an <s>extremely non-obvious</s> conclusion that the premise consists of three parts: <br><br><ul><li>  The first part is obviously some kind of synchronization to ‚Äúwake up‚Äù the receiver and the chip in the display unit.  It consists of five pulses of 0.4 ms each with pauses of 0.4 ms and a single pulse of 1 ms duration with a 2 ms pause.  Remember the information about the duration, it is useful for implementing your own decoder. </li><li>  The second and third parts are directly data encoded in 16 pulses of different widths in each part (plus another 0.4 ms pulse at the very end). </li></ul><br>  Find out how the bits are coded in the second and third parts.  The alternation of wide and narrow pulses is similar to the <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25B7%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25B4%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">Manchester code</a> , which is used, in particular, on Ethernet networks.  But Manchester‚Äôs two broad impulses cannot be separated by narrow ones.  Therefore, noting that a wide pause always follows a narrow ‚Äúpause‚Äù and vice versa (with a total pulse duration + pause = 1 ms), suppose a simpler one ‚Äî the pulse width directly encodes a logical unit (narrow pulse) or zero (wide pulse). <br><br><h4>  Step two.  Pen decoding </h4><br>  So, we have 32 bits of data and 4 sensors.  It is logical to assume that 8 bits are allocated to each sensor, plus, probably, a checksum (we still remember the checksum!).  And we need to understand how distance to obstacles is encoded in these bits and so on.  To begin with, turn off all sensors and manually write the resulting bit sequence from the oscilloscope readings: <br><br>  10011100 10011100 10011101 01000100 <br><br>  hmm ... it is clear that nothing is clear.  In the absence of sensors, it would be logical to receive all ones or all zeros.  Nothing like this here.  We connect sensor A, sending it to the void (readings - "infinity"): <br><br>  10011100 10011100 10010011 01001100 <br><br>  changed the last two bytes.  In the 4th byte 1 bit changed.  Apparently, it is he who shows the presence of sensor A?  And in the 3rd byte 3 bits changed.  Moreover, if we consider them as a separate 3-bit number written from the low to high bit, we can see that it has increased by one: 011 + 1 = 100.  And this unit is added to the 4th byte.  From here two preliminary conclusions: <br><br><ul><li>  in the 3rd byte there are bits related to the checksum, </li><li>  checksum is a simple arithmetic sum of something with something, there is no CRC and other difficulties, </li><li>  the data as a whole is not encoded by bytes, but by 4-bit ‚Äúnibbles‚Äù. </li></ul><br>  Let's try to disconnect sensor A and connect sensor B: <br><br>  10011100 10011110 01011101 01000100 <br><br>  changed 2nd and 3rd bytes.  The sixth bit of the second byte (counting from zero) seems to be the ‚Äúpresence of sensor B‚Äù.  The lower 4 bits of the third byte - also the checksum, also increased by one, which appeared in the second byte.  But she appeared there not in the zero and not in the fourth, but in the sixth bit!  Already getting interesting.  Try simultaneously sensors A and B to "infinity": <br><br>  10011100 10011110 01010011 01001100 <br><br>  yes, something cleared up.  We have the second byte, as in the parcel ‚Äúsensor B only‚Äù and the fourth byte from the parcel ‚Äúsensor A only‚Äù.  But in the third byte there are two 4-bit parts from the two previous packages.  The assumption about 4-bit checksums begins to be confirmed?  The only unusual thing is that the checksum is stuck in the middle of the package. <br><br>  Let us now try to put an obstacle in front of sensor A (disabling B) at a distance of, say, 90 cm: <br><br>  10011100 10011100 10011111 01000110 <br><br>  About how, the ‚Äúpresence of sensor A‚Äù bit no longer shows us the presence of sensor A. But in the last 4 bits a bit appeared in another place.  And the checksum has changed dramatically.  Although if you compare with the original parcel without sensors: 1111-1011 = 100, and the last 4 bits: 0110-0010 = 100. Hurray!  Coincided! <br><br>  Nevertheless, it becomes clear later that manually copying these bits from the oscilloscope readings is hard and there is a high probability of making a mistake.  Therefore‚Ä¶ <br><br><h4>  Step three.  Decoding <s>feet</s> in the microcontroller </h4><br>  We have a microcontroller.  Arduino or just AVR on breadboard, whatever.  We have it, who does not like him to collect all the data for the head unit.  Therefore, it's time to write a program to decode the parcel from the PDC and transfer this parcel through the terminalka to the computer to simplify the further process of reversing. <br><br>  Since the level of signals from the PDC is standard 5 volts, the connection to the AVR for debugging is very simple - with a wire to any unspecialized leg (hmm ... maybe I shouldn't have crossed out in the header in vain?). <br><br>  The program source is available on <a href="">github</a> .  The decoding is handled by the PCINT3_vect interrupt handler function in line 119 and on.  The rest of the program does a lot of other interesting things, maybe someday I'll write an article about it.  In the meantime, I will describe in brief the algorithm for decoding the parcel from parking sensors. <br><br>  The current AVRok almost every foot can hang interruption, which will be triggered every time you change the level at the entrance.  Those.  each time when going from 0 to 5 volts and each time when going back from 5 to 0. Thus, it is enough to detect the time between the interrupt and activate the internal state using a timer.  There can be several states: waiting for the first 5 pulses, waiting for a wide pulse, waiting for a pause, waiting for the first 16 bits (followed by decoding depending on the pulse duration), waiting for the pause, waiting for the second 16 bits, waiting for the final pulse, transition to the initial state.  And all this is implemented in the interrupt handler, it takes literally a few clocks each time and does not occupy the main loop at all (although it takes a separate timer, but this is fixable). <br><br>  The resulting UART device produces decoded values ‚Äã‚Äãto the terminalka of the computer directly in the form of 4 bytes.  To simplify the subsequent analysis, open Excel and write a macro: <br><br><div class="spoiler">  <b class="spoiler_title">Habr can highlight BASIC?</b> <div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> lst As Worksheet <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> s As <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Dim</span></span> v, i, j As Long <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> lst = ActiveWorkbook.ActiveSheet <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> k = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> <span class="hljs-number"><span class="hljs-number">365</span></span> <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> i Mod <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> ii = i - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span> ii = i + <span class="hljs-number"><span class="hljs-number">1</span></span> s = <span class="hljs-string"><span class="hljs-string">"&amp;H0"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Mid</span></span>(lst.Cells(k, <span class="hljs-number"><span class="hljs-number">2</span></span>).Value, ii, <span class="hljs-number"><span class="hljs-number">1</span></span>) v = CDec(s) <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> (v <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> ^ j)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> lst.Cells(k, <span class="hljs-number"><span class="hljs-number">3</span></span> + (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">4</span></span> + j) = <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span> lst.Cells(k, <span class="hljs-number"><span class="hljs-number">3</span></span> + (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">4</span></span> + j) = <span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">Next</span></span> k</code> </pre> <br></div></div><br>  generating from 4 hex bytes like this (colors and signatures, of course, I already added): <br><br><img src="https://habrastorage.org/files/982/a3a/c41/982a3ac4166744459d5a1d061370f290.png"><br><br>  it became very clear that the ‚Äúsensor presence‚Äù bits are indeed available for all 4 sensors and affect the checksums, respectively.  And the disappearance of the sensor bit A for some indications is due to something else. <br><br>  Possessing all the above-described tools, we empirically get a table by sensor A: <br><br><img src="https://habrastorage.org/files/33f/481/ec7/33f481ec77f14fa48c74156f2e9fd572.png"><br><br>  Well, everything is very nice looming: <br><ul><li>  The last 4 bits are tens of centimeters of sensor A. And if you simulate distances up to zero, it turns out that tens of centimeters correspond to 1111 and then decreasing further, 10+ cm = 1110, 20+ cm = 1101, 30+ cm = 1100, etc. d.  up to 0011, corresponding to 130+ cm. </li><li>  The pale pink two columns of 2 bits correspond to units of centimeters (note that for 105, 95 and 85 cm the bits are the same).  And in the first column of the higher bits of a 4-bit value.  The coding principle is the same: 0 cm = 1111, 1 cm = 1110, etc.  up to 9 cm = 0110 </li><li>  The first checksum remains the same, but the second is changing slyly.  A column of tens of centimeters affects the amount directly, but both columns of units of centimeters affect only the older two bits of the checksum. </li></ul><br>  Collect a similar table on sensor B: <br><br><img src="https://habrastorage.org/files/95c/100/a1d/95c100a1d32042aba5e69dfc0b21e6b0.png"><br><br>  here it is more interesting: <br><ul><li>  Two columns of two bits each, encoding units of centimeters, remain in place (marked with light green).  It turns out that, most likely, the units of centimeters are displayed each time for the sensor nearest to the obstacle, and tens of centimeters - for each sensor separately.  Thus, on a standard screen, the distance to the sensor closest to the obstacle is displayed with an accuracy of one centimeter and, roughly, the distance to the other sensors in the form of stripes in front of the bumper. </li><li>  Dozens of centimeters for sensor B are also split into two columns, each divided into two bits (marked ‚Äúmedium green‚Äù). </li><li>  Referring to the instructions for Parktronic, we find out that the stated maximum fixed distance to the obstacle is 2.5 meters.  And in 4 bits you can encode only 1.6 meters.  So somewhere is the fifth bit?  Indeed, by simulating distances of 1.7 meters and beyond, we find out that this is the second bit of the first byte (marked dark-green).  Thus, tens of centimeters of sensor B are coded by bits in the following order (from the highest to the lowest): 2,1,0,16,15. </li><li>  The values ‚Äã‚Äãof both 4-bit checksums change.  Therefore, the bits associated with sensor B readings affect both sums. </li><li>  The first checksum is clearly changed by one along with changes per unit of tens of centimeters.  Apparently the remaining columns, which are also included in this amount - among the unchanged by sensor B. </li></ul><br><br>  Sensor queue C: <br><br><img src="https://habrastorage.org/files/f37/154/69a/f3715469ad174d3694e2c814de68175c.png"><br><br>  I'm starting to think like a Chinese: <br><ul><li>  <s>gonfen ji r√∂nran sun</s> oh oh, that is, units of centimeters are still in their places. </li><li>  Dozens of centimeters for the C sensor are encoded in five bits, which this time together, although they belong to different bytes (lilac and dark lilac).  The coding principle is similar to the previous sensors. </li><li>  The first checksum (the first 4 bits) is clearly changed by one along with changes per unit of tens of centimeters.  Similar to sensor B. Therefore, a preliminary conclusion: the first checksum includes the value of tens of centimeters of sensor B and sensor C (probably, without the fifth bit) and something else.  Intuition suggests that this is the lower 4 bits of the last byte.  Check below. </li></ul><br><br>  On the sensor D to collect a detailed table has become lazy, so: <br><br><img src="https://habrastorage.org/files/cd9/950/e23/cd9950e23a7f4c82994d79559ac14bd8.png"><br><br>  Well, all the hypotheses were confirmed.  The first 4 bits of the last byte encode tens of centimeters of sensor D. <br><br>  To test, we simulate several combinations of sensors A and B: <br><br><img src="https://habrastorage.org/files/d17/b7a/a55/d17b7aa5516b440da844f05ba199987f.png"><br><br>  yes, everything is the same. <br><br>  At this stage, we can fully decode the distances for each sensor, including units of centimeters.  And the presence / absence of sensors.  Maybe this is enough?  Hm  Something else seems to be undersampled ... <br><br><h4>  Step Four.  CRC (Chinese Redundancy Check) calculation </h4><br>  So, what we already know about local checksums: <br><ul><li>  There are two of them, 4 bits each, for some reason not in the last, but in the third byte. </li><li>  Each of them is a simple arithmetic sum of data from other columns. </li><li>  It is assumed that certain bits belong to specific checksums. </li></ul><br><br>  We note the currently known membership in the sample of any arbitrary readings: <br><br><img src="https://habrastorage.org/files/73d/04d/f0d/73d04df0d7914c829f9d796fb830d204.png"><br><br>  Let's try to sum up the first line, take the columns of tens of centimeters of sensors B, C and D: <br><br>  1110 + 0111 + 0011 = 11000 <br><br>  hmm, and the checksum in the third byte 0111. And what if minus one? <br><br>  1110 + 0111 + 0011 - 1 = 10111 <br><br>  matches if you drop the extra bit.  Check in other lines: <br><br>  1110 + 0111 + 0011 - 1 = 10111 (oh, it all happened again) <br>  0101 + 0111 + 0011 - 1 = 0111 (here without dropping) <br>  1111 + 1100 + 1100 - 1 = 100110 (here already two bits overflowed) <br>  0001 + 0101 + 0011 - 1 = 1000 (without dropping) <br><br>  Hurray, everything coincided! <br>  We still have unmarked columns.  They probably belong to the second checksum, so let's try to sum up: <br><br>  1010 + 1011 + 0011 = 11000 <br>  1110 + 0111 + 0101 = 11010 <br>  1110 + 0011 + 1000 = 11001 <br>  1111 + 1111 + 0111 = 100101 <br>  1111 + 1011 + 0111 = 100001 <br><br>  mda, not enough in common with the second checksum.  Let's see how much you need to subtract to coincide: <br><br>  1010 + 1011 + 0011 - 10 = 10110 <br>  1110 + 0111 + 0101 - 10 = 11000 <br>  1110 + 0011 + 1000 - 11 = 10110 <br>  1111 + 1111 + 0111 - 01 = 100100 <br>  1111 + 1011 + 0111 - 11 = 11110 <br><br>  I have already seen it somewhere ... well, yes, the first checksum!  The dependence is simple - from the second CS, it is necessary to take away what we have discarded as overflow when calculating the first CS, only xor'ennoe from 11. That is,  discarding 00 (nothing) from the first COP, from the second subtracting 11, etc. <br><br>  Whew, like everything.  There are two unused bits left, but they seem to be always one. <br><br><h4>  Step five.  Radio cleaning </h4><br>  In general, I am not a supporter of the use of radio channels anywhere.  The air is already decently polluted, so that it will all work in places (geographically) rather unstable.  Therefore, let us deal with the fact that we will eject the receiver and transmitter from the PDC by connecting the base unit, the display unit and our microcontroller by wires.  Why do I mention the display unit, although I was not going to put it?  And because of the tweeter.  Still, the transfer from the PDC base unit to our microcontroller, there is decoding, then sending to the head unit, there again decoding and rendering will make an uncritical, but noticeable lag in the distance display.  Therefore, the display unit will remain in the depths of tidy and will obviously squeak faster (although in the future, maybe I will make my microcontroller squeak). <br><br>  It would be possible not to bathe and connect all the blocks with wires just like in debug mode, directly.  However, throwing a miserable 5 volt TTL through the whole car, believe me, is not a good idea.  Therefore, we solder into all three devices of the MAX485 microcircuit, implementing the transfer via a much more reliable <a href="http://ru.wikipedia.org/wiki/RS-485">RS-485</a> interface.  In general, something like that (sorry for the unwashed flux).  Base unit: <br><br><img src="https://habrastorage.org/files/5ac/4e6/19f/5ac4e619f2b44e5a93099683cc740894.jpg"><br><br>  on the place of the white circle in the upper right corner of the board there was an R433A chip, the Q11 transistor and the resistor, instead of which the wires were soldered, were also removed from its piping.  And in the free space it was possible to arrange the microcircuit so that the legs fell on the negative contact and several other suitable contacts.  Since the base unit is always a transmitter, the DE and RE legs can be permanently closed by +5 volts.  Lines A and B of the RS485 interface are connected to an additional terminal. <br><br>  Display Unit: <br><br><img src="https://habrastorage.org/files/6b6/77b/3db/6b677b3db0804b7bad8282d149d45395.jpg"><br><br>  Well, here in general beauty, MAX485 soldered almost like a native instead of the standing <a href="http://www.hoperf.com/upload/rf/RF83.pdf">RF83C</a> receiver <a href="http://www.hoperf.com/upload/rf/RF83.pdf">chip</a> .  The DO data output legs and the minus GND, the DE and RE legs, coincided, since this part is always the receiver, they are planted on the ground.  The rest required just one jumper. <br><br>  Works as before: <br><br><img src="https://habrastorage.org/files/590/d1f/344/590d1f3440874ed49a38580637d246ac.jpg"><br><br>  I‚Äôll probably post a picture of my own microcontroller in the article about the rest of the KMENevoBT functionality from the github. <br><br>  Finally, the full decoding code of the parcel from the PDC from the debugging program in Delphi: <br><br><div class="spoiler">  <b class="spoiler_title">Well, do not hit, it's just a debugging code on the knee</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TfrmKMEmul</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b, c, d: Byte)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cm, la, lb, lc, ld, crc1, crc2: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> cm := $F - ( (a <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $C + (b <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">3</span></span> ); la := (d <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $F; lb := ((a <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) + ((b <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">3</span></span>); lc := ((a <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">3</span></span>) + ((b <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>); ld := (d) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $F; crc1 := ((lc <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $F + lb <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $F + ld) - <span class="hljs-number"><span class="hljs-number">1</span></span>); crc2 := ((a <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $F) + ((b <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $F) + ((d <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $F); crc2 := crc2 - ((crc1 <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) xor $<span class="hljs-number"><span class="hljs-number">3</span></span>); la := $F - la; lb := $<span class="hljs-number"><span class="hljs-number">1</span></span>F - lb; lc := $<span class="hljs-number"><span class="hljs-number">1</span></span>F - lc; ld := $F - ld; lbCM.Caption := IntToStr(cm); lbA.Caption := Format(<span class="hljs-string"><span class="hljs-string">'%.1f'</span></span>, [la/<span class="hljs-number"><span class="hljs-number">10</span></span>]); lbB.Caption := Format(<span class="hljs-string"><span class="hljs-string">'%.1f'</span></span>, [lb/<span class="hljs-number"><span class="hljs-number">10</span></span>]); lbC.Caption := Format(<span class="hljs-string"><span class="hljs-string">'%.1f'</span></span>, [lc/<span class="hljs-number"><span class="hljs-number">10</span></span>]); lbD.Caption := Format(<span class="hljs-string"><span class="hljs-string">'%.1f'</span></span>, [ld/<span class="hljs-number"><span class="hljs-number">10</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> la = $F - $<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> lbA.Font.Color := clRed <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lbA.Font.Color := clGreen; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lb = $<span class="hljs-number"><span class="hljs-number">1</span></span>F - $<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> lbB.Font.Color := clRed <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lbB.Font.Color := clGreen; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lc = $<span class="hljs-number"><span class="hljs-number">1</span></span>F - $<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> lbC.Font.Color := clRed <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lbC.Font.Color := clGreen; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ld = $F - $<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> lbD.Font.Color := clRed <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lbD.Font.Color := clGreen; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> crc1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $F = c <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $F <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> lbCRC.Caption := <span class="hljs-string"><span class="hljs-string">'OK'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lbCRC.Caption := <span class="hljs-string"><span class="hljs-string">'BAD'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (crc2 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $F = (c <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $F) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> lbCRC2.Caption := <span class="hljs-string"><span class="hljs-string">'OK'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lbCRC2.Caption := <span class="hljs-string"><span class="hljs-string">'BAD'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br><br><h4>  Step Six.  findings </h4><br>  Perhaps at some point it was worth to abandon further excavations and order the same parking sensors from Ebay, which the Italian from the forum was picking up on the first link, but I liked the parking sensors themselves.  It works very quickly and accurately.  I had to finish, already out of principle. <br>  What the Chinese smoked, developing such a protocol, is unclear. <br><br><div class="spoiler">  <b class="spoiler_title">Lyrical digression</b> <div class="spoiler_text">  I had a chance several years ago to unearth the diagnostic protocol for Ford cars with the brains of EEC-IV.  These are such brains on the basis of Intel's set of 8096, it seems.  In general, antiquity is at the level of a little bit of 8086. It was put on Fords from the mid 80s and up to the beginning of the 2000s, somewhere from the beginning of the 90s there was implemented the Data Communication Link Diagnostic Protocol (DCL).  So, most likely due to performance limitations, it was impossible to make an exchange protocol with asynchronous data exchange, like the COM port of a computer.  Therefore, the protocol was synchronous.  This meant that when the diagnostic was activated, the brains started sending ‚Äúframes‚Äù along the data line, consisting of words that are strictly synchronized in time.  To communicate with the brains, it was necessary to send their words to the specified intervals between the received words with an accuracy of tens of microseconds.  No computer with a COM port provided the required accuracy of sending bytes.  I had to do on the microcontroller ... <br>  Hmm, so what am I ... Ah, here.  In that case, such an interesting exchange protocol was justified by the limitations of the chip.  In the case of this PDC, I do not see any logic of just such a ‚Äúdance‚Äù bit.  What prevented to arrange, for example, 4x4 bits of tens of centimeters, then 4 bits of units of centimeters, 4 more bits for expanding up to 5 bits of sensors B and C and any service bits and at the end the checksum of all bits (just the sum, without distortions, as a last resort standard CRC8). <br></div></div><br><br>  By the way, knowing the exchange protocol, you can apply this parking sensor not only on the car, but, for example, on a homemade robot.  Yes, there are separate ultrasonic sensors for robots, but here there are four of them at once and they are read by one leg of the arduin, albeit with a delay of several milliseconds. <br><br>  All read all the best! <br><br>  PS I wanted to add a survey about whether to write about the excavation of the protocol of the brain for gas injection KME Nevo Pro.  There, several other techniques were used ... But I think, rather, it is necessary to ask about "do we need such car searches at Habr√©?". </div><p>Source: <a href="https://habr.com/ru/post/249409/">https://habr.com/ru/post/249409/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249399/index.html">How we did the multitouch table</a></li>
<li><a href="../249401/index.html">Robotics programming with Arduino and ROS</a></li>
<li><a href="../249403/index.html">We write the load tester on Node.js</a></li>
<li><a href="../249405/index.html">Forensic system administration</a></li>
<li><a href="../249407/index.html">Browser Vivaldi - the latest news and announcements</a></li>
<li><a href="../249411/index.html">The digest of interesting materials for the mobile developer # 88 (January 26 - February 1)</a></li>
<li><a href="../249413/index.html">Non-von Neumann computer based on combinatorial logic</a></li>
<li><a href="../249415/index.html">Overview of the most interesting materials on data analysis and machine learning ‚Ññ33 (January 26 - February 1, 2015)</a></li>
<li><a href="../249417/index.html">Breeze Server - we delimit access to objects using attributes</a></li>
<li><a href="../249419/index.html">Methods for modifying machine code: "selection" vs. "Genetic Engineering"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>