<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Convolutional neural network, part 1: structure, topology, activation functions and training set</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 These articles ( part 2 ) are part of my research at the university, which sounded like this: ‚ÄúSoftware system for detecting people in a vi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Convolutional neural network, part 1: structure, topology, activation functions and training set</h1><div class="post__text post__text-html js-mediator-article"><h2>  Foreword </h2><br>  These articles ( <a href="https://habrahabr.ru/post/348028/">part 2</a> ) are part of my research at the university, which sounded like this: ‚ÄúSoftware system for detecting people in a video stream using a convolutional neural network‚Äù.  The purpose of the work was to improve the speed characteristics in the process of detecting individuals in a video stream.  As a video stream, a smartphone camera was used, a desktop PS (Kotlin language) was written to create and train a convolutional neural network, as well as an Android mobile application (Kotlin language), which used a trained network and ‚Äútried‚Äù to recognize faces from the camera video stream.  The results, I say, turned out so-so, to use an exact copy of the topology I proposed at my own risk (I would not recommend). <a name="habracut"></a><br><br><div class="spoiler">  <b class="spoiler_title">Theoretical problems</b> <div class="spoiler_text"><ul><li>  define the problem to be solved by the neural network (classification, prediction, modification); </li><li>  define constraints in the problem being solved (speed, accuracy of response); </li><li>  define input (type: image, sound, size: 100x100, 30x30, format: RGB, in grayscale) and output data (number of classes); </li><li>  determine the topology of the convolutional network (the number of convolutional, subsample, fully connected layers; the number of feature maps, the size of the nuclei, activation functions). </li></ul><br></div></div><br><h2>  Introduction </h2><br>  The best results in the field of face recognition were shown by the Convolutional Neural Network or the convolutional neural network (hereinafter referred to as SNS), which is a logical development of the ideas of such national architecture as the cognitron and the neocognitron.  Success is due to the possibility of taking into account the two-dimensional topology of the image, in contrast to the multilayer perceptron. <br><br>  Convolutional neural networks provide partial resistance to scale changes, offsets, turns, angle changes and other distortions.  Convolutional neural networks combine three architectural ideas to ensure invariance to zoom, rotate shear, and spatial distortion: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  local receptor fields (provide local two-dimensional neuron connectivity); </li><li>  common synaptic coefficients (provide detection of certain features anywhere in the image and reduce the total number of weights); </li><li>  hierarchical organization with spatial subsamples. </li></ul><cut></cut><br>  At the moment, the convolutional neural network and its modifications are considered the best in accuracy and speed algorithms for finding objects on the scene.  Beginning in 2012, neural networks occupy the first places in the well-known international competition for image recognition, ImageNet. <br><br><img src="https://habrastorage.org/webt/lo/vp/uf/lovpufxy-jsgugrqozjfnxiiyj8.png"><br><br>  That is why in my work I used a convolutional neural network based on the principles of neocognitron and supplemented with training in the back-propagation error algorithm. <br><br><h2>  The structure of the convolutional neural network </h2><br>  SNA consists of different types of layers: convolutional layers, subsampling (subsampling) subsampling layers and layers of the ‚Äúordinary‚Äù neural network - the perceptron, in accordance with Figure 1. <br><br><img src="https://habrastorage.org/webt/4r/8-/t4/4r8-t4d26oc1pw5tt3pd373qa2g.png"><br>  <i>Figure 1 - convolutional neural network topology</i> <br><br>  The first two types of layers (convolutional, subsampling), alternating with each other, form the input feature vector for a multilayer perceptron. <br><br>  The convolution network received its name from the operation name ‚Äî convolution, the essence of which will be described later. <br><br>  Convolutional networks are a good middle ground between biologically plausible networks and a conventional multilayer perceptron.  Today, the best results in image recognition are obtained with their help.  On average, the recognition accuracy of such networks exceeds the usual ANNs by 10-15%.  SNS is a key technology of deep learning. <br><br>  The main reason for the success of the SNA was the concept of common weights.  Despite their large size, these networks have a small number of adjustable parameters compared to their ancestor, the neocognitron.  There are variants of the SNA (Tiled Convolutional Neural Network), similar to the neocognitron, in such networks occurs, a partial rejection of the associated weights, but the learning algorithm remains the same and is based on the back propagation of the error.  SNS can quickly work on a sequential machine and quickly learn through pure paralleling of the convolution process on each map, as well as reverse convolution when an error is spread over the network. <br><br>  The figure below shows the visualization of convolution and subsample: <br><br><img src="https://habrastorage.org/webt/vy/id/p9/vyidp9qwfzsnwrx7pysfaw7nvig.png"><br><br><div class="spoiler">  <b class="spoiler_title">Neuron model</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/dd/lc/xr/ddlcxrdusgtzxpl5vko34agg7py.png"><br><br><img src="https://habrastorage.org/webt/gr/pa/5d/grpa5dw9ev454pxsqoxlitlfskc.png"><br></div></div><br><h2>  Convolutional neural network topology </h2><br>  Determining the network topology focuses on the problem being solved, data from scientific articles and its own experimental experience. <br><br>  The following steps can influence the choice of topology: <br><br><ul><li>  define the task to be solved by a neural network (classification, forecasting, modification); </li><li>  define constraints in the problem being solved (speed, accuracy of response); </li><li>  define input (type: image, sound, size: 100x100, 30x30, format: RGB, in grayscale) and output data (number of classes). </li></ul><br>  The task solved by my neural network is the classification of images, specifically individuals.  The imposed restrictions on the network is the response speed - no more than 1 second and recognition accuracy of at least 70%.  The overall network topology is in accordance with Figure 2. <br><br><img src="https://habrastorage.org/webt/tf/pb/9m/tfpb9mda5whbxqxauct4_dhnkqw.png"><br>  <i>Figure 2 - The convolutional neural network topology</i> <br><br><h3>  Input layer </h3><br>  The input data are colored images of type JPEG, size 48x48 pixels.  If the size is too large, the computational complexity will increase, respectively, the limitations on the speed of response will be violated, the determination of the size in this problem is solved by the selection method.  If you choose a size that is too small, the network will not be able to identify the key features of the faces.  Each image is divided into 3 channels: red, blue, green.  Thus, 3 images of 48x48 pixels are obtained. <br><br>  The input layer takes into account the two-dimensional topology of images and consists of several maps (matrices), the map can be one, if the image is represented in shades of gray, otherwise there are 3, where each map corresponds to an image with a specific channel (red, blue and green) . <br><br>  The input data of each specific pixel value are normalized in the range from 0 to 1, according to the formula: <br><br><img src="https://habrastorage.org/webt/5i/il/g_/5iilg_28q6nvs3tex1cjk41_kjq.png"><br><br><h3>  Convolutional layer </h3><br>  A convolutional layer is a set of maps (another name is feature maps, in everyday life these are ordinary matrices), each map has a synaptic nucleus (in different sources it is called differently: a scanning core or a filter). <br><br>  The number of cards is determined by the requirements of the task; if you take a large number of cards, the recognition quality will increase, but the computational complexity will increase.  Based on the analysis of scientific articles, in most cases it is proposed to take the ratio of one to two, that is, each card of the previous layer (for example, the first convolutional layer, the previous one is the input one) is associated with two maps of the convolutional layer, in accordance with Figure 3. Number of cards - 6 <br><br><img src="https://habrastorage.org/webt/pk/8e/aw/pk8eawnhcnbpna1iv0ynzc4saqg.png"><br>  <i>Figure 3 - Organization of links between the maps of the convolutional layer and the previous one</i> <br><br>  The size of all maps of the convolutional layer is the same and is calculated by the formula 2: <br><br><img src="https://habrastorage.org/webt/ax/0o/zf/ax0ozfysv_geqonlmxqzz5dyfek.png"><br><br>  The kernel is a filter or a window that slides over the entire area of ‚Äã‚Äãthe previous map and finds certain attributes of objects.  For example, if the network was trained on multiple faces, then one of the nuclei could, in the learning process, produce the largest signal in the eye, mouth, eyebrow or nose, another core could detect other signs.  Kernel size is usually taken in the range from 3x3 to 7x7.  If the size of the nucleus is small, it will not be able to isolate any signs, if too large, then the number of connections between neurons increases.  Also, the core size is chosen so that the size of the maps of the convolutional layer is even, this allows us not to lose information when reducing the dimension in the subsample layer described below. <br><br>  The nucleus is a system of shared weights or synapses, it is one of the main features of the convolutional neural network.  In a conventional multilayer network there are a lot of connections between neurons, that is, synapses, which slows down the detection process very much.  In the convolutional network, on the contrary, the total weights reduces the number of connections and allows us to find the same feature throughout the image area. <br><br><img src="https://habrastorage.org/webt/nm/y2/pz/nmy2pz6esyjmfdba2akmmmhkbns.png"><br><br>  Initially, the values ‚Äã‚Äãof each map of the convolutional layer are equal to 0. The values ‚Äã‚Äãof the weights of the nuclei are set randomly in the range from -0.5 to 0.5.  The kernel slides over the previous map and performs a convolution operation, which is often used for image processing, the formula: <br><br><img src="https://habrastorage.org/webt/71/zc/8j/71zc8jmrrepiithlyrieftfaals.png"><br><br>  Informally, this operation can be described as follows: we pass the window of kernel size g with a given step (usually 1) the entire image f, at each step we elementwise multiply the window contents by the kernel g, the result is summed up and written into the result matrix, as shown in Figure 4. <br><br><img src="https://habrastorage.org/webt/v9/k2/kc/v9k2kc8ng4nrhryunr3wr6l5brg.png"><br>  <i>Figure 4 - The operation of convolution and obtaining the values ‚Äã‚Äãof the convolutional map (valid)</i> <br><br><img src="https://habrastorage.org/webt/o0/zh/rz/o0zhrzr_ml2tgsfmvl-mcrxjmbq.gif"><br>  <i>The operation of convolution and obtaining the values ‚Äã‚Äãof the convolutional map.</i>  <i>The core is shifted, the new map is the same size as the previous one (same)</i> <br><br>  However, depending on the method of processing the edges of the original matrix, the result may be less than the original image (valid), the same size (same) or larger (full), in accordance with Figure 5. <br><br><img src="https://habrastorage.org/webt/rs/z8/ly/rsz8lyxtufyifb_jvfv82h7zq0e.png"><br>  <i>Figure 5 - Three types of convolution of the original matrix</i> <br><br>  In a simplified form, this layer can be described by the formula: <br><br><img src="https://habrastorage.org/webt/n8/ef/ei/n8efeiot1pukkktme6wpndxhjb0.png"><br><br>  In this case, due to the edge effects, the size of the original matrices is reduced, the formula: <br><br><img src="https://habrastorage.org/webt/2f/f0/l3/2ff0l3wbge0tcbgyks1cjhm3jpa.png"><br><br><h3>  Sub-election layer </h3><br>  The subselection layer also, like the convolutional one, has maps, but their number coincides with the previous (convolutional) layer, there are 6 of them. The purpose of the layer is to reduce the dimension of the maps of the previous layer.  If at the previous convolution operation some signs have already been identified, then such a detailed image is no longer needed for further processing, and it is compacted to less detailed.  In addition, filtering already unnecessary parts helps not to retrain. <br>  In the process of scanning by the core of the subsampling layer (filter) of the map of the previous layer, the scanning core does not intersect, unlike the convolutional layer.  Usually, each map has a core of 2x2, which allows reducing previous maps of the convolutional layer by 2 times.  The entire attribute map is divided into 2x2 cells, from which the maximum values ‚Äã‚Äãare selected. <br><br>  Usually, the activation function RelU is used in the subsample layer.  The subsample operation (or MaxPooling - the choice of the maximum) in accordance with Figure 6. <br><br><img src="https://habrastorage.org/webt/0u/ji/tm/0ujitma2xn_ndxqswj5s31je2am.png"><br>  <i>Figure 6 - Formation of a new map of the subsample layer based on the previous map of the convolutional layer.</i>  <i>Subsample operation (Max Pooling)</i> <i><br></i> <br>  Formally, a layer can be described by the formula: <br><br><img src="https://habrastorage.org/webt/1u/nj/y2/1unjy2ro7uttyza6xb0xzebey-k.png"><br><br><h3>  Full bonded layer </h3><br>  The last of the types of layers is the layer of the usual multilayer perceptron.  The purpose of the layer is the classification, it models a complex non-linear function, which, while optimizing, improves the quality of recognition. <br><br><img src="https://habrastorage.org/webt/gq/qh/mk/gqqhmkn4zcnlopgaurj_pu9wb9y.png"><br><br>  The neurons of each map of the previous subsample layer are associated with one neuron of the hidden layer.  Thus, the number of neurons in a hidden layer is equal to the number of maps of a subsampling layer, but connections may not necessarily be such, for example, only a part of the neurons of one of the cards in the subsample layer is associated with the first neuron of the hidden layer, and the rest with the second, or all neurons of the first maps are connected with neurons 1 and 2 of the hidden layer.  The calculation of the values ‚Äã‚Äãof the neuron can be described by the formula: <br><br><img src="https://habrastorage.org/webt/k9/qd/a6/k9qda6floh3v4tu6awwthqlrxmy.png"><br><br><h3>  Output layer </h3><br>  The output layer is connected to all neurons of the previous layer.  The number of neurons corresponds to the number of recognizable classes, that is, 2 is a face and not a face.  But to reduce the number of connections and calculations for the binary case, you can use a single neuron and using the hyperbolic tangent as an activation function, the output of a neuron with a value of -1 means belonging to the ‚Äúnot a person‚Äù class, on the contrary, the output of a neuron with a value of 1 means that it belongs to the class individuals. <br><br><h3>  Select the activation function </h3><br>  One of the stages of the development of a neural network is the choice of the activation function of neurons.  The type of activation function largely determines the functionality of the neural network and the method of training this network.  The classical algorithm for back propagation of errors works well on two-layer and three-layer neural networks, but with a further increase in the depth it begins to experience problems.  One of the reasons is the so-called attenuation of the gradients.  As the error propagates from the output layer to the input layer, each current layer multiplies the current result by the derivative of the activation function.  The derivative of the traditional sigmoid activation function is less than unity in the entire domain of definition, therefore, after several layers, the error will become close to zero.  If, on the contrary, the activation function has an unlimited derivative (like, for example, a hyperbolic tangent), then an explosive increase in the error as it propagates can occur, which will lead to instability of the learning procedure. <br><br>  In this paper, the hyperbolic tangent is used as the activation function in the hidden and output layers, and ReLU is used in the convolutional layers.  Consider the most common activation functions used in neural networks. <br><br><img src="https://habrastorage.org/webt/ux/rx/mt/uxrxmtrbzdniqbytle0ps2_jhbs.png"><br><br><h4>  <font color="#9cc2ce">Sigmoid activation function</font> </h4><br>  This function belongs to the class of continuous functions and takes an arbitrary real number at the input, and at the output it gives a real number in the range from 0 to 1. In particular, large (modulo) negative numbers turn into zero, and large positive ones turn into one.  Historically, sigmoid has been widely used since its output is well interpreted as the level of neuron activation: from no activation (0) to fully saturated activation (1).  Sigmoid (sigmoid) is expressed by the formula: <br><br><img src="https://habrastorage.org/webt/r5/al/bv/r5albvidk9x7m1n50l44vlqstzs.png"><br><br>  Graph of sigmoidal function in accordance with the figure below: <br><br><img src="https://habrastorage.org/webt/yt/7z/cl/yt7zclkcvutm1gdkfznizhb8tsy.png"><br><br>  The extremely undesirable property of sigmoids is that when the function is saturated from one side or another (0 or 1), the gradient in these areas becomes close to zero. <br><br>  Recall that in the process of back propagation of an error, the given (local) gradient is multiplied by the total gradient.  Therefore, if the local gradient is very small, it actually nulls the overall gradient.  As a result, the signal will almost not pass through the neuron to its weights and recursively to its data.  In addition, you should be very careful when initializing the weights of sigmoid neurons to prevent saturation.  For example, if the initial weights are too large, most neurons will become saturated, with the result that the network will be poorly trained. <br><br>  Sigmoidal function is: <br><br><ul><li>  continuous; </li><li>  monotonically increasing; </li><li>  differentiable. </li></ul><br><h4>  <font color="#9cc2ce">Activation function hyperbolic tangent</font> </h4><br>  In this paper, the hyperbolic tangent is used as the activation function for the hidden and output layers.  This is due to the following reasons: <br><br><ul><li>  symmetric activation functions such as hyperbolic tangent provide faster convergence than the standard logistic function; </li><li>  the function has a continuous first derivative; </li><li>  a function has a simple derivative that can be calculated through its value, which saves computation. </li></ul><br>  The graph of the function of the hyperbolic tangent is shown in the figure: <br><br><img src="https://habrastorage.org/webt/zo/bj/em/zobjemw_q4mt82obm-ora2aipts.png"><br><br><h4>  <font color="#9cc2ce">Activation function ReLU</font> </h4><br>  It is known that neural networks are capable of approximating an arbitrarily complex function if there are enough layers in them and the activation function is nonlinear.  Activation functions like sigmoid or tangential are non-linear, but lead to problems with fading or increasing gradients.  However, you can use a much simpler option - rectified linear activation function (rectified linear unit, ReLU), which is expressed by the formula: <br><br><img src="https://habrastorage.org/webt/tq/by/ht/tqbyhtxpyotkoeqrn6aygpmne2m.png"><br><br>  Graph of the ReLU function in accordance with the figure below: <br><br><img src="https://habrastorage.org/webt/rf/vh/1n/rfvh1n0lmoootf-a3s1nmcsebxw.png"><br><br>  Benefits of using ReLU: <br><br><ul><li>  its derivative is equal to either one or zero, and therefore the growth or decay of gradients cannot occur, since  multiplying the unit by the delta error, we get the delta error, if we would use another function, for example, the hyperbolic tangent, then the delta error could either decrease or increase, or remain the same, that is, the derivative of the hyperbolic tangent returns a number with a different sign and the magnitude that can greatly affect the attenuation or growth of the gradient.  Moreover, the use of this function leads to the thinning of the scales; </li><li>  calculating sigmoids and hyperbolic tangent requires resource-intensive operations, such as exponentiation, while ReLU can be implemented using a simple threshold transformation of the activation matrix at zero; </li><li>  cuts off unnecessary parts in the channel with a negative output. </li></ul><br>  Among the shortcomings, it can be noted that the ReLU is not always sufficiently reliable and in the learning process can fail (‚Äúdie‚Äù).  For example, a large gradient passing through a ReLU can lead to such an update of the balance that the neuron is never activated again.  If this happens, then, from now on, the gradient passing through this neuron will always be zero.  Accordingly, this neuron will be irreversibly disabled.  For example, if the learning rate is too high, it may turn out that up to 40% of the ReLUs are ‚Äúdead‚Äù (that is, never activated).  This problem is solved by choosing the appropriate learning speed. <br><br><h3>  Training samples used in experiments </h3><br>  A training set consists of positive and negative examples.  In this case, from individuals and ‚Äúnon-individuals‚Äù.  The ratio of positive to negative examples 4 to 1, 8000 positive and 2000 negative. <br><br>  The LFW3D database [7] was used as a positive training sample.  It contains color images of frontal faces such as JPEG, size 90x90 pixels, in the amount of 13000. The database is provided via FTP, access is carried out with a password.  To receive a password, you must fill out a simple form on the main page of the site, where you can enter your name and email.  An example of people from the database is shown in accordance with the figure below: <br><br><img src="https://habrastorage.org/webt/ba/w7/l7/baw7l7rdin88jumez8pircr9pig.png"><br><br>  As a negative teaching examples used database SUN397 [8], it contains a huge number of various scenes, which are divided into categories.  A total of 130,000 images, 908 scenes, 313,000 scene objects.  The total weight of this base is 37 GB.  The categories of images are quite different and allow you to choose a more specific environment where the final PS will be used.  For example, if it is known a priori that the face detector is intended only for indoor recognition, then there is no point in using a training sample of nature, sky, mountains, etc.  For this reason, the author selected the following categories of images: living room, study, classroom, computer room.  Examples of images from the SUN397 training set are shown in accordance with the figure below: <br><br><img src="https://habrastorage.org/webt/ym/9c/vl/ym9cvlegckj4ajxvnxmioukbsmk.png"><br><br><h3>  results </h3><br>  Direct propagation of a signal from an input image of 90x90 pixels takes 20 ms (on a PC), 3000 ms in a mobile application.  When detecting a face in a video stream at a resolution of 640x480 pixels, it is possible to detect 50 non-overlapping areas with a size of 90x90 pixels.  The results obtained with the selected network topology are worse than the Viola-Jones algorithm. <br><br><h2>  findings </h2><br>  Convolutional neural networks provide partial resistance to scale changes, offsets, turns, angle changes and other distortions. <br><br>  <b>The core</b> is a filter that slides over the entire image and finds signs of a face in any place (invariance to displacements). <br><br>  <b>The sub-sample layer</b> gives: <br><br><ul><li>  an increase in the speed of calculations (at least 2 times), due to a decrease in the dimension of the maps of the previous layer; </li><li>  filtering already unnecessary parts; </li><li>  search for higher level traits (for the next convolutional layer). </li></ul><br>  <b>The last layers</b> are the layers of the usual multilayer perceptron.  Two fully connected and one day off.  This layer is responsible for the classification, from a mathematical point of view, models a complex non-linear function, optimizing which improves the quality of recognition.  The number of neurons in layer 6 by the number of maps of signs of a subsample layer. <br><br>  <b>Possible improvements</b> <br><br><ul><li>  consider neural networks Fast-RCNN, YOLO; </li><li>  parallelization of the learning process on graphics processors; </li><li>  use Android NDK (C ++) to improve performance </li></ul><br><br>  Training convolutional neural network is described in the <a href="https://habrahabr.ru/post/348028/">second part</a> . <br><br><h2>  Links </h2><br><br>  - <a href="https://habr.com/post/309508/">What is a convolutional neural network</a> <br><br>  - Learning sets: <br>  <a href="http://www.openu.ac.il/home/hassner/projects/frontalize/">Effective Face Frontalization in Unconstrained Images // Effective Face.</a> <br>  <a href="http://groups.csail.mit.edu/vision/SUN/">SUN Database // MIT Computer Science and Artificial Intelligence Laboratory</a> <br><br>  - <a href="http://mechanoid.kiev.ua/">Information on convolutional neural networks</a> <br><br>  - <a href="https://www.monographies.ru/ru/book/section%3Fid%3D2465">About neural network learning functions</a> <br><br>  - <a href="https://ai-science.ru/vidy-nejronnyx-setej/">Types of neural networks</a> (similar neural network classification scheme) <br><br>  - Neural networks for beginners: <a href="https://habrahabr.ru/post/312450/">one</a> and <a href="https://habrahabr.ru/post/313216/">two</a> . </div><p>Source: <a href="https://habr.com/ru/post/348000/">https://habr.com/ru/post/348000/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347990/index.html">In a section: the news aggregator on Android with backend. Distributed Message Processing Systems (Spark, Storm)</a></li>
<li><a href="../347992/index.html">False alarms. New technique of catching two birds with one stone</a></li>
<li><a href="../347994/index.html">UX research and evidence strength</a></li>
<li><a href="../347996/index.html">Parsing sites or long-term construction of the Moscow region</a></li>
<li><a href="../347998/index.html">We integrate TeamCity with JIRA - without plug-ins and administrators</a></li>
<li><a href="../348002/index.html">News from the world of OpenStreetMap ‚Ññ392 (01.16.2018-22.01.2018)</a></li>
<li><a href="../348004/index.html">Swift Package Manager</a></li>
<li><a href="../348006/index.html">Cryptocurrency Phishing</a></li>
<li><a href="../348008/index.html">We are friends of gRPC with a long-lived project, PHP and front-end</a></li>
<li><a href="../348010/index.html">False alarms. New technique of catching two birds with one stone. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>