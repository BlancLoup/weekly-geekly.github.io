<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The saga of how we wrote the console</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you plant a thousand monkeys for a thousand typewriters, then for a thousand years they will write a terminal emulator. - instead of an epigraph. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The saga of how we wrote the console</h1><div class="post__text post__text-html js-mediator-article">  <em>If you plant a thousand monkeys for a thousand typewriters, then for a thousand years they will write a terminal emulator.</em>  - instead of an epigraph. <br><br>  Sorry false start, this is not me, this is an android smartbook. <br><br>  When we started the cloud, the first problem was ‚Äúhow do we get the console‚Äù.  The standard XCP mechanism implies that the console is drawn using VNCTerm, and those who want to see it must first go to XenAPI, get the console session-id there, go to the console port, transfer the session id, get the RFB wrapped in HTTP, deploy HTTP, remove RFB (aka VNC), give it to a local VNC renderer (VNC client or java applet with the same functionality).  At the same time, the console was closed (the session was broken) with each restart of the virtual machine.  She was torn even when migrating a virtual machine.  In other words, it was a technology that meant "looked with one eye, repaired ssh / iptables and forgot."  Uncomfortable, slow, difficult.  I did not want to roll out such a product. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And I climbed into the wilds of serial-howto, console-howto and a few more terrible documents telling how to properly configure interrupts on the ISA card for multi-cards, as well as the specifics of setting linux-2.2 to work with them.  At the same time, the console device was studied in zena (an attentive reader could even notice exactly when I more or less figured out this issue - I wrote a brief overview on what was happening with the console on Habr√©). <br><br>  After that, the thought came: you need to write your own, because there is no ready-made good else's <br><br>  At first we wanted to take at least ready-made components and make our own of them.  I still remember that wonderful scheme in which we planned to save anyterm output to the database, do double tunneling of the serial port using UDP ... It looked, to put it mildly, unsightly. <br><br>  Then I got the idea to cut out anyterm.  To do this, it was necessary to see how the terminalki work.  It was very funny and instructive (anyone can read the PuTTY source code).  The main problem with this study was that they draw a lot on the screen.  Right in the process of processing input.  It was difficult to separate the specifics of DC from, in fact, what is a console. <br><br>  After a while, we came up with the idea of ‚Äã‚Äã‚Äúwe need our own terminal emulator‚Äù. <br>  The task seemed relatively simple, until we touched the abyss, called "escape codes and terminal types ...". <br><br><h1>  Typewriters </h1><br>  So, in the beginning was the typewriter.  At some point, there was a desire to combine the telegraph with a typewriter.  This is how the <em>teletype</em> came about. <br>  Of course, the engineers who created the teletype, there was no reason to do everything from scratch.  They simply attached codes to each typewriter key.  After some battles in the style of MS VS Netscape, the <s>html5</s> standard was created for the codes for these machines, I mean teletypes.  If my memory doesn‚Äôt change my memory, then it is ASCII, where all the key combinations that are typical for an American typewriter are provided.  Including the BELL code, which, by the way, should not do BEEP at all, but do a zink, because the typewriters had a bell, not a speaker. <br><br><a name="habracut"></a><br><br>  In the future, when mainframes appeared, they obviously output information to printers.  Which were either teletypes, or printing devices similar to them. <br><br>  When someone guessed to attach a monitor and keyboard to the mainframe, he naturally tried to ensure compatibility with existing printers.  Then, when manufacturers began to make new models of terminals, they tried to provide support for at least the basic set of functionality of previous versions ... This chain dragged on for a very long time vt52 (incompatible with the subsequent ones) - and glorious vt100, vt102, vt120, vt200, vt220, vt320, vt420, vt520 ... <br><br><h1>  TTY emulation terminal emulator, typewriter emulator </h1><br>  Then, when writing Linux, to be able to run programs (like vim, emacs, or mc), there was nothing left to do to support the terminal emulator ... In the same way, by the way, UNIX and its clones went: solaris, FreeBSD, hp- ux, etc. <br><br>  For the graphics mode, we wrote our own terminal emulators - the most advanced of them are xterm and rxvt (perfect - this means supporting everything, and not the most convenient / beautiful).  By the way, the most common ones - gnome-terminal and konsole - support far from everything and far from everything that is supported, processed correctly (those who wish can run vttest on their favorite terminals themselves and look at this disgrace). <br><br>  All these terminal emulators did the same thing - they emulated the operation of a terminal that emulates the terminals of previous generations that emulate a teletype, which emulate a typewriter. <br><br><h1>  Typewriters never die! </h1><br>  Living examples: <br><br>  For example, all self-respecting terminals have the option to issue BELL 8 characters to the end of the line.  This function is useless on the terminal - but very useful for a typewriter. <br><br>  Why do we have separate carriage return codes (guess what kind of carriage the carriage is talking about) and "line feed"?  Of course, because on typewriters these were separate actions (on the most advanced typewriters there was a lever combining CR / LF in itself). <br><br>  A more subtle and non-obvious example.  Why doesn't the Backspace character delete the character on the left, but only move the cursor, and delete delete the character on the right, and even shift the entire line? <br><br>  Obviously: there was a backspace button on typewriters.  And, since a typewriter can only move the carriage back and forth, but cannot delete characters, the backspace does not delete the character either.  And there was no delete on typewriters - and there was no reason to do backward compatibility. <br><br>  Dot matrix printers also left their indelible impression in Linux.  The pager program can emulate a dot matrix printer.  When, when outputting to a matrix printer, they wanted to make the text bold or underline, the carriage was shifted to the left and the text was printed again (or underscores were printed over the existing text).  If you feed such text to the pager (pg) program, it will show it appropriately (it will emulate a dot matrix printer).  However, I otveksya from the console. <br><br>  Another thing that greatly influenced the modern console was how the picture was displayed on the screen.  This affected the text mode CGA (which, in turn, had a lot of influence on Linux).  To understand how this happened, we need to remember how primitive text screens displayed the text image: <br><br>  Two areas were stored in memory ‚Äî attributes and characters (in some implementations through one, in some - as two separate areas of memory).  Color attributes were used as binary switches for supplying voltage from the R, G, B channels.  The sequence of bits (the result of scanning a line of bits from the character of the font selected by the index (code) of the output symbol) switched between two signal variants ‚Äî the background color and the tone color. <br><br>  The ‚Äúbrightness‚Äù attribute that appeared later only added additional voltage to the final signal.  The same explains why the ‚Äúbright black‚Äù for the console, it is not deep black, but only gray.  Well, quite unexpected is the fact that bright black in bright black is quite distinguishable, it looks like dark sulfur in almost black. <br><br>  Another funny feature is the interpretation of the bold attribute - since the first terminals had only one font in the range, they couldn‚Äôt show bold (as opposed to dot matrix printers) - and the solution was to show bold as a bright color tone (characters). <br><br>  The internal structure of the terminal has identified many other interesting points.  For example, where should we go if the line and column numbers are passed to us outside of the allowed values?  Obviously - the last allowed value.  And if very large?  Of course, we have coordinates in int8 / int16, so: it‚Äôs quite natural to do a ring overflow. <br><br>  Another great thing that came to the 21st century from the 19th century is the tap stops.  When typewriters began to improve, there was a problem of typing text in several columns.  The solution was elegant - there was a long row of pins behind the typewriter, each about the width of a symbol.  The pin could be in good condition or depressed.  A special lever was used to push the pin into the current position.  Another lever released the carriage (which was pulled by the spring) so that the carriage stopped at the given tabtop.  Entering the text in this case looked like this: ‚Äúenter text, press tab‚Äù, enter the following text. The most advanced typewriters, like Bashkiria-M, had buttons ‚Äú2‚Äù, ‚Äú3‚Äù, which allowed to skip several tabs.  How this was implemented in mechanics - I do not know.  In addition to the installation of tabstop (they, obviously, could be done on almost every column), there was a tab-reset lever that simply ‚Äúsqueezed‚Äù all the pins.  And of course, all terminals, starting with vt102 and ending with linux-3.0rc2, support the esc-code for ‚Äúunlocking tabs on typewriter tabs‚Äù. <br><br><h1>  our work </h1><br>  When we wrote the terminal a lot was not clear, for example, what are the tabstop after a reset?  (Readers brought up in msdos incorrectly answer "8").  The answer is to look in typewriters.  What are the tops left after pressing all the pins?  Of course, no.  Until you make them with your hands, nothing will appear.  That is why the reset command, the first copyrights in which they were delivered before I was born, during the reset of the terminal sends the code ‚Äúreset the topstop‚Äù, and then walks through the screen in 8-gap portions and arranges the so desired topstop every 8 characters.  Although different types of terminals may imagine a different size of ‚Äútabs by default‚Äù. <br><br>  In the course of our work on the terminal emulator, it is this ‚Äúiron logic‚Äù that became clear only with memories of typewriters, terminals with 8kb of onboard memory, hardware signal sweep circuits, etc.  Delivering the greatest torment for programmers.  Actually, for a programmer, <a href="http://habrahabr.ru/users/bobry/" class="user_link">bobry</a> is the author of our terminal emulation library. <br><br>  Many generations of terminals, their emulators, etc.  led to several standards of varying degrees of blurriness and the iron rule of the terminal emulator writer mimic legacy.  No one has a complete documentation on the terminal code (even the vt102 manual, a huge Talmud, still has quite a few muddy places). <br><br>  The situation with the documentation on the terminals can be described something like this: we have excellent documentation on the terminals and their codes, most of which are written in C and may contradict each other. <br><br>  Frankly, I was not mentally prepared for such an endless nightmare of Legacy, when we took the terminal.  That is, I theoretically knew that in Linux, the last maintainer sent a nafig terminal emulator code and left it unmainained, but I did not expect such an abyss. <br><br>  About two months passed between the first working prototype and the release - and these two months all the time it seemed to us that for the most part it works, only trifles remain. <br><br>  Actually, the main culprit of the celebration, the main and main author of the library is <a href="http://habrahabr.ru/users/bobry/" class="user_link">bobry</a> , who courageously fought the abyss of Legacy, C and longjumps in the xterm code (under my accompaniment of trolling on compability with typewriters and amazing stories about the nature of tapstop, grandma "Bashiriya-3M" still came in handy, not for nothing that I was messing with her <s>in the hungry and cold 90s</s> around the years 90-93 ...).  I can seriously say that he is currently one of the few programmers in the country (especially young programmers who haven‚Äôt found PL / I in the product), who knows well about how the Linux console works, knows esc codes and other horrors secret terminal emulation cuisine ... By the way, the name ncurses is a library for rendering images using esc codes, generally speaking, comes from English to curse - to express gratitude for a convenient and understandable thing. <br><br>  However, I praise us again: <br><br>  At the moment, our library is one of the best, and certainly the best among those that do not draw right away on the screen.  By the way, this is the main feature of our library - it allows you to operate with the image of the terminal in isolation from the way it is drawn.  This is what allowed us, for example, to easily and naturally write to the terminal a message stating that the virtual machine was forcibly completed (if the user kills the machine forcibly).  The virtual machine itself is already stopped at this point - and we, with cunning sapy, simply append the completion message to it.  Regular games with vncterm will not allow this. <br><br>  In the next part I will tell you more about this library, in addition, there will be another drama of modern humanity - browsers and their understanding of what a ‚Äúpressed button‚Äù is and how we made paste working in browsers. </div><p>Source: <a href="https://habr.com/ru/post/120852/">https://habr.com/ru/post/120852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../120843/index.html">Indomitable language bar or ‚ÄúGive a choice‚Äù!</a></li>
<li><a href="../120846/index.html">25% of hackers in the US are FBI informants</a></li>
<li><a href="../120847/index.html">Some more boring statistics</a></li>
<li><a href="../120850/index.html">Three minimalist tasks</a></li>
<li><a href="../120851/index.html">Looking for the perfect captcha</a></li>
<li><a href="../120853/index.html">Easily create beautiful CSS3 presentations with JaCSS</a></li>
<li><a href="../120854/index.html">Wii U - a new hybrid from Nintendo</a></li>
<li><a href="../120855/index.html">Google Chrome 12 (Stable)</a></li>
<li><a href="../120856/index.html">Liquid battery for electric vehicle</a></li>
<li><a href="../120857/index.html">Distribution of UX "Oscars" in New York</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>