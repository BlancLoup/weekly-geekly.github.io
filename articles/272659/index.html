<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Next, in search of palindromes 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After the seemingly good result obtained in the previous part turned out to be only a ‚Äúlocal maximum‚Äù, I gave up the puzzle for a while. I recall the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Next, in search of palindromes 3</h1><div class="post__text post__text-html js-mediator-article">  After the seemingly good result obtained in the <a href="http://habrahabr.ru/post/272555/">previous part</a> turned out to be only a ‚Äúlocal maximum‚Äù, I gave up the puzzle for a while.  I recall the condition: <br><blockquote>  ‚ÄúThe decimal number 585 is 1001001001 in binary.  It is palindromic in both bases.  Find n-th palindromic number ".  Or, in Russian: ‚ÄúThe decimal number 585 in binary number system looks like 1001001001. It is a palindrome in both number systems.  Find the nth palindrome like. ‚Äù </blockquote><br>  But the existence of a much faster, with a fundamentally different computational complexity, the algorithm did not give me rest, and in the end I returned to its <a href="https://discuss.codechef.com/questions/74483/dualpal-editorial">analysis</a> . <br><br>  In the end, the algorithm was not so complicated, but, in my opinion, very beautiful. <br><a name="habracut"></a><br>  The original explanation and implementation uses a prefix tree, but in my opinion, a slightly deeper understanding of the algorithm's mathematics allows us to get by with simpler and faster structures.  I think it is best to disassemble the algorithm by example. <br><br>  We will search for binary palindromes among decimal palindromes of width <b>8</b> .  The source palindromes are exactly <b>9000</b> : from 10,000001 to 99999999. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now take 2 sets of numbers: <br><br><ul><li>  And [ <b>90</b> ] = { <b>10</b> <u>0000</u> <b>01</b> , <b>11</b> <u>0000</u> <b>11</b> , <b>12</b> <u>0000</u> <b>21</b> , ..., <b>98</b> <u>0000</u> <b>89</b> , <b>99</b> <u>0000</u> <b>99</b> } </li><li>  B [ <b>100</b> ] = { <u>00</u> <b>0000</b> <u>00</u> , <u>00</u> <b>0110</b> <u>00</u> , <u>00</u> <b>0220</b> <u>00</u> , ..., <u>00</u> <b>9889</b> <u>00</u> , <u>00</u> <b>9999</b> <u>00</u> } </li></ul><br>  If we describe these sets formally, then set A is a subset of decimal palindromes of width <b>8</b> , in which the average <b>4</b> digits are zeroes, and the set of B consists of <b>0</b> , the set of decimal palindromes of width <b>2</b> multiplied by <b>10 <sup>3</sup></b> and the set of decimal palindromes of width <b>4</b> multiplied by <b>10 <sup>2</sup></b> . <br><br>  And if informally, then the set A is all possible ‚Äúedges‚Äù, and the set B is all possible ‚Äúmiddles‚Äù of decimal palindromes of width <b>8</b> .  It is obvious that the set of all decimal palindromes of width <b>8</b> is the set of all pairwise sums of elements of the sets A and B. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a in A)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b in B)</span></span></span><span class="hljs-function"> </span></span>{ palindrome = a + b; } }</code> </pre> <br>  Further, for brevity, I will use ‚Äúa‚Äù instead of ‚Äúelement of set A‚Äù, and ‚Äúb‚Äù instead of ‚Äúelement of set B‚Äù. <br><br>  Now we translate the elements of both sets into a binary number system: <br><br>  A <br><blockquote>  10000001 <b>100110</b> 001001011010 <b>000001</b> <br>  11000011 <b>101001</b> 111101100011 <b>001011</b> <br>  12000021 <b>101101</b> 110001101100 <b>010101</b> <br>  ... <br>  98000089 <b>101110</b> 101110101110011 <b>011001</b> <br>  99000099 <b>101111</b> 001101001111100 <b>100011</b> <br></blockquote><br>  B <br><blockquote>  00000000 <b>000000</b> <br>  00011000 <b>10101011 111000</b> <br>  00022000 101010111 <b>110000</b> <br>  ... <br>  00988900 11110001011011 <b>100100</b> <br>  00999900 11110100000111 <b>011100</b> <br></blockquote><br>  I singled out <b>6</b> upper and lower discharges for all a, and <b>6</b> lower discharges for all b.  Width <b>6</b> was not chosen randomly - this is the maximum degree of <b>2</b> , not exceeding the width of the ‚Äúedges‚Äù A = <b>10 <sup>2</sup></b> . <br><br>  Now let's take each a, and see what all palindromes have in common, formed from it by adding b.  What they have in common is that they are all in the interval between a itself and the next element A. <br><br>  For example, for a = 10000001, all decimal palindromes formed from it {10000001, 10011001, 10022001, ..., 10988901, 10999901} are in the interval [10000001, 11000011). <br><br>  This means that all decimal palindromes formed from a = 10000001 can begin only with the following <b>6</b> binary digits: <br><blockquote>  100110 - the first binary digits a = 10000001 <br>  100111 <br>  101,000 <br>  101001 - the first binary digits a = 11000011 <br></blockquote><br>  Therefore, in order to be binary palindromes, all these decimal palindromes can only end with the inverse permutation of the initial binary digits: <br><blockquote>  100110 -&gt; 011001 <br>  100111 -&gt; 111001 <br>  101000 -&gt; 000101 <br>  101001 -&gt; 100101 <br></blockquote><br>  And considering that a = 10000001 itself ends in binary numbers 000001, out of all possible b we are only interested in those that end in binary digits: <br><blockquote>  011001 - 000001 = 011000 <br>  111001 - 000001 = 111000 <br>  000101 - 000001 = 000100 <br>  100101 - 000001 = 100100 <br></blockquote><br>  Only for such b it is necessary to check whether 10000001 + b is a binary palindrome. <br><br>  Using this approach, the algorithm for finding palindromes in the bases of BASE <sub>0</sub> , BASE <sub>1</sub> in the interval [1, N] can be described as follows: <br><blockquote>  <i>For each width W of [1, the number of digits N in BASE <sub>0</sub> ]</i> <i><br></i>  <i>Generate sets A and B using BASE <sub>0</sub> .</i>  <i>‚ÄúEdge‚Äù width AW <sub>A</sub> = O (W / 4), W <sub>A</sub> ‚â• W <sub>B</sub></i> <i><br></i>  <i>Translate elements A and B to BASE <sub>1</sub></i> <i><br></i>  <i>Sort items B by recycle bin by last digit in BASE <sub>1</sub></i> <i><br></i>  <i>For each a of A</i> <i><br></i>  <i>For each X from the set of possible initial digits a + b</i> <i><br></i>  <i>For each b ending in (X - end digits a)</i> <i><br></i>  <i>Check whether a + b is a palindrome in BASE <sub>1</sub></i> </blockquote><br>  Unfortunately, I have already forgotten how to strictly prove the computational complexity of algorithms, I will give only a few considerations: <br><br><ol><li>  The sets A and B contain <b>O (N <sup>1/4</sup> )</b> elements. </li><li>  For each a, on average, there is at most <b>BASE <sub>0</sub></b> variants X. <br>  (We initially choose the width of the initial digits of interest to us in BASE <sub>1</sub> so that the resulting number is not more than <b>BASE <sub>0</sub> <sup>W <sub>A</sub></sup></b> , and max (A) is greater than min (A) in <b>BASE <sub>0</sub></b> times.) </li><li>  For each X, on average, no more than <b>BASE <sub>1</sub></b> different b is checked. <br>  (X is distributed evenly and almost does not correlate with the final numbers a in <b>BASE <sub>1.</sub></b> Each basket with b is chosen uniformly, and there are no more than <b><sub>1</sub></b> times less such baskets in <b>BASE</b> than b.) </li><li>  Check for a palindrome still takes <b>O (log (N))</b> . </li></ol><br>  In general, I assume that the computational complexity of the algorithm is <b>O (N <sup>1/4</sup> * log (N) * BASE <sub>0</sub> * BASE <sub>1</sub> )</b> . <br><br>  The first implementation of this algorithm was quite predictably a couple of orders of magnitude faster, and after spending a little more time on optimization, I brought the calculation time to just over <b>0.01</b> seconds, more than <b>1000</b> times faster than the previous algorithm.  This result finally satisfied me, but quite naturally there was a desire to test it on numbers larger than <b>2 <sup>60</sup></b> .  By this time, I had already discovered the <a href="https://oeis.org/A007632">sequence of</a> interest in the Encyclopedia of Integral Sequences.  The <a href="https://oeis.org/A007632/b007632.txt">list of double palindromes</a> had <b>122</b> members, the largest of which consisted of <b>131</b> bits.  It was impressive, but also indirectly indicated that no one had yet come up with an algorithm of logarithmic complexity. <br><br>  The call was serious - there was no doubt that the people who received such a result invested a lot of effort into the development of the algorithm and were also certainly ready to spend days and weeks of computer time for a subsequent search.  Therefore, I decided to at least approximately estimate the time that my algorithm needs to repeat: <br><br>  <b>2 <sup>131/2</sup></b> <b><sup>60</sup></b> = <b>2 <sup>71</sup></b> <br><br>  <b>2 <sup>71 * 1/4</sup></b> &lt; <b>2 <sup>18</sup></b> = <b>262144</b> <br><br>  Given the <b>0.01</b> seconds needed for the limit of <b>2 <sup>60</sup></b> , it turned out that my algorithm had to cope with this task in about <b>1</b> hour!  I felt some kind of trick, but the challenge was already accepted. <br><br>  To be continued. </div><p>Source: <a href="https://habr.com/ru/post/272659/">https://habr.com/ru/post/272659/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272649/index.html">Photoshop for coder (programmer)</a></li>
<li><a href="../272651/index.html">MongoDB as a monitoring tool for LOG files</a></li>
<li><a href="../272653/index.html">On the other side of the game: an open course on game design</a></li>
<li><a href="../272655/index.html">How we taught 1C to generate an IVR menu for Asterisk</a></li>
<li><a href="../272657/index.html">Architecture IoT-solutions on a real example</a></li>
<li><a href="../272661/index.html">NOT unlimited mailbox, or Tale about the secret limitation of Mail.ru</a></li>
<li><a href="../272667/index.html">Practice: How to set up an HP ProLiant ML10v2 server and prepare it for OS installation</a></li>
<li><a href="../272669/index.html">Tarantool as an application server</a></li>
<li><a href="../272671/index.html">ICQ mobile application design contest</a></li>
<li><a href="../272673/index.html">Shadows of the characters in the video The Blacksmith</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>