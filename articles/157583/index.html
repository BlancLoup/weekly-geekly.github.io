<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learn to think and write on Erlang (using the example of two combinatorial problems)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- ... Then I give him in the face ... No, you can not beat! 
 ‚ÄúThe fact of the matter is that it is impossible to beat,‚Äù Panikovsky sighed hypocritica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learn to think and write on Erlang (using the example of two combinatorial problems)</h1><div class="post__text post__text-html js-mediator-article">  - ... Then I give him in the face ... No, you can not beat! <br>  ‚ÄúThe fact of the matter is that it is impossible to beat,‚Äù Panikovsky sighed hypocritically.  - Bender does not allow. <br>  I. Ilf, E. Petrov.  <a href="http://www.lib.ru/ILFPETROV/telenok.txt">Golden calf</a> <br><br>  Brainworm Braga lived in a transparent vessel and was so <br>  strong that even horror.  It is not something from the belly - right from the mouth <br>  rushed to the head and began to throw there from side to side, <br>  breaking mental props and fortifications. <br>  M. Uspensky.  <a href="http://lib.ru/USPENSKIJM/where_nt.txt">Where we are not</a> . <br><br>  Perhaps everyone who first starts studying Erlang feels that he is in the position of Shura Balaganov, who was forbidden to use the only available and understandable method: ‚Äúyou can't beat ...‚Äù.  Erlang lacks such familiar concepts for most modern languages ‚Äã‚Äãas reassignment of a variable and, accordingly, accumulation of the result in one variable.  (For the sake of fairness, it should be noted that the behavior of the ‚Äúglobal variable variable‚Äù type in Erlang can still be implemented. For this, each process has a hash dictionary that stores key-value pairs defined by the programmer. There are built-in functions put (Key, Value), get (Key) and some other auxiliary functions. But using such a dictionary in applications is considered bad style and is recommended only in exceptional cases ( <a href="http://www.erlang.org/doc/man/erlang.html/">http://www.erlang.org/doc/man/erlang.html\#put-2</a> )).  As a result, iterations in the loop cannot be implemented using the usual incrementing of the values ‚Äã‚Äãof the iteration variable.  The accumulation of the result is carried out only through recursion, and the organization of cycles through tail recursion.  (Of course, both iterations and accumulation of the result in a cycle can be implemented through library functions for lists of lists: foreach (Function, List), lists: foldl (Function, StartValue, List), lists: foldr (Function, StartValue, List) ( <a href="http://www.erlang.org/doc/man/lists.html">http : //www.erlang.org/doc/man/lists.html</a> ) and their analogues for collections ( <a href="http://www.erlang.org/doc/man/sets.html">http://www.erlang.org/doc/man/sets.html</a> , <a href="http://www.erlang.org/doc/man/ordsets.html">http://www.erlang.org /doc/man/ordsets.html</a> , <a href="http://www.erlang.org/doc/man/gb_sets.html">http://www.erlang.org/doc/man/gb_sets.html</a> ) and arrays ( <a href="http://www.erlang.org/doc/man/array.html">http://www.erlang.org/doc/man/array.html</a> ). But our goal is to learn how to write cycles, and not to use ready-made solutions, so here we will refrain from using such libraries). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thus, in Erlang you have to break the usual patterns of thinking and replace them with new patterns, characteristic only for this programming language.  Of course, the ideal remedy is the brainwalk, capable of breaking all ‚Äúmental props and fortifications.‚Äù  But for us this is perhaps too radical a means, and we will go a different way. <br><br>  In the life of St. Anthony the Great there is a story about one of his students.  The disciple stood in the temple and listened to St. Anthony reading the Psalter.  As soon as the first verse of the first psalm sounded: <br> <code> ,      ...</code> <br>  the disciple left the temple.  Since then, no one has seen him for almost 30 years, and when he reappeared in the temple, Anthony the Great asked why he left them for so long and where he disappeared.  The disciple replied: ‚ÄúFather, I heard the words of the psalm, and retired to the wilderness in order to try to fulfill what the words are saying,  not to go to the council of unholy thoughts. ‚Äù  In other words, he learned a practical lesson from these words, and now he has come to read further.  Unfortunately, we do not have such a reserve of time, and our goals are not so sublime.  But the main concept can be adopted. <br>  We will look at two standard combinatorial tasks: <br><ol><li>  search for all possible permutations (permutations) from a given set of N elements </li><li>  search for all possible combinations (combinations) of a given set of N elements </li></ol><br>  and analyze various approaches and ways of solving them using the Erlang programming language, in order to understand and master some specific features of programming in this language using concrete examples. <br><a name="habracut"></a><br>  All examples are collected in the module combinat.erl and are available at: <a href="">https://github.com/raven29/combinat_erl.git</a> <br><br><h4>  Two goals - two recursions </h4><br>  As a solution algorithm, we will use direct recursive enumeration.  This means that at each step of the recursion is performed: <br><ol><li>  cycling through all possible values ‚Äã‚Äãfrom the list and adding each of these values ‚Äã‚Äãto existing results; </li><li>  a recursive call with the transfer of a new list, from which already used values ‚Äã‚Äãare excluded. </li></ol><br>  In other words, the procedure involves two stages: a looping at a given level of recursion and a transition to the next level.  Accordingly, these two targets require a double recursive call.  (The algorithm is based on a naive enumeration and, accordingly, requires optimization. However, it is quite suitable for our purposes, because, firstly, due to simplicity and clarity, it makes it easy to illustrate the methods and techniques used, secondly, it applies to both the problems considered with minimal differences, which makes it possible to carry out appropriate comparisons and parallels). <br><br><h5>  Base implementation </h5><br><br>  The basic functionality is implemented in the combinat: permuts_out (List, Number) and combinat: combs_out (List, Number) functions, which print, respectively, all permutations and all combinations of the Number length from the List elements.  The following is the permuts_out (List, Number) function that prints permutations.  This function is called recursively twice: in the 6th line - for looping through, in the 7th line - to go to the next level of recursion.  It is in this last call that the result is incremented in the [RemainH | Result] variable, and the elements contained in this result are excluded from the general list that is passed to the next level of recursion.  The fourth List argument holds the original list of elements that is required for correct calculation of the remainder only in the case of permutations. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">permuts_out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List, Number)</span></span></span><span class="hljs-function"> -&gt;</span></span> permuts_out(List, [], Number, List). permuts_out(_Remain, Result, Number, _List) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> length(Result) == Number -&gt; io:format(<span class="hljs-string"><span class="hljs-string">"~w~n"</span></span>, [Result]); permuts_out([], _Result, _Number, _List) -&gt; ok; permuts_out([RemainH|RemainT], Result, Number, List) -&gt; permuts_out(RemainT, Result, Number, List), permuts_out(List -- [RemainH|Result], [RemainH|Result], Number, List).</code> </pre><br><br>  A similar function for combinations differs from the previous function only by a simpler rule for calculating the transferred remainder and the absence of the fourth argument List. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combs_out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List, Number)</span></span></span><span class="hljs-function"> -&gt;</span></span> combs_out(List, [], Number). combs_out(_Remain, Result, Number) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> length(Result) == Number -&gt; io:format(<span class="hljs-string"><span class="hljs-string">"~w~n"</span></span>, [Result]); combs_out([], _Result, _Number) -&gt; ok; combs_out([RemainH|RemainT], Result, Number) -&gt; combs_out(RemainT, Result, Number), combs_out(RemainT, [RemainH|Result], Number).</code> </pre><br><br><h5>  Two recursions - two functions </h5><br><br>  For greater clarity, two recursive calls can be represented by two different functions.  The endings in the function names correspond to their assignments: * _iteration ‚Äî for iterations on the remainder list at a given level of recursion, * _recursion ‚Äî to move to the next level of recursion. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">permuts_out_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List, Number)</span></span></span><span class="hljs-function"> -&gt;</span></span> permuts_out_iteration(List, [], Number, List). permuts_out_iteration([], _Result, _Number, _List) -&gt; ok; permuts_out_iteration([RemainH|RemainT], Result, Number, List) -&gt; permuts_out_iteration(RemainT, Result, Number, List), permuts_out_recursion(List -- [RemainH|Result], [RemainH|Result], Number, List). permuts_out_recursion(_Remain, Result, Number, _List) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> length(Result) == Number -&gt; io:format(<span class="hljs-string"><span class="hljs-string">"~w~n"</span></span>, [Result]); permuts_out_recursion(Remain, Result, Number, List) -&gt; permuts_out_iteration(Remain, Result, Number, List). combs_out_2(List, Number) -&gt; combs_out_iteration(List, [], Number, List). combs_out_iteration([], _Result, _Number, _List) -&gt; ok; combs_out_iteration([RemainH|RemainT], Result, Number, List) -&gt; combs_out_iteration(RemainT, Result, Number, List), combs_out_recursion(RemainT, [RemainH|Result], Number, List). combs_out_recursion(_Remain, Result, Number, _List) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> length(Result) == Number -&gt; io:format(<span class="hljs-string"><span class="hljs-string">"~w~n"</span></span>, [Result]); combs_out_recursion(Remain, Result, Number, List) -&gt; combs_out_iteration(Remain, Result, Number, List).</code> </pre><br>  Perhaps this option can be considered antipattern, due to the excessive bulkiness. <br><br><h4>  Show the result! </h4><br><br>  If you want to write a library function, then there is little use from outputting to the standard stream.  You need to get the result and pass it in some form to the client code.  To accumulate the result in Erlang there are neither global variables nor static fields.  Instead, approaches characteristic of functional languages ‚Äã‚Äãcan be used: <br><br><ol><li>  return values ‚Äã‚Äãin ascending recursion </li><li>  callback function </li><li>  thread executor and thread accumulator </li></ol><br>  Consider each option in detail. <br><br><h5>  Bear there - bear back </h5><br>  So far, we have done something useful (if outputting the result to a computer screen can be considered a useful thing) in the body of the function, going down to the bottom of the descending recursion.  When moving back, the result returned by the function was not used at all.  In other words, the upward movement on recursion went ‚Äúempty‚Äù.  With this approach, it is impossible to put together all the displayed values, since  they are not related to each other.  More productive is the use of the result returned by the function when exiting recursion.  In this case, the first call to the recursive function can return the entire cumulative result.  The modification of the basic functions is given below and includes three points: <br><br><ol><li>  returning the result [Result] instead of outputting to the standard stream (line 3, 11) </li><li>  the initial value is returned at the bottom of the recursion - an empty list [] instead of the atom ‚Äúok‚Äù (line 4, 12) </li><li>  accumulation of the result by summing the lists "++" instead of a sequential call (line 6, 14) </li></ol><br>  The functions permuts_res (List, Number) and combs_res (List, Number) return a list of lists containing, respectively, all permutations and combinations of length Number. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">permuts_res</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List, Number)</span></span></span><span class="hljs-function"> -&gt;</span></span> permuts_res(List, [], Number, List). permuts_res(_Remain, Result, Number, _List) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> length(Result) == Number -&gt; [Result]; permuts_res([], _Result, _Number, _List) -&gt; []; permuts_res([RemainH|RemainT], Result, Number, List) -&gt; permuts_res(RemainT, Result, Number, List) ++ permuts_res(List -- [RemainH|Result], [RemainH|Result], Number, List). combs_res(List, Number) -&gt; combs_res(List, [], Number). combs_res(_Remain, Result, Number) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> length(Result) == Number -&gt; [Result]; combs_res([], _Result, _Number) -&gt; []; combs_res([RemainH|RemainT], Result, Number) -&gt; combs_res(RemainT, Result, Number) ++ combs_res(RemainT, [RemainH|Result], Number).</code> </pre><br><h5>  And do with it what you want! </h5><br><br>  Sometimes it is convenient not to accumulate the result in one collection variable, but to do something useful with each element immediately after its creation.  This approach allows you to increase productivity and significantly reduce memory consumption.  You can implement it with a callback function, which is passed as an additional argument.  The relevant options are listed below. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">permuts_clb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List, Number, Callback)</span></span></span><span class="hljs-function"> -&gt;</span></span> permuts_clb(List, [], Number, List, Callback). permuts_clb(_Remain, Result, Number, _List, Callback) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> length(Result) == Number -&gt; Callback(Result); permuts_clb([], _Result, _Number, _List, _Callback) -&gt; ok; permuts_clb([RemainH|RemainT], Result, Number, List, Callback) -&gt; permuts_clb(RemainT, Result, Number, List, Callback), permuts_clb(List -- [RemainH|Result], [RemainH|Result], Number, List, Callback). combs_clb(List, Number, Callback) -&gt; combs_clb(List, [], Number, Callback). combs_clb(_Remain, Result, Number, Callback) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> length(Result) == Number -&gt; Callback(Result); combs_clb([], _Result, _Number, _Callback) -&gt; ok; combs_clb([RemainH|RemainT], Result, Number, Callback) -&gt; combs_clb(RemainT, Result, Number, Callback), combs_clb(RemainT, [RemainH|Result], Number, Callback).</code> </pre><br>  The variable Callback can be passed the name of any function from a single argument (with an arity of one - according to the terminology of Erlang).  For example, you can call the printout of all permutations of the elements [1,2,3] to 2: <br><pre> <code class="erlang hljs">combinat:permuts_clb([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span>(X)-&gt;io:format(<span class="hljs-string"><span class="hljs-string">"~w~n"</span></span>,[X]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>).</code> </pre><br>  A more meaningful use of the callback function is discussed in the next section. <br><br><h5>  Big Brother is watching you </h5><br><br>  Another way to implement the accumulation of the result of branching recursion in Erlang is to use two threads.  One thread is a performer, it launches our program.  The other stream is the observer, the recursive function transmits the received results to it.  When the executing thread completes its work, the observer flow displays the total result.  Important: you cannot use the main stream (supervisor) in which the erl shell is running as an executing thread, since  this thread is not destroyed after program execution.  It continues to exist until the erl application is unloaded. <br><br>  Below is the corresponding implementation.  Line 3 is set to ‚Äúexit through the ladder‚Äù, which ensures the transmission of a message from the associated process even if it is completed normally.  By default, the trap_exit flag is set to false, which means receiving a message from the associated process only in the event of a crash.  Line 5 starts (and simultaneously binds) the executing thread.  This thread starts the function permuts_clb (or combs_clb), to which the arguments List, Number are passed, as well as the callback function Callback, which passes each single result to an observer process: <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R)</span></span></span><span class="hljs-function">-&gt;</span></span>Supervisor!R <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Line 6 starts the loop ([]) function with an empty initial value of the total result.  This function "listens" to messages from the executing thread.  When the next result is received, a recursive loop (Total ++ [Result]) call (line 14) occurs with an argument supplemented by the newly arrived result from the executing thread.  Upon completion of the executing thread, a ‚Äúladder exit‚Äù occurs: a special kind of tuple (line 10) is passed to loop (), through which the common result is output (line 11) and the connection with the executing thread is broken (line 12 ).  Supervisor - pid of the observer thread, Worker - pid of the executing thread. <br><br><pre> <code class="erlang hljs"><span class="hljs-comment"><span class="hljs-comment">%% Function = permuts_clb | combs_clb proc(Function, List, Number) -&gt; process_flag(trap_exit, true), Supervisor = self(), spawn_link(combinat, Function, [List, Number, fun(R)-&gt;Supervisor!R end]), loop([]). loop(Total) -&gt; receive {'EXIT', Worker, normal} -&gt; io:format("~w~n", [Total]), unlink(Worker); Result -&gt; loop(Total ++ [Result]) end.</span></span></code> </pre><br>  The function is called with permuts_clb or combs_clb as the first argument, depending on the problem being solved.  For example, printing of all permutations from elements [1,2,3] through 2 is carried out through a call: <br><pre> <code class="erlang hljs">combinat:proc(permuts_clb, [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>).</code> </pre><br>  There may be errors characteristic of a beginner.  First, you cannot start loop () before spawn_link ().  It would seem that it would be more reliable, since the listener function, which was started before the executor thread was launched, will certainly not miss a single message from this stream.  But as a result, the process will ‚Äúhang‚Äù on loop (), and the next line will never be called.  Secondly, the use of the Supervisor variable to send a message to the observer stream is mandatory: the design <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">!R</span></span></code> </pre><br>  does not work, since the self () function will be executed when called in the executing thread and, accordingly, will receive the pid of the executing thread.  Thanks to <a href="https://habrahabr.ru/users/w495/" class="user_link">w495</a> and <a href="https://habrahabr.ru/users/evilbluebeaver/" class="user_link">EvilBlueBeaver</a> for constructive criticism of these comments (and just for helping us figure it out). <br><br>  And one more small note: when experimenting with the proc () function, various oddities can occur, for example, the function may begin to produce a result with a ‚Äúdelay‚Äù, i.e.  with each call to produce the result of the previous call.  This may be due to the fact that we are launching the main stream as an observer stream.  Therefore, after some failure, the next loop () call will first process all messages from the last call, if any.  In this sense, the implementation of the listener stream will also be more reliable in a separate stream generated by the spawn () or spawn_link () function. <br><br><h4>  To understand is to turn on. </h4><br><br>  Some programming languages ‚Äã‚Äãhave a syntax structure called " <a href="http://en.wikipedia.org/wiki/List_comprehension">list comprehension</a> ".  It allows in a compact and elegant form to specify an iterative list traversal, as a result of which a new list is generated, each element of which is obtained from the original list by applying some function to each element of the original list.  The construction is based on the notation of mathematical set theory.  So, for example, in the list comprehension construction, the output of squares of all integers from 1 to 9 looks like: <br><pre> <code class="erlang hljs">[X*X || X &lt;- [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>]].</code> </pre><br>  In list comprehension it is also possible to transmit several lists and impose conditions.  As an example, consider the output of the multiplication table from 1 to 9: <br><pre> <code class="erlang hljs">[io:format(<span class="hljs-string"><span class="hljs-string">"~w * ~w = ~w~n"</span></span>, [I, J, I*J]) || I &lt;- [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>], J &lt;- [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>]].</code> </pre><br>  as well as multiplication tables, in which repeated results with the transposition of factors are excluded: <br><pre> <code class="erlang hljs">[io:format(<span class="hljs-string"><span class="hljs-string">"~w * ~w = ~w~n"</span></span>, [I, J, I*J]) || I &lt;- [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>], J &lt;- [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>], I &lt; J].</code> </pre><br><br>  In the Russian-language literature, ‚Äúlist comprehension‚Äù is translated as ‚Äúinclusion of lists‚Äù, ‚Äúgeneration of lists‚Äù.  The main meaning of the translation of ‚Äúcomprehension‚Äù is ‚Äúto comprehend‚Äù, ‚Äúto understand‚Äù.  So, to understand English is to include. <br><br>  It should be noted that the comprehension construct exists not only for lists, but also for collections of other types.  Erlang has list comprehension and <a href="http://learnyousomeerlang.com/starting-out-for-real">binary comprehension</a> . <br><br><h5>  The most elegant of its kind </h5><br><br>  In the list comprehension construction, you can specify an iterative list traversal; as a result, the basic function takes the form: <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">permuts_comp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List, Number)</span></span></span><span class="hljs-function"> -&gt;</span></span> permuts_comp(List, [], Number). permuts_comp(_Remain, Result, Number) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> length(Result) == Number -&gt; io:format(<span class="hljs-string"><span class="hljs-string">"~w~n"</span></span>, [Result]); permuts_comp(Remain, Result, Number) -&gt; [permuts_comp(Remain -- [R], [R] ++ Result, Number) || R &lt;- Remain].</code> </pre><br>  The permuts_comp function calls itself recursively from list comprehension. <br>  This is perhaps the most elegant permutation function of all possible. <br><br><h5>  If you can not, but really want ... </h5><br><br>  The generalization of the previous result on the function of combinations, unfortunately, is not so obvious.  The fact is that in list comprehension in this case it is necessary to transfer not the entire list, but only the remainder determined by the number from the previous call.  If instead of lists there was an array, one could easily calculate the necessary index.  But arrays are not in the basic types of Erlang.  It is necessary either to use the array library, or to organize the array "manually". <br>  This turns out to be quite simple, and the corresponding implementation is presented below.  From the source List, we build a list of ListIndexed tuples, each element of which contains the elements of the source list and an integer index (line 2).  For such a conversion, the function lists: zip (List1, List2) from the standard module lists.  When displaying the result, we use the function lists: unzip (ListIndexed), which returns the initial view without indexes to the indexed list (line 5).  And most importantly - in list comprehension, you can now easily specify the required limit on the indices included in the iterations (line 11). <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combs_comp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List, Number)</span></span></span><span class="hljs-function"> -&gt;</span></span> ListIndexed = lists:zip(List, lists:seq(<span class="hljs-number"><span class="hljs-number">1</span></span>, length(List))), combs_comp(ListIndexed, [], Number). combs_comp(_Remain, Result, Number) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> length(Result) == Number -&gt; {ResultValue, _I} = lists:unzip(Result), io:format(<span class="hljs-string"><span class="hljs-string">"~w~n"</span></span>, [ResultValue]); combs_comp(Remain, [], Number) -&gt; [combs_comp(Remain -- [R], [R], Number) || R &lt;- Remain]; combs_comp(Remain, [{HValue,HIndex}|T], Number) -&gt; [combs_comp(Remain -- [{R,I}], [{R,I}] ++ [{HValue,HIndex}|T], Number) || {R,I} &lt;- Remain, I &gt; HIndex].</code> </pre><br>  It looks somewhat awkward, and this is the only program among our examples in which we had to resort to library functions lists: zip (List1, List2), lists: unzip (ListTuple), lists: seq (StartValue, Length).  This attempt can also be considered a sample of the anti-pattern, since  for the task at hand, it would be more consistent to use the array module, but this will be another story ... </div><p>Source: <a href="https://habr.com/ru/post/157583/">https://habr.com/ru/post/157583/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../157575/index.html">"Simple Business" version 1.7.5.0. - especially for you - a new design of the portal, the agent program, the web version and the distribution module for your clients</a></li>
<li><a href="../157577/index.html">Crowdfunding for science</a></li>
<li><a href="../157579/index.html">OCEJPAD 6 Preparation</a></li>
<li><a href="../15758/index.html">The social circle is closed</a></li>
<li><a href="../157581/index.html">Right on, commander! Elite reborn on Kickstarter</a></li>
<li><a href="../157589/index.html">SCADA security in numbers</a></li>
<li><a href="../157591/index.html">Do you make manufacturers of popular services accountable for errors?</a></li>
<li><a href="../157593/index.html">Versatility vs. usability</a></li>
<li><a href="../157595/index.html">Overview of the program for auditing Microsoft SQL Server-NetWrix SQL Server Change Reporter 2.5</a></li>
<li><a href="../157597/index.html">We're friends of System.Web.Optimization Bundle with Windows Azure Storage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>