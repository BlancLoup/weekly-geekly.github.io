<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Making any object thread safe</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In these 3 articles, I will talk in detail about atomic operations, memory barriers and fast data exchange between threads, as well as ‚Äúsequence-point...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Making any object thread safe</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/7b3/9d2/e68/7b39d2e68a22afcce66af7b6567f8726.jpg" alt="image"><br><br>  In these 3 articles, I will talk in detail about atomic operations, memory barriers and fast data exchange between threads, as well as ‚Äúsequence-points‚Äù using the example ‚Äúexecute-around-idiom‚Äù, and at the same time we will try to do something useful ‚Äî a smart pointer that makes any object thread safe for any operations with its members ‚Äî variables or functions.  And then we will show how using it to achieve the performance of highly optimized lock-free algorithms on 8 - 64 cores. <br><a name="habracut"></a><br>  Three related articles: <br><br><ol><li>  Making any object thread safe </li><li>  <a href="https://habrahabr.ru/post/328362/">Accelerate std :: shared_mutex 10 times</a> </li><li>  <a href="https://habrahabr.ru/post/328374/">Thread safe std :: map with lock-free map performance</a> </li></ol><br>  ‚Üí <a href="https://www.codeproject.com/Articles/1183379/We-make-any-object-thread-safe">My article in English</a> <br>  ‚Üí <a href="https://github.com/AlexeyAB/object_threadsafe">Examples and tests from all three articles</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the standard C ++ library, there are no thread-safe containers (array, list, map ...) that can be used in several threads without additional locks.  Using standard containers for multi-stream exchange there is a danger that you forget to protect one of the sections of the mutex code or mistakenly protect it with another mutex. <br><br>  Obviously, the developer will make more mistakes if he uses his own solution instead of the standard one.  And if the task is so complicated that the solution is not in the standard, then the developer, solving it, will drown in mistakes. <br><br>  Based on the principle of ‚Äúpracticality is more important than impeccability‚Äù (‚Äúpracticality beats purity‚Äù), we will try to create not an ideal, but practical solution to this problem. <br><br>  In the article, we implement a smart pointer that makes any object thread safe, with a performance that is not inferior to optimized lock-free containers. <br><br>  A simplified non-optimized example of using such a pointer: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ contfree_safe_ptr&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; safe_map_string_int; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([&amp;]() { safe_map_string_int-&gt;emplace(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"apple"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">); })</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([&amp;]() { safe_map_string_int-&gt;emplace(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"potato"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">); })</span></span></span></span>; t1.join(); t2.join(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"apple = "</span></span> &lt;&lt; (*safe_map_string_int)[<span class="hljs-string"><span class="hljs-string">"apple"</span></span>] &lt;&lt; <span class="hljs-string"><span class="hljs-string">", potato = "</span></span> &lt;&lt; (*safe_map_string_int)[<span class="hljs-string"><span class="hljs-string">"potato"</span></span>] &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  At each step of our algorithm, we will quote from the standard to guarantee the necessary behavior. <br><br>  We will take a closer look at the C ++ memory model, the various possible synchronization and data exchange options between threads. <br><br>  In the second article, we will implement the optimized contention-free shared-mutex and optimized pointer based on its contfree_safe_ptr &lt;&gt;.  And in the third article we will show examples of the optimal use of contfree_safe_ptr &lt;&gt; and give performance tests. <br><br><h2>  <b>Start</b> </h2><br>  Let's start with the development of the smart pointer template safe_ptr &lt;T&gt;, which will be thread safe for any type T and show multi-threaded performance at the level of optimized lock-free algorithms. <br><br>  Moreover, with the ability to work atomically and consistently over several different objects, where even for lock-free data structures, we would have to use locks and there would be a risk of perpetual deadlock.  But we will develop a special mutex lock class that resolves deadlocks situations.  Then we implement our own high-performance contention-free shared-mutex, which is much faster than the standard std :: shared_mutex.  And based on this, we will create an optimized version of the safe pointer safe_ptr &lt;T&gt;, called contfree_safe_ptr &lt;&gt;.  At the end, we will perform performance tests comparing with the lock-free library CDSlib.  We will see similar performance to CDSlib (SkipListMap and BronsonAVLTreeMap) using the example contfree_safe_ptr &lt;std :: map &lt;&gt;&gt;. <br><br>  As a result, to make any of your T classes flow-safe, you do not need time, just write: contfree_safe_ptr &lt;T&gt; ptr_thread_safe; <br><br>  And the performance will be close to the fact that if you had been developing lock-free algorithms in the methods of your class for a month.  In addition, it will be possible to atomically change several contfree_safe_ptr &lt;&gt; at once.  Like std :: shared_ptr &lt;&gt;, our smart pointer will contain a reference count.  It can be copied, and after deleting the last copy, the dynamically allocated memory will automatically be freed. <br><br>  At the end, 1 safe_ptr.h file will be provided, which is enough to connect via #include ‚Äúsafe_ptr.h‚Äù so that you can use this class. <br><br><h2>  <b>Basic principles of multi-threaded data exchange</b> </h2><br>  As you know, we can read and modify the same object from different threads only in the following 4 cases: <br><br>  <b>1. Lock-based.</b>  The object is protected by locking: spin-lock, std (mutex, recursive_mutex, timed_mutex, shared_timed_mutex, shared_mutex ...): <a href="http://en.cppreference.com/mwiki/index.php%3Ftitle%3DSpecial%253ASearch%26search%3Dmutex">en.cppreference.com/mwiki/index.php?title=Special%3ASearch&amp;search=mutex</a> <br>  <b>2. Atomic.</b>  The object is of type std :: atomic &lt;T&gt;, where T is a pointer, bool, or integral type (std :: is_integral &lt;T&gt; :: value == true), and only if at type T there are atomic operations at the CPU level: <a href="http://en.cppreference.com/w/cpp/atomic/atomic">en .cppreference.com / w / cpp / atomic / atomic</a> <br>  <b>2 + 1 (Lock-based-Atomic)</b> Otherwise, if type T is a trivially copyable type, i.e.  satisfy the condition std :: is_trivially_copyable &lt;T&gt; :: value == true, then std :: atomic &lt;T&gt; works like Lock-based - the lock is automatically used inside it <br>  <b>3. Transaction-safe.</b>  Functions implemented to work with the object provide a stream-safe transaction_safe guarantee (Transactional Memory TS ( <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4514.pdf">ISO / IEC TS 19841: 2015</a> ) - Experimental C ++): <a href="http://en.cppreference.com/w/cpp/language/transactional_memory">en.cppreference.com/w/cpp/language/transactional_memory</a> <br>  <b>4. Lock-free.</b>  Functions for working with an object are implemented based on lock-free algorithms, i.e.  provide a stream-safe lock-free guarantee <br><br>  If you are well aware of all 4 ways to ensure flow-safety, you can skip this chapter. <br><br>  Consider in reverse order: <br><br>  <b>(4) Lock-free</b> algorithms are rather complicated, and often several scientific papers are required to create each complex algorithm.  Examples of lock-free algorithms for working with containers: unordered_map, ordered_map, queue ... and links to scientific papers can be found in the library - Concurrent Data Structures (CDS) library: <a href="https://github.com/khizmax/libcds">github.com/khizmax/libcds</a> <br>  These are very fast and reliable multi-threaded data structures, but so far there are no plans to include them in the standard C ++ 17 or C ++ 20 library and they are not included in the draft standards: <a href="http://www.open-std.org/JTC1/SC22/WG21/">www.open-std.org/JTC1/SC22/WG21</a> <br><br>  <b>(3) Transaction-safe</b> is planned to be included in the experimental part of the C ++ standard and there is already a draft of the standard ISO / IEC TS 19841: 2015: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4514.pdf">www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4514.pdf</a> <br>  But not even all STL-containers are planned to be transaction-safe.  For example, the container std :: map is not even planned to make transaction-safe, since  for it, only the following functions are defined as transaction-safe: begin, end, size, max_size, empty.  But not defined as thread safe functions: find, modify, insert.  And implementing your own object with transaction-safe member functions is not at all easy, otherwise you would have done it for std :: map. <br><br>  <b>(2) Atomic.</b>  This approach is already standardized in C ++ 11 and you can easily use it.  For example, it is enough to declare the variable std :: atomic shared_val;  then pass the link or pointer to it in several threads and all calls through member functions and std :: atomic operators will be thread safe: [3] <a href="http://coliru.stacked-crooked.com/a/9d0219a5cfaa3cd5">coliru.stacked-crooked.com/a/9d0219a5cfaa3cd5</a> <br>  Member functions, Specialized member functions: <a href="http://en.cppreference.com/w/cpp/atomic/atomic">en.cppreference.com/w/cpp/atomic/atomic</a> <br>  It is important to understand that if you do several operations on an atomic variable, no matter in one expression or in several, then between them another thread can change the value of this variable.  Therefore, for the atomic execution of several operations, the Lock-free approach based on the CAS function (Compare-And-Swap) compare_exchange_weak () is used - namely: we read the value from the atomic variable into the local variable (old_local_val), do the many operations we need and write the result into a local variable (new_local_val), and at the end of the CAS function we compare the current value of the atomic variable with the initial one (old_local_val) and if they are not equal, then we perform the cycle again, and if they are equal, it means that during this time another thread did not make any changes, then we change atomic value  variable to a new value (new_local_val).  Moreover, the comparison and assignment are done by a single operation. Compare_exchange_weak () is an atomic function and until it is completely executed, no one can change the value of a variable: [4] <a href="http://coliru.stacked-crooked.com/a/aa52b45150e5eb0a">coliru.stacked-crooked.com/a/aa52b45150e5eb0a</a> <br><br>  This looping approach is known as optimistic locking.  Pessimistic locks are called: spin-lock, mutex ... <br><br>  And if all operations of such a cycle are performed without pessimistic locks, then such an algorithm is called lock-free. <br><br>  Often, the atomic CAS function is replaced with pointers, namely: a new memory is allocated, a modified object is copied into it and a pointer to it is obtained, a series of actions are performed on this copy, and at the end the old pointer to the pointer to a new object is replaced with a CAS function, time another thread did not change the old pointer.  But if the pointer was changed by another thread, then everything repeats from the beginning. <br><br>  There may be a problem called ‚Äú <a href="https://en.wikipedia.org/wiki/ABA_problem">ABA</a> ‚Äù.  When other threads have time to change the pointer twice, and the second time the pointer is changed to the original value, but at this address other threads already have time to delete the object and create a new one.  Those.  the pointer value also points to another object, and we see that the value has not changed and we think that the object has not been replaced.  There are many ways to solve this problem, for example: LL / SC, RCU, hazard_pointer, garbage collector ... <br><br>  Atomic is the fastest way to exchange data between threads.  In addition, less strict and faster memory barriers can be used for all atomic operations, which we will discuss in more detail later.  By default, the most secure and strict reordering barrier is used: std :: memory_order_seq_cst.  But as we noted above: it takes a lot of effort to implement complex logic using atomic variables. <br><br>  <b>(2) - (1) Atomic &amp; Lock-based.</b> <br>  But if you need to read or change atomic several variables at once, std :: atomic a, b, c;  and you do not want to implement the lock-free algorithm and solve the ABA problem, you need to use a lock.  The processor atomic CAS function on most CPUs can check whether only one variable with a maximum width of 64-bit was changed, but at that time another variable could have changed.  Solution: std :: atomic &lt;T&gt; allows you to use for T - type structure of any size. <br><br>  The C ++ standard introduced the ability to use any type T for std :: atomic &lt;T&gt;, if it is ‚Äútrivially copyable type‚Äù, i.e.  satisfies the condition std :: is_trivially_copyable &lt;T&gt; :: value == true <br><br>  What the C ++ <b>Working Draft Standard</b> says <b>, Standard for Programming Language C ++ N4606 2016-07-12</b> : <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf">www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf</a> <br><blockquote>  <b>¬ß29.5 / 1</b> <br>  There is a generic class template <b>atomic &lt;T&gt;</b> .  This is a <b>trivially copyable</b> (3.9).  [Note: It can be difficult to use.  - end note] <br></blockquote><br><blockquote>  <b>¬ß3.9 / 9</b> <br>  Scalar types, (c) Clause 9, collectively <b>called trivially copyable types</b> <br></blockquote><br><br>  But if the atomic processor CAS function can check whether only one variable with a maximum width of 64-bit has been changed, and we have 3 variables for 32-bit, then how does the CAS function work in std :: atomic &lt;T&gt;?  CAS and all other functions will automatically use the lock (std :: mutex or some other) contained in the standard implementation of std :: atomic &lt;T&gt;, for T - trivially copyable types. <br><br>  For the atomic change of several variables - we can use the structure of the variables struct T {int price, count, total;  };  as the type for the std :: atomic &lt;T&gt; template. <br>  Example: [5] <a href="http://coliru.stacked-crooked.com/a/bdfb3dc440eb6e51">coliru.stacked-crooked.com/a/bdfb3dc440eb6e51</a> <br><blockquote>  Example output: 10, 7, 70 </blockquote><br>  In this example, the last value 70 at any time will be equal to the product of the first two values ‚Äã‚Äã10 * 7 - i.e.  the whole structure changes only atomically. <br><br>  This gcc and clang code for x86 must be compiled with the -latomic flag <br>  In addition, each call to std :: atomic &lt;T&gt; shared_val;  will cause a lock inside it, as indicated by the value of the function shared_val.is_lock_free () == false. <br><br>  Those.  Globally, we used optimistic locking (loop), and locally used 2 pessimistic locks when accessing an atomic variable: getting the old value and calling the CAS function. <br><br>  <b>(1) Lock-based.</b> <br>  But we will not be able to use std :: atomic &lt;T&gt; for any type T created by you because of the mandatory condition ‚Äútrivially copyable‚Äù for type T. Of all STL containers, we can only use std :: array &lt;&gt;.  For example, we cannot use std :: atomic &lt;std :: map &lt;int, int &gt;&gt;, since  type std :: map &lt;&gt; is not trivially copyable, for any arguments of its template.  And your own classes most likely cannot be used as a type T for std :: atomic &lt;T&gt; either. <br><br>  In this case, you will have to create the mutex objects yourself, block them each time before using shared objects and unlock them later.  Concept: <a href="http://en.cppreference.com/w/cpp/concept/Mutex">en.cppreference.com/w/cpp/concept/Mutex</a> . <br><br>  C ++ has the following mutexes: std :: mutex, std :: recursive_mutex, std :: timed_mutex, std :: recursive_timed_mutex, std :: shared_timed_mutex, std :: shared_mutex.  Read more about them here: <a href="http://en.cppreference.com/w/cpp/thread">en.cppreference.com/w/cpp/thread</a> . <br><br>  For example, we create any object shared by streams between std :: map &lt;int, T&gt; and create a mutex protecting it, then pass references to them in several streams.  And in each thread we block the mutex before using the shared object: [6] <a href="http://coliru.stacked-crooked.com/a/a97e905d54ae1fbb">coliru.stacked-crooked.com/a/a97e905d54ae1fbb</a> . <br><br>  And we block using RAII idioms: std :: lock_guard &lt;std :: mutex&gt; lock (mtx);  - when creating this object, its constructor locks the mutex, and at the end of the object‚Äôs life, the destructor unlocks the mutex.  Thus, we will not forget to unblock it, because  The destructor will be called automatically. <br><br>  But there are still 4 main problems: <br><br><ol><li>  Deadlocks - if you write the code so that stream-1 blocks mtx1, and stream-2 blocks mtx2, and holding blocking thread-1 will try to capture mtx2, and stream-2 will try to capture mtx1, then these threads will wait for each other forever.  Lock-free algorithms are deprived of this problem, but not any logic can be implemented with the help of lock-free - we will show this using an example of coordinated atomic change of several containers. </li><li>  If you write the code so that while the mutex is locked, you assign a reference to the shared object to the pointer, whose life is longer than that of the std :: lock_guard lock, then after removing the lock you can refer to the shared object using this pointer - this will lead to Data races i.e.  to the non-consistent state of the shared object and to the incorrect operation or crash of the program.  The same will happen if the iterator received from the shared object will be used after unlocking the mutex. </li><li>  You can confuse mutexes and block a mutex that protects another object - Data races. </li><li>  You can just forget to lock the mutex in the right place - Data races. </li></ol><br><h2>  <b>Execute Around Pointer Idiom</b> </h2><br>  In addition to RAII idioms, there is another interesting idiom - Execute Around Pointer, which will help to cope with the last two problems: <br><br><ol><li>  The mutex will be merged with your object, and you will not be able to block a separate mutex, but your object itself. </li><li>  The mutex will be blocked automatically when accessing any member of the class of the protected object ‚Äî and it will be blocked for the entire duration of the expression. </li></ol><br>  As a result, you will not be able to forget to block the mutex, and you will not be able to confuse mutexes. <br><br><h2>  <b>Making any object thread safe</b> </h2><br>  Execute Around Pointer Idiom is a long-known idiom with a strictly defined order of execution, used for various purposes from visualization to logging: <a href="https://en.wikibooks.org/wiki/More_C%252B%252B_Idioms/Execute-Around_Pointer">en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Execute-Around_Pointer</a> <br>  Example: [7] <a href="http://coliru.stacked-crooked.com/a/4f3255b5473c73cc">coliru.stacked-crooked.com/a/4f3255b5473c73cc</a> <br><br><pre> <code class="cpp hljs"> execute_around&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; vecc(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = my_accumulate(vecc-&gt;begin(), vecc-&gt;end(), <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  First, temporary objects of the proxy type will be created that block the mutexes inside execute_around, then iterators returned by the begin () and end () functions will be passed to the function, then the my_accumulate () function will be executed, and only after its completion will temporary objects of the proxy type be deleted , and their destructors unlock mutexes. <br><br>  Read more in the article: <b>C ++ Patterns Executing Around Sequences.</b>  <b>Kevlin Henney</b> : <a href="http://hillside.net/europlop/HillsideEurope/Papers/ExecutingAroundSequences.pdf">hillside.net/europlop/HillsideEurope/Papers/ExecutingAroundSequences.pdf</a> <br>  In C ++, there are two definitions that strictly define the order of operations of Standard ¬ß 1.9 (13): sequenced before and sequenced after.  In the standard quotes below, you will see ‚Äúsequenced before‚Äù 2 times. <br><br>  The principle and sequence of execution of all actions in Execute Around Pointer Idiom are strictly described in the C ++ <b>Standard Draft Standard for C ++ N4606 Standard Programming Language 2016-07-12</b> : <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf">www.open-std.org/jtc1/sc22/wg21/docs/papers/2016 /n4606.pdf</a> <br>  First we give five quotes from the standard, and then we will show how each of the quotes explains the behavior of Execute Around Pointer Idiom. <br><br>  1. For all types of T other than raw-pointers: x-&gt; m is interpreted as (x.operator -&gt; ()) -&gt; m.  Those.  expression (x-&gt; m) will unfold multiple times ((x.operator -&gt; (). operator -&gt; ()) -&gt; m until we get a raw pointer. An example with three expressions identical in meaning: [8] <a href="http://coliru.stacked-crooked.com/a/dda2474024b78a0b">coliru. stacked-crooked.com/a/dda2474024b78a0b</a> <br><blockquote>  <b>¬ß 13.5.6</b> <br>  operator-&gt; shall be a non-static member function taking no parameters.  It implements the class member access syntax that uses -&gt;. <br>  postfix-expression -&gt; template opt id-expression <br>  postfix-expression -&gt; pseudo-destructor-name <br>  An expression x-&gt; m is interpreted as (x.operator -&gt; ()) -&gt; m for a class object by the overload resolution mechanism (13.3). </blockquote><br>  2. When a function is called, even if it is ‚Äúinline,‚Äù absolutely any calculations and effects from expressions that calculate the function's arguments are executed before the function body begins to execute. <br><blockquote>  <b>¬ß 1.9 / 16</b> <br>  If you are calling on a line, it‚Äôs called function. </blockquote><br>  3. The entire expression is completely executed before the temporary object is destroyed. <br><blockquote>  <b>¬ß 1.9 / 10</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (S(<span class="hljs-number"><span class="hljs-number">3</span></span>).v()) <span class="hljs-comment"><span class="hljs-comment">// full-expression includes lvalue-to-rvalue and // int to bool conversions, performed before // temporary is deleted at end of full-expression { } }</span></span></code> </pre> </blockquote><br>  4. After the entire expression is completely executed, the temporary objects are destroyed in the reverse order of the order in which they were created. <br><blockquote>  <b>¬ß 1.9 Footnote 8</b> <br>  It has been determined that it has been determined that it has been defined as </blockquote><br>  5. Three cases when the temporary object is not destroyed at the end of the whole expression - 2 cases when the array elements are initialized, but the 3rd case when the reference to the temporary object is created. <br><blockquote>  <b>¬ß 12.2 Temporary objects</b> <br>  <b>¬ß 12.2 / 5</b> <br>  <b>There are three contexts in which they can be destroyed.</b>  An initial context (8.6).  The second context is where the copy is used (5.1.5, 12.8).  In the case of the next array element, it should be  The third context is when a reference is bound to a temporary. </blockquote><br><br>  For example, we have a simplified class execute_around &lt;&gt; <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> mutex_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::recursive_mutex&gt; class execute_around { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;mutex_type&gt; mtx; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; p; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ mtx-&gt;lock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ mtx-&gt;unlock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">proxy</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;mutex_type&gt; lock; T *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: proxy (T * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _p, mutex_type&amp; _mtx) : lock(_mtx), p(_p) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"locked \n"</span></span>;} proxy(proxy &amp;&amp;px) : lock(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(px.lock)), p(px.p) {} ~proxy () { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"unlocked \n"</span></span>; } T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -&gt; () {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p;} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -&gt; () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p;} }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; execute_around (Args ... args) : mtx(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;mutex_type&gt;()), p(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;T&gt;(args...)) {} proxy <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -&gt; () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> proxy(p.get(), *mtx); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> proxy <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> -&gt; () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> proxy(p.get(), *mtx); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">friend</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:lock_guard; };</code> </pre> <br>  And we use our sample execute_around &lt;&gt; class as follows, example: [45] <a href="http://coliru.stacked-crooked.com/a/d2e02b61af6459f5">coliru.stacked-crooked.com/a/d2e02b61af6459f5</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> execute_around&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; T; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vecc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = my_accumulate(vecc-&gt;begin(), vecc-&gt;end(), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Then the last expression can be converted to the following form through several transformations. <br><br>  1. According to the 1st quotation of the standard, x-&gt; m is interpreted as (x.operator -&gt; ()) -&gt; m: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = my_accumulate( (vecc.<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;())-&gt;begin(), (vecc.<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;())-&gt;end(), <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  2. Since  vecc.operator -&gt; () returns a temporary object T :: proxy (), we get: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = my_accumulate( T::proxy(vecc.p.get(), *vecc.mtx)-&gt;begin(), T::proxy(vecc.p.get(), *vecc.mtx)-&gt;end(), <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  3. Further, according to quotes 2, 3 and 4, temporary objects of proxy type will be created before the function starts to be executed and will be destroyed after the end of the function (after the end of the whole expression): <br><br><pre> <code class="cpp hljs">T::<span class="hljs-function"><span class="hljs-function">proxy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vecc.p.get(), *vecc.mtx)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// lock-1 std::recursive_mutex T::proxy tmp2(vecc.p.get(), *vecc.mtx); // lock-2 std::recursive_mutex int res = my_accumulate(tmp1-&gt;begin(), tmp2-&gt;end(), 0); tmp2.~ T::proxy(); // unlock-2 std::recursive_mutex tmp1.~ T::proxy(); // unlock-1 std::recursive_mutex</span></span></code> </pre> <br>  4. According to the 1st quotation again: <br>  ‚Ä¢ tmp1-&gt; begin () is equivalent to (tmp1.operator -&gt; ()) -&gt; begin () <br>  ‚Ä¢ tmp1.operator -&gt; () returns p <br>  As a result, we get where p is a shared_ptr pointer to our object of type std :: vector: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> execute_around&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; T; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vecc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; T::<span class="hljs-function"><span class="hljs-function">proxy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vecc.p.get(), *vecc.mtx)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// lock-1 std::recursive_mutex T::proxy tmp2(vecc.p.get(), *vecc.mtx); // lock-2 std::recursive_mutex int res = my_accumulate(tmp1.p-&gt;begin(), tmp2.p -&gt;end(), 0); tmp2.~ T::proxy(); // unlock-2 std::recursive_mutex tmp1.~ T::proxy(); // unlock-1 std::recursive_mutex</span></span></code> </pre> <br><br>  In 4 steps, we have described a strict sequence of all actions of the idiom.  Note that the standard does not guarantee the mutual order of creating temporary variables tmp1 and tmp2, i.e.  tmp2 can be created first and then tmp1, but this does not change the logic of our program. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that we did not refer to the fifth quotation of the standard, since </font><font style="vertical-align: inherit;">It describes 3 cases in which the time of removal of an object may differ from the given one, and as we see, none of these cases can correspond to ours. </font><font style="vertical-align: inherit;">The first 2 cases in the standard citation are initialization or copying of an array, they shorten the life of a temporary object, and the 3rd case is the extension of the life of a temporary object due to the presence of a reference to it.</font></font><br><br><h2> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread safe associative array</font></font></b> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agree, it would be convenient to have such a template class safe_ptr &lt;&gt; in which you can pass any type, and as a result get a thread-safe result type? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">safe_ptr &lt;std :: map &lt;std :: string, std :: pair &lt;std :: string, int&gt; &gt;&gt; safe_map_strings; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then you can work with this object as with a pointer to an associative array: std :: shared_ptr &lt;std :: map &lt;std :: string, std :: pair &lt;std :: string, int&gt; &gt;&gt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But now we can safely work with them from different streams, and each individual expression will be thread-safe:</font></font><br><br><pre> <code class="cpp hljs"> (*safe_map_strings)[<span class="hljs-string"><span class="hljs-string">"apple"</span></span>].first = <span class="hljs-string"><span class="hljs-string">"fruit"</span></span>; (*safe_map_strings)[<span class="hljs-string"><span class="hljs-string">"potato"</span></span>].first = <span class="hljs-string"><span class="hljs-string">"vegetable"</span></span>; safe_map_strings-&gt;at(<span class="hljs-string"><span class="hljs-string">"apple"</span></span>).second = safe_map_strings-&gt;at(<span class="hljs-string"><span class="hljs-string">"apple"</span></span>).second * <span class="hljs-number"><span class="hljs-number">2</span></span>; safe_map_strings-&gt;find(<span class="hljs-string"><span class="hljs-string">"potato"</span></span>)-&gt;second.second++;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a fully working example of a thread-safe associative: std :: map &lt;&gt;. [9] </font></font><br> <a href="http://coliru.stacked-crooked.com/a/5def728917274b22"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coliru.stacked-crooked.com/a/5def728917274b22</font></font></a> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;memory&gt; #include &lt;mutex&gt; #include &lt;thread&gt; #include &lt;map&gt; template&lt;typename T, typename mutex_t = std::recursive_mutex, typename x_lock_t = std::unique_lock&lt;mutex_t&gt;, typename s_lock_t = std::unique_lock&lt;mutex_t &gt;&gt; class safe_ptr { typedef mutex_t mtx_t; const std::shared_ptr&lt;T&gt; ptr; std::shared_ptr&lt;mutex_t&gt; mtx_ptr; template&lt;typename req_lock&gt; class auto_lock_t { T * const ptr; req_lock lock; public: auto_lock_t(auto_lock_t&amp;&amp; o) : ptr(std::move(o.ptr)), lock(std::move(o.lock)) { } auto_lock_t(T * const _ptr, mutex_t&amp; _mtx) : ptr(_ptr), lock(_mtx){} T* operator -&gt; () { return ptr; } const T* operator -&gt; () const { return ptr; } }; template&lt;typename req_lock&gt; class auto_lock_obj_t { T * const ptr; req_lock lock; public: auto_lock_obj_t(auto_lock_obj_t&amp;&amp; o) : ptr(std::move(o.ptr)), lock(std::move(o.lock)) { } auto_lock_obj_t(T * const _ptr, mutex_t&amp; _mtx) : ptr(_ptr), lock(_mtx){} template&lt;typename arg_t&gt; auto operator [] (arg_t arg) -&gt; decltype((*ptr)[arg]) { return (*ptr)[arg]; } }; void lock() { mtx_ptr-&gt;lock(); } void unlock() { mtx_ptr-&gt;unlock(); } friend struct link_safe_ptrs; template&lt;typename mutex_type&gt; friend class std::lock_guard; //template&lt;class... mutex_types&gt; friend class std::lock_guard; // C++17 public: template&lt;typename... Args&gt; safe_ptr(Args... args) : ptr(std::make_shared&lt;T&gt;(args...)), mtx_ptr(std::make_shared&lt;mutex_t&gt;()) {} auto_lock_t&lt;x_lock_t&gt; operator -&gt; () { return auto_lock_t&lt;x_lock_t&gt;(ptr.get(), *mtx_ptr); } auto_lock_obj_t&lt;x_lock_t&gt; operator * () { return auto_lock_obj_t&lt;x_lock_t&gt;(ptr.get(), *mtx_ptr); } const auto_lock_t&lt;s_lock_t&gt; operator -&gt; () const { return auto_lock_t&lt;s_lock_t&gt;(ptr.get(), *mtx_ptr); } const auto_lock_obj_t&lt;s_lock_t&gt; operator * () const { return auto_lock_obj_t&lt;s_lock_t&gt;(ptr.get(), *mtx_ptr); } }; // --------------------------------------------------------------- safe_ptr&lt;std::map&lt;std::string, std::pair&lt;std::string, int&gt; &gt;&gt; safe_map_strings_global; void func(decltype(safe_map_strings_global) safe_map_strings) { //std::lock_guard&lt;decltype(safe_map_strings)&gt; lock(safe_map_strings); (*safe_map_strings)["apple"].first = "fruit"; (*safe_map_strings)["potato"].first = "vegetable"; for (size_t i = 0; i &lt; 10000; ++i) { safe_map_strings-&gt;at("apple").second++; safe_map_strings-&gt;find("potato")-&gt;second.second++; } auto const readonly_safe_map_string = safe_map_strings; std::cout &lt;&lt; "potato is " &lt;&lt; readonly_safe_map_string-&gt;at("potato").first &lt;&lt; " " &lt;&lt; readonly_safe_map_string-&gt;at("potato").second &lt;&lt; ", apple is " &lt;&lt; readonly_safe_map_string-&gt;at("apple").first &lt;&lt; " " &lt;&lt; readonly_safe_map_string-&gt;at("apple").second &lt;&lt; std::endl; } int main() { std::vector&lt;std::thread&gt; vec_thread(10); for (auto &amp;i : vec_thread) i = std::move(std::thread(func, safe_map_strings_global)); for (auto &amp;i : vec_thread) i.join(); std::cout &lt;&lt; "end"; int b; std::cin &gt;&gt; b; return 0; }</span></span></span></span></code> </pre> <br><blockquote>  Conclusion: <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">potato is vegetable 65042, apple is fruit 65043 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">potato is vegetable 81762, apple is fruit 81767 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">potato is vegetable 84716, apple is fruit 84720 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">potato is vegetable 86645, apple is fruit 86650 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">potato is vegetable 90288, apple is fruit 90291 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">potato is vegetable 93070, apple is fruit 93071 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">potato is vegetable 93810, apple is fruit 93811 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">potato is vegetable 95788, apple is fruit 95790 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">potato is vegetable 98951, apple is fruit 98952 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">potato is vegetable 100000, apple is fruit 100000</font></font><br>  end </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From here 2 conclusions: </font></font><br><br><ol><li>    100000 ,       10    -. ,    ,  operator -&gt;        <b>auto_lock_t</b>  <b>auto_lock_obj_t</b> ,   ,         - ‚Äì data-race: [10] <a href="http://coliru.stacked-crooked.com/a/45d47bcb066adf2e">coliru.stacked-crooked.com/a/45d47bcb066adf2e</a> </li><li>     10000   ,      , ..            .  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before each increment operator ++ blocked the mutex, and immediately after the increment it was unlocked, and then the mutex could be blocked by another thread that executed the increment. </font><font style="vertical-align: inherit;">At the beginning of each thread, we can immediately block the mutex until the end of the execution of the stream function using </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: lock_guard</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;&gt;, and see what the result would be if the threads were executed sequentially rather than pseudo- </font><a href="http://coliru.stacked-crooked.com/a/cc252270fa9f7a78"><font style="vertical-align: inherit;">parallel</font></a><font style="vertical-align: inherit;"> : [11] </font></font><a href="http://coliru.stacked-crooked.com/a/cc252270fa9f7a78"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coliru.stacked-crooked.com/ a / cc252270fa9f7a78</font></font></a> </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Both findings confirm that our smart pointer class template safe_ptr &lt;T&gt; automatically ensures the flow-safety of the protected object of type T. </font></font><br><br><h2> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flow safety, atomicity and consistency of several objects.</font></font></b> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We show how to atomically change several objects at once so that their consistency is preserved. </font><font style="vertical-align: inherit;">And we will show when it is needed, how to do it and what happens if this is not done. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's give a simplified example, let's say we have 2 tables:</font></font><br><br><img src="https://hsto.org/web/6a4/573/aa9/6a4573aa9dd54722965d7de7732bf825.jpg" alt="image"><br><ol><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">user_accounts (INT user_id, STRING user_name, INT money)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a table with the amount of money for each client - sorted by the user_id field</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cash_flows (INT unique_id, INT src_id, INT dst_id, INT time, INT money)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a table showing the movement of money - each entry is referenced by two associative arrays sorted: by src_id field and by dst_id field</font></font></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1-st table struct user_accounts_t { std::string user_name; int64_t money; user_accounts_t(std::string u, int64_t m) : user_name(u), money(m) {} }; std::map&lt;uint64_t, user_accounts_t&gt; user_accounts; // 2-nd table struct cash_flows_t { uint64_t unique_id, src_id, dst_id, time; int64_t money; }; std::atomic&lt;uint64_t&gt; global_unique_id; // SQL-sequence std::multimap&lt;uint64_t, std::shared_ptr&lt;cash_flows_t&gt;&gt; cash_flows_src_id; std::multimap&lt;uint64_t, std::shared_ptr&lt;cash_flows_t&gt;&gt; cash_flows_dst_id;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In terms of a DBMS (RDBMS): </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The 1st table with an index for the user_id field is the Index-Organized-Table (Oracle) or Table with Clustered Index (MS SQL). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The 2nd table is a table with two ordered indexes with one src_id field and one dst_id field, respectively. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In real tasks, the table can contain millions of records for clients and billions of records for cash flow; in this case, the indices for the user_id, src_id, dst_id fields speed up the search for them hundreds of thousands of times, so they are urgently needed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose from three users send requests to perform three tasks in three parallel streams: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">move_money ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the stream transfers money from one client to another</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a) takes away money from one client </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> b) add the same amount of money to another client </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c) in the index on the field id-source adds a pointer to the cash transaction </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d) in the index on the id-destination field adds a pointer to the same cash transaction (in real tasks this is not necessary, but for example we will do it) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">show_total_amount ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - show the amount of money of all customers</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a) In the cycle we go through each client and summarize all the money. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">show_user_money_on_time ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - show the amount of client money with the specified user_id at the time point</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a) incoming - summarize all the money that came to the client from the time and later (using the index on the id-source field) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> b) outcoming - we summarize all the money that has left the client since time and later (using the index on the id-destination field) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c) user_money - get the current money from the client </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d) user_ user_money - incoming + outcoming is the amount of customer money at the time. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We know that any of the threads can be interrupted at any time by the operating system, for example, to give the CPU-Core to another thread. The most dangerous thing is that it happens extremely rarely and you may never meet with it when debugging, but one day it will happen at the client, and if this results in data-races, then the money may simply disappear in the financial system. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, we will deliberately add wait functions that put the stream to sleep for a few milliseconds in the most critical places to see the errors immediately. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will make our user_accounts, cash_flows_src_id, cash_flows_dst_id tables safe-safe using safe_ptr &lt;&gt;, but will the entire program become safe from this? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[12] </font></font><a href="http://coliru.stacked-crooked.com/a/5bbba59b63384a2b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coliru.stacked-crooked.com/a/5bbba59b63384a2b</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Look at the "main lines" in the output of the program, labeled &lt;&lt;&lt;: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Init table safe_user_accounts: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at time = 0 &lt;&lt;&lt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 =&gt; John Smith, 100 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 =&gt; John Rambo, 150 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- start transaction ... show_total_amount () </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 =&gt; John Smith, 100 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 =&gt; John Rambo, 100 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Result: all accounts total_amount = 200 &lt;&lt;&lt; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- start transaction ... show_user_money_on_time () </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 =&gt; John Smith, 150, at time = 0 &lt;&lt;&lt;</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Two errors are immediately visible: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initially, the sum of all (two) users had 250 money, and the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">show_total_amount ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">showed only 200, another 50 disappeared somewhere</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the time point, time = 0, user 1 had 100 money, and the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">show_user_money_on_time ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">showed an incorrect result ‚Äî user 1 had 150 money at time = 0</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem is that atomicity is observed only at the level of individual tables and indexes, but not in the aggregate, therefore consistency is violated. </font><font style="vertical-align: inherit;">The solution is to lock all used tables and indexes for the duration of all operations that must be performed atomically - this will preserve consistency. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Added lines are highlighted in yellow. </font></font><br><br><img src="https://hsto.org/web/9a9/73a/e2b/9a973ae2b9494308874bf812e09133d2.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correct example: [13] </font></font><a href="http://coliru.stacked-crooked.com/a/c8bfc7f5372dfd0c"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coliru.stacked-crooked.com/a/c8bfc7f5372dfd0c</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's look at the "main lines" in the output of the program, labeled &lt;&lt;&lt;:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Init table safe_user_accounts: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at time = 0 &lt;&lt;&lt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 =&gt; John Smith, 100 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 =&gt; John Rambo, 150 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Result: all accounts total_amount = 250 &lt;&lt;&lt; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 =&gt; John Smith, 100, at time = 0 &lt;&lt;&lt;</font></font></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now everything is correct, the amount of money of all customers is 250, and the amount of money from customer 1 was 100 at time 0. </font></font><br><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we were able to atomically perform operations not with one object, but immediately with 3 objects, while maintaining consistency of data for any operations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But there may be another problem. </font><font style="vertical-align: inherit;">If you or another developer in some of the functions block container mutexes in a different order, then a situation called deadlock is possible - when 2 threads hang forever waiting for each other. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the correct example above, we blocked mutexes in both the move_money () and show_user_money_on_time () functions in the same order:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lock1 (safe_user_accounts) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lock2 (safe_cash_flows_src_id) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lock3 (safe_cash_flows_dst_id) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's see what happens if we block the mutexes in the containers in each function in a different order: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ move_money ()</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lock2 (safe_cash_flows_src_id)</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lock3 (safe_cash_flows_dst_id) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lock1 (safe_user_accounts) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ show_user_money_on_time () </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lock3 (safe_cash_flows_dst_id) </font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lock2 (safe_cash_flows_src_id)</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lock1 (safe_user_accounts) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The move_money () function has locked lock2 and waits until lock3 is released to lock it. </font><font style="vertical-align: inherit;">The show_user_money_on_time () function has locked lock3 and waits until lock2 is released to lock it. </font><font style="vertical-align: inherit;">And they will wait for each other forever. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example: [14] </font></font><a href="http://coliru.stacked-crooked.com/a/0ddcd1ebe2be410b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coliru.stacked-crooked.com/a/0ddcd1ebe2be410b</font></font></a> <br><br>  Conclusion: <br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Init table safe_user_accounts: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at time = 0 &lt;&lt;&lt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 =&gt; John Smith, 100 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 =&gt; John Rambo, 150 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- start transaction ... move_money () </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- start transaction ... show_total_amount () </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 =&gt; John Smith, 100 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 =&gt; John Rambo, 150</font></font></blockquote><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">move_money ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">show_user_money_on_time ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> functions </font><font style="vertical-align: inherit;">were not completed and stopped forever at deadlock. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solutions are 4: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All developers in all functions always block mutexes in the same order and never make mistakes ‚Äî this is a very unreliable assumption </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You initially combine all the objects that will be used atomically into one structure, and use a safe pointer with the type of this structure struct all_t {std :: map &lt;int, int&gt; m1; std :: multimap &lt;int, int&gt; m2; ...}; safe_ptr &lt;all_t&gt; safe_all_obj; - but if you initially used these 2 containers only separately safe_ptr &lt;map &lt;int, int &gt;&gt; m1; safe_ptr &lt;multimap &lt;int, int &gt;&gt; m2; and have already written a lot of code, and then decided to combine them into one structure protected by one mutex, then you have to rewrite all the places where you use them, for example, instead of m2-&gt; at (5); need safe_all_obj-&gt; m2.at (5); To rewrite a lot of code is not very convenient. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can combine safe_ptr &lt;&gt; once together, so that they use the same recursive mutex, after which it will not matter in what order they are blocked, the consistency of these objects will always be preserved and never deadlock. To do this, you only need to add 1 line - it is very convenient. But it can reduce performance, because now locking one of the containers always results in locking all containers associated with it. You will get consistency even when it is not needed - at the cost of reduced performance. Example: [15] </font></font><a href="http://coliru.stacked-crooked.com/a/2a6f1535e0b95f7b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coliru.stacked-crooked.com/a/2a6f1535e0b95f7b</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All changes in the code are just one line: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static link_safe_ptrs tmp_link (safe_user_accounts, safe_cash_flows_src_id, safe_cash_flows_dst_id);</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusion - the main lines are shown: </font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Init table safe_user_accounts: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at time = 0 &lt;&lt;&lt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 =&gt; John Smith, 100 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 =&gt; John Rambo, 150 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Result: all accounts total_amount = 250 &lt;&lt;&lt; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 =&gt; John Smith, 100, at time = 0 &lt;&lt;&lt;</font></font></blockquote><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can use locking for several mutexes of different types at once with setting timeout for locking each mutex. </font><font style="vertical-align: inherit;">And if it is not possible to block at least one of the mutexes during this time, then all previously blocked mutexes will be unblocked, the thread will wait for some time and will try to block all mutexes in turn again. </font><font style="vertical-align: inherit;">To do this, it is enough to add one line before each use of the containers </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lock_timed_any_infinity lock_all (safe_cash_flows_src_id, safe_cash_flows_dst_id, safe_user_accounts); </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and no matter in what order you block container mutexes. </font><font style="vertical-align: inherit;">Example: [16] </font></font><a href="http://coliru.stacked-crooked.com/a/93206f216ba81dd6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coliru.stacked-crooked.com/a/93206f216ba81dd6</font></font></a> <br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> even if we block mutexes in different sequences: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then when using lock_timed_any_infinity, deadlock does not occur: [17] </font></font><a href="http://coliru.stacked-crooked.com/a/7ac7640918228090"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coliru.stacked-crooked.com/a/7ac7640918228090</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in a similar example, when using lock_guard &lt;&gt;, deadlock occurs: [18] </font></font><a href="http://coliru.stacked-crooked.com/a/a281f90299771434"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coliru.stacked-crooked.com/a/a281f90299771434</font></font></a> </li></ul><br><img src="https://hsto.org/web/d68/c3c/b91/d68c3cb91ec34066943d3f7aa4fbe0a7.jpg" alt="image"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, with the help of locks, we solved the problem of composability ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composable</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) guaranteed without permanent deadlock: </font></font><a href="https://en.wikipedia.org/wiki/Lock_(computer_science)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://en.wikipedia.org/wiki/Lock_(computer_science)#Lack_of_composability</font></font></a> <br><br><h2> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composable and Deadlocks</font></font></b> </h2><br>  Since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">above, for thread-safety, we used locks, then our algorithms are called lock-based. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And is everything really good with the absence of deadlocks in lock-free containers, algorithms based on Transactional Memory, and whether there are deadlocks in modern DBMS: MSSQL (lock-based IL) and Oracle (multi-version concurrency control). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The lock-free algorithms do not allow atomic change of several containers at once. RDBMS (RDBMS) have all the same problems with the deadlock, as in the lock-based algorithms, and often solve them in the same way via lock timeouts or lock graphs. And the new transaction-safe section in the C ++ standard does not allow using sophisticated algorithms such as std :: map &lt;&gt;.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lock-free algorithms do not have the property Composable operations - the joint use of several lock-free algorithms. </font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">several lock-free data structures cannot be changed or read atomically at once. </font><font style="vertical-align: inherit;">For example, you can use lock-free containers of associative arrays from </font></font><a href="https://github.com/khizmax/libcds"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libCDS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and they will be individually thread safe. </font><font style="vertical-align: inherit;">But if you want to atomically execute operations with several lock-free containers at once and maintain consistency, then you cannot do this, because </font><font style="vertical-align: inherit;">their API does not provide functions of lock-free operations simultaneously on multiple containers. </font><font style="vertical-align: inherit;">While you are changing or reading one container, another will be changed at this time. </font><font style="vertical-align: inherit;">To avoid this, you will have to use locks, in this case, these will already be containers based on locks, which means that all the problems of lock-based algorithms, namely the possibility of deadlocks, will become common. </font><font style="vertical-align: inherit;">In addition, locks are sometimes used when using just one container:</font></font><br><br><ul><li> <a href="http://libcds.sourceforge.net/doc/cds-api/namespacecds_1_1sync.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libcds.sourceforge.net/doc/cds-api/namespacecds_1_1sync.html</font></font></a> </li><li> <a href="https://github.com/khizmax/libcds/tree/master/cds/lock"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/khizmax/libcds/tree/master/cds/lock</font></font></a> </li><li> <a href="https://github.com/khizmax/libcds/tree/master/cds/sync"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/khizmax/libcds/tree/master/cds/sync</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In transactional RDBMS such as MSSQL (lock-based) and Oracle (multi-version concurrency control), locks are also used, and that is why there are deadlocks problems that, for example, can be solved automatically by building a graph of locks and finding cyclic expectations, or through setting timeout lock </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">select col from tbl where id in (....) for update wait 30; </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the timeout has expired or deadlock is found in the blocking column, a rollback (rollback) of one of the transaction occurs - i.e. </font><font style="vertical-align: inherit;">cancellation of all changes that have already been made by this transaction, unlocking of everything that was blocked, and then you can try to complete the transaction from the very beginning (and so many times):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oracle Database Online Documentation 11g Release 1 (11.1) - Deadlocks: </font></font><a href="https://docs.oracle.com/cd/B28359_01/server.111/b28318/consist.htm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docs.oracle.com/cd/B28359_01/server.111/b28318/consist.htm#i5337</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oracle Locks: </font></font><a href="https://docs.oracle.com/cd/B28359_01/server.111/b28318/consist.htm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docs.oracle.com/cd/B28359_01/server.111 /b28318/consist.htm#i5249</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As you can see, exclusive incompatible locks are used by any expression: Insert / Update / Delete / Select-For-Update</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSSQL Detecting and Ending Deadlocks: </font></font><a href="https://technet.microsoft.com/en-us/library/ms178104(v%3Dsql.105).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://technet.microsoft.com/en-us/library/ms178104(v=sql.105).aspx</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MS SQL Locks: </font></font><a href="https://technet.microsoft.com/en-us/library/ms186396(v%3Dsql.105).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://technet.microsoft.com/en-us/ library / ms186396 (v = sql.105) .aspx</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In turn, Transactional Memory, unlike Lock-free containers, can atomically work with multiple containers / data. </font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transactional Memory has the property Composable operations. Inside, either pessimistic locks are used (with a probability of a deadlock conflict) or optimistic locks (with a greater probability of conflicting modifications with competitive modifications). And in case of any conflicts, the transaction is automatically canceled and repeated from the very beginning, which entails multiple repetitions of all operations - and this incurs a large overhead. These overheads are trying to reduce by creating a Hardware Transactional Memory at the CPU level, but so far there are no implementations showing acceptable performance, although Intel has already added Hardware Transactional Memory in the CPU Haswell. The C ++ standard also promises to include Transactional Memory, but only in the future, so far only as an experimental one and without the support of working with std :: map.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so far everything is beautiful only in theory. </font><font style="vertical-align: inherit;">But in the future it will most likely replace the synchronization methods we are used to</font></font><br><br>  <b>Total:</b> <br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lock-based</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algorithms are not compiled, if such a possibility is not built into when they are implemented, but this possibility can be implemented, and we have successfully implemented it in the previous sections.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lock-free</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algorithms are not compiled and linking them without locks is an overly complex task, and with locks such an algorithm is no longer lock-free and there is a risk of eternal deadlocks.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RDBMS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : MSSQL (lock-based IL) and Oracle (MVCC) - eternal deadlocks are possible, which are removed via lock graphs or timeouts</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The transactional memory</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the experimental part of the C ++ standard is so far limited to use only in the simplest algorithms and does not allow the use of algorithms such as in the methods of std :: map &lt;&gt; or more complicated.</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current conclusion:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the deadlock problem exists in all types of algorithms and systems showing high performance, where several data structures are involved simultaneously, and we have proposed 2 options for its solution for safe_ptr &lt;&gt;</font></font><br><br><ol><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static link_safe_ptrs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tmp_link (safe_user_accounts, safe_cash_flows_src_id, safe_cash_flows_dst_id); </font><font style="vertical-align: inherit;">- use one mutex for multiple containers</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lock_timed_any_infinity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lock_all (safe_cash_flows_src_id, safe_cash_flows_dst_id, safe_user_accounts); - use lock timeouts, and at the end of time unlock everything and try to lock again</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case when only 1 container and a recursive mutex are used for safe_ptr &lt;&gt;, then deadlock is impossible in safe_ptr &lt;&gt;, since </font><font style="vertical-align: inherit;">deadlock requires at least 2 recursive mutexes (or 1 non-recursive).</font></font><br><br><h2> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composable lock-based algorithms</font></font></b> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the general case, it is considered that lock-based programs are not composable (Composable), i.e. if you simply take 2 lock-based data structures and atomically change them in turn, you will not get a consistent state at any time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But above we easily put together three lock-based containers, how did we manage it? There is a slight clarification to this effect - highlighted in bold:</font></font><br><blockquote> Perhaps the most fundamental objection [...] is that lock-based programs do not compose: correct fragments may fail when combined. For example, consider a hash table with thread-safe insert and delete operations. Now suppose that we want to delete one item A from table t1, and insert it into table t2; but the intermediate state (in which neither table contains the item) must not be visible to other threads. <b>Unless the implementor of the hash table anticipates this need, there is simply no way to satisfy this requirement.</b> [...] In short, operations that are individually correct (insert, delete) cannot be composed into larger correct operations. </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄîTim Harris et al., ‚ÄúComposable Memory Transactions‚Äù, Section 2: Background, pg.2 [6] </font></font><br> <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2005/01/2005-ppopp-composable.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.microsoft.com/en-us/research/wp-content/uploads/2005/01/2005-ppopp- composable.pdf</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The fact is that the lock-based algorithms are not assembled, if such a possibility is not included in their implementation.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lock-based data structures are not compiled automatically, but they can be manually assembled, for example, like with the lock_timed_any_infinity class, if you have access to their mutexes for layout operations from the outside. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We implemented the lock-based template class safe_ptr &lt;T&gt; and in it for any type T we provided for the need to link and solve deadlocks using linking operations: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link_safe_ptrs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lock_timed_any_infinity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lock_timed_any_once</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So why did we choose locks and their pessimistic option?</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Locking is a standard mechanism for ensuring the security of operating systems and C ++. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With the help of locks, we can realize the composability and consistency of multiple data structures. </font></font></li><li>     deadlock      ,   ,      .        conflicting modifications,   ,    C++-       . </li><li> <b>Tom Kyte</b> is a Senior Technical Architect in Oracle's Server Technology Division ‚Äì      Oracle DB (Multi-Version Concurrency Control): <a href="https://asktom.oracle.com/pls/asktom/f%3Fp%3D100:11:0::::P11_QUESTION_ID:5771117722373">https://asktom.oracle.com/pls/asktom/f?p=100:11:0::::P11_QUESTION_ID:5771117722373</a> <br>   ,       Lockout  Deadlock   : <br><blockquote> <b>I am a huge fan of so called pessimistic locking</b> . The user has very clearly announced their intent to UPDATE THE DATA. The lockouts they refer to are easily handled with session timeouts (trivial) and the deadlock is so rare and would definitely be an application bug (in both Oracle and RDB). </blockquote></li><li> Deadlock ‚Äì  .   ,                ,   <b>lock_timed_any_infinity</b> . ,      ,  : <b>link_safe_ptrs</b>  <b>std::lock_guard</b> &lt;&gt;. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is also no need for automatic escalation of locks. </font><font style="vertical-align: inherit;">For example, Oracle DB never does this: </font></font><a href="https://docs.oracle.com/cd/B28359_01/server.111/b28318/consist.htm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docs.oracle.com/cd/B28359_01/server.111/b28318/consist.htm#CIHCFHGE</font></font></a> <br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oracle Database never escalates locks. </font><font style="vertical-align: inherit;">Lock escalation greatly increases the likelihood of deadlocks.</font></font></blockquote></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will continue to periodically refer to the rich experience of industrial DBMS in the implementation of our algorithms. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of using safe_ptr &lt;T&gt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from safe_ptr.h: </font></font><a href="https://github.com/AlexeyAB/object_threadsafe/tree/master/any_object_threadsafe"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/AlexeyAB/object_threadsafe/tree/master/any_object_threadsafe</font></font></a> <br><br><h3>  <b>Conclusion:</b> </h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We proved the correctness of Execute Around Pointer Idiom to automatically ensure secure access from different threads. </font><font style="vertical-align: inherit;">Showed an example of its composable. </font><font style="vertical-align: inherit;">And also showed the advantages of using pessimistic locks to ensure thread-safety.</font></font></div><p>Source: <a href="https://habr.com/ru/post/328348/">https://habr.com/ru/post/328348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328336/index.html">A caring look at IT jobs</a></li>
<li><a href="../328340/index.html">Realistic IT company strategies in crisis</a></li>
<li><a href="../328342/index.html">Researchers have learned to attack industrial robots. Thousands of them are available from the network.</a></li>
<li><a href="../328344/index.html">Startup of the day (April 2017)</a></li>
<li><a href="../328346/index.html">Bash scripts, part 10: practical examples</a></li>
<li><a href="../328352/index.html">Top 10 Mistakes Made by Django Developers</a></li>
<li><a href="../328354/index.html">Comparison of PVS-Studio C # and static analyzer built into Visual Studio based on the code of the CruiseControl.NET project</a></li>
<li><a href="../328356/index.html">As we did the third internship in iOS and Android development at Redmadrobot</a></li>
<li><a href="../328358/index.html">Fatty programs - we study the factor of memory part B</a></li>
<li><a href="../328360/index.html">Min-Long Chou: What I designed for Uncharted 4. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>