<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Basics of multithreading in the .NET Framework</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Multithreading is one of the most difficult topics in programming; there are always a lot of problems with it. Without a clear understanding of the in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Basics of multithreading in the .NET Framework</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d2f/b61/380/d2fb6138061447bf8bf5cc2daf7141c1.jpg"><br><br>  Multithreading is one of the most difficult topics in programming; there are always a lot of problems with it.  Without a clear understanding of the internal mechanisms, it will be very difficult to predict the outcome of an application using multiple threads.  We will not duplicate here the mass of theoretical information, which is very much in the network and smart books.  Instead, focus on the specific and most important issues that need special attention and be sure to keep them in mind during the development process. <br><a name="habracut"></a><br><h3>  Streams </h3><br>  As everyone probably knows, the thread in the .NET Framework is represented as a <i>Thread</i> class.  Developers can create new threads, give them meaningful names, change priority, start, wait for shutdown, or stop. <br><br>  Streams are divided into <i>background</i> (background) and <i>foreground</i> (the main one, the one in the foreground).  The main difference between them is that the <i>foreground</i> streams impede the end of the program.  As soon as all <i>foreground</i> streams are stopped, the system will automatically stop all <i>background</i> and terminate the application.  To determine whether a stream is background or not, the following property of the current stream must be called: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cs hljs">Thread.CurrentThread.IsBackground</code> </pre> <br><br>  By default, when creating a thread using the <i>Thread</i> class, we get the <i>foreground</i> stream.  In order to change it to the background, we can use the <i>thread.IsBackground</i> property. <br><br>  In applications that have a user interface (UI), there is always at least one main (GUI) thread that is responsible for the state of the interface components.  It is important to know that only this, the so-called ‚ÄúUI stream‚Äù, which is created for an application, usually in a single copy (although not always), can change the view state. <br><br>  It is also worth mentioning about exceptional situations that can occur in child threads.  In such a situation, the application will be terminated urgently, and we will get a <i>Unhandled Exception</i> , even if we wrap the startup code of the stream in a <i>try / catch block</i> .  In this case, error handling must be placed in the code of the child thread, in which it will be possible to respond to a specific exception. <br><br>  Using global exception handling ( <i>Application_Error</i> in ASP.NET, <i>Application.DispatcherUnhandledException</i> in WPF, <i>Application.ThreadException</i> in WinForms, etc.) it is important to remember that with this approach we will be able to ‚Äúcatch‚Äù exceptions that ONLY occurred in the UI stream, that is, we do not ‚Äúcatch‚Äù exceptions from additional background threads.  We can also use <i>AppDomain.CurrentDomain.UnhandledException</i> and hook into the process of processing all unhandled exceptions within the application domain, but we can‚Äôt prevent the application from terminating. <br><br>  Threads are expensive objects that take up memory, can use various system resources and are in different states.  To create them takes time.  Compared to processes, they are less resource-intensive, but still require fairly large costs of creation and destruction.  Moreover, the developer is responsible for releasing the resources held by a specific flow.  For example, to perform a mass of small tasks it is not efficient to start multiple threads, since the costs of starting them may exceed the benefit of use.  In order to be able to reuse already running threads and get rid of the creation costs, a so-called pool thread ( <i>ThreadPool</i> ) was introduced. <br><br><h3>  ThreadPool </h3><br>  Within each process, the CLR creates one additional abstraction called a thread pool.  It is a set of threads that are in standby mode and ready to perform any useful work.  When the application starts, the pool of threads starts the minimum number of threads that are in the state of waiting for new tasks.  If there are not enough active threads to efficiently perform tasks in the pool, it launches new ones and uses them according to the same reuse principle.  The pool is quite smart and is able to determine the required effective number of threads, as well as stop unnecessary or run additional ones.  You can set the maximum and minimum number of threads, but in practice this is rarely done. <br><br>  The threads inside the pool are divided into two groups: worker and I / O threads.  Workflows focus on work related to CPU loading (CPU based), while I / O flows focus on working with I / O devices: a file system, a network card, and others.  If you try to perform an I / O operation on a workflow (CPU based), then it will be a waste of resources, since the thread will be in a state of waiting for an I / O operation to complete.  Separate I / O streams are intended for such tasks.  When using a thread pool, this is hidden explicitly from the developers.  You can get the number of different threads in the pool using the code: <br><br><pre> <code class="cs hljs">ThreadPool.GetAvailableThreads(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> workerThreads, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> competitionPortThreads);</code> </pre> <br><br>  In order to determine whether the current thread is taken from a pool or created manually, you need to use the following construction: <br><br><pre> <code class="cs hljs">Thread.CurrentThread.IsThreadPoolThread</code> </pre> <br><br>  You can start a task using a stream taken in a pool using: <br><br><ul><li>  ThreadPool: ThreadPool.QueueUserWorkItem </li><li>  asynchronous delegates (a pair of delegate methods: BeginInvoke () and EndInvoke ()) </li><li>  BackgroundWorker class </li><li>  TPL (Task Parallel Library, which we'll talk about later) </li></ul><br>  The following constructs also use a thread pool, but they do it implicitly, which is important to know and remember: <br><br><ul><li>  WCF, Remoting, ASP.NET, ASMX Web Services </li><li>  <a href="http://www.albahari.com/threading/part3.aspx">System.Timers.Timer</a> and <a href="http://www.albahari.com/threading/part3.aspx">System.Threading.Timer</a> </li><li>  EAP (the event-based asynchronous pattern, let's talk about it later) </li><li>  PLINQ </li></ul><br>  It is useful to keep in mind the following points: <br><br><ul><li>  Threads from the pool cannot be assigned a name. </li><li>  Threads from the pool are always background. </li><li>  Blocking threads from the pool can lead to the launch of additional threads and performance degradation. </li><li>  You can change the priority of the thread from the pool, but it will return to the default value ( <i>normal</i> ) after returning to the pool </li></ul><br><br><h3>  Synchronization </h3><br>  When building a multi-threaded application, it is necessary to ensure that any part of the shared data is protected from the possibility of changing their values ‚Äã‚Äãby multiple threads.  Given that the managed heap is one of the resources shared by the threads, and all the threads in the <i>AppDomain</i> have concurrent access to the shared data of the application, it is obvious that access to such shared data must be synchronized.  This ensures that only one stream (or the specified amount, in the case of a Semaphore) will receive access to a specific block of code at a time.  Thus, we can guarantee the integrity of the data, as well as their relevance at any time.  Let's look at possible synchronization options and frequent problems.  Speaking of synchronization, usually there are 4 types: <br><br><ul><li>  Blocking calling code </li><li>  Constructions restricting access to pieces of code </li><li>  Signal Constructions </li><li>  Non-blocking lock </li></ul><br><h3>  Blocking </h3><br>  By locking is meant waiting for one thread to complete another or to be in standby mode for some time.  It is usually implemented using the methods of the class <i>Thread: Sleep ()</i> and <i>Join ()</i> , the method <i>EndInvoke () of</i> asynchronous delegates or using task ( <i>Task</i> ) and their waiting mechanisms.  The following constructs are examples of poor expectation approaches: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!proceed); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (DateTime.Now &lt; nextStartTime);</code> </pre><br><br>  Such designs require a lot of processor resources, although they do not do any useful work.  At the same time, the OS and CLR think that our thread is busy with performing important calculations and allocate the necessary resources for it.  This approach should always be avoided. <br><br>  A similar example would be the following construction: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!proceed) Thread.Sleep(<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><br>  Here, the calling thread periodically falls asleep for a short time, but it is sufficient for the system to switch contexts and perform other tasks in parallel.  This approach is much better than the previous one, but still not perfect.  The main problem arises at the moment when it is necessary to change the <i>proceed</i> flag from different threads.  Such a construction would be an effective solution if we expect the condition in the cycle to be satisfied in a very short time and entail a small number of iterations.  If there are many iterations, the system will need to constantly switch the context of this stream and spend additional resources on it. <br><br><h3>  Locking </h3><br>  Exclusive locking is used to ensure that only one thread will execute a particular piece of code.  This is necessary to ensure that the data is current at any time.  In the .NET Framework there are quite a few mechanisms that allow you to block access to parts of the code, but we consider only the most popular ones.  And at the same time we will analyze the most frequent errors associated with the use of such structures. <br><br><img src="https://habrastorage.org/files/c44/8a7/d1b/c448a7d1bb62483f91b91a176bb4e4c6.png"><br><br>  The table shows the most popular mechanisms for organizing locks.  Using Mutexes, interprocessor locking can be implemented (and not just for several threads of the same process).  A semaphore differs from Myutex in that it allows you to specify the number of threads or processes that can get simultaneous access to a particular section of code.  The lock construct, which is a call to a pair of methods: <i>Monitor.Enter ()</i> and <i>Monitor.Exit ()</i> , is used very often, so we will consider possible problems and recommendations for its use. <br><br>  Static members of classes that developers often operate on are always thread safe, and access to such data must be synchronized.  The only difference is the static constructor, since the CLR blocks all calls from third-party threads to the static members of the class until the static constructor completes its work. <br><br>  When using blocking with the lock keyword, keep in mind the following rules: <br><br><ul><li>  it is necessary to avoid blocking types: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)) {‚Ä¶}</code> </pre> <br>  &lt;The fact is that each type is stored in a single copy within the same domain and this approach may lead to deadlocks.  Therefore, you should avoid similar structures. </li><li>  You must avoid blocking this object: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {‚Ä¶}</code> </pre> <br>  This approach can also lead to a deadlock. </li><li>  As a synchronization object, you can use an additional field in a particular class: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lockObject) {‚Ä¶}</code> </pre> </li><li>  you need to use the Monitor.TryEnter construction (this.lockObject, 3000) when you are in doubt, and the stream can be blocked.  This design will allow you to exit the lock after a specified time interval. </li><li>  It is necessary to use the Interlocked class for atomic operations instead of similar constructions: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lockObject) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter++; }</code> </pre> </li></ul><br><br><h3>  Signaling </h3><br>  This mechanism allows the thread to stop and wait until it receives a notification from another thread about the possibility of continuing work. <br><br><img src="https://habrastorage.org/files/ea7/383/270/ea73832703724dd6b43e8e9fe74916fd.png"><br><br>  The table shows the most common designs that are used in the "signaling".  Using this approach will often be more effective than the previous ones. <br><br><h4>  Nonblocking synchronization </h4><br>  In addition to the mechanisms listed above, the .NET Framework provides constructs that can perform simple operations without blocking, stopping, or waiting for other threads.  Due to the absence of locks and context switching, the code will work faster, but it is very easy to make a mistake, which is fraught with difficult problems.  Ultimately, your code may become even slower than if you applied the common approach using <i>lock</i> .  One of the variants of such synchronization is the use of so-called memory barriers ( <i>Thread.MemoryBarrier ()</i> ), which impede optimization, caching of CPU registers and rearrangement of program instructions. <br><br>  Another approach is to use the <i>volatile</i> keyword, which marks the required class fields.  It causes the compiler to generate memory barriers every time it is read and written to a variable marked <i>volatile</i> .  This approach is good in the case when you have one stream, or some streams only read, while others only write.  If you need to read and modify in one stream, then you should use the <i>lock</i> operator. <br><br>  Both of the above possibilities are quite difficult to understand, they require clear knowledge of memory models and optimizations at different levels, and therefore are used quite rarely.  Yes, and they need to be applied very carefully and only when you understand what you are doing and why. <br><br>  The simplest and recommended approach for atomic operations is the use of the <i>Interlocked</i> class, which was mentioned above.  Behind the scenes, memory barriers are also generated, and we do not need to worry about additional locks.  This class has quite a few methods for atomic operations, such as increase, decrease, change, change with comparison, etc. <br><br><h4>  Collections </h4><br>  It is useful to know that in the <i>System.Collections.Concurrent</i> namespace, quite a lot of thread-safe collections are defined for different tasks.  The most common: <br><br>  BlockingCollection <br>  Concurrentbag <br>  ConcurrentDictionary &lt;TKey, TValue&gt; <br>  ConcurrentQueue <br>  Concurrentstack <br><br>  In most cases, there is no point in implementing your own such collection - it is much easier and wiser to use ready-made tested classes. <br><br><h3>  Asynchrony </h3><br>  Separately, I would like to highlight the so-called asynchrony, which, on the one hand, is always directly related to the launch of additional streams, and on the other, with additional questions and theory, which should also be discussed. <br><br>  Let us demonstrate the difference between synchronous and asynchronous approaches in a clear example. <br><br>  Suppose you want to eat pizza at the office and you have two options: <br><br>  1st, synchronous option: walk on foot to the pizzeria, choose the pizza you are interested in, make an order, wait until it is brought, get to the office with the pizza or have lunch directly at the pizzeria, after which you will return and continue to work.  In the process of walking and waiting for an order, you will be in standby mode and will not be able to do other useful work (for simplicity, it is understood here that the office work brings money and which you cannot perform outside the workplace). <br><br>  2nd, asynchronous option: order a pizza by phone.  After the order you are not blocked, you can perform useful work at the workplace while your order is being processed and delivered to the office. <br><br><h3>  Evolution </h3><br>  As the .NET Framework developed, there were many innovations and approaches for running asynchronous operations.  The first solution for asynchronous tasks was an approach called APM ( <i>Asynchronous Programming Model</i> ).  It is based on asynchronous delegates that use a pair of methods named <i>BeginOperationName</i> and <i>EndOperationName</i> , which respectively begin and end the asynchronous Operation <i>OperationName</i> .  After calling the <i>BeginOperationName</i> method <i>, the</i> application can continue executing instructions in the calling thread while an asynchronous operation is being performed in another.  For each call to the <i>BeginOperationName</i> method, the application must also have a call to the <i>EndOperationName</i> method to get the results of the operation. <br><br>  This approach can be found in a variety of technologies and classes, but it is fraught with complexity and redundancy of the code. <br><br>  In version 2.0, a new model was introduced called the <i>Event-based Asynchronous Pattern</i> (EAP).  A class that supports an asynchronous model based on events will contain one or more methods <i>MethodNameAsync</i> .  It can reflect synchronous versions that perform the same action with the current thread.  This class can also contain the Event <i>MethodNameCompleted</i> event and the <i>MethodNameAsyncCancel</i> method (or just <i>CancelAsync</i> ) to cancel the operation.  This approach is common when working with services.  In Silverlight, it is used to access the server side, and Ajax is essentially an implementation of this approach.  It is necessary to be afraid of long chains of related event calls, when, at the end of one long-term operation, the next, then the next, and so on, is called at the end of one long-term operation.  This is fraught with deadlocks and unexpected results.  Exception handling and results of an asynchronous operation are available only in the event handler through the corresponding parameter properties: <i>Error</i> and <i>Result</i> . <br><br>  In .NET Framework 4.0, an advanced model called <i>Task-based Asynchronous Model</i> (TAP) was introduced, which is task <i>-based</i> .  TPL and PLINQ are also built on them, but we'll talk about them in detail next time.  This implementation of the asynchronous model is based on the <i>Task</i> and <code>Task&lt;Result&gt;System.Threading.Tasks</code> , which are used to provide arbitrary asynchronous operations.  TAP is the recommended asynchronous pattern for developing new components.  It is very important to understand the difference between a thread ( <i>Thread</i> ) and a task ( <i>Task</i> ), which are very different.  <i>Thread</i> (thread) is an encapsulation of a thread of execution, while <i>Task</i> is a job (or simply an asynchronous operation) that can be executed in parallel.  To perform the task, a free thread from the thread pool is used.  Upon completion, the thread will be returned to the pool, and the class user will receive the result of the task.  If you need to start a lengthy operation and you do not want to block one of the pool threads for a long time, then you can do it using the <i>TaskCreationOptions.LongRunning</i> parameter.  You can create and run tasks in different ways, and it is often not clear which one to choose.  The difference is mainly only in ease of use and the number of parameters with settings that are available in one way or another. <br><br>  In the latest versions of the framework, new features have appeared based on the same tasks that simplify writing asynchronous code and make it more readable and understandable.  To do this, we have introduced new keywords <i>async</i> and <i>await</i> , which mark asynchronous methods and their calls.  Asynchronous code becomes very similar to synchronous: we simply call the desired operation and all code that follows its call will automatically be wrapped in a kind of callback that will be called after the completion of the asynchronous operation.  Also, this approach allows you to handle exceptions in a synchronous manner;  clearly wait for the completion of the operation;  determine the actions to be performed and the relevant conditions.  For example, we can add code that will be executed only if an exception was generated in an asynchronous operation.  But not everything is so simple, even despite the mass of information on this topic. <br><br><h3>  async \ await </h3><br>  Consider the basic guidelines for using these keywords, as well as some interesting examples.  Most often it is recommended to use asynchrony "from beginning to end."  This implies the use of only one approach in a particular call or function block; do not mix synchronous calls with asynchronous ones.  A classic example of this problem: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DeadlockDemo</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DelayAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayTask = DelayAsync(); delayTask.Wait(); } }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This code works fine in a console application, but when you call the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DeadlockDemo.Test ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">from a thread's GUI, a deadlock will occur. This is related to how </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> handles contexts. By default, when an incomplete </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is expected </font><font style="vertical-align: inherit;">, the current context is captured and used to resume the method when the task is completed. The context is the current </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , unless it is null, as is the case with console applications. There it is the current </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskScheduler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (thread pool context). GUI- and ASP.NET-applications have </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which allows you to execute only one piece of code at a time. When an </font><i><font style="vertical-align: inherit;">await</font></i><font style="vertical-align: inherit;"> expression</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completes execution, it tries to execute the rest of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method within the captured context. </font><font style="vertical-align: inherit;">But he already has a thread that (synchronously) waits for the completion of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method. </font><font style="vertical-align: inherit;">It turns out that each of them waits for each other, causing a deadlock. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also recommended to avoid constructions of the form </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async void</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (an asynchronous method that returns nothing). </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> methods can return </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><code>Task&lt;Result&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The last option was left for backward compatibility and allows you to add asynchronous event handlers. </font><font style="vertical-align: inherit;">But it is worth remembering about some specific differences of similar methods, namely:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exceptions can not be caught by standard means </font></font></li><li>      ,        .  ,             ,      <i>Task</i> . </li><li>    ,          . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Always try to configure the context whenever possible. </font><font style="vertical-align: inherit;">As already mentioned, the code inside the asynchronous method after calling </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will require the synchronization context in which it was called. </font><font style="vertical-align: inherit;">This is a very useful feature, especially in GUI applications, but sometimes it is not necessary. </font><font style="vertical-align: inherit;">For example, when code does not need to access user interface elements. </font><font style="vertical-align: inherit;">The previous example with deadlock can be easily corrected by changing just one line:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This recommendation is very relevant when developing any libraries that do not know anything about the GUI. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider a few more examples of the use of new keywords, as well as some features of their use: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1)</font></font><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.Write(<span class="hljs-string"><span class="hljs-string">"work"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> child = Test(); Console.Write(<span class="hljs-string"><span class="hljs-string">"started"</span></span>); child.Wait(); Console.Write(<span class="hljs-string"><span class="hljs-string">"finished"</span></span>); }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúWork‚Äù will appear on the screen first, then ‚Äústarted‚Äù, and only then ‚Äúfinished‚Äù. At first glance, it seems that the word "started" should be displayed first. Do not forget that in this code there is a problem with deadlock, which we considered. This is due to the fact that the method marked with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async keyword</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does not start additional threads and is processed synchronously until it encounters the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keyword inside </font><font style="vertical-align: inherit;">. Only after that a new </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object will be created </font><font style="vertical-align: inherit;">and a deferred task </font><font style="vertical-align: inherit;">will be </font><font style="vertical-align: inherit;">launched. To correct this behavior in the above example, it is enough to replace the line with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread.Sleep (...)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">await Task.Delay (...)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  2) <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Before"</span></span>); Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"After"</span></span>); }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can assume that we will expect 1 second before the second output to the screen, but this is not so - both messages will be displayed without delay. This is due to the fact that the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.Delay ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">, like many other asynchronous methods, returns an object of type Task, but we ignored this task. We do not expect it to be completed in any of the possible ways, which entails the immediate display of both messages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3)</font></font><br><pre> <code class="cs hljs">Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Before"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.StartNew(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"After"</span></span>);</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As in the previous example, the output to the screen will not be suspended for one second. </font><font style="vertical-align: inherit;">This is because the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StartNew ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">accepts the delegate and returns </font></font><code>Task&lt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where T is the type returned by the delegate. </font><font style="vertical-align: inherit;">In the example, our delegate returns a Task. </font><font style="vertical-align: inherit;">As a result, we get the result in the form </font></font><code>Task&lt;ask&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Using the word await ‚Äúexpects‚Äù only the completion of an external task, which immediately returns an internal Task created in the delegate, which is then ignored. </font><font style="vertical-align: inherit;">You can fix this problem by rewriting the code as follows:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); });</code> </pre> <br><br>  four) <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { TestAsync().Wait(); }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despite the use of keywords, this code is not asynchronous and runs synchronously, because we are creating a task and we are clearly awaiting its execution. </font><font style="vertical-align: inherit;">In this case, the calling thread is blocked and waits for the completion of the running task.</font></font><br><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, developers have quite a lot of opportunities to work with multi-threaded applications. It is important not only to know the theory, but also to be able to apply effective approaches to solving specific problems. For example, the use of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">almost unequivocally suggests that you have outdated code in the project, although the likelihood of having to use it is very small. In normal situations, the use of the pool is always justified, for obvious reasons. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The use of multithreading in applications with GUI usually entails additional restrictions, do not forget about them!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also worth remembering about other ready-made implementations, such as thread-safe collections. </font><font style="vertical-align: inherit;">This eliminates the writing of additional code and prevents possible implementation errors. </font><font style="vertical-align: inherit;">Well, do not forget about the features of new keywords.</font></font></div><p>Source: <a href="https://habr.com/ru/post/260745/">https://habr.com/ru/post/260745/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260733/index.html">The future of electronic signature</a></li>
<li><a href="../260735/index.html">Go as a language for learning programming</a></li>
<li><a href="../260737/index.html">Thunderstorm, lightning, and means of protection of the power grid on its own</a></li>
<li><a href="../260739/index.html">Sencha: About licenses and restrictions</a></li>
<li><a href="../260741/index.html">Getting started with OpenCV and its use in C #</a></li>
<li><a href="../260747/index.html">Black archeology date of mining</a></li>
<li><a href="../260749/index.html">Making homemade accessories for Dendy</a></li>
<li><a href="../260753/index.html">Collection and visualization of application metrics in Graphite and Graph-Explorer</a></li>
<li><a href="../260755/index.html">How the PVS-Studio team improved the Unreal Engine code</a></li>
<li><a href="../260757/index.html">How we made programming language from JSON</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>