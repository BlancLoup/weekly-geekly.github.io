<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multiplexed I / O</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preface 
 In this article, I would like to touch on important aspects of programming applications for the web, which should serve many users at the sa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multiplexed I / O</h1><div class="post__text post__text-html js-mediator-article"><h4>  Preface </h4><br>  In this article, I would like to touch on important aspects of programming applications for the web, which should serve many users at the same time, which means that we will analyze all the annoying asynchronous I / O, multiplexing, etc. <br>  The following objectives are pursued: <br><ol><li>  Systematize the material in this area, discuss some inconsistencies in terminology </li><li>  Fully disassemble the foundation on which applications for serving many clients are built </li><li>  Develop a strategy for a future python application that should serve many clients </li><li>  Create a clear picture in your head (no wonder they say you understand - when you can explain) </li></ol><br><br><a name="habracut"></a><br><h4>  What for? </h4><br>  Years of PHP programming have borne fruit - I never wondered what was going on behind the scenes.  But when the projects began to slow down but surely, I decided that it was time to take up the mind and began to study the python (which I am doing successfully now).  But since I am absolutely bored with all sorts of words like fork, socket, eventloop, multiprocessing, epoll, etc.  I decided to dig deeper.  What came out of it is up to you.  However, some confusion is present.  Confirmation of this can be found in the links [ <a href="http://stackoverflow.com/questions/2625493/asynchronous-vs-non-blocking">6</a> , <a href="http://www.developerfusion.com/article/28/introduction-to-tcpip/8/">7</a> ] <br><br><h4>  int main () </h4><br>  This article discusses I / O based on Linux OS version 2.6 and later.  Since the material is largely focused on people like me (the device for heating water is optionally equipped with a sounder), you will have to disassemble a lot of the basics, so just skip the items you do not need. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Basic concepts </h5><br>  <b>The file</b> is a fundamental abstraction in Linux.  Linux follows the ‚Äúeverything is a file‚Äù philosophy, which means most interaction is realized through reading and writing files.  File operations are performed using a unique descriptor - a file descriptor or fd.  Most of the Linux system programming is in working with file descriptors. <br>  There are <b>regular files</b> (regular file) - this is what we are used to (the usual ‚Äúfile‚Äù in the usual sense) and <b>special files</b> - these are some objects that are represented as files.  Linux supports 4 types of special files: <br><ul><li>  Block device files </li><li>  Character I / O device files </li><li>  Named pipelines (named pipe or FIFO) </li><li>  Sockets </li></ul><br>  The latter is precisely the sphere of our interests, because sockets provide communication between two different processes that can be located on different computers (client-server).  In fact, network programming and programming for the Internet is built on sockets. <br>  In the first approximation, it is enough to consider only regular files and sockets. <br><br><br><h5>  I / O models </h5><br>  A total of 5 + 1 different I / O models are available on Unix-like systems.  "Plus one" I will explain a little later, but for now let's consider each model in more detail. <br><br><h6>  Blocking I / O (blocking I / O) </h6><br>  By default, all input and output is performed in a blocking style.  Consider a schematic depiction of processes occurring during blocking I / O. <br><br><img src="https://habrastorage.org/files/fb1/76d/774/fb176d774ed54a47bd479743c43a3dc4.gif"><br><br>  In this case, the process makes the <i>recvfrom</i> system call.  As a result, the process is blocked (goes to sleep) until data arrives and the system call writes it to the application buffer. <br>  After that, the system call ends (return OK) and we can process our data. <br>  Obviously, this approach has a very big drawback - while we are waiting for data (and they can go for a very long time due to the quality of the connection, etc.), the process is asleep and does not respond to requests. <br><br><h6>  Nonblocking I / O (nonblocking I / O) </h6><br>  We can set a non-blocking mode when working with sockets, actually telling the kernel the following: ‚ÄúIf the I / O that we want to do is impossible without immersing the process in a lock (sleep), then give me an error that you can‚Äôt do without blocking.‚Äù a schematic representation of the processes occurring in non-blocking I / O. <br><br><img src="https://habrastorage.org/files/045/b65/4a0/045b654a0ed149ad853d1d4f4ca644f1.gif"><br><br>  The first three times that we send a system call for reading do not return a result, because  the kernel sees that there is no data and just returns the error EWOULDBLOCK. <br>  The last system call succeeds because  data is ready for reading.  As a result, the kernel writes the data to the process buffer and it becomes available for processing. <br>  On this basis, you can create a loop that constantly calls recvfrom (asks for data) for sockets opened in non-blocking mode.  This mode is called polling.  The application constantly polls the system kernel for data availability.  I basically do not see restrictions to interrogate several sockets sequentially and respectively read from the first, which has data.  This approach leads to large overheads (CPU time). <br><br><br><h6>  I / O multiplexing (multiplexing I / O) </h6><br>  In general, the word multiplexing translates as "seal."  I think it can be successfully described by the motto of time management - ‚Äúlearn to do more‚Äù.  When multiplexing I / O, we refer to one of the system call available in the OS (multiplexer such as select, poll, pselect, dev / poll, epoll (recommended for Linux), kqueue (BSD)) and block on it instead of blocking on actual I / O call.  Schematically, the multiplexing process is represented in the image. <br><br><img src="https://habrastorage.org/files/a71/404/b9f/a71404b9fd384eb4bbdb144d21a796c8.gif"><br><br>  The application is blocked by calling select and waiting for the socket to become available for reading.  Then the kernel returns us the status <i>readable</i> and you can retrieve data using <i>recvfrom</i> .  At first glance, sheer disappointment.  The same blocking, waiting, and 2 more system calls (select and recvfrom) - high overhead.  But unlike the blocking method, select (and any other multiplexer) allows you to expect data not from one but from several file descriptors.  It must be said that this is the most reasonable method for serving a multitude of clients, especially if resources are rather limited.  Why is this so?  Because multiplexer reduces downtime (sleep).  I will try to explain the following image <br><br><img src="https://habrastorage.org/files/359/12f/e91/35912fe91b434654991987de364359dd.gif"><br><br>  A pool of descriptors corresponding to the sockets is created.  Even if during the connection we received the answer EINPROGRESS, it means that the connection is established, which does not bother us in any way, because  during the test, the multiplexer will still be taken by the one that was first released. <br>  And now attention!  The most important thing! <br>  Answer the question: Which event is more likely?  For event A, that data will be ready for <u>a particular socket</u> or event B, that data will be ready for at least <u>one socket?</u>  .  Answer: B <br>  In the case of multiplexing, ALL of the sockets are checked in our loop and the first one is taken.  While we are working with him, others can also come along, that is, we reduce the time to simple (the first time we can wait a long time, but the other times are much less). <br>  If we solve the problem in the usual way (with blocking), we will have to guess from which connection to read the first second, etc.  those.  we are 100% wrong and we will wait, and although we could not waste this time <br><br><h6>  I / O in threads / child processes (One file descr per thread or process) </h6><br>  Speaking at the beginning that there is a 5 + 1 method, there was meant just such an approach, when several threads or processes are used, in each of which a blocking I / O is performed.  It is similar to I / O multiplexing, but it has several disadvantages.  Everyone knows that Linux threads are quite expensive (from the TZ system commands), so using threads causes an increase in overhead.  Moreover, if python is considered as a programming language, there is a GIL in it and, accordingly, only one thread can be executed within 1 process at any one time.  Another option is to create child processes for handling I / O in a blocking style.  But then it is necessary to think about the interaction between the processes (IPC - interprocess communication), which has some difficulties.  In addition, if the total number of cores does not exceed one, then this approach has a dubious advantage.  By the way, as far as I know, Apache works just approximately according to this scheme (MPM prefork or threads) servicing a client either in a thread or in a separate process. <br><br><h6>  Signal-driven I / O input </h6><br>  It is possible to use signals, forcing the kernel to send us a signal of the form <i>SIGIO</i> , when it becomes possible to read data without blocking (the handle is ready for reading).  This approach is schematically represented in the image. <br><br><img src="https://habrastorage.org/files/d27/290/fcd/d27290fcd79041e9baf2c8c8346fa057.gif"><br><br>  First, you need to set the socket parameters for working with signals and assign a signal handler (signal handler) using the sigaction system call.  The result is returned instantly and the application is therefore not blocked.  In fact, the core takes all the work, because  it keeps track of when the data is ready and sends us a SIGIO signal, which calls the handler installed on it (callback function).  Accordingly, the recvfrom call itself can be made either in the signal handler or in the main program thread.  As far as I can tell, there is one problem - there can be only one signal for each process of this type.  Those.  we can only work with one fd at a time (although I'm not sure) <br><br><br><h6>  Asynchronous I / O (asyncronous I / O) </h6><br>  Asynchronous I / O is performed using special system calls.  The basis is a simple idea - the kernel is given the command to start the operation and notify us (using signals, or something else) when the input / output operation is complete (including copying data to the process buffer).  This is the main difference of this implementation from the implementation on the signals.  Schematically, asynchronous I / O processes are represented in the image. <br><br><img src="https://habrastorage.org/files/4a3/599/6e3/4a35996e37534ddf9b837a87b45667eb.gif"><br><br>  Make the aio_read system call and specify all the necessary parameters.  The rest of the work does the core for us.  Of course, there must be a mechanism that notifies the process that the I / O is complete.  And then there are potentially many problems.  But more about that another time. <br>  In general, a lot of problems are associated with this term, examples of references have already been given.  Often there is a confusion of concepts between asynchronous, non-blocking and multiplexed input output, apparently because the very concept of "asynchronous" can be interpreted in different ways.  In my understanding, asynchronous means independent in time.  Ie once started, he lives his life until it is fulfilled, and then we just get the result <br><br><h5>  On practice </h5><br>  In practice, there is a combination of different models based on the problem.  Proceed as follows: <br><ul><li>  It is not profitable to use a thread / process for every lock operation. </li><li>  Many clients in different threads / processes.  Each thread / process uses a multiplexer. </li><li>  Many clients in different threads / processes.  Asynchronous I / O is being used (aio) </li><li>  Just build the server into the kernel. </li></ul><br>  More details in <a href="http://www.kegel.com/c10k.html">The C10K problem</a> <br><br><br><h4>  Total </h4><br>  I hope that now it will be at least a little clear about the differences in those things that are easily confused. <br>  Well, yes, multiplexing taxis (until aio is finished, I think). <br>  Studying the reference literature, I came to the conclusion that, unlike sockets, regular files cannot be translated into non-blocking mode.  For them, it seems, aio is available that is considered here: <a href="http://davmac.org/davpage/linux/async-io.html">Asynchronous I / O</a> <br><br><h4>  Literature and links </h4><br><ol><li>  Robert Love ‚ÄúLinux.  System Programming" </li><li>  W. Richard Stevens, Bill Fenner, Andrew M. Rudoff "Unix Network Programming Volume 1, Third Edition: The sockets networking API" </li><li>  Stephens R., Rago S. ‚ÄúUnix.  Professional programming, 2nd edition ¬ª </li><li>  Beloved <a href="http://www.kegel.com/c10k.html">The C10K problem</a> </li><li>  <a href="http://davmac.org/davpage/linux/async-io.html">Asynchronous I / O on linux or welcome to hell</a> </li><li>  <a href="http://www.artima.com/articles/io_design_patterns.html">Comparing Two High-Performance I / O Design Patterns</a> </li><li>  <a href="http://stackoverflow.com/questions/2625493/asynchronous-vs-non-blocking">Asynchronous vs non-blocking</a> </li><li>  <a href="http://www.developerfusion.com/article/28/introduction-to-tcpip/8/">Blocking vs.</a>  <a href="http://www.developerfusion.com/article/28/introduction-to-tcpip/8/">Non-Blocking Sockets</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/111357/">https://habr.com/ru/post/111357/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111347/index.html">Processors Sandy bridge</a></li>
<li><a href="../111350/index.html">Comet ‚Äì application for Mochiweb with a load of 1 000 000 users. Part 2/3</a></li>
<li><a href="../111351/index.html">Free digital signature for open drivers</a></li>
<li><a href="../111354/index.html">Experience the first application for Windows Phone 7 Series using Silverlight</a></li>
<li><a href="../111356/index.html">Some subtleties of IT outsourcing</a></li>
<li><a href="../111358/index.html">Designing power subsystem electronic meter</a></li>
<li><a href="../111360/index.html">testcreator - automate student testing</a></li>
<li><a href="../111361/index.html">Dijkstra's algorithm. Search for optimal routes on the graph</a></li>
<li><a href="../111362/index.html">Microsoft Touch Mouse</a></li>
<li><a href="../111363/index.html">My approach to website design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>