<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We profile Habr's download or how 189 requests for render pages affect</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago, I became interested in website performance, download optimizations and things like that. And now, having come again to Habr, I thought ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We profile Habr's download or how 189 requests for render pages affect</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/dg/5m/ab/dg5mabkefi6xhfiovvydhay2fkw.jpeg" alt="Take a thick cherry juice"></p><br><p>  Some time ago, I became interested in website performance, download optimizations and things like that.  And now, having come again to Habr, I thought that I was used to taking a rather fast resource load as a given, without even thinking about how this was achieved.  Therefore, I decided to combine business with pleasure - to see how things are going with Habr's performance and what technical solutions were made to optimize it. </p><br><p>  For those who are interested to know what has been done so that we receive the content as quickly as possible and what Habr's download from Argentina looks like - I ask for cat. </p><a name="habracut"></a><br><h2 id="podgotovka">  Training </h2><br><p>  We will need a fresh version of Chrome / Canary working in anonymous mode (check that you have all the extensions turned off).  Also, in the developer console (Developer Tools - F12), in the network tab, you need to set the disable cache flag, because  <strong>we will only profile the first load, while there are no resources in the cache yet.</strong> </p><br><h2 id="etap-pervyy---po-verham">  Stage One - "On Top" </h2><br><p>  The main purpose of this part is to get acquainted with the site as a whole, to understand its structure and find out what specific resources it needs. </p><br><p>  Open the developer tools, go to the network tab, open the site and at the very bottom of the tab look at the statistics on the use of the network: </p><br><p><img src="https://habrastorage.org/webt/ni/fs/yb/nifsybxewz18qswerh5jubfsn1a.png" alt="And white mother's cape."></p><br><p>  The whole site was loaded in 2.02 seconds, which looks just fine (considering the load of Habr).  The <a href="https://developer.mozilla.org/ru/docs/Web/Events/DOMContentLoaded">DomContentLoaded</a> (farther just DCL) event generally appeared in 1.01 seconds, which looks even better.  With all this, the site makes 189 requests and loads 9.6MB of resources.  This tells us that either the Habra team is a genius (it may well be), and the article should be finished right here (and ask the team for coffee and cookies to them), or remember that I have a 100 MB / c channel and Core I7 .  Those.  you need to get a little closer to reality and at least limit the width of the channel. </p><br><p>  Turn on the Fast 3g mode and look again: </p><br><p><img src="https://habrastorage.org/webt/bp/ov/lk/bpovlkvte1ojvmuamwcoki4uniq.png" alt="Lei gently juice on the raincoat -"></p><br><p>  DCL has deteriorated to 3.48 seconds, which is still quite acceptable.  But finally the site was loaded for godless 54.76 seconds.  Now everything is logical - you can‚Äôt just take and download almost 10 megabytes when you have a weak connection.  Most likely, the guys did a good job to show us the content as quickly as possible (this is indicated by the fact that even in fast3g DCL mode arises quickly enough), and all that are not critical are left to load in the background.  We will check it a little later, and now let's see why we have been loading for so long.  Sort all requests by load time: </p><br><p><img src="https://habrastorage.org/webt/el/jv/uc/eljvucnzbn0d83cd2konxv8ff-8.png" alt="A stain will appear."><br>  <a href="">Clickable</a> </p><br><p>  The images (top-7) and one JavaScript file - prebid.js are loaded the longest.  If we look at their size, it can be assumed that this is the reason for the slow loading. </p><br><div class="spoiler">  <b class="spoiler_title">About assumptions</b> <div class="spoiler_text"><p>  With the assumptions you need to be extremely careful.  For example, long-term resource loading can be caused not only by file size, but also, for example, problems with DNS, peak load on the storage or cold server cache.  Therefore, an unverified assumption may force you to lose time on solving a problem that does not even exist. </p></div></div><br><p>  Looking at the statistics ( <a href="https://en.wikipedia.org/wiki/Time_to_first_byte">TTFB</a> : 0.610 ms, download: 40,000 ms), we can conclude that our assumption is quite likely.  Let's admire our TOP 1 (png, 1560780, 24bit): </p><br><p><img src="https://habrastorage.org/webt/61/ts/aj/61tsajb8gnvzqjaw0cg-mqdj32e.png" alt="Now, so there was no stain"></p><br><p>  In fact, problems with images are mainly problems of our traffic.  Images (as opposed to styles and scripts) do not block the rendering of a web page, and therefore, despite the presence of such heavyweights (sometimes worse, they have seen), this has almost no effect on performance.  Although, of course, optimization in this direction (for example, transcoding in jpeg2000 or webp, or progressive download would not be superfluous). </p><br><div class="spoiler">  <b class="spoiler_title">About images</b> <div class="spoiler_text"><p>  As I wrote above, images do not block the rendering of the page.  But they use our connection pool, and in HTTP 1.x their number is limited, and with http 2.x and Chrome, too, everything is not as smooth as I heard.  Therefore, even here there is a chance that some image may slow down the download of the synchronous script, and that, in turn, will already stop rendering the page.  In addition, loading an image can also cause the layout to recalculate, thereby slowing down the render.  If we look at the Habr's markup, on almost all img tags there is a width and height.  This removes the need to reflow a positive effect on boot performance.  Read more about it <a href="https://www.voorhoede.nl/nl/blog/say-no-to-image-reflow/">here</a> . </p></div></div><br><p>  Let's see what other resources Habr pulls - go through the types and sort by load time.  Let's start with javascript </p><br><h3 id="javascript">  Javascript </h3><br><div class="spoiler">  <b class="spoiler_title">About javascript</b> <div class="spoiler_text"><p>  JavaScript has several problems in terms of site performance.  First of all (everyone knows about it and has been talking for a long time), the synchronous js blocks the further rendering of the page.  Those.  until we get our JavaScript and execute it, the browser will wait (not really, the browser, especially Chrome, can optimize, but that's another story) and will not render further content.  Using synchronous scripts in head, we postpone the moment when the user sees at least something (even text).  Therefore, everyone is trying to throw Js to the bottom of the page or even make it asynchronous.  It works, but it does not solve the second problem, which is brought to us by the fact that JavaScript is still a scripting language.  Therefore, the browser is not enough to just download it - it also needs to be "understood".  And here, it turns out that this is a problem, because weak processors (for example, in cheap phones or netbooks, or even good laptops in limited performance mode) do it slowly, blocking the main thread!  Below is an example of how an asynchronous ad script got into the critical section of the Habr's render and even a little, but still spoiled the performance.  If anyone is interested, here is a very (very, very) good article on <a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201">this topic.</a> </p></div></div><br><p>  Habr scripts loads a lot - 1.1 MB (and this is already in a compressed form) for 40 requests.  Frankly speaking, this is essential, it will still affect us and something needs to be done about it.  We sort our scripts "by waterfall".  Our task is to find scripts that have loaded up to the blue line, since it is they (most likely) that prevent us from rendering the site as quickly as possible. </p><br><p><img src="https://habrastorage.org/webt/0m/8g/u4/0m8gu4f9s-odx2kf7xg8jiweuke.png" alt="On my mother's raincoat,"><br>  <a href="">Clickable</a> </p><br><p> Open the html, which gave us Habr (it is important to look exactly the answer, since the final html will look different) and go through the list.  As you can see, jQuery, raven.js, advertise.js and adriver.js are loaded synchronously directly from the head of the tag (i.e., they block everything).  Gpt and publisher are loaded from head but asynchronously (i.e., they do not block anything, the browser will render the page further while they are swinging).  Vendors, Main and Math, checklogin are loaded at the end, but synchronously (Ie the text is already there, we can read it, but DCL will not appear until they are loaded).  The rest of the initial answer does not appear - they are added dynamically, but this is another topic. </p><br><p>  So, we found those scripts that somehow influence how quickly we see the text on the page.  These are the first candidates for optimization.  Ideally, they should be made asynchronous or placed as low as possible in order to allow the browser to render content for us.  However, the ideal is not achievable, since most likely there are other scripts on the site that depend on the same jQuery.  The desire to download raven as early as possible - a library for tracking various errors that occur on the client can also be understood.  But advertise.js and adriver.js are already real candidates for, at least moving down the page, and as a maximum also in asynchronous mode.  A similar story with gpt and publisher.  Yes, they are loaded asynchronously, but, nevertheless, they can (and will) interfere with us when loading.  Therefore, they too could be sent to the bottom of the page.  In addition, you can try to use the attributes of <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content">Resource Hints</a> - preload / prefetch / dns-prefetch to help the browser know what to load in advance.  By the way, I advise you to read about Resource Hints - a very interesting tool, albeit with limited (so far) support. </p><br><p>  Now sort the list by file size: </p><br><p><img src="https://habrastorage.org/webt/r-/om/kq/r-omkqj5qrslwffj42o5eogv_3s.png" alt="The cloak should be put entirely"><br>  https://github.com/Drag13/articles/blob/habrformance/habrformance/scripts.PNG </p><br><p>  We see a script that is loaded twice (pubads).  We also note that prebid.js is loaded from the not-for-prod folder. </p><br><p><img src="https://habrastorage.org/webt/4e/su/7w/4esu7wsvwdpgmbw8nscc_sqcgmo.png" alt="In thick cherry juice."></p><br><p>  To clear our conscience, we check that all scripts are minified.  Suddenly, check-login.js and adriver.js microscripts were not minified.  Particularly pleased with the content of the latter: </p><br><p><img src="https://habrastorage.org/webt/6q/nv/q8/6qnvq8dimcd_5m3w77mr3mkjlea.png" alt="Take the cherry mother's cape"></p><br><p>  And with scripts you can temporarily end. </p><br><h3 id="stili">  Styles </h3><br><div class="spoiler">  <b class="spoiler_title">About styles</b> <div class="spoiler_text"><p>  With styles, everything is also not so simple.  First, the synchronous loading of styles also blocks the main stream (although they parse quickly, faster than JavaScript).  And secondly, everything is a little more complicated.  Why does the browser need CSS?  To collect <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model">SSOM</a> .  And what can JavaScript do with CSS?  Correct - change.  And what will happen if CSSOM is not yet compiled, and js is already trying to change something there?  The answer is - and who knows.  Therefore, the browser postpones the execution of JavaScript until the CSSOM is calculated.  As correctly written in another <a href="https://blog.logrocket.com/how-browser-rendering-works-behind-the-scenes-6782b0e8fb10">very useful article</a> - no CSS = no javascript.  Therefore, loading CSS blocks JS execution. </p></div></div><br><p>  Here are the styles that Habr loads: </p><br><p><img src="https://habrastorage.org/webt/nm/6y/a7/nm6ya7qcp1bdqcp5sl2fiingrp8.png" alt="And a cup of milk."><br>  <a href="">Clickable</a> </p><br><p>  As you can see, there are only three of them, with the second and third being loaded in a separate frame, so we ignore them.  But the first set of styles is crucial for the entire site.  And we downloaded it for a very long time.  Why?  First, they waited a long time for a response from the server (TTFB 570 ms, we will return to it in the third section), and second, we loaded 713 ms for a long time.  What can be done here?  The first and simplest is to try to add the preload attribute.  This will prompt the browser to start loading CSS as early as possible.  The second option is to select the critical CSS and inject it directly into the web page, and load the remnants synchronously (or even asynchronously).  This will lead to an increase in the page size (but it is not so small anymore and + 5kb will not spoil anything) and a possible redrawing of the leyauta (loss of time), but you can try. </p><br><p>  I will not even show fonts.  It is there alone, though for some reason it is loaded from the Habr server directly instead of the CDN (and most likely not just).  But I will say thank you for the fact that there is only one font. </p><br><p>  This review part of the analysis of the site can be considered complete.  Time to go deeper. </p><br><h2 id="etap-vtoroy---ruchnoy-rezhim">  Stage Two - "Manual Mode" </h2><br><p>  At the last stage, we looked at <em>what</em> Habr loads.  Now we will see <em>how</em> it is rendered. </p><br><p>  Go to the profiling tab.  We check what the slowdown fast3g is worth (then we run it again without restrictions) and run it.  First of all, we are interested in everything that happens before the <a href="https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics">First contentful paint (FCP)</a> event, and DCL just in case.  Select the area from the start of the download to FCP and look at the final chart. </p><br><p><img src="https://habrastorage.org/webt/1s/nb/qi/1snbqidqssgm4mxoulzysms7swu.png" alt="Ley gently milk -"></p><br><p>  Everything happens pretty quickly - 2.161 sec to FCP (it was faster, but apparently, something has changed), but as you can see, most of the time the browser was idle.  The payload took only 14% of the time (about 310 ms).  Ideally, the main browser stream runs all the time - parsing html, CSS, executes JS.  And then - nothing.  Why?  Because the browser simply had nothing to do.  Remember we cut the traffic?  The browser has sent requests and is now just waiting for them to be executed.  If we open the network process diagram (the top one), everything will become immediately clear. </p><br><p><img src="https://habrastorage.org/webt/uf/1-/gt/uf1-gt0kx7rkdpd9tzeod3hv99o.png" alt="A stain will appear."><br>  <a href="">Clickable</a> </p><br><p>  In 2029, the browser saw main.bundle.css, sent a request to receive it, and waited.  At this time, the prescanner (smart chrome, he knows how to run ahead) found that there are synchronous scripts at the bottom and, not waiting for css to arrive, he sent a request for getting scripts.  Then advertise and adriver were loaded (but we remember that while CSSOM is not created, you cannot touch JS), so the browser ignored them.  After that, gpt and raven were loaded, but the CSS was still loaded, so they were also ignored.  Finally, the CSS was loaded, which the browser parsed for 12 ms and immediately went to the parsit embedded in the JS page.  Then the browser again fell asleep for almost 150 ms waiting for jQuery.min.js.  And after that, I took up the work seriously - figured out the loaded jQuery (20ms), parsed raven.js (4ms), parsed almost the whole page (36ms), recalculated styles (28ms), calculated the leyout (78 ms + 8 ms) and Finally, for ~ 6 ms, we painted the page.  This is where we got FCP.  Next, we parse the page, parse the scripts ‚Äî hello unnecessary (publishertag.js, gpt.js who got into the main thread before DCL), played around with the styles a bit (which caused a slight loss of time due to the leuta recalculation) and started waiting for the vendors. bundle.js.  We almost spent another 1100 ms to wait for the vendors.  True, in parallel with it, we also loaded main.bundle.js (which, by the way, booted faster), so not everything is so bad.  Then everything went well again.  Raspasili vendors, Raspari main bundle, Raspars Math.Jax, and finally finished the page and got DCL.  True, some handler worked immediately on my I7 to stop the main thread for 80 ms (i.e., the site seemed to hang for 80 ms).  Now we almost did not notice this, but on a weak processor, theoretically, this may be noticeable. If this happens with you after the content rendering, this is a reason to check JS. </p><br><p>  What can I say.  Again, despite how it looks, everything is pretty good.  The main problems brought us: </p><br><ul><li>  A large simple browser (including due to the artificial disproportion between the computing power of the computer and the width of the channel, but this is also a completely valid scenario) </li><li>  Long loading of CSS which postponed work with critical js </li><li>  Synchronous loading of jQuery, vendors and main bundles that stopped the appearance of content. </li></ul><br><p>  What can be done with this, we have already discussed: </p><br><ul><li>  Try adding preload attribute for CSS and maybe some JS </li><li>  Shrink or shrink CSS </li><li>  Trying to throw scripts out of synchronous download at all (at least some) </li></ul><br><p>  Now let's repeat the same thing without any restrictions on the width of the channel.  The picture is already much better: 0.452 seconds to FMP, the easiest of all!  13 ms.  DCL - 953 ms, idle time 15 ms.  Here is the download of my dream.  That's just it happened because I opened a new tab and did not remove caching.  Let's try the same thing, but without the cache: </p><br><p><img src="https://habrastorage.org/webt/g5/ji/5q/g5ji5qscsjud50jdqkoazqoxsga.png" alt="Now, so there was no stain"></p><br><p>  Everything is also quite good, FCP / FMP - 1689, payload 45%.  By the way, it is also bad to adjust the load to 100%, since weaker machines will be overloaded.  So it is better to have a stock on idle.  But, suddenly a lot of time was spent on Rendering - 400 ms for FMP.  Of these, 200 ms was spent on recalculation of styles and recalculation of the layout. </p><br><p>  By the way, another interesting point.  Remember the advertising scripts - gpt.js and publishertag.js which were mentioned in the first part?  Now you can see that, despite their asynchrony, they could (albeit a bit) spoil the statistics.  This happened because the execution of asynchronous scripts is done by the readiness of the scripts themselves.  Those.  this can happen at any time, including before FCP / DCL, which happened in 3309. </p><br><p>  So, we made a manual disassembly.  It's time to uncover automatics. </p><br><h2 id="etap-tretiy---s-etogo-nado-bylo-nachinat">  Stage Three - "From this it was necessary to begin" </h2><br><div class="spoiler">  <b class="spoiler_title">About collective farm</b> <div class="spoiler_text"><p>  I think everyone understands that this study is very conditional.  At least, because all the time while I was testing new articles appeared, the load on the server and the load on the network backbones changed.  In an amicable way, you need to deploy a dedicated server to which no one will write anything, emulate the relevant load with the relevant delays and only then profile something.  Otherwise, you can make some assumption, (for example, about the need to add a preload attribute to CSS), add it, put it on production, and then it turns out that the load during the test has increased dramatically and the same style was given to us by the server already 500 ms later.  And it turns out that the preload is bad - it only made everything worse.  And the author and the last radish.  In addition, profiling manually (as in the second part), until you drove out all the automatic tools and solve the problems found there, also makes little sense, because after the first of your changes the picture will change. </p><br><p>  Therefore, before any experiments, we need the most stable environment.  This time.  Second, you never need to go deep (for example, in profiling) from the very beginning.  First run the automatic tools, let them work for you.  Collect reports, see what you can do as well as possible in the shortest amount of time.  Try it.  If you succeed, perhaps this is enough for you.  For example, your css.bundle weighs 100kb, but in reality you need 45kb (by the way, the real situation: they took all the bootstrap, and only the net was needed).  Reduced the size of the styles and won half a second almost for nothing.  These are two.  Always check back.  It would seem, zainlaynil styles, everything should become better, and worse.  And why?  And because in the styles of 50kb base64 images, and our page has a total load of 200kb resources.  Just remember that there is no silver bullet and universal scenarios.  These are three.  And finally, even if it contradicts the previous proposal.  If your site is not complicated - just monitor TTFB (server problems), download resources (hello logos for 2MB) and don‚Äôt allow access to Google Tag Manager from anyone.  Most likely this will be quite enough. </p></div></div><br><p>  Let's not go far, in the same Developer Tools, open the audit tab and run LightHouse (LH) with the following settings: desktop, performance only, no throttling, clear storage.  After a short wait (do not leave the page on which you are auditing and do nothing better at all) we get fantastic numbers (even with the cache turned off) </p><br><p><img src="https://habrastorage.org/webt/cg/cu/rc/cgcurczrbd7r4xhjqrtqgw-pj5s.png" alt="On my mother's raincoat,"></p><br><p>  It even seems to me that these figures were specifically tailored to. </p><br><p>  At the same time, LH still complains about: </p><br><ul><li>  Outdated image format (suggests using webp, jpeg2000, etc) </li><li>  The number of DOM node - too many of them: 2533, with the recommended 1500. </li><li>  Too much traffic </li><li>  Invalid caching policy - there are no caching headers on 23 resources </li><li>  Using document.write </li></ul><br><p>  It's all clear.  Images compress and transcode (ha), DOM - find who creates so many node (ha ha), set caching to static resources (well, you can), and tear off the document.write from his writer (three ha ha if it's someone else script) </p><br><div class="spoiler">  <b class="spoiler_title">Pro tips</b> <div class="spoiler_text"><p>  Many of us (and I am no exception to what this article shows) love to give advice.  However, much of what has been done has its own, often hidden, reason.  In addition, it is easy to give advice, but it is much more difficult to implement them.  What is worth only one advice to reduce CSS, - try to figure out which styles are not needed if there are tons of them, and some of the styles come from JavaScript.  Plus, any such changes are likely to require regression testing, which will cost the client a pretty penny.  Therefore, any optimizations should be approached with good skepticism and, first of all, optimize those problems that give the greatest gain per unit of time. </p></div></div><br><p>  Now let's try launching the same thing, but already limiting the channel width to fast3g and, attention, for the first time, set a fourfold slowdown of the processor (goodbye I7, hello celeron): </p><br><p><img src="https://habrastorage.org/webt/td/ei/3j/tdei3jxtwbcvda5csqvvmgz2tua.png" alt="The cloak should be put entirely"></p><br><p>  As you can see, things got worse (but FCP is still 3500 ms, FMP 5.7): </p><br><ul><li>  Significantly increased image problems.  LH again suggests using next-gen image formats, but now, in his opinion, this will save us as much as 11 conditional seconds. </li><li>  The problem with render-blocking resources has grown.  And here two synchronous microscript adriver.js and advertise.js each surfaced 50 bytes each, which I have already mentioned. </li><li>  There was a suggestion to cut the CSS with a hint that only 5kb out of 45kb is used. </li><li>  The problem of too busy main thread first appeared.  We cut the computing power and the browser just started to choke in JavaScript - (8.5 seconds for the script evaluation of which 2186 ms was spent on raven.js).  Not weak, eh? </li></ul><br><p>  What conclusions can be drawn from here?  Habr works well on fast internet and powerful machines.  Shifting towards something cheaper can cause problems.  Problems caused by: </p><br><ul><li>  Large images </li><li>  Large DOM </li><li>  More javascript per page </li></ul><br><p>  A lot has been done so that these problems do not interfere with the rapid emergence of content, but for weak machines it is still relevant (for example, blocking raven.js). </p><br><p>  Finally, let's go beyond the developer console, and try another well-known tool - <a href="https://www.webpagetest.org/">webpagetest.org</a> </p><br><p>  It is remarkable to many - and detailed graphs, and tips, and settings.  But what else he has is good - he allows you to choose a location from which you are supposedly watching the site.  We all remember that Habr has become international.  So let's see how Habr will be loaded, for example from Argentina.  Of course, I would have access to the metrics, I would choose a more relevant location, and so - there will be Buenos Aires. </p><br><p>  And for the purity of the experiment, use <a href="https://habr.com/">https://habr.com</a> (without ru / en postfix). </p><br><p><img src="https://habrastorage.org/webt/qz/hb/gn/qzhbgnvpgll4xbdlvejmvfzpndm.png" alt="In a pot of milk."></p><br><p>  (partially shown, full version <a href="https://www.webpagetest.org/result/190601_F9_f0f3b815c240efc7ba3b39b30bf193f9/1/details/">here</a> ) </p><br><p>  Everything is very detailed here.  You can see how much time (and to whom) it took to resolve DNS (500 ms for the main page), how much it took to establish a connection, ssl, and so on.  It is immediately clear that we spent 1150 ms only on redirecting from the main page to the English version (reason to see why it takes so long).  By the way, it has quite a lot of redirects (habrastorage suffers most of all). </p><br><p>  You can also see the ill-fated main.bundle.css.  It turns out that this is the first appeal to dr.habracdn.net, which leads to the need to perform dns lookup - 36 ms (by the way, I saw 400 ms each).  Plus SSL negotiation 606 ms, plus TTFB 601 ms, plus another download.  In general, not fast.  But in spite of all this DCL - 4100 ms or so, which also pleases. </p><br><p>  There is also a great tab image analysis, which shows how and how much you can save if you compress images.  A photo of some red cat from a site in PNG weighs 1.4MB, and in webp + downscaling (yes, cheating, but still) - 17.7 KB.  For comparison, the same photo in the same resolution, but still in png weighs 154kb.  In general, only about this tool, you can write a separate article.  But, in brief: </p><br><ul><li>  We lost about two seconds on the initial loading of the page (and this despite the fact that later we loaded it in a few milliseconds, i.e. the channel was simply awesome). </li><li>  A large number of redirects.  It eats time, it is necessary to deal with it. </li><li>  A long TTFB (webpagetest even put us F for this) - perhaps too high a load </li><li>  Really large downloads chart that allows you to assess how many requests Habr makes (and still the main content is given pretty quickly) </li></ul><br><h2 id="vyvody">  findings </h2><br><p>  And we will have no conclusions.  There will be points for further study: </p><br><p>  For server: </p><br><ul><li>  Sometimes TTFB jumps up to 500 ms or more for static resources (this is <strong>without</strong> dns, ssl and initial connection) </li><li>  Redirection habrastorage </li></ul><br><p>  For client: </p><br><ul><li>  Not optimal images </li><li>  Big size DOM-a </li><li>  Probably not optimal positions of blocking scripts. </li></ul><br><p>  At the same time, it is obvious that a good optimization work has been done.  The site quickly loads the main text, the rest occurs after we see the content.  Clearly, this is not a SPA, the server gives you content that is already ready to be shown, for which even JS is not needed - just to style and ready.  But the less guys are great.  There is still a wish to reduce the number of trackers / analytics / advertising, but this is more likely a dream a little comparable to the requirements of the business. </p><br><h2 id="poleznye-ssylki">  useful links </h2><br><ul><li>  <a href="https://medium.com/web-standards/performance-metrics-ff23c213164e">Pro performance metrics</a> </li><li>  <a href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201">Pro performance</a> </li><li>  <a href="https://docs.google.com/presentation/d/1Lq2DD28CGa7bxawVH_2OcmyiTiBn74dvC6vn2essroY/edit">Deep profiling in Chrome</a> </li><li>  <a href="https://www.webpagetest.org/">Webpagetest</a> </li><li>  <a href="https://www.2dogsdesign.com/webpagetest-waterfall/">How to use webpagetest</a> </li><li>  <a href="https://www.phpied.com/rendering-repaint-reflowrelayout-restyle/">How does render 1</a> </li><li>  <a href="https://blog.logrocket.com/how-browser-rendering-works-behind-the-scenes-6782b0e8fb10">How does render 2</a> </li><li>  <a href="https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics">About FCP</a> </li></ul><br><p>  Ps.  I apologize for the large number of anglicisms (especially for the layout) and for the longrid.  But without them it‚Äôs very hard, and I‚Äôm already tired of all these parts 1, 2 and 3. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/454444/">https://habr.com/ru/post/454444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454432/index.html">Interesting archeology: R style guide under a magnifying glass</a></li>
<li><a href="../454434/index.html">PDA (Pocket Travel Computer): GPS Logger Circuitry</a></li>
<li><a href="../454436/index.html">Small python joy # 1: loguru</a></li>
<li><a href="../454440/index.html">Little Python Joy # 2: Starlette</a></li>
<li><a href="../454442/index.html">How to choose a proxy network for business: 3 practical advice</a></li>
<li><a href="../454446/index.html">What's new in C # 8?</a></li>
<li><a href="../454448/index.html">The history of assembling a ‚Äúvillage supercomputer‚Äù from spare parts from eBay, Aliexpress and a computer store. Part 2</a></li>
<li><a href="../45445/index.html">International Nanotechnology Forum, Moscow</a></li>
<li><a href="../454450/index.html">How Edison Invented Wireless and Did Not Understand It</a></li>
<li><a href="../454456/index.html">Training Cisco 200-125 CCNA v3.0. Day 7. FAQ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>