<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Padding Oracle Attack: cryptography still scares</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This vulnerability has been repaired for fifteen years. 
 The four-year-old text ‚ÄúPadding Oracle Attack or why cryptography scares‚Äù described the CBC ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Padding Oracle Attack: cryptography still scares</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/f2c/d27/5a7/f2cd275a796e0ade7fab4c87f15157ac.jpg" width="280" align="right"><h3>  <font color="#678">This vulnerability has been repaired for fifteen years.</font> </h3><br>  The four-year-old text <a href="https://habrahabr.ru/post/247527/">‚ÄúPadding Oracle Attack or why cryptography scares‚Äù</a> described the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B6%25D0%25B8%25D0%25BC_%25D1%2581%25D1%2586%25D0%25B5%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25B2_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D0%25B0">CBC encryption mode</a> in detail.  In this mode, each regular plaintext block xor-is with the previous ciphertext block: as a result, each ciphertext block depends on each plaintext block that has been processed by that moment. <br> <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25B9%25D0%25BB:EncryptCBC.png"><img src="https://habrastorage.org/getpro/habr/post_images/2be/853/4fe/2be8534fe77240de057b2847715b6311.png" width="600"></a> <br>  To skip the original message (of arbitrary length) through the CBC cipher, it is appended with a <a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">MAC</a> (hash for integrity checking, usually 20-byte SHA-1) and then padding to complete the plaintext to an integer number of blocks (usually 16-byte): <br><img src="https://habrastorage.org/getpro/habr/post_images/bd0/e1c/925/bd0e1c925a49586eabc050204d7cfdfb.jpg" width="400"><br><br>  Padding consists of equal bytes, one less than its length: <code>(0)</code> or <code>(1,1)</code> or <code>(2,2,2)</code> or the like. <br>  Thus, the recipient of the ciphertext should <ol><li>  decipher all its blocks; </li><li>  read the last byte of the last block to determine the length of the padding and, accordingly, the MAC position in clear text; </li><li>  check the correctness of the packing and MAC. </li></ol><br>  In 2002, French cryptographer Serge Vodenet discovered a vulnerability to padding oracle attacks in CBC: <a name="habracut"></a>  if you intercept a ciphertext (using a MitM attack), change the last byte of the penultimate block, send the modified ciphertext to the server, and monitor its response, then the difference between the ‚Äúincorrect packing‚Äù and ‚Äúincorrect MAC‚Äù answers will make it possible to determine the last byte in 256 requests source plaintext.  Then MitM begins to change the penultimate byte of the penultimate block, and for 256 requests it determines the penultimate byte of plaintext, etc.  - 256 requests to decrypt each byte. <br><br>  Practically, this vulnerability could (was) be used to steal an HTTPS cookie: the attacker sends the user to his page, on which the script, on behalf of the user, will send HTTPS requests to the server of interest to the attacker one by one.  The user's browser will insert his cookies for this server into each request, while the MitM server, controlled by the attacker, will intercept messages between the user and the HTTPS server, change one byte in them in the penultimate block, and monitor the server's response.  It will take less than a minute to decrypt all cookies. <br><img src="https://habrastorage.org/getpro/habr/post_images/3f3/67d/168/3f367d168cccad57564f7d1343ccd68a.png"><br>  It would seem that to protect against Vodene‚Äôs attack, it is enough that the server returns the same error code if the code is incorrect and the MAC is incorrect;  but these two cases can still <a href="https://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf">be distinguished</a> in time until the server responds: calculating and checking the MAC takes significantly more time than just checking the stuffing in the last block. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since there should be no difference, packing or MAC did not pass the check - it may seem that there is no need to check the contents of the packing: if the plaintext does not end with a sequence of identical bytes, then it is obviously incorrect, so the MAC will not coincide with the overwhelming probability.  But if an attacker selects such a ciphertext size so that the last block is completely occupied with stuffing and replaces it with any previous block from the same ciphertext on the MitM server, the server will report an error only if the last byte of the substituted block is not decrypted in (block_length ‚Äì 1).  It turns out the same "padding oracle", only in profile.  This attack was called <a href="https://habrahabr.ru/company/mailru/blog/241113/">POODLE</a> .  Modern SSL / TLS implementations necessarily check the contents of the stuffing, and if it is incorrect, they consider the stuffing to be absent, and send the entire CBC decryption result to the MAC check.  In principle, this allows customers not to send an extra block, consisting entirely of stuffing, when the plaintext (along with the MAC) initially consists of an integer number of blocks, and does not end with a sequence of identical bytes. <br><br>  After these corrections, the padding oracle vulnerabilities were considered eliminated until, in 2013, a pair of British researchers invented <a href="https://en.wikipedia.org/wiki/Lucky_Thirteen_attack">the Lucky 13</a> attack, which is based on the fact that the MAC calculation time depends on the length of the hashed string.  Since SHA-1 processes a string with 64-byte blocks, an attacker can try all possible two-byte combinations as the last two bytes of the penultimate CBC block, and a jump in server response time will mean a transition between a 55-byte hash string (one SHA-1 block ; a nine-byte "trailer") and a 56-byte (two blocks) are added to the end of the hashed string, i.e.  between two byte packing and single byte: <br><img src="https://habrastorage.org/getpro/habr/post_images/0fc/5ae/d79/0fc5aed79b27221c6ae5e59205472bc0.png"><br><br>  By intercepting and changing the HTTPS request 65,536 times, measuring the response time of the server each time, the last two bytes of plaintext can be restored in a ‚Äústerile‚Äù laboratory environment.  In practice, the accumulation of sufficient statistics to restore two bytes will require more than one hundred repetitions of this series of 65536 queries.  Thus, the attack "Lucky 13" was more likely a theoretical danger. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/801/058/ad3/801058ad343a104ba44622f5005a46ff.jpg" align="right"><blockquote>  <i>This attack got its name due to the fact that the size of the header, which is hashed before the ‚Äúpayload‚Äù, limited the search for packing options to double-byte sequences.</i>  <i>Whether this header is 14-byte or longer, a jump in the server response time would fall on shorter pieces of plaintext, and it would take hundreds of times more stuffing options to sort through.</i>  <i>On the other hand, if this header were 11-byte, the jump would fall on the transition between blocks 8 and 9 of plaintext, and the attack would be completely impossible.</i>  <i>Well, the happiest number is, of course, 12: with such a header length, it would be enough for an attack to iterate over the values ‚Äã‚Äãof the last byte in itself, as in the Vodene attack.</i> </blockquote><br>  To protect against ‚ÄúLucky 13‚Äù, the OpenSSL developers have put <a href="https://www.imperialviolet.org/2013/02/04/luckythirteen.html">forth a remarkable ingenuity</a> : in fact, it is impossible to use branching in the entire MAC verification code and the packing, otherwise the verification time for different input data will be different!  Omitting the details of the implementation of the SHA-1 without branching by the number of blocks processed, let us focus on the last verification step: comparing the calculated MAC value with the actual recorded in clear text.  To avoid branching, the code checks the entire plaintext byte by byte, combining the difference between the expected and actual values ‚Äã‚Äãwith the ‚ÄúMAC mask‚Äù and the ‚Äúpacking mask‚Äù, and combining the results of all bytes with OR: <br><img src="https://habrastorage.org/getpro/habr/post_images/6ae/ab7/cd4/6aeab7cd44feff1b4d9e58fb3a4af3fc.jpg"><br><br>  The 32-byte plaintext depicted consists of a six-byte message, 20 MAC bytes, and six stuffing bytes.  Packing can be no longer than 12 bytes (with an empty message), but in any case, the code must calculate the MAC and check all the bytes of the message before returning an error code. <br><br>  Well, what will this code do if the last byte of the plaintext is "12" - a deliberately impossible packing length? <br><img src="https://habrastorage.org/getpro/habr/post_images/f93/f38/e94/f93f38e94a3a661a991b05071864a18a.jpg"><br>  The MAC will be calculated for a message of length -1! <br>  No matter how the result will turn out, it is obviously meaningless;  more importantly, the MAC check mask ‚Äúmoved‚Äù by one byte per start of the message ‚Äî i.e.  from the resulting garbage value only 19 bytes will be checked. <br><br>  But what if you move the MAC mask entirely behind the beginning of the message? <br><img src="https://habrastorage.org/getpro/habr/post_images/774/bcb/7a0/774bcb7a0a7eaa362a13341fa5cc723f.jpg"><br><br>  Now you can ignore the MAC check: anyway, all difference bytes will be pro-and-yens with a zero mask!  The only remaining obstacle is checking the contents of the pack.  All its bytes must be equal to the last, i.e.  31: <br><img src="https://habrastorage.org/getpro/habr/post_images/c38/9a1/bf4/c389a1bf481bfc5a6d215f3bc9a2b050.jpg"><br>  Thus, the attacker can check whether the plaintext will consist entirely of bytes with a value (cryptographic length ‚Äì 1): in this case, OpenSSL will consider the ciphertext correct, and the server will return a higher level error (for example, an HTTP error). <br><br>  How to use such an oracle?  Now the MitM server has to act much more sophisticated than when attacking Vodene.  Suppose an attacker script sent a POST request to the HTTPS server ending in 31 bytes with a value of 31. The MitM server intercepts the ciphertext, takes <i>only the last two blocks</i> from it, and as the initialization vector takes the third end of the ciphertext and will it with each request to change the first byte: <br><img src="https://habrastorage.org/getpro/habr/post_images/eba/058/1f3/eba0581f3df0ed7ef1aa57548486341a.jpg"><br><br>  Of the 256 attempts with different values ‚Äã‚Äãof the first byte IV, 255 will lead to the error "incorrect MAC or stuffing", and one attempt will lead to another error - so we can recover the 32nd byte from the end of the POST request! <br>  In the POST request, we increase the length of the path by one byte, and shorten the request body by byte, then we will know the 31st from the end of the request.  Now we change the second byte IV so that the second byte of plaintext again turns 31. Again we will change the first byte IV, and again we can restore the 32nd byte from the end of the query! <br>  Shifting the ‚Äútransparent byte‚Äù in this way, MitM can decrypt the last 16 bytes in the POST header, and, if lucky, the HTTPS cookies will be among the 16 bytes.  The decryption rate is the same as in the original Vodenet attack: up to 256 requests for each recovered byte.  It turns out that incidentally with the protection of "Lucky 13" in OpenSSL introduced a vulnerability that is much more serious than the very "Lucky 13"! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/60f/edc/9fc/60fedc9fcdaae441f40aa688bb64751f.jpg" align="right" width="280"><blockquote>  <i>Technical Note: even if the POST request ends in a sequence of bytes 31, it will be supplemented by MAC and stuffing before CBC encryption, so that in the described form the attack will not work.</i>  <i>Preparatory stage of the attack - by varying the requested path, choose a POST request length so that the MAC and this padding occupy the last two CBC blocks in their entirety;</i>  <i>then during the attack these last two blocks will be discarded, and blocks from the fifth to the third from the end will be used.</i>  <i>By establishing such coordination between the script that generates HTTPS requests and the MitM server, an attacker can ensure that the result of the CBC decryption will end in 31 bytes with a value of 31.</i> </blockquote><br>  Summing up: over the course of 15 years since the discovery of the first ‚Äúpadding oracle‚Äù, each attempt to eliminate such ‚Äúoracles‚Äù was followed by the discovery (or even inadvertent creation!) Of new ones.  I wonder how much time will pass until the next ‚Äúpadding oracle‚Äù is found in TLS using CBC ciphers? </div><p>Source: <a href="https://habr.com/ru/post/338072/">https://habr.com/ru/post/338072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338060/index.html">Cut XML by XQuery Markup</a></li>
<li><a href="../338064/index.html">The principle of sole responsibility: the foundation of decomposition</a></li>
<li><a href="../338066/index.html">Moki and explicit contracts</a></li>
<li><a href="../338068/index.html">Angular vs. React vs. Vue: Comparison 2017</a></li>
<li><a href="../338070/index.html">ASO in iOS 11: a pivot table of changes</a></li>
<li><a href="../338074/index.html">Classic 2D quest or how our two years of development went. Part 1</a></li>
<li><a href="../338078/index.html">In the footsteps of cyberdetective</a></li>
<li><a href="../338080/index.html">How to manage enterprise SSH keys</a></li>
<li><a href="../338082/index.html">What's in the black box: what are the costs of the virtual and physical infrastructure</a></li>
<li><a href="../338084/index.html">Ethereum Smart Contracts: writing a simple contract for ICO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>