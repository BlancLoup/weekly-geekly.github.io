<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blocking the launch of the second instance of the Perl program</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From time to time it becomes necessary to ensure that the program is guaranteed to work in one copy. For example, it may be a script that generates a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blocking the launch of the second instance of the Perl program</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/51f/95e/d12/51f95ed12178eda049e65cd8a899a143.jpg" alt="image"><br><br>  From time to time it becomes necessary to ensure that the program is guaranteed to work in one copy.  For example, it may be a script that generates a certain file - if you run two instances of the script at the same time, the file will be corrupted. <br><br>  It is necessary to check whether the process being started is the only currently running instance of the program, or is there already another instance running? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are several methods of such verification, differing reliability. <br><a name="habracut"></a><br><h4>  Basic methods </h4><br><h5>  1) Verifying the existence of a pid file </h5><br>  The script runs and checks for the presence of the pid file.  If the pid file already exists, it means that another instance of the script is already running and should not be run a second time.  If the pid file does not exist, the script creates the pid file and starts working. <br><br>  The problem is that the first instance may fall without deleting the pid file.  And now it will be impossible to run the script at all, since the launched script will always detect the pid file, consider itself the second instance and refuse to run until the pid file is manually deleted.  In addition, there is a problem with race conditions, since checking the existence of a file and the subsequent creation of this file are two separate operations, rather than one atomic one. <br><br><h5>  2) Checking the availability of the pida in the process list </h5><br>  The script starts, reads the pid file and then checks if there is a process with the read pid in the process table.  If such a process exists, it means that another instance of the script is already running and should not be started a second time.  If such a process does not exist, the script writes its PID to the PID file and starts working. <br><br>  The problem is that the first copy may fall, and the pay it worked with may be issued to another process.  After that, as in the first method, there will be a problem with running the script.  Of course, the likelihood of such a situation is somewhat lower than in the first case, because the re-pid will not be issued immediately.  Yes, and the likelihood that an outsider process will receive exactly the same peed as our process is not very big, but it is there, since there are not an infinite amount of them and they are given out in a circle.  Well, plus the race conditions, since there are more operations here than in the first method. <br><br><h5>  3) PID file lock </h5><br>  The script starts and tries to block the pid file.  If it was not possible to block, it means that another instance of the script is already running and should not be launched a second time.  If you succeed in blocking the pid file, the script continues to work. <br><br>  This method has no problems arising in the previous two methods: <br><br><ol><li>  The fall of the first instance of the script automatically removes the lock from the pid file, so the next instance can be started without any problems. </li><li>  There is no race conditions, since the lock is an atomic action </li></ol><br>  Thus, this method is guaranteed to block the launch of the second copy of the program. <br><br><h4>  Pid locking method </h4><br>  Consider in detail the implementation of this method. <br><br><pre><code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl use Carp; use Fcntl qw(:DEFAULT :flock); check_proc('/tmp/testscript.pid') and die "  ,   !\n"; #   , #    #    sleep 15; #     sub check_proc { my ($file) = @_; my $result; sysopen LOCK, $file, O_RDWR|O_CREAT or croak "   $file: $!"; if ( flock LOCK, LOCK_EX|LOCK_NB ) { truncate LOCK, 0 or croak "   $file: $!"; my $old_fh = select LOCK; $| = 1; select $old_fh; print LOCK $$; } else { $result = &lt;LOCK&gt;; if (defined $result) { chomp $result; } else { carp " PID  - $file"; $result = '0 but true'; } } return $result; }</span></span></code> </pre> <br><br>  First of all, the script calls the function check_proc, which checks for the presence of another running instance, and, if the check completes successfully, the script stops with the appropriate message. <br><br>  Notice that in this line, the functions check_proc and die are combined using the conditional operator and.  Usually such bundles are made through the or operator, but in our case the logic of the bundle is different - we kind of say to the script: ‚ÄúRealize the meaninglessness of your existence and die!‚Äù. <br><br>  The check_proc function returns the pid of an already running instance, if it is actually running, or undef.  Accordingly, the true result of this function means that one copy of the program is already running and you do not need to start a second time. <br><br><h4>  Check_proc function </h4><br>  Now let's sort the function check_proc line by line. <br><br><h5>  1) The sysopen function opens a file for reading and writing. </h5><br>  It is important that the file must be opened in non-destructive mode, otherwise the contents of the file will be destroyed.  Because of this, you cannot use the simple open function, since it cannot open files in non-destructive mode. <br><br>  The sysopen function with the O_RDWR | O_CREAT flags opens the file in nondestructive mode.  The O_RDWR flag means opening simultaneously for reading and writing, the O_CREAT flag creates a file if it does not exist at the time of opening.  Flags are imported from the Fcntl module (you can do without Fcntl if you use the numerical values ‚Äã‚Äãof the flags). <br><br><h5>  2) The flock function locks the file. </h5><br>  Since we need to make sure that only one process has a lock, we need to request an exclusive lock.  Exclusive locking is set by the LOCK_EX flag.  As soon as the process gets an exclusive lock, everything, no one else can get such a lock in parallel.  This, in fact, is the basis for blocking the launch of the second copy of the program, this is a key function. <br><br>  If the flock function detects that someone else has already locked the file, then it will wait until the lock is released.  This behavior is not suitable for our verification.  We do not need to wait for the file to be released, we need the check_proc function to immediately return a positive result when a lock is detected.  To do this, use the flag LOCK_NB. <br><br>  Further behavior depends on whether the lock (3) succeeded or failed (4). <br><br><h5>  3a) The truncate function clears the file </h5><br>  Since we opened the file in non-destructive mode, the old contents of the file remained intact.  This content we do not need, and may even interfere, so the file must be cleaned. <br><br><h5>  3b) Combination of select functions and $ variable |  disables buffering </h5><br>  We need to write the PID of the current process to the PID file.  But the output to the file is buffered block by block, so the write of the pida will be (seemingly) completed, but in fact the file will be (for the present) empty.  Because of this, some other process trying to read from the PID file of the PID of our running process will find an emptiness there.  Our check is based on blocking the pid file, not on checking the pid, so for our processes the absence of the pid will not be a disaster.  But for processes for which the pit itself is important, this will create a problem. <br><br>  To disable output buffering, you need the variable $ | associated with the output handle.  set to true value.  The first select sets the handle of our pid file with the current descriptor, then the variable is set to the true value, then the second select returns STDOUT back to the place of the current descriptor.  After that, writing to the file will take place immediately, without buffering. <br><br><h5>  4a) Read the pid from the pid file </h5><br>  Reading from the file itself is trivial, but it must be kept in mind that it is possible that a pid will not be detected in the file.  This will mean that the program instance is already running (after all, the lock could not be obtained), but for some reason, the ID of this running instance was not recorded.  This should not be a problem for our verification, because it is not based on verification of the IDA.  But the check_proc function should return the true value in case of detection of the running instance, so instead of the missing pida, you need to return something else, which is, nevertheless, true. <br><br>  A suitable value in this case is ‚Äútrue zero‚Äù.  This is a magic value (of which there are many in a pearl), which is zero in a numeric context, and true in a boolean.  There are several options for recording true zero, I use the option "0 but true." <br><br><h4>  Conclusion </h4><br>  The method of blocking a pid-file is the most reliable way to ensure that the program runs in a single copy. <br><br>  The check_proc function and the connection of the Fcntl module can be put into a separate module (for example, with the name MacLeod.pm), in this case the program will be run in one copy in just two lines: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> MacLeod; check_proc(<span class="hljs-string"><span class="hljs-string">'/tmp/testscript.pid'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"  ,   !\n"</span></span>;</code> </pre><br>  Or, the check can be made a bit more detailed: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> MacLeod; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $pid = check_proc(<span class="hljs-string"><span class="hljs-string">'/tmp/testscript.pid'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($pid) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"   $pid  ,   !\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"!\n"</span></span>; }</code> </pre><br>  In this case, the return of the running process returned by the check_proc function is written to the $ pid variable and can be displayed in a message. </div><p>Source: <a href="https://habr.com/ru/post/235279/">https://habr.com/ru/post/235279/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../235259/index.html">Draw will be cast ¬©</a></li>
<li><a href="../235271/index.html">What we know and what we do not know about the assessment of labor costs in software development</a></li>
<li><a href="../235273/index.html">Unlock your phone with NFC-clips: a one-touch game</a></li>
<li><a href="../235275/index.html">Diagnosing problems in a team in four hours on the example of a live startup</a></li>
<li><a href="../235277/index.html">Year-long experiment: a smartphone without distracting programs</a></li>
<li><a href="../235281/index.html">What weapons could be different programming languages</a></li>
<li><a href="../235283/index.html">Educational program on cartographic projections with pictures</a></li>
<li><a href="../235285/index.html">Developer Contest for Epson Moverio BT-200</a></li>
<li><a href="../235287/index.html">Error based MySQL injection or do not swear</a></li>
<li><a href="../235291/index.html">Domestic software - the key to the development of intellectual production in Russia?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>