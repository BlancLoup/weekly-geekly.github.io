<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What really happened to vista</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="See also: ‚Äú What really happened with Vista: an insider retrospective ‚Äù 

 I usually eat about things that I was directly involved in ‚Äî either writing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What really happened to vista</h1><div class="post__text post__text-html js-mediator-article">  <i><font color="gray">See also: ‚Äú <a href="https://habrahabr.ru/post/347922/">What really happened with Vista: an insider retrospective</a> ‚Äù</font></i> <br><br>  I usually eat about things that I was directly involved in ‚Äî either writing code, or managing a project.  In this article, I chose a different approach to write about my view on the root causes of the Windows Vista fiasco (codename Longhorn).  Although it happened more than a decade ago, it was a key period for switching to mobile devices - and those events had long-term consequences inside Microsoft.  I found that many attempts to describe the problems of Microsoft, especially in connection with the transition to the mobile platform, are not convincing and do not coincide with my understanding of what happened.  The Vanity Fair article <a href="http://www.vanityfair.com/news/business/2012/08/microsoft-lost-mojo-steve-ballmer">‚ÄúThe Lost Decade of Microsoft‚Äù</a> describes bureaucratic rot and undercover struggle (‚Äúlife ... has become continually violent‚Äù) or cultural rot due to the negative effects of the competitive stacks rating system.  <a href="https://www.theatlantic.com/business/archive/2013/08/how-goliaths-beat-themselves-microsofts-mobile-failure-and-the-innovators-dilemma/279143/">A subsequent article</a> in The Atlantic describes the situation as a classic ‚Äúinnovator dilemma‚Äù. <br><br>  I think that the situation can be stated differently - with a better connection to specific facts about projects and the true motives of key parties.  This is not an attempt to write an alternative history - I have no idea what would happen if those mistakes were not made.  But they certainly did not help Microsoft get through this crucial moment in the computer industry. <br><a name="habracut"></a><br>  This is not a journalistic investigation - I did not conduct a large series of interviews with key participants in the events.  Here is my personal opinion based on what I saw at that time and what I learned later.  Although at the time I worked in the Office division, I had to work closely with many colleagues from the Windows division, so I am well aware of the processes that took place there. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I apologize for the large size of the article.  Here is a summary: <br><br><ul><li>  Microsoft misjudged key trends in hardware development.  In particular, a sharp turn in 2003 in the trend of a rapid increase in the frequency of a single-threaded processor, with corresponding improvements in other key elements of the PC.  Vista was planned and created for equipment that did not exist.  It was bad for desktops, worse for laptops and terrible for mobile devices. </li><li>  The C # bet and managed code was poorly justified and poorly implemented.  Responsibility for this particular failure can be directly attributed to Bill Gates and his fruitless attempts to create the holy grail from a universal repository with a universal application infrastructure.  This failure has especially long-term consequences. </li><li>  Project management in the Windows division remained at a catastrophic level throughout its history, including projects that were not brought to the end.  Vista was a disaster, but it was just the culmination of a series of almost catastrophic scenarios in a key mission of executing complex projects. </li></ul><br>  Since this is very important for this story, I want to start with a small example about the structure of the industry and the creation of value qualities. <br><br>  Any device consists of hardware, operating system (OS) and applications.  At the most basic level, the OS manages and exposes hardware resources so that applications can share them.  The OS also provides software interfaces (APIs) that allow different types of hardware to connect to the device, and APIs that provide applications with access to this hardware, as well as OS system services.  Although at the basic level, the OS provides only hardware resources, in practice the ‚ÄúOS‚Äù includes many other high-level functions, including a graphical user interface, sophisticated controls for displaying and editing formatted text or embedding HTML, high-level network support, file management, for sharing data and functionality between applications and even entire applications like a browser, email client, working with photos and cameras.  The history of the OS, especially in the consumer world, involves the inclusion of more and more high-level services, which are either directly provided to users or exposed as an API for applications. <br><br>  This development of high-level functionality is due to the <i>beneficial cycle</i> and multilateral network effects inherent in the OS business.  More and more OS users are attracting more developers.  More developers create more applications, which makes the OS more attractive to users.  This leads to a cycle where even more users lead to an even greater increase in the number of developers.  The operating system API provided is what makes the business strategy so successful and stable for the winners of this contest.  Millions of developers as a whole spend enormous efforts on programming system APIs and services behind them.  The stronger some application depends on the complex API provided by a particular OS, the more difficult it is to transfer this application to some other OS.  So, even if a competitor is able to repeat the key functionality of another OS, he still will not receive these applications.  It‚Äôs absolutely impossible for a single OS vendor to duplicate efforts spent by millions of developers. <br><br>  With this dynamic, there are many reinforcing reasons for the supplier to add ever more complex functionality and APIs to their OS, which make it easier for developers to access this functionality.  Complex functionality should attract developers, and with simple APIs they can quickly build better applications.  These best applications are immediately included in the beneficial cycle of attracting more users.  A classic example was when Windows became the first OS where it was allowed to embed HTML documents directly into applications.  Crucially, after using this functionality, it became harder to move the application to another OS. <br><br>  If you look at Windows, iOS and Android, then they all use the same strategy, although Microsoft, Apple and Google have different ways to monetize.  Microsoft classically charges for a license on each device.  It is paid by OEM builders who sell devices with Windows.  This is a horizontal business strategy with a large number of OEMs, each of which pays Microsoft for each device assembled and sold.  Apple is monetized through production and direct sales of devices.  Google depends on post-sale monetization, mainly through search.  In fact, the fear that Apple and Microsoft will take away the mobile search market (and mobile services in general) is the main reason for Google‚Äôs investment in Android.  Microsoft is also switching to direct monetization from the sale of devices (through the Surface line), as well as to post-sale monetization (through Bing and paid subscriptions like Office 365). <br><br>  Another important part that needs to be considered here is third-party middleware (middleware) like Java and Adobe Flash.  In a sense, it does not differ from high-level OS services, except that it is created and provided by a third-party company.  OS providers and developers of middleware software have a mix of love and hate.  In the sense that middleware allows developers to quickly create great applications for their platform, this is love.  The hate part is driven by several driving forces.  Certain types of middleware specifically solve the problem of creating applications that run on different platforms.  Middleware like Java and Flash are distributed under the motto ‚Äúwrite once, run everywhere‚Äù.  Applications built on such middleware are not directly dependent on the API in the OS - and therefore can run on any platform where this middleware exists.  It converts its API to the native operating system API.  (Note that modern readers can represent Java either as a server infrastructure for websites, or as a preferred language for developing Android applications. I mean the root causes of its creation as a language for browser applications on demand. As such, it was considered times when vista was planned). <br><br>  Cross-platform middleware destroys the network effects that are created as a result of binding applications to a specific OS through exclusive APIs specific to that OS.  Applications built on such middleware also tend to use the ‚Äúlowest overall functionality‚Äù of all operating systems and do not quickly adopt new features that appear in the operating system.  Some types of OS functionality create their own internal network effects, in which the more applications use this functionality, the better all applications work.  A classic example is a formatted copy-paste;  the more applications support copying and pasting of formatted content among themselves, the more valuable is the OS for each user.  If a third-party middleware provider blocks this dynamic, then over time it blocks the possibility of stable OS differentiation. <br><br>  The browser as an application delivery platform is probably the most stable example of middleware that disrupts the dynamics of the system APIs.  If you look at 35 years of computer history, then in some moments other approaches also appeared, but they all failed for reasons that we will not go into here.  For our history, it is critically important that 20 years ago it was not so obvious what all would result in.  Fear of middleware and disruption of stable differentiation of the API were major factors in the days of Vista. <br><br>  Let's look at the history of Windows and the problems in the implementation of this project. <br><br>  I am going to carry out hard work to summarize the results, but I think that we will not lose the point.  Typically, each Windows release had a main theme and an approximate time limit.  For example, Windows 95 had to update 32-bit user Windows, install a modern file system, a new UI, and standard network tools (including a browser).  In addition to the main themes, individual developers and groups independently defined key functions in their field - and began development.  The product in development turned out to be unstable, because for a long time new functions could not yet work stably with each other.  At a certain point, the developers made a decision that they developed a sufficiently well functional - and started working on stability and preparing for release.  Historically, the Windows developers usually overdue the planned release date (Windows 95 was originally called Windows 93), and the important planned functionality was either dropped or significantly reduced compared to the original plans.  The stage of preparation for release often turned into a ‚Äúdeath march‚Äù when bugs were corrected in late evenings and on weekends ‚Äî and the deadlines were constantly shifted.  I want to note that the key difference between Windows and Office was that after Office 97, the Office team set the release date of the next version ‚Äî and usually kept the deadlines.  This made it possible to achieve broad coordination with minimal overhead. <br><br>  The process was very different from modern development practices.  Regardless of whether the idea of ‚Äã‚Äãa separate function comes from top to bottom as part of a broader vision or from bottom to top from individual developers and groups, but modern practitioners usually provide for continuous quality control and very frequent releases for users.  Services can be updated in production several times a day, and a new client code is issued weekly or monthly (updating a client is expensive for both the provider and users, making it difficult to update too often).  This requires that the basic architectural and engineering infrastructure works reliably in large, complex systems, such as Windows or Office.  This process does not always make it easier for significant breakthroughs in complex functionality, but dramatically increases the flexibility of development teams and their ability to respond to external events and realities.  He also gives a much more honest assessment of real current progress.  It may be worthwhile to write a separate article, as the Office division made the transition to these modern development practices, but suffice it to say that the Windows division did not even come close to them at that time. <br><br>  Windows XP has become a major release, which also corresponded to the mentioned sad pattern.  It combined business and user platforms on a reliable Windows NT kernel with a user-friendly interface.  It was difficult to achieve compatibility with all applications created for the Windows platform, but this was a key factor for the transition to a single business and user platform.  Unfortunately, Windows XP found a 0day vulnerability that hit the headlines right on the day of the public release.  This and other information security catastrophes forced Microsoft to drastically upgrade software and rethink security development practices ‚Äî and eventually release a dimensionless service pack for Windows XP, in which most Windows divisions took part.  In addition, the key Windows kernel development groups (Core groups) worked on the 64-bit version, which is especially important for integrating Windows client and server installations (while Windows was lagging behind other corporate platforms like Sun Solaris in 64-bit computing) .  This was critically important because Windows was competing (and successfully) in the area of ‚Äã‚Äãlarger corporate servers. <br><br>  Although the large divisions of the Windows division concentrated on these initiatives, an equally large organization was involved in creating the next generation of Windows on top of the ‚Äúmanaged‚Äù C # platform.  Here you need a little explanation of the background. <br><br>  From the earliest days, the browser began to develop as an application delivery platform.  Marc Andreessen's notorious quote ‚ÄúNetscape will soon leave only a poorly tuned set of device drivers from Windows‚Äù dates back to 1995.  This led to the implementation of the embrace and extend strategy, which caused Microsoft so much trouble in the antitrust investigation.  Microsoft created and developed its own browser and mechanism for implementing proprietary ActiveX code.  At that time, Java appeared as an alternative application delivery strategy.  Developers could use Java, a high-level language with its own rich set of APIs, where the code was automatically downloaded and launched in the browser.  Java was advertised as ‚Äúwrite once, run everywhere‚Äù technology, which clearly fell into the range of ‚Äúhate‚Äù responses to middleware.  Suddenly, Microsoft signed a licensing agreement with Sun for Java, but then the company was sued when Microsoft expanded Java to directly access native Windows API interfaces (which violated the ‚Äúrun everywhere‚Äù principle, but gave Java developers access to a richer and growing set of API on the platform).  Microsoft reached a deal on the Java lawsuit and ultimately decided to go its own way with the C # programming language.  This decision was disastrous for many reasons.  (I note that C # itself is an excellent piece of technology - disaster was in strategy). <br><br>  C # is a "managed" language.  Mostly, this means that developers do not need to manage the allocation and freeing of memory "manually."  The language and runtime use <i><a href="https://en.wikipedia.org/wiki/Garbage_collection_%2528computer_science%2529">garbage collection</a></i> to automatically free any memory that is no longer in use.  It is important that the runtime also prevented the types of memory errors that caused many security vulnerabilities at the time.  At that time, and in reality over the next decade, passionate arguments continued about the effect of automatic memory management on programming performance and security.  I will not retell those arguments here.  Suffice it to say that the most successful modern iOS operating system has decided not to play these games (Android is sold in larger quantities, but iOS gets the lion's share of the profits).  Managed environments have a cost overrun compared to unmanaged environments, so they need more memory to work.  Most of the environments that take advantage of the performance of managed code, try to carefully limit its use only where it makes the most sense, and not blindly use it everywhere. <br><br>  If programmers first encountered this type of environment (which is almost 100% of the developers of a Windows project at the time), then they are not serious about using memory.  But no matter how the memory is managed, automatically or manually, it is a resource, and a frivolous attitude to the resource leads to bloated code, which requires more memory to work.  In fact, even ‚Äúhigh productivity‚Äù (generating a large amount of code) is not always the main criterion for the success of a project ( <a href="http://quoteinvestigator.com/2012/04/28/shorter-letter/">‚Äúif I had more time, I would have written a shorter letter‚Äù</a> ).  At that time, the use of more resources was part of the value system, because it increased the value of the fat client for the computing capabilities of the system (compared to a ‚Äúthin client‚Äù like a simple application that works through a web page).  When creating the Longhorn update, Windows developers would brag about how many new APIs they wrote. <br><br>  Part of the C # bet was also a bet on a rich library of main classes and the creation of a new client technology as a set of class libraries on top of this base.  The base library provided simple types such as strings and arrays, as well as more complex data structures and services like lists and hashing tables.  The point is that this should ensure consistency for the entire Windows API.  Win32 were at first relatively small uniform APIs, but over the past decade they have been heavily inflated by the efforts of so many groups that have added to the API set without any single consistent concept.  The new library was considered as an opportunity to bring everything back to normal. <br><br>  The fact that no other operating system chose such a path was seen as a kind of ‚Äúbig bet,‚Äù which was a fundamental part of the value system in the internal culture of Microsoft.  Unfortunately, apart from the problems of using bloated resources, there were fundamental challenges using the new technology in the operating system (especially with how to handle resource failures in critical parts of the OS, how to independently update applications, a controlled runtime environment and the OS, and how to make different parts of the OS developed independently of each other) that were not decided or not fully understood at that time.  There was literally no migration strategy for existing applications built on top of unmanaged Win32.  Despite this, huge armies of developers launched construction on top of this unstable platform.  What were they working on? <br><br>  In this place it makes sense to connect to the story of Bill Gates. <br><br>  The entire history of Microsoft since the founding of the company has been dedicated to the superiority of software over hardware.  Software is a universal commodity, and the value is in the programs.  If you look at the sustainable profits of the PC ecosystem, then this view really seems accurate.  Definitely accurate in terms of OEM and Microsoft relationships.  Intel company received the lion's share of profits among manufacturers of all computer equipment.  At the same time, the dynamics of the entire computer ecosystem was maintained by an endless exponential increase in the productivity of iron under the action of Moore's law and other exponential trends.  The software caught the wave because it was it that received the main economic benefit from the final product. ,      ‚Äî        . <br><br>          .         .   RIM (   Blackberry)    iPhone,  <a href="http://www.macnn.com/articles/10/12/27/rim.thought.apple.was.lying.on.iphone.in.2007/"> </a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was: "This is impossible"! It is impossible to construct a full-screen lightweight phone with a touch interface and such performance that the battery lasts for a sufficiently long time. But in reality this was possible. For the last ten years, the market has been moving forward with continuous hardware innovations (better screens, faster communication, more productive processors, more memory, better camera, new sensors, more capacious batteries, weight reduction, instant switching on) indirectly through the OS software.</font></font><br><br>  iOS    ,   ,      ,     .          Apple      ,                          ,     ,       ‚Äî    iOS             . <br><br>       ,     Windows   Vista.      ,     ,    ,     . <br><br>    Longhorn,               C#.  WinFS         .               .          ,         ,         ,           .     ,       .            .    -     Cairo,        Windows 95. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Avalon group (later Windows Presentation Foundation) was supposed to rethink the presentation layer on top of powerful graphics processors. The presentation layer focused on creating a universal canvas, where the user interface and rich application content were seamlessly mixed together, so the result was partially a document, and partly a user interface, all under the control of powerful graphics processors capable of handling 3D games. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The third group wrote code that came out as Windows Communication Foundations (WCF) to create network functions. This is a critical component of almost any modern application.</font></font><br><br>           .      C#          ,        .      API             . <br><br>     ?   ,  . <br><br>        ,      . <br><br>   Core       64- Windows,       Longhorn.   <i></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amount of code. Unfortunately, when you build a complex system and work without clear limits and deadlines, the correct mental state of a team that generates a lot of code does not match the mental state of those who build a railway across the country and have already completed it by 90%. They can rather be compared with those who dug an incredibly deep hole, and now they are thinking about how to get back and bury it. The team only coped with the understanding of all the consequences of attempting to deliver OS functions on top of this managed infrastructure. They realized that they have a ton of work to simply make the basic premises a reality. Besides all this, not one of the main components has been brought to the stage of readiness. They also began to understand the limitations of performance when introducing major new subsystems into existing code.WinFS and Avalon projects did not replace the existing OS infrastructure, but lay on top of it. So, the essential expenses of computing resources were simply added from above.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As explained in the </font><font style="vertical-align: inherit;">2005 </font></font><a href="https://www.wsj.com/articles/SB112743680328349448"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wall Street Journal article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Olchin decided to remove these major components from the release, continuing to develop them. As a result, after three years of the product cycle, work on them had to start virtually from scratch. All of these managed functions had to be excluded from the basic composition of the OS and delivered separately. Their exclusion was clearly the right decision, but the exclusion of both subsystems revealed and caused problems that would then persist for a decade.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The C # bet and managed code included a strategy that reduced investments in unmanaged Win32 layers. I remember long meetings with attempts to persuade representatives of the Windows division to make relatively small commits to the text and graphic functions necessary for Office. The exception to the release of these components of C # made it even more obvious that Windows will remain for several years without key user interface controls for developers (such as Office) in its main Win32 API.</font></font><br><br>     ,    Avalon      IE.  IE ,      Avalon,  IE          ,    .  ÃÅ   ,  HTML   ,   ,          HTML,      Avalon. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This was a huge strategic mistake that opened the door to spread Firefox, and then Google‚Äôs Chrome browser. Although it is impossible to say, it would have prevented such an outcome from investing in IE, but definitely it would not have become worse. The cessation of attachments also undermined the IE team and left them unprepared and lacking staff in the face of the continuing rapid evolution of web technologies, which ruined IE‚Äôs reputation among web developers. The fact of the mistake made immediately became obvious to everyone in the company: there was no need to be a special visionary. Office and other units in the company actively invested in the web and HTML. There was no real way how these tools could go to Avalon, and even more so the whole industry. In fact, the Avalon team never described this real way:something magical had to happen - and suddenly everyone starts to write Avalon applications instead of HTML. It was as absurd as it was shameless. Immediately after we ‚Äúwon‚Äù the browser war and watched AOL takeover of Netscape, we drastically reduce the further development of technology on these open standards. Only with the start of the project, Windows 7 restored the staff of the IE group and resumed active investments in IE and standard web technologies.Only with the start of the project, Windows 7 restored the staff of the IE group and resumed active investments in IE and standard web technologies.Only with the start of the project, Windows 7 restored the staff of the IE group and resumed active investments in IE and standard web technologies.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Other issues that follow are associated with Avalon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Avalon model was based on the concept of Bill to provide a universal canvas, a runtime environment for applications. As I explained in the article </font></font><a href="https://hackernoon.com/leaky-by-design-7b423142ece0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúLeaky at the level of architecture‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , one of the main problems for developers of frameworks like Avalon is how to open functions at different levels so that applications can become attached to them at the appropriate functional level and not incur extra productivity. If you open the functionality only at the highest level, then all the work will in fact be inaccessible for more complex applications (such as Office applications) that need to be linked at lower levels. It took another 10 years before the release of Windows 10 before they solved these problems at the architecture level.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avalon also made a bid for energy-intensive graphics cards. The mobile graphic model, although using some of the same elements, was mainly focused on achieving smooth animation through pre-rendered textures or layers, with their zooming, panning and blending. The number of layers is carefully limited, so that the mobile graphics processor shows a large frame rate, which is necessary for smooth animation and user interaction, while consuming some energy. The Avalon graphic model effectively moved in the opposite direction.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problems with WinFS in some ways turned out to be even more fundamental than with Avalon. While Avalon was supplied separately, and some key concepts were used as the basis for the UI components in Windows 8 and 10, the WinFS project was completely stopped. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initially it was assumed that WinFS </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">would become</font></font></i>  .            ,        , ‚Äî              .    ,      Windows     (  64- ).   WinFS    ,         .   ,  WinFS              .      ,       .     WinFS    ,   ¬´ ¬ª,    ,   .  Microsoft     ,     ,  WinFS.  ,         ,  √≥       ,       -        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At a deeper level, the vision of Bill's ecosystem of applications that store everything and share their data in this relational repository, directly contradicts the way applications build their data models. </font><font style="vertical-align: inherit;">While some desktop applications (and almost all internal IT applications) use relational storage for their internal data models, they don‚Äôt want to provide these data models for unsupervised reading and writing by other applications. </font><font style="vertical-align: inherit;">I explained some of the fundamental reasons in the above-mentioned article </font></font><a href="https://hackernoon.com/leaky-by-design-7b423142ece0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Leaky at the level of architecture"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">There were (and there are) many other options for applications that want to use relational storage. </font><font style="vertical-align: inherit;">And of course, the long-term trend was that all this data is moving to the cloud, and not locked into the local PC storage.</font></font><br><br>                    Vista.    ,      ,           .      Windows    Windows 7,         Windows    (DevDiv),       DevDiv,     ,  ,     .       ,      Windows     Windows 8,     ,           Windows.    .       .   ,      ‚Äî  Windows.   ¬´ ¬ª,           (, ,     Office     ).  ,            ,      ,        .        ¬´  ¬ª.   ,     Flash (   )        Silverlight      .     ,          ,        ,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If binder software is considered to be one of the worst nightmares for an OS supplier in terms of losing the monopoly on mediation, it becomes clear that "we are facing an enemy, and this is one of us." I do not declare that I have insider information for that period, but I remember the annoyance of this concentration on the layers of the managed year and their uselessness for most Office scenarios, although I cannot clearly formulate strategic issues. In fact, it was precisely system innovations in iOS that gave a clear understanding in hindsight how much the wrong direction was chosen for work.</font></font><br><br>    ,       C#, ,      Vista,      . Windows XP       64   ,    128     -   Windows XP.  Vista      512 ,       1  (         ‚ÄúVista Capable‚Äù  ).           .    ,    ¬´¬ª   -  ,       .        (    )    ,      .        ,      ,        ,         ,      .   Windows 7   ,       ‚Äî    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another blow to the reputation of Vista as a stable system was caused by the problematic nature of the drivers - key software, which was written and supplied by hardware manufacturers (graphics cards, network cards, hard drives, etc.) for embedding in the OS. In the Vista system, an important change was made in the driver model: they were taken out of the OS kernel to a layer that is more reliable to manage. The famous ‚Äúblue screen of death‚Äù of Windows XP after an operating system crash almost always appeared due to the failure of some third-party driver. Having removed this code from the kernel, Windows should have increased the overall reliability of the system.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changes in the driver model required massive changes in the driver code for Windows from all hardware manufacturers. The advantage of this major detuning from competitors becomes a stone around your neck when you try to make such large-scale changes in the entire ecosystem. Since the release of Vista was often delayed, it was difficult for hardware manufacturers to set the priority for this work and the timing of its execution. Many were not ready for Vista. This meant that the first experience of using a new system for many users was associated with missing or very buggy drivers.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The processor speed scaling collapse I mentioned at the beginning of this article contributed to performance issues. The computer industry has evolved under the influence of exponential growth in data processing ‚Äî the amount of data that can be stored and processed, processing speed, bandwidth, and communication delays between different devices. Much of this is due to Moore‚Äôs law ‚Äî a regular doubling of the number of transistors that are placed in the same area of ‚Äã‚Äãan integrated circuit. This simple doubling law is familiar to users. They can expect that Moore's law will manifest itself in increasing the processor speed, the amount of RAM, storage capacity and connection speed.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reality is a bit more complicated. The increase in processor speed is accompanied by an increase in power consumption and heat dissipation. I remember a vivid diagram showing the growth of heat in Intel processors. The logarithmic scale depicted a straight line from the first Intel processors, through the Pentium, to heat dissipation on the surface of the Sun. Here comes to mind the law of Stein: "If something can not last forever, it will not." The computer industry ran headlong into the "energy barrier". Processor speeds could not scale without an unacceptable increase in power consumption and heat dissipation. If you look at the graphics speeds of processors, then the turn occurred in 2003, at the height of the Vista fiasco. Other trends also made the naive perception of improvements in productivity dangerous.Chip makers produced memory chips with a higher density of transistors, but the ‚Äúmemory barrier‚Äù meant that the delay between the CPU and the memory made it more and more difficult to efficiently use all this memory. Perhaps most of the problems in creating a balanced PC system were caused by an increase in disk capacity, but a much slower increase in the number of random I / O operations per second. This meant that larger programs were placed on larger disks, but they loaded much slower. Because of the imbalance, fast programs could easily make I / O requests faster than the disk was able to process them - the result was slowed-down systems, despite the increase in processor speed and more memory.that the delay between the CPU and the memory made it more and more difficult to effectively use all this memory. Perhaps most of the problems in creating a balanced PC system were caused by an increase in disk capacity, but a much slower increase in the number of random I / O operations per second. This meant that larger programs were placed on larger disks, but they loaded much slower. Because of the imbalance, fast programs could easily make I / O requests faster than the disk was able to process them - the result was slowed-down systems, despite the increase in processor speed and more memory.that the delay between the CPU and the memory made it more and more difficult to effectively use all this memory. Perhaps most of the problems in creating a balanced PC system were caused by an increase in disk capacity, but a much slower increase in the number of random I / O operations per second. This meant that larger programs were placed on larger disks, but they loaded much slower. Because of the imbalance, fast programs could easily make I / O requests faster than the disk was able to process them - the result was slowed-down systems, despite the increase in processor speed and more memory.but a much slower increase in the number of random I / O operations per second. This meant that larger programs were placed on larger disks, but they loaded much slower. Because of the imbalance, fast programs could easily make I / O requests faster than the disk was able to process them - the result was slowed-down systems, despite the increase in processor speed and more memory.but a much slower increase in the number of random I / O operations per second. This meant that larger programs were placed on larger disks, but they loaded much slower. Because of the imbalance, fast programs could easily make I / O requests faster than the disk was able to process them - the result was slowed-down systems, despite the increase in processor speed and more memory.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vista came out in a period when the transition to a mobile platform accelerated. Laptop sales surpassed desktop sales in 2003; and by 2005, laptops had overtaken desktops by the number of devices sold. Because Vista did not work so well on cheap new laptops ("netbooks"), Microsoft had to allow OEM builders to continue shipping Windows XP to these lower-priced machines.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An important part of what is happening here was a deeper problem - the fundamental sufficiency of the desktop PC form factor for those tasks that were solved on it. The main areas of use are productivity (mainly Office), communications, surfing (including search, websites and web applications), some internal business applications, and frontend for specialized devices (think of your dentist‚Äôs X-ray machine). All this has generally stabilized by the year 2000 and has not changed much since then. Microsoft could create new APIs, but computers already did almost everything that users needed. Improvements needed by people ‚Äî better controllability, stability, performance, security from the software side and longer battery life, lighter weight, faster processors,increased communication speed, larger screens - from the hardware side. Many of these improvements required a decrease in software, rather than an increase.</font></font><br><br>  ‚Äî     ,             <a href="https://www.amazon.com/Innovators-Dilemma-Technologies-Management-Innovation-ebook/dp/B00E257S86/">¬´ ¬ª</a> .    <a href="https://www.amazon.com/Rise-Fall-American-Growth-Princeton/dp/0691147728/">¬´    ¬ª</a>            .  ‚Äî    .         ‚Äî  ,         ,      .   ,       ,        ,               .       -           .  ,     ,    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that here I focus on the sufficiency of the form factor. General computing requirements in the economy continued to grow at an explosive pace. But faster and ubiquitous communications meant more flexibility in how the application distributes its computing requirements (data and processing) between different nodes in the system. In the past two decades, under the influence of many factors, an increasing part of the processing goes to the server or to the cloud. I'd rather have powered these computational cycles from the Grand Coulee HPP with a server in eastern Washington state than carrying a battery with me. If you need access to data from different devices or multiple users, then I want to store and process them on the server, not on the local PC.Progress in wireless communications (and overall bandwidth end-to-end communications) has made this device operation scenario exceptionally stable.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We did not observe this only on desktop computers (including laptops). Probably, the tablets showed a trend of sufficiency of the form factor more than anything else. Although in a broader perspective it is not. For decades, various tablet reincarnations have not satisfied us with weight, battery life, computational power, input modes, and total response time. But when the iPad appeared on the scene with its combination of screen size, weight, battery life, touch input, processor speed, and instant power-on, we reached a sufficient point. The changes that have been made since then are mostly incremental in nature - which makes the engineers who work on these things crazy and spend a lot of energy and creative powers. Engineers from Maytag, working on a new washing machine, should have the same feelings.</font></font><br><br> ,    ,      .        ‚Äî         . , ,     .   ,            ,        . <br><br>         ? <br><br>     ,   .   .     . <br><br>           .      ,        ,    .            ‚Äî   .  ,     ,               ,   .        ,       .    ,         . <br><br>     ,      - ,              . -     ,       <a href="http://lib.ru/KLARK/superior.txt">¬´ ¬ª</a> ,    1951 .    ‚Äî         . </div><p>Source: <a href="https://habr.com/ru/post/348386/">https://habr.com/ru/post/348386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348376/index.html">pdbe is an assistant to the built-in python debugger and debugging process</a></li>
<li><a href="../348378/index.html">VDOM do it yourself</a></li>
<li><a href="../348380/index.html">8-bit computer with BASIC and VGA-out on the Arduino</a></li>
<li><a href="../348382/index.html">Is it true that PM does something useful and what it takes to become</a></li>
<li><a href="../348384/index.html">Pygest # 22. Releases, articles, interesting projects, packages and libraries from the world of Python [January 18, 2018 - February 4, 2018]</a></li>
<li><a href="../348390/index.html">Web typography: create tables for reading, not for beauty</a></li>
<li><a href="../348392/index.html">The obvious benefit: how and why to use the service approach beyond IT (Part 2)</a></li>
<li><a href="../348394/index.html">Notes on deploying Ruby on Rails Deployment on Google Cloud Kubernetes Engine</a></li>
<li><a href="../348396/index.html">How I hacked the bitcoin mining pool</a></li>
<li><a href="../348398/index.html">Product Design Digest, January 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>