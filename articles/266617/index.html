<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Free realtime list of online users (Parse.com + Pubnub)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once I wrote a familiar task for practice: write an application where there is one login / login button and an online user list. At the same time, use...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Free realtime list of online users (Parse.com + Pubnub)</h1><div class="post__text post__text-html js-mediator-article">  Once I wrote a familiar task for practice: write an application where there is one login / login button and an online user list.  At the same time, users must "live" only 30 seconds.  As is always the case, during the initial consideration of the problem, I thought: ha, what is there to do then?  We use cloud storage and a server for users, and then it‚Äôs a bit small ... but it‚Äôs not there. <br><br>  Under the cut, I'll tell you what problems I had to face when developing the backend on Parse.com, why I had to use it in conjunction with Pubnub, and how to connect all this when developing for Android. <br><br>  What happened in the end: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/d0f/9a7/2c8/d0f9a72c8afd031e82f31d48d6f327c0.gif" alt="Demonstration"><br><br><a name="habracut"></a><br>  Strictly speaking, the topic of bundles Parse.com and Pubnub have already been <a href="http://habrahabr.ru/post/198864/">engaged in Habr√©</a> .  However, unlike the article, here I want to stop in more detail on the cloud code Parse.com, and the target application is developing for Android, and not iOS. <br><br><h4>  Parse.com </h4><br>  <a href="https://parse.com/">Parse.com</a> provides extensive cloud functionality: here is the database in a beautiful graphical wrapper, and server code, and analytics, and even push notifications!  And everything is free until you cross the threshold of <a href="https://parse.com/plans">30 requests per second, 20GB of used storage capacity, etc.</a>  .  I was completely satisfied with these requirements (it's free!), So the choice fell on this service. <br><br><h5>  Problems </h5><br>  Having thoroughly studied the <a href="https://parse.com/docs/android/guide">guide</a> , several problems surfaced, connected with the <i>real-time</i> list of online users and their <u>lifetime</u> : <br><ol><li>  no fields of type Timer for custom objects </li><li>  the service does not provide the possibility of a <a href="http://javascript.ru/ajax/comet/long-poll">long pulling</a> (or I did not find one like this) </li><li>  Standard class User / Session is not suitable for this task. </li></ol><br><h5>  Solutions </h5><br>  Let me explain why this is exactly the problem. <br>  The Timer type (or something like that) was planned to be used as an expireAt field in order to receive notifications (ideally, automatically delete) about when the user ‚Äúdies‚Äù. <br><br>  In the absence of this type, you will have to use the usual Date type and watch yourself when the user needs to be ‚Äúkilled‚Äù. <br><br>  It was planned to use long pulling to track incoming / outgoing users, but the service does not provide such an option out of the box. <br><br>  It was decided to use <a href="https://parse.com/docs/android/guide">installations</a> .  In short, these are global channels for transferring data between anyone (server-client, client-client, etc.).  Thus, after the login / login the server should send a message to the channel that such and such a user is logged in / out.  This provides a real-time user list.  (However, this is not entirely true, but more on that later). <br><br>  The Parse.com SDK has built-in login / login methods, so it would be very nice to use them when developing.  However, this proved impossible. <br><br>  As mentioned above, when logging in / logging out, a message should be sent to the channel about whether the user is ‚Äúalive‚Äù (or ‚Äúdead‚Äù if he has logged out).  The service provides the ability to create triggers, for example, AfterSave, beforeDelete, etc.  The problem is that there are no such events for Session.  This means that for each file you need to literally delete the user with his session, which negates all the advantages of the methods built into the SDK. <br><br>  Therefore, it was decided to use the IMH_Session custom class, by hooking it with the afterDelete and afterSave triggers, in which an alert is sent to the global channel. <br><br><h5>  Nuances </h5><br>  And then it would be time to celebrate and sit down victoriously at Android Studio, but ... installations are based on default push notifications.  Let me explain for those who, like me, in the tank.  Push notifications do not guarantee anything.  They work on the principle of Fire &amp; Forget, that is, by sending a push notification, there is no certainty that it <b>reached</b> the addressee.  Moreover, it is impossible to even say <b>when</b> it happened! <br><br>  So there‚Äôs no real-time talk. <br><br>  There is also a problem with flooding in the channel.  Installations are equal, so any client can send anything, and the rest will have to choose from this garbage only server messages.  And it's not a fact that they are from the server.  There is a problem of verification.  At a minimum, for each message to the server, you will have to send a request to confirm information about the user, which will lead to chaos and those same free 30 requests per second will quickly end. <br><br><h4>  Pubnub </h4><br>  Despite the deplorable situation, a solution was found.  This output was <a href="http://www.pubnub.com/">Pubnub</a> .  In general, this service out of the box provides the SDK for online chat, but, unfortunately, <a href="http://www.pubnub.com/pricing/">it is paid and is called an addon</a> . <br><br>  The service itself provides everything you need for real-time applications.  But we are only interested in one thing - realtime broadcast channels.  They are free, easy to use and, perhaps most importantly, they have access control!  Just what we need to not bother with verification. <br><br>  The delimitation occurs due to two separate keys: publish_key and subscribe_key.  As you probably already guessed, the first key goes to the server, and the second to the client application.  If you keep the key secret first, no one will spam the channel and you can trust any message specified in it.  Perfect! <br><br>  <s>ps I‚Äôm writing Parse.com, but Pubnub (without `.com`) is just because I‚Äôm used to it.</s>  <s>Hope this doesn't hurt anyone's eyes.</s> <br><br><h4>  Backend - Parse.com </h4><br>  Now it was necessary to start organizing the server API and its implementation.  Let me remind you that the idea of ‚Äã‚Äãthe pipeline is: <br><ol><li>  custom (via API) login () </li><li>  Parse.com cloud code </li><li>  creation of the user in a DB </li><li>  trigger afterSave (), notifying Pubnub channel about user login </li><li>  return current user in response to login () </li></ol><br>  The following APIs have been created for this: <br><ul><li>  Login </li><li>  Logout </li><li>  Getonlineusers </li><li>  Getnow </li></ul><br>  I will explain about the latter.  I planned to use it to synchronize client time with server time.  I implemented the API myself, but I didn‚Äôt make it in my hands.  However, the API itself, I decided to leave. <br><br>  I apologize in advance for the smell of the code.  Never a js developer.  I will consider any wishes on his organization: <br><div class="spoiler">  <b class="spoiler_title">Server code</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*global Parse:false, $:false, jQuery:false */</span></span> <span class="hljs-comment"><span class="hljs-comment">// Importas var _ = require('underscore'); // jshint ignore:line var moment = require('moment'); // jshint ignore:line // Constants var sessionObjName = "IMH_Session"; var sessionLifetimeSec = 13; var channelName = "events"; var publishKey = "pub-c-6271f363-519a-432d-9059-e65a7203ce0e", subscribeKey = "sub-c-a3d06db8-410b-11e5-8bf2-0619f8945a4f", httpRequestUrl = 'http://pubsub.pubnub.com/publish/' + publishKey + '/' + subscribeKey + '/0/' + channelName + '/0/'; // Utils function Log(obj, tag) { "use strict"; var loggingString = "Cloud_code: "; if (tag != null) { // jshint ignore:line loggingString += "[" + tag + "] "; } loggingString += JSON.stringify(obj) + "\n"; console.log(loggingString); // jshint ignore:line } function GetNow() { "use strict"; return moment.utc(); } // Supporting var baseSession = {udid: "", loginedAt: GetNow(), aliveTo: GetNow()}; var errorHandler = function(error) { "use strict"; Log(error.message, "error"); }; function DeleteSession(obj) { obj.set("loginedAt", obj.get("aliveTo")); SendEvent(obj); obj.destroy(); } function DeleteDeadSessions() { "use strict"; var query = new Parse.Query(sessionObjName); // jshint ignore:line var promise = query.lessThanOrEqualTo("aliveTo", GetNow().toDate()) .each(function(obj) { Log(obj, "Delete dead session"); DeleteSession(obj); } ); return promise; } function NewSession(udid) { "use strict"; var session = _.clone(baseSession); session.udid = udid; session.loginedAt = GetNow(); session.aliveTo = GetNow().add({seconds: sessionLifetimeSec}); return session; } function GetSessionQuery() { "use strict"; var objConstructor = Parse.Object.extend(sessionObjName); // jshint ignore:line var query = new Parse.Query(objConstructor); //query.select("udid", "loginedAt", "aliveTo"); //not work for some reason return query; } function IsUserOnline(udid, onUserOnlineHanlder, onUserOfflineHanlder, onError) { "use strict"; var userAlive = false; var query = GetSessionQuery(); query.equalTo("udid", udid).greaterThanOrEqualTo("aliveTo", GetNow().toDate()); query.find({ success: function(result) { if (result.length == 0) { onUserOfflineHanlder(); } else { onUserOnlineHanlder(result); } }, error: onError }); } function NewParseSession(session) { "use strict"; var objConstructor = Parse.Object.extend(sessionObjName); // jshint ignore:line var obj = new objConstructor(); obj.set({ udid: session.udid, loginedAt: session.loginedAt.toDate(), aliveTo: session.aliveTo.toDate() } ); return obj; } function SendEvent(session) { "use strict"; Parse.Cloud.httpRequest({ // jshint ignore:line url: httpRequestUrl + JSON.stringify(session), success: function(httpResponse) {}, error: function(httpResponse) { Log('Request failed with response code ' + httpResponse.status); } }); } // API functions var API_GetNow = function(request, response) { "use strict"; var onUserOnline = function(result) { response.success( GetNow().toDate() ); }; var onUserOffline = function(error) { response.error(error); }; var onError = function(error) { response.error(error); }; IsUserOnline(request.params.udid, onUserOnline, onUserOffline, onError); }; var API_GetOnlineUsers = function(request, response) { "use strict"; var onUserOnline = function(result) { var query = GetSessionQuery() .addDescending("aliveTo"); query.find({ success: function(result) { response.success( JSON.stringify(result) ); }, error: errorHandler }); }; var onUserOffline = function(error) { response.error(error); }; var onError = function(error) { response.error(error); }; DeleteDeadSessions().always( function() { IsUserOnline(request.params.udid, onUserOnline, onUserOffline, onError); }); }; var API_Login = function(request, response) { "use strict"; var userUdid = request.params.udid; var session = NewSession(userUdid); var parseObject = NewParseSession(session); Parse.Cloud.run("Logout", {udid: userUdid}).always( function() { parseObject.save(null, { success: function(obj) { Log(obj, "Login:save"); response.success( JSON.stringify(parseObject) ); }, error: function(error) { errorHandler(error); response.error(error); } }); }); }; var API_Logout = function(request, response) { "use strict"; var userUdid = request.params.udid; var query = GetSessionQuery() .equalTo("udid", userUdid); query.each( function(obj) { Log(obj, "Logout:destroy"); DeleteSession(obj); }).done( function() {response.success();} ); }; // Bindings Parse.Cloud.afterSave(sessionObjName, function(request) { // jshint ignore:line "use strict"; SendEvent(request.object); }); // API definitions Parse.Cloud.define("GetNow", API_GetNow); // jshint ignore:line Parse.Cloud.define("GetOnlineUsers", API_GetOnlineUsers); // jshint ignore:line Parse.Cloud.define("Login", API_Login); // jshint ignore:line Parse.Cloud.define("Logout", API_Logout); // jshint ignore:line</span></span></code> </pre> <br></div></div><br>  As you can see, I did without the afterDelete () trigger.  The reason is that with afterDelete () I had races.  On the one hand, the newly released user is now deleted and will soon send an alert to the channel.  On the other hand, he immediately tries to log in again. <br>  In the end, the channel will see something like ‚ÄúX went in,‚Äù ‚ÄúX went in,‚Äù ‚ÄúX went out.‚Äù  The last two messages are not in their places.  Because of this, there have been situations on the client when the user seems to be still ‚Äúalive‚Äù and has just entered, but is not displayed in the online list, because if you believe the channel, then it is ‚Äúdead.‚Äù <br><br><h5>  More nuances! </h5><br>  As noted earlier, Parse.com makes it necessary to use Date, instead of any Timer, to organize expireAt (in our case, aliveTo).  But the question is: when will they check all users on whether they are ‚Äúalive‚Äù or already ‚Äúdead‚Äù? <br><br>  One solution is to use <a href="https://parse.com/docs/android/guide">Job</a> and delete inactive users every 5-10 seconds.  But strictly speaking, this is not quite realtime.  I wanted users to "die" instantly, regardless of some kind of background-job (by the way, it has a limit on the maximum execution time - 15 minutes. So it would have to be recreated all the time).  Therefore, a different approach was implemented. <br><br>  How does the ordinary life of the user: <br><br>  Login -&gt; GetOnlineUsers -&gt; Logout <br><br>  or <br><br>  Login -&gt; GetOnlineUsers -&gt; minimized the application, that is, skipped messages in the channel -&gt; GetOnlineUsers -&gt; Logout <br><br>  It was decided to remove the ‚Äúdead‚Äù users at the moment when someone requests GetOnlineUsers.  This means that, in fact, ‚Äúdead‚Äù users can be stored in the database for at least as long as someone requests a list of ‚Äúlive‚Äù.  At this moment, all dead users will be removed (in the best traditions of lazy computing). <br><br>  Thus, the "life" of users will have to follow locally on the client.  Alert in the channel about the death of the user will come only if he logged out himself.  Otherwise, the user is considered alive forever. <br><br><h4>  Android </h4><br><h5>  Pubnub </h5><br>  Pubnub SDK, or rather its free part, is very easy to use.  To begin with, a wrapper was made over Pubnub so that, if anything, you could use any other service: <br><br><div class="spoiler">  <b class="spoiler_title">Wrap over Pubnub - Channel</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PubnubChannel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Channel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CHANNEL_NAME = <span class="hljs-string"><span class="hljs-string">"events"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String SUBSCRIBE_KEY = <span class="hljs-string"><span class="hljs-string">"sub-c-a3d06db8-410b-11e5-8bf2-0619f8945a4f"</span></span>; Pubnub pubnub = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pubnub(<span class="hljs-string"><span class="hljs-string">""</span></span>, SUBSCRIBE_KEY); Callback pubnubCallback = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Callback() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String channel, Object message)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (listener != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { listener.onConnect(channel, <span class="hljs-string"><span class="hljs-string">"Connected: "</span></span> + message.toString()); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disconnectCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String channel, Object message)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (listener != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { listener.onDisconnect(channel, <span class="hljs-string"><span class="hljs-string">"Disconnected: "</span></span> + message.toString()); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reconnectCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String channel, Object message)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (listener != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { listener.onReconnect(channel, <span class="hljs-string"><span class="hljs-string">"Reconnected: "</span></span> + message.toString()); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">successCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String channel, Object message, String timetoken)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (listener != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { listener.onMessageRecieve(channel, message.toString(), timetoken); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String channel, PubnubError error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (listener != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { listener.onErrorOccur(channel, <span class="hljs-string"><span class="hljs-string">"Error occured: "</span></span> + error.toString()); } } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PubnubChannel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ setName(CHANNEL_NAME); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ChannelException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { pubnub.subscribe(CHANNEL_NAME, pubnubCallback); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (PubnubException e) { e.printStackTrace(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChannelException(ChannelException.CONNECT_ERROR, e); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pubnub.unsubscribeAll(); } }</code> </pre><br></div></div><br>  Then a wrapper was made over the obstetric (yes-yes), in order to track not some messages in the channel, but counter users: <br><br><div class="spoiler">  <b class="spoiler_title">Wrap on Channel - ServerChannel</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerChannel</span></span></span><span class="hljs-class"> </span></span>{ Logger l = LoggerFactory.getLogger(ServerChannel.class); JsonParser jsonParser; Channel serverChannel; ServerChannel.EventListener listener; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Channel.EventListener listenerAdapter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Channel.EventListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String channel, String greeting)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDisconnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String channel, String reason)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (listener != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { listener.onDisconnect(reason); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReconnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String channel, String reason)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessageRecieve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String channel, String message, String timetoken)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (listener != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { ServerChannel.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onMessageRecieve(message, timetoken); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onErrorOccur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String channel, String error)</span></span></span><span class="hljs-function"> </span></span>{ l.warn(String.format(<span class="hljs-string"><span class="hljs-string">"%s : [error] %s"</span></span>, channel, error)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (listener != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { ServerChannel.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe(); } } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServerChannel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Channel serverChannel, JsonParser jsonParser)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serverChannel = serverChannel; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jsonParser = jsonParser; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull ServerChannel.EventListener listener)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listener = listener; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ listener = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ChannelException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { serverChannel.setListener(listenerAdapter); serverChannel.subscribe(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ChannelException e) { e.printStackTrace(); serverChannel.clearListener(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ serverChannel.unsubscribe(); serverChannel.clearListener(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessageRecieve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String userJson, String timetoken)</span></span></span><span class="hljs-function"> </span></span>{ DyingUser dyingUser = jsonParser.fromJson(userJson, DyingUser.class); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dyingUser != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dyingUser.isAlive()) { listener.onUserLogin(dyingUser); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { listener.onUserLogout(dyingUser); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDisconnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String reason)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUserLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DyingUser dyingUser)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUserLogout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DyingUser dyingUser)</span></span></span></span>; } }</code> </pre><br></div></div><br><h5>  Parse.com </h5><br>  Again, nothing complicated.  All logic is stored on the server.  All we need is to use the API and parse json into the objects. <br><br><div class="spoiler">  <b class="spoiler_title">AuthApi</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthApi</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Api</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String API_Login = <span class="hljs-string"><span class="hljs-string">"Login"</span></span>, API_Logout = <span class="hljs-string"><span class="hljs-string">"Logout"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AuthApi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JsonParser parser)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(parser); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DyingUser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String udid)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ApiException </span></span>{ DyingUser dyingUser; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { String jsonObject = ParseCloud.callFunction(API_Login, constructRequestForUser(udid)); dyingUser = parser.fromJson(jsonObject, DyingUser.class); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ParseException e) { e.printStackTrace(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApiException(ApiException.LOGIN_ERROR, e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dyingUser; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DyingUser dyingUser)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ParseCloud.callFunction(API_Logout, constructRequestForUser(dyingUser.getUdid())); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ParseException e) { e.printStackTrace(); } } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">UserApi</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserApi</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Api</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String API_GetOnlineUsers = <span class="hljs-string"><span class="hljs-string">"GetOnlineUsers"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserApi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JsonParser parser)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(parser); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> ArrayList&lt;DyingUser&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOnlineUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DyingUser dyingUser)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ApiException </span></span>{ ArrayList&lt;DyingUser&gt; users; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { String jsonUsers = ParseCloud.callFunction(API_GetOnlineUsers, constructRequestForUser(dyingUser.getUdid())); users = parser.fromJson(jsonUsers, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeToken&lt;List&lt;DyingUser&gt;&gt;(){}.getType()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ParseException e) { e.printStackTrace(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApiException(ApiException.GET_USERS_ERROR, e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> users; } }</code> </pre><br></div></div><br>  Well, the base class: <br><br><div class="spoiler">  <b class="spoiler_title">Api</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Api</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> JsonParser parser; Api(JsonParser parser) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parser = parser; } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Map&lt;String, ?&gt; constructRequestForUser(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String udid) { Map&lt;String, String&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); result.put(<span class="hljs-string"><span class="hljs-string">"udid"</span></span>, udid); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre><br></div></div><br>  Using the above classes and their methods, we get access to the login, login and get online user list. <br><br><h5>  Realtime </h5><br><h6>  UI update </h6><br>  Since the users "die" and rather quickly, it was decided to display their remaining time of life.  Since the lifetime is measured in seconds and the goal of the task in providing real-time, the UI should be updated at least once a second.  For this, the TimeTicker class has been made, whose object is stored in the Activity.  Activity fragments during onAttach () receive a TimeTicker object from the Activity () (for this is the TimeTicker.Owner interface) and subscribe to its events. <br><br><div class="spoiler">  <b class="spoiler_title">Timeticker</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimeTicker</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Listenable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimeTicker</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventListener</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> TICKING_PERIOD_MS_DEFAULT = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> DO_INSTANT_TICK_ON_START_DEFAULT = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> tickingPeriodMs; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> doInstantTickOnStart; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Handler uiHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Handler(Looper.getMainLooper()); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Timer tickingTimer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(); TimerTask tickingTask; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TimeTicker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(DO_INSTANT_TICK_ON_START_DEFAULT); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TimeTicker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> doInstantTickOnStart)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doInstantTickOnStart = doInstantTickOnStart; setTickingPeriodMs(TICKING_PERIOD_MS_DEFAULT); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTickingPeriodMs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tickingPeriodMs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tickingPeriodMs = tickingPeriodMs; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tickingTask != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { stop(); } tickingTask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerTask() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uiHandler.post(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ forEachListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ListenerExecutor&lt;TimeTicker.EventListener&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ getListener().onSecondTick(); } }); } }); } }; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> delay = (doInstantTickOnStart) ? <span class="hljs-number"><span class="hljs-number">0</span></span> : tickingPeriodMs; tickingTimer.scheduleAtFixedRate(tickingTask, delay, tickingPeriodMs); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tickingTask != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { tickingTask.cancel(); } tickingTask = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; tickingTimer.purge(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Listenable</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSecondTick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Owner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">TimeTicker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTimeTicker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } }</code> </pre><br></div></div><br>  This ensures that the UI is updated once a second, which means that everything looks as if users are gradually dying. <br><br><h6>  List of "dying" users </h6><br>  This problem seemed to me the most interesting of all related to this task: we have a list of users who "die."  Their time is close to zero, and when this happens, the user should be removed from the list. <br><br>  The simplest implementation is to tie the timer to each user and delete it when reaching "death".  However, this is not a particularly interesting decision.  Let's pervert!  This is the implementation I got with the use of one timer and the possibility of pause / resume (if the application is minimized, for example, it comes in handy). <br><br>  <s>I have never refactored this code since I wrote it for the first time, so it may not be very good:</s> <br><br><div class="spoiler">  <b class="spoiler_title">TemporarySet</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemporarySet</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TItem</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Listenable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemporarySet</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventListener</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resumable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SortedSet&lt;TemporaryElement&lt;TItem&gt;&gt; sortedElementsSet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeSet&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;TItem&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Timer timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> TimerTask timerTask = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> TemporaryElement&lt;TItem&gt; nextElementToDie = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isResumed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TemporarySet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ notifier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TemporarySet.EventListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCleared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TemporarySet.EventListener listener : getListenersSet()) { listener.onCleared(); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TemporarySet.EventListener listener : getListenersSet()) { listener.onAdded(item); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TemporarySet.EventListener listener : getListenersSet()) { listener.onRemoved(item); } } }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TItem object, DateTime deathTime)</span></span></span><span class="hljs-function"> </span></span>{ TemporaryElement&lt;TItem&gt; element = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TemporaryElement&lt;&gt;(object, deathTime); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _add(element); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TItem object)</span></span></span><span class="hljs-function"> </span></span>{ TemporaryElement&lt;TItem&gt; element = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TemporaryElement&lt;&gt;(object); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _remove(element); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ _clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> List&lt;TItem&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asReadonlyList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.unmodifiableList(list); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ cancelNextDeath(); list.clear(); sortedElementsSet.clear(); notifier.onCleared(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TemporaryElement&lt;TItem&gt; insertingElement)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> wasInserted = _insertElementUnique(insertingElement); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wasInserted) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextElementToDie != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; nextElementToDie.deathTime.isAfter(insertingElement.deathTime)) { cancelNextDeath(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextElementToDie == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { openNextDeath(); } notifier.onAdded(insertingElement.object); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wasInserted; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TemporaryElement&lt;TItem&gt; deletingElement)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> wasDeleted = _deleteElementByObject(deletingElement); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wasDeleted) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextElementToDie.equals(deletingElement)) { cancelNextDeath(); openNextDeath(); } notifier.onRemoved(deletingElement.object); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wasDeleted; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openNextDeath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ cancelNextDeath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sortedElementsSet.size() != <span class="hljs-number"><span class="hljs-number">0</span></span>) { nextElementToDie = sortedElementsSet.first(); timerTask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerTask() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ _remove(nextElementToDie); } }; DateTime now = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(); Duration duration = TimeUtils.GetNonNegativeDuration(now, nextElementToDie.deathTime); timer.schedule(timerTask, duration.getMillis()); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancelNextDeath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timerTask != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { timerTask.cancel(); } timer.purge(); nextElementToDie = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; timerTask = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> Iterator&lt;TemporaryElement&lt;TItem&gt;&gt; findElement(TemporaryElement&lt;TItem&gt; searchingElement) { Iterator&lt;TemporaryElement&lt;TItem&gt;&gt; resultIterator = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Iterator&lt;TemporaryElement&lt;TItem&gt;&gt; iterator = sortedElementsSet.iterator(); iterator.hasNext() &amp;&amp; resultIterator == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iterator.next().equals(searchingElement)) { resultIterator = iterator; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resultIterator; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_insertElementUnique</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TemporaryElement&lt;TItem&gt; element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> wasInserted = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Iterator&lt;TemporaryElement&lt;TItem&gt;&gt; iterator = findElement(element); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iterator == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { wasInserted = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; sortedElementsSet.add(element); list.add(element.object); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wasInserted; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_deleteElementByObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TemporaryElement&lt;TItem&gt; element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> wasDeleted = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Iterator&lt;TemporaryElement&lt;TItem&gt;&gt; iterator = findElement(element); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iterator != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { wasDeleted = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; iterator.remove(); list.remove(element.object); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wasDeleted; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ isResumed = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; openNextDeath(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ cancelNextDeath(); isResumed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isResumed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isResumed; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Listenable</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCleared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object item)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object item)</span></span></span></span>; } }</code> </pre><br></div></div><br>  I want to note that there is an asReadonlyList method that I do not use.  Previously, it was used as an Adapter argument for a ListFragment, which made it possible not to use any EventListener at all.  But later I decided to move away from this undertaking, but the code decided to leave (for the future, to see how you should not do it). <br><br>  The largest orgy in this list is created in the findElement, _insertElementUnique and _deleteElementByObject methods.  The reason is that SortedSet stores objects sorted by date and, accordingly, the search also takes place by date.  However, when the user "dies", the server sends a message in which loginedAt == deathAt, which leads to the madness of SortedSet and the entire TemporarySet. <br><br>  Since <a href="http://stackoverflow.com/a/156685/2653714">there are no normal Pair &lt;A, B&gt;</a> in Java ( <b>upd:</b> as <a href="https://habrahabr.ru/users/bringoff/" class="user_link">Bringoff</a> rightly pointed out, <a href="http://developer.android.com/reference/android/util/Pair.html">it is still there</a> ), the wrapper was implemented: <br><br><div class="spoiler">  <b class="spoiler_title">TemporaryElement</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemporaryElement</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> T object; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DateTime deathTime; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TemporaryElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull T object, @NonNull DateTime deathTime)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.deathTime = deathTime; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.object = object; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TemporaryElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull T object)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(object, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">0</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; TemporaryElement&lt;?&gt; that = (TemporaryElement&lt;?&gt;) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> object.equals(that.object); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> object.hashCode(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Object another)</span></span></span><span class="hljs-function"> </span></span>{ TemporaryElement a = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, b = (TemporaryElement) another; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> datesComparisionResult = a.deathTime.compareTo(b.deathTime); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> objectsComparisionResult = a.hashCode() - b.hashCode(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (datesComparisionResult != <span class="hljs-number"><span class="hljs-number">0</span></span>) ? datesComparisionResult : objectsComparisionResult; } }</code> </pre><br></div></div><br>  As a result, the implemented TemporarySet allows you to add / delete users with a lifetime, after which it remains only to implement the TemporarySet.EventListener interface and wait. <br><br><h4>  Conclusion </h4><br>  The task turned out to be more difficult than originally planned.  I spent a lot of time parsing the Parse.com Guide.  Here, for example, one of the nuances: <br><br><div class="spoiler">  <b class="spoiler_title">afterSave</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Parse.Cloud.afterSave(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request</span></span></span><span class="hljs-function">) </span></span>{}); <span class="hljs-comment"><span class="hljs-comment">// custom Foo object Parse.Cloud.afterSave("User", function(request) {}); // custom(!) User object Parse.Cloud.afterSave(Parse.User, function(request) {}); // Parse.com User object Parse.Cloud.afterSave(Parse.Session, function(request) {}); // error! can't bind to Parse.Session</span></span></code> </pre><br></div></div><br>  Much time was spent on gradient animation.  More precisely, not so much on the animation, as on the search for a ready-made solution.  Unfortunately, I did not find a suitable method for me, so I wrote my solution.  I wrote <a href="http://stackoverflow.com/questions/32224797/how-to-animate-gradient">in</a> detail <a href="http://stackoverflow.com/questions/32224797/how-to-animate-gradient">on stackoverflow in broken English</a> . <br><br>  All my code can be viewed <a href="">here</a> . <br><br>  To be fair, I would like to note that it would be nice to add something like GetUsersChangesAfterDate () to the API, which would allow you to receive changes in the list of users after the specified date (I mean, turned off the application -&gt; deployed -&gt; GetUsersChangesAfterDate). <br><br>  And at the end I would like to ask a few questions to the reader: <br><ol><li>  Could it have been easier, but also free? </li><li>  Is there an easier way to update a UI every N seconds? </li><li>  What to do with the time of life "0: 0" the user?  Should we artificially add 1 second to the time of life, so that the user ‚Äúdies‚Äù after ‚Äú0: 1‚Äù?  Or is it decided somehow differently?  Or leave "0: 0" - is this normal? </li></ol></div><p>Source: <a href="https://habr.com/ru/post/266617/">https://habr.com/ru/post/266617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266607/index.html">Energy Efficiency Data Center: Water and Refrigerants</a></li>
<li><a href="../266609/index.html">Incoding Framework - Get started</a></li>
<li><a href="../266611/index.html">Layout letters: What is "kinetic email"</a></li>
<li><a href="../266613/index.html">Duck stories: duck looking for bugs</a></li>
<li><a href="../266615/index.html">Asynchronous execution of PHP script on subprocesses</a></li>
<li><a href="../266619/index.html">Overview of alternatives Proof of Work. Part 2. Proof of Activity, Proof of Burn, Proof of Capacity and Generals</a></li>
<li><a href="../266623/index.html">Event-oriented Python backtesting step by step. Part 3</a></li>
<li><a href="../266625/index.html">Cisco internship program - Cisco International Internship Program. How it was</a></li>
<li><a href="../266627/index.html">Himself a virtual operator</a></li>
<li><a href="../266629/index.html">Increase array efficiency</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>