<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What are good free monads</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I offer the readers of "Habrakhabr" a translation of the article "Why free monads matter" . 

 Interpreters 
 Good programmers share the data and inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What are good free monads</h1><div class="post__text post__text-html js-mediator-article">  <i>I offer the readers of "Habrakhabr" a translation of the article <a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">"Why free monads matter"</a> .</i> <br><br><h4>  Interpreters </h4><br>  Good programmers share the data and interpreters that process this data.  An example is the compilers, which represent the source code as an abstract syntax tree, which can later be processed by one of many interpreters.  Namely, we can: <br><ul><li>  compile and run it; </li><li>  directly run using the traditional interpreter; </li><li>  compress and archive; </li><li>  just leave him alone. </li></ul><br>  The advantages of this separation are obvious.  Let's try to build an abstraction that reflects the essence of the syntax tree.  It is better to start with a specific example.  To do this, we will design our own toy language and try to format it as a data type. <br><a name="habracut"></a><br>  The language will include only three commands: <br><ul><li>  output b - print b on the terminal </li><li>  bell - activate the system speaker </li><li>  done - end of execution </li></ul><br>  We will present it in the form of a syntactic tree, in which the following commands will be the leaves of the previous ones: <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Toy</span></span></span><span class="hljs-class"> b next = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Output</span></span></span><span class="hljs-class"> b next | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bell</span></span></span><span class="hljs-class"> next | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Done</span></span></span></span></code> </pre> <br>  Please note that the Done command has no list and therefore must be terminal. <br>  Now I could write a program and run it with an interpreter: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- output 'A' -- done Output 'A' Done :: Toy Char (Toy a next)</span></span></code> </pre><br>  But unfortunately, this is a bad decision that wouldn't work.  When adding each new command to the program, the expression will change its type: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- bell -- output 'A' -- done Bell (Output 'A' Done) :: Toy a (Toy Char (Toy b next))</span></span></code> </pre><br>  Fortunately, in order to use any number of instances of Toy and at the same time save the type, we can proceed as follows: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cheat</span></span></span><span class="hljs-class"> f = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cheat</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cheat</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">))</span></span></code> </pre><br>  The cheat type defines a sequence of functors, which ends with the Done constructor.  To pleasant surprise, Haskell already contains a similar type: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fix</span></span></span><span class="hljs-class"> f = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fix</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fix</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">))</span></span></code> </pre><br>  Fix means "the fixed point of a functor" (fixed point of the functor).  Armed with Fix, we can rewrite our programs: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Fix</span></span> (<span class="hljs-type"><span class="hljs-type">Output</span></span> '<span class="hljs-type"><span class="hljs-type">A'</span></span> (<span class="hljs-type"><span class="hljs-type">Fix</span></span> <span class="hljs-type"><span class="hljs-type">Done</span></span>)) :: <span class="hljs-type"><span class="hljs-type">Fix</span></span> (<span class="hljs-type"><span class="hljs-type">Toy</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span>) <span class="hljs-type"><span class="hljs-type">Fix</span></span> (<span class="hljs-type"><span class="hljs-type">Bell</span></span> (<span class="hljs-type"><span class="hljs-type">Fix</span></span> (<span class="hljs-type"><span class="hljs-type">Output</span></span> '<span class="hljs-type"><span class="hljs-type">A'</span></span> (<span class="hljs-type"><span class="hljs-type">Fix</span></span> <span class="hljs-type"><span class="hljs-type">Done</span></span>)))) :: <span class="hljs-type"><span class="hljs-type">Fix</span></span> (<span class="hljs-type"><span class="hljs-type">Toy</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span>)</code> </pre><br>  Now both expressions have the same type.  Fine.  However, this solution still has problems: every chain of functors must be completed by the Done constructor.  Unfortunately, programmers do not often write programs on their own from beginning to end.  More often we just want to write a procedure that could be called from other programs.  The Fix type does not allow this. <br><br>  Let's try to solve this problem.  Our procedure ends, but we are not ready to call Done, instead we will throw an exception so that the calling procedure can process it and continue execution: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FixE</span></span></span><span class="hljs-class"> fe = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fix</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FixE</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fe</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Throw</span></span></span><span class="hljs-class"> e</span></span></code> </pre><br>  The handler function will look like this: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">catch</span></span> (<span class="hljs-type"><span class="hljs-type">Fucntor</span></span> f) =&gt; <span class="hljs-type"><span class="hljs-type">FixE</span></span> f e1 -&gt; (e1 -&gt; <span class="hljs-type"><span class="hljs-type">FixE</span></span> f e2) -&gt; <span class="hljs-type"><span class="hljs-type">FixE</span></span> f e2 catch (<span class="hljs-type"><span class="hljs-type">Fix</span></span> x) f = <span class="hljs-type"><span class="hljs-type">Fix</span></span> (fmap (flip catch f) x) catch (<span class="hljs-type"><span class="hljs-type">Throw</span></span> e) f = fe</code> </pre><br>  To use it, you need to make Toy an instance of the Functor class: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Toy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap f (<span class="hljs-type"><span class="hljs-type">Output</span></span> x next) = <span class="hljs-type"><span class="hljs-type">Output</span></span> x (f next) fmap f (<span class="hljs-type"><span class="hljs-type">Bell</span></span> next) = <span class="hljs-type"><span class="hljs-type">Bell</span></span> (f next) fmap f <span class="hljs-type"><span class="hljs-type">Done</span></span> = <span class="hljs-type"><span class="hljs-type">Done</span></span></code> </pre><br>  Now we can write the code that will be executed and return control to the calling procedure: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IncompleteException</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IncompleteException</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- output 'A' -- throw IncompleteException subroutine = Fix (Output 'A' (Throw IncompleteException)) :: FixE (Toy Char) IncompleteException -- try {subroutine} -- catch (IncompleteException) { -- bell -- done -- } program = subroutine `catch` (\_ -&gt; Fix (Bell (Fix Done))) :: Fix (Toy Char) e</span></span></span></span></code> </pre><br><h4>  Monad Free.  Part 1 </h4><br>  We proudly pack an ‚Äúimproved‚Äù Fix and publish it on Hackage as fix-impoved, and then we find out that it is not quite used as we assumed: users send normal values ‚Äã‚Äãinstead of exceptions.  How dare they!  Exceptions only for exceptional situations!  What a boob! <br>  ... although it is not known who is who, because our FixE is already implemented and is called Free: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> fr = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fr</span></span></span><span class="hljs-class">) instance (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monad</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) where return = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) &gt;&gt;= f = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmap</span></span></span><span class="hljs-class"> (&gt;&gt;= </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) x) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) &gt;&gt;= f = fr</span></span></code> </pre><br>  return - our Throw and (&gt;&gt; =) - catch.  Users intelligently applied exceptions to pass normal values. <br>  The remarkable aspect of haskell is the free option to use do-notation for any monads.  But in order to use do-notation with the commands of our language, we need to change their types from Toy b to Free (Toy b).  It will look like this: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">output</span></span> :: a -&gt; <span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">Toy</span></span> a) () output x = <span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">Output</span></span> x (<span class="hljs-type"><span class="hljs-type">Pure</span></span> ())) bell :: <span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">Toy</span></span> a) () bell = <span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">Bell</span></span> (<span class="hljs-type"><span class="hljs-type">Pure</span></span> ())) done :: <span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">Toy</span></span> a) r done = <span class="hljs-type"><span class="hljs-type">Free</span></span> <span class="hljs-type"><span class="hljs-type">Done</span></span></code> </pre><br>  Noticed the general pattern? <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">liftF</span></span> :: (<span class="hljs-type"><span class="hljs-type">Functor</span></span> f) =&gt; fr -&gt; <span class="hljs-type"><span class="hljs-type">Free</span></span> fr liftF command = <span class="hljs-type"><span class="hljs-type">Free</span></span> (fmap <span class="hljs-type"><span class="hljs-type">Pure</span></span> command) output x = liftF (<span class="hljs-type"><span class="hljs-type">Output</span></span> x ()) bell = liftF (<span class="hljs-type"><span class="hljs-type">Bell</span></span> ()) done = liftF <span class="hljs-type"><span class="hljs-type">Done</span></span></code> </pre><br>  Now we can consistently execute commands using do-notation.  Let's rewrite our previous example, getting rid of unnecessary exceptions: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">subroutine</span></span> :: <span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">Toy</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span>) () subroutine = output '<span class="hljs-type"><span class="hljs-type">A'</span></span> program :: <span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">Toy</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span>) r program = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> subroutine bell done</code> </pre><br>  This is where the magic begins.  Our program in do-notation is pure data that we can interpret.  Beginners often associate monads with external effects, but the code above only generates data.  We can show this by writing a function that will translate them into a string representation: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">showProgram</span></span> :: (<span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">Show</span></span> r) =&gt; <span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">Toy</span></span> a) r -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> showProgram (<span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">Output</span></span> ax)) = <span class="hljs-string"><span class="hljs-string">"output "</span></span> ++ show a ++ <span class="hljs-string"><span class="hljs-string">"\n"</span></span> ++ showProgram x showProgram (<span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">Bell</span></span> x)) = <span class="hljs-string"><span class="hljs-string">"bell\n"</span></span> ++ showProgram x showProgram (<span class="hljs-type"><span class="hljs-type">Free</span></span> <span class="hljs-type"><span class="hljs-type">Done</span></span>) = <span class="hljs-string"><span class="hljs-string">"done\n"</span></span> showProgram (<span class="hljs-type"><span class="hljs-type">Pure</span></span> r) = <span class="hljs-string"><span class="hljs-string">"return "</span></span> ++ show r ++ <span class="hljs-string"><span class="hljs-string">"\n"</span></span></code> </pre><br>  and run it <br><pre> <code class="haskell hljs">&gt;&gt;&gt; putStr (showProgram program) output '<span class="hljs-type"><span class="hljs-type">A'</span></span> bell done</code> </pre><br>  Looks like we just wrote our first interpreter.  We can use it to verify that our monad obeys certain laws: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">pretty</span></span> :: (<span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">Show</span></span> r) =&gt; <span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">Toy</span></span> a) r -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> () pretty = putStr . showProgram &gt;&gt;&gt; pretty (output '<span class="hljs-type"><span class="hljs-type">A'</span></span>) output '<span class="hljs-type"><span class="hljs-type">A'</span></span> return () &gt;&gt;&gt; pretty (return '<span class="hljs-type"><span class="hljs-type">A'</span></span> &gt;&gt;= output) output '<span class="hljs-type"><span class="hljs-type">A'</span></span> return () &gt;&gt;&gt; pretty (output '<span class="hljs-type"><span class="hljs-type">A'</span></span> &gt;&gt;= return) output '<span class="hljs-type"><span class="hljs-type">A'</span></span> return () &gt;&gt;&gt; pretty ((output '<span class="hljs-type"><span class="hljs-type">A'</span></span> &gt;&gt; done) &gt;&gt; output '<span class="hljs-type"><span class="hljs-type">C'</span></span>) output '<span class="hljs-type"><span class="hljs-type">A'</span></span> done &gt;&gt;&gt; pretty (output '<span class="hljs-type"><span class="hljs-type">A'</span></span> &gt;&gt; (done &gt;&gt; output '<span class="hljs-type"><span class="hljs-type">C'</span></span>)) output '<span class="hljs-type"><span class="hljs-type">A'</span></span> done</code> </pre><br>  Notice how Done "swallows" all the commands following it.  I included Done in Toy for illustration purposes only.  In most cases, we do not need such a constructor, but rather the behavior provided by Pure, that is, the possibility of continuing execution, but there may be exceptions. <br><br>  We can also write an interpreter in its traditional meaning: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ringBell</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () <span class="hljs-comment"><span class="hljs-comment">-- ,  ,   interpret :: (Show b) =&gt; Free (Toy b) r -&gt; IO () interpret (Free (Output bx)) = print b &gt;&gt; interpret x interpret (Free (Bell x)) = ringBell &gt;&gt; interpret x interpret (Free Done ) = return () interpret (Pure r) = throwIO (userError "Improper termination")</span></span></code> </pre><br>  Monad Free no matter how you use it. <br><br><h4>  Multitasking </h4><br>  Suppose that we have two monadic "streams" and we want to alternate the steps of their implementation.  In the case of IO monads, we could use forkIO just by running them in parallel, however, that if we need to do the same for State or even Cont monads.  You can try to present the stream as a list of monadic actions: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Thread</span></span></span><span class="hljs-class"> m = [m ()]</span></span></code> </pre><br>  ... but there is no guarantee that the interpreter will call them in the specified order, as there is no possibility to transfer the results of calculations between actions.  However, we can guarantee the order of execution by investing each subsequent action in the previous one and use a separate constructor to indicate the end of the stream: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Thread</span></span></span><span class="hljs-class"> mr = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Atomic</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Thread</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mr</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Return</span></span></span><span class="hljs-class"> r</span></span></code> </pre><br>  This structure allows you to get the next action only after the completion of the current one.  Now we can wrap each individual monad call into an atomic step Thread: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">atomic</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; ma -&gt; <span class="hljs-type"><span class="hljs-type">Thread</span></span> ma atomic m = <span class="hljs-type"><span class="hljs-type">Atomic</span></span> $ liftM <span class="hljs-type"><span class="hljs-type">Return</span></span> m</code> </pre><br>  Now we need to make Thread a monad: we ‚Äúpretend‚Äù that we glue the two streams, but at the same time preserving the atomicity of each step, in order to be able to alternate them with the steps of other streams: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monad</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monad</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Thread</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> return = <span class="hljs-type"><span class="hljs-type">Return</span></span> (<span class="hljs-type"><span class="hljs-type">Atomic</span></span> m) &gt;&gt;= f = <span class="hljs-type"><span class="hljs-type">Atomic</span></span> (liftM (&gt;&gt;= f) m) (<span class="hljs-type"><span class="hljs-type">Return</span></span> r) &gt;&gt;= f = fr</code> </pre><br>  Using this, we can create threads consisting of atomic steps: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">thread1</span></span> :: <span class="hljs-type"><span class="hljs-type">Thread</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () thread1 = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> atomic $ print <span class="hljs-number"><span class="hljs-number">1</span></span> atomic $ print <span class="hljs-number"><span class="hljs-number">2</span></span> thread2 :: <span class="hljs-type"><span class="hljs-type">Thread</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> () thread2 = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> str &lt;- atomic $ getLine atomic $ putStrLn str</code> </pre><br>  All that remains to be done is to implement the alternation of two streams, while maintaining the atomicity of the individual steps.  Let's write the simplest implementation: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">interleave</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; <span class="hljs-type"><span class="hljs-type">Thread</span></span> mr -&gt; <span class="hljs-type"><span class="hljs-type">Thread</span></span> mr -&gt; <span class="hljs-type"><span class="hljs-type">Thread</span></span> mr interleave (<span class="hljs-type"><span class="hljs-type">Atomic</span></span> m1) (<span class="hljs-type"><span class="hljs-type">Atomic</span></span> m2) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> next1 &lt;- atomic m1 next2 &lt;- atomic m2 interleave next1 next2 interleave t1 (<span class="hljs-type"><span class="hljs-type">Return</span></span> _) = t1 interleave (<span class="hljs-type"><span class="hljs-type">Return</span></span> _) t2 = t2</code> </pre><br>  Now we need to learn how to run the resultant streams: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runThread</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; <span class="hljs-type"><span class="hljs-type">Thread</span></span> mr -&gt; mr runThread (<span class="hljs-type"><span class="hljs-type">Atomic</span></span> m) = m &gt;&gt;= runThread runThread (<span class="hljs-type"><span class="hljs-type">Return</span></span> r) = return r &gt;&gt;&gt; runThread (interleave thread1 thread2) <span class="hljs-number"><span class="hljs-number">1</span></span> [[<span class="hljs-type"><span class="hljs-type">Input</span></span>: <span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>]] <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-type"><span class="hljs-type">Hello</span></span>, world!</code> </pre><br>  Magic!  We just implemented the simplest flow control system.  Try using it with the pure state monad now. <br><br><h4>  Monad Free.  Part 2 </h4><br>  If you were careful, you might have noticed that Thread is a veiled Free and atomic - liftF.  This example well demonstrates how close free monads and lists are.  Indeed, compare the definitions of Free and List: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> fr = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fr</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> r </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class"> a (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> ) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span></span></code> </pre><br>  In other words, we can think of a free monad as a list of functors.  The Free constructor behaves like Cons, adding a functor to the list and Pure as Nil, symbolizing an empty list (lack of functors). <br><br>  If List is a list of values ‚Äã‚Äãand a free monad is a list of functors, what happens if these functors themselves are values: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List'</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> ((,) a) () </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List'</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> ((,) a) () = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class">' </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> () = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> a (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class">' </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> ()</span></span></code> </pre><br>  It turns out an ordinary list. <br><br>  Thus, the list is a special case of the monad Free.  However, [] as an instance of the Monad class is different from List 'a (i.e. Free ((,) a)).  In the List 'a monad, join (note bind) apparently behaves like (++) and return like [].  You can think of the List 'a monad as an unusual way of concatenating values ‚Äã‚Äãusing do-notation. <br><br>  When you think of a free monad as a list, many things become more obvious.  For example, liftF is represented by a list with a single element creating a free monad containing one functor: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">singleton</span></span> x = <span class="hljs-type"><span class="hljs-type">Cons</span></span> x <span class="hljs-type"><span class="hljs-type">Nii</span></span> <span class="hljs-comment"><span class="hljs-comment">-- x:[]  [x] liftF x = Free (fmap Pure x)</span></span></code> </pre><br>  Similarly, the interleave function is the merging of lists: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">merge</span></span> (x1:xs1) (x2:xs2) = x1:x2:merge xs1 xs2 merge xs1 [] = xs1 merge [] xs2 = xs2 <span class="hljs-comment"><span class="hljs-comment">--     : -- [x1] ++ [x2] ++ interleave xs1 xs2 interleave (Atomic m1) (Atomic m2) = do next1 &lt;- liftF m1 next2 &lt;- liftF m2 interleave next1 next2 interleave a1 (Return _) = a1 interleave (Return _) a2 = a2</span></span></code> </pre><br>  Indeed, multitasking looks like the usual merging of action lists, if you look at free monads in this way.  In the next post, I will look at an excellent article that demonstrates how you can build elegant flow control systems and planners using free monads. <br><br>  It is not a coincidence that Free monads are similar to lists.  When considering the category theory, it can be understood that both of them are free objects, where lists are free monoids, and Free monads are free monads. <br><br><h4>  Interpreters.  Continuation </h4><br>  In the first part, I introduced the concept of using free monads in interpreters, but the potential of this idea is much more than it might seem - it is not limited to compilers and formatted output.  As an example, suppose you decide to beat Notch with his idea of ‚Äã‚Äãthe game 0x10c by writing a game with the possibility of programming in it on haskell.  You want to allow players to run their programs, but at the same time restrict full access to the IO monad.  What are your actions? <br><br>  You could use the original haskell design, in which the output would be presented as a list of requests to the outside world and input - as a list of answers received from it: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> :: [<span class="hljs-type"><span class="hljs-type">Response</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Request</span></span>]</code> </pre><br>  The Request type is an enumeration of all the actions that you can perform, and Response - the results obtained.  For our game, the query set could be as follows: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Request</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Look</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Direction</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReadLine</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fire</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Direction</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WriteLine</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span></span></code> </pre><br>  ... and a set of answers: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Response</span></span></span><span class="hljs-class">= </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Image</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Picture</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--   Look | ChartLine String --   Read | Succeed Bool --   Write</span></span></span></span></code> </pre><br>  It is safe to say that this approach will not work.  We have no explicit correspondence between requests and responses (Fire has no answer at all), and it is completely unclear what will happen if we try to get an answer before we send the request. <br><br>  Let's try to establish this by combining these types into one: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Interaction</span></span></span><span class="hljs-class"> next = | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Look</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Direction</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Image</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fire</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Direction</span></span></span><span class="hljs-class"> next | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReadLine</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WriteLine</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Each constructor has fields that the player needs to fill out (parameters requests).  The player can also transfer functions that the interpreter will apply to the received answers.  You can think of the Interaction type as a contract between the programmer and the interpreter for each individual step. <br><br>  You can easily make Interaction an instance of the class Functor: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Interaction</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span>: fmap f (<span class="hljs-type"><span class="hljs-type">Look</span></span> dir g) = <span class="hljs-type"><span class="hljs-type">Look</span></span> dir (f . g) fmap f (<span class="hljs-type"><span class="hljs-type">Fire</span></span> dir x) = <span class="hljs-type"><span class="hljs-type">Fire</span></span> dir (fx) fmap f (<span class="hljs-type"><span class="hljs-type">ReadLine</span></span> g) = <span class="hljs-type"><span class="hljs-type">ReadLine</span></span> (f . g) fmap f (<span class="hljs-type"><span class="hljs-type">WriteLine</span></span> sg) = <span class="hljs-type"><span class="hljs-type">WriteLine</span></span> s (f . g)</code> </pre><br>  In fact, there is no need to do it yourself.  GHC provides the DeriveFunctor extension, which allows you to simply write: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Interaction</span></span></span><span class="hljs-class"> ... </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  And achieve the desired result. <br>  As before, we can create a list of actions using the Free monad: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Interaction</span></span></span></span></code> </pre><br>  With this type, the player can write a simple program: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">easyToAnger</span></span> = <span class="hljs-type"><span class="hljs-type">Free</span></span> $ <span class="hljs-type"><span class="hljs-type">ReadLine</span></span> $ \s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-string"><span class="hljs-string">"No"</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Free</span></span> $ <span class="hljs-type"><span class="hljs-type">Fire</span></span> <span class="hljs-type"><span class="hljs-type">Forward</span></span> $ <span class="hljs-type"><span class="hljs-type">Free</span></span> $ <span class="hljs-type"><span class="hljs-type">WriteLine</span></span> <span class="hljs-string"><span class="hljs-string">"Take that!"</span></span> (\_ -&gt; easyToAnger) - -&gt; easyToAnger</code> </pre><br>  Now this program can be launched, possibly by converting it into the hypothetical monad Game: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">interpret</span></span> :: <span class="hljs-type"><span class="hljs-type">Program</span></span> r -&gt; <span class="hljs-type"><span class="hljs-type">Game</span></span> r interpret prog = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> prog <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">Look</span></span> dir g) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> img &lt;- collectImage dir interpret (g img) <span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">Fire</span></span> dir next) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> sendBullet dir interpret next <span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">ReadLine</span></span> g) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> str &lt;- getChatLine interpret (g str) <span class="hljs-type"><span class="hljs-type">Free</span></span> (<span class="hljs-type"><span class="hljs-type">WriteLine</span></span> sg) -&gt; putChatLine s interpret (g <span class="hljs-type"><span class="hljs-type">True</span></span>) <span class="hljs-type"><span class="hljs-type">Pure</span></span> r -&gt; return r</code> </pre><br>  Since we use the Free monad, we can treat the player with syntactic sugar, allowing him to write programs in do-notation: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">look</span></span> :: <span class="hljs-type"><span class="hljs-type">Direction</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program</span></span> <span class="hljs-type"><span class="hljs-type">Image</span></span> look dir = liftF (<span class="hljs-type"><span class="hljs-type">Look</span></span> dir id) fire :: <span class="hljs-type"><span class="hljs-type">Direction</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program</span></span> () fire dir = liftF (<span class="hljs-type"><span class="hljs-type">Fire</span></span> dir ()) readLine :: <span class="hljs-type"><span class="hljs-type">Program</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> readLine = liftF (<span class="hljs-type"><span class="hljs-type">ReadLine</span></span> id) writeLine :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> writeLine s = liftF (<span class="hljs-type"><span class="hljs-type">WriteLine</span></span> s id)</code> </pre><br>  Now it will be more convenient for the player to write programs: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">easyToAnger</span></span> :: <span class="hljs-type"><span class="hljs-type">Program</span></span> a easyToAnger = forever $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> str &lt;- readLine when (str == <span class="hljs-string"><span class="hljs-string">"No"</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> fire <span class="hljs-type"><span class="hljs-type">Forward</span></span> _ &lt;- writeLine <span class="hljs-string"><span class="hljs-string">"Take that!"</span></span> return ()</code> </pre><br>  In a nutshell, we provided the player with an interaction language that limits his possible actions, and at the same time saved syntax sugar and haskell buns.  Behind us remained the complete freedom of interpretation of the players' programs.  For example, if I were going to release a patch tomorrow that would change the game world (and haskell had hot-swapping mechanisms), I could change the interpreter without interrupting the execution of the players' programs. <br><br><h4>  Free monads.  Part 3 </h4><br>  The free monad is the interpreter's best friend.  It ‚Äúfrees the interpreter‚Äù as much as possible and at the same time keeps the necessary minimum to remain a monad. <br><br>  Every time when we want the interpreter to provide the programmer with only the possibility of using monads, free monads come to the rescue.  If you present yourself as an interpreter, and me as a programmer, then you reserve the right to choose alternatives, forcing me to write my programs using only the free monads that you give me. <br><br>  The expression ‚Äúfree interpreter‚Äù as far as possible ‚Äúsounds like an optimization problem, which can be rephrased as: <br><br>  <i>Which monad is the most flexible to interpret, provided it is still a monad</i> <br><br>  In fact, a detailed consideration of the concept of "freedom", given the restrictions, leads to the definition of a free object in the category theory, where this concept is formalized.  The free monad is the ‚Äúmost free‚Äù object, which is a monad. </div><p>Source: <a href="https://habr.com/ru/post/254715/">https://habr.com/ru/post/254715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254703/index.html">Django 1.8 released</a></li>
<li><a href="../254705/index.html">Amateurs vs. Experts - recipes for beginners</a></li>
<li><a href="../254707/index.html">Machine learning in navigation devices: we determine the maneuvers of the machine by the accelerometer and gyroscope</a></li>
<li><a href="../254711/index.html">Presentation of speakers of the Desktop UI & Business Application conference. About UI</a></li>
<li><a href="../254713/index.html">Even more jQuery?</a></li>
<li><a href="../254717/index.html">On middleware</a></li>
<li><a href="../254719/index.html">The Bresenham algorithm in a soldering furnace - theory</a></li>
<li><a href="../254721/index.html">Practical use of a small vocabulary</a></li>
<li><a href="../254727/index.html">Asynchronous work with Tarantool on Python</a></li>
<li><a href="../254731/index.html">Improving xaml: Bindable Converters, Switch Converter, Sets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>