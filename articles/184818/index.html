<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedural generation of floor plans</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What does a major game developer do when he needs to concoct a lot of space for the game world? Hires a bunch of artists. What makes a lazy / poor / l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedural generation of floor plans</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage3/7d8/baf/7ab/7d8baf7ab46d91e6ef1e8f000823b74e.gif"><br>  What does a major game developer do when he needs to concoct a lot of space for the game world?  Hires a bunch of artists.  What makes a lazy / poor / lonely game developer in the same situation?  Writes a procedural generator that does all the dirty work for it. <br><br>  There are <a href="http://arxiv.org/pdf/1211.5842.pdf">many</a> , <a href="http://dspace.mit.edu/bitstream/handle/1721.1/45649/399893067.pdf">many</a> <a href="https://dr.library.brocku.ca/bitstream/handle/10464/3409/Brock_Flack_Robert_2011.pdf%3Fsequence%3D1">articles</a> on procedural generation of floor plans.  <a href="http://graphics.tudelft.nl/~rval/papers/tutenel.tciaig11.pdf">Here</a> <a href="http://rvsn.csail.mit.edu/Pubs/master_whiting_2006june_bmgwriteup.pdf">are</a> <a href="http://www.generativeart.com/on/cic/GA2010/2010_18.pdf">five</a> <a href="http://axon.cs.byu.edu/Dan/673/papers/martin.pdf">links</a> <a href="http://iv.csit.carleton.ca/~awhitehe/pubs/SIGGRAPH2006.pdf">to</a> <a href="http://www.benbradley.com/files/picag.pdf">articles</a> .  Only the source to none of them. <br><br>  In this article I will talk about how I implemented one simple generation method on Unity3d, which leads to good results and is easily modified.  With pictures and sources. <br><a name="habracut"></a><br>  If you want, you can read the <a href="http://graphics.tudelft.nl/~rval/papers/lopes.GAMEON10.pdf">original article</a> , but the essence is approximately as follows: <br><ul><li>  The whole space is divided into cells like grid in architectural plans. </li><li>  Exterior walls already exist and are fed to the entrance of the program. </li><li>  There is a list of rooms that need to be placed on the plan. </li><li>  The rooms have the parameter ‚Äúdesired size‚Äù and coefficients of attraction to each other. </li><li>  The points of birth of rooms are scattered according to a plan in a random way, possibly with the help of some kind of approximate map. </li><li>  Then each point begins to grow rectangularly until it reaches the dimensions defined for it. </li><li>  When all the rectangles have grown, the rooms start to grow in the shape of an L until it is possible. </li><li>  The remaining free space is attached to the neighbors. </li></ul><br>  Rooms grow one wall at a time to avoid walls and rooms crawling on top of each other.  The wall is selected from the largest walls of the room, if there is the same - a random one is taken.  The largest wall is taken in order to increase the area of ‚Äã‚Äãthe rooms was maximum, and they were "plump". 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now about my implementation.  I didn‚Äôt bother with the realistic layout, the coefficients and the size of the rooms - these are all decorations, I worked on the basic algorithm, everything else can be added quickly.  The article also speaks of special checks that prevent the appearance of U-shaped rooms, I did not do them, I do not see anything wrong with such rooms.  Also, I did not arrange corridors, doors and windows, this is a separate topic, and their placement may depend on the generation of the rest of the building. <br><br>  The most difficult was to choose the principle of growth of rooms and the method of storing data about them and the building.  One and the same result can be obtained with the help of cellular automata or even a simple run through the array.  I tried several options, I always wanted to know about the dimensions of the room and the exact position of its walls, so I created a class in which only the corners of the room are stored, and the walls are automatically created by linking two adjacent corners. <br><img align="right" src="https://habrastorage.org/storage3/d40/c38/e53/d40c38e53f0e36b01be2c78fea705816.gif"><br>  Linking walls is essentially a search for a polygon shell from a set of points.  The task is non-trivial and with a bunch of dirty tricks, if you're interested, then I advise you to look <a href="http://en.wikipedia.org/wiki/Convex_hull_algorithms">here</a> .  Fortunately, I decided to confine myself to right angles between adjacent walls and made a simple algorithm: <br><ul><li>  Find the minimum and maximum values ‚Äã‚Äãof the coordinates X and Y in the set of points. </li><li>  From the point (minX, minY) we go upstairs through the game and alternately look for a point with such coordinates, if it is not there, then we search for the right, bottom and left.  When we find, we take it out of the old list, transfer it to the new list. </li><li>  From the coordinates of this point in the old list we are looking for the next point higher in the game, if we find it, we transfer it to the new list, delete it from the old one, remember that we found a wall that is parallel to Y, then the next wall should be parallel to X. </li><li>  We are looking for a point along Ix to the right and left, transferring it to a new list, remembering the orientation of the wall just found, looking further by analogy. </li><li>  The last point in the old list is simply transferred to the new one. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Sort the corners of the room</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GridVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SortCorners</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    var minX = corners[0].x; var maxX = corners[0].x; var minY = corners[0].y; var maxY = corners[0].y; foreach (var corner in corners) { if (corner.x &lt; minX) minX = corner.x; if (corner.x &gt; maxX) maxX = corner.x; if (corner.y &lt; minY) minY = corner.y; if (corner.y &gt; maxY) maxY = corner.y; } //    var oldC = new List&lt;GridVector&gt;(corners); var newC = new List&lt;GridVector&gt;(); bool parallelX = false; while (oldC.Count &gt; 1) { //    if (newC.Count == 0) { if (ScanUp(ref oldC, ref newC, minX, minY, maxY)) continue; if (ScanRight(ref oldC, ref newC, minX, minY, maxX)) continue; if (ScanDown(ref oldC, ref newC, minX, minY, minY)) continue; if (!ScanLeft(ref oldC, ref newC, minX, minY, minX)) { Debug.Log("Error on start"); return null; } } //    else { var last = newC[newC.Count - 1]; if (parallelX) { if (ScanRight(ref oldC, ref newC, last.x, last.y, maxX)) { parallelX = false; continue; } if (ScanLeft(ref oldC, ref newC, last.x, last.y, minX)) { parallelX = false; continue; } } else { if (ScanUp(ref oldC, ref newC, last.x, last.y, maxY)) { parallelX = true; continue; } if (ScanDown(ref oldC, ref newC, last.x, last.y, minY)) { parallelX = true; continue; } } Debug.Log("Error -------------------------------------------------"); Debug.Log("Corners: " + corners.Count); Debug.Log("OldC: " + oldC.Count); Debug.Log("NewC: " + newC.Count); Debug.Log(last); color = Color.red; return last; } } //     newC.Add(oldC[0]); corners = newC; return null; } bool ScanLeft(ref List&lt;GridVector&gt; oldC, ref List&lt;GridVector&gt; newC, int startX, int startY, int minX) { for (var x = startX; x &gt;= minX; x--) { var index = oldC.FindIndex(gv =&gt; gv.x == x &amp;&amp; gv.y == startY); if (index &gt; -1) { newC.Add(oldC[index]); oldC.RemoveAt(index); return true; } } return false; } bool ScanUp(ref List&lt;GridVector&gt; oldC, ref List&lt;GridVector&gt; newC, int startX, int startY, int maxY) { for (var y = startY; y &lt;= maxY; y++) { var index = oldC.FindIndex(gv =&gt; gv.x == startX &amp;&amp; gv.y == y); if (index &gt; -1) { newC.Add(oldC[index]); oldC.RemoveAt(index); return true; } } return false; } bool ScanRight(ref List&lt;GridVector&gt; oldC, ref List&lt;GridVector&gt; newC, int startX, int startY, int maxX) { for (var x = startX; x &lt;= maxX; x++) { var index = oldC.FindIndex(gv =&gt; gv.x == x &amp;&amp; gv.y == startY); if (index &gt; -1) { newC.Add(oldC[index]); oldC.RemoveAt(index); return true; } } return false; } bool ScanDown(ref List&lt;GridVector&gt; oldC, ref List&lt;GridVector&gt; newC, int startX, int startY, int minY) { for (var y = startY; y &gt;= minY; y--) { var index = oldC.FindIndex(gv =&gt; gv.x == startX &amp;&amp; gv.y == y); if (index &gt; -1) { newC.Add(oldC[index]); oldC.RemoveAt(index); return true; } } return false; }</span></span></code> </pre> <br></div></div><br><img align="left" src="https://habrastorage.org/storage3/c2c/dba/8cd/c2cdba8cd6b387e285aa01e6aad30914.png"><br>  In the end, we get a list of angles, sorted in a clockwise direction, from which you can easily draw walls.  Thanks to the sorting, it becomes easy to recognize another important thing - the direction outward from the wall of the room.  In order to rotate the end of the wall outward, you need to swap X and Y in places and invert the first coordinate to get the following: (-y, x). <br><br>  Rooms are stored as points, points are sorted, walls are built automatically, outward direction is known - all this is enough to check the free space on the floor plan and grow rooms.  Sometimes the truth has to add new walls when the old ones have already rested against something and cannot grow. <br><img align="right" src="https://habrastorage.org/storage3/bc4/69a/32a/bc469a32a2c1d4730499a7248bb559c6.gif"><br>  To check the availability of cells and search for possible new walls, I use a single function that collects a list of available for growth sections of the wall supplied to the entrance.  Then I sort the found segments from the whole room into categories: solid walls, pieces at the edge of the wall, central segments.  I choose the largest wall available and send it to the growth function of the room, but she understands, she already has such a wall, or we need to create a new one.  When there is a wall, the coordinates of its ends are shifted outwards, which leads to the automatic lengthening of the adjacent walls. <br><br><div class="spoiler">  <b class="spoiler_title">Search wall segments</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">List&lt;RoomWall&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindSegments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RoomWall wall, Color freeColor, Color roomColor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moved = wall + wall.outwards.minimized; BresenhamLine(moved, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.7f</span></span> + <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.7f</span></span> + <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.7f</span></span> + <span class="hljs-number"><span class="hljs-number">0.1f</span></span>), segmentsTexture); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x0 = moved.start.x; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y0 = moved.start.y; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1 = moved.end.x; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y1 = moved.end.y; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;RoomWall&gt;(); GridVector start = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; GridVector end = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> steep = Math.Abs(y1 - y0) &gt; Math.Abs(x1 - x0); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (steep) { Swap(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x0, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y0); Swap(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x1, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y1); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x0 &gt; x1) { Swap(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x0, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x1); Swap(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y0, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y1); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = x0; x &lt;= x1; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = y0; y &lt;= y1; y++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> coordX = steep ? y : x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> coordY = steep ? x : y; Color color = texture.GetPixel(coordX, coordY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (color != freeColor &amp;&amp; color != roomColor) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (end != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; start != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segment = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RoomWall(start, end); segment -= wall.outwards.minimized; segments.Add(segment); start = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; end = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } scanTexture.SetPixel(coordX, coordY, Color.red); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { start = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GridVector(coordX, coordY); } end = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GridVector(coordX, coordY); scanTexture.SetPixel(coordX, coordY, Color.green); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (end != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; start != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segment = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RoomWall(start, end); segment -= wall.outwards.minimized; segments.Add(segment); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> segments; }</code> </pre><br></div></div><br>  To display all the manipulations with the rooms, I use a texture, in pixels of which I bring up the positions of the walls.  If you do not erase the old walls, you get filled areas, as in the gif-ke at the beginning of the article.  I draw walls with the help of the Brezenham lines, which I wrote about <a href="http://habrahabr.ru/post/185086/">here</a> .  In case of problems with the gluing of the walls, everything at once becomes clear.  Instead of texture, you can use a two-dimensional array, or immediately operate a three-dimensional model. <br><br>  Exterior walls can be generated very simply.  We draw several black rectangles of arbitrary sizes, and on top of them we draw the same white ones and one pixel less on each side.  It turns out a lot of different houses.  You can also make them three-dimensional and cover the roof.  <i>Kanevsky's voice:</i> However, this is a completely different story. <br><img align="left" src="https://habrastorage.org/storage3/17c/850/2db/17c8502dbea82f006d4ca585fd163060.gif"><br>  On the links below you can see the binary and source code of the finished project. <br><br>  <a href="http://basmanovdaniil.github.io/ProceduralExperiments">Unity Web Player</a> |  <a href="">Windows</a> |  <a href="">Linux</a> |  <a href="">Mac</a> |  <a href="https://github.com/BasmanovDaniil/ProceduralExperiments">Sources on GitHub</a> <br><br>  Shift - Creates random exterior walls with random rooms. <br>  Ctrl - Load a test texture with random rooms. <br>  Enter - Remove all rooms and load a test texture. <br>  Spacebar - Stop rooms growing <br>  Alphabet Keyboard Unit - Enable Free Cell Search Visualization <br>  Left mouse button on the free area - Add room <br>  Esc - Exit <br><br>  For Linux users: Make ProceduralExperiments.x86 executable using ‚Äúchmod + x ProceduralExperiments.x86‚Äù and run. </div><p>Source: <a href="https://habr.com/ru/post/184818/">https://habr.com/ru/post/184818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../184796/index.html">Luminol chemiluminescence / what's inside the ‚Äúglowing sticks‚Äù?</a></li>
<li><a href="../184800/index.html">Entertaining C ++: Compile Time Counter</a></li>
<li><a href="../184802/index.html">Opera Software has a certificate stolen and malware signed to it</a></li>
<li><a href="../184804/index.html">What are looking for with the word "urgent"</a></li>
<li><a href="../184812/index.html">Raising Junior</a></li>
<li><a href="../184824/index.html">Digg Reader beta</a></li>
<li><a href="../184826/index.html">Google cleared the planet from the clouds</a></li>
<li><a href="../184830/index.html">C ++ support in ReSharper</a></li>
<li><a href="../184832/index.html">Speech technology. Recognition of continuous speech for teapots on the example of IVR systems</a></li>
<li><a href="../184840/index.html">Windows 8.1 Preview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>