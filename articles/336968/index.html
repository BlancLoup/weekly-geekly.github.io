<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We pump USB Mass Storage Device on STM32F103 using FreeRTOS and DMA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I was picking my device on the STM32F103 microcontroller as a USB Mass Storage Device , or in Russian, like a USB flash drive. It seems to b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We pump USB Mass Storage Device on STM32F103 using FreeRTOS and DMA</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/0de/81c/e04/0de81ce04b6d40e9be648d31ed6e9c95.png" alt="image"><br>  Recently, <a href="https://habrahabr.ru/post/335018/">I was picking my device on the STM32F103 microcontroller as a USB Mass Storage Device</a> , or in Russian, like a USB flash drive.  It seems to be relatively simple: everything in the STM32CubeMX graphical configurator generated a couple of clicks in a code, added an SD card driver, and voila - everything works.  Only very slowly - 200kbytes / s, despite the fact that the bandwidth of the USB bus in Full Speed ‚Äã‚Äãmode is much higher - 12 Mbit / s (roughly 1.2 MB / s).  Moreover, the start time of my flash drive in the operating system is about 50 seconds, which is simply uncomfortable at work.  Since I dived into this area, why not start up the transmission rate. <br><br>  Actually, <a href="https://geektimes.ru/post/291037/">I already wrote my driver for the SD card</a> (or rather the SPI driver), which worked through DMA and provided speeds of up to 500kb / s.  Unfortunately, in the context of USB, this driver did not work.  The reason for everything is the USB communication model itself - everything is done on interrupts, whereas my driver was designed to work in a normal stream.  Yes, and powdered synchronization primitives FreeRTOS. <br><br>  In this article, I made a couple of tricks that allowed us to squeeze the most out of the USB bundle and the SD card connected to the STM32F103 microcontroller via SPI.  Also there will be about FreeRTOS, synchronization objects and general approaches to data transfer via DMA.  So, I think, the article will be useful for those who only understand the STM32 controllers, and tools like DMA, and approaches when working with FreeRTOS.  The code is based on the HAL and USB Middleware libraries from the <a href="http://www.st.com/en/embedded-software/stm32cubef1.html">STM32Cube</a> package, as well as <a href="https://github.com/greiman/SdFat">SdFat</a> for working with an SD card. <br><a name="habracut"></a><br><h2>  Architecture Overview </h2><br>  If you do not go into the details of individual components, then the implementation of the Mass Storage Device (aka Mass Storage Class - MSC) on the side of the microcontroller is a relatively simple thing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/web/b8c/33c/174/b8c33c17476b40b29c9f4d5537a04305.png" alt="image"><br><br>  On the one hand is the USB Core library.  It communicates with the host, provides device registration, and implements all sorts of low-level USB. <br><br>  The Mass Storage driver (using the USB kernel) can receive and send data to the host.  Approximately as COM port, only data is transmitted in blocks.  Here the semantic content of this data is important: SCSI commands and data are transmitted to them.  And there are only a few types of commands running: read data, write data, find out the size of the storage device, and find out the readiness of the device. <br><br>  The task of the MSC driver is to interpret SCSI commands and redirect calls to the mass storage device driver.  It can be any block access memory device (RAM disk, flash drive, network storage, CD, etc.).  In my case, the storage device is a microSD card connected via SPI.  The set of functions that are required from the driver is about the same: read, write, give the size and state of readiness. <br><br>  And here there is one important nuance, because of which the whole fuss itself is actually.  The fact is that the USB protocol is host oriented.  Only the host can start transactions, send or collect data.  From the point of view of the microcontroller, this means that all activity associated with USB will take place in the context of an interrupt.  In this case, the corresponding handler will be called in the MSC driver. <br><br>  As for sending data from the microcontroller towards the host.  The microcontroller can not independently initiate data transfer.  The maximum that the microcontroller can signal the USB core is that there is data that the host can pick up. <br><br>  With the SD card itself is not so simple.  The fact is that the card is a complex device (apparently, there is a microcontroller there), and the communication protocol is very nontrivial.  Those.  it did not just send / receive data to a specific address (as is the case with some I2C EEPROM module).  The protocol of communication with the card provides a whole set of various commands and confirmations, checks of checksums and observance of any timeouts. <br><br>  I use <a href="https://github.com/greiman/SdFat">the SdFat library</a> .  It implements work with the SD card at the FAT file system level, which I actively use in my device.  In the case of USB connection, everything connected with the file system is disabled (this role goes to the host).  But what is important, the library separately allocates a card driver with an interface, practically the way the MSC driver wants it to read, write, find out the size. <br><br><img src="https://habrastorage.org/web/0fd/ba1/fc7/0fdba1fc720e42568d8c51eff60bd43b.png" alt="image"><br>  The card driver implements the protocol for communicating with the card via SPI.  He knows which commands to send to the card, in what sequence and what to expect answers.  But the driver itself does not deal with communication with iron.  To do this, there is another level of abstraction - the SPI driver, which translates read / write requests for individual blocks into the actual data transmission over the SPI bus.  It was in this place that I managed to organize data transfer via DMA, which increased the data transfer speed in normal mode, but the whole raspberry broke in the case of USB (DMA eventually had to be turned off) <br><br>  But first things first. <br><br><h2>  What problem do we solve? </h2><br>  <i>This question is often asked by my colleague, which is very puzzling interlocutors during technical disputes.</i> <br><br>  There are 2 problems with this whole kitchen: <br><br><ul><li>  Low linear speed when working from USB.  Mainly due to the use of synchronous read / write operations </li><li>  High CPU usage (up to 100%) - the device becomes impossible to use.  The reason is disabled DMA and the need to drive the data by means of the processor. </li></ul><br>  But this is from the controller, and there are still aspects of the USB Mass Storage protocol.  I put the USB Wireshark sniffer and looked at exactly which packets run on the bus and I see at least 3 more reasons for low speed <br><br><ul><li>  The host sends too many transactions </li><li>  Transactions stretched over time </li><li> The read / write operations themselves occur synchronously, waiting for the end </li></ul><br>  The problem of the number of transactions is quite simple to solve.  It turned out that when my device is connected, the OS reads the entire <a href="https://ru.wikipedia.org/wiki/FAT">FAT table</a> and makes many more small readings of the directory and the MBR.  I have a flash drive for 8 gigs, formatted in FAT32 with a cluster size of 4kb.  It turns out that the FAT table takes about 8 MB.  With a linear transmission rate of 200kb / s, it turns out almost 40 seconds. <br><br>  The easiest way to reduce the number of read operations when a device is connected is to reduce the FAT table.  Simply reformat the flash drive and increase the cluster size (thereby reducing their number and the size of the table).  I formatted the card by setting the cluster size to 16kb - the FAT table size was just under 2 MB, and the initialization time was reduced to 20 seconds. <br><br><div class="spoiler">  <b class="spoiler_title">More is not always better</b> <div class="spoiler_text">  I realized that for my device, a flash drive for 8 gig is too much, I do not need so much.  1 gigabyte, or even 512 megabytes, is enough.  Just at hand such a flash drive yet.  Moreover, they are not even on sale now.  We'll have to scrape the bottom of the barrel.  How to find - try. <br></div></div><br>  In any case, reformatting a flash drive does not solve the problem of linear speed (the speed with which large files are sequentially read).  It still remains at the level of 200kb / s and loads the processor on the most I do not want.  Let's see what you can do about it. <br><br><h2>  What is wrong with DMA from USB? </h2><br>  Finally, let's go over to the code and see how I read / write to the flash card (SPI driver) <br><br>  In my project I use FreeRTOS.  This is just an awesome tool that allowed me to process each function of my device in a separate thread (task).  I managed to throw out huge state machines for all occasions, and the code became significantly simpler and clearer.  All tasks work simultaneously, yielding to each other and synchronizing if needed.  Well, if all the threads fell asleep waiting for some event, then you can use the power saving modes of the microcontroller. <br><br>  The code that works with the SD card also works in a separate thread.  This allowed us to write read / write functions very elegantly. <br><br><div class="spoiler">  <b class="spoiler_title">SPI driver for reading / writing data to an SD card using DMA</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> SdFatSPIDriver::receive(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { <span class="hljs-comment"><span class="hljs-comment">// Start data transfer memset(buf, 0xff, n); HAL_SPI_TransmitReceive_DMA(&amp;spiHandle, buf, buf, n); // Wait until transfer is completed xSemaphoreTake(xSema, 100); return 0; // Ok status } void SdFatSPIDriver::send(const uint8_t* buf, size_t n) { // Start data transfer HAL_SPI_Transmit_DMA(&amp;spiHandle, (uint8_t*)buf, n); // Wait until transfer is completed xSemaphoreTake(xSema, 100); } void SdFatSPIDriver::dmaTransferCompletedCB() { // Resume SD thread xSemaphoreGiveFromISR(xSema, NULL); }</span></span></code> </pre> <br></div></div><br>  The beauty here is that when we need to read or write a large block of data, this code does not wait for completion.  Instead, data transfer via DMA is started, and the stream falls asleep.  In this case, the processor can go about its business, and the transfer of control passes to other threads.  When the transfer is complete, a DMA interrupt is triggered and wakes up the thread that was waiting for data transfer. <br><br><div class="spoiler">  <b class="spoiler_title">Who is there?</b> <div class="spoiler_text">  If such new tricks are new to you, then I recommend you first get acquainted with the principle of semaphores in signal-wait mode, for example, <a href="https://habrahabr.ru/post/261273/">here</a> or <a href="https://habrahabr.ru/post/249283/">here</a> <br></div></div><br>  The problem is that such an approach is difficult to pull on the USB model where all the logic of the work occurs in interrupts, and not in the normal execution stream.  Those.  it turns out that we will receive a read / write request in the interrupt, and the completion of the data transfer will also have to wait in the same interrupt. <br><br>  We can, of course, organize the transfer via DMA in the context of an interruption, but there will be little sense from this.  DMA works well where you can start the transfer and switch the processor to some other useful work until the data transfer is complete.  But by launching the transmission from the interruption, we will not be able to interrupt the interruption (sorry for the tautology) and go about our business.  We'll have to hang out there waiting for the transfer to end.  Those.  the operation will be synchronous and the total time will be the same as in the case without DMA. <br><br>  It would be much more interesting to request data transfer via DMA from the host and exit the interrupt.  And then somehow on the next interruption to report on the work done. <br><br>  But this is not the whole picture.  If reading from a card would consist only in sending a block of data, then such an approach would not be difficult to implement.  But the SPI broadcast is by far the most important part, but not the only one.  If you look at the read / write data block at the level of the card driver, the process looks like this. <br><br><ul><li>  Send a command to the map, wait and check the response </li><li>  Wait until the card is ready </li><li>  Send data (this is the function I gave above) </li><li>  Calculate the checksum and compare it with the card opinion </li><li>  Complete the transfer </li></ul><br>  If we consider that this type of linear algorithm is implemented by a series of nested function calls, then cutting it down in the middle will not be very reasonable.  We'll have to thoroughly upset the entire library.  And if we consider that in some cases the transfer may be carried out not in one piece but in a cycle with a series of small blocks, the task becomes impossible at all. <br><br>  But it is not all that bad.  If you look even higher - at the level of the MSC driver - then it will generally go to the drum exactly how data transfer will occur - in one block or several, with or without DMA.  The main thing is to transfer data and report on the status. <br><br>  An ideal place for experimentation will be the layer between the MSC driver and the card driver.  Before all the bullying, this component looked quite trivial - in fact, it is an adapter between the interface that the MSC driver wants to see and what the card driver issues. <br><br><div class="spoiler">  <b class="spoiler_title">Original adapter implementation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> SD_MSC_Read (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> blk_addr, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> blk_len) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)lun; <span class="hljs-comment"><span class="hljs-comment">// Not used if(!card.readBlocks(blk_addr, buf, blk_len)) return USBD_FAIL; return (USBD_OK); } int8_t SD_MSC_Write (uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len) { (void)lun; // Not used if(!card.writeBlocks(blk_addr, buf, blk_len)) return USBD_FAIL; return (USBD_OK); }</span></span></code> </pre> <br></div></div><br>  As I said, the card driver does not work if it is called from under the interrupt.  But after all, it works well in the normal stream.  So here we run a separate thread. <br><br>  This thread will receive read and write requests through the queue.  Each request includes information about the type of operation (read / write), the number of the block to be read or written, the number of blocks and a pointer to the data buffer.  I also got a pointer to the context of the operation - we will need it later. <br><br><div class="spoiler">  <b class="spoiler_title">Queue of read / write requests</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> IOOperation { IO_Read, IO_Write }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOMsg</span></span></span><span class="hljs-class"> {</span></span> IOOperation op; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> lba; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * buf; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> len; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * context; }; <span class="hljs-comment"><span class="hljs-comment">// A queue of IO commands to execute in a separate thread QueueHandle_t sdCmdQueue = NULL; // Initialize thread responsible for communication with SD card bool initSDIOThread() { // Initialize synchronisation sdCmdQueue = xQueueCreate(1, sizeof(IOMsg)); bool res = card.begin(&amp;spiDriver, PA4, SPI_FULL_SPEED); return res; }</span></span></code> </pre> <br></div></div><br>  The thread itself sleeps waiting for commands.  If a command came, then the necessary operation is performed, and simultaneously.  At the end of the operation, we call a callback, which, depending on the implementation, will do what is needed after the end of the read / write operation. <br><br><div class="spoiler">  <b class="spoiler_title">Stream serving read / write to the card</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cardReadCompletedCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> res, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * context)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cardWriteCompletedCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> res, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * context)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xSDIOThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvParameters)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { IOMsg msg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(xQueueReceive(sdCmdQueue, &amp;msg, portMAX_DELAY)) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(msg.op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IO_Read: { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res = card.readBlocks(msg.lba, msg.buf, msg.len); cardReadCompletedCB(res ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">0xff</span></span>, msg.context); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IO_Write: { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res = card.writeBlocks(msg.lba, msg.buf, msg.len); cardWriteCompletedCB(res? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">0xff</span></span>, msg.context); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } }</code> </pre> <br></div></div><br>  Since all this is done as part of the normal flow, the card driver inside can use DMA and FreeRTOS synchronization. <br><br>  MSC functions have become a little more complicated, but not much.  Now, instead of reading or writing directly, this code sends a request to the corresponding stream. <br><br><div class="spoiler">  <b class="spoiler_title">Sending read / write requests</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> SD_MSC_Read (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> blk_addr, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> blk_len, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * context) { <span class="hljs-comment"><span class="hljs-comment">// Send read command to IO executor thread IOMsg msg; msg.op = IO_Read; msg.lba = blk_addr; msg.len = blk_len; msg.buf = buf; msg.context = context; if(xQueueSendFromISR(sdCmdQueue, &amp;msg, NULL) != pdPASS) return USBD_FAIL; return (USBD_OK); } int8_t SD_MSC_Write (uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len, void * context) { // Send read command to IO executor thread IOMsg msg; msg.op = IO_Write; msg.lba = blk_addr; msg.len = blk_len; msg.buf = buf; msg.context = context; if(xQueueSendFromISR(sdCmdQueue, &amp;msg, NULL) != pdPASS) return USBD_FAIL; return (USBD_OK); }</span></span></code> </pre> <br></div></div><br>  There is an important point here - the semantics of these functions has changed.  Now they are asynchronous, i.e.  Do not wait for the real end of the operation.  So it will be necessary to correct the code that causes them, but we will deal with this later. <br><br>  In the meantime, to test these functions, we will create another test stream.  It will emulate the USB core and send read requests. <br><br><div class="spoiler">  <b class="spoiler_title">Test stream</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> io_buf[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TaskHandle_t xTestTask = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cardReadCompletedCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> res, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * context)</span></span></span><span class="hljs-function"> </span></span>{ xTaskNotifyGive(xTestTask); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cardWriteCompletedCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> res, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * context)</span></span></span><span class="hljs-function"> </span></span>{ xTaskNotifyGive(xTestTask); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xSDTestThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvParameters)</span></span></span><span class="hljs-function"> </span></span>{ xTestTask = xTaskGetCurrentTaskHandle(); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> prev = HAL_GetTick(); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> opsPer1s = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cardSize = card.cardSize(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;cardSize; i++) { opsPer1s++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(SD_MSC_Read(<span class="hljs-number"><span class="hljs-number">0</span></span>, io_buf, i, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) usbDebugWrite(<span class="hljs-string"><span class="hljs-string">"Failed to read block %d\r\n"</span></span>, i); ulTaskNotifyTake(pdTRUE, portMAX_DELAY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(HAL_GetTick() - prev &gt; <span class="hljs-number"><span class="hljs-number">1000</span></span>) { prev = HAL_GetTick(); usbDebugWrite(<span class="hljs-string"><span class="hljs-string">"Reading speed: %d kbytes/s\r\n"</span></span>, opsPer1s); opsPer1s = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) ; }</code> </pre> <br></div></div><br>  This code reads the entire map from the beginning to the end in 1kb blocks and measures the reading speed.  Each read operation sends a request to the SD card stream.  There is a synchronous reading and reports the end through the callback.  I framed my implementation of this callback, which simply signals the test thread to continue (the test thread sleeps in the ulTaskNotifyTake () function all the time). <br><br>  But most importantly, the reading speed in this version is about 450kb / s, and the processor is only 3-4% loaded.  In my opinion not bad. <br><br><h2>  We pump over driver MSC </h2><br>  So, we won the card driver by enabling DMA.  But the read / write semantics has changed from synchronous to asynchronous.  Now you need to correct the implementation of the MSC and teach it to work with asynchronous calls.  Those.  we need to start the transfer via the DMA to the first request from the host, and to respond to all the subsequent ones, saying ‚Äúthe previous operation has not finished yet, look later‚Äù. <br><br>  In fact, <a href="http://microsin.net/programming/arm-working-with-usb/usb-in-a-nutshell-part1.html">the USB protocol provides such a mechanism right out of the box</a> .  The receiving party confirms the transfer of data with a certain status.  If the data is received and processed successfully, the receiver acknowledges the transaction with ACK status.  If the device cannot process the transaction (not initialized, is in an error state, or does not work for some other reason), the response will be STALL. <br><br>  But if the device has recognized the transaction, is in a healthy state, but the data is not yet ready, then the device can respond with a NAK.  In this case, the host must contact the device with the exact same request a little later.  We could use this status for deferred read / write - on the first call of the host we start data transfer via DMA, but respond to the transaction NAK.  When the host comes with a repeat transaction and the transfer via DMA has already ended - we answer ACK. <br><br>  Unfortunately, I have not found a good way to send a NAK signal in the USB library from ST.  Function return codes are either not checked, or they can process only 2 states - everything is fine, or an error.  In the second case, all endpoints are closed, STALL status is set everywhere. <br><br>  I suspect that at the lowest USB driver level, the confirmation of NAK is used quite actively, but I didn‚Äôt figure out how to get stuck with NAK at the class driver level. <br><br>  Apparently, the creators of the libraries from ST, instead of various confirmations, provided a more humane interface.  If the device has something to send to the host, it calls the USBD_LL_Transmit () function - the host will take the data provided.  And if the function was not called, the device will automatically respond with NAK responses.  Approximately the same situation with the reception of data.  If the device is ready to receive, then it calls the USBD_LL_PrepareReceive () function.  Otherwise, the device will respond with a NAK if the host attempts to transmit data.  We use this knowledge to implement our MSC driver. <br><br>  Let's see what transactions run on the USB bus (the analysis was made before the changes in the card driver). <br><br><img src="https://habrastorage.org/web/423/108/cef/423108cefc554a60b4c109482087c45a.png" alt="image"><br><br>  It's not even the transactions themselves that are interesting here, but their time stamps.  The transactions on this picture I chose "light" - those that do not require processing.  The microcontroller responds to such requests with hard answers, without much thought.  The important thing is that the host does not fire a transaction in a continuous flow.  Transactions go no more than once per 1 ms.  Even if the answer is ready immediately, the host will take it only on the next transaction after 1ms. <br><br>  And this is how reading one block of data in terms of transactions on the USB bus looks like. <br><br><img src="https://habrastorage.org/web/1b0/192/abf/1b0192abfd7d46f49b0a7652aa1fbfa2.png" alt="image"><br><br>  First, the host sends the SCSI command for reading, and then reads the data (second line) and status (third) in separate transactions.  The first transaction is the longest.  During the processing of this transaction, the microcontroller is just engaged in reading from the card.  And, again, between transactions, the host pauses 1ms. <br><br><div class="spoiler">  <b class="spoiler_title">By the way.</b> <div class="spoiler_text">  In USB terminology, the direction from the host to the device is called OUT, although for the controller it is a trick.  Conversely, the direction from the device to the host is called IN, although for us this means sending data. <br></div></div><br>  The MSC driver algorithm on the microcontroller side looks like this <br><br><ul><li>  SCSI Transaction: Read (10) LUN: 0x00 (LBA: 0x00000000, Len: 1) <br><ul><li>  The host sends the command to read.  From the side of the microcontroller, the function MSC_BOT_DataOut () is called </li><li>  The command is processed by the chain of functions MSC_BOT_DataOut () -&gt; MSC_BOT_CBW_Decode () -&gt; SCSI_ProcessCmd () -&gt; SCSI_Read10 () </li><li>  Since the driver is in the hmsc-&gt; bot_state == USBD_BOT_IDLE state, the read procedure is being prepared: the command parameters are checked, the number of blocks is remembered to be read, and then control of the SCSI_ProcessRead () function is transferred asking to read the first block </li><li>  The SCSI_ProcessRead () function reads data in <b>synchronous</b> mode.  <b>This is where the microcontroller is busy most of the time</b> . </li><li>  When data is received, it is transferred (using the USBD_LL_Transmit () function) to the output buffer of the MSC_IN endpoint so that the host can pick it up. </li><li>  The driver goes to hmsc-&gt; bot_state = USBD_BOT_DATA_IN </li></ul></li><li>  SCSI Transaction: Data In <br><ul><li>  The host collects data from the output buffer of the microcontroller in packets of 64 bytes (the maximum recommended packet size for USB Full Speed ‚Äã‚Äãdevices).  All this happens at the lowest level in the USB core, the MSC driver does not participate in this </li><li>  When the host has taken all the data, a Data In event occurs.  Control is passed to the MSC_BOT_DataIn () function.  I focus your attention that this function is called after the actual data is sent. </li><li>  The driver is in the hmsc-&gt; bot_state == USBD_BOT_DATA_IN state, which means we are still in read mode. </li><li>  If not all the ordered blocks have been read yet - we <b>start reading the next piece and wait for completion</b> , transfer it to the output buffer and wait until the host takes the data.  The algorithm is repeated. </li><li>  If all blocks are read, the driver switches to the USBD_BOT_LAST_DATA_IN state to send the final command status. </li></ul></li><li>  SCSI Transaction: Response <br><ul><li>  The parcel data has already been sent. </li><li>  the driver only receives a notification of this, enters the USBD_BOT_IDLE state </li></ul></li></ul><br>  The longest operation in this scheme is the actual reading from the card.  According to my measurements, reading takes about 2-3ms in synchronous mode.  Moreover, the transfer occurs by means of the processor and all this happens in the USB interrupt.  For comparison, the reading of a single block with a length of 512 through DMA takes a little more than 1 ms. <br><br>  I did not succeed significantly (say, up to 1 Mb / s) to speed up the data reading - apparently this is the bandwidth of the card connected via SPI.  But we can try to put into my service 1ms pause between transactions. <br><br>  I see it like this (slightly simplified) <br><br><ul><li>  SCSI Transaction: Read (10) LUN: 0x00 (LBA: 0x00000000, Len: 1) <br><ul><li>  The microcontroller receives a command to read, checks all parameters, remembers the number of blocks to be read. </li><li>  The microcontroller starts reading the first block in asynchronous mode </li><li>  We leave from interruption without waiting for the termination of reading </li></ul></li><li>  When reading is over, callback is called. <br><ul><li>  The read data is sent to the output buffer. </li><li>  The host reads them without the driver MSC </li></ul></li><li>  SCSI Transaction: Data In <br><ul><li>  Callback function DataIn () is called, which signals that the host has taken the data and you can do the following reading </li><li>  We start reading the next block.  The algorithm is repeated starting with the read callback. </li><li>  If all blocks are read - send the status package </li></ul></li><li>  SCSI Transaction: Response <br><ul><li>  The parcel data has already been sent. </li><li>  Preparing for the next transaction </li></ul></li></ul><br>  Let's try to implement such an approach, since the SCSI_ProcessRead () function is easily divided into ‚Äúbefore‚Äù and ‚Äúafter‚Äù.  That is, the code that starts reading will be executed in the context of the interrupt, and the remaining code will move to callback.  The task of this callback is to push the read data into the output buffer (the host will then somehow take this data with the corresponding requests) <br><br><div class="spoiler">  <b class="spoiler_title">SCSI_ProcessRead () function, adapted for asynchronous read</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief SCSI_ProcessRead * Handle Read Process * @param lun: Logical unit number * @retval status */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> int8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SCSI_ProcessRead</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lun)</span></span></span><span class="hljs-function"> </span></span>{ USBD_MSC_BOT_HandleTypeDef *hmsc = pdev-&gt;pClassDataMSC; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len; len = MIN(hmsc-&gt;scsi_blk_len , MSC_MEDIA_PACKET); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( pdev-&gt;pClassSpecificInterfaceMSC-&gt;Read(lun , hmsc-&gt;bot_data, hmsc-&gt;scsi_blk_addr / hmsc-&gt;scsi_blk_size, len / hmsc-&gt;scsi_blk_size, pdev) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { SCSI_SenseCode(pdev, lun, HARDWARE_ERROR, UNRECOVERED_READ_ERROR); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } hmsc-&gt;bot_state = USBD_BOT_DATA_IN; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cardReadCompletedCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> res, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * context)</span></span></span><span class="hljs-function"> </span></span>{ USBD_HandleTypeDef * pdev = (USBD_HandleTypeDef *)context; USBD_MSC_BOT_HandleTypeDef *hmsc = pdev-&gt;pClassDataMSC; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun = hmsc-&gt;cbw.bLUN; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len = MIN(hmsc-&gt;scsi_blk_len , MSC_MEDIA_PACKET); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(res != <span class="hljs-number"><span class="hljs-number">0</span></span>) { SCSI_SenseCode(pdev, lun, HARDWARE_ERROR, UNRECOVERED_READ_ERROR); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } USBD_LL_Transmit (pdev, MSC_IN_EP, hmsc-&gt;bot_data, len); hmsc-&gt;scsi_blk_addr += len; hmsc-&gt;scsi_blk_len -= len; <span class="hljs-comment"><span class="hljs-comment">/* case 6 : Hi = Di */</span></span> hmsc-&gt;csw.dDataResidue -= len; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hmsc-&gt;scsi_blk_len == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hmsc-&gt;bot_state = USBD_BOT_LAST_DATA_IN; } }</code> </pre> <br></div></div><br>  In the callback, you need to refer to several variables that were defined in the SCSI_ProcessRead () function - a pointer to the USB handle, the length of the transmitted block, LUN.  This is where the context parameter came in handy.  I, however, did not transmit everything, but only pdev, and everything else can be extracted from it.  As for me, this approach is simpler than the whole structure with the necessary fields.  And, in any case, it is better than getting several global variables. <br><br><h2>  Add double buffer </h2><br>  The approach, in general, earned, but the speed was still a little more than 200kb / s (although the processor load was fixed and became about 2-3%).  Let's understand what prevents to work faster. <br><br>  According to the advice in the comments to one of my articles, I still got an oscilloscope (albeit cheap).  He was very helpful to understand what was going on there at all.  I took an unused pin and put a unit on it before reading and zero after the reading was over.  On the oscilloscope, the reading process looked like this. <br><br><img src="https://habrastorage.org/web/9ae/9d6/b51/9ae9d6b51af54945871013fff2b2603b.jpg" alt="image"><br><br>  Those.  reading itself 512 bytes takes a bit more than 1ms.  When reading from the card ends the data is transferred to the output buffer, from where the host picks them up for the next 1ms.  Those.  here either reading from the card, or transferring via USB, but not at the same time. <br><br>  Typically, this situation is resolved using double buffering.  Moreover, the USB peripherals of the STM32F103 microcontrollers already offer mechanisms for double buffering.  Only they will not suit us for two reasons: <br><br><ol><li>  To use double buffering, which the microcontroller itself offers, you may have to redraw the USB core and the MSC implementation </li><li>  The buffer size is only 64 bytes, while the SD card cannot work in blocks of less than 512 bytes. </li></ol><br>  So we have to invent our own implementation.  However, this should not be difficult.  First, we reserve a space for the second buffer.  I did not begin to get to it a separate variable, and simply increased the existing buffer by 2 times.  I also had to get the bot_data_idx variable, which will indicate which half of this double buffer is currently used: 0 - the first half, 1 - the second. <br><br><div class="spoiler">  <b class="spoiler_title">Double buffer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">USBD_MSC_BOT_HandleTypeDef</span></span></span><span class="hljs-class"> {</span></span> ... USBD_MSC_BOT_CBWTypeDef cbw; USBD_MSC_BOT_CSWTypeDef csw; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> bot_data_length; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> bot_data[<span class="hljs-number"><span class="hljs-number">2</span></span> * MSC_MEDIA_PACKET]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> bot_data_idx; ... } USBD_MSC_BOT_HandleTypeDef;</code> </pre></div></div><br>  By the way, cbw and csw structures are very sensitive to alignment.  Some values ‚Äã‚Äãwere incorrectly written or read from the fields of these structures.  Therefore it was necessary to transfer them higher than data buffers. <br><br>  The original implementation worked on a DataIn interrupt - a signal that the data had gone.  Those.  upon a command from the host, a read was started, after which the data was stored in the output buffer.  Reading the next chunk of data was ‚Äúrecharged‚Äù by interrupting DataIn.  This option does not suit us.  We will begin reading immediately after the previous reading has ended. <br><br><div class="spoiler">  <b class="spoiler_title">Reload the reading immediately after the previous one has ended.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cardReadCompletedCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> res, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * context)</span></span></span><span class="hljs-function"> </span></span>{ USBD_HandleTypeDef * pdev = (USBD_HandleTypeDef *)context; USBD_MSC_BOT_HandleTypeDef *hmsc = pdev-&gt;pClassDataMSC; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun = hmsc-&gt;cbw.bLUN; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len = MIN(hmsc-&gt;scsi_blk_len , MSC_MEDIA_PACKET); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(res != <span class="hljs-number"><span class="hljs-number">0</span></span>) { SCSI_SenseCode(pdev, lun, HARDWARE_ERROR, UNRECOVERED_READ_ERROR); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Synchronization to avoid several transmits at a time // This must be located here as it waits finishing previous USB transfer // while the code below prepares next one pdev-&gt;pClassSpecificInterfaceMSC-&gt;OnFinishOp(); // Save these values for transmitting data uint8_t * txBuf = hmsc-&gt;bot_data + hmsc-&gt;bot_data_idx * MSC_MEDIA_PACKET; uint16_t txSize = len; // But before transmitting set the correct state // Note: we are in context of SD thread, not the USB interrupt // So values have to be correct when DataIn interrupt occurrs hmsc-&gt;scsi_blk_addr += len; hmsc-&gt;scsi_blk_len -= len; /* case 6 : Hi = Di */ hmsc-&gt;csw.dDataResidue -= len; if (hmsc-&gt;scsi_blk_len == 0) { hmsc-&gt;bot_state = USBD_BOT_LAST_DATA_IN; } else { hmsc-&gt;bot_data_idx ^= 1; hmsc-&gt;bot_data_length = MSC_MEDIA_PACKET; SCSI_ProcessRead(pdev, lun); // Not checking error code - SCSI_ProcessRead() already enters error state in case of read failure } // Now we can transmit data read from SD USBD_LL_Transmit (pdev, MSC_IN_EP, txBuf, txSize); }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This feature has slightly changed the structure. First, it is here that support for double buffering is implemented. Since this function is called when the reading from the card is completed, we can immediately start the next reading by calling SCSI_ProcessRead (). So that the new reading does not overwrite the newly read data, the second buffer is used. The variable bot_data_idx is responsible for switching buffers.</font></font><br><br>  But that is not all.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, the sequence of actions has changed. Now, the reading of the next data block is charged first and only then USBD_LL_Transmit () is called. This is done because the cardReadCompletedCB () function is called in the context of a normal thread. If you call USBD_LL_Transmit () first, and then change the values ‚Äã‚Äãof the hmsc fields, then at this point a USB interrupt may be triggered, which also wants to change these fields. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thirdly, it was necessary to fasten additional synchronization. The fact is that usually reading from a card takes a little longer than transferring via USB. But sometimes it happens the other way around and then the USBD_LL_Transmit () call for the next block happens earlier than the previous block was completely sent. USB core from such arrogance fool and the data is sent incorrectly.</font></font><br><br><img src="https://habrastorage.org/web/a71/739/a66/a71739a66f0c4517a03f0c57be747cd5.png" alt="image"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data sending (Transmit) is confirmed by the Data In event, but sometimes several Transmit'es occur in a row. For such cases, you need synchronization.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is solved very simply by adding a little sync. I added a couple of functions to the USBD_StorageTypeDef interface with a fairly simple implementation (although the names are probably not very successful). The implementation uses the normal </font></font><a href="https://habrahabr.ru/post/261273/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semaphore in signal-wait mode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . OnFinishOp (), which is called, in the cardReadCompletedCB () callback will sleep and wait for the previous data packet to go. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sending is confirmed by the DataIn event, which is processed by the SCSI_Read10 () function, which will cause OnStartOp (), which unlocks OnFinishOp (), which will send the next data packet </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the house that Jack built</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Even if the functions are called in the reverse order (and this is exactly what will happen during the first reading - first SCSI_Read10 (), then cardReadCompletedCB ()), everything will also work fine (the semaphore property in signal-wait mode).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronization features</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SD_MSC_OnStartOp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ xSemaphoreGiveFromISR(usbTransmitSema, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SD_MSC_OnFinishOp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ xSemaphoreTake(usbTransmitSema, portMAX_DELAY); }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this synchronization, the picture takes the following form. </font></font><br><br><img src="https://habrastorage.org/web/705/584/771/705584771e534af6a13d2f907705bc32.png" alt="image"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red arrows indicate synchronization. </font><font style="vertical-align: inherit;">The last Transmit is waiting for the previous Data In.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The last piece of the puzzle is the SCSI_Read10 () function.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the SCSI_Read10 () function that is called on the Data In event</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief SCSI_Read10 * Process Read10 command * @param lun: Logical unit number * @param params: Command parameters * @retval status */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> int8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SCSI_Read10</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lun , </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *params)</span></span></span><span class="hljs-function"> </span></span>{ USBD_MSC_BOT_HandleTypeDef *hmsc = pdev-&gt;pClassDataMSC; <span class="hljs-comment"><span class="hljs-comment">// Synchronization to avoid several transmits at a time pdev-&gt;pClassSpecificInterfaceMSC-&gt;OnStartOp(); if(hmsc-&gt;bot_state == USBD_BOT_IDLE) /* Idle */ { // Params checking ‚Ä¶ hmsc-&gt;scsi_blk_addr = ... hmsc-&gt;scsi_blk_len = ... hmsc-&gt;bot_state = USBD_BOT_DATA_IN; ... hmsc-&gt;bot_data_idx = 0; hmsc-&gt;bot_data_length = MSC_MEDIA_PACKET; return SCSI_ProcessRead(pdev, lun); } return 0; }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the original implementation of SCSI_Read10 (), the parameters were checked for the first function call and the reading process of the first block was started. The same function is called later on interrupting DataIn when the previous packet has already been sent and you need to start reading the next one. Both branches started reading using the SCSI_ProcessRead () function. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the new implementation, the SCSI_ProcessRead () call moved inside the ifA and is called only to read the first block (bot_state == USBD_BOT_IDLE), while the reading of subsequent blocks is started from cardReadCompletedCB (). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see what came of it. I specifically added a small delay between the readings of the blocks, so that I could see such nicks on the oscilloscope. In fact, there is so little time between reading operations that my oscilloscope does not see.</font></font><br><br><img src="https://habrastorage.org/web/452/77c/8b8/45277c8b8c764f38b8056e4ef7d48b49.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see from this picture, the idea was a success. </font><font style="vertical-align: inherit;">A new read operation starts as soon as the previous one has ended. </font><font style="vertical-align: inherit;">The pauses between readings are rather small and are dictated mainly by the host (the same delay of 1 ms between transactions). </font><font style="vertical-align: inherit;">The average read speed of large files reaches 400-440kb / s, which is quite good. </font><font style="vertical-align: inherit;">And finally, the processor load is about 2%.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What about the record? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">While I tactfully avoided the topic of writing to the card. </font><font style="vertical-align: inherit;">But now, with the knowledge and understanding of how the MSC driver works, the implementation of the recording function should not be difficult. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The original implementation works like this.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SCSI Write Transaction </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The command is processed by the chain of functions MSC_BOT_DataOut () -&gt; MSC_BOT_CBW_Decode () -&gt; SCSI_ProcessCmd () -&gt; SCSI_Write10 () </font></font></li><li>      hmsc-&gt;bot_state == USBD_BOT_IDLE,    :   ,        </li><li>   USBD_LL_PrepareReceive()    USB    . </li><li>     hmsc-&gt;bot_state = USBD_BOT_DATA_OUT </li></ul></li><li>  SCSI: Data Out <br><ul><li>      64        .          USB,  MSC     </li><li>      Data Out     SCSI_Write10() </li><li>      hmsc-&gt;bot_state == USBD_BOT_DATA_OUT,     SCSI_ProcessWrite() </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a record on the card in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronous mode</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If not all data has been received yet, then the reception is ‚Äúrecharged‚Äù by calling USBD_LL_PrepareReceive () </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If all blocks are written, the function MSC_BOT_SendCSW () is called which sends a confirmation to the host (Control Status Word - CSW), and the driver switches to USBD_BOT_IDLE </font></font></li></ul></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SCSI Transaction: Response </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this point, the status package has already been sent. </font><font style="vertical-align: inherit;">No action required.</font></font></li></ul></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To begin with, we adapt the original implementation to the asynchrony of the Write () function. </font><font style="vertical-align: inherit;">You just need to separate the SCSI_ProcessWrite () function and call the second half in the callback.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation of the recording function</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief SCSI_ProcessWrite * Handle Write Process * @param lun: Logical unit number * @retval status */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> int8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SCSI_ProcessWrite</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lun)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len; USBD_MSC_BOT_HandleTypeDef *hmsc = pdev-&gt;pClassDataMSC; len = MIN(hmsc-&gt;scsi_blk_len , MSC_MEDIA_PACKET); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pdev-&gt;pClassSpecificInterfaceMSC-&gt;Write(lun , hmsc-&gt;bot_data, hmsc-&gt;scsi_blk_addr / hmsc-&gt;scsi_blk_size, len / hmsc-&gt;scsi_blk_size, pdev) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { SCSI_SenseCode(pdev, lun, HARDWARE_ERROR, WRITE_FAULT); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cardWriteCompletedCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> res, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * context)</span></span></span><span class="hljs-function"> </span></span>{ USBD_HandleTypeDef * pdev = (USBD_HandleTypeDef *)context; USBD_MSC_BOT_HandleTypeDef *hmsc = pdev-&gt;pClassDataMSC; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun = hmsc-&gt;cbw.bLUN; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len = MIN(hmsc-&gt;scsi_blk_len , MSC_MEDIA_PACKET); <span class="hljs-comment"><span class="hljs-comment">// Check error code first if(res != 0) { SCSI_SenseCode(pdev, lun, HARDWARE_ERROR, WRITE_FAULT); return; } hmsc-&gt;scsi_blk_addr += len; hmsc-&gt;scsi_blk_len -= len; /* case 12 : Ho = Do */ hmsc-&gt;csw.dDataResidue -= len; if (hmsc-&gt;scsi_blk_len == 0) { MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_PASSED); } else { /* Prepare EP to Receive next packet */ USBD_LL_PrepareReceive (pdev, MSC_OUT_EP, hmsc-&gt;bot_data, MIN (hmsc-&gt;scsi_blk_len, MSC_MEDIA_PACKET)); } }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just as in the case of reading, you need to somehow deliver some variables from the first function to the second. And for this I use the context parameter and pass the handle to the USB device (you can extract all the necessary data from it). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The recording speed in this mode is about 90kb / s and is mainly limited by the write speed to the card. This is confirmed by the waveform - each peak is a record of one block. Judging by the picture, recording 512 bytes takes from 3 to 6ms (each time in different ways). </font></font><br><br><img src="https://habrastorage.org/web/ed0/3d8/e02/ed03d8e02db945cb90c18e93ca728204.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, the record can sometimes stick from 100ms to 0.5s - apparently somewhere in the map there is a need for various internal activities - block remapping, erasing pages, or something like that.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on this, doping a double buffer is unlikely to drastically improve the situation. </font><font style="vertical-align: inherit;">But still try to do it purely from sports interest. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the essence of the exercise is to take the next block from the host while the previous one is written to the card. </font><font style="vertical-align: inherit;">The option to start writing and receiving the next block at the same time somewhere in the SCSI_Write10 () function comes to mind immediately, i.e. </font><font style="vertical-align: inherit;">on DataOut event (reception of the next block is completed). </font><font style="vertical-align: inherit;">Only nothing will work.</font></font> because<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reception is much faster than recording and more data can be received than the card has time to write. </font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following data overwrites previously received, but not yet processed. </font></font><br><br><img src="https://habrastorage.org/web/89b/417/a7f/89b417a7fdfd43fdbd12f0bcdab29f7a.png" alt="image"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this scheme, several packages can be taken in a row, but not all of them will have time to be written to the SD card. Most likely, some of the data will be cut by the next block.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is necessary to do synchronization. Only where? In the case of a read operation, we organized double buffering and synchronization in the place where reading from the card ends and data is transferred to USB. This place was the cardReadCompletedCB () function. In the case of a write operation, such a central place will be the SCSI_Write10 () function - we will find ourselves in it when the next data block is received, and it is from here that we will start writing to the card.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But between cardReadCompletedCB () and SCSI_Write10 () functions there is one fundamental difference - the first works in the SD card stream, and the second in the USB interrupt. A regular thread may be suspended while waiting for some event or synchronization object. With the interruption, such a focus will not work - all the functions of FreeRTOS with the FromISR suffix are non-blocking. They either work as they should (capture a resource if it is free, send / receive messages through a queue if there is space or a required message there), or these functions return an error. But they never wait. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But if it is impossible to organize the wait in the interrupt, then you can try to make sure that the interruption is not caused at all once more. More precisely, even this: so that the interruption occurs exactly as many times and at such times as we need.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at a few cases that may arise during the reception / recording process. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Case number 1: receiving the first block. As soon as the first block is received, you can begin recording this block. At the same time you can start receiving the second unit. This will eliminate the pause when we do not accept the next block while the previous one is being written to the card. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Case # 2: receiving a block in the middle of a transaction. Most likely both buffers will already be filled. Somewhere in the SD card stream, the data block is recorded from the first block, while we only received the second block from the host. In principle, nothing prevents you from charging the second block record - there is a queue at the input (see the SD_MSC_Read () function above), which regulates the input requests and will write the blocks one by one. You just need to make sure that there is space for 2 requests in this queue.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But how to regulate the reception? We have only 2 receive buffers. If immediately after receiving the second block, start receiving the next one, then it overwrites the data in the first buffer, where the card is currently writing to. In this case, it would be more correct to start receiving the next data block when the buffer becomes free - when the recording ends (that is, in the record function callback). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, case number 3: you need to be able to properly complete the procedure for receiving / recording. With the last block, everything is clear - instead of receiving the next block, you need to send to the CSW host that the data is accepted and the transaction can be closed. But it must be remembered that at the beginning of the transaction we have already organized an extra reception, so the penultimate block should not order the receipt of an extra block. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a picture that describes these cases.</font></font><br><br><img src="https://habrastorage.org/web/b89/825/55e/b8982555e7b14ac58dff5fabcd8892b2.png" alt="image"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Case 1: on the first DataOut, we immediately begin receiving the second block. </font><font style="vertical-align: inherit;">Case 2: we start receiving the next block only after the recording is finished and the buffer is free. </font><font style="vertical-align: inherit;">Case 3: we do not start reception at the last but one recording, at the last one we send CSW</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An interesting observation: if the recording goes to the card from the first buffer, then at the end of the recording the next block will be received into the same first buffer. </font><font style="vertical-align: inherit;">Similarly, with the second buffer. </font><font style="vertical-align: inherit;">I would like to use this fact in my implementation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's try to realize our plans. </font><font style="vertical-align: inherit;">To implement the first case (receiving an additional block) we need a special state.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New state for receiving the first block</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USBD_BOT_DATA_OUT_1ST 6 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Data Out state for the first receiving block */</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And its processing</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief MSC_BOT_DataOut * Process MSC OUT data * @param pdev: device instance * @param epnum: endpoint index * @retval None */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MSC_BOT_DataOut</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> epnum)</span></span></span><span class="hljs-function"> </span></span>{ USBD_MSC_BOT_HandleTypeDef *hmsc = pdev-&gt;pClassDataMSC; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (hmsc-&gt;bot_state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> USBD_BOT_IDLE: MSC_BOT_CBW_Decode(pdev); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> USBD_BOT_DATA_OUT: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> USBD_BOT_DATA_OUT_1ST: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(SCSI_ProcessCmd(pdev, hmsc-&gt;cbw.bLUN, &amp;hmsc-&gt;cbw.CB[<span class="hljs-number"><span class="hljs-number">0</span></span>]) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_FAILED); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To implement the second case (block reception upon completion of the recording), you need to somehow send a certain amount of information to the callback. </font><font style="vertical-align: inherit;">To do this, I started a structure with a recording context, and declared 2 instances of this structure in the USB handle.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recording context</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> next_write_len; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * buf; USBD_HandleTypeDef * pdev; } USBD_WriteBlockContext; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">USBD_MSC_BOT_HandleTypeDef</span></span></span><span class="hljs-class"> {</span></span> ‚Ä¶ USBD_WriteBlockContext write_ctxt[<span class="hljs-number"><span class="hljs-number">2</span></span>]; ... } USBD_MSC_BOT_HandleTypeDef;</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Do not forget to change the size of the write queue in the SD card stream. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queue initialization</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Initialize thread responsible for communication with SD card bool initSDIOThread() { // Initialize synchronisation sdCmdQueue = xQueueCreate(2, sizeof(IOMsg)); ‚Ä¶ }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The SCSI_Write10 () function has changed little, only initialization of the double buffer index was added and the transition to the USBD_BOT_DATA_OUT_1ST state </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCSI_Write10 function ()</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief SCSI_Write10 * Process Write10 command * @param lun: Logical unit number * @param params: Command parameters * @retval status */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> int8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SCSI_Write10</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lun , </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *params)</span></span></span><span class="hljs-function"> </span></span>{ USBD_MSC_BOT_HandleTypeDef *hmsc = pdev-&gt;pClassDataMSC; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hmsc-&gt;bot_state == USBD_BOT_IDLE) <span class="hljs-comment"><span class="hljs-comment">/* Idle */</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Checking params ‚Ä¶ hmsc-&gt;scsi_blk_addr = ... hmsc-&gt;scsi_blk_len = ... /* Prepare EP to receive first data packet */ hmsc-&gt;bot_state = USBD_BOT_DATA_OUT_1ST; hmsc-&gt;bot_data_idx = 0; USBD_LL_PrepareReceive (pdev, MSC_OUT_EP, hmsc-&gt;bot_data, MIN (hmsc-&gt;scsi_blk_len, MSC_MEDIA_PACKET)); } else /* Write Process ongoing */ { return SCSI_ProcessWrite(pdev, lun); } return 0; }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All the most interesting logic will be concentrated in the SCSI_ProcessWrite () function - this is where the buffers will be distributed and the whole chain of readings and records will be built. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCSI_ProcessWrite () function</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief SCSI_ProcessWrite * Handle Write Process * @param lun: Logical unit number * @retval status */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> int8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SCSI_ProcessWrite</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USBD_HandleTypeDef *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lun)</span></span></span><span class="hljs-function"> </span></span>{ USBD_MSC_BOT_HandleTypeDef *hmsc = pdev-&gt;pClassDataMSC; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len = MIN(hmsc-&gt;scsi_blk_len , MSC_MEDIA_PACKET); USBD_WriteBlockContext * ctxt = hmsc-&gt;write_ctxt + hmsc-&gt;bot_data_idx; <span class="hljs-comment"><span class="hljs-comment">// Figure out what to do after writing the block if(hmsc-&gt;scsi_blk_len == len) { ctxt-&gt;next_write_len = 0xffffffff; } else if(hmsc-&gt;scsi_blk_len == len + MSC_MEDIA_PACKET) { ctxt-&gt;next_write_len = 0; } else { ctxt-&gt;next_write_len = MIN(hmsc-&gt;scsi_blk_len - 2 * MSC_MEDIA_PACKET, MSC_MEDIA_PACKET); } // Prepare other fields of the context ctxt-&gt;buf = hmsc-&gt;bot_data + hmsc-&gt;bot_data_idx * MSC_MEDIA_PACKET; ctxt-&gt;pdev = pdev; // Do not allow several receives at a time if(hmsc-&gt;bot_state != USBD_BOT_DATA_OUT_1ST) pdev-&gt;pClassSpecificInterfaceMSC-&gt;OnStartOp(); // Write received data if(pdev-&gt;pClassSpecificInterfaceMSC-&gt;Write(lun , ctxt-&gt;buf, hmsc-&gt;scsi_blk_addr / hmsc-&gt;scsi_blk_size, len / hmsc-&gt;scsi_blk_size, ctxt) &lt; 0) { SCSI_SenseCode(pdev, lun, HARDWARE_ERROR, WRITE_FAULT); return -1; } // Switching blocks hmsc-&gt;bot_data_idx ^= 1; hmsc-&gt;scsi_blk_addr += len; hmsc-&gt;scsi_blk_len -= len; /* case 12 : Ho = Do */ hmsc-&gt;csw.dDataResidue -= len; // Performing one extra receive for the first time in order to run receive and write operations in parallel if(hmsc-&gt;bot_state == USBD_BOT_DATA_OUT_1ST &amp;&amp; hmsc-&gt;scsi_blk_len != 0) { hmsc-&gt;bot_state = USBD_BOT_DATA_OUT; USBD_LL_PrepareReceive (pdev, MSC_OUT_EP, hmsc-&gt;bot_data + hmsc-&gt;bot_data_idx * MSC_MEDIA_PACKET, // Second buffer MIN (hmsc-&gt;scsi_blk_len, MSC_MEDIA_PACKET)); } return 0; }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, the recording context is being prepared here - information that will be passed to the callback. </font><font style="vertical-align: inherit;">In particular, it decides what we will do when the recording of this block ends:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the usual case, we will begin receiving the next block in the same buffer (case # 2 from those described above) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the case of the penultimate block, we will not do anything (case # 3) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the case of the last block, we will send Control Status Word (CSW) - a report to the host on the status of the operation </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After the data block has been sent to the write queue on the card, the buffer index (bot_data_idx) switches to the alternate. </font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the next packet will be received in another buffer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, a special case (case # 1) - we organize additional data reception in the case of the first block (USBD_BOT_DATA_OUT_1ST state) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font><font style="vertical-align: inherit;">counterpart </font><font style="vertical-align: inherit;">of this code is a callback about the completion of writing to the card. </font><font style="vertical-align: inherit;">Depending on which block was recorded, or the reception of the next block is organized, or the CSW is sent, or nothing happens.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Callback recording function</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cardWriteCompletedCB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> res, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * context)</span></span></span><span class="hljs-function"> </span></span>{ USBD_WriteBlockContext * ctxt = (USBD_WriteBlockContext*)context; USBD_HandleTypeDef * pdev = ctxt-&gt;pdev; USBD_MSC_BOT_HandleTypeDef *hmsc = pdev-&gt;pClassDataMSC; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun = hmsc-&gt;cbw.bLUN; <span class="hljs-comment"><span class="hljs-comment">// Check error code first if(res != 0) { SCSI_SenseCode(pdev, lun, HARDWARE_ERROR, WRITE_FAULT); return; } if (ctxt-&gt;next_write_len == 0xffffffff) { MSC_BOT_SendCSW (pdev, USBD_CSW_CMD_PASSED); } else { pdev-&gt;pClassSpecificInterfaceMSC-&gt;OnFinishOp(); if(ctxt-&gt;next_write_len != 0) { /* Prepare EP to Receive next packet */ USBD_LL_PrepareReceive (pdev, MSC_OUT_EP, ctxt-&gt;buf, ctxt-&gt;next_write_len); } } }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The final chord is synchronization, the essence of which is easier to show in the picture. </font></font><br><br><img src="https://habrastorage.org/web/16a/cd9/a34/16acd9a346854f63a0b65eb1607dede4.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Very rarely, but still sometimes there is a situation when writing to the card ends earlier than the next packet is received. As a result, the code (if there was no synchronization) could request the reception of one more packet, although the current one has not yet been fully accepted. To this did not happen had to add synchronization. Now, before requesting reception of the next block, the code will wait for the reception of the previous block to end. The synchronization tools used in reading (OnStartOp () / OnFinishOp ()) are fine.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The conditions under which you need to synchronize are quite tricky. By accepting an additional block at the beginning of a transaction, synchronization is carried out with a shift of one block. Therefore, the callback of the N-block record waits for receiving N + 1 block. This in turn means that the reception of the first block (occurs in the context of a USB interrupt) and the recording of the latter (occurs in the context of the SD card stream) do not need synchronization. </font></font><br><br><img src="https://habrastorage.org/web/0a5/bd9/564/0a5bd9564c7142e1ba8477058acc21a1.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It may seem that the red arrow duplicates the black one, which starts the recording of the next block. But if you look at the code, you can see that it is not. Red (synchronization) synchronizes the code in the MSC driver (blue square), while the queue is processed in the card driver (where the main loop of the SD card stream is). I did not really want to interfere with the code of different components.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I set up some debug logging, writing 4kb of data looks like this </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug log of 4 kb block</font></font></b> <div class="spoiler_text"> <code>Starting write operation for LBA=0041C600, len=4096 <br> Receiving first block into buf=1 <br> Writing block of data for LBA=0041C600, len=512, buf=0 <br> This will be regular block <br> Receiving an extra block into buf=1 <br> Writing block of data for LBA=0041C800, len=512, buf=1 <br> This will be regular block <br> Write completed callback with status 0 (buf=0) <br> Preparing next receive into buf=0 <br> Writing block of data for LBA=0041CA00, len=512, buf=0 <br> This will be regular block <br> Write completed callback with status 0 (buf=1) <br> Preparing next receive into buf=1 <br> Writing block of data for LBA=0041CC00, len=512, buf=1 <br> This will be regular block <br> Write completed callback with status 0 (buf=0) <br> Preparing next receive into buf=0 <br> Writing block of data for LBA=0041CE00, len=512, buf=0 <br> This will be regular block <br> Write completed callback with status 0 (buf=1) <br> Preparing next receive into buf=1 <br> Writing block of data for LBA=0041D000, len=512, buf=1 <br> This will be regular block <br> Write completed callback with status 0 (buf=0) <br> Preparing next receive into buf=0 <br> Writing block of data for LBA=0041D200, len=512, buf=0 <br> This will be one before the last block <br> Write completed callback with status 0 (buf=1) <br> Preparing next receive into buf=1 <br> Writing block of data for LBA=0041D400, len=512, buf=1 <br> This will be the last block <br> Write completed callback with status 0 (buf=0) <br> Write completed callback with status 0 (buf=1) <br> Write finished. Sending CSW</code> <br> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As expected, this did not add significant speed gains. </font><font style="vertical-align: inherit;">After reworking speed was 95-100 kb / s. </font><font style="vertical-align: inherit;">But as I said, it was all made of sports interest.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Is it even faster? </font></font></h2><br>  Let's try.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somewhere in the middle of work, I accidentally noticed that reading a single block and reading a sequence of blocks are different commands of an SD card. They are even represented by different card driver methods - readBlock () and readBlocks (). Similarly, the commands for recording a single block and recording a series of blocks differ. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the default MSC driver is sharpened to work with one block at a time, it made sense to replace readBlocks () with readBlock (). To my surprise, the reading speed even increased and became at the level of 480-500kb / s! A similar trick with the recording functions, unfortunately, did not increase the speed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But from the very beginning I was tormented by one question. Let's take another look at the picture of reading. Between the notches (reading one block) - about 2ms.</font></font><br><br><img src="https://habrastorage.org/web/452/77c/8b8/45277c8b8c764f38b8056e4ef7d48b49.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI clocking is tuned to 18 MHz (the 72 MHz core frequency divider is used by 4). </font><font style="vertical-align: inherit;">Theoretically, the transmission of 512 bytes should occupy 512 bytes * 8 bits / 18 MHz = 228 Œºs. </font><font style="vertical-align: inherit;">Yes, there will be a certain overhead to synchronize multiple threads, queue maintenance and other things, but this does not explain the difference almost 10 times! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using an oscilloscope, I measured how much real time various parts of a read operation take.</font></font><br><br><table><tbody><tr><td>  <b>Operation</b> </td><td>  <b>Time</b> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Send request from MSC driver to card driver (using request queue) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;100¬µs </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sending a map command for reading </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 70¬µs </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Card Waiting </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 500-1000 ¬µs </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reading one block from the card </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 280 ¬µs </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Send the answer back to the MSC driver </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;100 ¬µs </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To my surprise, it turned out that the longest operation is not at all reading the data, but the interval between the command to read and the confirmation from the card that the card is ready and you can read the data. </font><font style="vertical-align: inherit;">Moreover, this interval is very much floating, depending on various parameters - the frequency of requests, the size of the read data, as well as the address of the read block. </font><font style="vertical-align: inherit;">The last moment is very interesting - the farther from the beginning of the card is the block that needs to be read - the faster it reads (in any case, this was the case for my experimental card). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A similar (but sadder) picture is observed when writing to the card. </font><font style="vertical-align: inherit;">I was not able to measure all timings well enough, because </font><font style="vertical-align: inherit;">they swam within fairly wide limits, but it looks like this.</font></font><br><br><table><tbody><tr><td>  <b>Operation</b> </td><td>  <b>Time</b> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sending a command card for recording </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 70¬µs </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Card Waiting </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1-5ms </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Write one block to card </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.4-1.2ms </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All this is aggravated by a fairly large CPU load - about 75%. </font><font style="vertical-align: inherit;">The recording itself should theoretically occupy the same 228¬µs, as well as the reading - they are clocked by the same 18 MHz. </font><font style="vertical-align: inherit;">Only in this case does the synchronization of FreeRTOS threads still figure. </font><font style="vertical-align: inherit;">Apparently due to high CPU usage and the need to switch to other (higher priority) threads, the total time is much longer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the biggest sadness is waiting for the card to be ready. </font><font style="vertical-align: inherit;">It is many times more than in the case of reading. </font><font style="vertical-align: inherit;">Moreover, this is where the card can stick for 100 or even 500 ms. </font><font style="vertical-align: inherit;">In addition, in the driver of the card this part is implemented by active waiting, which leads to the very high CPU load</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Active card readiness</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// wait for card to go not busy bool SdSpiCard::waitNotBusy(uint16_t timeoutMS) { uint16_t t0 = curTimeMS(); while (spiReceive() != 0XFF) { if (isTimedOut(t0, timeoutMS)) { return false; } } return true; }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are branches in the code that will add a call to SysCall :: yield () inside the loop, but I'm afraid this will not fix the situation. </font><font style="vertical-align: inherit;">This call is only recommended to the task scheduler to switch to another thread. </font><font style="vertical-align: inherit;">But since my other streams are mostly asleep, this will not drastically improve the situation - the map will not stop being stupid.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another fun moment. </font><font style="vertical-align: inherit;">In FreeRTOS, the contexts are switched by the SysTick interrupt, which is set to 1ms by default. </font><font style="vertical-align: inherit;">Because of this, many operations on the oscilloscope are aligned on the grid in increments of 1ms. </font><font style="vertical-align: inherit;">If the card does not tupit and it takes less than 1 ms to read one block, then including all threads, synchronization and queues, you can turn around in one tick. </font><font style="vertical-align: inherit;">Hence, the theoretical maximum reading speed in such a model is exactly 500 kb / s (0.5 kb per 1 ms). </font><font style="vertical-align: inherit;">What pleases - it is achieved!</font></font><br><br><img src="https://habrastorage.org/web/48a/7d0/405/48a7d04057b347d0b38e97bb1d379366.jpg" alt="image"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this thing can be bypassed. Alignment by 1ms occurs for the following reason. Interruption from USB or from DMA is not tied to anything and can occur somewhere in the middle of a tick. If the interrupt has changed the state of the synchronization object (for example, unlocked the semaphore, or added a message to the queue), FreeRTOS will not instantly know about it. When the interrupt does its work, then control is transferred to the thread that worked before the interruption. When the tick is over, the scheduler will be called, and depending on the state of the synchronization object it can switch to the corresponding stream.</font></font><br><br><img src="https://habrastorage.org/web/29c/5c3/fe0/29c5c3fe03c84aafb6e688b76235d089.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But just for such cases FreeRTOS has a mechanism for forcing the scheduler. </font><font style="vertical-align: inherit;">As I said, you can not interrupt the interruption. </font><font style="vertical-align: inherit;">But you can be beamed about the need to call the scheduler (I stress: do not call the scheduler, but be the beacon of the need to call). </font><font style="vertical-align: inherit;">This is exactly what the portYIELD_FROM_ISR () function does</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ask the scheduler to switch threads immediately after the interruption.</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SdFatSPIDriver::dmaTransferCompletedCB() { <span class="hljs-comment"><span class="hljs-comment">// Resume SD thread BaseType_t xHigherPriorityTaskWoken; xSemaphoreGiveFromISR(xSema, &amp;xHigherPriorityTaskWoken); portYIELD_FROM_ISR(xHigherPriorityTaskWoken); }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now when the interrupt processing is finished (say, from DMA), the PendSV interrupt will be automatically triggered, and the scheduler is called in the handler of which. </font><font style="vertical-align: inherit;">The latter in turn forcibly switches the context and transfers control to the stream that was waiting for the semaphore.</font></font> So<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interrupt response time can be significantly reduced, and as a result such a trick allows you to overclock the reading on the test card right up to 600 kb / s! </font></font><br><br><img src="https://habrastorage.org/web/855/861/fb3/855861fb33a245038f78011449e6490b.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this is if there is no long wait for the card to be ready. Unfortunately, if the card thinks for a long time, then the reading is stretched by 2 ticks (and the record is 4-6) and the speed is much lower. Moreover, if the active wait code is constantly hammered into the card, and the card does not respond for a long time, then a whole tick can also pass. In this case, the OS scheduler may decide that this thread runs for too long and, in general, switch control to other threads. Because of this, there may be an additional delay.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, I tested all this on an 8GB class 6 card. I also tried several other cards that I had on hand. </font><font style="vertical-align: inherit;">Another card is also on 8GB but class 10 for some reason gave out only 300-350 kb / s for reading, but 120 kb / s for writing. </font><font style="vertical-align: inherit;">I even ventured to put the biggest and fastest card that I had - 32GB. </font><font style="vertical-align: inherit;">She managed to achieve maximum speeds - 650kb / s for reading and 120kb / s for writing. </font><font style="vertical-align: inherit;">By the way, the speeds that I cite are average. </font><font style="vertical-align: inherit;">I had nothing to measure the instantaneous speed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What conclusions can be drawn from this analysis?</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firstly, SPI is clearly not a native interface for SD cards. </font><font style="vertical-align: inherit;">Even cool cards are stupid at the most common operations. </font><font style="vertical-align: inherit;">It makes sense to look in the direction of SDIO (I already took a bag with STM32F103RCT6 at the post office - there is SDIO support out of the box)</font></font></li><li> -,   .     .     SDIO      </li><li> -,              ( 4).     /     .  20    (STM32F103C8T6)       512         </li></ul><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article I described how I managed to pump the USB MSC implementation from STMicroelectronics. Unlike other series of STM32 microcontrollers, the F103 series does not have built-in DMA support for USB. But with the help of FreeRTOS I managed to screw the read / write SD card through DMA. Well, in order to make the most efficient use of the USB bus bandwidth, I managed to fasten double buffering. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result exceeded my expectations. Initially, I aimed at a speed of about 400kb / s, but I managed to squeeze as much as 650kb / s. But for me it‚Äôs important not even absolute speed indicators, but the fact that this speed is achieved with minimal processor intervention. So the data is transferred using DMA and USB peripherals, and the processor is connected only to charge the next operation.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, it was not possible to get super speeds with the recording - only 100-120kb / s. This is due to the huge timeouts of the SD card itself. Well, since the card is connected via SPI there is no other way to find out about the readiness of the card (except to constantly interrogate it), and there is no way. Because of this, there is a rather high processor load on write operations. I have a secret hope that connecting the card via SDIO can achieve much higher speeds. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I tried not only to give the code, but also to tell how it works and why it works that way. Perhaps this will help to do something similar for other controllers or libraries. I did not select it in a separate library, because This code depends on other parts of my project and the FreeRTOS library. Moreover, I built my code on the basis of a </font></font><a href="https://habrahabr.ru/post/335018/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very patched implementation of MSC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">So if you want to use my version it will have to be backed up to the original library. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link to my repository: </font></font><a href="https://github.com/grafalex82/GPSLogger"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/grafalex82/GPSLogger</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I will be glad for constructive comments and other ideas on how to speed up work with an SD card.</font></font></div><p>Source: <a href="https://habr.com/ru/post/336968/">https://habr.com/ru/post/336968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336958/index.html">Locky is alive: 23 million infected emails per day</a></li>
<li><a href="../336960/index.html">Security Week 35: Carders donate to Hutchins, 500 thousand pacemakers withdrawn, 711 million emails were found in the spam bot</a></li>
<li><a href="../336962/index.html">The flaw in formatting Swift blocks in Xcode</a></li>
<li><a href="../336964/index.html">40 spectacular ARKit demos that will soon see the world</a></li>
<li><a href="../336966/index.html">We configure the Internet gateway with transparent bypass of blocking (and we will block advertising)</a></li>
<li><a href="../336970/index.html">RxSwift: a bit about share (), replay (), shareReplayLatestWhileConnected () and other cool operators</a></li>
<li><a href="../336972/index.html">Optimization of the process of searching for violators of land legislation</a></li>
<li><a href="../336976/index.html">‚ÄúBy whom do you see yourself in 5 years?‚Äù: Wall Street top manager's advice on the answers to the cunning questions of recruiters</a></li>
<li><a href="../336978/index.html">Traffic mirroring on Juniper MX</a></li>
<li><a href="../336980/index.html">Creating a programming language using LLVM. Part 9: Add Debugging Information</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>