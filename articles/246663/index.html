<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Named Parameters in Modern C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From Wikipedia: ‚Äú Named parameters in programming languages ‚Äã‚Äãmean support for specifying explicit parameter names in a function call. A function call...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Named Parameters in Modern C ++</h1><div class="post__text post__text-html js-mediator-article">  From Wikipedia: ‚Äú <i>Named parameters in programming languages ‚Äã‚Äãmean support for specifying explicit parameter names in a function call. A function call that takes named parameters differs from a normal function call, in which the arguments passed are associated with the function parameters only in their order in the function call</i> ‚Äù <br><br>  Let's look at an example: <br><br><pre><code class="cpp hljs">createArray(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   ?   "10" ?   "20" ? createArray(length=10, capacity=20); // ,   ! createArray(capacity=20, length=10); //    .</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And one more example in a fictional pseudo-language: <br><pre> <code class="cpp hljs">window = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Window { xPosition = <span class="hljs-number"><span class="hljs-number">10</span></span>, yPosition = <span class="hljs-number"><span class="hljs-number">20</span></span>, width = <span class="hljs-number"><span class="hljs-number">100</span></span>, height = <span class="hljs-number"><span class="hljs-number">50</span></span> };</code> </pre><br><br>  This approach is especially useful for functions with a large number of optional parameters, which, when called, only need to change some of the default values.  Some programming languages ‚Äã‚Äãsupport named parameters (C #, Objective-C, ...), but not C ++.  In this post, we will look at a couple of classic ways of emulating named parameters in C ++, well, let's try to invent something new. <br><a name="habracut"></a><br><br><h4>  Comments </h4><br>  Let's start with the unreal, but the easiest way - emulate named parameters through comments :) <br><br><pre> <code class="cpp hljs">Window window { <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-comment"><span class="hljs-comment">// xPosition 20, // yPosition 100, // width 50 // height };</span></span></code> </pre><br><br>  This approach is very popular among Windows developers, as the examples in MSDN are often provided with such comments. <br><br><h4>  Idiom "named parameter" </h4><br>  The idea <a href="http://www.parashift.com/c%2B%2B-faq/named-parameter-idiom.html">comes</a> from Java programming style: create a proxy class that will include all optional parameters in the form of methods.  After that, we can use a chain of calls to these methods to set only the parameters we need: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 File f { OpenFile{"path"} //   .readonly() .createIfNotExist() . ... };</span></span></code> </pre><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2   (    "   -") File f = OpenFile { ... } .readonly() .createIfNotExist() ... ;</span></span></code> </pre><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 3   "   -" -      ( CreateFile) auto f = CreateFile ( OpenFile("path") .readonly() .createIfNotExists() . ... ));</span></span></code> </pre><br><br>  The OpenFile class is a set of parameters, and the File constructor takes an object of this class.  Some authors (for example, <a href="http://www.parashift.com/c%2B%2B-faq/named-parameter-idiom.html">here</a> ) argue that OpenFile should only have private members and declare the File class friendly.  This may make sense if you want to use some more complex parameter setting logic.  But for the assignment of simple values, the above style with public methods will also be fine. <br><br>  In this approach: <br><ul><li>  Required parameters are also positional (the OpenFile constructor call must be first and cannot be changed) </li><li>  Optional parameters must have copy (move) constructors </li><li>  You need to write an additional proxy class. </li></ul><br><br><h4>  Idiom "parameter package" </h4><br>  The idea is similar to the previous one and is taken from the book <a href="http://www.amazon.it/Advanced-Metaprogramming-Davide-Di-Gennaro/dp/1460966163">Davide Di Gennaro's Advanced C ++ Metaprogramming</a> - a technique of using proxy objects for setting parameters through an assignment operator (=), in the end we get the following syntactic sugar: <br><br><pre> <code class="cpp hljs">MyFunction(begin(v), end(v), where[logger=<span class="hljs-built_in"><span class="hljs-built_in">clog</span></span>][comparator=greater&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;()]);</code> </pre><br><br>  Involved entities: <br><ul><li>  logger and comparator are global constants.  The assignment operator simply returns a wrapped copy of the value assigned. </li><li>  where is a global constant of the parameter package type.  Its operator [] simply returns a new proxy object, which replaces one of its members with a new argument. </li></ul><br><br>  In characters: <br><br><pre> <code class="cpp hljs">where = {a, b, c } where[logger = x] ‚Üí { a,b,c }[ argument&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(x) ] ‚Üí {x,b,c}</code> </pre><br><br>  Implementation Sketch: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// argument template &lt;size_t CODE, typename T = void&gt; struct argument { T arg; argument(const T&amp; that) : arg(that) { } }; // void argument - just to use operator= template &lt;size_t CODE&gt; struct argument&lt;CODE, void&gt; { argument(int = 0) { } template &lt;typename T&gt; argument&lt;CODE, T&gt; operator=(const T&amp; that) const { return that; } argument&lt;CODE, std::ostream&amp;&gt; operator=(std::ostream&amp; that) const { return that; } }; // " " ( ) template &lt;typename T1, typename T2, typename T3&gt; struct argument_pack { T1 first; T2 second; T3 third; argument_pack(int = 0) { } argument_pack(T1 a1, T2 a2, T3 a3) : first(a1), second(a2), third(a3) { } template &lt;typename T&gt; argument_pack&lt;T, T2, T3&gt; operator[](const argument&lt;0, T&gt;&amp; x) const { return argument_pack&lt;T, T2, T3&gt;(x.arg, second, third); } template &lt;typename T&gt; argument_pack&lt;T1, T, T3&gt; operator[](const argument&lt;1, T&gt;&amp; x) const { return argument_pack&lt;T1, T, T3&gt;(first, x.arg, third); } template &lt;typename T&gt; argument_pack&lt;T1, T2, T&gt; operator[](const argument&lt;2, T&gt;&amp; x) const { return argument_pack&lt;T1, T2, T&gt;(first, second, x.arg); } }; enum { LESS, LOGGER }; const argument&lt;LESS&gt; comparator = 0; const argument&lt;LOGGER&gt; logger = 0; typedef argument_pack&lt;basic_comparator, less&lt;int&gt;, std::ostream&gt; pack_t; static const pack_t where(basic_comparator(), less&lt;int&gt;(), std::cout);</span></span></code> </pre><br><br>  For the full code, look in the original book. <br><br>  Although the technique seems interesting, in practice it is difficult to make it quite comfortable and common.  In the book, it was not represented at all in the solution of the problem under consideration, but as an example of the ‚Äúchained‚Äù call of the operator []. <br><br><h4>  Tags </h4><br>  Andrzej Krzemie≈Ñski published an interesting post <a href="http://akrzemi1.wordpress.com/2013/06/05/intuitive-interface-part-i/">‚ÄúIntuitive Interface‚Äù</a> , where he proposed the following: named parameters are pairs of companions ‚Äî real value and empty structure (empty structures of different types are needed to select the desired overloaded function).  Here is an example of this approach from STL: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>()&gt; f{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocator_arg, a}; <span class="hljs-comment"><span class="hljs-comment">// a -  std::unique_lock&lt;std::mutex&gt; l{m, std::defer_lock}; //  lock</span></span></code> </pre><br><br>  Andrzej proposed to generalize the approach: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   STL std::vector&lt;int&gt; v1(std::with_size, 10, std::with_value, 6);</span></span></code> </pre><br><br>  As you understand, you will need to create a number of overloaded functions, and you cannot choose the order of the parameters.  The advantages include the absence of the need for copy / transfer constructors.  Passing defaults also works without problems.  From the article: ‚ÄúTags are not an ideal solution, since they clutter up namespaces with overloaded functions that are useful only in a few places where they call‚Äù <br><br>  In addition, one of the readers suggested a good idea for a different tag implementation: <br>  std :: vector v1 (std :: with_size (10), std :: with_value (6)); <br><br><h4>  Boost </h4><br>  Boost has a <a href="http://www.boost.org/doc/libs/1_53_0/libs/parameter/doc/html/index.html">library of parameters</a> . <br><br>  As might be expected, this is a fairly complete and practical implementation.  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include &lt;boost/parameter/name.hpp&gt; #include &lt;boost/parameter/preprocessor.hpp&gt; #include &lt;string&gt; BOOST_PARAMETER_NAME(foo) BOOST_PARAMETER_NAME(bar) BOOST_PARAMETER_NAME(baz) BOOST_PARAMETER_NAME(bonk) BOOST_PARAMETER_FUNCTION( (int), //    function_with_named_parameters, //   tag, //  "".    BOOST_PARAMETER_NAME,      "tag" (required //       (foo, (int)) (bar, (float)) ) (optional // ,    -    (baz, (bool) , false) (bonk, (std::string), "default value") ) ) { if (baz &amp;&amp; (bar &gt; 1.0)) return foo; return bonk.size(); } //   function_with_named_parameters(1, 10.0); function_with_named_parameters(7, _bar = 3.14); function_with_named_parameters( _bar = 0.0, _foo = 42); function_with_named_parameters( _bar = 2.5, _bonk= "Hello", _foo = 9); function_with_named_parameters(9, 2.5, true, "Hello");</span></span></code> </pre><br><br><h4>  Named parameters in modern C ++ </h4><br>  Recent C ++ standards open new doors.  Let's see if we can apply any of them to solve our problem. <br><br><h4>  Lambda </h4><br>  The chain call method is too verbose.  I do not want to add a bunch of functions that return the object itself.  How about defining a structure and setting its members through lambda functions? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileRecipe</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Path; <span class="hljs-comment"><span class="hljs-comment">//   bool ReadOnly = true; //   bool CreateIfNotExist = false; //   // ... }; class File { File(string _path, bool _readOnly, bool _createIfNotexist) : path(move(_path)), readOnly(_readOnly), createIfNotExist(_createIfNotExist) {} private: string path; bool readOnly; bool createIfNotExist; }; auto file = CreateFile( "path", [](auto&amp; r) { // - - r.CreateIfNotExist = true; });</span></span></code> </pre><br><br>  We still need a class for storing parameters, but the approach itself scales better than the classic idiom of the named parameter, in which you need to explicitly prescribe all the "chain" functions.  Another option is to make a File class constructor that accepts an object of type FileRecipe. <br><br>  How to improve the readability of the required parameters?  Let's try to combine this approach with tags: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> file = CreateFile( _path, <span class="hljs-string"><span class="hljs-string">"path"</span></span>, [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; r) { r.CreateIfNotExist = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; });</code> </pre><br><br>  True, they are still positional.  If you allow the possibility to get an error ‚Äúno required parameter‚Äù in runtime, you can use the type <a href="http://en.cppreference.com/w/cpp/experimental/optional">optional</a> <br><br>  I recently tried using this approach to configure tests and mocks.  For example, I needed to create tests for a simple dice game.  The configuration and tests used to look like this: <br><br><pre> <code class="cpp hljs">TEST_F(SomeDiceGameConfig, JustTwoTurnsGame) { GameConfiguration gameConfig { <span class="hljs-number"><span class="hljs-number">5u</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2u</span></span> }; }</code> </pre><br><br>  Using this approach, they may look like this: <br><br><pre> <code class="cpp hljs">TEST_F(SomeDiceGameConfig, JustTwoTurnsGame) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> gameConfig = CreateGameConfig( [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; r) { r.NumberOfDice = <span class="hljs-number"><span class="hljs-number">5u</span></span>; r.MaxDiceValue = <span class="hljs-number"><span class="hljs-number">6</span></span>; r.NumberOfTurns = <span class="hljs-number"><span class="hljs-number">2u</span></span>; }); }</code> </pre><br><br>  We can also use macros in order not to repeat in each test with the call of the same lambda: <br><br><pre> <code class="cpp hljs">TEST_F(SomeDiceGameConfig, JustTwoTurnsGame) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> gameConfig = CREATE_CONFIG( r.NumberOfDice = <span class="hljs-number"><span class="hljs-number">5u</span></span>; r.MaxDiceValue = <span class="hljs-number"><span class="hljs-number">6</span></span>; r.NumberOfTurns = <span class="hljs-number"><span class="hljs-number">2u</span></span>; ); }</code> </pre><br><br><h4>  Using Variadic Templates </h4><br>  Appeared in C ++ 11 Variadic Templates can improve the method described above.  Let's remember the tags again.  Tags can be a better approach than lambda + object parameters, since we don‚Äôt need to create another object, there are no problems with copy constructors, all parameters are processed uniformly (with lambdas we had to handle the required parameters differently).  But tags can be a good enough approach only if we had: <br><ul><li>  Do with declaring only one overloaded constructor or function </li><li>  Get the ability to freely determine the order of parameters (tag-value pairs) </li><li>  Have both required and optional parameters </li></ul><br><br>  Something like: <br><br><pre> <code class="cpp hljs">File f { _readonly, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, _path, <span class="hljs-string"><span class="hljs-string">"some path"</span></span> };</code> </pre><br><br>  or: <br><br><pre> <code class="cpp hljs">File f { by_name, Args&amp;&amp;... args) {}</code> </pre><br><br>  My idea is as follows: I want to use Variadic Templates to allow the user to determine the order of the parameters and omit the optional parameters. <br><br>  Imagine two constructors: <br><br><pre> <code class="cpp hljs">File(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> readonly, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> createIfNotExist) {} <span class="hljs-comment"><span class="hljs-comment">//    template&lt;typename... Args&gt; File(by_name_t, Args&amp;&amp;... args) {}</span></span></code> </pre><br><br>  An object of type File can be created in either of two ways.  If you use the second constructor, it will look at all the parameters in the set and call the first constructor with the appropriate set of parameters.  Parameter viewing and code generation is performed at the compilation stage, it takes linear time and does not affect the time spent on a call in runtime. <br><br>  This implementation is only a sketch, for sure it can be improved. <br><br>  Here's how a class can be designed: <br><br><pre> <code class="cpp hljs">File(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> readonly, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> createIfNotExists <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>) : _path (move(path)), _createIfNotExist(createIfNotExist), _readonly(readonly) <span class="hljs-comment"><span class="hljs-comment">// ,etc... { } template&lt;typename Args...&gt; File(named_tag, Args&amp;&amp;... args) : File{ REQUIRED(path), OPTIONAL(read, false) // , etc... } //  { }</span></span></code> </pre><br><br>  Before showing you the working code, let's make it clear that we can apply the same idea to a proxy: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = File { by_name, readonly=<span class="hljs-literal"><span class="hljs-literal">true</span></span>, path=<span class="hljs-string"><span class="hljs-string">"path"</span></span> };</code> </pre><br><br>  The main difference here is in the transfer of arguments: with a proxy, we get syntactic sugar (operator =), but now we need to store and transfer values ‚Äã‚Äã(not very good for non-relocatable / replicable types). <br><br>  <a href="">Here</a> you can experiment with the code.  I started with the tagged version and then switched to the proxy, so both versions are there.  You will find two sections called ‚ÄúPACK UTILS‚Äù (for tags and proxy). <br><br>  Here is what the class will look like: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">window</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   window( string pTitle, int pH, int pW, int pPosx, int pPosy, int&amp; pHandle) : title(move(pTitle)), h(pH), w(pW), posx(pPosx), posy(pPosy), handle(pHandle) { } // ,   (_title = "title") template&lt;typename... pack&gt; window(use_named_t, pack&amp;&amp;... _pack) : window { REQUIRED_NAME(title), // required OPTIONAL_NAME(h, 100), // optional OPTIONAL_NAME(w, 400), // optional OPTIONAL_NAME(posx, 0), // optional OPTIONAL_NAME(posy, 0), // optional REQUIRED_NAME(handle) } // required { } // ,   (__title, "title") template&lt;typename... pack&gt; window(use_tags_t, pack&amp;&amp;... _pack) : window { REQUIRED_TAG(title), // required OPTIONAL_TAG(h, 100), // optional OPTIONAL_TAG(w, 400), // optional OPTIONAL_TAG(posx, 0), // optional OPTIONAL_TAG(posy, 0), // optional REQUIRED_TAG(handle) } // required { } private: string title; int h, w; int posx, posy; int&amp; handle; };</span></span></code> </pre><br><br>  As you can see, both of the latest constructors always call the ‚Äúclassic‚Äù constructor to do the actual work. <br><br>  The following piece of code shows how a user can create an object: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    window w1 {use_tags, __title, "Title", __h, 10, __w, 100, __handle, i}; cout &lt;&lt; w1 &lt;&lt; endl; //    window w2 {use_named, _h = 10, _title = "Title", _handle = i, _w = 100}; cout &lt;&lt; w2 &lt;&lt; endl; //   window w3 {"Title", 10, 400, 0, 0, i}; cout &lt;&lt; w3 &lt;&lt; endl;</span></span></code> </pre><br><br>  Pros: <br><br><ul><li>  Required and optional parameters used uniformly. </li><li>  Order is not fixed </li><li>  The tagged method does not have the disadvantages of passing parameters </li><li>  The proxy method is very visual (at the expense of the operator =) </li></ul><br><br>  Minuses: <br><ul><li>  Errors at compile time can be difficult to understand (static_assert can help in some cases) </li><li>  Available parameters must be documented. </li><li>  "Pollution" of the namespace with unnecessary functions / constructors </li><li>  Default values ‚Äã‚Äãare always calculated. </li><li>  The tagged method is not perfect in terms of clarity (tag and value are separated by commas) </li><li>  The proxy method is not perfect in terms of passing parameters </li></ul><br><br>  Pay attention to the first problem: Clang is smart enough to report a problem quite clearly.  Imagine that I forgot about the obligatory parameter with the name of the window, here is the output of the compiler: <br><br><pre> <code class="bash hljs">main.cpp:28:2: error: static_assert failed <span class="hljs-string"><span class="hljs-string">"Required parameter"</span></span> static_assert(pos &gt;= 0, <span class="hljs-string"><span class="hljs-string">"Required parameter"</span></span>); ^ ~~~~~~~~ main.cpp:217:14: note: <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> instantiation of template class <span class="hljs-string"><span class="hljs-string">'get_at&lt;-1, 0&gt;'</span></span> requested here : window { REQUIRED_NAME(title), ^</code> </pre><br>  Now you know exactly what was missing and where. <br><br><h4>  Minimalist approach using std :: tuple </h4><br>  [this paragraph was written by Davide Di Gennaro] <br><br>  We can use the tuple functional (std :: tuple) to write a very compact and portable implementation of our task.  We will rely on a few simple principles: <br><br><ul><li>  The parameter set will be a special tuple, where after each "tag type" its value will go (that is, the type will be something like (std :: tuple &lt;age_tag, int, name_tag, string, ...&gt;) </li><li>  The standard language library already includes the functions of transferring / concatenating objects and tuples, which guarantees performance and correctness. </li><li>  We will use a macro to define global constants representing the tag. </li><li>  The syntax for creating a parameter set will look like (tag1 = value1) + (tag2 = value2) + ... </li><li>  The client will accept the parameter set as a reference to the template type, i.e. <br><br>  template &lt;typename pack_t&gt; <br>  void MyFunction ([whatever], T &amp; parameter_pack) // or const T &amp;, T &amp;&amp;, etc. <br></li><li>  Inside the function call, the client will extract the necessary values ‚Äã‚Äãfrom the parameter set and somehow use them (well, for example, write to local variables): </li></ul><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tag { CREATE_TAG(age, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); CREATE_TAG(name, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pack_t</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; parameter_pack)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> myage; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> myname; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b1 = extract_from_pack(tag::name, myname, parameter_pack); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b2 = extract_from_pack(tag::age, myage, parameter_pack); assert(b1 &amp;&amp; myname == <span class="hljs-string"><span class="hljs-string">"John"</span></span>); assert(b2 &amp;&amp; myage == <span class="hljs-number"><span class="hljs-number">18</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pack = (tag::age=<span class="hljs-number"><span class="hljs-number">18</span></span>)+(tag::name=<span class="hljs-string"><span class="hljs-string">"John"</span></span>); MyFunction(pack); }</code> </pre><br><br>  This is how the implementation of this idea might look. <br><br>  First macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tuple&gt; #include &lt;utility&gt; template &lt;typename T&gt; struct parameter {}; #define CREATE_TAG(name, TYPE) \ \ struct name##_t \ { \ std::tuple&lt;parameter&lt;name##_t&gt;, TYPE&gt; operator=(TYPE&amp;&amp; x) const \ { return std::forward_as_tuple(parameter&lt;name##_t&gt;(), x); } \ \ name##_t(int) {} \ }; \ \ const name##_t name = 0</span></span></span></span></code> </pre><br><br>  Expanding the macro CREATE_TAG (age, int) creates a class and a global object. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">age_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;parameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">age_t</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; x) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward_as_tuple(parameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">age_t</span></span>&gt;(), x); } <span class="hljs-keyword"><span class="hljs-keyword">age_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) {} }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">age_t</span></span> age = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br><br><br>  Conceptually assignment <br><br><pre> <code class="cpp hljs">age = <span class="hljs-number"><span class="hljs-number">18</span></span></code> </pre><br><br>  Transformed into something like: <br><br><pre> <code class="cpp hljs">make_tuple(parameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">age_t</span></span>&gt;(), <span class="hljs-number"><span class="hljs-number">18</span></span>);</code> </pre><br><br>  Please note that we wrote: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;parameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">age_t</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; x) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span></code> </pre><br><br>  We require r-value on the right.  This is done for the sake of security: for the sake of improved code readability with parameter sets, you may want to assign constants, not variables. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> myage = <span class="hljs-number"><span class="hljs-number">18</span></span>; f(myage); <span class="hljs-comment"><span class="hljs-comment">// ok g((...) + (age=18)); // ok g((...) + (age=myage)); //  ,       </span></span></code> </pre><br><br>  In addition, we can use the move semantics: <br><br>  Difference between <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;parameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">age_t</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; x) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(parameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">age_t</span></span>&gt;(), x); }</code> </pre><br><br>  and <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;parameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">age_t</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; x) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward_as_tuple(parameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">age_t</span></span>&gt;(), x); }</code> </pre><br><br>  very thin.  In the latter case, it returns std :: tuple &lt;..., int &amp;&amp;&gt;, but since the function returns std :: tuple &lt;..., int&gt;, the displacement constructor std :: tuple is called. <br><br>  As an alternative, we could write: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;parameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">age_t</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; x) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(parameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">age_t</span></span>&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(x)); }</code> </pre><br><br>  And now we write the appropriate concatenation operator for our tuples. <br><br>  We implicitly agree that all tuples that start with a parameter were created by our code, so without any explicit validation, we simply discard the parameter. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TAG1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... P1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TAG2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... P2&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;parameter&lt;TAG1&gt;, P1..., parameter&lt;TAG2&gt;, P2...&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+ (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;parameter&lt;TAG1&gt;, P1...&gt;&amp;&amp; pack1, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;parameter&lt;TAG2&gt;, P2...&gt;&amp;&amp; pack2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_cat(pack1, pack2); }</code> </pre><br><br>  Very simple function: checks that both tuples have the form <br><br><pre> <code class="cpp hljs">tuple&lt;parameter&lt;tag&gt;, type, [maybe something <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>]&gt;</code> </pre><br><br>  and connects them. <br><br>  Finally, we will write the function to extract the argument from the set.  Please note that this function has transfer semantics (i.e., after its call, the parameter will be retrieved from the set). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TAG, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... P, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TAG1&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract_from_pack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TAG tag, T&amp; var, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;parameter&lt;TAG1&gt;, P...&gt;&amp; pack)</span></span></span></span>;</code> </pre><br><br>  It works as follows: if the set contains a parameter, then the variable gets the value immediately following it and the function returns true.  Otherwise, something bad happens (we can choose a compilation error, return false, throw an exception). <br><br>  To make this choice possible, the function will look like: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ERR, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TAG, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... P, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TAG1&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract_from_pack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TAG tag, T&amp; var, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;parameter&lt;TAG1&gt;, P...&gt;&amp; pack)</span></span></span></span></code> </pre><br><br>  and we will call it like this: <br><pre> <code class="cpp hljs">extract_from_pack&lt; erorr_policy &gt; (age, myage, mypack);</code> </pre><br><br>  In view of the rules for working with variadic templates, extract_from_pack knows that the parameter set has the form tuple &lt;parameter, ...&gt;, so you need to check recursively whether TAG is really TAG1.  We implement this by calling the class: <br><br><pre> <code class="cpp hljs">extract_from_pack&lt; erorr_policy &gt; (age, myage, mypack);</code> </pre><br><br>  causes <br><br><pre> <code class="cpp hljs">extractor&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, erorr_policy &gt;::extract (age, myage, mypack);</code> </pre><br><br>  which further causes <br><br><pre> <code class="cpp hljs">extractor&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, erorr_policy &gt;::extract (age, myage, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(pack), mypack);</code> </pre><br><br>  which has two overloaded options: <br><br><pre> <code class="cpp hljs">extract(TAG, ‚Ä¶ , TAG, ‚Ä¶)</code> </pre><br><br>  which, if executed, performs the assignment and returns true or <br><br><pre> <code class="cpp hljs">extract(TAG, ‚Ä¶ , DIFFERENT_TAG, ‚Ä¶)</code> </pre><br><br>  which continues the iteration, calling again <br><br><pre> <code class="cpp hljs">extractor&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>, erorr_policy &gt;::extract (age, myage, mypack);</code> </pre><br><br>  when the continuation of the iteration is not possible, error_policy :: err (...) is called <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ERR&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extractor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> USERTAG, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TAG, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USERTAG tag, T&amp; var, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;parameter&lt;TAG&gt;, P...&gt;&amp;&amp; pack)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> extract(tag, var, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;N&gt;(pack), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(pack)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> USERTAG, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TAG, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USERTAG tag, T&amp; var, parameter&lt;TAG&gt; p0, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;P...&gt;&amp;&amp; pack)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> extractor&lt;(N+<span class="hljs-number"><span class="hljs-number">2</span></span> &gt;= <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(P)) ? <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">-1</span></span>) : N+<span class="hljs-number"><span class="hljs-number">2</span></span>, ERR&gt;::extract(tag, var, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(pack)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> USERTAG, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(USERTAG tag, T&amp; var, parameter&lt;USERTAG&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;P...&gt;&amp;&amp; pack)</span></span></span><span class="hljs-function"> </span></span>{ var = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;N+<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(pack)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ERR&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extractor</span></span></span><span class="hljs-class">&lt;size_t(-1), ERR&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TAG, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> DIFFERENT_TAG, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TAG tag, T&amp; var, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;parameter&lt;DIFFERENT_TAG&gt;, P...&gt;&amp;&amp; pack)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERR::err(tag); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ERR, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TAG, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... P, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TAG1&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract_from_pack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TAG tag, T&amp; var, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;parameter&lt;TAG1&gt;, P...&gt;&amp; pack)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> extractor&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, ERR&gt;::extract(tag, var, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(pack)); }</code> </pre><br><br>  In view of the flexible nature of the parameter sets, the ‚Äúreturn false‚Äù error can be considered the best policy to handle (any more strict behavior will in fact mean that each parameter is mandatory). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">soft_error</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">err</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } };</code> </pre><br><br>  However, if for some reason you need, we can also choose from these two: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hard_error</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">err</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,  static_assert(false)   .     ? }; struct throw_exception { template &lt;typename T&gt; static bool err(T) { throw T(); return false; } };</span></span></code> </pre><br><br>  An additional improvement could be a redundancy check for such cases as: <br><pre> <code class="bash hljs">(age=18)+(age=19)</code> </pre><br><br><h4>  Final Notes </h4><br>  We did not discuss the runtime technique, like: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyFunction</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(option_parser&amp; pack)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> name = pack.require(<span class="hljs-string"><span class="hljs-string">"name"</span></span>).as&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> age = pack.optional(<span class="hljs-string"><span class="hljs-string">"age"</span></span>, []{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; }).as&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); ... }</code> </pre><br><br>  The code works on runtime, trying to get the parameters it needs in the course of work, respectively, we have a lot of time, well, you will learn about the error only when it occurs.  The code is far from ideal, I cite it only as a ‚Äúproof of concept‚Äù and I do not think that in this form it can be used in real projects. <br><br>  I also found the sentence to add named parameters to the C ++ standard <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4172.htm">here</a> .  It would be great if. </div><p>Source: <a href="https://habr.com/ru/post/246663/">https://habr.com/ru/post/246663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246645/index.html">Digest of Russian programs to support IT startups # 2</a></li>
<li><a href="../246653/index.html">Comparing Windows Server Versions</a></li>
<li><a href="../246657/index.html">Solving the ‚ÄúAAAAAA‚Äù problem with Facebook Hacker Cup using dynamic programming on B-Prolog</a></li>
<li><a href="../246659/index.html">WordPress Site Migration Guide</a></li>
<li><a href="../246661/index.html">Project ‚ÄúFor Web‚Äù: available materials on frontend and design</a></li>
<li><a href="../246665/index.html">Meet the .Net community at CLRium # 2. How does the CLR, Roslyn, RyuJIT, CoreFx work?</a></li>
<li><a href="../246667/index.html">Auto Layout with a variable set of elements</a></li>
<li><a href="../246671/index.html">Network UPS Tools (NUT) on CentOS and Windows with SMS sending via smstools + playsms</a></li>
<li><a href="../246673/index.html">Black Swift: Why We Made It</a></li>
<li><a href="../246675/index.html">JMSpy - spy on method calls</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>