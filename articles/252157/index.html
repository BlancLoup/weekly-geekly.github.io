<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Social Network Analysis: Spark GraphX</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 



 Today we will get acquainted with the tasks of Social Network Analysis ( SNA ), as well as finish the review of the Apache Spark librar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Social Network Analysis: Spark GraphX</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br><img src="https://habrastorage.org/files/de8/cbc/aa0/de8cbcaa013e4699adec94c6a0407672.png"><br><br>  Today we will get acquainted with the tasks of Social Network Analysis ( <b>SNA</b> ), as well as finish the review of the <b>Apache Spark</b> library for analyzing Big Data.  Namely, as promised in previous articles ( <a href="http://habrahabr.ru/post/250811/">one</a> and <a href="http://habrahabr.ru/post/251471/">two</a> <a href="http://habrahabr.ru/post/250811/">times</a> ), we will consider one of the Apache Spark components designed to analyze graphs - <b>GraphX</b> .  We will try to understand how distributed storage of graphs and calculations on them is implemented in this library.  We will also show with concrete examples how this library can be used in practice: searching for spam, ranking search results, identifying communities in social networks, searching for opinion leaders is not a complete list of applications for analyzing graphs. <br><a name="habracut"></a><br>  Let's start with the fact that we recall (for those who are not immersed in graph theory) the main objects with which we will work in this article and dive into algorithms and all the beautiful mathematics that stands behind it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Graph theory, random and web graphs </h3><br>  Probably the best thing in this section is to send the reader to watch the wonderful video lectures and brochures of my supervisor <a href="http://www.gazeta.ru/science/2012/02/08_a_3992561.shtml">Andrei Mikhailovich Raigorodsky</a> , for example, <a href="http://www.gazeta.ru/science/2012/02/08_a_3992561.shtml">here</a> - no one will tell about it better than anyone.  It is highly recommended to also see <a href="http://www.youtube.com/watch%3Fv%3DKDQ-m5q2Riw">this</a> or <a href="https://mipt.ru/upload/30d/Pages_130-140_from_Trud-8-14-arphcxl1tgs.pdf">that</a> .  And even better - sign up for the course Andrei Mikhailovich <a href="https://www.coursera.org/instructor/raigorodsky">Coursera</a> .  Therefore, here we only give the basic concepts and we will not go into details. <br><br>  A graph is a pair <b>G = (V, E)</b> - where, <b>V</b> is a set of <b>vertices</b> (say, sites on the Internet), and <b>E</b> is a set of <b>edges</b> connecting vertices (respectively, links between sites).  Quite understandable structure, the analysis of which is engaged for many years.  However, in practice, when analyzing real networks, the question arises - how is this graph constructed?  Let's say a new site appears on the Internet - to whom it will link first of all, how many new links will appear on average, how well will this site be ranked in search results? <br><br>  People have been involved in this task ( <b>web graph</b> device) almost since the advent of the Internet.  During this time, <a href="https://mipt.ru/upload/30d/Pages_130-140_from_Trud-8-14-arphcxl1tgs.pdf">many models</a> were invented.  Not so long ago, a <a href="https://events.yandex.ru/lib/talks/1311/">generalized model</a> was proposed in <b>Yandex</b> , and <a href="https://events.yandex.ru/lib/talks/1919/">its properties were</a> also investigated. <br><br>  If the graph is already given to us, its properties, as well as further calculations on the graph, are completely defined.  For example, you can examine how the degree of a particular vertex (the number of friends of a person in a social network) itself, or measure the distances between specific vertices (through how many handshakes 2 specified people in the network are familiar), calculate connectivity components (a group of people any 2 people are familiar) and more. <br><br>  <b>Classical algorithms are:</b> <br><br>  <b><a href="https://ru.wikipedia.org/wiki/PageRank">PageRank</a></b> is a well-known algorithm for calculating the "authority" of a vertex in a graph proposed by Google in 1998 and used for a long time to rank search results <br><br>  <b><a href="http://en.wikipedia.org/wiki/Strongly_connected_component">Search for (strongly) connected components</a></b> ‚Äî an algorithm for finding subsets of graph vertices such that between any two vertices from a particular subset there is a path, and there are no paths between the vertices of different subsets <br><br>  <b><a href="http://en.wikipedia.org/wiki/Shortest_path_problem">Counting shortest paths in a graph</a></b> ‚Äî between any pair of vertices, between specific two vertices, on weighted graphs, and in other productions <br><br>  As well as counting the number of triangles, clustering, the distribution of degrees of vertices, click search in the graph and much more.  It is worth noting that most of the algorithms are iterative, and therefore, in this context, the GraphX ‚Äã‚Äãlibrary shows itself very well in view of the fact that it caches data in RAM.  Next, we consider what opportunities this library provides us. <br><br><h3>  Spark GraphX </h3><br>  Immediately, we note that GraphX ‚Äã‚Äãis far from being the first and not the only graph analysis tool (well-known tools are, for example, <b>GraphLab</b> ‚Äî the current <a href="https://dato.com/">Dato.com</a> or <b>Pregel</b> calculation model ‚Äî whose API is partially used in GraphX), and also that the writing of this post was still under development and its possibilities are not so great.  Nevertheless, practically for any tasks that arise in practice, GraphX ‚Äã‚Äãsomehow justifies its use. <br><br>  GraphX ‚Äã‚Äãdoes not yet have Python support, so we will write the code in Scala, assuming that <b>SparkContext</b> has already been created (in the code below, the variable <b>sc</b> ).  Most of the code below is taken from the documentation and public materials.  So, to begin with we will load all necessary libraries: <br><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.graphx._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.rdd.<span class="hljs-type"><span class="hljs-type">RDD</span></span></code> </pre> <br>  In Spark, the concept of a graph is implemented in the form of a so-called <b>Property Graph</b> - this is a multigraph with labels (additional information) on vertices and edges.  <b>A multigraph</b> is a <b>directed</b> (edges have directions) graph in which <b>multiple edges are</b> allowed (there may be several edges between two vertices), <b>loops</b> (an edge from a vertex to itself).  We immediately say that in the case of oriented graphs, such concepts as the <b>incoming degree</b> (the number of incoming edges) and the <b>outgoing degree</b> (the number of outgoing edges from the vertex) are defined.  Let's look at examples how to build a specific graph. <br><br><h4>  Graphing </h4><br>  You can build a graph using the <b>Graph</b> constructor, passing arrays of vertices and edges from a local program to the input (not forgetting to make <b>RDD</b> of them using the <b>.parallelize ()</b> function): <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vertexArray = <span class="hljs-type"><span class="hljs-type">Array</span></span>( (<span class="hljs-number"><span class="hljs-number">1</span></span>L, (<span class="hljs-string"><span class="hljs-string">"Alice"</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>)), (<span class="hljs-number"><span class="hljs-number">2</span></span>L, (<span class="hljs-string"><span class="hljs-string">"Bob"</span></span>, <span class="hljs-number"><span class="hljs-number">27</span></span>)), (<span class="hljs-number"><span class="hljs-number">3</span></span>L, (<span class="hljs-string"><span class="hljs-string">"Charlie"</span></span>, <span class="hljs-number"><span class="hljs-number">65</span></span>)), (<span class="hljs-number"><span class="hljs-number">4</span></span>L, (<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>)), (<span class="hljs-number"><span class="hljs-number">5</span></span>L, (<span class="hljs-string"><span class="hljs-string">"Ed"</span></span>, <span class="hljs-number"><span class="hljs-number">55</span></span>)), (<span class="hljs-number"><span class="hljs-number">6</span></span>L, (<span class="hljs-string"><span class="hljs-string">"Fran"</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>)) ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> edgeArray = <span class="hljs-type"><span class="hljs-type">Array</span></span>( <span class="hljs-type"><span class="hljs-type">Edge</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>L, <span class="hljs-number"><span class="hljs-number">1</span></span>L, <span class="hljs-number"><span class="hljs-number">7</span></span>), <span class="hljs-type"><span class="hljs-type">Edge</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>L, <span class="hljs-number"><span class="hljs-number">4</span></span>L, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-type"><span class="hljs-type">Edge</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>L, <span class="hljs-number"><span class="hljs-number">2</span></span>L, <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-type"><span class="hljs-type">Edge</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>L, <span class="hljs-number"><span class="hljs-number">6</span></span>L, <span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-type"><span class="hljs-type">Edge</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>L, <span class="hljs-number"><span class="hljs-number">1</span></span>L, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-type"><span class="hljs-type">Edge</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>L, <span class="hljs-number"><span class="hljs-number">2</span></span>L, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-type"><span class="hljs-type">Edge</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>L, <span class="hljs-number"><span class="hljs-number">3</span></span>L, <span class="hljs-number"><span class="hljs-number">8</span></span>), <span class="hljs-type"><span class="hljs-type">Edge</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>L, <span class="hljs-number"><span class="hljs-number">6</span></span>L, <span class="hljs-number"><span class="hljs-number">3</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vertexRDD = sc.parallelize(vertexArray) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> edgeRDD = sc.parallelize(edgeArray) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph = <span class="hljs-type"><span class="hljs-type">Graph</span></span>(vertexRDD, edgeRDD)</code> </pre><br>  Or, if the vertices and edges must first be constructed on the basis of some data lying, say in <b>HDFS</b> , it is necessary to first process the initial data themselves (as is often the case with the <b>.map ()</b> transformation).  For example, if we have Wikipedia articles stored as <b>(id, title)</b> , as well as links between articles stored as pairs, then the graph is fairly easy to create - you need to separate <b>id</b> from <b>title</b> in the first case and construct the edges themselves (there is an <b>Edge</b> constructor for this) - in the second case, at the output, getting a list of vertices and edges that can be passed to the <b>Graph</b> constructor: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> articles = sc.textFile(<span class="hljs-string"><span class="hljs-string">"articles.txt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> links = sc.textFile(<span class="hljs-string"><span class="hljs-string">"links.txt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vertices = articles.map { line =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fields = line.split('\t') (fields(<span class="hljs-number"><span class="hljs-number">0</span></span>).toLong, fields(<span class="hljs-number"><span class="hljs-number">1</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> edges = links.map { line =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fields = line.split('\t') <span class="hljs-type"><span class="hljs-type">Edge</span></span>(fields(<span class="hljs-number"><span class="hljs-number">0</span></span>).toLong, fields(<span class="hljs-number"><span class="hljs-number">1</span></span>).toLong, <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph = <span class="hljs-type"><span class="hljs-type">Graph</span></span>(vertices, edges, <span class="hljs-string"><span class="hljs-string">""</span></span>).cache()</code> </pre><br>  After constructing the graph for it, it is possible to calculate some characteristics and also run on it the algorithms, including those listed above.  Until we continue, it is worth noting here that in Spark, in addition to the concept of vertices and edges, the concept of triplet is also implemented - this object, which in a sense extends the edge object a little ( <b>Edge</b> ) - in addition to information about the edge, information about tops adjacent to it. <br><br><h4>  Calculations on graphs </h4><br>  The remarkable fact is that in most packages (and GraphX ‚Äã‚Äãis not an exception) - after the construction of the graph, it becomes easy to do calculations on it, as well as to run standard algorithms.  Indeed, the methods of calculation on graphs themselves are studied quite well, and in concrete applied problems the most difficult thing is to define the graph, namely, to determine what are vertices and what are edges (on what basis to carry them out).  Below is a list of some of the available methods for the Graph object with comments: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Graph</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VD</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ED</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    val numEdges: Long //   val numVertices: Long //   val inDegrees: VertexRDD[Int] //    val outDegrees: VertexRDD[Int] //    val degrees: VertexRDD[Int] //    //   ,    val vertices: VertexRDD[VD] val edges: EdgeRDD[ED] val triplets: RDD[EdgeTriplet[VD, ED]] //   ( )     def mapVertices[VD2](map: (VertexID, VD) =&gt; VD2): Graph[VD2, ED] def mapEdges[ED2](map: Edge[ED] =&gt; ED2): Graph[VD, ED2] def mapEdges[ED2](map: (PartitionID, Iterator[Edge[ED]]) =&gt; Iterator[ED2]): Graph[VD, ED2] def mapTriplets[ED2](map: EdgeTriplet[VD, ED] =&gt; ED2): Graph[VD, ED2] //   def reverse: Graph[VD, ED] //  -       def subgraph( epred: EdgeTriplet[VD,ED] =&gt; Boolean = (x =&gt; true), vpred: (VertexID, VD) =&gt; Boolean = ((v, d) =&gt; true)) : Graph[VD, ED] //  ,    def groupEdges(merge: (ED, ED) =&gt; ED): Graph[VD, ED] //   //    def pageRank(tol: Double, resetProb: Double = 0.15): Graph[Double, Double] //  PageRank def connectedComponents(): Graph[VertexID, ED] //    def triangleCount(): Graph[Int, ED] //    def stronglyConnectedComponents(numIter: Int): Graph[VertexID, ED] //     }</span></span></code> </pre><br>  It is worth noting that the current implementation of SparkX contains quite a few implemented algorithms, so it is still relevant to use the above known packages instead of Apache Spark, however, there is confidence that GraphX ‚Äã‚Äãwill be significantly improved in the future, and thanks to the possibility of caching data in RAM, likely to get enough popularity in graph problems.  In conclusion, we give examples of practical problems where graph methods have to be applied. <br><br><h4>  Practical tasks </h4><br>  As mentioned above, the main problem in practical tasks is no longer to run complex algorithms - namely, the correct definition of the graph, its correct preprocessing and the reduction of the problem to the classical solved one.  Consider this in examples where we leave the reader a large number of questions for reflection: <br><br>  <b>Prediction of the appearance of a new edge (Link Prediction)</b> <br>  The task is fairly common - a sequence of edges is given, which are added to the graph up to a certain point.  It is necessary to predict which edges will appear in the future in our graph.  From the point of view of real life, this task is part of a recommendatory system ‚Äî for example, predicting connections (‚Äúfriendship‚Äù) between two users of social services.  network.  In this task, it is actually necessary to predict for each pair of arbitrarily selected vertices - what is the probability that there will be a rib between them in the future - here you just need to work with signs and with a description of the vertices.  For example, as one of the signs, there may be an intersection of a set of friends, or a Jacquard measure.  The reader is invited to think about possible metrics of similarity between the peaks and write your own variation in the comments). <br><br>  <b>Selection of communities in social networks</b> <br>  A task that is difficult to attribute to any specific tasks.  Often it is considered in the context of the ‚Äúclustering on graphs‚Äù task.  There are a lot of methods to solve here - from simple selection of connected components (the algorithm was mentioned above) with a correctly defined subset of vertices, to sequential removal of edges from the graph until the necessary component remains.  Here, again - it is very important to first understand which communities we want to allocate in the network, i.e.  first work with the description of vertices and edges, and only then think how to select the communities themselves in the subgraph. <br><br>  <b>Shortest distances on graphs</b> <br>  This task is also a classic one and is implemented, for example, in the same Yandex. Metro or other services that help find the shortest paths in a certain graph ‚Äî be it a graph of connections between points of a city or a graph of dating. <br><br>  Or a task that a mobile operator can easily encounter, for example: <br><br>  <b>Identifying opinion leaders online</b> <br>  In order to promote, say, some new option, for example, the mobile Internet, in order to optimize the advertising budget, I would like to highlight people who are in some sense surrounded by attention.  In our terms, these are the vertices of the graph that are more authoritative in the network - therefore, this task, if properly constructed, is reduced to the PageRank task. <br><br>  So, we have considered typical applied graph analysis problems that may arise in practice, as well as one of the tools that can be used to solve them.  This concludes the review of the Apache Spark library, and indeed the review of tools and in the future we will focus more on algorithms and specific tasks! </div><p>Source: <a href="https://habr.com/ru/post/252157/">https://habr.com/ru/post/252157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252147/index.html">History of Imagine Cup 2014 through the eyes of Brainy Studio</a></li>
<li><a href="../252149/index.html">HP MSA Disk Arrays as a Basis for Data Consolidation</a></li>
<li><a href="../252151/index.html">We turn useless feedback into useful: working with the Plesk community</a></li>
<li><a href="../252153/index.html">Moto alarm based on Arduino UNO with accelerometer MMA7361</a></li>
<li><a href="../252155/index.html">And Internet Explorer may be useful.</a></li>
<li><a href="../252161/index.html">Opera Mini for Windows Phone, video from MWC</a></li>
<li><a href="../252165/index.html">FREAK - TLS Downgrade attack on Android and iOS</a></li>
<li><a href="../252167/index.html">BitTorrent Sync 2.0 has been released with a paid PRO package</a></li>
<li><a href="../252169/index.html">Trends 2015: Why more and more "non-techies" are learning layout</a></li>
<li><a href="../252171/index.html">3-2-1-Let's go! Microsoft Developer Tour in Russia, Belarus and Kazakhstan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>