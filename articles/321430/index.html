<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mongoose Embedded Compact Web Server</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the process of developing various projects in C / C ++, it is often necessary to communicate with external systems or send data to clients via HTTP...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mongoose Embedded Compact Web Server</h1><div class="post__text post__text-html js-mediator-article">  In the process of developing various projects in C / C ++, it is often necessary to communicate with external systems or send data to clients via HTTP.  An example is any web service, as well as any device with a web interface such as a router, video surveillance system, etc. <br><br>  What then do they usually do?  That's right, go trodden path - Apache / nginx + PHP.  And then hell begins, because: <br><br>  1. All this needs to be installed and configured. <br>  2. All this eats a decent amount of resources. <br>  3. From PHP somehow need to get data from the developed system.  If you are lucky enough to just get into the database. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Therefore, I, as I think of many other developers, have an overwhelming desire to cram all these functions directly into the system being developed.  This will give undeniable advantages: <br><br>  1. It is less than external dependences, so installation and setup is simpler. <br>  2. Theoretically less resource consumption. <br>  3. You can give data directly from your product, without intermediaries. <br>  But at the same time, we don‚Äôt want to bother with all the intricacies of processing HTTP connections, parsing, etc. <br><br>  There are such solutions.  And in this article I would like to superficially introduce you to one of them - the Mongoose embedded server (not to be confused with MongoDB). <br><a name="habracut"></a><br><h3>  Main features </h3><br>  Mongoose was initially positioned as an embedded web server.  This means that if you have a project in C / C ++ - you just need to include two compact files mongoose.c and mongoose.h in your project, write literally a few dozen lines of code - and voila, you can process HTTP requests! <br><br>  However, in recent years, Mongoose has seriously grown up and now it‚Äôs not just an embedded web server, but a whole embedded ‚Äúnetwork library‚Äù.  That is, in addition to the HTTP server, with its help you can also implement: TCP and UDP sockets, HTTP client, WebSocket, MQTT, DNS client and DNS server, etc. <br><br>  Also a huge plus of this library is that it works asynchronously, i.e.  you simply write an event handler function that is called on any event (connection establishment, break, data reception, transfer, request, etc.), and in the main loop of your program you insert a function that your handler calls for each event event. <br><br>  Thus, your program can be single-threaded and non-blocking, which has a positive effect on saving resources and performance. <br><br><h3>  Usage example </h3><br>  An abstract example for clarity: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mongoose.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     struct mg_mgr mg_manager; //  http- struct mg_connection *http_mg_conn; //  http- struct mg_serve_http_opts s_http_server_opts; const char *example_data_buf = "{ \"some_response_data\": \"Hello world!\" }"; const char *html_error_template = "&lt;html&gt;\n" "&lt;head&gt;&lt;title&gt;%d %s&lt;/title&gt;&lt;/head&gt;\n" "&lt;body bgcolor=\"white\"&gt;\n" "&lt;center&gt;&lt;h1&gt;%d %s&lt;/h1&gt;&lt;/center&gt;\n" "&lt;/body&gt;\n" "&lt;/html&gt;\n"; //----------------------------------------------------------------------------- //     void http_request_handler(struct mg_connection *conn, int ev, void *ev_data) { switch (ev) { case MG_EV_ACCEPT: { //   -      conn-&gt;sock break; } case MG_EV_HTTP_REQUEST: { struct http_message *http_msg = (struct http_message *)ev_data; //  HTTP- // http_msg-&gt;uri - URI  // http_msg-&gt;body -   //    if (mg_vcmp(&amp;http_msg-&gt;uri, "/api/v1.0/queue/get") == 0) { mg_printf(conn, "HTTP/1.1 200 OK\r\n" "Server: MyWebServer\r\n" "Content-Type: application/json\r\n" "Content-Length: %d\r\n" "Connection: close\r\n" "\r\n", (int)strlen(example_data_buf)); mg_send(conn, example_data_buf, strlen(example_data_buf)); //      conn-&gt;flags // ,        : conn-&gt;flags |= MG_F_SEND_AND_CLOSE; } //    404 else if (strncmp(http_msg-&gt;uri.p, "/api", 4) == 0) { char buf_404[2048]; sprintf(buf_404, html_error_template, 404, "Not Found", 404, "Not Found"); mg_printf(conn, "HTTP/1.1 404 Not Found\r\n" "Server: MyWebServer\r\n" "Content-Type: text/html\r\n" "Content-Length: %d\r\n" "Connection: close\r\n" "\r\n", (int)strlen(buf_404)); mg_send(conn, buf_404, strlen(buf_404)); conn-&gt;flags |= MG_F_SEND_AND_CLOSE; } //   URI -   else mg_serve_http(conn, http_msg, s_http_server_opts); break; } case MG_EV_RECV: { //  *(int *)ev_data  break; } case MG_EV_SEND: { //  *(int *)ev_data  break; } case MG_EV_CLOSE: { //   break; } default: { break; } } } bool flag_kill = false; //----------------------------------------------------------------------------- void termination_handler(int) { flag_kill = true; } //--------------------------------------------------------------------------- int main(int, char *[]) { signal(SIGTERM, termination_handler); signal(SIGSTOP, termination_handler); signal(SIGKILL, termination_handler); signal(SIGINT, termination_handler); signal(SIGQUIT, termination_handler); //    s_http_server_opts.document_root = "/var/www"; //       s_http_server_opts.enable_directory_listing = "no"; //   mg_mgr_init(&amp;mg_manager, NULL); //    localhost:8080    -  http_request_handler http_mg_conn = mg_bind(&amp;mg_manager, "127.0.0.1:8080", http_request_handler); if (!http_mg_conn) return -1; //   http mg_set_protocol_http_websocket(http_mg_conn); while (!flag_kill) { //    -   //    mg_connection-&gt;sock   //   (   )      select/poll, //     sleep- // ... // int ms_wait = 1000; //           ms_wait   //     bool has_other_work_to_do = false; //       mg_mgr_poll(&amp;mg_manager, has_other_work_to_do ? 0 : ms_wait); } //    mg_mgr_free(&amp;mg_manager); return 0; }</span></span></span></span></code> </pre> <br>  Please note that the connection remains open until the client closes it, or until we close it explicitly (using conn-&gt; flags).  This means that we can process the request after exiting the handler function. <br><br>  Thus, for asynchronous request processing, we can only implement the request queue and control of connections.  And then you can make asynchronous queries to the database and external data sources / consumers. <br><br>  In theory, it should be a very beautiful solution! <br>  It is ideal for creating (for AJAX) web interfaces for managing compact devices, and for example, for creating various APIs using the HTTP protocol. <br><br>  Despite the simplicity, it seems to me that this is also a scalable solution (if this applies generally to the architecture of your application, of course), because  ahead you can put the nginx proxy: <br><pre> <code class="nginx hljs"> <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /api { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1:8080; }</code> </pre><br>  Well, then you can still connect and balancing a few instances ... <br><br><h3>  Conclusion </h3><br>  Judging by the project <a href="https://github.com/cesanta/mongoose">GitHub page</a> , it is still actively developing. <br><br>  A huge fly in the ointment is the GPLv2 license, and the price tag on a commercial license for small projects bites. <br><br>  If any reader uses this library, especially in production, please leave comments! </div><p>Source: <a href="https://habr.com/ru/post/321430/">https://habr.com/ru/post/321430/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321418/index.html">GitLab 8.16 released: Support for Google Container Engine, built-in Prometheus + time tracking in CE</a></li>
<li><a href="../321420/index.html">Product Design Digest, January 2017</a></li>
<li><a href="../321424/index.html">DRM-protected Windows files can be used to de-anonymize a Tor user</a></li>
<li><a href="../321426/index.html">Development for Sailfish OS: Creating your own QML component in C ++</a></li>
<li><a href="../321428/index.html">BIND vulnerability allows you to ‚Äúdrop‚Äù any server: how and why it works</a></li>
<li><a href="../321432/index.html">Virtuozz moving</a></li>
<li><a href="../321434/index.html">Neyrabayesovsky approach to machine learning problems. Lecture by Dmitry Vetrov in Yandex</a></li>
<li><a href="../321436/index.html">YouTrack release 2017.1 and Hub 2017.1</a></li>
<li><a href="../321438/index.html">Offer a project for testing with the PVS-Studio analyzer: now on GitHub</a></li>
<li><a href="../321440/index.html">How to enable JTAG debugging via USB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>