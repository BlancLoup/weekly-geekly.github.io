<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Comet ‚Äì application for Mochiweb with a load of 1 000 000 users. Part 3/3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1 and Part 2 in this series of articles showed how to create an application using mochiweb, and how to send messages to connected users. We reduc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Comet ‚Äì application for Mochiweb with a load of 1 000 000 users. Part 3/3</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/blogs/erlang/111252/">Part 1</a> and <a href="http://habrahabr.ru/blogs/erlang/111350/">Part 2</a> in this series of articles showed how to create an application using mochiweb, and how to send messages to connected users.  We reduced the memory consumption to 8 KB for each connection.  We repeated the c10k test.  We made graphics.  It was fun, but now it's time to repeat everything for 1 million connections. <br><br>  This article covers the following: <br>  ‚Ä¢ Using the Mnesia database; <br>  ‚Ä¢ Generate a believable ‚Äúfriends‚Äù data set for a million users; <br>  ‚Ä¢ Configure Mnesia and enter our data; <br>  ‚Ä¢ Discovery of a million connections from one machine; <br>  ‚Ä¢ Comparative test with 1 million users; <br>  ‚Ä¢ Libevent + C for handling connections; <br>  ‚Ä¢ Final conclusions. <br><a name="habracut"></a><br>  One of the parts of this test is the ability to open 1,000,000 connections from a single test machine.  Writing a server that is able to accept 1,000,000 connections is easier than actually creating 1,000,000 connections.  Thus, a fair amount of this article is about the methods used to open 1,000,000 connections from a single machine. <br><br><h4>  Launch our Pubsub. </h4><br>  In Part 2, we used a router to send messages to specific users.  This is fine for the chat / IM system, but there are more useful things we could do instead.  Before we start a large-scale test, let's add another module - the subscriber database.  We will create a repository with data about your friends, so it can provide you with all the events generated by people from your friends list. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      My intention is to use it for Last.fm.  That way, I can get a real-time channel of the songs that my friends are currently listening to.  This can equally apply to other events generated on social networks.  Photos uploaded to Flickr, Facebook news, Twitter, etc.  FriendFeed even has a real-time API in beta, so this is definitely relevant. <br><br><h4>  Subscription Manager Implementation </h4><br>  We are implementing a simple subscription manager, but we will be subscribing people to all their friends automatically. <br><br>  API: <br>  ‚Ä¢ add_subscriptions ([{Subscriber, Subscribee}, ...]) <br>  ‚Ä¢ remove_subscriptions ([{Subscriber, Subscribee}, ...]) <br>  ‚Ä¢ get_subscribers (User) <br><br><pre><code class="hljs pgsql">-module(subsmanager). -behaviour(gen_server). -<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>("/usr/local/lib/erlang/lib/stdlib-1.15.4/include/qlc.hrl"). -export([init/<span class="hljs-number"><span class="hljs-number">1</span></span>, handle_call/<span class="hljs-number"><span class="hljs-number">3</span></span>, handle_cast/<span class="hljs-number"><span class="hljs-number">2</span></span>, handle_info/<span class="hljs-number"><span class="hljs-number">2</span></span>, terminate/<span class="hljs-number"><span class="hljs-number">2</span></span>, code_change/<span class="hljs-number"><span class="hljs-number">3</span></span>]). -export([add_subscriptions/<span class="hljs-number"><span class="hljs-number">1</span></span>, remove_subscriptions/<span class="hljs-number"><span class="hljs-number">1</span></span>, get_subscribers/<span class="hljs-number"><span class="hljs-number">1</span></span>, first_run/<span class="hljs-number"><span class="hljs-number">0</span></span>, stop/<span class="hljs-number"><span class="hljs-number">0</span></span>, start_link/<span class="hljs-number"><span class="hljs-number">0</span></span>]). -<span class="hljs-type"><span class="hljs-type">record</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">subscription</span></span>, {subscriber, subscribee}). -<span class="hljs-type"><span class="hljs-type">record</span></span>(state, {}). % state <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mnesia -define(<span class="hljs-keyword"><span class="hljs-keyword">SERVER</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">global</span></span>:whereis_name(?MODULE)). start_link() -&gt; gen_server:start_link({<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>, ?MODULE}, ?MODULE, [], []). stop() -&gt; gen_server:<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(?<span class="hljs-keyword"><span class="hljs-keyword">SERVER</span></span>, {stop}). add_subscriptions(SubsList) -&gt; gen_server:<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(?<span class="hljs-keyword"><span class="hljs-keyword">SERVER</span></span>, {add_subscriptions, SubsList}, <span class="hljs-keyword"><span class="hljs-keyword">infinity</span></span>). remove_subscriptions(SubsList) -&gt; gen_server:<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(?<span class="hljs-keyword"><span class="hljs-keyword">SERVER</span></span>, {remove_subscriptions, SubsList}, <span class="hljs-keyword"><span class="hljs-keyword">infinity</span></span>). get_subscribers(<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>) -&gt; gen_server:<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(?<span class="hljs-keyword"><span class="hljs-keyword">SERVER</span></span>, {get_subscribers, <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>}). %% init([]) -&gt; ok = mnesia:<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>(), io:format("Waiting on mnesia tables..\n",[]), mnesia:wait_for_tables([<span class="hljs-keyword"><span class="hljs-keyword">subscription</span></span>], <span class="hljs-number"><span class="hljs-number">30000</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> = mnesia:table_info(<span class="hljs-keyword"><span class="hljs-keyword">subscription</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">all</span></span>), io:format("OK. Subscription table info: \n~w\n\n",[<span class="hljs-keyword"><span class="hljs-keyword">Info</span></span>]), {ok, #state{}}. handle_call({stop}, _From, State) -&gt; {stop, stop, State}; handle_call({add_subscriptions, SubsList}, _From, State) -&gt; % Transactionally <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> slower: % F = fun() -&gt; % [ ok = mnesia:<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(S) || S &lt;- SubsList ] % <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, % mnesia:<span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span>(F), [ mnesia:dirty_write(S) || S &lt;- SubsList ], {reply, ok, State}; handle_call({remove_subscriptions, SubsList}, _From, State) -&gt; F = fun() -&gt; [ ok = mnesia:delete_object(S) || S &lt;- SubsList ] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, mnesia:<span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span>(F), {reply, ok, State}; handle_call({get_subscribers, <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">From</span></span>, State) -&gt; F = fun() -&gt; Subs = mnesia:dirty_match_object(#<span class="hljs-keyword"><span class="hljs-keyword">subscription</span></span>{subscriber=<span class="hljs-string"><span class="hljs-string">'_'</span></span>, subscribee=<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>}), Users = [Dude || #<span class="hljs-keyword"><span class="hljs-keyword">subscription</span></span>{subscriber=Dude, subscribee=_} &lt;- Subs], gen_server:reply(<span class="hljs-keyword"><span class="hljs-keyword">From</span></span>, Users) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, spawn(F), {noreply, State}. handle_cast(_Msg, State) -&gt; {noreply, State}. handle_info(_Msg, State) -&gt; {noreply, State}. terminate(_Reason, _State) -&gt; mnesia:stop(), ok. code_change(_OldVersion, State, _Extra) -&gt; io:format("Reloading code for ?MODULE\n",[]), {ok, State}. %% first_run() -&gt; mnesia:create_schema([node()]), ok = mnesia:<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>(), Ret = mnesia:create_table(<span class="hljs-keyword"><span class="hljs-keyword">subscription</span></span>, [ {disc_copies, [node()]}, {attributes, record_info(fields, <span class="hljs-keyword"><span class="hljs-keyword">subscription</span></span>)}, {<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, [subscribee]}, %<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> subscribee too {<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, bag} ]), Ret.</code> </pre> <br><br>  Remarkable: <br>  ‚Ä¢ I included qlc.hrl, necessary for Mnesia, using the absolute path.  This is not good, but it did not work out differently. <br>  ‚Ä¢ get_subscribers generates another process and delegates the creation of a response to this same process using gen_server: reply.  This means that the gen_server loop will not block on this call if we often call a lookup. <br>  ‚Ä¢ rr ("subsmanager.erl").  The example below allows you to use record definitions in the erl shell.  Put your definitions in the records.hrl file and include it in your modules is the best style.  I did it for short. <br><br>  Now check.  first_run () creates the Mnesia scheme, so it is important to call it first.  Another potential bug with mnesia is that (by default) only the node that created it can access the database, so give the erl shell a name. <br><pre> <code class="hljs ruby">$ mkdir /var/mnesia $ erl -boot start_sasl -mnesia dir <span class="hljs-string"><span class="hljs-string">'"/var/mnesia_data"'</span></span> -sname subsman (subsman@localhost)<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; c(subsmanager). {ok,subsmanager} (subsman@localhost)<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">subsmanager:</span></span>first_run(). ... {atomic,ok} (subsman@localhost)<span class="hljs-number"><span class="hljs-number">3</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">subsmanager:</span></span>start_link(). Waiting on mnesia tables.. OK. Subscription table <span class="hljs-symbol"><span class="hljs-symbol">info:</span></span> [{access_mode,read_write},{active_replicas,[subsman@localhost]},{arity,<span class="hljs-number"><span class="hljs-number">3</span></span>},{attributes,[subscriber,subscribee]},{checkpoints,[]},{commit_work,[{index,bag,[{<span class="hljs-number"><span class="hljs-number">3</span></span>,{ram,<span class="hljs-number"><span class="hljs-number">57378</span></span>}}]}]},{cookie,{{<span class="hljs-number"><span class="hljs-number">1224</span></span>,<span class="hljs-number"><span class="hljs-number">800064</span></span>,<span class="hljs-number"><span class="hljs-number">900003</span></span>},subsman@localhost}},{cstruct,{cstruct,subscription,bag,[],[subsman@localhost],[],<span class="hljs-number"><span class="hljs-number">0</span></span>,read_write,[<span class="hljs-number"><span class="hljs-number">3</span></span>],[],<span class="hljs-literal"><span class="hljs-literal">false</span></span>,subscription,[subscriber,subscribee],[],[],{{<span class="hljs-number"><span class="hljs-number">1224</span></span>,<span class="hljs-number"><span class="hljs-number">863164</span></span>,<span class="hljs-number"><span class="hljs-number">904753</span></span>},subsman@localhost},{{<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>},[]}}},{disc_copies,[subsman@localhost]},{disc_only_copies,[]},{frag_properties,[]},{index,[<span class="hljs-number"><span class="hljs-number">3</span></span>]},{load_by_force,<span class="hljs-literal"><span class="hljs-literal">false</span></span>},{load_node,subsman@localhost},{load_order,<span class="hljs-number"><span class="hljs-number">0</span></span>},{load_reason,{dumper,create_table}},{local_content,<span class="hljs-literal"><span class="hljs-literal">false</span></span>},{master_nodes,[]},{memory,<span class="hljs-number"><span class="hljs-number">288</span></span>},{ram_copies,[]},{record_name,subscription},{record_validation,{subscription,<span class="hljs-number"><span class="hljs-number">3</span></span>,bag}},{type,bag},{size,<span class="hljs-number"><span class="hljs-number">0</span></span>},{snmp,[]},{storage_type,disc_copies},{subscribers,[]},{user_properties,[]},{version,{{<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>},[]}},{where_to_commit,[{subsman@localhost,disc_copies}]},{where_to_read,subsman@localhost},{where_to_write,[subsman@localhost]},{wild_pattern,{subscription,<span class="hljs-string"><span class="hljs-string">'_'</span></span>,<span class="hljs-string"><span class="hljs-string">'_'</span></span>}},{{index,<span class="hljs-number"><span class="hljs-number">3</span></span>},<span class="hljs-number"><span class="hljs-number">57378</span></span>}] {ok,&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">105.0</span></span>&gt;} (subsman@localhost)<span class="hljs-number"><span class="hljs-number">4</span></span>&gt; rr(<span class="hljs-string"><span class="hljs-string">"subsmanager.erl"</span></span>). [state,subscription] (subsman@localhost)<span class="hljs-number"><span class="hljs-number">5</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">subsmanager:</span></span>add_subscriptions([ <span class="hljs-comment"><span class="hljs-comment">#subscription{subscriber=alice, subscribee=rj} ]). ok (subsman</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@localhost</span></span></span><span class="hljs-comment">)6&gt; subsmanager:add_subscriptions([ #subscription{subscriber=bob, subscribee=rj} ]). ok (subsman</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@localhost</span></span></span><span class="hljs-comment">)7&gt; subsmanager:get_subscribers(rj). [bob,alice] (subsman</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@localhost</span></span></span><span class="hljs-comment">)8&gt; subsmanager:remove_subscriptions([ #subscription{subscriber=bob, subscribee=rj} ]). ok (subsman</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@localhost</span></span></span><span class="hljs-comment">)8&gt; subsmanager:get_subscribers(rj). [alice] (subsman</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@localhost</span></span></span><span class="hljs-comment">)10&gt; subsmanager:get_subscribers(charlie). []</span></span></code> </pre><br>  We will use integer Id to distinguish between users - but for this test I used atoms (rj, alice, bob) and assumed that alice and bob are friends of rj.  It is great that mnesia (and ets / dets) do not care which types you used - any Erlang term is allowed.  This means that updating to support various types will not be difficult. <br><br><h4>  Change router </h4><br>  Instead of addressing messages to specific users, that is, router: send (123, ‚ÄúHello user 123‚Äù), we ‚Äúmark‚Äù the messages ‚Äî the person who generated the message ‚Äî and there is a router that sends the message to each subscribed user.  In other words, the API will work like this: router: send (123, ‚ÄúHello everyone subscribed to user 123‚Äù). <br><pre> <code class="hljs pgsql">-module(router). -behaviour(gen_server). -export([start_link/<span class="hljs-number"><span class="hljs-number">0</span></span>]). -export([init/<span class="hljs-number"><span class="hljs-number">1</span></span>, handle_call/<span class="hljs-number"><span class="hljs-number">3</span></span>, handle_cast/<span class="hljs-number"><span class="hljs-number">2</span></span>, handle_info/<span class="hljs-number"><span class="hljs-number">2</span></span>, terminate/<span class="hljs-number"><span class="hljs-number">2</span></span>, code_change/<span class="hljs-number"><span class="hljs-number">3</span></span>]). -export([send/<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>, logout/<span class="hljs-number"><span class="hljs-number">1</span></span>]). -define(<span class="hljs-keyword"><span class="hljs-keyword">SERVER</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">global</span></span>:whereis_name(?MODULE)). % will hold bidirectional <span class="hljs-keyword"><span class="hljs-keyword">mapping</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> id &lt;‚Äì&gt; pid -<span class="hljs-type"><span class="hljs-type">record</span></span>(state, {pid2id, id2pid}). start_link() -&gt; gen_server:start_link({<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>, ?MODULE}, ?MODULE, [], []). % sends Msg <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> anyone subscribed <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Id send(Id, Msg) -&gt; gen_server:<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(?<span class="hljs-keyword"><span class="hljs-keyword">SERVER</span></span>, {send, Id, Msg}). <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>(Id, Pid) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> is_pid(Pid) -&gt; gen_server:<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(?<span class="hljs-keyword"><span class="hljs-keyword">SERVER</span></span>, {<span class="hljs-keyword"><span class="hljs-keyword">login</span></span>, Id, Pid}). logout(Pid) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> is_pid(Pid) -&gt; gen_server:<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(?<span class="hljs-keyword"><span class="hljs-keyword">SERVER</span></span>, {logout, Pid}). %% init([]) -&gt; % <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> this so we can catch death <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logged</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pids: process_flag(trap_exit, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>), % use ets <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> routing <span class="hljs-keyword"><span class="hljs-keyword">tables</span></span> {ok, #state{ pid2id = ets:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(?MODULE, [bag]), id2pid = ets:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(?MODULE, [bag]) } }. handle_call({<span class="hljs-keyword"><span class="hljs-keyword">login</span></span>, Id, Pid}, _From, State) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> is_pid(Pid) -&gt; ets:<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(State#state.pid2id, {Pid, Id}), ets:<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(State#state.id2pid, {Id, Pid}), link(Pid), % tell us <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> they <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>, so we can <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> them <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> %io:format("~w logged in as ~w\n",[Pid, Id]), {reply, ok, State}; handle_call({logout, Pid}, _From, State) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> is_pid(Pid) -&gt; unlink(Pid), PidRows = ets:lookup(State#state.pid2id, Pid), <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> PidRows <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [] -&gt; ok; _ -&gt; IdRows = [ {I,P} || {P,I} &lt;- PidRows ], % invert tuples ets:<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(State#state.pid2id, Pid), % <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> pid-&gt;id entries [ ets:delete_object(State#state.id2pid, Obj) || Obj &lt;- IdRows ] % <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> id-&gt;pid <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, %io:format("pid ~w logged out\n",[Pid]), {reply, ok, State}; handle_call({send, Id, Msg}, <span class="hljs-keyword"><span class="hljs-keyword">From</span></span>, State) -&gt; F = fun() -&gt; % <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> users who are subscribed <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Id: Users = subsmanager:get_subscribers(Id), io:format("Subscribers of ~w = ~w\n",[Id, Users]), % <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> pids <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> anyone <span class="hljs-keyword"><span class="hljs-keyword">logged</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Users list: Pids0 = lists:map( fun(U)-&gt; [ P || { _I, P } &lt;- ets:lookup(State#state.id2pid, U) ] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, [ Id | Users ] % we are <span class="hljs-keyword"><span class="hljs-keyword">always</span></span> subscribed <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ourselves ), Pids = lists:flatten(Pids0), io:format("Pids: ~w\n", [Pids]), % send Msg <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> them <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> M = {router_msg, Msg}, [ Pid ! M || Pid &lt;- Pids ], % respond <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> how many users saw the message gen_server:reply(<span class="hljs-keyword"><span class="hljs-keyword">From</span></span>, {ok, length(Pids)}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, spawn(F), {noreply, State}. % handle death <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> cleanup <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logged</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> processes handle_info(<span class="hljs-keyword"><span class="hljs-keyword">Info</span></span>, State) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> {<span class="hljs-string"><span class="hljs-string">'EXIT'</span></span>, Pid, _Why} -&gt; handle_call({logout, Pid}, blah, State); Wtf -&gt; io:format("Caught unhandled message: ~w\n", [Wtf]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, {noreply, State}. handle_cast(_Msg, State) -&gt; {noreply, State}. terminate(_Reason, _State) -&gt; ok. code_change(_OldVsn, State, _Extra) -&gt; {ok, State}.</code> </pre><br><br>  A small test - I used atoms instead of id. <br><pre> <code class="hljs mel">(subsman@localhost)<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; c(subsmanager), c(router), rr(<span class="hljs-string"><span class="hljs-string">"subsmanager.erl"</span></span>). (subsman@localhost)<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; subsmanager:start_link(). (subsman@localhost)<span class="hljs-number"><span class="hljs-number">3</span></span>&gt; router:start_link(). (subsman@localhost)<span class="hljs-number"><span class="hljs-number">4</span></span>&gt; Subs = [#subscription{subscriber=alice, subscribee=rj}, #subscription{subscriber=bob, subscribee=rj}]. [#subscription{subscriber = alice,subscribee = rj}, #subscription{subscriber = bob,subscribee = rj}] (subsman@localhost)<span class="hljs-number"><span class="hljs-number">5</span></span>&gt; subsmanager:add_subscriptions(Subs). ok (subsman@localhost)<span class="hljs-number"><span class="hljs-number">6</span></span>&gt; router:send(rj, <span class="hljs-string"><span class="hljs-string">"RJ did something"</span></span>). Subscribers of rj = [bob,alice] Pids: [] {ok,<span class="hljs-number"><span class="hljs-number">0</span></span>} (subsman@localhost)<span class="hljs-number"><span class="hljs-number">7</span></span>&gt; router:login(alice, self()). ok (subsman@localhost)<span class="hljs-number"><span class="hljs-number">8</span></span>&gt; router:send(rj, <span class="hljs-string"><span class="hljs-string">"RJ did something"</span></span>). Subscribers of rj = [bob,alice] Pids: [&lt;<span class="hljs-number"><span class="hljs-number">0.46</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>&gt;] {ok,<span class="hljs-number"><span class="hljs-number">1</span></span>} (subsman@localhost)<span class="hljs-number"><span class="hljs-number">9</span></span>&gt; receive {router_msg, M} -&gt; io:<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>(<span class="hljs-string"><span class="hljs-string">"~s\n"</span></span>,[M]) end. RJ did something ok</code> </pre><br>  It can be seen that alice can receive messages when someone to whom it is subscribed sends a message, even though the message was not sent directly to alice.  The output shows that the router identified possible targets as [alice, bob], but sent a message to one person, alice, because bob was not authorized. <br><br><h4>  Generating a simple dataset </h4><br>  We can generate a lot of relationships at random, but this is not particularly realistic.  Social networks usually have a few super popular users (some Twitter users have over 100,000 followers), and many people with just a handful of friends. <br>  To generate the data set, I used the Python module from the excellent igraph library: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> igraph g = igraph.Graph.Barabasi(<span class="hljs-number"><span class="hljs-number">1000000</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, directed=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Edges: "</span></span> + str(g.ecount()) + <span class="hljs-string"><span class="hljs-string">" Verticies: "</span></span> + str(g.vcount()) g.write_edgelist(<span class="hljs-string"><span class="hljs-string">"fakefriends.txt"</span></span>)</code> </pre><br><br><h4>  Data loading in Mnesia </h4><br>  This little module reads the fakefriends.txt file and creates a list of subscriptions. <br><pre> <code class="hljs pgsql">-module(readfriends). -export([<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>]). -<span class="hljs-type"><span class="hljs-type">record</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">subscription</span></span>, {subscriber, subscribee}). <span class="hljs-keyword"><span class="hljs-keyword">load</span></span>(Filename) -&gt; for_each_line_in_file(Filename, fun(<span class="hljs-type"><span class="hljs-type">Line</span></span>, Acc) -&gt; [<span class="hljs-keyword"><span class="hljs-keyword">As</span></span>, Bs] = string:tokens(string:strip(<span class="hljs-type"><span class="hljs-type">Line</span></span>, right, $\n), " "), {A, _} = string:to_integer(<span class="hljs-keyword"><span class="hljs-keyword">As</span></span>), {B, _} = string:to_integer(Bs), [ #<span class="hljs-keyword"><span class="hljs-keyword">subscription</span></span>{subscriber=A, subscribee=B} | Acc ] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, [<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>], []). % via: http://www.trapexit.org/Reading_Lines_from_a_File for_each_line_in_file(<span class="hljs-type"><span class="hljs-type">Name</span></span>, Proc, Mode, Accum0) -&gt; {ok, Device} = file:<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-type"><span class="hljs-type">Name</span></span>, Mode), for_each_line(Device, Proc, Accum0). for_each_line(Device, Proc, Accum) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> io:get_line(Device, "") <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> eof -&gt; file:<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>(Device), Accum; <span class="hljs-type"><span class="hljs-type">Line</span></span> -&gt; NewAccum = Proc(<span class="hljs-type"><span class="hljs-type">Line</span></span>, Accum), for_each_line(Device, Proc, NewAccum) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>  Now in the subsmanager shell you can read from a text file and add subscriptions: <br><pre> <code class="hljs swift">$ erl -name router@minifeeds4.gs2 +<span class="hljs-type"><span class="hljs-type">K</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> +<span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-number"><span class="hljs-number">128</span></span> -setcookie secretcookie -mnesia dump_log_write_threshold <span class="hljs-number"><span class="hljs-number">50000</span></span> -mnesia dc_dump_limit <span class="hljs-number"><span class="hljs-number">40</span></span> erl&gt; <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>(readfriends), <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>(subsmanager). erl&gt; subsmanager:first_run(). erl&gt; subsmanager:start_link(). erl&gt; subsmanager:add_subscriptions( readfriends:load(<span class="hljs-string"><span class="hljs-string">"fakefriends.txt"</span></span>) ).</code> </pre><br>  Tick ‚Äã‚Äãthe additional parameters - they will help to avoid the messages "** WARNING ** Mnesia is overloaded".  Mnesia documentation contains many other settings worth seeing. <br><br><h4>  1,000,000 </h4><br>  Creating a million tcp connections from one node is nontrivial.  I have a feeling that people who do it regularly, on selected small clusters to simulate a large number of connections, probably use a real tool like Tsung.  Even with the configuration from Part 1, we still run into the hard ports limit.  When creating a tcp connection, the client port is allocated from the range in / proc / sys / net / ipv4 / ip_local_port_range.  It does not matter if you specify it manually, or use the automatic port.  In Part 1, we set the range to ‚Äú1024,65535‚Äù, i.e.  we have 65535-1024 = 64511 unprivileged available ports.  Some of them will be used by other processes, but we will never pass for 64511 clients, because we will exhaust ports. <br>  The local port range is IP related, so if we make outgoing connections from different local IP addresses, we will be able to open more than 64511 outgoing connections. <br><br>  So let's create 17 new IP addresses to make 62,000 connections from each ‚Äî this will provide us with a total of 1,054,000 connections: <br><pre> <code class="hljs bash">$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> `seq 1 17`; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> sudo ifconfig eth0:<span class="hljs-variable"><span class="hljs-variable">$i</span></span> 10.0.0.<span class="hljs-variable"><span class="hljs-variable">$i</span></span> up ; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br>  If you check ifconfig now, you should see your virtual interfaces: eth0: 1, eth0: 2 ... eth0: 17, each with a different IP address. <br><br>  All that remains now is to change the floodtest from Part 1 to select a local IP.  Unfortunately, the erlang http client does not allow you to determine the source IP. <br><br>  <i>At this point, I considered another possibility: use 17 pairs of IP ‚Äî one on the server and one on the client ‚Äî each pair on their own isolated / 30 subnet.</i>  <i>I think that if I then forced the client to connect to any server IP, it would force the local address to be the second of the pair, because only one of the local IPs would actually be able to reach the server's IP on a given subnet.</i>  <i>In theory, this would mean declaring that a local source IP on the client machine would not be necessary (although the range of server IP addresses would have to be determined).</i>  <i>I don't know if it would work or not ‚Äî it sounded likely at the time.</i>  <i>In the end, I decided that it would be too perverted.</i> <br><br>  gen_tcp allows you to specify the source address, so I ended up using a raw client: <br><pre> <code class="hljs kotlin">-module(floodtest2). -compile(export_all). -define(SERVERADDR, <span class="hljs-string"><span class="hljs-string">"10.1.2.3"</span></span>). % <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> mochiweb <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> running -define(SERVERPORT, <span class="hljs-number"><span class="hljs-number">8000</span></span>). % Generate the config <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bash like so (chose some available address space): % EACH=<span class="hljs-number"><span class="hljs-number">62000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> `seq <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>`; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"{{10,0,0,</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">}, $(((</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">-1)*</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$EACH</span></span></span><span class="hljs-string">+1)), $((</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">*</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$EACH</span></span></span><span class="hljs-string">))}, "</span></span>; done run(Interval) -&gt; Config = [ {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">62000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}, <span class="hljs-number"><span class="hljs-number">62001</span></span>, <span class="hljs-number"><span class="hljs-number">124000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}, <span class="hljs-number"><span class="hljs-number">124001</span></span>, <span class="hljs-number"><span class="hljs-number">186000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}, <span class="hljs-number"><span class="hljs-number">186001</span></span>, <span class="hljs-number"><span class="hljs-number">248000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>}, <span class="hljs-number"><span class="hljs-number">248001</span></span>, <span class="hljs-number"><span class="hljs-number">310000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>}, <span class="hljs-number"><span class="hljs-number">310001</span></span>, <span class="hljs-number"><span class="hljs-number">372000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>}, <span class="hljs-number"><span class="hljs-number">372001</span></span>, <span class="hljs-number"><span class="hljs-number">434000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>}, <span class="hljs-number"><span class="hljs-number">434001</span></span>, <span class="hljs-number"><span class="hljs-number">496000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>}, <span class="hljs-number"><span class="hljs-number">496001</span></span>, <span class="hljs-number"><span class="hljs-number">558000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>}, <span class="hljs-number"><span class="hljs-number">558001</span></span>, <span class="hljs-number"><span class="hljs-number">620000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>}, <span class="hljs-number"><span class="hljs-number">620001</span></span>, <span class="hljs-number"><span class="hljs-number">682000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>}, <span class="hljs-number"><span class="hljs-number">682001</span></span>, <span class="hljs-number"><span class="hljs-number">744000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>}, <span class="hljs-number"><span class="hljs-number">744001</span></span>, <span class="hljs-number"><span class="hljs-number">806000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>}, <span class="hljs-number"><span class="hljs-number">806001</span></span>, <span class="hljs-number"><span class="hljs-number">868000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>}, <span class="hljs-number"><span class="hljs-number">868001</span></span>, <span class="hljs-number"><span class="hljs-number">930000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>}, <span class="hljs-number"><span class="hljs-number">930001</span></span>, <span class="hljs-number"><span class="hljs-number">992000</span></span>}, {{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">17</span></span>}, <span class="hljs-number"><span class="hljs-number">992001</span></span>, <span class="hljs-number"><span class="hljs-number">1054000</span></span>}], start(Config, Interval). start(Config, Interval) -&gt; Monitor = monitor(), AdjustedInterval = Interval / length(Config), [ spawn(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> start/5, [Lower, Upper, Ip, AdjustedInterval, Monitor]) || {Ip, Lower, Upper} </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;- Config ], ok. start(LowerID, UpperID, _, _, _) when LowerID == UpperID -&gt;</span></span></span><span class="hljs-function"> done; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LowerID, UpperID, LocalIP, Interval, Monitor)</span></span></span></span> -&gt; spawn(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> connect/5, [?SERVERADDR, ?SERVERPORT, LocalIP, "/test/"++LowerID, Monitor]), receive after Interval -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LowerID + </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, UpperID, LocalIP, Interval, Monitor)</span></span></span></span> end. connect(ServerAddr, ServerPort, ClientIP, Path, Monitor) -&gt; Opts = [binary, {packet, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {ip, ClientIP}, {reuseaddr, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {active, <span class="hljs-literal"><span class="hljs-literal">false</span></span>}], {ok, Sock} = gen_tcp:connect(ServerAddr, ServerPort, Opts), Monitor ! <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>, ReqL = io_lib:format(<span class="hljs-string"><span class="hljs-string">"GET ~s\r\nHost: ~s\r\n\r\n"</span></span>, [Path, ServerAddr]), Req = list_to_binary(ReqL), ok = gen_tcp:send(Sock, [Req]), do_recv(Sock, Monitor), (<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> gen_tcp:close(Sock)), ok. do_recv(Sock, Monitor)-&gt; case gen_tcp:recv(Sock, <span class="hljs-number"><span class="hljs-number">0</span></span>) of {ok, B} -&gt; Monitor ! {bytes, size(B)}, io:format(<span class="hljs-string"><span class="hljs-string">"Recvd ~s\n"</span></span>, [ binary_to_list(B)]), io:format(<span class="hljs-string"><span class="hljs-string">"Recvd ~w bytes\n"</span></span>, [size(B)]), do_recv(Sock, Monitor); {error, closed} -&gt; Monitor ! closed, closed; Other -&gt; Monitor ! closed, io:format(<span class="hljs-string"><span class="hljs-string">"Other:~w\n"</span></span>,[Other]) end. % Monitor process receives stats and reports how much <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> we received etc: monitor() -&gt; Pid = spawn(?MODULE, monitor0, [{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>}]), timer:send_interval(<span class="hljs-number"><span class="hljs-number">10000</span></span>, Pid, report), Pid. monitor0({Open, Closed, Chunks, Bytes}=S) -&gt; receive report -&gt; io:format(<span class="hljs-string"><span class="hljs-string">"{Open, Closed, Chunks, Bytes} = ~w\n"</span></span>,[S]); <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> -&gt; monitor0({Open + <span class="hljs-number"><span class="hljs-number">1</span></span>, Closed, Chunks, Bytes}); closed -&gt; monitor0({Open, Closed + <span class="hljs-number"><span class="hljs-number">1</span></span>, Chunks, Bytes}); chunk -&gt; monitor0({Open, Closed, Chunks + <span class="hljs-number"><span class="hljs-number">1</span></span>, Bytes}); {bytes, B} -&gt; monitor0({Open, Closed, Chunks, Bytes + B}) end.</code> </pre><br>  First I connected to the mochiweb application from Part 1 - it just sends one message to each client every 10 seconds. <br><pre> <code class="hljs swift">erl&gt; <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>(floodtest2), floodtest2:run(<span class="hljs-number"><span class="hljs-number">20</span></span>).</code> </pre><br><br><h4>  It quickly ate all my memory </h4><br>  It turns out that opening a large number of connections using gen_tcp kills a lot of memory.  I guess it would take ~ 36GB to make it work.  I was not interested in trying to optimize my erlang http client, and the only machine with more than 32GB of memory I could get was one of our databases, and I could not find a good excuse to turn down Last.fm while I dabble :) <br><br>  At this moment I decided to recall the tested libevent, which, has an HTTP API.  Newer versions also have the evhttp_connection_set_local_address function in the http API. <br><br>  Here is an http C client using libevent: <br><pre> <code class="hljs lua">#include &lt;sys/types.h&gt; #include &lt;sys/<span class="hljs-built_in"><span class="hljs-built_in">time</span></span>.h&gt; #include &lt;sys/queue.h&gt; #include &lt;stdlib.h&gt; #include &lt;err.h&gt; #include &lt;event.h&gt; #include &lt;evhttp.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>.h&gt; #include &lt;<span class="hljs-built_in"><span class="hljs-built_in">time</span></span>.h&gt; #include &lt;pthread.h&gt; #define BUFSIZE <span class="hljs-number"><span class="hljs-number">4096</span></span> #define NUMCONNS <span class="hljs-number"><span class="hljs-number">62000</span></span> #define SERVERADDR <span class="hljs-string"><span class="hljs-string">"10.103.1.43"</span></span> #define SERVERPORT <span class="hljs-number"><span class="hljs-number">8000</span></span> #define SLEEP_MS <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> buf[BUFSIZE]; int bytes_recvd = <span class="hljs-number"><span class="hljs-number">0</span></span>; int chunks_recvd = <span class="hljs-number"><span class="hljs-number">0</span></span>; int closed = <span class="hljs-number"><span class="hljs-number">0</span></span>; int connected = <span class="hljs-number"><span class="hljs-number">0</span></span>; // called per chunk received void chunkcb(struct evhttp_request * req, void * <span class="hljs-built_in"><span class="hljs-built_in">arg</span></span>) { int s = evbuffer_remove( req-&gt;input_buffer, &amp;buf, BUFSIZE ); //printf(<span class="hljs-string"><span class="hljs-string">"Read %d bytes: %s\n"</span></span>, s, &amp;buf); bytes_recvd += s; chunks_recvd++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(connected &gt;= NUMCONNS &amp;&amp; chunks_recvd%<span class="hljs-number"><span class="hljs-number">10000</span></span>==<span class="hljs-number"><span class="hljs-number">0</span></span>) printf(<span class="hljs-string"><span class="hljs-string">"&gt;Chunks: %d\tBytes: %d\tClosed: %d\n"</span></span>, chunks_recvd, bytes_recvd, closed); } // gets called when request completes void reqcb(struct evhttp_request * req, void * <span class="hljs-built_in"><span class="hljs-built_in">arg</span></span>) { closed++; } int main(int argc, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> **argv) { event_init(); struct evhttp *evhttp_connection; struct evhttp_request *evhttp_request; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> addr[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>[<span class="hljs-number"><span class="hljs-number">32</span></span>]; // eg: <span class="hljs-string"><span class="hljs-string">"/test/123"</span></span> int i,octet; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(octet=<span class="hljs-number"><span class="hljs-number">1</span></span>; octet&lt;=<span class="hljs-number"><span class="hljs-number">17</span></span>; octet++){ sprintf(&amp;addr, <span class="hljs-string"><span class="hljs-string">"10.224.0.%d"</span></span>, octet); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">1</span></span>;i&lt;=NUMCONNS;i++) { evhttp_connection = evhttp_connection_new(SERVERADDR, SERVERPORT); evhttp_connection_set_local_address(evhttp_connection, &amp;addr); evhttp_set_timeout(evhttp_connection, <span class="hljs-number"><span class="hljs-number">864000</span></span>); // <span class="hljs-number"><span class="hljs-number">10</span></span> day timeout evhttp_request = evhttp_request_new(reqcb, NULL); evhttp_request-&gt;chunk_cb = chunkcb; sprintf(&amp;<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>, <span class="hljs-string"><span class="hljs-string">"/test/%d"</span></span>, ++connected); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i%<span class="hljs-number"><span class="hljs-number">100</span></span>==<span class="hljs-number"><span class="hljs-number">0</span></span>) printf(<span class="hljs-string"><span class="hljs-string">"Req: %s\t-&gt;\t%s\n"</span></span>, addr, &amp;<span class="hljs-built_in"><span class="hljs-built_in">path</span></span>); evhttp_make_request( evhttp_connection, evhttp_request, EVHTTP_REQ_GET, <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> ); evhttp_connection_set_timeout(evhttp_request-&gt;evcon, <span class="hljs-number"><span class="hljs-number">864000</span></span>); event_loop( EVLOOP_NONBLOCK ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( connected % <span class="hljs-number"><span class="hljs-number">200</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> ) printf(<span class="hljs-string"><span class="hljs-string">"\nChunks: %d\tBytes: %d\tClosed: %d\n"</span></span>, chunks_recvd, bytes_recvd, closed); usleep(SLEEP_MS*<span class="hljs-number"><span class="hljs-number">1000</span></span>); } } event_dispatch(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Most parameters are hardcoded as #define, so you can edit and recompile it: <br><pre> <code class="hljs ruby">$ gcc -o httpclient httpclient.c -levent $ ./httpclient</code> </pre><br><br><h4>  It is still unable to open more than 64,500 ports. </h4><br>  To open more than 64,500 connections, you must determine the local address and local port yourself, and manage them accordingly. <br><br>  Unfortunately, the libevent HTTP API does not have an option to define a local port.  I fixed libevent to add such a function: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evhttp_connection_set_local_port</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> evhttp_connection *evcon, u_short port</span></span></span><span class="hljs-function">)</span></span>;.</code> </pre><br>  It was an amazingly pleasant experience: libevent seems to be properly written, and the documentation is pretty decent. <br><br>  With this modified libevent, I was able to add the following in the above code: <br><pre> <code class="hljs lisp">evhttp_connection_set_local_port(<span class="hljs-name"><span class="hljs-name">evhttp_connection</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>+i)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  Now multiple connections from different addresses could use the same local port number, specific to the local address.  I recompiled the client and let it work for a while to make sure that it passes the barrier. <br><br>  Netstat confirms this: <br><pre> <code class="hljs swift"># netstat -n | awk '/^tcp/ {t[$<span class="hljs-type"><span class="hljs-type">NF</span></span>]++}<span class="hljs-type"><span class="hljs-type">END</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(state <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> t){<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> state, t[state]}}' <span class="hljs-type"><span class="hljs-type">TIME_WAIT</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-type"><span class="hljs-type">ESTABLISHED</span></span> <span class="hljs-number"><span class="hljs-number">118222</span></span></code> </pre><br>  This shows how many ports are open in different states.  We finally managed to open more than 2 ^ 16 connections. <br><br>  Now we have a tool capable of opening a million http connections from a single computer.  It looks like it uses about 2 KB for each connection, plus what the kernel occupies.  It's time to test our mochiweb server. <br><br><h4>  C1024K </h4><br>  For this test I used 4 different servers.  The main difference between this test and the previous ones is a modified client written in C. <br>  Server 1 - Quad-core 2GHz CPU, 16GB of RAM <br>  ‚Ä¢ Starting subsmanager <br>  ‚Ä¢ Data Download <br>  ‚Ä¢ Starting the router <br>  Server 2 - Dual Quad-core 2.8GHz CPU, 32GB of RAM <br>  ‚Ä¢ Launch Mochiweb application <br>  Server 3 - Quad-core 2GHz CPU, 16GB of RAM <br>  ‚Ä¢ Creation of 17 IP addresses <br>  ‚Ä¢ Install libevent <br>  ‚Ä¢ Client Start: ./httpclient (100 connections per second) <br>  Server 4 - Dual-core 2GHz, 2GB RAM <br>  ‚Ä¢ Run msggen to send heaps of messages <br><br>  Memory usage during connection opening and for some time: <br><img src="https://habrastorage.org/storage/habraeffect/99/0a/990adb2b0b14d2c533856b20c5076859.png"><br>  HttpClient has a built-in 10ms delay between connections, so it took almost 3 hours to open a million connections.  I demanded a total of 25GB of memory.  This is what my server looks like through the eyes of Ganglia: <br><img src="https://habrastorage.org/storage/habraeffect/18/9e/189ee7454e725aad11900dca00e9fa9a.png"><br>  You can see that it takes about 38GB, and further paging begins.  I suspect that the difference is mainly in the consumption of the core. <br><br>  Messages were generated using 1000 processes, with an average time between messages of about 60 ms per process, giving about 16666 messages per second: <br><pre> <code class="hljs perl">erl&gt; [ spawn( fun()-&gt;msggen:start(<span class="hljs-number"><span class="hljs-number">1000000</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>+random:uniform(<span class="hljs-number"><span class="hljs-number">100</span></span>), <span class="hljs-number"><span class="hljs-number">1000000</span></span>) end) || I &lt;- lists:se<span class="hljs-string"><span class="hljs-string">q(1,1000)</span></span> ].</code> </pre><br>  Server 4 in Ganglia: <br><img src="http://habrastorage.org/storage/habraeffect/05/a6/05a6ca691576b310ff886ae946e7995b.png"><br>  About 10 MB per second - 16,666 messages. <br><br>  When I started sending messages, the load on the first server remained low.  CPU consumption on the second server increased: <br><img src="http://habrastorage.org/storage/habraeffect/9b/4e/9b4e632241b3342804a43e92156878af.png"><br>  Naturally, because  processes exit hibernate () for processing messages, memory usage increases slightly.  Having all open connections without any messages is optimal in memory usage.  Not surprisingly, some actions require more memory. <br><br>  So where is the memory flowing?  Mochiweb requires 40 GB of RAM to keep 1,000,000 active connections open.  Under load, up to 30GB of memory will be used by mochiweb, and the remaining 10 GB by the kernel.  In other words, you need about 40Kb per connection. <br><br>  During the various tests with a lot of connections, I ended up making some additional changes to sysctl.conf.  I came to this through trial and error, and I do not know which values ‚Äã‚Äãto change.  My policy was waiting for an error to check /var/log/kern.log and see what the mysterious error tells me.  Here are the settings: <br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.core.rmem_max = <span class="hljs-number"><span class="hljs-number">33554432</span></span> <span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.core.wmem_max = <span class="hljs-number"><span class="hljs-number">33554432</span></span> <span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.ipv4.tcp_rmem = <span class="hljs-number"><span class="hljs-number">4096</span></span> <span class="hljs-number"><span class="hljs-number">16384</span></span> <span class="hljs-number"><span class="hljs-number">33554432</span></span> <span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.ipv4.tcp_wmem = <span class="hljs-number"><span class="hljs-number">4096</span></span> <span class="hljs-number"><span class="hljs-number">16384</span></span> <span class="hljs-number"><span class="hljs-number">33554432</span></span> <span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.ipv4.tcp_mem = <span class="hljs-number"><span class="hljs-number">786432</span></span> <span class="hljs-number"><span class="hljs-number">1048576</span></span> <span class="hljs-number"><span class="hljs-number">26777216</span></span> <span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.ipv4.tcp_max_tw_buckets = <span class="hljs-number"><span class="hljs-number">360000</span></span> <span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.core.netdev_max_backlog = <span class="hljs-number"><span class="hljs-number">2500</span></span> vm.min_free_kbytes = <span class="hljs-number"><span class="hljs-number">65536</span></span> vm.swappiness = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.ipv4.ip_local_port_range = <span class="hljs-number"><span class="hljs-number">1024</span></span> <span class="hljs-number"><span class="hljs-number">65535</span></span></code> </pre><br>  I would like to learn more about TCP Linux settings in order to make more substantiated explanations.  Almost certainly, these settings are not optimal, but at least that was enough to reach 1,000,000 connections. <br><br><h4>  Erlang node on Libevent </h4><br>  After intervening in the HTTP API for libevent, it seemed perfectly reasonable to carry out the above test with libevent HTTPd written in C. <br><br>  I would like to leave as much code as possible on erlang, so let's do a minimum of C - just handle HTTP connections. <br><br>  Libevent has an asynchronous HTTP API, which makes the implementation of an HTTP server trivial.  I also looked for a reason to try the C interface for Erlang.  This is an HTTP server using libevent, which identifies users using a whole Id (like our mochiweb app), and also acts as an Erlang C node. <br><br>  It connects to the designated Erlang node, listens for messages like {123, &lt;&lt; ‚ÄúHello user 123‚Äù &gt;&gt;}, sends ‚ÄúHello user 123 ‚Ä≥ for user 123, if it is connected.  Messages for users who are not connected are discarded, as before. <br><pre> <code class="hljs lua">#include &lt;sys/types.h&gt; #include &lt;sys/<span class="hljs-built_in"><span class="hljs-built_in">time</span></span>.h&gt; #include &lt;sys/queue.h&gt; #include &lt;stdlib.h&gt; #include &lt;err.h&gt; #include &lt;event.h&gt; #include &lt;evhttp.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>.h&gt; #include <span class="hljs-string"><span class="hljs-string">"erl_interface.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"ei.h"</span></span> #include &lt;pthread.h&gt; #define BUFSIZE <span class="hljs-number"><span class="hljs-number">1024</span></span> #define MAXUSERS (<span class="hljs-number"><span class="hljs-number">17</span></span>*<span class="hljs-number"><span class="hljs-number">65536</span></span>) // C1024K // List of current http requests by uid: struct evhttp_request * clients[MAXUSERS+<span class="hljs-number"><span class="hljs-number">1</span></span>]; // Memory to store uids passed to the cleanup callback: int slots[MAXUSERS+<span class="hljs-number"><span class="hljs-number">1</span></span>]; // called when user disconnects void cleanup(struct evhttp_connection *evcon, void *<span class="hljs-built_in"><span class="hljs-built_in">arg</span></span>) { int *uidp = (int *) <span class="hljs-built_in"><span class="hljs-built_in">arg</span></span>; fprintf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"disconnected uid %d\n"</span></span>, *uidp); clients[*uidp] = NULL; } // handles http connections, sets them up <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> chunked transfer, // extracts the user id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> registers <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the global connection <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>, // also sends a welcome chunk. void request_handler(struct evhttp_request *req, void *<span class="hljs-built_in"><span class="hljs-built_in">arg</span></span>) { struct evbuffer *buf; buf = evbuffer_new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buf == NULL){ err(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"failed to create response buffer"</span></span>); } evhttp_add_header(req-&gt;output_headers, <span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>, <span class="hljs-string"><span class="hljs-string">"text/html; charset=utf-8"</span></span>); int uid = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strncmp(evhttp_request_uri(req), <span class="hljs-string"><span class="hljs-string">"/test/"</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>){ uid = atoi( <span class="hljs-number"><span class="hljs-number">6</span></span>+evhttp_request_uri(req) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(uid &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ evbuffer_add_printf(buf, <span class="hljs-string"><span class="hljs-string">"User id not found, try /test/123 instead"</span></span>); evhttp_send_reply(req, HTTP_NOTFOUND, <span class="hljs-string"><span class="hljs-string">"Not Found"</span></span>, buf); evbuffer_free(buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(uid &gt; MAXUSERS){ evbuffer_add_printf(buf, <span class="hljs-string"><span class="hljs-string">"Max uid allowed is %d"</span></span>, MAXUSERS); evhttp_send_reply(req, HTTP_SERVUNAVAIL, <span class="hljs-string"><span class="hljs-string">"We ran out of numbers"</span></span>, buf); evbuffer_free(buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } evhttp_send_reply_start(req, HTTP_OK, <span class="hljs-string"><span class="hljs-string">"OK"</span></span>); // Send welcome chunk: evbuffer_add_printf(buf, <span class="hljs-string"><span class="hljs-string">"Welcome, Url: '%s' Id: %d\n"</span></span>, evhttp_request_uri(req), uid); evhttp_send_reply_chunk(req, buf); evbuffer_free(buf); // put reference into global uid-&gt;connection <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>: clients[uid] = req; // set <span class="hljs-built_in"><span class="hljs-built_in">close</span></span> callback evhttp_connection_set_closecb( req-&gt;evcon, cleanup, &amp;slots[uid] ); } // runs <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a thread ‚Äì the erlang c-node stuff // expects msgs like {uid, msg} <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sends aa <span class="hljs-string"><span class="hljs-string">'msg'</span></span> chunk to uid <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> connected void cnode_run() { int fd; /* fd to Erlang node */ int got; /* Result of receive */ unsigned <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> buf[BUFSIZE]; /* Buffer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> incoming message */ ErlMessage emsg; /* Incoming message */ ETERM *uid, *msg; erl_init(NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (erl_connect_init(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"secretcookie"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) erl_err_quit(<span class="hljs-string"><span class="hljs-string">"erl_connect_init"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((fd = erl_connect(<span class="hljs-string"><span class="hljs-string">"httpdmaster@localhost"</span></span>)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) erl_err_quit(<span class="hljs-string"><span class="hljs-string">"erl_connect"</span></span>); fprintf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Connected to httpdmaster@localhost\n\r"</span></span>); struct evbuffer *evbuf; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { got = erl_receive_msg(fd, buf, BUFSIZE, &amp;emsg); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (got == ERL_TICK) { continue; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (got == ERL_ERROR) { fprintf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"ERL_ERROR from erl_receive_msg.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emsg.<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> == ERL_REG_SEND) { // get uid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> body data from eg: {<span class="hljs-number"><span class="hljs-number">123</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>&gt;&gt;} uid = erl_element(<span class="hljs-number"><span class="hljs-number">1</span></span>, emsg.msg); msg = erl_element(<span class="hljs-number"><span class="hljs-number">2</span></span>, emsg.msg); int userid = ERL_INT_VALUE(uid); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *body = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *) ERL_BIN_PTR(msg); int body_len = ERL_BIN_SIZE(msg); // Is this userid connected? <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(clients[userid]){ fprintf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Sending %d bytes to uid %d\n"</span></span>, body_len, userid); evbuf = evbuffer_new(); evbuffer_add(evbuf, (const void*)body, (size_t) body_len); evhttp_send_reply_chunk(clients[userid], evbuf); evbuffer_free(evbuf); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ fprintf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Discarding %d bytes to uid %d ‚Äì user not connected\n"</span></span>, body_len, userid); // noop } erl_free_term(emsg.msg); erl_free_term(uid); erl_free_term(msg); } } } // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we got here, erlang connection died. // this thread is supposed to run forever // TODO ‚Äì gracefully handle failure / reconnect / etc pthread_exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); } int main(int argc, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> **argv) { // Launch the thread that runs the cnode: pthread_attr_t tattr; pthread_t helper; int <span class="hljs-built_in"><span class="hljs-built_in">status</span></span>; pthread_create(&amp;helper, NULL, cnode_run, NULL); int i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;=MAXUSERS;i++) slots[i]=i; // Launch libevent httpd: struct evhttp *httpd; event_init(); httpd = evhttp_start(<span class="hljs-string"><span class="hljs-string">"0.0.0.0"</span></span>, <span class="hljs-number"><span class="hljs-number">8000</span></span>); evhttp_set_gencb(httpd, request_handler, NULL); event_dispatch(); // Not reached, event_dispatch() shouldn<span class="hljs-string"><span class="hljs-string">'t return evhttp_free(httpd); return 0; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The maximum number of users is set using #define, port 8000 is listened on and users are expected. </font><font style="vertical-align: inherit;">The name of the Erlang cookie node is also hardcoded. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start the node to which the server will connect:</font></font><br><pre> <code class="hljs ruby">$ erl -setcookie secretcookie -sname httpdmaster@localhost</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run C-node: </font></font><br><pre> <code class="hljs ruby">$ gcc -o httpdcnode httpdcnode.c -lerl_interface -lei -levent $ ./httpdcnode</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Check that the node is visible: </font></font><br><pre> <code class="hljs scala">erl&gt; nodes(hidden). [c1<span class="hljs-meta"><span class="hljs-meta">@localhost</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open </font></font><a href="http://localhost/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">localhost</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 8000 / test / 123 </font><font style="vertical-align: inherit;">in your browser </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">You should see the welcome message. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, send a message to the C node:</font></font><br><pre> <code class="hljs ruby">erl&gt; {any, c1@localhost} ! {<span class="hljs-number"><span class="hljs-number">123</span></span>, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"Hello Libevent World"</span></span><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>}.</code> </pre><br>  ,     Pid ‚Äî   {procname, node}.   ¬´any¬ª,   ,   C-. <br><br>        Erlang,     libevent   ,     Erlang. <br><br>    ,   1 000 000   httpdcnode ,     ,   .  ,      10   . <br><br>      2GB: <br><img src="http://habrastorage.org/storage/habraeffect/e6/68/e668ac6be86de46482d9a6d98af80b45.png"><br><br> <b> 2   .</b> <br><br>  : <br><pre> <code class="hljs pgsql">Mem: <span class="hljs-number"><span class="hljs-number">32968672</span></span>k total, <span class="hljs-number"><span class="hljs-number">9636488</span></span>k used, <span class="hljs-number"><span class="hljs-number">23332184</span></span>k free, <span class="hljs-number"><span class="hljs-number">180</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span></code> </pre><br>  kernel/ TCP    8  ,   ,        . <br><br>  libevent-cnode       .        ,     ‚Äúrace conditions‚Äù,    ,     . <br><br>   ,   Erlang    ,  C + libevent    .   C        C-,   Erlang     API.         . <br><br><h4>   </h4><br><br>       ,    ,       Last.fm.     40      ‚Äî      ,  40GB       . 10GB  . </div><p>Source: <a href="https://habr.com/ru/post/111600/">https://habr.com/ru/post/111600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111593/index.html">New version of the robot LittleDog from DARPA</a></li>
<li><a href="../111595/index.html">FIXber - software testing services market</a></li>
<li><a href="../111596/index.html">Facebook Hacker Cup</a></li>
<li><a href="../111597/index.html">How to choose customers</a></li>
<li><a href="../111598/index.html">MySpace will fire more than half of its employees.</a></li>
<li><a href="../111601/index.html">LibreOffice will become the default office in Ubuntu 11.04</a></li>
<li><a href="../111602/index.html">Idioms Pimpl and Fast Pimpl - a pointer to the implementation</a></li>
<li><a href="../111603/index.html">Habraindex for articles on programming for Android</a></li>
<li><a href="../111606/index.html">Using crowdsourcing in finding a good topic for a diploma</a></li>
<li><a href="../111608/index.html">Creating a series of pictures with images of their sequence numbers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>