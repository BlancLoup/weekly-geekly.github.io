<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Removing the image from the OV7670 camera to a VGA monitor using FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 Having read many fascinating articles about interesting developments under FPGA, such as Tetris , radio transmitter and others , I also set...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Removing the image from the OV7670 camera to a VGA monitor using FPGA</h1><div class="post__text post__text-html js-mediator-article"><h4>  Foreword </h4><br>  Having read many fascinating articles about interesting developments under FPGA, such as <a href="https://habrahabr.ru/post/247535/">Tetris</a> , <a href="https://habrahabr.ru/post/178903/">radio transmitter</a> and <a href="https://habrahabr.ru/hub/fpga/">others</a> , I also set about trying to do something for the soul.  For this purpose, I purchased the <a href="http://www.voti.nl/docs/OV7670.pdf">OV7670</a> camera and the <a href="">DE-1</a> debug board from Terasic with a Cyclone II chip from Altera.  The task set the following: display the image from the camera on the VGA monitor.  In order to justify the use of FPGA, I am going to do it at the maximum speed for the camera.  I should note that knowledge in the field of electronics will help to understand this work more easily: knowledge of VGA and I2C interfaces, an idea of ‚Äã‚ÄãSDRAM memory, etc. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  This article is not a study, it is rather a report on the work done, in which I tried to show the main idea and the most interesting and difficult places in my opinion.  In terms of complexity, this project follows ‚Äúto blink an LED,‚Äù but it has a huge potential for expansion.  The project intentionally does not use ready IP-cores and standard interfaces, since the project was originally planned as a handwritten one.  It also helps to win a little in terms of resources and speed.  I hope this article will be of interest to readers, and the desire to see yourself on the screen through a "self-made camera" will lead to the study of FPGA. <br><br><div class="spoiler">  <b class="spoiler_title">Disclamer</b> <div class="spoiler_text">  In some places of the project, the architecture and syntax of the code may not be optimal.  This is due to the fact that I was engaged in the implementation of the project in my spare time, and between approaches there were sometimes breaks of several months: old thoughts were forgotten, but new ones appeared.  So, for example, the central automat was greatly simplified: from the original monster only the name ‚Äúglobal‚Äù remained.  Before publication, I refactored the code, but if there are any flaws, please indicate them in the comments. <br></div></div><br><h4>  Problems and solutions </h4><br>  In order to understand what awaits us, take a look at the hardware and evaluate what problems we will have to face.  Camera OV7670.  The camera is capable of producing an image with a resolution of 640x480 pixels with a frequency of 30 frames per second in RGB565 format.  To operate the camera, it is necessary to feed a 24 MHz clock on it.  The camera transmits data to the user on an 8-bit bus, as well as synchronization gates VSYNC and HSYNC.  Timing diagrams of the camera are shown in Figure 1. <br><br><img src="https://habrastorage.org/files/5f3/0bb/cb0/5f30bbcb0ba141e59c6a847cf71900ee.png"><br>  <i>Pic1</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Color information is transmitted in 2 cycles per byte.  Packing data in bytes is shown in Figure 2. <br><br><img src="https://habrastorage.org/files/aec/de9/373/aecde93736244317a0003b1b1114bc20.png"><br>  <i>Pic2</i> <br><br>  VGA monitor.  VGA is an analog signal, so it will not work to provide digital data to its input.  But on board the DE-1 there are 4-bit DACs, and we will use them to convert a digital signal into an analog one.  VGA with a resolution of 640x480 has a refresh rate of 60 frames per second.  It is necessary to set data on the DAC with a frequency of 25.175 MHz, as well as to form synchronization gates VSYNC and HSYNC.  Timing for VGA can be found <a href="http://tinyvga.com/vga-timing">here</a> . <br><br>  It becomes clear that the frequency of data from the camera and the frequency of data output to the monitor are different, which eliminates the possibility of direct connection.  The way out of this situation is to use the <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D0%25B4%25D1%2580%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B9_%25D0%25B1%25D1%2583%25D1%2584%25D0%25B5%25D1%2580">frame buffer</a> .  We will allocate two equal areas in memory: the current frame from the camera will be recorded into one, and the previous one will be extracted from the second, after the end of the recorded frame, the buffers are swapped.  To store one frame, 640 * 480 * 16 = 4.915 * 10 ^ 6 bits are required, which is much more than on-chip memory available onboard the Cyclone II.  Therefore, we will use <a href="http://www.datasheet4u.com/datasheet/A/2/V/A2V64S40CTP_ZentelElectronics.pdf.html">SDRAM memory</a> located in a separate chip on the DE-1 board for storing frames.  This will allow us to organize a frame buffer for solving a technical problem and provide an opportunity to practice writing the SDRAM controller. <br><br>  The next problem arises from the solution of the previous one.  When using SDRAM memory in our project, two important points need to be taken into account: first, the memory works at a high frequency of 120 MHz for our design and we have a new problem - the transfer of data from the clowk domain of the camera to the clown domain SDRAM;  secondly, in order to achieve maximum performance, writing in SDRAM follows whole transactions called burst.  To solve these problems, the FIFO, organized in on-chip FPGA memory, is the best approach.  The basic idea is this: the camera at a low frequency fills up the FIFO, after which the SDRAM controller reads the data at a high frequency and immediately writes it to the memory in one transaction. <br><br>  The output of data on the monitor is organized the same principle.  Data from SDRAM is written to the FIFO, and then retrieved at 25 MHz for submission to the DAC.  After emptying the FIFO, the operation is repeated. <br><br>  The smallest problem is that out-of-the-box camera settings do not suit us, and we need to change them.  The most important point, the camera provides data in the format YUV422, and you need to change it to RGB444.  To access the internal registers of the OV7670, it will be necessary to describe the I2C transmitter module. <br><br>  Now we can say which modules we will have to implement, and what tasks they will solve. <br><br><ul><li>  cam_wrp - the module receives data from the camera and writes it to the input FIFO; </li><li>  hvsync - the module generates gates for VGA, receives data from SDRAM, writes them to the input FIFO and sends it to the DAC by the gate; </li><li>  sdram_cntr - SDRAM controller; </li><li>  FSM_global - automatic control; </li><li>  camera_configure - camera configuration and control module. </li></ul><br>  Figure 3 shows the functional design diagram. <br><br><img src="https://habrastorage.org/files/6c9/4d6/f1d/6c94d6f1d0c7493ea4e3b82862d7a639.png"><br>  <i>Pic.3</i> <br><br>  Let us consider in more detail each of the modules. <br><br><h4>  Cam_wrp module </h4><br>  One of the simplest modules.  His task at the time of the action of the hsync strobe camera to take two bytes in succession, form one two-byte word from them and record it in the FIFO.  The signal from the SDRAM controller to transfer to him the entire contents of the FIFO. <br><br>  To ‚Äúpack‚Äù 2 consecutive bytes into one word, we use the wr_fifo signal, which we invert by shred (divide the frequency by 2).  When this signal is in logical 1, we write data in the low byte, when in logical 0 it is written in the high byte.  We also use wr_fifo as a signal to write to the FIFO.  In addition to the data bus from the FIFO, a bus is derived on which the number of data written to it is set.  This bus is connected to the control unit.  Figure 4 shows the timing diagram of ‚Äúpacking‚Äù bytes into double-byte words. <br><br><img src="https://habrastorage.org/files/79e/bdb/340/79ebdb340df24048bf38a9c2d3314902.png"><br>  <i>Pic.4</i> <br><br><h4>  FSM_global module </h4><br>  The module has a very pathetic name, in fact it is a simple automaton of only 4 states, but it performs a very important function.  By monitoring the readiness signal of the sd_ready SDRAM controller, the fullness of the input and output FIFO, the machine issues the SDRAM commands to the controller to pick up data from the input or write to the output FIFO.  Reading and writing occur a little earlier than the FIFO is full or empty.  It is necessary to choose the fill level of the FIFO correctly so that operations with the FIFO at high frequency do not end earlier than at low frequency - this is guaranteed to lead to errors.  In the part devoted to the SDRAM controller, I will give a picture illustrating this feature. <br><br><h4>  SDRAM_contr module </h4><br>  SDRAM controllers have already been written a lot; I didn‚Äôt want to reinvent the bike once again, so I decided to reinvent the crawler bike.  Namely, the SDRAM controller, sharpened for this particular project.  This will simplify management and slightly speed up the work.  The transition graph of the automaton for a full-fledged SDRAM controller is presented in Figure 5. <br><br><img src="https://habrastorage.org/files/320/7f0/fad/3207f0fad0b64339bb6f25819737fcd2.png"><br>  <i>Pic.5</i> <br><br>  Let's think that we can exclude from it. <br><br>  First, we will not refresh the data.  This assumption is definitely not suitable for a general purpose controller, but in our case we will use the same memory area, constantly referring to it.  Data will not have time to degrade. <br><br>  Secondly, since we will always write and read data with a vector of length 640, we can refuse to work with individual numbers; we will only write burst. <br><br>  Third, do not think about the address, we will simply increment it after each burst and zero it at the end of each frame.  The resulting transition graph is shown in Figure 6. <br><br><img src="https://habrastorage.org/files/a51/847/091/a518470917ee4033912e3274eaac20ef.png"><br>  <i>Pic.6</i> <br><br>  The controller starts in the idle state.  Before starting normal operation, it is necessary to initialize the memory chip (state of the s0_MRS machine), after which the mode_flag flag is set, the controller goes into the standby state, and we can write and read data.  To do this, the fsm_global module receives a command to start reading or writing, open the required column in the selected bank (state s0_ACT), and then read or write should occur (state s0_WRIT, s0_READ).  Unfortunately, doing away with one burst will not come out, the depth of the column in our memory chip is only 256 16-bit words, and we need to write a vector of length 640. We will have to write for 3 burst, two by 256 and one by 128. the lines remain empty, that is, we use resources rationally, but since we don‚Äôt have a shortage of them, I decided not to complicate the machine and accept this. <br><br>  As for addresses, they are allocated different registers for reading and writing, which are incremented before each bust.  Thus, to write a vector with a length of 640, we pass 640 * 4 = 1440 addresses.  The vertical sync strobe of the camera or the VGA addresses are reset for writing and reading, respectively. <br><br>  We use double buffering: we write to one buffer from another.  To simplify one buffer I placed in the bank 0, and the second in the bank 1 of the SDRAM chip.  Banks for reading and writing are reversed after the end of the reception frame from the camera.  Figure 7 shows the time diagrams of a single vector recording.  It can be seen that the entry is divided into 3 parts: after each address is incremented, the entire transfer occurs under the cur_wr gate.  To read the chart is similar. <br><br><img src="https://habrastorage.org/files/ce7/80e/7dd/ce780e7dd7ac4eb5bd5be89a6fbb3da9.png"><br>  <i>Fig.7</i> <br><br>  Figure 8 shows how the data from the camera is written to the SDRAM compared to the fill time of the FIFO.  Please note that we are starting to write in SDRAM, without waiting for the final filling of the FIFO. <br><br><img src="https://habrastorage.org/files/601/756/0bc/6017560bcac54046a8fb7667dfefb15a.png"><br>  <i>Fig.8</i> <br><br><h4>  Hvsync module </h4><br>  This is one of two modules in this project, not written by me.  Once I was implementing a similar module, I was not interested in repeating, so I used an excellent module written by the authors of the site <a href="http://marsohod.org/">marsohod.org</a> .  There is nothing superfluous in this module, it is parameterized and can be easily configured for any screen resolution.  I practically did not change it, I added only the FIFO connected to the SDRAM controller, and the binding signals for it.  With the FIFO, the bus is displayed, on which the amount of data recorded in it is set, this bus is connected to the control unit by analogy with the input FIFO.  FIFO output is connected to the wire that go to the DAC. <br><br><h4>  Module camera_configure </h4><br>  Initially allowing myself the liberty of a home project and inattentively reading the documentation, I wanted to launch the camera with the ‚Äúdefault‚Äù settings, but it turned out that without setting the OV7670 transmits information in YUV422 format, not RGB565.  I didn‚Äôt want to rewrite anything, and I decided that I had to do everything according to my mind and properly initialize the camera.  Since the camera is controlled by I2C, an idea to use NIOS came to mind.  NIOS with an I2C crust with opencore could not be started with a half-kick, but I stumbled upon the Verilog <a href="https://github.com/westonb/OV7670-Verilog">module initialization</a> and it was for OV7670.  He so easily integrated into the code that he didn‚Äôt have to change almost anything, he changed only one line: instead of RGB565 he activated the RGB444 mode, since there are exactly 4 bit DACs on the board.  Figure 9 shows the time diagram of the software reset of the camera by recording the number 0x80 at the address 0x12. <br><br><img src="https://habrastorage.org/files/537/1a5/058/5371a50586364d24a3e95cc848e3879d.png"><br>  <i>Fig.9</i> <br><br><h4>  Demonstration of the result </h4><br>  After all the modules are written, we connect them together in a top module, assemble them into Quartus, and can be tested.  The video shows the result. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/9qrgI4VpW-4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  I had chosen a not very good time for shooting - the sunset and a very bright sun - the camera does not adequately respond to too bright sun glare.  It is seen that moving objects are displayed correctly, there is no jerking and no loops.  This is exactly what I achieved using FPGA, which allows you to process all 30 (and more camera capabilities) fps with a little blood.  If we talk about image clarity, I can say that the text from A4 sheet is read without complications, unfortunately, the photo from the monitor is worse than in reality.  Figure 10 shows a fragment of A4 paper with camera documentation. <br><br><img src="https://habrastorage.org/files/9bb/149/c6a/9bb149c6aeef490c96cffcaa8a459ac3.jpg">  " <br><br>  On the presented videos and photos some disadvantages are visible: the first with sharpness and the second with color. <br>  I associate the problem with the sharpness on the video with the imperfectly exposed focus.  The focus is adjusted on the camera mechanically, by screwing in or twisting the lens thread.  The thread is plastic and has a fairly large gap, even the sharpness may deteriorate from a slight shaking. <br><br>  The problem with the excessive green yellowness of the white sheet, it seems to me, is related to the problem with the white balance: the shooting was done indoors with lighting that was far from natural.  Also the camera settings may affect the chroma situation.  I practically did not experiment, take off, I used it as a magic number. <br><br><h4>  Conclusion </h4><br>  The task was to output the image from the OV7670 camera to a VGA monitor in real time, it has been solved.  If you compare the result obtained in this project with the result obtained by other developers using microcontrollers or Arduino, you can see that they are inferior in the display speed of moving objects.  The complexity of this project does not exceed the same, performed using a microcontroller.  A person with basic knowledge in the design of an FPGA can implement it in a few days.  The project has a great potential for expansion, it is possible to filter the resulting image, object recognition and so on.  The design on the Cyclone II chip occupies the following resources: LE - 745 (4%), memory bits - 32768 (14%), PLL - 1 (25%), Embedded Multiplier - 0 (0%) - thus, developers still have enough resources to implement their ideas. <br><br><h4>  Afterword </h4><br>  What's next?  In the future, I plan to expand the project by adding image processing in real time using <a href="https://habrahabr.ru/post/142818/">matrix filters</a> . <br><br>  I express my thanks to <a href="https://habrahabr.ru/users/ishevchuk/" class="user_link">ishevchuk</a> for the advice on the content and design of the article and to my girlfriend for the spelling check. <br><br><div class="spoiler">  <b class="spoiler_title">Bad doubles</b> <div class="spoiler_text">  When you first turn on the screen appeared mysterious patterns.  Long thought it could be that.  As a result, it turned out that the focus was not placed in the chamber.  After I twisted the lens on the lens, everything fell into place. <br><br><img src="https://habrastorage.org/files/1d0/492/9bb/1d04929bb64d48b8905c9be70b31cb8e.jpg">  "alt =" image "/&gt; <br><br>  The second time the camera was turned on, it was incorrectly initialized, which led to an unexpected selfie. <br><br><img src="https://habrastorage.org/files/13f/bd0/eef/13fbd0eef8f147f79c1be679a69c8e21.PNG">  " <br></div></div><br>  Download the archive with the source code <a href="https://yadi.sk/d/BYxgbiZOrhqwU">here (Ya.Disk)</a> . </div><p>Source: <a href="https://habr.com/ru/post/283488/">https://habr.com/ru/post/283488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../283476/index.html">50 sociopaths in a live-action role-playing game: Gibson's Neuronomicon and its mechanics</a></li>
<li><a href="../283478/index.html">Communication 2016: what's interesting?</a></li>
<li><a href="../283480/index.html">NFC - to the masses. New technologies at Eurovision, music and sports venues</a></li>
<li><a href="../283482/index.html">Once again about how not to make a ‚Äúsieve‚Äù from your network</a></li>
<li><a href="../283484/index.html">Errors when connecting payments on the Internet</a></li>
<li><a href="../283490/index.html">Vulkan API (glNext) from Khronos Group</a></li>
<li><a href="../283492/index.html">Let's collect a moss-mite under a microscope or focus-stacking photos from the console</a></li>
<li><a href="../283494/index.html">Developing a simple pedometer application on ReactNative</a></li>
<li><a href="../283496/index.html">In the Opera browser appeared power saving mode</a></li>
<li><a href="../283498/index.html">Announcement of the track Windows conference DevCon 2016</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>