<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quick interactive layout of the hall on canvas</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We develop a library for displaying large interactive hall schemes on the canvas without frameworks and make it work well in ie and mobile devices. Al...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quick interactive layout of the hall on canvas</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ky/2y/f4/ky2yf4arjtfuilhixft4b3auuy8.png"></div><br><p>  We develop a library for displaying large interactive hall schemes on the canvas without frameworks and make it work well in ie and mobile devices.  Along the way, we deal with the features of the canvas. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Why typeScript?</b> <div class="spoiler_text">  First, I wanted to try.  And secondly, the full support of the PLO. <br>  Yes, and strict typing, in my opinion, can reduce the number of bugs.  In general, I am programming in PHP, so comments on the code are welcome. <br></div></div><br><h2>  Formulation of the problem </h2><br><p>  First of all let's form the requirements: <br></p><br><ul><li>  Productivity: 5-10 thousand objects should not confuse our library, even in ie </li><li>  You can hover / click on each object and the object should be able to process it. </li><li>  The circuit should scale and move. </li><li>  Adaptability to the size of the container </li><li>  Support for touch devices </li></ul><br><h2>  Introduction </h2><br>  We will not pull and immediately see the <a href="http://nikitchenko.ru/scheme-designer/examples/">demo</a> , so it will be clearer what it is about. <br><br>  In the article I will insert only small sections of code, the rest can be viewed at <br>  <a href="https://github.com/NikitchenkoSergey/scheme-designer">Github</a> <br><p>  We recall that the canvas is essentially a picture with api, so the handling of hovers and clicks on our conscience: you need to read the coordinates yourself, taking into account the scale and scroll, look for objects by their coordinates.  But at the same time, we completely control the performance and draw only what we need. <br><br>  Constantly iterate through all the objects in the scheme and check their coordinates is not optimal.  Although this will happen quickly enough, we will still do better: we will build search trees, breaking the map into sectors. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition to search optimization, we will try to follow the following rules for working with canvas: <br></p><br><h4>  requestAnimationFrame </h4><br><p>  The browser has its own rendering timer, and using the <a href="https://developer.mozilla.org/ru/docs/DOM/window.requestAnimationFrame">requestAnimationFrame</a> method, you can ask the browser to render our frame along with the rest of the animations - this will avoid double browser operation.  To cancel the animation, there is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelAnimationFrame">cancelAnimationFrame</a> .  <a href="">Polyphyl</a> . </p><br><h4>  Caching complex objects </h4><br><p>  It is not necessary to constantly redraw complex objects if they do not change.  You can draw them in advance on a hidden canvas, and then take them from there. </p><br><h4>  Draw only visible objects </h4><br><p>  Even if an element goes beyond the bounds of the canvas, time is still spent on its drawing. <br>  This is especially noticeable in the ie, he honestly draws everything, while in chrome it is optimized, and much less time is spent on it. <br></p><br><h4>  Redraw only changed objects </h4><br><p>  It makes no sense to redraw the entire scene, if one element has changed. </p><br><h4>  Less text </h4><br><p>  Drawing text for canvas is a hard task, so you need to avoid a lot of <br>  objects with text.  Even if you want to put a number on each place - it is better to limit the display of this number by scale: for example, show the number only at a certain approximation, when this information will be useful. </p><br><h2>  Architecture </h2><br><p><img src="https://habrastorage.org/webt/ht/d3/u8/htd3u8n2xggybhjcyrfrfhi0zf8.png"><br></p><br><p>  <strong>Scheme</strong> is the main class. <br>  <strong>View</strong> - the class knows the canvas on which to draw, and its parameters (we will have two). <br>  <strong>SchemeObject</strong> - the class of the schema object knows its location, how to draw itself and how to handle events.  May contain additional parameters, for example, price. <br>  <strong>EventManager</strong> - class handling and create events.  Upon receiving an event, passes it to the desired class. <br>  <strong>ScrollManager</strong> is the class responsible for scrolling the schema. <br>  <strong>ZoomManager</strong> - the class responsible for the zoom scheme. <br>  <strong>StorageManager</strong> is a class that is responsible for storing schema objects, creating a search tree and searching for objects by coordinates. <br>  <strong>Polyfill</strong> - class with a set of polylifilov for cross-browser compatibility. <br>  <strong>Tools</strong> - a class with various functions, such as defining the intersection of squares. <br>  <strong>ImageStorage</strong> - a class for creating images for storing images <br></p><br><h2>  Configuration </h2><br><p>  I really want the scheme to have flexible settings.  To do this, create such a simple method for configuring an object: </p><br><pre><code class="hljs cs"><span class="hljs-comment"><span class="hljs-comment">/** * Object configurator * @param obj * @param params */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj: any, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params">: any</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> paramName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>[paramName]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> setter = <span class="hljs-string"><span class="hljs-string">'set'</span></span> + Tools.capitalizeFirstLetter(paramName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> obj[setter] === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { obj[setter].apply(obj, [<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>]); } } }</code> </pre> <br><p>  Now you can configure objects like this: </p><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Tools</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.configure</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">params</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.options</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">Tools</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.configure</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scrollManager</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">params</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scroll</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">Tools</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.configure</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.zoomManager</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">params</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.zoom</span></span>);</code> </pre><br><p>  This is convenient: you only need to create setters for objects that can not only set a value in a property, but also pass on or change the value if necessary. </p><br><h2>  Storage and display of objects </h2><br><p>  First of all, you need to learn how to simply place objects on the scheme.  But for this you need to understand what objects are now in sight.  We agreed not to constantly iterate over all objects, but to build a search tree. </p><br><p>  To build a tree, it is necessary to divide the layout of the hall into parts, write one part into the left tree node, and the other into the right one.  The node key will be a rectangle bounding the circuit area.  Since  an object represents a plane, not a point, it can be in several nodes of the tree at once - not a big deal.  Question: how to break the circuit?  To achieve maximum profit, the tree should be balanced, i.e.  the number of elements in the nodes should be about the same.  In our case, you can not particularly bother, because  usually the objects in the scheme are almost uniform.  Just halve alternately by width and height.  Here is a split for a tree of depth 8: </p><br><img src="https://habrastorage.org/webt/d0/sj/eu/d0sjeuqlou3x-9_wqhv4vu744-i.png"><br><br><h3>  Code </h3><br>  <strong>TreeNode</strong> - the tree node class knows its parent, its children, and the coordinates of the square of the objects it contains: <br><br><div class="spoiler">  <b class="spoiler_title">TreeNode</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"> <span class="hljs-comment"><span class="hljs-comment">/** * Tree node */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Parent node */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> parent: TreeNode; <span class="hljs-comment"><span class="hljs-comment">/** * Children nodes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> children: TreeNode[] = []; <span class="hljs-comment"><span class="hljs-comment">/** * Bounding rect of node */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> boundingRect: BoundingRect; <span class="hljs-comment"><span class="hljs-comment">/** * Objects in node */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> objects: SchemeObject[] = []; <span class="hljs-comment"><span class="hljs-comment">/** * Depth */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> depth: number; <span class="hljs-comment"><span class="hljs-comment">/** * Constructor * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> parent * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> boundingRect * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> objects * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> depth */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(parent: <span class="hljs-literal"><span class="hljs-literal">null</span></span> | TreeNode, boundingRect: BoundingRect, objects: SchemeObject[], depth: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent = parent; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.boundingRect = boundingRect; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.objects = objects; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.depth = depth; } <span class="hljs-comment"><span class="hljs-comment">/** * Add child * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> child */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> addChild(child: TreeNode): void { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.children.push(child); } <span class="hljs-comment"><span class="hljs-comment">/** * Get objects * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@returns</span></span></span><span class="hljs-comment"> {SchemeObject[]} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> getObjects(): SchemeObject[] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.objects; } <span class="hljs-comment"><span class="hljs-comment">/** * Get children * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@returns</span></span></span><span class="hljs-comment"> {TreeNode[]} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> getChildren(): TreeNode[] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.children; } <span class="hljs-comment"><span class="hljs-comment">/** * Is last node * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@returns</span></span></span><span class="hljs-comment"> {boolean} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> isLastNode(): boolean { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.objects.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/** * Get last children * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@returns</span></span></span><span class="hljs-comment"> {TreeNode[]} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> getLastChildren(): TreeNode[] { let result: TreeNode[] = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let childNode of <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.children) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childNode.isLastNode()) { result.push(childNode); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { let lastChildNodeChildren = childNode.getLastChildren(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let lastChildNodeChild of lastChildNodeChildren) { result.push(lastChildNodeChild); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-comment"><span class="hljs-comment">/** * Get child by coordinates * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> coordinates * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@returns</span></span></span><span class="hljs-comment"> {TreeNode|null} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> getChildByCoordinates(coordinates: Coordinates): TreeNode | <span class="hljs-literal"><span class="hljs-literal">null</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let childNode of <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.children) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tools.pointInRect(coordinates, childNode.getBoundingRect())) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> childNode; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/** * Get child by bounding rect * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> boundingRect * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@returns</span></span></span><span class="hljs-comment"> {TreeNode[]} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> getChildrenByBoundingRect(boundingRect: BoundingRect): TreeNode[] { let result: TreeNode[] = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let childNode of <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.children) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tools.rectIntersectRect(childNode.getBoundingRect(), boundingRect)) { result.push(childNode); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-comment"><span class="hljs-comment">/** * Remove objects */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> removeObjects(): void { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.objects = []; } <span class="hljs-comment"><span class="hljs-comment">/** * Get bounding rect * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@returns</span></span></span><span class="hljs-comment"> {BoundingRect} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> getBoundingRect(): BoundingRect { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.boundingRect; } <span class="hljs-comment"><span class="hljs-comment">/** * Get depth * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@returns</span></span></span><span class="hljs-comment"> {number} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> getDepth(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.depth; }</code> </pre><br></div></div><br>  Now you need to recursively create a tree, filling it with objects.  It looks like this: we take the next node, if the depth is less than the one set in the configs - split the objects of this node along the dividing line and create two child nodes, put the objects in them. <br><br><div class="spoiler">  <b class="spoiler_title">Two methods that do this</b> <div class="spoiler_text"><pre> <code class="hljs cs"> <span class="hljs-comment"><span class="hljs-comment">/** * Recursive explode node * @param node * @param depth */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">explodeTreeNodes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node: TreeNode, depth: number</span></span></span><span class="hljs-function">): </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.explodeTreeNode(node); depth--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (depth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> childNode of node.getChildren()) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.explodeTreeNodes(childNode, depth); } } } <span class="hljs-comment"><span class="hljs-comment">/** * Explode node to children * @param node */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">explodeTreeNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node: TreeNode</span></span></span><span class="hljs-function">): </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nodeBoundingRect = node.getBoundingRect(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newDepth = node.getDepth() + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftBoundingRect = Tools.clone(nodeBoundingRect) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> BoundingRect; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightBoundingRect = Tools.clone(nodeBoundingRect) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> BoundingRect; <span class="hljs-comment"><span class="hljs-comment">/** * Width or height explode */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newDepth % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> width = nodeBoundingRect.right - nodeBoundingRect.left; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> delta = width / <span class="hljs-number"><span class="hljs-number">2</span></span>; leftBoundingRect.right = leftBoundingRect.right - delta; rightBoundingRect.left = rightBoundingRect.left + delta; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> height = nodeBoundingRect.bottom - nodeBoundingRect.top; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> delta = height / <span class="hljs-number"><span class="hljs-number">2</span></span>; leftBoundingRect.bottom = leftBoundingRect.bottom - delta; rightBoundingRect.top = rightBoundingRect.top + delta; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftNodeObjects = Tools.filterObjectsByBoundingRect(leftBoundingRect, node.getObjects()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightNodeObjects = Tools.filterObjectsByBoundingRect(rightBoundingRect, node.getObjects()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(node, leftBoundingRect, leftNodeObjects, newDepth); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(node, rightBoundingRect, rightNodeObjects, newDepth); node.addChild(leftNode); node.addChild(rightNode); node.removeObjects(); }</code> </pre><br></div></div><br><p>  Now it is very easy for us to find the desired objects both by the square and by coordinates.  There are already amendments to the scroll and zoom, let's talk about them a little lower. </p><br><div class="spoiler">  <b class="spoiler_title">By coordinates</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> <span class="hljs-comment"><span class="hljs-comment">/** * Find node by coordinates * @param node * @param coordinates * @returns {TreeNode|null} */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> findNodeByCoordinates(node: TreeNode, coordinates: Coordinates): TreeNode | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> { let childNode = node.getChildByCoordinates(coordinates); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!childNode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childNode.isLastNode()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> childNode; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.findNodeByCoordinates(childNode, coordinates); } } <span class="hljs-comment"><span class="hljs-comment">/** * find objects by coordinates in tree * @param coordinates Coordinates * @returns {SchemeObject[]} */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> findObjectsByCoordinates(coordinates: Coordinates): SchemeObject[] { let result: SchemeObject[] = []; // scale let x = coordinates.x; let y = coordinates.y; x = x / this.scheme.getZoomManager().getScale(); y = y / this.scheme.getZoomManager().getScale(); // scroll x = x - this.scheme.getScrollManager().getScrollLeft(); y = y - this.scheme.getScrollManager().getScrollTop(); // <span class="hljs-keyword"><span class="hljs-keyword">search</span></span> node let rootNode = this.getTree(); let node = this.findNodeByCoordinates(rootNode, {x: x, y: y}); let nodeObjects: SchemeObject[] = []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node) { nodeObjects = node.getObjects(); } // <span class="hljs-keyword"><span class="hljs-keyword">search</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let schemeObject <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> nodeObjects) { let boundingRect = schemeObject.getBoundingRect(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tools.pointInRect({x: x, y: y}, boundingRect)) { result.push(schemeObject) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pro lines in 1px</b> <div class="spoiler_text">  When you try to draw a line in 1px, you can get an unexpected result: it will be two thick and translucent.  To avoid this, you need to shift the coordinates by 0.5px. <br>  <a href="https://stackoverflow.com/questions/7530593/html5-canvas-and-line-width/7531540">Detailed description of the problem</a> . <br></div></div><br><p>  We can also easily determine which objects are in view and require rendering without going through all the objects: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"> <span class="hljs-comment"><span class="hljs-comment">/** * Render visible objects */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> renderAll(): void { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderingRequestId) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cancelAnimationFrameApply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderingRequestId); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderingRequestId = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eventManager.sendEvent(<span class="hljs-string"><span class="hljs-string">'beforeRenderAll'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clearContext(); let scrollLeft = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scrollManager.getScrollLeft(); let scrollTop = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scrollManager.getScrollTop(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.view.setScrollLeft(scrollLeft); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.view.setScrollTop(scrollTop); let width = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getWidth() / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.zoomManager.getScale(); let height = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHeight() / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.zoomManager.getScale(); let leftOffset = -scrollLeft; let topOffset = -scrollTop; let nodes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageManager.findNodesByBoundingRect(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, { left: leftOffset, top: topOffset, right: leftOffset + width, bottom: topOffset + height }); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let node of nodes) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let schemeObject of node.getObjects()) { schemeObject.render(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.view); } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eventManager.sendEvent(<span class="hljs-string"><span class="hljs-string">'afterRenderAll'</span></span>); }</code> </pre><br></div></div><br><p>  Object storage and retrieval class: <a href="">src / managers / StorageManager.ts</a> </p><br><h2>  Scaling </h2><br><p>  Zoom is simple.  Canvas has a <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/scale">scale</a> method that transforms a grid of coordinates.  But we need not just to zoom, we need to zoom to the point where the cursor or center is located. <br></p><br><p>  For zooming to a point, you only need to know two points: the old zoom center (at the old scale) and the new one, and add their difference to the scheme offset: </p><br><div class="spoiler">  <b class="spoiler_title">Method</b> <div class="spoiler_text"><pre> <code class="hljs cs"> <span class="hljs-comment"><span class="hljs-comment">/** * Zoom to point * @param point * @param delta */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zoomToPoint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">point: Coordinates, delta: number</span></span></span><span class="hljs-function">): </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prevScale = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scheme.getZoomManager().getScale(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zoomed = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scheme.getZoomManager().zoom(delta); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomed) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newScale = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scheme.getZoomManager().getScale(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> prevCenter: Coordinates = { x: point.x / prevScale, y: point.y / prevScale, }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newCenter: Coordinates = { x: point.x / newScale, y: point.y / newScale, }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftOffsetDelta = newCenter.x - prevCenter.x; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topOffsetDelta = newCenter.y - prevCenter.y; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scheme.getScrollManager().scroll( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scheme.getScrollManager().getScrollLeft() + leftOffsetDelta, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scheme.getScrollManager().getScrollTop() + topOffsetDelta ); } }</code> </pre><br></div></div><br><p>  But we want to support the touch device, so you need to process the movement of two fingers and disable the native zoom: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs coffeescript"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scheme.getCanvas().addEventListener(<span class="hljs-string"><span class="hljs-string">'touchstart'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e: TouchEvent)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.touchDistance = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onMouseDown(e); }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scheme.getCanvas().addEventListener(<span class="hljs-string"><span class="hljs-string">'touchmove'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e: TouchEvent)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.targetTouches.length == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> one finger - dragging <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onMouseMove(e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.targetTouches.length == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> two finger - zoom const p1 = e.targetTouches[<span class="hljs-number"><span class="hljs-number">0</span></span>]; const p2 = e.targetTouches[<span class="hljs-number"><span class="hljs-number">1</span></span>]; let distance = Math.sqrt(Math.pow(p2.pageX - p1.pageX, <span class="hljs-number"><span class="hljs-number">2</span></span>) + Math.pow(p2.pageY - p1.pageY, <span class="hljs-number"><span class="hljs-number">2</span></span>)); let delta = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.touchDistance) { delta = distance - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.touchDistance; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.touchDistance = distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scheme.getZoomManager().zoomToPointer(e, delta / <span class="hljs-number"><span class="hljs-number">5</span></span>); } } e.preventDefault(); });</code> </pre><br></div></div><br><p>  An unpleasant feature was found in iPhones 6 and older: with a quick double-tap, a native zoom appeared with a focus on the canvas, and in this mode the canvas began to slow down terribly.  There is no reaction to the viewport.  It is treated as follows: </p><br><pre> <code class="hljs coffeescript"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scheme.getCanvas().addEventListener(<span class="hljs-string"><span class="hljs-string">'touchend'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e: TouchEvent)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> prevent double tap zoom let now = (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date()).getTime(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lastTouchEndTime &amp;&amp; now - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lastTouchEndTime &lt;= <span class="hljs-number"><span class="hljs-number">300</span></span>) { e.preventDefault(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onMouseUp(e); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lastTouchEndTime = now; });</code> </pre><br><p>  Scaling class: <a href="">src / managers / ZoomManager.ts</a> </p><br><h2>  Relocation scheme </h2><br><p>  I decided to simply add to the coordinates of the offset to the left and above. <br>  True, there is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/translate">translate</a> method that shifts the grid of coordinates.  At the time of development, it seemed to me not very convenient, but perhaps I will use it still.  But all this stuff, we are most interested in event processing. <br></p><br><p>  Some people when clicking can shift the cursor a little, we have to take this into account: <br></p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> <span class="hljs-comment"><span class="hljs-comment">/** * Mouse down * @param e */</span></span> protected onMouseDown(e: MouseEvent | TouchEvent): <span class="hljs-type"><span class="hljs-type">void</span></span> { this.leftButtonDown = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; this.setLastClientPositionFromEvent(e); } <span class="hljs-comment"><span class="hljs-comment">/** * Mouse up * @param e */</span></span> protected onMouseUp(e: MouseEvent | TouchEvent): <span class="hljs-type"><span class="hljs-type">void</span></span> { this.leftButtonDown = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; this.setLastClientPositionFromEvent(e); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.isDragging) { this.scheme.setCursorStyle(this.scheme.getDefaultCursorStyle()); this.scheme.requestRenderAll(); } // defer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> prevent <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> click <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mouseUp setTimeout(() =&gt; {this.isDragging = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }, <span class="hljs-number"><span class="hljs-number">10</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/** * On mouse move * @param e */</span></span> protected onMouseMove(e: MouseEvent | TouchEvent): <span class="hljs-type"><span class="hljs-type">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.leftButtonDown) { let newCoordinates = this.getCoordinatesFromEvent(e); let deltaX = Math.abs(newCoordinates.x - this.getLastClientX()); let deltaY = Math.abs(newCoordinates.y - this.getLastClientY()); // <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> click <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (deltaX &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> || deltaY &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { this.isDragging = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; this.scheme.setCursorStyle(<span class="hljs-string"><span class="hljs-string">'move'</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!this.isDragging) { this.handleHover(e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { this.scheme.getScrollManager().handleDragging(e); } } <span class="hljs-comment"><span class="hljs-comment">/** * Handle dragging * @param e */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> handleDragging(e: MouseEvent | TouchEvent): <span class="hljs-type"><span class="hljs-type">void</span></span> { let lastClientX = this.scheme.getEventManager().getLastClientX(); let lastClientY = this.scheme.getEventManager().getLastClientY(); this.scheme.getEventManager().setLastClientPositionFromEvent(e); let leftCenterOffset = this.scheme.getEventManager().getLastClientX() - lastClientX; let topCenterOffset = this.scheme.getEventManager().getLastClientY() - lastClientY; // scale leftCenterOffset = leftCenterOffset / this.scheme.getZoomManager().getScale(); topCenterOffset = topCenterOffset / this.scheme.getZoomManager().getScale(); let scrollLeft = leftCenterOffset + this.getScrollLeft(); let scrollTop = topCenterOffset + this.getScrollTop(); this.scroll(scrollLeft, scrollTop); }</code> </pre><br></div></div><br><p>  The class responsible for the scroll: <a href="">src / managers / ScrollManager.ts</a> </p><br><h2>  Optimization </h2><br><p>  It seems that there is already a working version of the scheme, but an unpleasant surprise awaits us: <br>  Our scheme now works quickly only in chrome.  The problem is that when you move the scheme in full size and zoom out of this full size, all objects are redrawn.  And when only a part of the objects fit on the scale, it works normally. </p><br><p>  At first I wanted to merge the nearest places into clusters so that the place of hundreds of objects draw one at a small scale.  But I could not find / come up with an algorithm that would do it in a reasonable time and would be stable, since  Objects on the map can be located as you like. </p><br><p>  Then I remembered the rule that is written on each fence (and at the beginning of this article) when working with canvas: do not redraw unchanging parts.  Indeed, when moving and zooming, the scheme itself does not change, so we just need to have a ‚Äúsnapshot‚Äù of the scheme n times the initial scale and, when moving / zooming, do not render objects, but simply substitute our image until the map resolution exceeds the resolution of the image.  And then the remaining real objects will be quickly drawn in view of their number. </p><br><p>  But this picture also has to change sometimes.  For example, when choosing a place, it changes the view and we do not want the selected places to disappear while the scheme is being moved.  To redraw the entire image (n times the initial size of the map) when clicked is expensive, <br>  but at the same time, we can allow ourselves not to care much about the intersection of objects in the snapshot and update only the square in which the modified object is located. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-comment"><span class="hljs-comment">/** * Update scheme cache * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> onlyChanged */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> updateCache(onlyChanged: boolean): void { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cacheView) { let storage = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageManager.getImageStorage(<span class="hljs-string"><span class="hljs-string">'scheme-cache'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cacheView = new View(storage.getCanvas()); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onlyChanged) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let schemeObject of <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.changedObjects) { schemeObject.clear(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cacheView); schemeObject.render(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cacheView); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { let boundingRect = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageManager.getObjectsBoundingRect(); let scale = (<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.zoomManager.getScaleWithAllObjects()) * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cacheSchemeRatio; let rectWidth = boundingRect.right * scale; let rectHeight = boundingRect.bottom * scale; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cacheView.setDimensions({ width: rectWidth, height: rectHeight }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cacheView.getContext().scale(scale, scale); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let schemeObject of <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getObjects()) { schemeObject.render(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cacheView); } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.changedObjects = []; } <span class="hljs-comment"><span class="hljs-comment">/** * Draw from cache */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> drawFromCache() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cacheView) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderingRequestId) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cancelAnimationFrameApply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderingRequestId); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderingRequestId = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clearContext(); let boundingRect = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageManager.getObjectsBoundingRect(); let rectWidth = boundingRect.right; let rectHeight = boundingRect.bottom; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.view.getContext().drawImage( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cacheView.getCanvas(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getScrollManager().getScrollLeft(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getScrollManager().getScrollTop(), rectWidth, rectHeight ); } <span class="hljs-comment"><span class="hljs-comment">/** * Request draw from cache * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@returns</span></span></span><span class="hljs-comment"> {Scheme} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> requestDrawFromCache(): <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderingRequestId) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderingRequestId = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requestFrameAnimationApply(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.drawFromCache(); }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br></div></div><br><p>  In this seemingly uncomplicated way, we greatly increased the speed of the circuit. </p><br><p>  Thank you for reading to the end.  In the process of working on the scheme, I spied on the sources of <a href="http://fabricjs.com/">fabricjs</a> and <a href="http://www.chartjs.org/">chartjs in</a> order to cycle less. </p></div><p>Source: <a href="https://habr.com/ru/post/349886/">https://habr.com/ru/post/349886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349870/index.html">Parsing ICO TenX: scam or not?</a></li>
<li><a href="../349872/index.html">How are the address tips "Dadata"</a></li>
<li><a href="../349874/index.html">Blue Shift or iOS application launch time optimization. Yandex lecture</a></li>
<li><a href="../349876/index.html">Three ways to update a query in Jira from ScriptRunner using the Jira Java API</a></li>
<li><a href="../349880/index.html">Vue.js + Asp.NETCore + TypeScript application without Webpack</a></li>
<li><a href="../349888/index.html">The digest of interesting materials for the mobile developer # 242 (February 19 - February 25)</a></li>
<li><a href="../349890/index.html">We receive the list of passengers of flights of the largest air carrier of Ukraine</a></li>
<li><a href="../349894/index.html">Script for obtaining information from a Windows image</a></li>
<li><a href="../349900/index.html">Creating a Telegram bot to get information on the Dogecoin wallet</a></li>
<li><a href="../349902/index.html">"Digital States": how it all began</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>