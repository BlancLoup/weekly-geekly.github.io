<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cheat Sheet with HTTP C ++ Libraries</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unfortunately, in the standard C ++ library there are no tools for working with the HTTP protocol. Perhaps in the future they will appear, but at the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cheat Sheet with HTTP C ++ Libraries</h1><div class="post__text post__text-html js-mediator-article">  Unfortunately, in the standard C ++ library there are no tools for working with the HTTP protocol.  Perhaps in the future they will appear, but at the moment every time, if necessary, to pull some REST service, parse a web page, write a simple bot or crawler, you have to ask questions "And which library should I take, so that I can quickly and simply be?".  Sometimes the project already uses some kind of framework (and sometimes even a few), and then you have to remember, "But how do you make an HTTP request with available resources?".  In order not to be confused, I decided to write for myself a cheat sheet with examples of HTTP requests for C ++ using different libraries.  And the most convenient place to store such cribs is Habr: you yourself will not lose, and others can come in handy. <br><br>  Will be considered: <br><ul><li>  <b>WinInet</b> </li><li>  <b>Winhttp</b> </li><li>  <b>Casablanca</b> </li><li>  <b>Qt</b> </li><li>  <b>Poco</b> </li><li>  <b>wxWidgets</b> </li><li>  <b>Boost.Asio</b> </li><li>  <b>libcurl</b> </li><li>  <b>neon</b> </li><li>  <b>.NET (C ++ / CLI)</b> </li><li>  <b><b>IXMLHTTPRequest</b></b> </li><li>  <b>Happyhttp</b> </li><li>  <b>cpp-netlib</b> </li></ul><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  WinInet </h4><br>  <b>Site</b> : <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa385483(v%3Dvs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/aa385483(v=vs.85).aspx</a> <br>  <b>Platform</b> : Windows 95 and above <br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tchar.h&gt; #include &lt;wininet.h&gt; /// .... HINTERNET hIntSession = ::InternetOpen(_T("MyApp"), INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0); HINTERNET hHttpSession = InternetConnect(hIntSession, _T("api.twitter.com"), 80, 0, 0, INTERNET_SERVICE_HTTP, 0, NULL); HINTERNET hHttpRequest = HttpOpenRequest( hHttpSession, _T("GET"), _T("1/statuses/user_timeline.xml?screen_name=twitterapi"), 0, 0, 0, INTERNET_FLAG_RELOAD, 0); TCHAR* szHeaders = _T("Content-Type: text/html\nMySpecialHeder: whatever"); CHAR szReq[1024] = ""; if( !HttpSendRequest(hHttpRequest, szHeaders, _tcslen(szHeaders), szReq, strlen(szReq))) { DWORD dwErr = GetLastError(); /// handle error } CHAR szBuffer[1025]; DWORD dwRead=0; while(::InternetReadFile(hHttpRequest, szBuffer, sizeof(szBuffer)-1, &amp;dwRead) &amp;&amp; dwRead) { szBuffer[dwRead] = 0; OutputDebugStringA(szBuffer); dwRead=0; } ::InternetCloseHandle(hHttpRequest); ::InternetCloseHandle(hHttpSession); ::InternetCloseHandle(hIntSession);</span></span></span></span></code> </pre> <br></div></div><br><br><h4>  Winhttp </h4><br>  <b>Site</b> : <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa382925(v%3Dvs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/aa382925(v=vs.85).aspx</a> <br>  <b>Platform</b> : Windows 2000 and above <br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs">DWORD dwSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; DWORD dwDownloaded = <span class="hljs-number"><span class="hljs-number">0</span></span>; LPSTR pszOutBuffer; BOOL bResults = FALSE; HINTERNET hSession = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, hConnect = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, hRequest = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Use WinHttpOpen to obtain a session handle. hSession = WinHttpOpen( L"WinHTTP Example/1.0", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0 ); // Specify an HTTP server. if( hSession ) hConnect = WinHttpConnect( hSession, L"www.microsoft.com", INTERNET_DEFAULT_HTTPS_PORT, 0 ); // Create an HTTP request handle. if( hConnect ) hRequest = WinHttpOpenRequest( hConnect, L"GET", NULL, NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_SECURE ); // Send a request. if( hRequest ) bResults = WinHttpSendRequest( hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0 ); // End the request. if( bResults ) bResults = WinHttpReceiveResponse( hRequest, NULL ); // Keep checking for data until there is nothing left. if( bResults ) { do { // Check for available data. dwSize = 0; if( !WinHttpQueryDataAvailable( hRequest, &amp;dwSize ) ) printf( "Error %u in WinHttpQueryDataAvailable.\n", GetLastError( ) ); // Allocate space for the buffer. pszOutBuffer = new char[dwSize+1]; if( !pszOutBuffer ) { printf( "Out of memory\n" ); dwSize=0; } else { // Read the data. ZeroMemory( pszOutBuffer, dwSize+1 ); if( !WinHttpReadData( hRequest, (LPVOID)pszOutBuffer, dwSize, &amp;dwDownloaded ) ) printf( "Error %u in WinHttpReadData.\n", GetLastError( ) ); else printf( "%s", pszOutBuffer ); // Free the memory allocated to the buffer. delete [] pszOutBuffer; } } while( dwSize &gt; 0 ); } // Report any errors. if( !bResults ) printf( "Error %d has occurred.\n", GetLastError( ) ); // Close any open handles. if( hRequest ) WinHttpCloseHandle( hRequest ); if( hConnect ) WinHttpCloseHandle( hConnect ); if( hSession ) WinHttpCloseHandle( hSession );</span></span></code> </pre><br></div></div><br><br><h5>  Casablanca </h5><br>  <b>Website</b> : <a href="https://casablanca.codeplex.com/">https://casablanca.codeplex.com</a> <br>  <b>Platform</b> : all <br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">http_client </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">L"http://www.myhttpserver.com"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">http_request </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(methods::GET)</span></span></span></span>; client.request(request).then([](http_response response) { <span class="hljs-comment"><span class="hljs-comment">// Perform actions here to inspect the HTTP response... if(response.status_code() == status_codes::OK) { } });</span></span></code> </pre><br></div></div><br><br><h5>  Qt </h5><br>  <b>Website</b> : <a href="http://qt-project.org/">http://qt-project.org</a> <br>  <b>Platform</b> : all <br><div class="spoiler">  <b class="spoiler_title">Qt 4.x usage example (already out of date)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"handler.h"</span></span></span><span class="hljs-meta"> Handler::Handler(QObject *parent) :QObject(parent) { http = new QHttp(this); connect(http, SIGNAL(stateChanged(int)), this, SLOT(stateChanged(int))); connect(http, SIGNAL(responseHeaderReceived(QHttpResponseHeader)), this, SLOT(responseHeaderReceived(QHttpResponseHeader))); connect(http, SIGNAL(requestFinished(int,bool)), this, SLOT(requestFinished(int,bool))); } void Handler::doHttp() { http-&gt;setHost(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"google.com"</span></span></span><span class="hljs-meta">); http-&gt;get(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/"</span></span></span><span class="hljs-meta">); } void Handler::stateChanged(int state) { switch(state) { case 0: qDebug() </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "Unconnected"; break; case 1: qDebug() &lt;&lt; "Host Lookup"; break; case 2: qDebug() &lt;&lt; "Connecting"; break; case 3: qDebug() &lt;&lt; "Sending"; break; case 4: qDebug() &lt;&lt; "Reading"; break; case 5: qDebug() &lt;&lt; "Connect"; break; case 6: qDebug() &lt;&lt; "Closing"; break; } } void Handler::responseHeaderReceived(const QHttpResponseHeader &amp;resp) { qDebug() &lt;&lt; "Size : " &lt;&lt; resp.contentLength(); qDebug() &lt;&lt; "Type : " &lt;&lt; resp.contentType(); qDebug() &lt;&lt; "Status Code : " &lt;&lt; resp.statusCode(); } void Handler::requestFinished(int id, bool error) { qDebug() &lt;&lt; "Request Id : " &lt;&lt; id; if(error) { qDebug() &lt;&lt; "Error"; } else { qDebug() &lt;&lt; http-&gt;readAll(); } }</span></span></span></span></code> </pre><br></div></div><div class="spoiler">  <b class="spoiler_title">Qt 5.x usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Downloader::doDownload() { manager = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QNetworkAccessManager(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); connect(manager, SIGNAL(finished(QNetworkReply*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(replyFinished(QNetworkReply*))); manager-&gt;get(QNetworkRequest(QUrl(<span class="hljs-string"><span class="hljs-string">"http://google.com"</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Downloader::replyFinished (QNetworkReply *reply) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(reply-&gt;error() != QNetworkReply::NoError) { qDebug() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR!"</span></span>; qDebug() &lt;&lt; reply-&gt;errorString(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::ContentTypeHeader).toString(); qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::LastModifiedHeader).toDateTime().toString(); qDebug() &lt;&lt; reply-&gt;header(QNetworkRequest::ContentLengthHeader).toULongLong(); qDebug() &lt;&lt; reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(); qDebug() &lt;&lt; reply-&gt;attribute(QNetworkRequest::HttpReasonPhraseAttribute).toString(); <span class="hljs-function"><span class="hljs-function">QFile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"C:/Qt/Dummy/downloaded.txt"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(file.open(QFile::Append)) { file.write(reply-&gt;readAll()); } } reply-&gt;deleteLater(); }</code> </pre><br></div></div><br><br><h5>  Poco </h5><br>  <b>Website</b> : <a href="http://pocoproject.org/">http://pocoproject.org</a> <br>  <b>Platform</b> : all <br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Poco/Net/HTTPClientSession.h&gt; #include &lt;Poco/Net/HTTPRequest.h&gt; #include &lt;Poco/Net/HTTPResponse.h&gt; #include &lt;Poco/StreamCopier.h&gt; #include &lt;Poco/Path.h&gt; #include &lt;Poco/URI.h&gt; #include &lt;Poco/Exception.h&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace Poco::Net; using namespace Poco; using namespace std; int main(int argc, char **argv) { if (argc != 2) { cout &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " &lt;uri&gt;" &lt;&lt; endl; cout &lt;&lt; " fetches the resource identified by &lt;uri&gt; and print it" &lt;&lt; endl; return -1; } try { // prepare session URI uri(argv[1]); HTTPClientSession session(uri.getHost(), uri.getPort()); // prepare path string path(uri.getPathAndQuery()); if (path.empty()) path = "/"; // send request HTTPRequest req(HTTPRequest::HTTP_GET, path, HTTPMessage::HTTP_1_1); session.sendRequest(req); // get response HTTPResponse res; cout &lt;&lt; res.getStatus() &lt;&lt; " " &lt;&lt; res.getReason() &lt;&lt; endl; // print response istream &amp;is = session.receiveResponse(res); StreamCopier::copyStream(is, cout); } catch (Exception &amp;ex) { cerr &lt;&lt; ex.displayText() &lt;&lt; endl; return -1; } return 0; }</span></span></span></span></code> </pre><br></div></div><br><br><h5>  wxWidgets </h5><br>  <b>Website</b> : <a href="http://www.wxwidgets.org/">http://www.wxwidgets.org</a> <br>  <b>Platform</b> : all <br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wx/sstream.h&gt; #include &lt;wx/protocol/http.h&gt; wxHTTP get; get.SetHeader(_T("Content-type"), _T("text/html; charset=utf-8")); get.SetTimeout(10); // 10 seconds of timeout instead of 10 minutes ... // this will wait until the user connects to the internet. It is important in case of dialup (or ADSL) connections while (!get.Connect(_T("www.google.com"))) // only the server, no pages here yet ... wxSleep(5); wxApp::IsMainLoopRunning(); // should return true // use _T("/") for index.html, index.php, default.asp, etc. wxInputStream *httpStream = get.GetInputStream(_T("/intl/en/about.html")); // wxLogVerbose( wxString(_T(" GetInputStream: ")) &lt;&lt; get.GetResponse() &lt;&lt; _T("-") &lt;&lt; ((resStream)? _T("OK ") : _T("FAILURE ")) &lt;&lt; get.GetError() ); if (get.GetError() == wxPROTO_NOERR) { wxString res; wxStringOutputStream out_stream(&amp;res); httpStream-&gt;Read(out_stream); wxMessageBox(res); // wxLogVerbose( wxString(_T(" returned document length: ")) &lt;&lt; res.Length() ); } else { wxMessageBox(_T("Unable to connect!")); } wxDELETE(httpStream); get.Close();</span></span></span></span></code> </pre><br></div></div><br><br><h5>  Boost.Asio </h5><br>  <b>Website</b> : <a href="http://www.boost.org/doc/libs/1_55_0/doc/html/boost_asio.html">http://www.boost.org/doc/libs/1_55_0/doc/html/boost_asio.html</a> <br>  <b>Platform</b> : all <br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;istream&gt; #include &lt;ostream&gt; #include &lt;string&gt; #include &lt;boost/asio.hpp&gt; using boost::asio::ip::tcp; int main(int argc, char* argv[]) { try { if (argc != 3) { std::cout &lt;&lt; "Usage: sync_client &lt;server&gt; &lt;path&gt;\n"; std::cout &lt;&lt; "Example:\n"; std::cout &lt;&lt; " sync_client www.boost.org /LICENSE_1_0.txt\n"; return 1; } boost::asio::io_service io_service; // Get a list of endpoints corresponding to the server name. tcp::resolver resolver(io_service); tcp::resolver::query query(argv[1], "http"); tcp::resolver::iterator endpoint_iterator = resolver.resolve(query); // Try each endpoint until we successfully establish a connection. tcp::socket socket(io_service); boost::asio::connect(socket, endpoint_iterator); // Form the request. We specify the "Connection: close" header so that the // server will close the socket after transmitting the response. This will // allow us to treat all data up until the EOF as the content. boost::asio::streambuf request; std::ostream request_stream(&amp;request); request_stream &lt;&lt; "GET " &lt;&lt; argv[2] &lt;&lt; " HTTP/1.0\r\n"; request_stream &lt;&lt; "Host: " &lt;&lt; argv[1] &lt;&lt; "\r\n"; request_stream &lt;&lt; "Accept: */*\r\n"; request_stream &lt;&lt; "Connection: close\r\n\r\n"; // Send the request. boost::asio::write(socket, request); // Read the response status line. The response streambuf will automatically // grow to accommodate the entire line. The growth may be limited by passing // a maximum size to the streambuf constructor. boost::asio::streambuf response; boost::asio::read_until(socket, response, "\r\n"); // Check that response is OK. std::istream response_stream(&amp;response); std::string http_version; response_stream &gt;&gt; http_version; unsigned int status_code; response_stream &gt;&gt; status_code; std::string status_message; std::getline(response_stream, status_message); if (!response_stream || http_version.substr(0, 5) != "HTTP/") { std::cout &lt;&lt; "Invalid response\n"; return 1; } if (status_code != 200) { std::cout &lt;&lt; "Response returned with status code " &lt;&lt; status_code &lt;&lt; "\n"; return 1; } // Read the response headers, which are terminated by a blank line. boost::asio::read_until(socket, response, "\r\n\r\n"); // Process the response headers. std::string header; while (std::getline(response_stream, header) &amp;&amp; header != "\r") std::cout &lt;&lt; header &lt;&lt; "\n"; std::cout &lt;&lt; "\n"; // Write whatever content we already have to output. if (response.size() &gt; 0) std::cout &lt;&lt; &amp;response; // Read until EOF, writing data to output as we go. boost::system::error_code error; while (boost::asio::read(socket, response, boost::asio::transfer_at_least(1), error)) std::cout &lt;&lt; &amp;response; if (error != boost::asio::error::eof) throw boost::system::system_error(error); } catch (std::exception&amp; e) { std::cout &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; "\n"; } return 0; }</span></span></span></span></code> </pre><br></div></div><br><br><h5>  libcurl </h5><br>  <b>Website</b> : <a href="http://curl.haxx.se/libcurl">http://curl.haxx.se/libcurl</a> <br>  <b>Platform</b> : all <br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;curl/curl.h&gt; int main(void) { CURL *curl; CURLcode res; curl = curl_easy_init(); if(curl) { curl_easy_setopt(curl, CURLOPT_URL, "http://example.com"); /* example.com is redirected, so we tell libcurl to follow redirection */ curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L); /* Perform the request, res will get the return code */ res = curl_easy_perform(curl); /* Check for errors */ if(res != CURLE_OK) fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res)); /* always cleanup */ curl_easy_cleanup(curl); } return 0; }</span></span></span></span></code> </pre><br></div></div><br><br><h5>  neon </h5><br>  <b>Website</b> : <a href="http://www.webdav.org/neon">http://www.webdav.org/neon</a> <br>  <b>Platform</b> : all <br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ne_session.h&gt; #include &lt;ne_request.h&gt; #include &lt;ne_utils.h&gt; #include &lt;ne_uri.h&gt; int httpResponseReader(void *userdata, const char *buf, size_t len) { string *str = (string *)userdata; str-&gt;append(buf, len); return 0; } int do_get(string host) { ne_session *sess; ne_request *req; string response; ne_sock_init(); sess = ne_session_create("http", host.c_str(), 80); ne_set_useragent(sess, "MyAgent/1.0"); req = ne_request_create(sess, "GET", "/SomeURL/method?with=parameter&amp;value=data"); // if accepting only 2xx codes, use "ne_accept_2xx" ne_add_response_body_reader(req, ne_accept_always, httpResponseReader, &amp;response); int result = ne_request_dispatch(req); int status = ne_get_status(req)-&gt;code; ne_request_destroy(req); string errorMessage = ne_get_error(sess); ne_session_destroy(sess); printf("result %d, status %d\n", result, status); cout &lt;&lt; response &lt;&lt; "\n"; switch (result) { case NE_OK: break; case NE_CONNECT: throw ConnectionError(errorMessage); case NE_TIMEOUT: throw TimeOutError(errorMessage); case NE_AUTH: throw AuthenticationError(errorMessage); default: throw AnotherWebError(errorMessage); } return 0; }</span></span></span></span></code> </pre><br></div></div><br><br><h5>  .NET </h5><br>  <b>Website</b> : <a href="httpwebrequest.aspx">http://msdn.microsoft.com/en-us/library/system.net.httpwebrequest.aspx</a> <br>  <b>Platform</b> : Windows XP and above <br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#using </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;System.dll&gt; using namespace System; using namespace System::Net; using namespace System::Text; using namespace System::IO; // Specify the URL to receive the request. int main() { array&lt;String^&gt;^args = Environment::GetCommandLineArgs(); HttpWebRequest^ request = dynamic_cast&lt;HttpWebRequest^&gt;(WebRequest::Create( args[ 1 ] )); // Set some reasonable limits on resources used by this request request-&gt;MaximumAutomaticRedirections = 4; request-&gt;MaximumResponseHeadersLength = 4; // Set credentials to use for this request. request-&gt;Credentials = CredentialCache::DefaultCredentials; HttpWebResponse^ response = dynamic_cast&lt;HttpWebResponse^&gt;(request-&gt;GetResponse()); Console::WriteLine( "Content length is {0}", response-&gt;ContentLength ); Console::WriteLine( "Content type is {0}", response-&gt;ContentType ); // Get the stream associated with the response. Stream^ receiveStream = response-&gt;GetResponseStream(); // Pipes the stream to a higher level stream reader with the required encoding format. StreamReader^ readStream = gcnew StreamReader( receiveStream,Encoding::UTF8 ); Console::WriteLine( "Response stream received." ); Console::WriteLine( readStream-&gt;ReadToEnd() ); response-&gt;Close(); readStream-&gt;Close(); }</span></span></span></span></code> </pre><br></div></div><br><br><h5>  IXMLHTTPRequest </h5><br>  <b>Site</b> : <a href="http://msdn.microsoft.com/en-us/library/ms759148(v%3Dvs.85).aspx">http://msdn.microsoft.com/en-us/library/ms759148(v=vs.85).aspx</a> <br>  <b>Platform</b> : Windows XP and above <br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;atlbase.h&gt; #include &lt;msxml6.h&gt; HRESULT hr; CComPtr&lt;IXMLHTTPRequest&gt; request; hr = request.CoCreateInstance(CLSID_XMLHTTP60); hr = request-&gt;open( _bstr_t("GET"), _bstr_t("https://www.google.com/images/srpr/logo11w.png"), _variant_t(VARIANT_FALSE), _variant_t(), _variant_t()); hr = request-&gt;send(_variant_t()); // get status - 200 if succuss long status; hr = request-&gt;get_status(&amp;status); // load image data (if url points to an image) VARIANT responseVariant; hr = request-&gt;get_responseStream(&amp;responseVariant); IStream* stream = (IStream*)responseVariant.punkVal; CImage *image = new CImage(); image-&gt;Load(stream); stream-&gt;Release();</span></span></span></span></code> </pre><br></div></div><br><br><h5>  Happyhttp </h5><br>  <b>Website</b> : <a href="http.html">http://scumways.com/happyhttp/happyhttp.html</a> <br>  <b>Platform</b> : all <br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// invoked when response headers have been received void OnBegin( const happyhttp::Response* r, void* userdata ) { printf( "BEGIN (%d %s)\n", r-&gt;getstatus(), r-&gt;getreason() ); count = 0; } // invoked to process response body data (may be called multiple times) void OnData( const happyhttp::Response* r, void* userdata, const unsigned char* data, int n ) { fwrite( data,1,n, stdout ); count += n; } // invoked when response is complete void OnComplete( const happyhttp::Response* r, void* userdata ) { printf( "COMPLETE (%d bytes)\n", count ); } void TestGET() { happyhttp::Connection conn( "www.scumways.com", 80 ); conn.setcallbacks( OnBegin, OnData, OnComplete, 0 ); conn.request( "GET", "/happyhttp/test.php" ); while( conn.outstanding() ) conn.pump(); }</span></span></code> </pre><br></div></div><br><br><h5>  cpp-netlib </h5><br>  <b>Website</b> : <a href="http://cpp-netlib.org/">http://cpp-netlib.org</a> <br>  <b>Platform</b> : all <br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost::network; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost::network::http; client::<span class="hljs-function"><span class="hljs-function">request </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"http://127.0.0.1:8000/"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; request_ &lt;&lt; header(<span class="hljs-string"><span class="hljs-string">"Connection"</span></span>, <span class="hljs-string"><span class="hljs-string">"close"</span></span>); client client_; client::response response_ = client_.get(request_); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> body_ = body(response_);</code> </pre><br></div></div><br><br><h4>  So, tell me in the end what to use! </h4><br>  Want the classics checked up for years - take libcurl.  Write an application with a visual interface - take Qt.  Want to write in C ++ 11 - take Casablanca.  Write under .NET - use standard platform tools.  You write something without an interface, and besides an HTTP client, you want to have various convenient tools ‚Äî Boost or POCO. </div><p>Source: <a href="https://habr.com/ru/post/226557/">https://habr.com/ru/post/226557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226543/index.html">Earth rise on the moon ... common</a></li>
<li><a href="../226545/index.html">Easy way to paginate in Highcharts</a></li>
<li><a href="../226547/index.html">Fujitsu conference in Perm "Business-oriented data processing center"</a></li>
<li><a href="../226549/index.html">Kick Up Your Team Spirit with Payoneer</a></li>
<li><a href="../226553/index.html">One ring to enter the hostel, or how I spoiled the ID EM reader</a></li>
<li><a href="../226559/index.html">Java Multi-Threading Labs: Parallel Copy</a></li>
<li><a href="../226561/index.html">Everyone is equal, but some are more equal or is it possible to spam on Google Play</a></li>
<li><a href="../226563/index.html">MultiCAD.NET API: Saving non-graphic information in .dwg-drawings</a></li>
<li><a href="../226565/index.html">Textbook on programming language D. Part 2</a></li>
<li><a href="../226571/index.html">The story of creating a world map for the game ‚ÄúC & C Tiberium Alliances‚Äù. Postmortem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>