<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementation of FFT node with floating point on the FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! This article will discuss the implementation of the fast Fourier transform in floating point format on the FPGA. The main features of kernel de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementation of FFT node with floating point on the FPGA</h1><div class="post__text post__text-html js-mediator-article">  Hello!  This article will discuss the implementation of the fast Fourier transform in floating point format on the FPGA.  The main features of kernel development from the very first stage to the finished configurable IP core will be shown.  In particular, a comparison will be made with ready-made Xilinx cores, showing the advantages and disadvantages of various implementation options.  The article will tell about the main feature of the core FFT and OBPF - about the absence of the need to translate the data into natural order after the FFT and OBPF for their joint connective.  In this article I will try to reflect all the subtleties of the project called FP23FFTK, I will give real examples of using the finished core.  The project is written in VHDL and sharpened under the Xilinx FPGA of the last families. <br><br><img src="https://habrastorage.org/files/8fa/94e/229/8fa94e2290254ab39add09cb48e2ab91.png"><br><a name="habracut"></a><br><h3>  Introduction </h3><br>  In digital signal processing, without any doubt, the main analysis tool is the Fast Fourier Transform (FFT).  The algorithm is used in almost all areas of science and technology.  The simplest physical example of the Fourier transform is the human perception of sound.  Whenever we hear a sound, the auricle automatically performs a complex calculation, which a person is able to do only after several years of studying math.  The essence of the phenomenon lies in the fact that the auditory organ represents sound in the form of a spectrum of consecutive loudness values ‚Äã‚Äãfor tones of different heights, and the brain transforms the received information into perceived sound. <br><br>  In matters of radio engineering, FFT algorithms are used in convolutions and in the design of digital correlators, used in image processing, as well as in audio and video equipment (equalizers, spectrum analyzers, vocoders).  In addition, FFT methods underlie all sorts of data encryption and compression algorithms (jpeg, mpeg4, mp3), as well as when working with long numbers.  FFT is used in sonar systems to detect surface ships and submarines, and in radar systems to obtain information about speed, flight direction and distance to targets. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Various FFT modules are available in almost any application package for research, such as Maple, MATLAB, GNU Octave, MathCAD, Mathematica.  The specialist must understand the Fourier transform process and be able to correctly apply it to solve the set tasks, where necessary. <br><br>  The first software implementation of the FFT algorithm was carried out in the early 60s of the 20th century at the IBM Computing Center by John Cooley under the direction of John Tukey.  In 1965 they also published an article devoted to the fast Fourier transform algorithm.  This method formed the basis of many FFT algorithms and was named after the developers - Cooley-Tukey.  Since then, quite a lot of various publications and monographs have been issued, in which various methods and algorithms of FFT are developed and described, reducing the number of operations performed, reducing energy costs and resources, etc.  Today, FFT is not the name of one, but a large number of different algorithms designed to quickly calculate the Fourier transform. <br><br><h3>  Theory </h3><br>  I will not describe in detail the theory from the course of the radio engineering faculty of the type ‚ÄúDigital signal processing‚Äù.  Instead, I will provide a selection of the most useful sources, where you can get acquainted with both theoretical research and practical calculations and implementation features of various FFT algorithms. <br><br>  <b>Articles on Habr√©:</b> <br><br><ul><li>  <a href="https://habrahabr.ru/post/196374/">Simple words about Fourier transform</a> </li><li>  <a href="https://habrahabr.ru/post/269991/">Practical application of Fourier transform</a> </li><li>  <a href="https://habrahabr.ru/post/247385/">Fourier transform in action ...</a> </li><li>  <a href="https://habrahabr.ru/post/265781/">Fourier processing of digital images</a> </li><li>  <a href="https://habrahabr.ru/post/112068/">Matlab and Fast Fourier Transform</a> </li><li>  <a href="https://habrahabr.ru/post/253447/">Spectral analysis of signals</a> </li></ul><br>  <b>Books:</b> <br><br><ul><li>  E.S.  Ifcher, Barry U. Dervis., Digital Signal Processing.  Practical approach </li><li>  <a href="http://dsp-book.narod.ru/RG.html">Rabiner L., Gold B., Theory and application of digital signal processing</a> </li></ul><br>  <b>DSPLIB website:</b> <br><br><ul><li>  <a href="http://ru.dsplib.org/content/fft_dec_in_time.html">Time thinning FFT</a> </li><li>  <a href="http://ru.dsplib.org/content/fft_dec_in_freq.html">FFT with thinning by frequency</a> </li><li>  <a href="http://ru.dsplib.org/content/fft_introduction.html">Fast Fourier transform.</a>  <a href="http://ru.dsplib.org/content/fft_introduction.html">Principle of construction</a> </li><li>  <a href="http://www.dsplib.ru/content/polyphasefft/polyphase.html">Polyphase FFT</a> </li></ul><br><h3>  Algorithm </h3><br>  The FFT node is made according to the Kuli-Tuki algorithm with base 2. All calculations for such an implementation are reduced to the repeated execution of the basic operation ‚Äúbutterfly‚Äù.  The transformation method is based on a conveyor scheme with frequency thinning (for FFT) and temporary thinning (for IFFT).  The algorithm uses a scheme of double parallelism.  This approach allows the processing of a continuous stream of complex samples from the ADC, the sampling frequency of which is 2 times higher than the processing clock frequency.  That is, the FFT ‚Äúbutterfly‚Äù performs a calculation for two complex samples at the same time.  If 4 or 8 times parallelism is used, then the data stream from the ADC or any other source can be processed at a frequency 4 and 8 times higher than the processing frequency.  Such schemes are often used in problems of the polyphase Fourier transform (Polyphase FFT) and are of particular interest. <br><br>  To save RAMB memory in the FPGA chip, starting from a certain stage of the FFT (at NFFT&gt; 4096 points), linear interpolation of the turning coefficients is used - decomposition into a Taylor series to the first derivative.  This allows instead of storing the entire set of coefficients to use only a part of them, and the rest to be obtained by approximate calculation from the original set.  By sacrificing the resources of the DSP48 primitives, the resources of the block RAMB are saved, which for FFT nodes is a critical place in any hardware implementation on the FPGA.  More on this will be discussed below. <br><br><h3>  Structural scheme </h3><br>  In the structure of the implemented FFT node, 3 functional nodes can be distinguished: data conversion from integer type to a special floating point format, an input buffer for recording signal samples, and an FFT core, which contains various complete special purpose nodes. <br><br>  Schematic view of the synthesized project: <i>Input buffer + FP converters + FFT Core</i> <br><br><img src="https://habrastorage.org/files/07e/578/f7d/07e578f7d97d4ec29d481701ed083487.png"><br><br>  To increase efficiency, all calculations are performed in a special 23-bit floating-point format FP23.  This is a progressive implementation of the FP18 and FP27 algorithms, on the basis of which all the logic is built.  The following features are characteristic of the FP23 format: the word width is 23 bits, the mantissa is 16, the exponents are 6 and the sign is 1. The FP23 format is specially adapted to the FPGA architecture and takes into account the internal features of the operation of crystal blocks such as the DSP48 universal digital processing unit and memory blocks RAMB18.  The use of the floating point format ensures high accuracy of signal processing with ADC regardless of their amplitude and allows you to avoid computational errors when scaling data inherent to systems with integer hardware computing with a limitation on the width of the calculations.  You can read about it <a href="https://habrahabr.ru/post/279269/">in my previous article</a> . <br><br>  The following figure shows the pipeline FFT calculation scheme for a sequence of length <i>N = 2 ^ n</i> .  It contains: <br><br><ul><li>  <b>Input buffer</b> - performs the initial data preparation at the FFT input (permutation of the samples, depending on the implementation and the used ADC scheme), </li><li>  <b>Rotation coefficients generators</b> - nodes of distributed and block memory, in which sine and cosine counts are stored, </li><li>  <b>The butterfly</b> is the basic operation of the FFT core (with frequency and time decimation), </li><li>  <b>Delay lines and cross</b> -connectors ‚Äî provide the input of ‚Äúbutterflies‚Äù of elements of the array being processed with the necessary indices. </li></ul><br><br><img src="https://habrastorage.org/files/b7f/f9c/358/b7ff9c3589684fa68df5ccfdfaa4511b.png"><br><br>  The FFT core conveyor is designed so that the data at its input must come in a <i>natural order</i> , and at the output of the FFT a data stream is formed in a <i>discharge-inverse order</i> .  For OBPF, the opposite is true - the input data are in <i>binary-inverse order</i> , and the output in natural or <i>natural order</i> .  This is the main advantage of this bundle of FFT and OBFT in comparison with ready-made cores from Xilinx, for which the input data must be strictly in natural order, and the output data depends on the enabled option. <br><br>  What is a binary-inverse order and how it is obtained from the natural order is clearly demonstrated by the following picture (for a sequence of N = 8 samples): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/98d/3ff/67a/98d3ff67adf94412bf702eaf84cece2e.png"></div><br><h3>  Input buffer </h3><br>  It is built on the distributed or internal memory of the FPGA crystal.  In the latest implementation, it is a memory, at the input of which N complex samples arrive, and at the output two N / 2 packs of samples are formed, and the first pack contains samples [0;  N / 2 -1], and in the second bundle [N / 2;  N-1].  In fact, the input buffer is the zero delay line for the FFT node and there is a primary permutation of the data in it. <br><br>  The VHDL source code for implementing buffer memory or delay lines is fairly simple and essentially implements dual-port memory: <br><br><pre><code class="vhdl hljs">PR_RAMB: <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(clk) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clk<span class="hljs-symbol"><span class="hljs-symbol">'event</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> clk = <span class="hljs-string"><span class="hljs-string">'1'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enb = <span class="hljs-string"><span class="hljs-string">'1'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ram_dout &lt;= ram(conv_integer(addrb)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ena = <span class="hljs-string"><span class="hljs-string">'1'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wea = <span class="hljs-string"><span class="hljs-string">'1'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ram(conv_integer(addra)) &lt;= ram_din; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>;</code> </pre> <br><h3>  Rotation coefficients generators </h3><br>  For each stage of the butterfly calculation, a different number of coefficients is needed.  For example, for the first stage only 1 coefficient is needed, for the second stage 2, for the third 4, etc.  proportional to the power of two.  In this regard, the turning factors are implemented on the basis of distributed (SLICEM) and internal (RAMB) FPGA memory in the form of ROM-memory, which stores the sine and cosine counts.  For economical storage is used reception, allowing to reduce memory resources.  It consists in the fact that with the help of a quarter of the sine and cosine period it is possible to construct the entire period of the harmonic signal using only operations with the sign and direction of the memory address.  If necessary, only one eighth of the coefficients can be stored, and the remaining sections can be obtained by switching the data source of harmonic signals between themselves and changing the direction of the counter.  In the current implementation, this does not bring performance gains and slightly saves the resource of block memory, and significantly increases the amount of logical resources of the crystal. <br><br>  Example of cosine shaping: <br><br><ul><li>  First quarter: counter address +1, counts cos, </li><li>  Second quarter: +1 address counter, -sin counts, </li><li>  Third quarter: address counter -1, count -sin, </li><li>  Fourth quarter: address counter -1, cos counts, </li></ul><br>  Simple logic on the multiplexers of the address and data counter allows saving FPGA memory 4 times. <br><br>  The coefficients are stored in an integer format of 16 bits and after they are retrieved from memory, they are transferred to the FP23 format.  I have evaluated performance for floating point and integer format.  Practice has shown that the first version saves the crystal memory <b>1.5 times</b> , while the performance of the entire core does not deteriorate, and the added delay in converting formats at some stages even brings some advantages (leveling the delays with the data and coefficients for the butterfly with frequency decimation). <br><br>  The rotation coefficients for small FFT lengths are stored in the distributed memory of the FPGA in the SLICEM cells up to the stage when it is necessary to store 512 complex samples with a total capacity of 32 bits.  For large FFT lengths, RAMB18 block memory is used, and for storing 1024 pairs of samples, only 2 RAMB18 blocks are needed, which is equivalent to 36 * 1K = 16 * 2 * 1K = 18K * 2. Note that 1024 coefficients are converted to 2048 using the described earlier method of partial data storage, and taking into account the double parallelism Radix-2, it allows you to serve the FFT with a length of NFFT = 4096 samples. <br><br>  For NFFT FFT lengths&gt; 4096 counts, the expansion of the coefficients in a Taylor series to the first derivative is used, which allows to calculate the turning coefficients with sufficiently high accuracy and save FPGA memory additionally.  We omit some theoretical calculations and proceed directly to the practical features of the calculation. <br><br>  For large values ‚Äã‚Äãof NFFT, the turning factors are not stored directly in the block memory of the FPGA, but are obtained by calculating using the Taylor method.  The calculated formulas for the real and imaginary parts of the turning factors in a simplified form are given below: <br><br><img src="https://habrastorage.org/files/0dc/903/431/0dc90343191f477492a3a53f45778955.png"><br><br>  In these formulas: <br><br>  A <sub>w</sub> - the amplitude of the turning factors (as a rule, A <sub>w</sub> = 2 <sup>16</sup> ), <br>  2 <sup>Nmax</sup> - the maximum number of turning factors limiting the use of FPGA block memory (in the current implementation, 2 <sup>Nmax</sup> = 2048, that is, Nmax = 12), <br>  k is the counter of all coefficient values ‚Äã‚Äãat the current FFT stage, k = 0 ... 2 <sup>Nmax</sup> ‚àô M-1, <br>  j - counter of intermediate values ‚Äã‚Äãof the coefficients at the current stage of the FFT, j = 0 ... M-1, <br>  M is a number depending on the stage of calculation, is defined as M = 2 <sup>stage</sup> , where stage is the number of the FFT stage. <br>  Re <sub>k</sub> , Im <sub>k</sub> - calculated values ‚Äã‚Äãof the turning factors. <br><br>  The figure shows a simplified scheme for implementing the calculation of coefficients according to the Taylor scheme (the address counter is used to extract coefficients from memory and mathematical operations with data) <br><br><img src="https://habrastorage.org/files/cd1/a61/c98/cd1a61c983bb48a49d3eb81cfdae06c6.png"><br>  Since the calculations of the turning coefficients are performed using mathematical operations and extracting data from the block memory, each stage of storing the coefficients occupies the resources DSP48 and RAMB18.  For the presented calculation formulas, an algorithm was written using 2 operations of multiplying harmonic functions and 1 operation of multiplying by the counter value, which is equivalent to 3 DSP48 blocks. <br><br>  If the Taylor scheme was not used in the core, then for each next stage the block memory resources would grow proportionally to degree 2. For 4096 samples, 4 RAMB primitives are expended, for 8192 samples - 8 primitives, etc.  When using the Taylor algorithm, the number of block memory primitives always <u>remains fixed</u> and equal to 2. <br><br>  The code for creating the sine and cosine coefficients is based on the VHDL function (you must use the MATH package).  The function is synthesized and successfully converts data into a 32-bit data vector in integer format. <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> rom_twiddle(xx : <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std_array_32xN <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span> pi_new : real:=<span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span> re_int : <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>:=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span> im_int : <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>:=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span> sc_int : std_array_32xN; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ii <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>**(xx-<span class="hljs-number"><span class="hljs-number">1</span></span>)-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> pi_new := (real(ii) * MATH_PI)/(<span class="hljs-number"><span class="hljs-number">2.0</span></span>**xx); re_int := <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>(<span class="hljs-number"><span class="hljs-number">32768.0</span></span>*COS( pi_new)); im_int := <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>(<span class="hljs-number"><span class="hljs-number">32768.0</span></span>*SIN(-pi_new)); sc_int(ii)(<span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-keyword"><span class="hljs-keyword">downto</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>) := <span class="hljs-built_in"><span class="hljs-built_in">STD_LOGIC_VECTOR</span></span>(CONV_SIGNED(im_int, <span class="hljs-number"><span class="hljs-number">16</span></span>)); sc_int(ii)(<span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">downto</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>) := <span class="hljs-built_in"><span class="hljs-built_in">STD_LOGIC_VECTOR</span></span>(CONV_SIGNED(re_int, <span class="hljs-number"><span class="hljs-number">16</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sc_int; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> rom_twiddle;</code> </pre> <br>  Table of resources for the implementation of turning factors: <br><br><img src="https://habrastorage.org/files/96e/e94/961/96ee94961bb14219b12b619ccc1439ba.png"><br><br><h3>  Butterfly </h3><br>  Each butterfly for FFT and OBPF uses 4 multipliers and 6 adders-subtractors, realizing the function of complex multiplication and addition / subtraction.  Of the functional blocks presented, only multipliers use DSP48 cells, 1 each.  From this it follows that only 4 DSP48 primitives per FFT butterfly.  Formulas for calculating butterflies with thinning in frequency and time are given in the sources above.  Butterflies are implemented quite simply.  Butterfly does not occupy resources of block memory.  The pitfall here is simple and easy to manage: you should take into account delays in the calculations in the process of calculating the data and unloading the turning coefficients Wn.  For the FFT and OBPF these delays are different! <br><br><img src="https://habrastorage.org/files/314/cef/c74/314cefc74ca04c04b476bd0d01d9469b.png"><br><br><h3>  Delay lines </h3><br>  Cross-switches and delay lines implement data swapping to the required order for each stage of the FFT.  The most detailed description of the permutation algorithm is given in the book of <b>Rabiner and Gold</b> !  Use distributed or block memory FPGA.  No tricks to save memory here, unfortunately, can not be done.  This is the most non-optimizable block and is implemented as it is. <br><br>  Table of resources for the implementation of delay lines in general: <br><br><img src="https://habrastorage.org/files/08e/9ec/4ff/08e9ec4ffce24bc4a8b98f8d710bd8c1.png"><br><br>  Let me take a picture from the book, which shows the process of binary rearrangement in the delay lines at different stages for NFFT = 16. <br><img src="https://habrastorage.org/files/8ca/236/77c/8ca23677c551496ba8ff15d9ec0b672d.png"><br><br>  In C ++, this algorithm is implemented as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt=<span class="hljs-number"><span class="hljs-number">1</span></span>; cnt&lt;stages+<span class="hljs-number"><span class="hljs-number">1</span></span>; cnt++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CNT_ii = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">2.0</span></span>,(stFFT-cnt)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CNT_jj = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">2.0</span></span>,(cnt<span class="hljs-number"><span class="hljs-number">-1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> jj=<span class="hljs-number"><span class="hljs-number">0</span></span>; jj&lt;CNT_jj; jj++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ii=<span class="hljs-number"><span class="hljs-number">0</span></span>; ii&lt;CNT_ii; ii++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> jN = ii+jj*(N_FFT/<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">2.0</span></span>,cnt<span class="hljs-number"><span class="hljs-number">-1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iN = N_FFT/(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">2.0</span></span>,cnt)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xx = jj*N_FFT/<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">2.0</span></span>,cnt); <span class="hljs-comment"><span class="hljs-comment">// mix data // -------- A, B, WW, IND[A], IND[B], IND[W] -------- // ButterflyFP(Ax, Bx, CFW, jN, jN+iN, ii*CNT_jj); } } }</span></span></code> </pre> <br>  The butterfly receives the <b>A</b> and <b>B</b> counts with the numbers <b>jN</b> and <b>jN + iN</b> , and the coefficients <b>WW</b> are received with the numbers <b>ii * CNT_jj</b> .  For a complete understanding of the process, it is enough to look at the binary permutation scheme and the example from the book. <br><br><h3>  Total resources </h3><br>  Further actions are quite simple - all nodes must be correctly connected to each other, taking into account delays in performing various operations (mathematics in butterflies, unloading coefficients for different stages).  If everything is done correctly, in the end result you will have a ready-made working core. <br><br>  The following table shows the resource calculation for the FP23FFTK FFT core and for the Xilinx FFT core (Floating point, Radix-2, Pipelined Streaming I / O options).  The table for the Xilinx core contains two columns of resources for block memory: <b>(1)</b> - without converting the order from binary inverse to natural ( <i>bitreverse output data</i> ) and <b>(2)</b> - with conversion ( <i>natural output data</i> ). <br><br><img src="https://habrastorage.org/files/6aa/395/49b/6aa39549be7442f7ad21b1b40666ac0b.png"><br><br>  As can be seen from the table, the FP23FFTK core is <b>2.5 times</b> smaller than the DSP48 primitives with NFFT = 64K, which is primarily due to the format of the data with the reduced mantissa and the exponent (FP23 vs FP32).  In addition, the kernel takes <b>2.5 times</b> less than the components of the block memory for the <i>bitreverse</i> option and <b>4 times</b> less for the <i>natural</i> option in the Xilinx core.  This can be justified by a truncated data format, but it gives a gain of only 1.5 times.  The remaining improvements are related to the storage characteristics of the turning factors and the use of the Taylor algorithm. <br><br>  Example: the Xilinx FFT core must accept input data in its natural order ( <b>kernel feature!</b> ), Therefore, for the FFT + OBPF bundle of Xilinx cores with NFFT = 64K, ~ 1600 block memory cells will be required, and for the same bundle in FP23FFTK format only ~ 400 cells RAMB, since OBPF is not required to translate data into a natural form, and at its output data is already in kind.  This feature allows you to build compact compression filters (a bunch of FFT + OBPF) on fast convolutions in small FPGA crystals without loss of performance! <br><br>  Below is the log of FFT core synthesis for NFFT = 65536 points: <br><br><img src="https://habrastorage.org/files/1b8/e42/6fa/1b8e426fa85a4f709861df5b5a318d8b.png"><br><br><h3>  Core performance </h3><br>  Due to the fact that I am limited in iron, the FFT core was tested only on two crystals: Virtex-6 (XC6VSX315T) and Kintex-7 (XC7K325T). <br><br>  For the FFT + OBPF bundle with NFFT = 64K counts on Xilinx FPGA Virtex-6 SX315T, it was possible to achieve stable filter operation at a frequency F <sub>dsp</sub> = <b>333 MHz</b> .  The Xilinx FFT core also worked at this frequency, but the amount of resources occupied was significantly higher. <br><br>  For the Kintex-7 FPGA, a stable multichannel circuit with independent filters is implemented with NFFT = 8K, the processing frequency is also equal to F <sub>dsp</sub> = <b>333 MHz</b> . <br><br>  Unfortunately, at frequencies above 333 MHz and on the FPGA of other families, the operation of the nodes was not checked. <br><br>  The table below shows the delays <b>in cycles</b> from the input to the kernel output (the full calculation of a packet of NFFT samples) for different FFT lengths.  As can be seen from the table, for Xilinx and here the results are disappointing.  With the help of the FP23FFTK kernel, it was possible to reduce the time for a complete FFT calculation by <b>~ 2.5 times</b> !  And if you also include a translation in the natural order in IP Xilinx, then the values ‚Äã‚Äãwill be even greater. <br><img src="https://habrastorage.org/files/afe/c0a/5a2/afec0a5a245b45f090aa0d0ab97b76d2.png"><br><br><h3>  Implementation examples on FPGAs </h3><br>  1. <b>4 channels direct FFT.</b>  FPGA: Virtex-6 SX315T (~ 1300 RAMB, ~ 1400 DSP48).  4x FP23FFTK, NFFT = 16K <br><br><img src="https://habrastorage.org/files/cd8/73e/110/cd873e110f024ec18df9ab0d9cc91836.png"><br><br><div class="spoiler">  <b class="spoiler_title">Other examples ...</b> <div class="spoiler_text">  2. <b>8 channels of compression (FFT + OBPF).</b>  FPGA: Virtex-6 SX315T (~ 1300 RAMB, ~ 1400 DSP48).  16x FP23FFTK, NFFT = 16K <br><br><img src="https://habrastorage.org/files/fd1/6db/ef8/fd16dbef8fee433ab65709774cef4f9c.png"><br><br>  3. FFT + OBPF 64K (large compression filter).  FPGA: XC7VX1140TFLG-2 (~ 3700 RAMB, ~ 3600 DSP48). <br><br><img src="https://habrastorage.org/files/8a1/600/d52/8a1600d520c04d729e864f7f9d402561.png"><br><br>  4. <b>Picture of random FFT layout</b> (resembles a butterfly): <br><br><img src="https://habrastorage.org/files/a2a/97e/640/a2a97e6400744e9696fb2c71be5d69f8.png"><br></div></div><br><h3>  Kernel check </h3><br>  For the simulation and debugging of the FFT core in floating point format on the FPGA, various development tools were used. <br><br>  <b>A)</b> Testing of the <b>RTL-model of</b> the FFT core was carried out using Xilinx Vivado and Aldec Active-HDL CAD systems.  Despite the high performance of Vivado, it has several drawbacks, one of which is poor code editing tools.  It seems that the product is constantly evolving, but some useful gadgets are still missing in the program, so the source code is written in Notepad ++, configured to work with VHDL / Verilog files.  Unlike Vivado, Active-HDL models much faster, and also allows you to save time diagrams after exiting the application.  Modelsim was not used for lack of license :) <br><br>  <b>B)</b> Testing of the <b>software model of</b> the FFT core was carried out in Microsoft Visual Studio, for which an application was written in C ++ that repeated the RTL model, but without delays and clock frequencies, which made it possible to quickly and effectively debug at different stages of design ( , commutation switching nodes, mathematical operations, the implementation of the Taylor algorithm and the complete core FFT). <br><br>  <b>C)</b> Full testing was carried out in Matlab / GNU Octave.  Scripts with various test signals were created for debugging, but the simplest <u>chirp signal</u> with different deviation, amplitude, offset, and other parameters turned out to be ideal for visual modeling.  It allows you to check the performance of the FFT in the whole part of the spectrum, in contrast to the harmonic signals.  When testing with sinusoidal signals, I fell into the trap several times, which is eliminated by the use of the chirp signal.  If I apply a sinusoidal signal of a certain frequency to the FFT input, then at the output I get a good harmonic at the desired frequency, but as soon as I change the period of the input sinusoid, errors occurred.  The nature of these errors in the process of debugging the RTL code was not easy to trace, but then I found the answer: incorrect delays in the butterfly nodes and turning factors at some stages of the calculations.  The use of the chirp signal eliminated this problem and allowed us to select the correct delays at each stage of the FFT calculation.  Also, using m-scripts, we compared the work of C ++ and RTL-models, and also checked the difference in calculations in the FP23 floating-point format and in the float / double format. <br><br><h3>  Testing algorithm </h3><br>  This process may seem somewhat routine, but it was in this sequence that I managed to ensure the correct operation of all the FFT nodes.  It may also help you if you use the kernel in your projects. <br><br>  <b>1.</b> Run the Matlab / Octave script to create a reference signal.  You can control the following variables: <br><br><ul><li>  NFFT is the FFT / OBPF length, the number of transform points, </li><li>  Asig - input signal amplitude (0-32767), </li><li>  Fsig is the frequency of the input signal, </li><li>  F0 is the initial chirp frequency (signal phase), </li><li>  Fm is the frequency of the chirp signal envelope (for a non-rectangular envelope), </li></ul><br>  As a result, two files are created (for the real and imaginary components), which are used in C ++ and RTL models. <br><br>  <b>2.</b> Create a project in Microsoft Visual Studio, taking the source code in C ++ in the appropriate directory. <br>  <b>3.</b> Build and run the project.  You can set the following variables in the h-file: <br><ul><li>  NFFT is the length of the FFT / OBPF (depends on the choice in claim 1), </li><li>  SCALE is a scaling factor that determines the range of numbers after converting data from the FP23 format to the INT16 format.  Values ‚Äã‚Äãrange from 0 to 0x3F. </li><li>  _TAY (0/1) - use the calculation of coefficients using the Taylor algorithm (for NFFT&gt; 4096). </li></ul><br>  <b>4.</b> Create an HDL project in a Vivado or Active-HDL environment, taking the source files to VHDL. <br>  <b>5.</b> Run the simulation using a file from the testbench directory.  You can set the following options in this file: <br><br><ul><li>  NFFT is the length of the FFT / OBPF (depends on the choice in claim 1), </li><li>  SCALE is a scaling factor that determines the range of numbers after converting data from the FP23 format to the INT16 format.  Values ‚Äã‚Äãrange from 0 to 0x3F. </li><li>  USE_SCALE (TRUE / FALSE) - use the calculation of the coefficients by the Taylor algorithm or the calculation of the coefficients directly (for NFFT&gt; 4096).  The return value for the _TAY variable from p.3. </li><li>  USE_FLY_FFT (TRUE / FALSE) - use of butterflies in the FFT core.  For debugging purposes, the option has remained, it does not carry any practical benefits. </li><li>  USE_FLY_IFFT (TRUE / FALSE) - the use of butterflies in the OBPF core. </li></ul><br>  <b>6.</b> Re-run the m-script (from item 1) to test the operation of the C ++ / RTL cores of the FFT and OBPF. <br><br>  After these magical actions are carried out, the graph of the input signal and the graphs of the signal passing through the FFT and OBPF nodes will be reflected on the screen.  To test only one FFT node, you need to take another m-script from the math directory and make some changes to the source files. <br><br>  Visual inspection of C ++ and RTL models (a bunch of FFT + OBPF): <br><br><img src="https://habrastorage.org/files/046/5df/37b/0465df37b6994e388082c73efbe46fdd.png"><br><br><div class="spoiler">  <b class="spoiler_title">FFT core test results</b> <div class="spoiler_text">  White Noise Chirp Test (Vivado Model) <br><img src="https://habrastorage.org/files/3df/dc7/f9f/3dfdc7f9f3484f399109978fbd960457.png"><br><br>  FFT input: <br><img src="https://habrastorage.org/files/1ef/e52/49c/1efe5249c1a54be092aeff24fe2ff34a.png"><br><br>  Another test example (input signal and FFT result): <br><img src="https://habrastorage.org/files/ca8/b97/5bd/ca8b975bd2034a8484996c664b12654c.png"><br><br>  Testing in hardware (debugging in ChipScope) on the Kintex-7 FPGA: <br><img src="https://habrastorage.org/files/eb8/4ff/c32/eb84ffc32e904916a7439e1059b01585.png"><br><br>  The filter operation is a compressed chirp pulse (there is no compression filter in the source codes of the implementation): <br><img src="https://habrastorage.org/files/8ec/929/f5f/8ec929f5fb864d93a01cf41a38779d99.png"><br></div></div><br><h3>  Features of the FFT core FP23FFTK </h3><br><ul><li>  Implementation at the level of gates and primitives Xilinx. </li><li>  Description Language - VHDL. </li><li>  NFFT transform length = 8-256K points. </li><li>  Flexible adjustment of NFFT conversion length. </li><li>  The specialized format of numbers in floating point is FP23, (the bit width of the mantissa is 16 bits). </li><li>  Scale output when converting to fixed point format. </li><li>  Compact storage of turning factors through expansion in a Taylor series to the first derivative. </li><li>  Storage of a quarter of the period of the coefficients in the distributed and block memory. </li><li>  Butterfly for FFT - time decimation, for OBPF - by frequency. </li><li>  FFT: input data - in the direct order, at the output in binary inverse. </li><li>  OBPF: input data in binary-inverse order, output - in the forward. </li><li>  Conveyor processing scheme with double parallelism.  <i>Radix-2</i> </li><li>  The minimum data burst is NFFT samples in continuous or block mode. </li><li>  High computation speed and small amount of resources. </li><li>  Significantly shorter delay time for full computation relative to existing cores. </li><li>  Implementation on the last FPGA crystals (Virtex-6, 7-Series, Ultrascale) </li><li>  No need for expensive bitreverse operation for FFT + OBPF bundle </li><li>  Open source. </li></ul><br><h3>  Source </h3><br>  All FP23FFTK FFT core kernel sources on VHDL (including basic operations in FP23 format), the C ++ test model and Matlab / Octave m-scripts are available <a href="https://github.com/capitanov/fp23fftk/">in my github profile</a> . <br><br><h3>  Future plans </h3><br>  Of course, the development of the project does not end there.  In my plans on the basis of already created models to make a lot of interesting and new, for example: <br><br><ul><li>  To increase the accuracy of calculations for large FFT lengths, implement the FP32 format (similar to IEEE-754), taking into account the FPGA features, the mantissa length is 25 bits. </li><li>  The FFT and OBPF nodes in the FP32 format, the length of NFFT = 256K and higher using the example of a compression filter. </li><li>  Polyphase FFT according to the scheme Radix-4, Radix-8, which will allow in the pipeline mode to process data streams from the ADC at very high frequencies. </li><li>  Ultra-long FFT scheme (based on 2D-FFT) using external memory for NFFT = 1M-256M points. </li><li>  <s>Rewrite source files on SystemVerilog.</s>  <s>Whether it is necessary?</s> </li></ul><br><h3>  Conclusion </h3><br>       ,        .      Xilinx  FP23FFTK <b></b>  ,    , ,    .  ,        FP23FFTK      ,        ! <br><br>              <u> </u> (   , ).   , , ,           .         ,    .    ,        ‚Äî       <b> </b> . ,    ++        ,               . <br><br> ,   -          .             (   ,     FP23  ..).   <a href="https://habrahabr.ru/users/dsmv2014/" class="user_link">dsmv2014</a> ,                      . <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/322728/">https://habr.com/ru/post/322728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322714/index.html">NetScaler Unified Gateway: a secure solution for applications through a single URL</a></li>
<li><a href="../322716/index.html">PyMC3 - MCMC and not only</a></li>
<li><a href="../322720/index.html">VLAN configuration on the routerOS operating system</a></li>
<li><a href="../322724/index.html">ClickHouse: very fast and very convenient</a></li>
<li><a href="../322726/index.html">DEV Labs 2017. Online conference for .NET developers. March 4</a></li>
<li><a href="../322730/index.html">What is the Tarantool IIoT platform?</a></li>
<li><a href="../322732/index.html">LED-it-GO - Data Security Risk</a></li>
<li><a href="../322734/index.html">Check-list: what is VDI or how to distinguish a real product from ‚Äúimport-substituted‚Äù crafts</a></li>
<li><a href="../322736/index.html">Travel Financial Transaction</a></li>
<li><a href="../322738/index.html">The role of the payment service in online transactions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>