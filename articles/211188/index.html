<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Algorithms of logic of the bot for the game "Minesweeper"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probably each of us ever played, or at least tried to play ‚ÄúMinesweeper‚Äù (‚ÄúMineSweeper‚Äù). The logic of the game is simple, but at one time they even p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Algorithms of logic of the bot for the game "Minesweeper"</h1><div class="post__text post__text-html js-mediator-article">  Probably each of us ever played, or at least tried to play ‚ÄúMinesweeper‚Äù (‚ÄúMineSweeper‚Äù).  The logic of the game is simple, but at one time they even promised a reward for the algorithm of its passing.  In my bot, logic has three algorithms that are used depending on the situation on the field.  The basic algorithm allows you to find all the cells with a 100% and 0% probability of finding a mine.  Using only this algorithm and opening random cells at random in the absence of a reliable solution in a standard sapper at the ‚ÄúExpert‚Äù level, 33% of winnings can be achieved.  However, some additional algorithms allow you to raise this value to 44% (Windows 7). <br><a name="habracut"></a><br><h4>  Main algorithm </h4><br>  The basic algorithm is as follows.  Unknown cells (Cell class) adjacent to one open cell are formed into a group (Group class), into which the value of the cell to which it is also attached is written. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b0/15d/5bd/6b015d5bd1c71c0c6eaf77e616577cb2.png"></div><br>  The figure shows four groups, some of which intersect, and some even contain other groups.  We denote (123,1) - the group consists of cells 1,2 and 3, and there is 1 mine in them.  (5678.2) - in four cells there are 2 mines. <br><br>  First you need to convert groups.  For this: <br><ol><li>  Compare each group with each subsequent group. </li><li>  If the groups are the same, then the second one is deleted. </li><li>  If one group contains the other, then subtract the larger from the larger one.  That is, there were two groups (5678.2) and (5.1), it became (678.1) and (5.1);  (2345.3) and (5.1) ‚Üí (234.2) and (5.1) </li><li>  Intersecting groups, for example (123.1) and (234.2), are transformed according to the following principle: <br><ol><li>  Create a new group of intersecting cells (23 ,?) </li><li>  We calculate the number of mines in the new group, equal to the number of mines in the group with a large number of mines (234.2) minus the remaining number of cells in another group after the separation of intersecting cells (1 ,?).  That is 2-1 = 1. We receive (23,1) </li><li>  If the calculated number of mines in the new group (23.1) is not equal to the number of mines in the group with a smaller number of mines (123.1), then stop the conversion </li><li>  Subtract the newly formed group from both intersecting groups.  (123.1) - (23.1) = (1.0), (234.2) - (23.1) = (4.1). </li><li>  Add a newly formed group to the list of groups </li></ol>  Thus (234.2) and (123.1) ‚Üí (1.0) and (23.1) and (4.1). <br></li><li>  Repeat from step 1 until no changes are made. </li></ol><div class="spoiler">  <b class="spoiler_title">Group creation and conversion method</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** *    ,     ,       ,  . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setGroups</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ groups.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) field[x][y].setGroup(groups); <span class="hljs-comment"><span class="hljs-comment">//   boolean repeat; do{ repeat=false; for (int i = 0; i &lt; groups.size() - 1; i++) { //     Group groupI = groups.get(i); for (int j = i + 1; j &lt; groups.size(); j++) { //       Group groupJ=groups.get(j); if (groupI.equals(groupJ)) //    {groups.remove(j--);break;} Group parent; //   Group child; //   if (groupI.size()&gt;groupJ.size()) //       -  {parent=groupI;child=groupJ;} else {child=groupI;parent=groupJ;} if (parent.contains(child)) { //     parent.subtraction(child); //      repeat=true; //     } else if (groupI.overlaps(groupJ) &gt; 0) { //     if (groupI.getMines()&gt;groupJ.getMines())//       -  {parent=groupI;child=groupJ;} else {child=groupI;parent=groupJ;} Group overlap = parent.getOverlap(child);//     if (overlap != null) { //      (      0%  100%) groups.add(overlap); //       parent.subtraction(overlap); child.subtraction(overlap); repeat=true; } } } } } while(repeat); }</span></span></code> </pre> </div></div><br>  As a result, we get three types of groups. <ul><li>  min number is zero </li><li>  the number of mines is equal to the number of cells in the group </li><li>  a non-zero number of mines is less than the number of cells in the group </li></ul>  Accordingly, all the cells from the first group can be safely opened, and from the second group can be marked.  This is the essence of the main algorithm. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  <b>If there is no reliable solution</b> </h5><br>  But often there are situations when there is no reliable solution to the situation.  Then the following algorithm comes to the rescue.  Its essence is to use the theory of probability.  The algorithm works in two stages: <ol><li>  Determination of probability in individual cells, taking into account the effect of several open cells </li><li>  Adjustment of probabilities, taking into account the mutual influence of groups with common cells on each other </li></ol>  Let us consider how this method works on the example of a situation where only two adjacent cells with values ‚Äã‚Äã4 and 2 are open. The probabilities of finding mines from cells 4 and 2 are individually equal to 4/7 = 0.57 and 2/7 = 0.28, respectively. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0dc/439/740/0dc4397405eeae78d164af438ac52f6c.png"></div><br>  To calculate the probability of finding a mine in a cell next to several open cells, we use the formula for calculating the probability of at least one event: <blockquote>  The probability of an event A, consisting in the occurrence of at least one of the events  <sub>1</sub> ,  <sub>2</sub> , ...,  <sub>n</sub> , independent in aggregate, is equal to the difference between the unit and the product of the probabilities of opposite events.  A = 1- (1-A <sub>1</sub> ) * (1-A <sub>2</sub> ) * .... * (1-A <sub>n</sub> ) </blockquote>  In adjacent cells after applying this formula, the result is 1- (1-0,57) * (1-0,28) = 0,69. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3a/058/e02/d3a058e02ac5cdbf422fd3f4dcf6b6cf.png"></div><br>  However, it should be remembered that the sum of probabilities in each group of cells must be equal to the number of mines in the group.  Therefore, all values ‚Äã‚Äãin each group need to be multiplied so that in the end their sum equals the number of minutes.  This number is equal to the number of mines in the group divided by the current sum of the probabilities of the cells of the group: <br><blockquote>  4 / (0.57 + 0.57 + 0.57 + 0.69 + 0.69 + 0.69 + 0.69) = 0.895 <br>  0.57 * 0.895 = 0.485 0.69 * 0.895 = 0.618 </blockquote><br>  Now those cells that had a probability of 0.57 have 0.485, and those that 0.69 ‚Üí 0.618 <br>  A similar calculation for the second group is carried out taking into account the adjustment from the previous one. <br><blockquote>  2 / (0.28 + 0.28 + 0.28 + 0.618 + 0.618 + 0.618 + 0.618) = 0.604 <br>  0.28 * 0.604 = 0.169 0.618 * 0.604 = 0.373 </blockquote><br>  We see that the probability in common cells has changed again, so this adjustment for each group needs to be repeated several times until the system comes to some stable values, which will be the true probabilities of finding mines in the cells. <br><blockquote>  4 / (0.485 + 0.485 + 0.485 + 0.373 + 0.373 + 0.373 + 0.373) = 1.357 <br>  0.485 * 1.357 = 0.658 0.373 * 1.357 = 0.506 <br>  2 / (0.169 + 0.169 + 0.169 + 0.506 + 0.506 + 0.506 + 0.506) = 0.79 <br>  0.169 * 0.79 = 0.134 0.506 * 0.79 = 0.4 </blockquote><br>  ‚Ä¶ etc. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6c/d6a/e60/d6cd6ae607e195e32c56a8c7672d80ab.png"></div><br>  It remains only to choose one of the cells with a minimum probability and make a move. <br><div class="spoiler">  <b class="spoiler_title">This method is in code.</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** *          ,          */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">correctPosibilities</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Map&lt;Cell,Double&gt;cells= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">//        ,          for (Group group : groups){ for (Cell cell: group.getList()){ Double value; if ((value=cells.get(cell))==null) //       cells.put(cell,(double) group.getMines()/ group.size()); //        else //    ,        cells.put(cell,Prob.sum(value,(double) group.getMines()/ group.size())); } } //      ,             boolean repeat; do{ repeat=false; for (Group group : groups){ //    List&lt;Double&gt; prob= group.getProbabilities(); //          Double sum=0.0; for (Double elem:prob)sum+=elem; //    int mines= group.getMines()*100; //        (- ) if (Math.abs(sum-mines)&gt;1){ //     ,    repeat=true; //    Prob.correct(prob,mines); //   for (int i=0;i&lt; group.size();i++){ //        double value= prob.get(i); group.getList().get(i).setPossibility(value); } } } } while (repeat); for (Cell cell:cells.keySet()){ //  if (cell.getPossibility()&gt;99)cell.setPossibility(99); if (cell.getPossibility()&lt;0)cell.setPossibility(0); } }</span></span></code> </pre></div></div><br><br><h5>  <b>Last moves</b> </h5><br>  At the final stage of the game, the number of unmarked mines plays an important role.  Knowing this amount, you can enumerate them in unknown cells, and mark the appropriate options.  In the process of searching for suitable options for each cell count the number of marks.  Dividing the resulting values ‚Äã‚Äãby the total number of marks, we obtain the probability of finding the min for each cell.  For example, in this situation, which seemed to have only one reliable solution, the last method (LastTurns) found 3 cells with a 0% probability of finding a mine. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e67/a7b/014/e67a7b0143081efb44308a3c281afa0e.png"></div><br>  LastTurns (9.21) checked 144 suitable combinations of 293930 possible and found 3 cells with a minimum probability of 0% <br><br>  From the point of view of the complexity of understanding an idea, this method is the easiest, so I will not analyze it in detail yet. <br><div class="spoiler">  <b class="spoiler_title">Its implementation</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** *      .          30 * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ArrayList&lt;Point&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLastTurns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minesLeft = countMinesLeft(); <span class="hljs-comment"><span class="hljs-comment">//     ArrayList&lt;Cell&gt; unknownCells = getUnknownCells(); //    int notOpened = unknownCells.size(); //    Integer[] combinations = new Sequence6().getSequensed(minesLeft, notOpened); //            ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); //    for (int i = 0; i &lt; combinations.length; i++) { //                 String combination = Integer.toBinaryString(combinations[i]); //      ,     if (combination.length() &lt; notOpened) { //    "0"    ,        String prefix = ""; for (int k = combination.length(); k &lt; notOpened; k++) prefix += "0"; combination = prefix + combination; } for (int j = 0; j &lt; notOpened; j++) { //      if (combination.charAt(j) == '1') unknownCells.get(j).setMine(); if (combination.charAt(j) == '0') unknownCells.get(j).setUnknown(); } if (test()) list.add(combination); //         ,       } clear(unknownCells); //       String[] comb = new String[list.size()]; list.toArray(comb); //    ,      int[] possibilities2 = new int[notOpened]; //     ,   ,        for (int i = 0; i &lt; comb.length; i++) //    possibilities2[] for (int j = 0; j &lt; notOpened; j++) if (comb[i].charAt(j) == '1') possibilities2[j]++; //        ,       1 int min = Integer.MAX_VALUE; ArrayList&lt;Integer&gt; minIndices = new ArrayList&lt;&gt;(); //       possibilities2[] for (int i = 0; i &lt; possibilities2.length; i++) { if (possibilities2[i] == min) minIndices.add(i); if (possibilities2[i] &lt; min) { min = possibilities2[i]; minIndices.clear(); minIndices.add(i); } unknownCells.get(i).setPossibility(100*possibilities2[i]/comb.length); //        } double minPossibility = 100.0 * possibilities2[minIndices.get(0)] / comb.length; System.out.println("LastTurns(" + minesLeft + "," + notOpened + ")  " + comb.length + "    " + combinations.length + "    " + minIndices.size() + " " + "    " + (int) minPossibility + " %"); ArrayList&lt;Point&gt; result = new ArrayList&lt;Point&gt;(minIndices.size());//       for (int index : minIndices) { result.add(unknownCells.get(index).getPoint()); } return result; }</span></span></code> </pre></div></div><br><br><h5>  <b>Conclusion</b> </h5><br>  In practice, with a sufficient number of samples, the calculated and actual values ‚Äã‚Äãof the probabilities of finding a mine in a cell almost coincide.  The following table shows the results of the bot on the Minesweeper under Windows XP for one night, where <ol><li>  Estimated% </li><li>  The total number of openings of cells with the calculated% </li><li>  Number of hits on a mine </li><li>  Actual% </li></ol><br><br><table><tbody><tr><th>  one. </th><td>  one </td><td>  2 </td><td>  3 </td><td>  four </td><td>  five </td><td>  6 </td><td>  7 </td><td>  eight </td><td>  9 </td><td>  ten </td><td>  eleven </td><td>  12 </td><td>  13 </td><td>  14 </td><td>  15 </td><td>  sixteen </td><td>  17 </td><td>  18 </td><td>  nineteen </td><td>  20 </td><td>  21 </td><td>  22 </td><td>  23 </td><td>  24 </td><td>  25 </td></tr><tr><th>  2 </th><td>  31 </td><td>  55 </td><td>  117 </td><td>  131 </td><td>  304 </td><td>  291 </td><td>  303 </td><td>  339 </td><td>  507 </td><td>  435 </td><td>  479 </td><td>  1201 </td><td>  152 </td><td>  146 </td><td>  118 </td><td>  143 </td><td>  164 </td><td>  141 </td><td>  367 </td><td>  3968 </td><td>  145 </td><td>  63 </td><td>  47 </td><td>  26 </td><td>  92 </td></tr><tr><th>  3 </th><td>  one </td><td>  four </td><td>  9 </td><td>  6 </td><td>  20 </td><td>  nineteen </td><td>  27 </td><td>  29 </td><td>  56 </td><td>  43 </td><td>  60 </td><td>  147 </td><td>  15 </td><td>  25 </td><td>  14 </td><td>  20 </td><td>  33 </td><td>  26 </td><td>  65 </td><td>  350 </td><td>  14 </td><td>  five </td><td>  12 </td><td>  four </td><td>  23 </td></tr><tr><th>  four. </th><td>  3 </td><td>  7 </td><td>  7 </td><td>  four </td><td>  6 </td><td>  6 </td><td>  eight </td><td>  eight </td><td>  eleven </td><td>  9 </td><td>  12 </td><td>  12 </td><td>  9 </td><td>  17 </td><td>  eleven </td><td>  13 </td><td>  20 </td><td>  18 </td><td>  17 </td><td>  eight </td><td>  9 </td><td>  7 </td><td>  25 </td><td>  15 </td><td>  25 </td></tr></tbody></table><br><table><tbody><tr><th>  one. </th><td>  26 </td><td>  27 </td><td>  28 </td><td>  29 </td><td>  thirty </td><td>  31 </td><td>  32 </td><td>  33 </td><td>  34 </td><td>  35 </td><td>  36 </td><td>  37 </td><td>  38 </td><td>  39 </td><td>  40 </td><td>  41 </td><td>  42 </td><td>  43 </td><td>  44 </td><td>  45 </td><td>  46 </td><td>  47 </td><td>  48 </td><td>  49 </td><td>  50 </td></tr><tr><th>  2 </th><td>  18 </td><td>  ten </td><td>  24 </td><td>  18 </td><td>  9 </td><td>  eleven </td><td>  6 </td><td>  135 </td><td>  eight </td><td>  2 </td><td>  four </td><td>  2 </td><td>  one </td><td>  3 </td><td>  sixteen </td><td></td><td>  2 </td><td>  2 </td><td></td><td></td><td>  one </td><td></td><td></td><td></td><td>  462 </td></tr><tr><th>  3 </th><td>  one </td><td>  9 </td><td>  2 </td><td>  3 </td><td>  3 </td><td>  2 </td><td>  one </td><td>  43 </td><td>  one </td><td>  0 </td><td>  one </td><td>  0 </td><td>  0 </td><td>  one </td><td>  four </td><td></td><td>  one </td><td>  one </td><td></td><td></td><td>  0 </td><td></td><td></td><td></td><td>  210 </td></tr><tr><th>  four. </th><td>  five </td><td>  37 </td><td>  eleven </td><td>  thirty </td><td>  33 </td><td>  18 </td><td>  sixteen </td><td>  31 </td><td>  12 </td><td>  0 </td><td>  25 </td><td>  0 </td><td>  0 </td><td>  33 </td><td>  25 </td><td></td><td>  50 </td><td>  50 </td><td></td><td></td><td>  0 </td><td></td><td></td><td></td><td>  45 </td></tr></tbody></table><br>  A large discrepancy in the region of 20‚Äì22% is probably due to the fact that often this percentage had cells that did not have a number already open (for example, at the beginning of the game), and Minesweeper adjusted to the player, sometimes removing the mine from under the opened cell.  The algorithm of work was implemented on java and tested on standard Windows sapper (7 and XP), application in VK and on gameplay.  By the way, after several days of ‚Äútechnical problems‚Äù when accessing my account from my IP, the game changed the remuneration rules for opening part of the field: initially returned 10% of the rate for 10% of the open field, then 5%, then 2%, and when I stopped playing, then returned 5%. </div><p>Source: <a href="https://habr.com/ru/post/211188/">https://habr.com/ru/post/211188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211170/index.html">Duplicity - backup with encryption</a></li>
<li><a href="../211174/index.html">OpenWrt + VPNclient for a router with 4mb ROM</a></li>
<li><a href="../211176/index.html">Protection against DDOS attacks using BGP</a></li>
<li><a href="../211182/index.html">Cicada 3301: a secret hacker community or just a game?</a></li>
<li><a href="../211184/index.html">Mice cried, pricked, but continued to gnaw cactus</a></li>
<li><a href="../211192/index.html">How mobile phones have changed the game industry</a></li>
<li><a href="../211194/index.html">An example of optimizing computing on CUDA</a></li>
<li><a href="../211198/index.html">Post news with a picture in the Vkontakte group (Perl)</a></li>
<li><a href="../211200/index.html">The problem of glass balls - the solution in general</a></li>
<li><a href="../211202/index.html">Unity3D multiplayer basics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>