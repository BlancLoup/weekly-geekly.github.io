<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to React Loadable</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr. I present to you a free translation of the article ‚ÄúIntroducing React Loadable‚Äù by James Kyle. In it, James tells what a component-oriented ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to React Loadable</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr.  I present to you a free translation of the article <a href="https://medium.com/%40thejameskyle/react-loadable-2674c59de178">‚ÄúIntroducing React Loadable‚Äù by</a> James Kyle.  In it, James tells what a component-oriented approach to code separation is and represents the Loadable library he developed, a tool that allows you to implement this approach in React.js applications. <br><br><img src="https://habrastorage.org/files/c65/062/4e2/c650624e2128425686dcb272628c0e31.png" alt="image"><br>  <i>Single build file and multiple file build</i> <br><br>  <i>From the translator: I allowed myself not to translate some verbs and terms commonly used in untranslated transliterated form (such as ‚Äúpreloader‚Äù and ‚Äúrendering‚Äù), I believe, they will be understood even by users who read only materials in Russian.</i> <br><a name="habracut"></a><br>  With the growth of the code base of your application, a moment comes when a single assembly file begins to negatively affect the speed of the initial page load.  Splitting code into multiple files and dynamically loading them solves this problem. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Modern tools, such as Browserify and Webpack, cope well with this task. <br><br>  In this case, you have to decide on what principle the code fragments will be combined into one file and how your application will learn about the successful loading of the next fragment and handle this event. <br><br><h2>  Route-oriented and component-oriented approach to code separation </h2><br>  Now almost universally used route-oriented approach.  Those.  Your code fragments are allocated in separate files based on the principle that the code in each file is necessary for the operation of a specific page (route) of your application.  And using this approach is quite logical, because clicking on the link, and then waiting for the page to load is a standard and familiar action for the user. <br><br>  But there is no limit to perfection, why not try to improve this approach? <br><br>  For applications on React.js, routing is just a component.  And this means that we can try to use a component-oriented approach to code separation. <br><br><img src="https://habrastorage.org/files/988/cdd/fb9/988cddfb968f45d3ab8bc41325f56950.png" alt="image"><br>  <i>Build with route-oriented and component-oriented approach</i> <br><br>  There is a mass of components whose code would be logical to allocate in a separate file.  Modal windows, inactive tabs and many other interface elements are initially hidden and may not appear on the page at all if the user does not take certain actions. <br><br>  So why do we have to load the code of these components (and, possibly, the code of third-party libraries to work with these components) immediately upon entering the page? <br><br>  At the same time, with a component-oriented approach, the separation of code according to the routes of the application also works great, because, as we mentioned above, the route is just a component.  So just do what's best for your application. <br><br>  And of course, you would like to implement a component-oriented separation of the code did not have to spend a lot of effort.  To select a component in a separate code fragment, it was enough to change a few lines in your application, and other ‚Äúmagic‚Äù would be executed ‚Äúunder the hood‚Äù without your participation. <br><br><h2>  Introduction to React Loadable </h2><br>  I wrote a small library - React Loadable, which allows you to do everything exactly as you want. <br><br>  Suppose we have two components.  We import the component <code>AnotherComponent</code> and use it in the <code>render</code> method of the component <code>MyComponent</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AnotherComponent <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./another-component'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">AnotherComponent</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>; } }</code> </pre><br>  Now import happens synchronously.  We need a way to make it asynchronous. <br><br>  This can be done using <a href="https://github.com/tc39/proposal-dynamic-import">dynamic imports</a> .  <code>MyComponent</code> code so that <code>AnotherComponent</code> asynchronously. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">AnotherComponent</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; componentWillMount() { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./another-component'</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AnotherComponent</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ AnotherComponent }); }); } render() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {AnotherComponent} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!AnotherComponent) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Loading...</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">AnotherComponent</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>; }; } }</code> </pre><br>  However, such an implementation of asynchronous loading requires rather massive changes in the component code.  But we have not yet described the case if the dynamic import fails.  But what if we also need to render the application on the server side (server-side rendering)? <br><br>  Using <code>Loadable</code> is a higher order component <i>(if you work with react.js, you probably know this term and the principle of using such components, if not, read the <a href="https://facebook.github.io/react/docs/higher-order-components.html">relevant section of the documentation</a> , or just note that this is a function that accepts the react component input, and on its basis returns a new component, with advanced behavior - note.)</i> from my library you can abstract away from all these problems. <br><br>  <code>Loadable</code> works extremely simple. <br><br>  The minimum that you need is to transfer to <code>Loadable</code> an object with <code>loader</code> properties ‚Äî a function that performs dynamic component import and <code>LoadingComponent</code> ‚Äî the component that will be shown during the loading process. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Loadable <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-loadable'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLoadingComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Loading...</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LoadableAnotherComponent = Loadable({ <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./another-component'</span></span>), <span class="hljs-attr"><span class="hljs-attr">LoadingComponent</span></span>: MyLoadingComponent }); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LoadableAnotherComponent</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>; } }</code> </pre><br>  But what happens if the component load fails? <br><br>  We will need to somehow handle the error and notify the user. <br>  If an error occurs, it will be passed to LoadingComponent as a property of the component (prop). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLoadingComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ error }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Error!</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Loading...</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre><br>  Webpack of the second version can work out of the box with dynamic imports - select the code that is connected via dynamic imports into separate files and load them in runtime.  This means that you can easily experiment and select the code separation scheme that is optimal for the performance of your application. <br><br>  You can see the working example by running the <a href="https://github.com/thejameskyle/react-loadable-example">demo project from my repository</a> .  And if you want to understand in detail how Webpack 2 works with dynamic imports, check out the <a href="https://webpack.js.org/guides/code-splitting-import/">following</a> <a href="https://webpack.js.org/guides/code-splitting-require/">sections of</a> its official documentation. <br><br><h2>  Preventing "pre-boot blinking" component </h2><br>  Under certain conditions, component loading can occur very quickly (in less than 200 milliseconds);  This will lead to a brief appearance on the screen of the preloader component, which will instantly be replaced by the loaded component.  The user's eye will not have time to see the preloader, it will only notice a certain ‚Äúflicker‚Äù before loading the component. <br><br>  A number of studies have shown that with this behavior, the user subjectively perceives the loading time longer than it actually happens.  Those.  for this case, it is better not to show the preloader at all, but just wait for the component to load. <br><br>  <code>MyLoadingComponent</code> also has the property <code>pastDelay</code> which is set to <code>true</code> at the time when 200 milliseconds pass from the beginning of the component download <i>(I see that this solution is not fully working - after all, if the component is loaded for 400 milliseconds, then after 200 millisecond waiting, the preloader will seem on the screen for the same 200 milliseconds - the interpreter's thoughts)</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyLoadingComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ error, pastDelay }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Error!</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pastDelay) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Loading...</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre><br>  The value 200 milliseconds is used by default, but you can change it by specifying the appropriate property: <br><br><pre> <code class="javascript hljs">Loadable({ <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./another-component'</span></span>), <span class="hljs-attr"><span class="hljs-attr">LoadingComponent</span></span>: MyLoadingComponent, <span class="hljs-attr"><span class="hljs-attr">delay</span></span>: <span class="hljs-number"><span class="hljs-number">300</span></span> });</code> </pre><br><h2>  Preload </h2><br>  For further optimization, you can also preload the component so that by the time it is necessary to show the component on the page, its code has already been loaded.  For example, you should show the component on the page after clicking on the button.  In this case, you can start downloading the file with the code of this component as soon as the user moves the cursor over this button. <br><br>  The component created by calling the <code>Loadable</code> function provides a static <code>preload</code> method for this purpose. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> LoadableMyComponent = Loadable({ <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./another-component'</span></span>), <span class="hljs-attr"><span class="hljs-attr">LoadingComponent</span></span>: MyLoadingComponent, }); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">showComponent</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; onClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">showComponent</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); }; onMouseOver = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { LoadableMyComponent.preload(); }; render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.onClick}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onMouseOver</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.onMouseOver}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Show loadable component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {this.state.showComponent &amp;&amp; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LoadableMyComponent</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span><span class="xml">} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) } }</code> </pre><br><h2>  Server side rendering </h2><br>  My library also supports server-side rendering. <br><br>  To do this, in the object passed as an argument to the <code>Loadable</code> function in the <code>Loadable</code> property, <code>serverSideRequirePath</code> must specify the full path to the component. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'path'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LoadableAnotherComponent = Loadable({ <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./another-component'</span></span>), <span class="hljs-attr"><span class="hljs-attr">LoadingComponent</span></span>: MyLoadingComponent, <span class="hljs-attr"><span class="hljs-attr">delay</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">serverSideRequirePath</span></span>: path.join(__dirname, <span class="hljs-string"><span class="hljs-string">'./another-component'</span></span>) });</code> </pre><br>  In this case, if the page on which the component is present will be rendered on the server side, the component will be loaded synchronously, and if on the client side, it will be asynchronous. <br><br>  In this case, in the server code we have to solve the problem of assembling a common script file that will be connected from the initially loaded html file. <br><br>  As noted above, if we want the component to be rendered on the server side, then the <code>serverSideRequirePath</code> property of the <code>serverSideRequirePath</code> object specifies the full path to the module defining this component.  The function <code>Loadable</code> is available in the <code>flushServerSideRequires</code> , the call of which returns an array from the paths to all the modules of the loadable components of the current page.  When you run a Webpack with the <code>--json</code> flag <code>--json</code> upon completion of the build, an <code>output-webpack-stats.json</code> file will be created <code>output-webpack-stats.json</code> stores detailed information about the build.  Using this data we will be able to calculate which pieces of the assembly are necessary for the current page and connect them via <code>script</code> tags in the html file of the generated page (see the <a href="https://gist.github.com/thejameskyle/abecfe8ec2a7ce1e312a904527a31908">sample code</a> ). <br><br>  There remains the last, not yet solved task - to configure the Webpack so that it can resolve all this on the client.  Sean, I will be waiting for your message after the publication of this article <i>(here the author refers to Sean Larkin - the creator and main metainter of the Webpack project. Today, already completing the translation, I came across <a href="https://twitter.com/thejameskyle/status/848719758807650304">this tweet</a> and, as I understand it, this problem was solved And the implementation of server-side rendering is even more simplified</i> . <br><br>  Potentially, I can imagine a lot of tools and technologies, the use of which in conjunction with my library can make your applications even more cool.  For example, with <a href="https://github.com/acdlite/react-fiber-architecture"><code>React Fiber</code></a> we can not only dynamically load the component code, but also implement ‚Äúsmart‚Äù rendering - i.e.  determine the priority, which parts of the loaded component should be rendered first, and which parts should be postponed,  only after the rendering of the higher priority elements has been completed. <br><br>  In conclusion, I urge everyone to install and try my library, and also put Star to its <a href="https://github.com/thejameskyle/react-loadable">repository on github</a> . <br><br><pre> <code class="javascript hljs">yarn add react-loadable # or npm install --save react-loadable</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/325688/">https://habr.com/ru/post/325688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325676/index.html">Huawei USG 6300. Basic firewall configuration out of the box</a></li>
<li><a href="../325678/index.html">Write on C as a gentleman</a></li>
<li><a href="../325682/index.html">The fraudster pulled out of two companies $ 100 million with the help of social engineering</a></li>
<li><a href="../325684/index.html">"Do not think about support down": how to realize the hidden features of your support service</a></li>
<li><a href="../325686/index.html">Orange pi one</a></li>
<li><a href="../325690/index.html">Why I abandoned multiple monitors</a></li>
<li><a href="../325692/index.html">MakiseGUI - a free graphical user interface library for microcontrollers</a></li>
<li><a href="../325694/index.html">How IT professionals work. Fedor Bykov, Director of Research and Development at PROMT</a></li>
<li><a href="../325696/index.html">Introduction to the magical world of payment mediation</a></li>
<li><a href="../325700/index.html">Practical experience using this HotSwap</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>