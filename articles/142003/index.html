<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unbiased rendering (rendering without assumptions)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In computer graphics, rendering without assumptions refers to a rendering technique that does not include systematic errors, assumptions, or errors in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unbiased rendering (rendering without assumptions)</h1><div class="post__text post__text-html js-mediator-article"> In computer graphics, <a href="http://en.wikipedia.org/wiki/Unbiased_rendering">rendering without assumptions</a> refers to a rendering technique that does not include systematic errors, assumptions, or errors in the calculation.  The image is obtained as it should be in nature, and the render has no quality settings for surfaces or light sources. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/265/c55/caf/265c55caf2ee64eaa69855499a9fe302.png"><br>  Image rendered using Maxwell Render. <br><br><a name="habracut"></a><br>  <b>Let's start with the bad</b> <br>  When the Anbias came into being, they were poorly optimized, and the iron was much weaker.  Even quad-cores were rare, at least in the CIS.  Many designers have refused such renders due to the fact that they had to wait too long for the noise from the image to disappear.  Many professionals find it much easier to <a href="">set up</a> global lighting in Vray and do post-processing in Photoshop as a whole in 2-3 hours, than to press the ‚Äúrender‚Äù button in Maxwell and wait for an acceptable quality of, say, 8 (and more) hours.  Sometimes the noise from any refraction did not want to go for days. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>And what is good about them?</b> <br>  Physically accurate effects: <br>  - <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BB%25D0%25BE%25D0%25B1%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BE%25D1%2581%25D0%25B2%25D0%25B5%25D1%2589%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">global illumination</a> , (including <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2583%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0">caustic</a> ); <br>  - <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BB%25D1%2583%25D0%25B1%25D0%25B8%25D0%25BD%25D0%25B0_%25D1%2580%25D0%25B5%25D0%25B7%25D0%25BA%25D0%25BE_%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B0%25D0%25B5%25D0%25BC%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25B0">Depth of field</a> (DOF) and <a href="http://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B5%25D0%25B2%25D0%25B5%25D0%25BB%25D1%2591%25D0%25BD%25D0%25BA%25D0%25B0">shake</a> (Motion Blur); <br>  - <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B4%25D0%25BF%25D0%25BE%25D0%25B2%25D0%25B5%25D1%2580%25D1%2585%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2580%25D0%25B0%25D1%2581%25D1%2581%25D0%25B5%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">subsurface scattering</a> ; <br>  - some renders even support <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D1%2581%25D0%25BF%25D0%25B5%25D1%2580%25D1%2581%25D0%25B8%25D1%258F_%25D1%2581%25D0%25B2%25D0%25B5%25D1%2582%25D0%25B0">dispersion</a> ; <br>  - soft shadows, realistic reflections, in general, everything is like in life. <br><br>  All these effects we see from the first seconds of rendering. <br>  The rendering time depends little on the number of triangles, this makes it possible not to save resources on their number. <br><br>  Plus, the hardware is not in place, the processor performance is gradually increasing, and more interestingly, with the development of general-purpose computing technology on graphics cards ( <a href="http://ru.wikipedia.org/wiki/GPGPU">GPGPU</a> ), renderers began to appear, which use the GPU shader cores for computing.  And the renders themselves began to give the best picture at the same computational cost. <br><br>  <b>Let's see</b> <br>  what the rendering process looks like: <br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/ff1/308/ab4ff1308709b0e3efb18f222e35f43b.jpg"><br>  Core i5 2500 3.3GHz, Maxwell Render 2.6, 400k triangles, personally created in 3ds Max model. <br><br>  At the heart of anbias renders is Path Tracing with various types of optimization. <br>  <i>(Maybe some visitors noticed that I already <a href="http://habrahabr.ru/post/132862/">published</a> and <a href="http://habrahabr.ru/post/132904/">published</a> posts about tracing the path to the GPU. But I decided to cover the topic more deeply and extensively.)</i> <br>  *** <br><br>  <b>ALGORITHM</b> <br><br>  Path Tracing (PT) is based on Monte Carlo integration.  The more samples we calculate per pixel (pixel color = arithmetic average of the colors of all samples at this point) - the more accurate the result will be. <br>  A sample (sample) is the rays that, after passing the path of reflections and refractions through the scene (from the camera to the light source), forms the color of the pixel to be painted at a certain point in the image. <br>  Preview of the image (noisy image) we get almost immediately after voxelization (about it later). <br><br>  The number of samples can not be infinite.  The ‚Äúperfect‚Äù picture will never be; it will take an infinite amount of time.  Rendering can be considered complete if the noise is not distinguishable by eye.  (usually 1000 - 10000 samples per pixel, or 2-20 billion samples per image of FullHD format, in special cases - even more).  Nor should we forget that a slight noise makes the image realistic. <br><br>  The more complex the paths that the rays travel, the slower the noise will go. <br>  The easiest way to render light sources.  Rays from light sources directly into the camera. <br>  It is more difficult to render objects illuminated by direct rays from light sources. <br>  Even more difficult - objects illuminated by another object, illuminated by a light source. <br>  And so on.  This feature makes the rendering of interiors more difficult than exteriors, for the simple reason that in the interiors more computing resources are used to calculate complex paths. <br><img src="https://habrastorage.org/getpro/habr/post_images/ea6/6ff/17d/ea66ff17dc399d3dbed08ecc4ab5c6af.jpg"><br>  From left to right, direct light, first reflection, second reflection, third reflection, result. <br><br>  The maximum depth of reflections and refractions in most renders is adjustable, and is equal to 8 by default. <br>  In some (eg Maxwell, Fry) the depth of reflections is limited by a much larger number, and depends on the parameters of the surfaces.  For example, it does not make sense to calculate a large depth of reflections for a dark brown table, while in order to calculate the refractions inside the glass it is required to increase the depth of reflections. <br><br>  <b>Soft shadows</b> <br>  The algorithm for obtaining soft shadows in PT is quite simple.  The beam emanating from the camera towards a point on the surface is directed to an arbitrary place (the degree of ‚Äúarbitrariness‚Äù depends on the parameters of the given surface) on the light source. <br>  If the beam has safely reached the light source (green), then we paint this pixel in the desired color. <br>  If the beam met an obstacle on the way (red), then the corresponding pixel on the screen is not painted over. <br>  <i>(By the way, the algorithm is similar to rendering shadows in raytracing)</i> <br><img src="https://habrastorage.org/getpro/habr/post_images/660/d77/094/660d7709445c3c0bf64ba0fbd812d73e.png"><br>  Number of samples per pixel: on the left - 1, on the right - 5. <br>  For example, for clarity, there are no secondary reflections. <br><br>  <b>Reflections and refractions</b> <br>  <a href="http://ru.wikipedia.org/wiki/BRDF">Reflective function</a> depends primarily on the degree of roughness.  And the degree of roughness is determined by the magnitude of the deviation error from the reflected beam. <br><img src="https://habrastorage.org/getpro/habr/post_images/00a/549/223/00a549223f712dd3cdf1df2a26f05c70.png"><br><br>  If the degree of deviation = 0 - then we get a mirror image.  If 1 <i>(or 100%)</i> - then the incident beam can be reflected in any direction.  From 0 to 1 we get a reflection of varying degrees of roughness. <br><img src="https://habrastorage.org/getpro/habr/post_images/be2/dab/f38/be2dabf38d5fa405baaf5230a822592d.jpg" title="Degree of roughness"><br>  The degree of surface roughness (from 0 to 1). <br>  Reflective function may be more complex (for example, an <a href="">anisotropic surface</a> ). <br><br>  The refractiveness roughness algorithm is similar to reflections, only the beam penetrates into the object, changing its direction in accordance with the refractive index of this object. <br><br>  <b>Materials</b> <br>  Materials, as a rule, consist of several layers. <br><img src="https://habrastorage.org/getpro/habr/post_images/731/77e/982/73177e98282581f41c02c8579658efff.png" title="Overlay layers"><br>  Simplified plastic surface models. <br>  In many anbias renderers (Maxwell, Fry, Indigo, Lux) it is possible to calculate the present subsurface scattering.  Some of the rays pass and scatter below the surface, which makes its own adjustment to the resulting image. <br><br>  <b>Depth of field</b> <br>  The effect known in photography is achieved in PT with little or no computational overhead. <br><img src="https://habrastorage.org/getpro/habr/post_images/6f0/2c6/07f/6f02c607fda0f84eba62d19ced52793e.png"><br>  *** <br><br>  <b>OPTIMIZATION METHODS</b> <br><br>  <b>Importance sampling</b> <br>  ‚ÄúImportant Sampling‚Äù requires that the computer does not waste computing power on ‚Äúclean‚Äù areas.  Often, surfaces that are ‚Äúcleaned‚Äù are illuminated by direct light, while areas illuminated by refracted or reflected light remain noisy for a very long time. <br><img src="https://habrastorage.org/getpro/habr/post_images/ff1/92e/c6e/ff192ec6eb0bbb055cda093cb1752d6b.jpg" title="Jug with life-threatening handle"><br>  Areas highlighted in red have increased noise. <br><br>  <b>Bidirectional path tracing</b> <br>  PT in its pure form is used very rarely.  The probability that the rays emanating from the virtual camera reach the source is very small and highly dependent on the size of the light source.  The smaller the light source, the more difficult it is for the beam to ‚Äúget‚Äù into it. <br>  The BDPT algorithm emits rays simultaneously from the light source and from the camera.  This allows you to ‚Äúpainlessly‚Äù bring even point sources of light into the scene. <br>  Used in most unbiased GPU renders. <br><br>  <b>Metropolis Light Transport</b> <br>  The MLT mutant ray algorithm makes it possible to achieve less noise with the same number of samples.  The algorithm retains the ‚Äúnodes‚Äù (reflection points) of those rays that have strongly influenced the resulting image, and produces minor deviations from the original direction of the beam.  Also, may introduce additional nodes in the path of the beam.  After, it checks how strongly the change in direction influences the intensity of the beam, and determines whether to make further mutations of this beam. <br>  Used in all unbiased renderers using a CPU. <br>  <i>(There is another method for optimizing mutating rays - Energy Redistribution Path Tracing, but it is not used everywhere, and there is little information about it.)</i> <br><br>  How it works, you can look at the video more clearly (MLT vs BDPT). <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/AFJihgfocno%3Ffeature%3Doembed&amp;xid=25657,15700019,15700186,15700191,15700253,15700255,15700259&amp;usg=ALkJrhiSIg3xUMB2_7uOOC2hkSjPLW4-AQ" frameborder="0" allowfullscreen=""></iframe><br><br>  Here we can see the effectiveness of each of the rendering optimization methods. <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/GMDfy_B0rvQ%3Ffeature%3Doembed&amp;xid=25657,15700019,15700186,15700191,15700253,15700255,15700259&amp;usg=ALkJrhjazoW-TDghQgF8aBD6N-asZCw6hg" frameborder="0" allowfullscreen=""></iframe><br><br>  <b>Voxelisation</b> <br>  Before rendering, voxelization is necessary so that the program does not check all triangles for the possibility of intersection with one ray.  The algorithm discards those areas of space, the triangles in which can not be in the path of the beam. <br>  Objects must be voxelised each time a change occurs in the geometry, or new objects are added.  But it is not necessary when moving the camera, changing the materials of objects or the environment. <br>  In addition, you can enter a voxel rendering algorithm in PT. <br>  *** <br><br>  <b>GPU</b> <br>  Due to the fact that modern graphics processors cope with <a href="http://ru.wikipedia.org/wiki/Float">float</a> computing much better than CPU, the trace of the path is gradually placed on their shoulders. <br><br>  <b>Real-time rendering</b> <br>  Enthusiasts have already started creating games that use PT.  <a href="http://code.google.com/p/sfera/downloads/list">You can try the</a> game <a href="http://code.google.com/p/sfera/downloads/list">yourself</a> (using OpenCL) if you have a powerful enough card <i>(you can try playing on the CPU, but it will slow you down a lot)</i> . <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/Dh9uWYaiP3s%3Ffeature%3Doembed&amp;xid=25657,15700019,15700186,15700191,15700253,15700255,15700259&amp;usg=ALkJrhg-13D20CoxfdZ_4pcmGtYisAdPkw" frameborder="0" allowfullscreen=""></iframe><br><br>  The author of the following video (I <a href="http://raytracey.blogspot.com/">recommend to watch his website</a> ) states that in the near future the PT engine will be used in games.  Rendered this video using 2 GTX580 in real time. <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/gZlCWLbwC-0%3Ffeature%3Doembed&amp;xid=25657,15700019,15700186,15700191,15700253,15700255,15700259&amp;usg=ALkJrhgox0DgKGsCnmldr3DF_pFSRiWpaQ" frameborder="0" allowfullscreen=""></iframe><br><br>  <b>How to use a GPU</b> <br>  CUDA - software and hardware architecture allows you to compile C ++ and perform calculations on Nvidia video cards. <br>  ATIFirestream is the same for ATI cards only. <br>  OpenCL - a framework for computing on all OpenCL-compatible (most modern CPU and GPU) devices. <br>  DirectCompute is a framework from Microsoft, supported by video cards with DX10, 11 support. <br>  GLSL is a shader programming language that works on all graphics accelerators. <br><br>  The following video demonstrates the speed of computing physics using various programming platforms.  And physics, like graphics, requires good performance of floating point operations, so I think this video is applicable to this article. <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/aJCcqa87ZsQ%3Ffeature%3Doembed&amp;xid=25657,15700019,15700186,15700191,15700253,15700255,15700259&amp;usg=ALkJrhiHK_6IaSAJ4-Bz1_sd71izzwE9YA" frameborder="0" allowfullscreen=""></iframe><br>  ( <i>GLSL demonstrates speed at CUDA level, why then does not PT exist on GLSL?</i> ) <br>  *** <br><br>  <b>AND A BIT MORE</b> <br><br>  <b>The most famous anbias renders:</b> <br>  <a href="http://www.maxwellrender.com/">Maxwell Render is the</a> most popular unbiased render. <br>  <a href="http://www.indigorenderer.com/">Indigo</a> has a GPU analogue IndigoRT. <br>  <a href="http://www.randomcontrol.com/fryrender">FryRender</a> render from RandomControl, has a GPU analogue - Arion Render. <br>  <a href="http://www.luxrender.net/en_GB/index">LuxRender</a> open source render, has GPU acceleration support.  The site can also be found completely GPU render - SmallLuxGPU. <br>  <a href="http://www.refractivesoftware.com/">Octane Render</a> fully GPU render. <br>  <a href="http://www.mentalimages.com/products/iray.html">iRay</a> is in the box with the latest 3ds Max, uses CUDA and a processor. <br>  <a href="http://www.blender.org/download/get-blender/">Cycles Render</a> (built into Blender, supports both CUDA and OpenCL). <br><br>  <b>Popular misconception</b> <br>  There is a popular misconception that the V-Ray RT is the anbias renderer.  No, it is not.  This is <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B0%25D1%2581%25D1%2581%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D0%25BB%25D1%2583%25D1%2587%25D0%25B5%25D0%25B9">raytracing</a> with adaptive <a href="http://www.ixbt.com/video2/reactor-articles/glossary.shtml">anti-aliasing</a> .  Of course, sampling and rendering of shadows is similar to the path tracing algorithm.  But global illumination and caustics remain subject to the general settings of the time, and they must be configured for each specific case. <br>  The same goes for Bunkspeed Hypershot and Luxeon Keyshot (earlier versions, before switching to iRay). <br><br>  <b>Let's sum up:</b> <br>  V-Ray Oldfags will say that they can do all the beauty in Virey, and they will be right.  After all, render is not the main thing.  The main thing - an artist with a head, smooth hands and creativity in the soul! <br>  But unbiased renders can help us not pay attention to the technical settings of the render, but focus on the creative process. </div><p>Source: <a href="https://habr.com/ru/post/142003/">https://habr.com/ru/post/142003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../141995/index.html">The Magic Repository: Integrating Spring Data-JPA and Google Guice</a></li>
<li><a href="../141996/index.html">Cache + jQuery. Fast start</a></li>
<li><a href="../141997/index.html">Area for Moscow</a></li>
<li><a href="../141999/index.html">Building effective business systems. Chapter 1: Introduction</a></li>
<li><a href="../142002/index.html">Viva France! "The law on inaccessible books of the twentieth century"</a></li>
<li><a href="../142005/index.html">Personal experience with Jive SBS 5.0.2</a></li>
<li><a href="../142006/index.html">Linux Tycoon: Distribution Building Simulator</a></li>
<li><a href="../142007/index.html">Canon announced the imminent release of 2 cameras capable of shooting 4K video: EOS-1D C and EOS C500</a></li>
<li><a href="../142008/index.html">US Supreme Court announces: Congress may pass privatization laws in public domain</a></li>
<li><a href="../142011/index.html">How to make customers permanent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>