<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Guide to magical methods in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a translation of the 1.17 version of the manual from Rafe Kettler. 


 Content 


1. Introduction 
2. Design and initialization 
3. Redefiniti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Guide to magical methods in Python</h1><div class="post__text post__text-html js-mediator-article">  This is a translation of the 1.17 version of the <a href="http://www.rafekettler.com/magicmethods.html">manual</a> from Rafe Kettler. <br><br><br><h2>  Content </h2><br><ol><li>  <a href="http://habrahabr.ru/post/186608/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Design and initialization</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Redefinition of operators on arbitrary classes</a> <ul><li>  <a href="http://habrahabr.ru/post/186608/">Magic methods of comparison</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Numeric magic methods</a> </li></ul></li><li>  <a href="http://habrahabr.ru/post/186608/">Introducing your classes</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Attribute Access Control</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Creating arbitrary sequences</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Reflection</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Called Objects</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Context managers</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Abstract base classes</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Building descriptors</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Copying</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Using the pickle module on your objects</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Conclusion</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Appendix 1: How to invoke magic methods.</a> </li><li>  <a href="http://habrahabr.ru/post/186608/">Appendix 2: Changes in Python 3</a> </li></ol><br><br><h2><a name="intro"></a>  Introduction </h2><br>  What are magical methods?  They are all in object-oriented Python.  These are special methods by which you can add "magic" to your classes.  They are always framed by two underscores (for example, <code>__init__</code> or <code>__lt__</code> ).  Also, they are not as well documented as we would like.  All magic methods are described in the documentation, but very randomly and almost without any organization.  Therefore, in order to correct what I perceive as a lack of Python documentation, I am going to provide more information about magical methods, written in plain language and richly supplied with examples.  I hope you enjoy this guide.  Use it as a teaching material, memo, or full description.  I just tried to describe magical methods as clearly as possible. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <br><h2><a name="construction"></a>  Design and initialization. </h2><br>  Everyone knows the most basic magic method, <code>__init__</code> .  With it, we can initialize the object.  However, when I write <code>x = SomeClass()</code> , <code>__init__</code> not the first thing that is called.  In fact, an object instance creates a <code>__new__</code> method, and then the arguments are passed to the initializer.  At the other end of the object's life cycle is the <code>__del__</code> method.  Let's take a closer look at these three magic methods: <br><br><ul><li> <code>__new__(cls, [...)</code> <br>  This is the first method that will be called when the object is initialized.  It takes a class as parameters and then any other arguments that will be passed to <code>__init__</code> .  <code>__new__</code> used very rarely, but is sometimes useful, in particular, when a class is inherited from an immutable type, such as a tuple or string.  I do not intend to dwell on <code>__new__</code> in <code>__new__</code> , since it is not something that is often needed, but this method is described very well and in detail in the <a href="http://www.python.org/download/releases/2.2/descrintro/">documentation</a> . <br><br></li><li> <code>__init__(self, [...)</code> <br>  Class initializer  Everything that the original constructor was called with is passed to it (for example, if we call <code>x = SomeClass(10, 'foo')</code> , <code>__init__</code> gets <code>10</code> and <code>'foo'</code> as arguments. <code>__init__</code> almost universally used when defining classes. <br><br></li><li> <code>__del__(self)</code> <br>  If <code>__new__</code> and <code>__init__</code> form an object constructor, <code>__del__</code> is its destructor.  It does not define the behavior for the expression <code>del x</code> (therefore this code is not equivalent to <code>x.__del__()</code> ).  Rather, it defines the behavior of the object at the time the object enters the garbage collector.  This can be quite convenient for objects that may require additional clean-ups during deletion, such as sockets or file objects.  However, you need to be careful, since there is no guarantee that <code>__del__</code> will be called if the object continues to live when the interpreter shuts down.  Therefore, <code>__del__</code> cannot serve as a substitute for good programmer practices (always terminate the connection, if you have finished working with it, and the like).  In fact, due to the lack of a call guarantee, <code>__del__</code> should almost never be used;  use it with caution! <br><br>  <strong>Note from the translator:</strong> <a href="https://habrahabr.ru/users/svetlov/" class="user_link">svetlov</a> <a href="https://habr.com/ru/post/186608/">notes</a> that the author is mistaken here, in fact, <code>__del__</code> always called upon completion of the interpreter. <br><br></li></ul><br>  Connect all together, here is an example of <code>__init__</code> and <code>__del__</code> in action: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> join <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileObject</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">'''   ,     ,      .'''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, filepath=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'~'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, filename=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'sample.txt'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   filename  filepath      self.file = open(join(filepath, filename), 'r+') def __del__(self): self.file.close() del self.file</span></span></code> </pre><br><br><h2><a name="operators"></a>  Redefinition of operators on arbitrary classes </h2><br>  One of the great advantages of using magic methods in Python is that they provide an easy way to make objects behave like built-in types.  This means that you can avoid the dull, illogical and non-standard behavior of the basic operators.  In some languages, it‚Äôs common to write something like this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> instance.equals(other_instance): <span class="hljs-comment"><span class="hljs-comment"># do something</span></span></code> </pre><br>  Of course, you can do the same in Python, but this adds confusion and unnecessary verbosity.  Different libraries can call the same operations differently, forcing the programmer using them to perform more actions than necessary.  Using the power of magic methods, we can determine the desired method ( <code>__eq__</code> , in this case), and so accurately express what we <em>had in mind</em> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> instance == other_instance: <span class="hljs-comment"><span class="hljs-comment">#do something</span></span></code> </pre><br>  This is one of the strengths of magical methods.  The vast majority of them allow us to determine what standard operators will do, so that we can use operators on our classes as if they are built-in types. <br><br><br><h3><a name="comparisons"></a>  Magic methods of comparison </h3><br>  In Python, a lot of magic methods created to determine the intuitive comparison between objects using operators, rather than clumsy methods.  In addition, they provide a way to override the default behavior of Python for comparing objects (by reference).  Here is a list of these methods and what they do: <br><br><ul><li> <code>__cmp__(self, other)</code> <br>  The most basic of comparison methods.  It, in fact, determines the behavior for all comparison operators (&gt;, ==,! =, Etc.), but not always the way you need it (for example, if the equivalence of two copies is determined by one criterion, and the fact that one is greater than another for some other).  <code>__cmp__</code> should return a negative number if <code>self &lt; other</code> , zero if <code>self == other</code> , and a positive number in the case of <code>self &gt; other</code> .  But, usually, it is better to define every comparison that you need than to define them all in <code>__cmp__</code> .  But <code>__cmp__</code> can be a good way to avoid repetition and increase clarity when all necessary comparisons are operated with one criterion. <br><br></li><li> <code>__eq__(self, other)</code> <br>  Defines the behavior of the equality operator, <code>==</code> . <br><br></li><li> <code>__ne__(self, other)</code> <br>  Defines the behavior of the inequality operator,! <code>!=</code> . <br><br></li><li> <code>__lt__(self, other)</code> <br>  Specifies less operator behavior, <code>&lt;</code> . <br><br></li><li> <code>__gt__(self, other)</code> <br>  Defines the behavior of the operator more, <code>&gt;</code> . <br><br></li><li> <code>__le__(self, other)</code> <br>  Defines the operator's behavior less than or equal to, <code>&lt;=</code> . <br><br></li><li> <code>__ge__(self, other)</code> <br>  Defines the operator's behavior greater than or equal to, <code>&gt;=</code> . <br><br></li></ul><br>  For example, consider a class that describes a word.  We can compare words lexicographically (alphabetically), which is the default behavior when comparing strings, but we may want to use when comparing some other criterion, such as length or number of syllables.  In this example, we will compare in length.  Here is the implementation: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Word</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(str)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">'''  ,     .'''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__new__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, word)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    __new__,    str  #       ( ) if ' ' in word: print "Value contains spaces. Truncating to first space." word = word[:word.index(' ')] #  Word       return str.__new__(cls, word) def __gt__(self, other): return len(self) &gt; len(other) def __lt__(self, other): return len(self) &lt; len(other) def __ge__(self, other): return len(self) &gt;= len(other) def __le__(self, other): return len(self) &lt;= len(other)</span></span></code> </pre><br>  Now we can create two <code>Word</code> (using <code>Word('foo')</code> and <code>Word('bar')</code> ) and compare them in length.  Note that we did not define <code>__eq__</code> and <code>__ne__</code> , as this will lead to strange behavior (for example, <code>Word('foo') == Word('bar')</code> will be regarded as true).  This does not make sense when testing for equivalence based on length, so we leave the standard equivalence test from <code>str</code> . <br>  Now it seems to be a good time to mention that you do not have to define each of the magic comparison methods in order to fully cover all the comparisons.  The standard library kindly provides us with a class-detector in the <code>functools</code> module, which will determine all comparing methods, all you need to do is define only <code>__eq__</code> and one more ( <code>__gt__</code> , <code>__lt__</code> , etc.) This feature is available starting from version 2.7 of Python, but if You are satisfied, you will save a lot of time and effort.  To enable it, place <code>@total_ordering</code> above your class definition. <br><br><br><h3><a name="numeric"></a>  Numerical magic methods </h3><br>  In the same way that you can determine how your objects will be compared by comparison operators, you can define their behavior for numeric operators.  Get ready, friends, a lot of them.  For better organization, I divided numerical magic methods into 5 categories: unary operators, ordinary arithmetic operators, reflected arithmetic operators (more details later), compound assignments and type conversions. <br><br><br><h4>  Unary operators and functions </h4><br>  Unary operators and functions have only one operand - negation, absolute value, and so on. <br><br><ul><li> <code>__pos__(self)</code> <br>  Defines unary plus behavior ( <code>+some_object</code> ) <br><br></li><li> <code>__neg__(self)</code> <br>  Defines behavior for negation ( <code>-some_object</code> ) <br><br></li><li> <code>__abs__(self)</code> <br>  Defines the behavior for the built-in function <code>abs()</code> . <br><br></li><li> <code>__invert__(self)</code> <br>  Specifies the behavior to be inverted by the <code>~</code> operator.  For an explanation of what he does, see the <a href="http://en.wikipedia.org/wiki/Bitwise_operation">Wikipedia article on binary operators</a> . <br><br></li><li> <code>__round__(self, n)</code> <br>  Defines the behavior for the built-in <code>round()</code> function.  <code>n</code> is the number of decimal places to be rounded. <br><br></li><li> <code>__floor__(self)</code> <br>  Defines the behavior for <code>math.floor()</code> , that is, rounding to the nearest smaller integer. <br><br></li><li> <code>__ceil__(self)</code> <br>  Defines the behavior for <code>math.ceil()</code> , that is, rounding to the nearest larger integer. <br><br></li><li> <code>__trunc__(self)</code> <br>  Defines the behavior for <code>math.trunc()</code> , that is, circumcision to integer. <br><br></li></ul><br><h4>  Common arithmetic operators </h4><br>  Now consider the usual binary operators (and a couple more functions): +, -, * and similar ones.  They, for the most part, perfectly describe themselves. <br><br><ul><li> <code>__add__(self, other)</code> <br>  Addition. <br><br></li><li> <code>__sub__(self, other)</code> <br>  Subtraction. <br><br></li><li> <code>__mul__(self, other)</code> <br>  Multiplication. <br><br></li><li> <code>__floordiv__(self, other)</code> <br>  Integer division, operator <code>//</code> . <br><br></li><li> <code>__div__(self, other)</code> <br>  Division, operator. <br><br></li><li> <code>__truediv__(self, other)</code> <br>  <em>Proper</em> division.  Note that this only works when used <code>from __future__ import division</code> . <br><br></li><li> <code>__mod__(self, other)</code> <br>  The remainder of the division operator <code>%</code> . <br><br></li><li> <code>__divmod__(self, other)</code> <br>  Defines the behavior for the built-in <code>divmod()</code> function. <br><br></li><li> <code>__pow__</code> <br>  Exponentiation, operator <code>**</code> . <br><br></li><li> <code>__lshift__(self, other)</code> <br>  Binary left shift, operator <code>&lt;&lt;</code> . <br><br></li><li> <code>__rshift__(self, other)</code> <br>  Binary right shift, operator <code>&gt;&gt;</code> . <br><br></li><li> <code>__and__(self, other)</code> <br>  Binary AND, <code>&amp;</code> operator. <br><br></li><li> <code>__or__(self, other)</code> <br>  Binary OR operator <code>|</code>  . <br><br></li><li> <code>__xor__(self, other)</code> <br>  Binary xor, operator <code>^</code> . <br><br></li></ul><br><h4>  Reflected arithmetic operators </h4><br>  Remember how I said that I was going to dwell on the reflected arithmetic in more detail?  You might think that this is some kind of big, scary and incomprehensible concept.  In fact, everything is very simple.  Here is an example: <br><br><pre> <code class="python hljs">some_object + other</code> </pre><br>  This is the "usual" addition.  The only thing that distinguishes the equivalent reflected expression is the order of the terms: <br><br><pre> <code class="python hljs">other + some_object</code> </pre><br>  Thus, all these magic methods do the same as their regular versions, except for performing the operation with the <code>other</code> as the first operand and <code>self</code> as the second.  In most cases, the result of the reflected operation is the same as its usual equivalent, so when defining <code>__radd__</code> you can limit yourself to calling <code>__add__</code> and that's all.  Note that the object to the left of the operator ( <code>other</code> in the example) should not have the usual, unreflected version of this method.  In our example, <code>some_object.__radd__</code> will be called only if <code>__add__</code> not defined in the <code>other</code> . <br><br><ul><li> <code>__radd__(self, other)</code> <br>  Reflected addition. <br><br></li><li> <code>__rsub__(self, other)</code> <br>  Reflected subtraction. <br><br></li><li> <code>__rmul__(self, other)</code> <br>  Reflected multiplication. <br><br></li><li> <code>__rfloordiv__(self, other)</code> <br>  Reflected integer division, operator <code>//</code> . <br><br></li><li> <code>__rdiv__(self, other)</code> <br>  Reflected division operator <code>/</code> . <br><br></li><li> <code>__rtruediv__(self, other)</code> <br>  Reflected <em>correct</em> division.  Note that it only works when used <code>from __future__ import division</code> . <br><br></li><li> <code>__rmod__(self, other)</code> <br>  Reflected remainder of division, operator <code>%</code> . <br><br></li><li> <code>__rdivmod__(self, other)</code> <br>  Defines the behavior for the built-in <code>divmod()</code> function when <code>divmod(other, self)</code> called. <br><br></li><li> <code>__rpow__</code> <br>  Reflected elevation to steppe, operator <code>**</code> . <br><br></li><li> <code>__rlshift__(self, other)</code> <br>  Reflected binary left shift, operator <code>&lt;&lt;</code> . <br><br></li><li> <code>__rrshift__(self, other)</code> <br>  The reflected binary shift to the right, the operator <code>&gt;&gt;</code> . <br><br></li><li> <code>__rand__(self, other)</code> <br>  Reflected binary AND, <code>&amp;</code> operator. <br><br></li><li> <code>__ror__(self, other)</code> <br>  Reflected binary OR operator <code>|</code>  . <br><br></li><li> <code>__rxor__(self, other)</code> <br>  Reflected binary xor, operator <code>^</code> . <br><br><br></li></ul><h4>  Compound assignment </h4><br>  In Python, magic methods for compound assignment are widely represented.  You are most likely already familiar with compound assignment; this is a combination of the ‚Äúordinary‚Äù operator and assignment.  If it is still not clear, here is an example: <br><br><pre> <code class="python hljs">x = <span class="hljs-number"><span class="hljs-number">5</span></span> x += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#   x = x + 1</span></span></code> </pre><br>  Each of these methods should return the value that will be assigned to the variable on the left (for example, for <code>a += b</code> , <code>__iadd__</code> should return <code>a + b</code> , which will be assigned to <code>a</code> ).  Here is a list: <br><br><ul><li> <code>__iadd__(self, other)</code> <br>  Addition with assignment. <br><br></li><li> <code>__isub__(self, other)</code> <br>  Subtraction with assignment. <br><br></li><li> <code>__imul__(self, other)</code> <br>  Multiplication with assignment. <br><br></li><li> <code>__ifloordiv__(self, other)</code> <br>  Integer division with assignment, operator <code>//=</code> . <br><br></li><li> <code>__idiv__(self, other)</code> <br>  Division with assignment operator <code>/=</code> . <br><br></li><li> <code>__itruediv__(self, other)</code> <br>  <em>Proper</em> division with assignment.  Note that only works <code>from __future__ import division</code> . <br><br></li><li> <code>__imod_(self, other)</code> <br>  The remainder of the division with assignment operator <code>%=</code> . <br><br></li><li> <code>__ipow__</code> <br>  Raising to step with assignment, operator <code>**=</code> . <br><br></li><li> <code>__ilshift__(self, other)</code> <br>  Binary left shift with assignment operator <code>&lt;&lt;=</code> . <br><br></li><li> <code>__irshift__(self, other)</code> <br>  Binary right shift with assignment operator <code>&gt;&gt;=</code> . <br><br></li><li> <code>__iand__(self, other)</code> <br>  Binary AND with assignment, operator <code>&amp;=</code> . <br><br></li><li> <code>__ior__(self, other)</code> <br>  Binary OR assignment, operator <code>|=</code> . <br><br></li><li> <code>__ixor__(self, other)</code> <br>  Binary xor with assignment, operator <code>^=</code> . <br><br><br></li></ul><h4>  Magic type conversion methods </h4><br>  In addition, in Python there are many magic methods designed to define behavior for built-in type conversion functions, such as <code>float()</code> .  Here they are: <br><br><ul><li> <code>__int__(self)</code> <br>  Type conversion to int. <br><br></li><li> <code>__long__(self)</code> <br>  Type conversion to long. <br><br></li><li> <code>__float__(self)</code> <br>  Type conversion to float. <br><br></li><li> <code>__complex__(self)</code> <br>  Type conversion to complex number. <br><br></li><li> <code>__oct__(self)</code> <br>  Type conversion to octal number. <br><br></li><li> <code>__hex__(self)</code> <br>  Type conversion to hexadecimal number. <br><br></li><li> <code>__index__(self)</code> <br>  Type conversion to int when the object is used in slices (expressions like [start: stop: step]).  If you define your numeric type, which can be used as a list index, you must define <code>__index__</code> . <br><br></li><li> <code>__trunc__(self)</code> <br>  Called when <code>math.trunc(self)</code> .  Must return its value truncated to an integer type (usually long). <br><br></li><li> <code>__coerce__(self, other)</code> <br>  A method for implementing arithmetic with operands of different types.  <code>__coerce__</code> should return <code>None</code> if type conversion is not possible.  If the transformation is possible, it must return a pair (a tuple of 2 elements) of <code>self</code> and <code>other</code> , converted to the same type. <br><br></li></ul><br><h2><a name="representations"></a>  Introducing Your Classes </h2><br>  It is often useful to present a class as a string.  There are several methods in Python that you can define to customize the behavior of built-in functions when representing your class. <br><br><ul><li> <code>__str__(self)</code> <br>  Defines the behavior of the <code>str()</code> function called on an instance of your class. <br><br></li><li> <code>__repr__(self)</code> <br>  Defines the behavior of the <code>repr()</code> function <code>repr()</code> on an instance of your class.  The main difference from <code>str()</code> in the target audience.  <code>repr()</code> more intended for machine-oriented output (moreover, it often has to be valid Python code), and <code>str()</code> intended for people to read. <br><br></li><li> <code>__unicode__(self)</code> <br>  Determines the behavior of the <code>unicode()</code> function called on an instance of your class.  <code>unicode()</code> is similar to <code>str()</code> , but returns a string in unicode.  Be careful: if the client calls <code>str()</code> on an instance of your class, and you have only defined <code>__unicode__()</code> , then this will not work.  Try to always define <code>__str__()</code> for the case when someone does not have the luxury of Unicode. <br><br></li><li> <code>__format__(self, formatstr)</code> <br>  Defines the behavior when an instance of your class is used in formatting new style strings.  For example, <code>"Hello, {0:abc}!".format(a)</code> will call <code>a.__format__("abc")</code> .  This can be useful for defining your own numeric or string types, which you may want to provide some special formatting options. <br><br></li><li> <code>__hash__(self)</code> <br>  Defines the behavior of the <code>hash()</code> function that is called for an instance of your class.  The method should return an integer value that will be used to quickly compare keys in dictionaries.  Note that in this case, it is usually necessary to determine <code>__eq__</code> too.  Follow this rule: <code>a == b</code> implies <code>hash(a) == hash(b)</code> . <br><br></li><li> <code>__nonzero__(self)</code> <br>  Defines the behavior of the <code>bool()</code> function called on an instance of your class.  Should return True or False, depending on when you consider the instance corresponding to True or False. <br><br></li><li> <code>__dir__(self)</code> <br>  Defines the behavior of the <code>dir()</code> function called on an instance of your class.  This method should return a list of attributes to the user.  Normally, the definition of <code>__dir__</code> not required, but it can be vital for the interactive use of your class, if you redefine <code>__getattr__</code> or <code>__getattribute__</code> (which you will meet in the next section), or otherwise dynamically create attributes. <br><br></li><li> <code>__sizeof__(self)</code> <br>  Defines the behavior of the <code>sys.getsizeof()</code> function <code>sys.getsizeof()</code> on an instance of your class.  The method should return the size of your object in bytes.  It is mainly useful for classes defined in extensions to C, but it is still useful to know about it. <br><br></li></ul><br>  We are almost done with the boring (and devoid of examples) part of the magic method manual.  Now that we have covered the most basic magical methods, it's time to move on to more advanced material. <br><br><br><h2><a name="access"></a>  Attribute Access Control </h2><br>  Many people who come to Python from other languages ‚Äã‚Äãcomplain about the absence of real encapsulation for classes (for example, there is no way to define private attributes with public access methods).  This is not entirely true: it is just that many things associated with encapsulation are implemented by Python through ‚Äúmagic‚Äù, and not by explicit modifiers for methods and fields.  See: <br><br><ul><li> <code>__getattr__(self, name)</code> <br>  You can define the behavior for the case when the user tries to access an attribute that does not exist (at all or for now).  This can be useful for intercepting and redirecting frequent typos, warnings about the use of obsolete attributes (you can still calculate and return this attribute if you want), or tricky to return <code>AttributeError</code> when you need it.  However, this method is called only when trying to access a non-existent attribute, so this is not a very good solution for encapsulation. <br><br></li><li> <code>__setattr__(self, name, value)</code> <br>  Unlike <code>__getattr__</code> , <code>__setattr__</code> encapsulation solution.  This method allows you to define a behavior for assigning a value to an attribute, whether the attribute exists or not.  That is, you can define any rules for any attribute value changes.  However, you must be careful how to use <code>__setattr__</code> , see the bad case example at the end of this list. <br><br></li><li> <code>__delattr__</code> <br>  This is the same as <code>__setattr__</code> , but to remove attributes, instead of setting values.  Here, the same precautions are required as in <code>__setattr__</code> to avoid infinite recursion (calling <code>del self.name</code> in the definition of <code>__delattr__</code> will cause infinite recursion). <br><br></li><li> <code>__getattribute__(self, name)</code> <br>  <code>__getattribute__</code> looks to the place among its colleagues <code>__setattr__</code> and <code>__delattr__</code> , but I would not recommend you to use it.  <code>__getattribute__</code> can be used only with classes of a new type (in new versions of Python, all classes are of a new type, and in old versions you can get such a class inherited from <code>object</code> ).        <em></em>     (    ,  <code>__getattr__(self, name)</code> ).         ,     (      <code>__getattribute__</code>   ,   ). ,  ,      <code>__getattr__</code> ,     <code>__getattribute__</code>            <code>AttributeError</code> .       (  ,   ),     ,   ,       (      ,     )        . <br><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can easily get a problem when defining any attribute that controls access to attributes.</font></font> Consider an example: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__setattr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, value)</span></span></span><span class="hljs-function">:</span></span> self.name = value <span class="hljs-comment"><span class="hljs-comment">#  ,    ,     , #  __setattr__(). # ,      self.__setattr__('name', value). #      ,   ,     def __setattr__(self, name, value): self.__dict__[name] = value #      #    </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once again, the power of magical methods in Python is incredible, and with great force comes great responsibility. </font><font style="vertical-align: inherit;">It is important to know how to correctly use magic methods without breaking anything. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, what have we learned about controlling access to attributes? </font><font style="vertical-align: inherit;">They do not need to be used lightly. </font><font style="vertical-align: inherit;">In fact, they tend to be overly powerful and illogical. </font><font style="vertical-align: inherit;">The reason why they still exist is to satisfy a certain desire: Python is not inclined to prohibit bad things completely, but only to complicate their use. </font><font style="vertical-align: inherit;">Freedom is paramount, so you can actually do whatever you want. </font><font style="vertical-align: inherit;">Here is an example of using access control methods (note that we use </font></font><code>super</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, since not all classes have an attribute </font></font><code>__dict__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AccessCounter</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">''',   value      .    ,   value.'''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val)</span></span></span><span class="hljs-function">:</span></span> super(AccessCounter, self).__setattr__(<span class="hljs-string"><span class="hljs-string">'counter'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) super(AccessCounter, self).__setattr__(<span class="hljs-string"><span class="hljs-string">'value'</span></span>, val) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__setattr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> name == <span class="hljs-string"><span class="hljs-string">'value'</span></span>: super(AccessCounter, self).__setattr__(<span class="hljs-string"><span class="hljs-string">'counter'</span></span>, self.counter + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">#      . #       , #   AttributeError(name) super(AccessCounter, self).__setattr__(name, value) def __delattr__(self, name): if name == 'value': super(AccessCounter, self).__setattr__('counter', self.counter + 1) super(AccessCounter, self).__delattr__(name)]</span></span></code> </pre><br><br><h2><a name="sequence"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating arbitrary sequences </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Python, there are many ways to make your classes behave like built-in sequences (dictionaries, tuples, lists, strings, and so on). </font><font style="vertical-align: inherit;">These are, undoubtedly, my favorite magical methods, due to the absurdity of the high degree of control that they give and the magic from which a whole host of global functions suddenly work fine with instances of your classes. </font><font style="vertical-align: inherit;">But before we get to all sorts of good things, we need to know about the protocols.</font></font><br><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Protocols </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, when it comes to creating your own sequences in Python, it's time to talk about the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">protocols</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Protocols are somewhat similar to interfaces in other languages ‚Äã‚Äãin that they provide a set of methods that you must implement. However, in Python, the protocols absolutely do not oblige to anything and do not necessarily require to implement any announcement. They are probably more like guidelines. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why are we talking about protocols? Because the implementation of arbitrary container types in Python entails the use of some of them. First, the protocol for defining immutable containers: to create an immutable container, you only have to define </font></font><code>__len__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>__getitem__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(more about them further). </font><font style="vertical-align: inherit;">The protocol of the container to be changed requires the same as the container that is not to be changed, plus </font></font><code>__setitem__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>__delitem__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And finally, if you want your objects to be iterated through iteration, you must determine </font></font><code>__iter__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which iterator returns. </font><font style="vertical-align: inherit;">This iterator must comply with an iterator protocol that requires methods </font></font><code>__iter__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(returns itself) and </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Magic containers </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Without further delay, here are the magic methods used by the containers: </font></font><br><br><ul><li> <code>__len__(self)</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Returns the number of elements in the container. </font><font style="vertical-align: inherit;">Part of the protocols for changeable and immutable containers.</font></font><br><br></li><li> <code>__getitem__(self, key)</code> <br>      ,   <code>self[key]</code> .           .    : <code>TypeError</code>      <code>KeyError</code>      . <br><br></li><li> <code>__setitem__(self, key, value)</code> <br>      ,   <code>self[nkey] = value</code> .    .  ,    <code>KeyError</code>  <code>TypeError</code>   . <br><br></li><li> <code>__delitem__(self, key)</code> <br>      (  <code>del self[key]</code> ).       .     ,   . <br><br></li><li> <code>__iter__(self)</code> <br>     .     ,      <code>iter()</code>        <code>for x in container:</code> .            <code>__iter__</code> ,   <code>self</code> . <br><br></li><li> <code>__reversed__(self)</code> <br>        <code>reversed()</code> .     .      ,    . <br><br></li><li> <code>__contains__(self, item)</code> <br> <code>__contains__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it is intended for checking the belonging of an element with </font></font><code>in</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>not in</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">You ask, why is this not part of the sequence protocol? </font><font style="vertical-align: inherit;">Because when </font></font><code>__contains__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not defined, Python simply iterates over the entire sequence element by element and returns </font></font><code>True</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if it finds the right one.</font></font><br><br></li><li> <code>__missing__(self, key)</code> <br> <code>__missing__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used when inheriting from </font></font><code>dict</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Defines the behavior for each case when trying to get an item by a nonexistent key (for example, if I have a dictionary </font></font><code>d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and I write </font></font><code>d["george"]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when </font></font><code>"george"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it is not a key in the dictionary, it is called </font></font><code>d.__missing__("george")</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br><br></li></ul><br><h4>  Example </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For an example, let's look at a list that implements some functional constructs that you might have found in other languages ‚Äã‚Äã(Haskell, for example). </font></font><br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctionalList</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">'''-       : head, tail, init, last, drop, take.'''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, values=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> values <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: self.values = [] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: self.values = values <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__len__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> len(self.values) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__getitem__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#      , list   return self.values[key] def __setitem__(self, key, value): self.values[key] = value def __delitem__(self, key): del self.values[key] def __iter__(self): return iter(self.values) def __reversed__(self): return FunctionalList(reversed(self.values)) def append(self, value): self.values.append(value) def head(self): #    return self.values[0] def tail(self): #      return self.values[1:] def init(self): #      return self.values[:-1] def last(self): #    return self.values[-1] def drop(self, n): #     n return self.values[n:] def take(self, n): #  n  return self.values[:n]</span></span></code> </pre><br>      ()     . , ,       ,          (   , ?),   <code>Counter</code> , <code>OrderedDict</code> , <code>NamedTuple</code> . <br><br><br><h2><a name="reflection"></a>  </h2><br>     ,    <code>isinstance()</code>  <code>issubclass()</code> ,    .  Here they are: <br><br><ul><li> <code>__instancecheck__(self, instance)</code> <br> ,       ( <code>isinstance(instance, class)</code> , . <br><br></li><li> <code>__subclasscheck__(self, subclass)</code> <br> ,        ( <code>issubclass(subclass, class)</code> ). <br><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It may seem that the beneficial uses of these magical methods are few and perhaps this is indeed the case. </font><font style="vertical-align: inherit;">I do not want to spend too much time on magical methods of reflection, they are not particularly important, but they reflect something important about object-oriented programming in Python and Python in general: there is almost always an easy way to do something, even if needed this ‚Äúsomething‚Äù occurs very rarely. </font><font style="vertical-align: inherit;">These magic methods may not look useful, but if you ever need them, you will be happy to remember that they exist (and for this you are reading this guide!).</font></font><br><br><br><h2><a name="callable"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Called Objects </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you probably already know, in Python, functions are first class objects. This means that they can be passed to functions or methods just like any other objects. This is an incredibly powerful feature. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The special magic method allows instances of your class to behave as if they were functions, that is, you can "call" them, pass them into functions that accept functions as arguments, and so on. This is another handy feature that makes programming in Python so enjoyable.</font></font><br><br><ul><li> <code>__call__(self, [args...])</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allows any instance of your class to be called as if it were a function. </font><font style="vertical-align: inherit;">Mostly, this means what it </font></font><code>x()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means the same as </font></font><code>x.__call__()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Notice </font></font><code>__call__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accepts an arbitrary number of arguments; </font><font style="vertical-align: inherit;">that is, you can define </font></font><code>__call__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it just like any other function that takes as many arguments as you need.</font></font><br><br></li></ul><br> <code>__call__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In particular, it can be useful in classes whose instances often change their state. </font><font style="vertical-align: inherit;">Invoking an instance can be an intuitive and elegant way to change the state of an object. </font><font style="vertical-align: inherit;">An example would be a class representing the position of an object on a plane:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Entity</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">''',    . "",    .'''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, size, x, y)</span></span></span><span class="hljs-function">:</span></span> self.x, self.y = x, y self.size = size <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'''  .'''</span></span> self.x, self.y = x, y <span class="hljs-comment"><span class="hljs-comment"># ...</span></span></code> </pre><br><br><h2><a name="context"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Context managers </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Python 2.5, a new keyword was introduced along with a new way to reuse code, a keyword </font></font><code>with</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The concept of context managers was not new to Python (it was implemented earlier as part of a library), but in </font></font><a href="http://www.python.org/dev/peps/pep-0343/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEP 343 it</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reached the status of a language construct. </font><font style="vertical-align: inherit;">You could already see expressions with </font></font><code>with</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'foo.txt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> bar: <span class="hljs-comment"><span class="hljs-comment">#  -   bar</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Context managers allow you to perform some actions for customization or cleanup when object creation is wrapped in an operator </font></font><code>with</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The behavior of the context manager is determined by two magic methods:</font></font><br><br><ul><li> <code>__enter__(self)</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Specifies what the context manager should do at the beginning of the block created by the operator </font></font><code>with</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Notice that the return </font></font><code>__enter__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value is the value that is being worked on internally </font></font><code>with</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br></li><li> <code>__exit__(self, exception_type, exception_value, traceback)</code> <br>      ,     (    ).     , ,           with.    , <code>exception_type</code> , <code>exception_value</code> ,  <code>traceback</code>    <code>None</code> .      ,       ;     , ,  <code>__exit__</code>  <code>True</code>       .    ,      ,    . <br><br></li></ul><br> <code>__enter__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>__exit__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be useful for specific classes with well-described and common behavior for setting them up and clearing resources. </font><font style="vertical-align: inherit;">You can use these methods to create common context managers for different objects.</font></font> Here is an example: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Closer</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">'''        close  with-.'''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj)</span></span></span><span class="hljs-function">:</span></span> self.obj = obj <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__enter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.obj <span class="hljs-comment"><span class="hljs-comment">#     with- def __exit__(self, exception_type, exception_val, trace): try: self.obj.close() except AttributeError: #     close print 'Not closable.' return True #  </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of using </font></font><code>Closer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with an FTP connection (a socket that has a close method):</font></font><br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> magicmethods <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Closer &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ftplib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FTP &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Closer(FTP(<span class="hljs-string"><span class="hljs-string">'ftp.somesite.com'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> conn: ... conn.dir() ... <span class="hljs-comment"><span class="hljs-comment"># output omitted for brevity &gt;&gt;&gt; conn.dir() # long AttributeError message, can't use a connection that's closed &gt;&gt;&gt; with Closer(int(5)) as i: ... i += 1 ... Not closable. &gt;&gt;&gt; i 6</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">See how our wrapper elegantly handles both the right and the wrong objects. </font><font style="vertical-align: inherit;">This is the power of context managers and magic methods. </font><font style="vertical-align: inherit;">Notice that the standard Python library includes a </font></font><a href="http://docs.python.org/library/contextlib.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contextlib</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> module </font><font style="vertical-align: inherit;">, which includes </font></font><code>contextlib.closing()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a context manager, which does roughly the same thing (without any handling of the case where the object has no method </font></font><code>close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br><br><br><h2><a name="abcs"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abstract base classes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">See </font></font><a href="http://docs.python.org/2/library/abc.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://docs.python.org/2/library/abc.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><br><h2><a name="descriptor"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Building descriptors </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descriptors are such classes, with the help of which you can add your logic to access events (receiving, modifying, deleting) to attributes of other objects. Descriptors are not intended to be used by themselves; rather, it is assumed that they will be owned by any related classes. Descriptors can be useful for building object-oriented databases or classes whose attributes are dependent on each other. In particular, descriptors are useful when representing attributes in several calculus systems or any calculated attributes (such as the distance from the starting point to the point represented by the attribute on the grid). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For a class to become a handle, it must implement at least one method from </font></font><code>__get__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>__set__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>__delete__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Let's look at these magical methods:</font></font><br><br><ul><li> <code>__get__(self, instance, instance_class)</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Specifies the behavior when returning a value from a handle. </font></font><code>instance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is an object for whose attribute descriptor the method is being called. </font></font><code>owner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the type (class) of the object.</font></font><br><br></li><li> <code>__set__(self, instance, value)</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Defines the behavior when the value changes from the descriptor. </font></font><code>instance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is an object for whose attribute descriptor the method is being called. </font></font><code>value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this value is set to the descriptor.</font></font><br><br></li><li> <code>__delete__(self, instance)</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Defines the behavior for deleting a value from a handle. </font></font><code>instance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the object that owns the handle.</font></font><br><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now an example of the useful use of descriptors: unit conversion. </font></font><br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meter</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">'''  .'''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self.value = float(value) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__get__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, instance, owner)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__set__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, instance, value)</span></span></span><span class="hljs-function">:</span></span> self.value = float(value) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foot</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">'''  .'''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__get__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, instance, owner)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance.meter * <span class="hljs-number"><span class="hljs-number">3.2808</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__set__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, instance, value)</span></span></span><span class="hljs-function">:</span></span> instance.meter = float(value) / <span class="hljs-number"><span class="hljs-number">3.2808</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Distance</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">''',  ,       .'''</span></span> meter = Meter() foot = Foot()</code> </pre><br><br><h2><a name="copying"></a>  Copying </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Python, the assignment operator does not copy objects, but only adds another reference. But for collections that contain mutable elements, sometimes you need a full copy so that you can change the elements of one sequence without affecting the other. Here comes into play </font></font><a href="http://docs.python.org/library/copy.html"><code>copy</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Fortunately, modules in Python do not have a reason, so we can not worry that they suddenly begin to copy themselves uncontrollably and soon Linux robots will flood the entire planet, but we must tell Python how to copy correctly.</font></font><br><br><ul><li> <code>__copy__(self)</code> <br>   <code>copy.copy()</code>    . <code>copy.copy()</code>  <em> </em>   ‚Äî  ,       ,        .      ,      . <br><br></li><li> <code>__deepcopy__(self, memodict={})</code> <br>   <code>copy.deepcopy()</code>    . <code>copy.deepcopy()</code>  <em> </em>   ‚Äî    <em></em>  . <code>memodict</code>     ,         ,     .      -  ,    <code>copy.deepcopy()</code>    <code>memodict</code> . <br><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When to use these magical methods? </font><font style="vertical-align: inherit;">As usual - in any case, when you need more than the standard behavior. </font><font style="vertical-align: inherit;">For example, if you are trying to copy an object that contains a cache as a dictionary (perhaps a very large dictionary), then you may not need to copy the entire cache, but do just one in the shared memory of objects.</font></font><br><br><br><h2><a name="pickling"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using the pickle module on your objects </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pickle is a module for serializing Python data structures and can be incredibly useful when you need to save the state of an object and restore it later (usually for caching purposes). </font><font style="vertical-align: inherit;">In addition, it is also an excellent source of experiences and confusion. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serialization is so important that in addition to its module ( </font></font><code>pickle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) it has its own </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">protocol</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and its own magic methods. </font><font style="vertical-align: inherit;">But for a start on how to serialize pickle with already existing data types (quietly skip if you already know).</font></font><br><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Briefly about serialization </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's dive into serialization. </font><font style="vertical-align: inherit;">Suppose you have a dictionary that you want to save and restore later. </font><font style="vertical-align: inherit;">You must write its contents to a file, carefully making sure that you are writing with the correct syntax, then restoring it, either by running </font></font><code>exec()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or reading the file. </font><font style="vertical-align: inherit;">But this is at best risky: if you store important data in the text, it can be damaged or changed in many ways, in order to crash your program or, in general, run some dangerous code on your computer. </font><font style="vertical-align: inherit;">Better use pickle:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle data = {<span class="hljs-string"><span class="hljs-string">'foo'</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-string"><span class="hljs-string">'bar'</span></span>: (<span class="hljs-string"><span class="hljs-string">'Hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'world!'</span></span>), <span class="hljs-string"><span class="hljs-string">'baz'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>} jar = open(<span class="hljs-string"><span class="hljs-string">'data.pkl'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) pickle.dump(data, jar) <span class="hljs-comment"><span class="hljs-comment">#     jar jar.close()</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And now, after a few hours, we need our dictionary again: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle pkl_file = open(<span class="hljs-string"><span class="hljs-string">'data.pkl'</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  data = pickle.load(pkl_file) #    print data pkl_file.close()</span></span></code> </pre><br>  What happened?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exactly what was expected. </font></font><code>data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as if it had always been there. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, a bit of caution: pickle is not perfect. </font><font style="vertical-align: inherit;">Its files are easily spoiled accidentally or intentionally. </font><font style="vertical-align: inherit;">Pickle may be safer than text files, but it can still be used to run malicious code. </font><font style="vertical-align: inherit;">In addition, it is incompatible between different versions of Python, so if you will distribute your objects using pickle, do not expect that all people will be able to use them. </font><font style="vertical-align: inherit;">However, a module can be a powerful tool for caching and other common serialization tasks.</font></font><br><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Serialize your own objects. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The pickle module is not only for built-in types. </font><font style="vertical-align: inherit;">It can be used with every class that implements its protocol. </font><font style="vertical-align: inherit;">This protocol contains four optional methods that allow you to configure how pickle will handle them (there are some differences for C extensions, but this is beyond the scope of our tutorial):</font></font><br><br><ul><li> <code>__getinitargs__(self)</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want your class to be invoked after deserialization </font></font><code>__init__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you can specify </font></font><code>__getinitargs__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which argument </font><font style="vertical-align: inherit;">sequence </font><font style="vertical-align: inherit;">should return, which will be sent to </font></font><code>__init__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Note that this method only works with old-style classes.</font></font><br><br></li><li> <code>__getnewargs__(self)</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For classes of new style, you can determine which parameters will be passed to </font></font><code>__new__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">during deserialization. </font><font style="vertical-align: inherit;">This method should also return a tuple of arguments that will be sent to </font></font><code>__new__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br></li><li> <code>__getstate__(self)</code> <br>    <code>__dict__</code> ,    ,       .      <code>__setstate__</code>   . <br><br></li><li> <code>__setstate__(self, state)</code> <br>      <code>__setstate__</code> ,      ,        <code>__dict__</code> .     <code>__getstate__</code> :   ,       ,    . <br><br></li><li> <code>__reduce__(self)</code> <br>      (  Python's C API),       ,   ,    . <code>__reduce__()</code>    ,      .     ,    ,     ,  .     2  5 :  ,   ,    ,      , ,     <code>__setstate__</code> (),      ()       (). <br><br></li><li> <code>__reduce_ex__(self, protocol)</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes it is useful to know the version of the protocol when implementing </font></font><code>__reduce__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And this can be achieved by implementing instead </font></font><code>__reduce_ex__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If </font></font><code>__reduce_ex__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implemented, preference is given to it when it is called (you must still implement it </font></font><code>__reduce__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for backward compatibility).</font></font><br><br></li></ul><br><h3>  Example </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, we will describe a slate ( </font></font><code>Slate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), which remembers what and when it was written on it. </font><font style="vertical-align: inherit;">However, specifically this board becomes clean every time it is serialized: the current value is not saved.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Slate</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">''',     .      .'''</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span> self.value = value self.last_change = time.asctime() self.history = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, new_value)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#  .     . self.history[self.last_change] = self.value self.value = new_value self.last_change = time.asctime() def print_changes(self): print 'Changelog for Slate object:' for k, v in self.history.items(): print '%s\t %s' % (k, v) def __getstate__(self): #    self.value or self.last_change. #   " "  . return self.history def __setstate__(self, state): self.history = state self.value, self.last_change = None, None</span></span></code> </pre><br><br><h2><a name="conclusion"></a>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The goal of this guide is to bring something to everyone who reads it, regardless of its experience in Python or object-oriented programming. </font><font style="vertical-align: inherit;">If you are new to Python, you have gained valuable knowledge of the basics of writing functional, elegant and easy-to-use classes. </font><font style="vertical-align: inherit;">If you are a mid-level programmer, then you may have found some nice new ideas and strategies, some good ways to reduce the amount of code written by you and your clients. </font><font style="vertical-align: inherit;">If you are a Pythonist expert, then you have updated some of your, perhaps, forgotten knowledge, and maybe you have found a couple of new tricks. </font><font style="vertical-align: inherit;">Regardless of your level, I hope that this journey through special Python methods was truly magical (I could not resist).</font></font><br><br><br><h2><a name="appendix1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Addition 1: How to cause magic methods </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some of the magic methods are directly related to the built-in functions; </font><font style="vertical-align: inherit;">in this case, it‚Äôs quite obvious how to call them. </font><font style="vertical-align: inherit;">However, this is not always the case. </font><font style="vertical-align: inherit;">This addition is dedicated to uncovering unobvious syntax leading to invocation of magic methods.</font></font><br><table><thead><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Magic method </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When it is called (example) </font></font></th><th>  Explanation </th></tr></thead><tbody><tr><td> <code>__new__(cls [,...])</code> </td> <td> <code>instance = MyClass(arg1, arg2)</code> </td> <td> <code>__new__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> called when creating an instance </font></font></td></tr><tr><td> <code>__init__(self [,...])</code> </td> <td> <code>instance = MyClass(arg1, arg2)</code> </td> <td> <code>__init__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> called when creating an instance </font></font></td></tr><tr><td> <code>__cmp__(self, other)</code> </td> <td> <code>self == other</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>self &gt; other</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Etc.</font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Called for any comparison. </font></font></td></tr><tr><td> <code>__pos__(self)</code> </td> <td> <code>+self</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unary plus sign </font></font></td></tr><tr><td> <code>__neg__(self)</code> </td> <td> <code>-self</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unary minus sign </font></font></td></tr><tr><td> <code>__invert__(self)</code> </td> <td> <code>~self</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bitwise inversion </font></font></td></tr><tr><td> <code>__index__(self)</code> </td> <td> <code>x[self]</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transformation when an object is used as an index </font></font></td></tr><tr><td> <code>__nonzero__(self)</code> </td> <td> <code>bool(self)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><code>if self:</code> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Object Boolean </font></font></td></tr><tr><td> <code>__getattr__(self, name)</code> </td> <td> <code>self.name # name  </code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trying to get a non-existent attribute. </font></font></td></tr><tr><td> <code>__setattr__(self, name, val)</code> </td> <td> <code>self.name = val</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assigning to any attribute </font></font></td></tr><tr><td> <code>__delattr__(self, name)</code> </td> <td> <code>del self.name</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attribute removal </font></font></td></tr><tr><td> <code>__getattribute__(self, name)</code> </td> <td> <code>self.name</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Get any attribute </font></font></td></tr><tr><td> <code>__getitem__(self, key)</code> </td> <td> <code>self[key]</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Getting an item through the index </font></font></td></tr><tr><td> <code>__setitem__(self, key, val)</code> </td> <td> <code>self[key] = val</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assignment to an element through an index </font></font></td></tr><tr><td> <code>__delitem__(self, key)</code> </td> <td> <code>del self[key]</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deleting an item by index </font></font></td></tr><tr><td> <code>__iter__(self)</code> </td> <td> <code>for x in self</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iteration </font></font></td></tr><tr><td> <code>__contains__(self, value)</code> </td> <td> <code>value in self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><code>value not in self</code> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affiliation checking with </font></font><code>in</code> </td></tr><tr><td> <code>__call__(self [,...])</code> </td> <td> <code>self(args)</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Call" instance </font></font></td></tr><tr><td> <code>__enter__(self)</code> </td> <td> <code>with self as x:</code> </td> <td> <code>with</code>    </td></tr><tr><td> <code>__exit__(self, exc, val, trace)</code> </td> <td> <code>with self as x:</code> </td> <td> <code>with</code>    </td></tr><tr><td> <code>__getstate__(self)</code> </td> <td> <code>pickle.dump(pkl_file, self)</code> </td> <td>  Serialization </td></tr><tr><td> <code>__setstate__(self)</code> </td> <td> <code>data = pickle.load(pkl_file)</code> </td> <td>  Serialization </td></tr></tbody></table><br><br> ,         ,      . <br><br><br><h2><a name="appendix2"></a>  2:    3 </h2><br>    ,   3   2.x     : <br><br><ul><li>     3       , <code>__unicode__</code> ,   <code>__bytes__</code> (      <code>__str__</code>  <code>__unicode__</code>  2.7)       . </li><li>      3  - ¬´ ¬ª, <code>__div__</code>  . </li><li> <code>__coerce__</code>  , -    . </li><li> <code>__cmp__</code>  , - . </li><li> <code>__nonzero__</code>    <code>__bool__</code> . </li><li> <code>next</code>    <a href="http://www.python.org/dev/peps/pep-3114/"></a>  <code>__next__</code> . </li></ul><br><br></div><p>Source: <a href="https://habr.com/ru/post/186608/">https://habr.com/ru/post/186608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../186594/index.html">CraftStudio - minecraft for the developer</a></li>
<li><a href="../186596/index.html">Yii 1.1.14 RC</a></li>
<li><a href="../186600/index.html">A few thoughts in the rumor about programmers</a></li>
<li><a href="../186602/index.html">Dribbble Meetup 2013 in Moscow</a></li>
<li><a href="../186606/index.html">Free2Play MMORPG. Types of players and their monetization</a></li>
<li><a href="../186610/index.html">Brief history of space exploration</a></li>
<li><a href="../186616/index.html">Clickjacking from A to Z</a></li>
<li><a href="../186618/index.html">Auto Acceleration: windows marketplace, in-app billing and what else we learned over the year</a></li>
<li><a href="../186624/index.html">Improving the organization in the work of the installation department</a></li>
<li><a href="../186630/index.html">Closed the "last in the world" wired telegraph</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>