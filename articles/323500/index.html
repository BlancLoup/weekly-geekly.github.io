<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simplify the universal / isomorphic application on React + Router + Redux + Express</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√©, there were already plenty of articles on how to make a universal (isomorphic) application on the React + Redux + Router + Koa / Express stac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simplify the universal / isomorphic application on React + Router + Redux + Express</h1><div class="post__text post__text-html js-mediator-article"><p>  On Habr√©, <a href="https://habrahabr.ru/post/310302/">there were already</a> <a href="https://habrahabr.ru/post/264423/">plenty of</a> <a href="https://habrahabr.ru/post/309958/">articles</a> on how to make a universal (isomorphic) application on the React + Redux + Router + Koa / Express stack ( <a href="http://lmgtfy.com/%3Fq%3Dsite%253Ahabrahabr.ru%2B%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25BC%25D0%25BE%25D1%2580%25D1%2584%25D0%25BD%25D1%258B%25D0%25B9%2Bredux">Google help</a> ), but I noticed that all of them contain duplicate code for server rendering.  I decided to simplify the task and allocate this common code to the library, and <a href="https://github.com/kirill-konshin/create-react-server">Create React Server</a> came into being, it works like this: </p><br><pre><code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Express <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"express"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./webpack.config"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> createRouter <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./src/createRouter"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> createStore <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./src/createStore"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {createExpressServer} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"create-react-server"</span></span>; createExpressServer({ createRouter: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(history)</span></span></span><span class="hljs-function"> =&gt;</span></span> (createRouter(history)), createStore: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({req, res})</span></span></span><span class="hljs-function"> =&gt;</span></span> (createStore()), port: <span class="hljs-number"><span class="hljs-number">3000</span></span> }));</code> </pre> <br><p>  The proposed method can save power and save from copy-paste.  In the approach itself, there is nothing fundamentally new, and for a deeper understanding, you can read the official documentation, as well as the articles on the links above.  Next, I will try to briefly outline the essence of server rendering and the necessary preparatory steps. <a name="habracut"></a></p><br><p>  The essence of server rendering is quite simple: on the server we need to determine, based on the router's rules, which component will be shown on the page, find out what data it needs to work, request this data, render HTML, and send this HTML along with the data to the client.  If we want to be completely cool, we can still run through the component tree and load data for all of them (not only for the content area), but this is beyond the scope of the article, although it is planned for implementation in the library. </p><br><p>  If you are too lazy to understand all this - take a look at other candidates, for example Next.JS and Electrode from my review article <a href="https://habrahabr.ru/post/323458">What to base React application on</a> . </p><br><h1 id="klient">  Customer </h1><br><p>  The preparatory stages are reduced to four things: </p><br><ol><li>  To clear the code from all browser-specific goodness like <code>window</code> , DOM manipulations, direct access to <code>location</code> , <code>history</code> , <code>document</code> , etc., none of this is on the server.  Anyway, this is a bad practice. </li><li>  The next step is to realize that every time you run the code you need to have a fresh context.  Otherwise, requests from different clients will overlap.  It is highly desirable to store data either locally or in the Redux Store, but not in the general code, there are only static things that do not change from request to request. </li><li>  It is highly desirable to analyze the code for memory leaks, on the server this will quickly become critical. </li><li>  Check and make sure that all used libraries are able to work from under the server. </li></ol><br><h2 id="router">  Router </h2><br><p>  This is probably the easiest part.  You only need to create a function that will return routes each time. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "react"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {IndexRoute, Route} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "react-router"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> NotFound <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./NotFound'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> def(promise) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(cmp =&gt; cmp.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>); } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;Route <span class="hljs-type"><span class="hljs-type">path</span></span>="/"&gt; &lt;IndexRoute getComponent={() =&gt; def(<span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./App'</span></span>))}/&gt; &lt;Route <span class="hljs-type"><span class="hljs-type">path</span></span>=<span class="hljs-string"><span class="hljs-string">'*'</span></span> component={NotFound}/&gt; &lt;/Router&gt;; }</code> </pre> <br><h2 id="redux-store">  Redux store </h2><br><p>  Many export the Redux Store instance in such a way that it becomes a singleton, and even access it not from under React components, you cannot do this on the server.  Each request must have its own Store, so now we will export a function that, on each call, creates it based on the transferred initial state: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {createStore} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"redux"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> reducers <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./reducers"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureStore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialState</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createStore( reducers, initialState ); }</code> </pre> <br><h2 id="stranica-konechnaya-tochka">  Page (end point) </h2><br><p>  The router allows the server to find the desired page, and the page itself should let the server know what data it needs.  For simplicity, we use the convention adopted in the framework of the NextJS framework: the static <code>getInitialProps</code> method.  In this method, we need to make <code>dispatch</code> actions that will bring the store to the desired state and then return control to the outside. </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {withWrapper} from <span class="hljs-string"><span class="hljs-string">"create-react-server/wrapper"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@connect</span></span>(state =&gt; ({foo: state.foo})) <span class="hljs-meta"><span class="hljs-meta">@withWrapper</span></span>() export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Page</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ async getInitialProps({store, history, location, params, query, req, res}) { await store.dispatch({<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'FO</span></span>O', payload: <span class="hljs-symbol"><span class="hljs-symbol">'fo</span></span>o'}); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div&gt; &lt;div&gt;{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.foo}&lt;/div&gt; &lt;/div&gt; ) } }</code> </pre> <br><p>  Instead of <code>async/await</code> you can simply return a <code>Promise</code> or a specific value.  Instead, annotations can be used as - <code>export default connect(...)(Page)</code> . </p><br><p>  In order for the server to understand that the page is a stub for 404, you need to mark it with the static property <code>notFound</code> : </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {withWrapper} from <span class="hljs-string"><span class="hljs-string">"create-react-server/wrapper"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@withWrapper</span></span> export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> 404</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Page</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ static notFound = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;h1&gt;<span class="hljs-type"><span class="hljs-type">Not</span></span> <span class="hljs-type"><span class="hljs-type">Found</span></span>&lt;/h1&gt; ) } }</code> </pre> <br><h2 id="inicializaciya-prilozheniya">  Application Initialization </h2><br><p>  Now we need to put everything together in the main entry point of the application.  A witch with a router is especially necessary if asynchronous paths are used (in our example, it is, a whole one). </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {render} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-dom"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Provider} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-redux"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {browserHistory, match, Router} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-router"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> createRoutes <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./routes"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> createStore <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./reduxStore"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {WrapperProvider} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"create-react-server/wrapper"</span></span>; const mountNode = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'app'</span></span>); const store = createStore(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__INITIAL__STATE__); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      function renderRouter(routes, store, mountNode) { match({history: browserHistory, routes}, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error, redirect, props)</span></span></span><span class="hljs-function"> =&gt;</span></span> { render(( &lt;Provider store={store}&gt; &lt;WrapperProvider initialProps={<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__INITIAL__PROPS__}&gt; &lt;Router {...props}&gt;{routes}&lt;/Router&gt; &lt;/WrapperProvider&gt; &lt;/Provider&gt; ), mountNode); }); } renderRouter(createRoutes(), store, mountNode);</code> </pre> <br><h2 id="shablon-html">  HTML template </h2><br><p>  In the example we use the HtmlWebpackPlugin plugin for convenience and automation.  It is not necessary to do this, but <code>index.html</code> (or another file, how to configure) is required to participate in the Webpack assembly (that is, to get to the output path). </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">charset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"utf-8"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>App<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"app"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h1 id="server">  Server </h1><br><p>  So we got to the server side directly.  When a request arrives at the server, the following chain of events occurs: </p><br><ol><li>  the server tries to find a static file, if it does not work for him, the server tries to determine the final page through a router, if that fails, the router will give the NotFound stub </li><li>  creates a new redux store </li><li>  calls the <code>getInitialProps</code> page, throwing the newly created Store there </li><li>  waits for all asynchronous activity to end </li><li>  renders the application in an HTML string </li><li>  serializes the state of the Store and injects it and HTML into the template (simultaneously waiting for the template to be available, in the dev mode it is generated by the plugin) </li><li>  sends everything to the customer </li></ol><br><p>  Step 6 is necessary, otherwise the client will not be able to correctly apply its code to the resulting HTML due to a state mismatch, as a result, a warning will be displayed that the client has rendered from scratch and all server rendering bonuses have been ignored. </p><br><h2 id="podgotovka">  Training </h2><br><pre> <code class="bash hljs">npm install babel-cli express webpack webpack-dev-server html-webpack-plugin --save-dev</code> </pre> <br><p>  For <code>babel-cli</code> to work correctly, you need to either create a <code>.babelrc</code> , or <code>babel</code> section in <code>package.json</code> .  Keep in mind that if you use <code>babel-plugin-syntax-dynamic-import</code> , then in the Webpack config itself you will need to create a separate config for Babel, which should not have <code>babel-plugin-syntax-dynamic-import</code> , but instead the following things: <code>babel-plugin-dynamic-import-webpack</code> and <code>babel-plugin-transform-ensure-ignore</code> (the first will replace <code>import()</code> with <code>require.ensure</code> , and the second with <code>require.ensure</code> with regular synchronous <code>require</code> ). </p><br><p>  In the <code>scripts</code> section of your <code>package.json</code> add the following: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: <span class="hljs-string"><span class="hljs-string">"webpack --progress"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"webpack-dev-server --progress"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dev-server"</span></span>: <span class="hljs-string"><span class="hljs-string">"NODE_ENV=development babel-node ./index.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"server"</span></span>: <span class="hljs-string"><span class="hljs-string">"NODE_ENV=production babel-node ./index.js"</span></span> } }</code> </pre> <br><p>  Thus, we will have 3 modes: without server rendering <code>start</code> , with rendering and <code>dev-server</code> on the fly, battle <code>server</code> mode (which requires pre-build <code>build</code> ). </p><br><p>  For convenience, <code>webpack.config.js</code> will have a <code>devServer</code> section, where at least you need to register the port and where to get the files, as well as add HtmlWebpackPlugin to the <code>plugins</code> section: </p><br><pre> <code class="hljs coffeescript">var HtmlWebpackPlugin = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'html-webpack-plugin'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... <span class="hljs-string"><span class="hljs-string">"output"</span></span>: { path: process.cwd() + <span class="hljs-string"><span class="hljs-string">'/build'</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    publicPath: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, }, <span class="hljs-string"><span class="hljs-string">"plugins"</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlWebpackPlugin({ filename: <span class="hljs-string"><span class="hljs-string">'index.html'</span></span>, favicon: <span class="hljs-string"><span class="hljs-string">'./src/favicon.ico'</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   template: <span class="hljs-string"><span class="hljs-string">'./src/index.html'</span></span> })], devServer: { port: process.env.PORT || <span class="hljs-number"><span class="hljs-number">3000</span></span>, contentBase: <span class="hljs-string"><span class="hljs-string">'./src'</span></span>, } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... }</code> </pre> <br><h2 id="create-react-server">  Create React Server </h2><br><p>  Now we will install the <a href="https://github.com/kirill-konshin/create-react-server">create-react-server</a> package, which will ease the rendering process. </p><br><pre> <code class="bash hljs">npm install create-react-server --save-dev</code> </pre> <br><p>  We will use the capabilities provided by the <code>webpack-dev-server</code> , and the rendering itself will occur by the same mechanism, but use different file systems (real for the combat mode, and virtual in memory for development).  Middleware will take care of this. </p><br><h2 id="server-dlya-statiki-karkas">  Static server (skeleton) </h2><br><p>  Start by creating a regular static server in the <code>server.js</code> file: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Express <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "express"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> webpack <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "webpack"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Server</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "webpack-dev-server"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "./webpack.config"; const port = process.env.PORT || <span class="hljs-number"><span class="hljs-number">3000</span></span>; //  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { const compiler = webpack(config); <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Server</span></span>(compiler, config.devServer) .<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>(port, <span class="hljs-string"><span class="hljs-string">'0.0.0.0'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { const app = Express(); app.use(Express.static(config.output.path)); app.<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>(port, <span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>(err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) throw err; console.log(<span class="hljs-string"><span class="hljs-string">'Listening %s'</span></span>, port); }</code> </pre> <br><h2 id="server-side-renderer">  Server side renderer </h2><br><p>  Now let's add the rendering directly, and add the middleware configuration for the imports: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">path</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "path"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> createRoutes <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "./src/routes"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> createStore <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "./src/reduxStore"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createExpressMiddleware, createWebpackMiddleware, skipRequireExtensions } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "create-react-server"; //   ,    NodeJS  -JS  skipRequireExtensions(); const <span class="hljs-keyword"><span class="hljs-keyword">options</span></span> = { createRoutes: () =&gt; (createRoutes()), createStore: ({req, res}) =&gt; (createStore({ foo: <span class="hljs-type"><span class="hljs-type">Date</span></span>.now() //   state     })), templatePath: <span class="hljs-type"><span class="hljs-type">path</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(config.output.path, <span class="hljs-string"><span class="hljs-string">'index.html'</span></span>), outputPath: config.output.path };</code> </pre> <br><p>  The <code>template({template, html, store, initialProps, component, req, res})</code> function <code>template({template, html, store, initialProps, component, req, res})</code> can also perform any other transformations with the template, as well as use any template engine instead of the banal <code>.replace()</code> , the output should be a regular HTML string. </p><br><p>  You can also pass an <code>errorTemplate</code> for those cases when something absolutely badly broke and nothing was rendered (in fact, this is the 500th error on the server, an abnormal situation). </p><br><p>  Now you need to replace the code for distributing statics with the configured middleware: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { const compiler = webpack(config); //     config.devServer.setup = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(app) { app.use(createWebpackMiddleware(compiler, config)(<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>)); }; <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Server</span></span>(compiler, config.devServer) .<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>(port, <span class="hljs-string"><span class="hljs-string">'0.0.0.0'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { const app = Express(); //    ,  ! app.use(createExpressMiddleware(<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>)); app.use(Express.static(config.output.path)); app.<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>(port, <span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>); }</code> </pre> <br><p>  A full example is here: <a href="">https://github.com/kirill-konshin/create-react-server/tree/master/examples/webpack-blocks/server.js</a> . </p><br><p>  Now it all remains to run: </p><br><pre> <code class="bash hljs">npm run dev-server</code> </pre> <br><h1 id="chto-mozhno-uluchshit">  What can be improved </h1><br><h2 id="obhod-vseh-komponentov-v-poiskah-getinitialprops">  Traversing all components in <code>getInitialProps</code> </h2><br><p>  There are plans to add this to the library in order to have a fully rendered site at the output, and not just the content area.  With this there is a problem associated with settling the execution sequence and common data between calls within a single request, but this is all solved. </p><br><h2 id="sborka-servera">  Server build </h2><br><p>  For combat mode, you can build a separate version of the server, so as not to use <code>babel-cli</code> in <code>babel-cli</code> , so we will win some memory and reduce the launch time.  You can collect as a stand-alone Babel, as well as through an additional config for Webpack, you must specify <code>{target: 'node', library: 'commonjs'}</code> , and the input point must export <code>createRouter</code> and <code>createStore</code> .  I will add this to the article, if there are requests in the comments, now for the sake of clarity everything is done as simply as possible. </p><br><h2 id="optimizaciya-rendertostring">  <code>renderToString</code> optimization </h2><br><p>  At some point, the <code>renderToString</code> method, which is part of the React DOM, may be the bottleneck.  You can deal with this, for example, <a href="https://github.com/walmartlabs/react-ssr-optimization">https://github.com/walmartlabs/react-ssr-optimization,</a> but this is beyond the scope of the article. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/323500/">https://habr.com/ru/post/323500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323490/index.html">Evolution of nature</a></li>
<li><a href="../323492/index.html">What startups use IaaS</a></li>
<li><a href="../323494/index.html">Chronic Fatigue Syndrome: how to deal with sleep if you are tired of getting tired</a></li>
<li><a href="../323496/index.html">Ansible: configure a zsh terminal with antigen, autosuggestions, fzf and a beautiful prompt with one command</a></li>
<li><a href="../323498/index.html">Ideal catalog, an implementation option</a></li>
<li><a href="../323508/index.html">Eclipse as a technology platform for 1C: Enterprise Development Tools</a></li>
<li><a href="../323510/index.html">Veeam Availability Suite now supports integration with Cisco HyperFlex</a></li>
<li><a href="../323512/index.html">Who is interested in the Russian IaaS</a></li>
<li><a href="../323514/index.html">CocoaHeads video footage March 1, 2017</a></li>
<li><a href="../323516/index.html">Complete latent semantic analysis with Python tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>