<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.Net Core bots for Telegram, Slack and Facebook</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, one of the bank‚Äôs projects posed the task of writing a bot. The result of this experience was this text, which is intended primarily for nov...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.Net Core bots for Telegram, Slack and Facebook</h1><div class="post__text post__text-html js-mediator-article">  Recently, one of the bank‚Äôs projects posed the task of writing a bot.  The result of this experience was this text, which is intended primarily for novice developers. <br><br> <a href="https://habrahabr.ru/company/alfa/blog/343846/"><img src="https://habrastorage.org/webt/-b/wy/80/-bwy80wne-voimxznfmoswfmm-q.png"></a> <br><br>  Practically everyone who uses modern messaging tools has come across bots.  One of the definitions of a bot is a program that performs automatically and / or on a predetermined schedule any actions through interfaces designed for people. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Bots can be used to inform, to automate processes (for example, to automatically generate a task in TFS based on the user's letter) and for many other purposes, but since  one article is not enough to consider all the options, then the story will go only about how to create a bot for processing commands. <br><a name="habracut"></a><br><h3>  Bot for Telegram </h3><br>  The easiest development platform is Telegram.  The process begins with a call to a special bot BotFather. <br><br><img src="https://habrastorage.org/webt/zu/vo/hh/zuvohhl6cnyir6em4cxipxjm8m8.png"><br><br>  It's very simple, in the search bar, type BotFather, press the start button, choose the \ newbot command, and then, consistently answering questions, enter the name of the bot and its user name.  In the final, Telegram will inform you that the bot has been successfully created, will provide its key and will offer to provide an additional description and / or enter command names. <br><br>  Technically, you have two ways to process messages and bot commands.  The first is that your service periodically polls the Telegram server for changes.  For the demonstration, we will use the Telegram.Bot API (the package is available via nuget). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Telegram.Bot; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Telegram.Bot.Args; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Telegram.Bot.Types; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Telegram.Bot.Types.Enums; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TelegramBotClient client; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// token,   BotFather client = new TelegramBotClient(token); client.OnMessage += BotOnMessageReceived; client.OnMessageEdited += BotOnMessageReceived; client.StartReceiving(); Console.ReadLine(); client.StopReceiving(); } private async void BotOnMessageReceived(object sender, MessageEventArgs messageEventArgs) { var message = messageEventArgs.Message; if (message?.Type == MessageType.TextMessage) { await client.SendTextMessageAsync(message.Chat.Id, message.Text); } } }</span></span></code> </pre> <br>  In the example above, each incoming message is resent to the user.  Immediately, I note that in the Telegram the team is also a message, only with the ‚Äú/‚Äù sign. <br><br>  The second method requires a webhook setting, i.e.  a service hosted at an https address that will handle the changes.  This method loads the Telegram server less, but requires a certificate.  However, the problem with the certificate is easily solved thanks to the Ngrok service (https://ngrok.com/), which can tunnel requests from the https address to the application address on your machine. <br><br>  To use Ngrok, you must: <br><br><ul><li>  register on the site and get a personal key; </li><li>  install ngrok.exe and in the command line enter the ngrok authtoken key Ngrok; </li><li>  execute the ngrok http portservice command; </li><li>  In Visual Studio, you can install the Ngrok plugin and use the command from the Tools -&gt; Start Ngrok tunnel menu. </li></ul><br>  After launch, a window will appear with the generated addresses.  Information about all tunneling events will also be displayed here. <br><br><img src="https://habrastorage.org/webt/cv/ag/zh/cvagzhmoxrgcd_sbuhmsgfx-2co.png"><br><br>  The HTTPS address that Ngrok returns will change each time tunneling starts, but you do not need to do this all the time when debugging the application.  Configure tunneling for a specific port once and stop (start) your service as many times as you like. <br><br>  Ngrok has an administrative page, available at <a href="http://127.0.0.1/">127.0.0.1</a> : 4040, where you can view user request parameters. <br><br><img src="https://habrastorage.org/webt/zt/od/vl/ztodvlzu7ut3qfelzucpgxpbauq.png"><br><br>  Let's return to our previous example with a re-sending of the message and create an ASP.NET Core project with the following WebAPI controller. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Route(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"bot"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BotController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { <span class="hljs-comment"><span class="hljs-comment">// token,   BotFather private readonly TelegramBotClient client = new TelegramBotClient(token); [HttpPost] public async void Post([FromBody]Update update) { if (update == null) return; var message = update.Message; if (message?.Type == MessageType.TextMessage) { await client.SendTextMessageAsync(message.Chat.Id, message.Text); } } }</span></span></code> </pre><br>  In order to tell Telegram where the service is located, you can write the following simple console application. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Telegram.Bot; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Telegram.Bot.Args; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Telegram.Bot.Types; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Telegram.Bot.Types.Enums; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// token,   BotFather var client = new TelegramBotClient(token); client.SetWebhookAsync("https   Ngrok ").Wait(); Console.ReadLine(); client.SetWebhookAsync().Wait(); } }</span></span></code> </pre><br><h3>  Slack bot </h3><br>  Consider another popular messaging service.  Creating a bot in Slack starts with a simple form ( <a href="https://api.slack.com/apps/new">https://api.slack.com/apps/new</a> ), where you need to fill in the name of the application and specify the workspace. <br><br>  After clicking the Create App button, a settings page will appear, where in the Add features and functionality subsection you need to select the Slash Commands item in order to proceed to creating bot commands.  On the form that appears, you will need to enter: <br><br><ul><li>  In the Command field - the name of the command. </li><li>  In the Request URL field - https-address of our service </li><li>  In the Short Description field - command assignment </li></ul><br><img src="https://habrastorage.org/webt/ci/gt/dt/cigtdts-k_febslf3hspd-t_3ka.png"><br><br>  In the figure, an example of how a chat from the getmoney command of the AlfaTestNdo bot looks like in a chat. <br><br><img src="https://habrastorage.org/webt/dw/jn/cz/dwjnczjpllmm1ttqt1n3l5_tzfe.png"><br><br>  After selecting the Slack command, the following message is sent to the specified https address <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Message</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> channel_id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> channel_name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> command { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> response_url { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> team_domain { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> team_id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> token { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> trigger_id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> user_id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> user_name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  Now let's see how our service code will look like, sending a ‚Äúhello‚Äù message in response. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Route(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"bot"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BotController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { [HttpPost] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Message message</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uri = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://slack.com/api/chat.postMessage?token="</span></span> + token + <span class="hljs-string"><span class="hljs-string">"&amp;channel=‚Äú + message.channel_id + "</span></span>&amp;text=hello<span class="hljs-string"><span class="hljs-string">"); var httpClient = new HttpClient(); await httpClient.GetAsync(uri).ConfigureAwait(false); } }</span></span></code> </pre><br>  The service calls the chat.postMessage method with the token key and the channel identifier message.channel_id. <br><br>  Slack defines the following types of keys: <br><br><ul><li>  User token is the key of the user who installed the application, and authorization through Oauth is applied.  It has the prefix xoxp.  Read more about it here <a href="https://api.slack.com/docs/oauth">https://api.slack.com/docs/oauth</a> </li><li>  Bot user token - key, technical virtual user.  It has the prefix xoxb.  Read more about them here <a href="https://api.slack.com/bot-users">https://api.slack.com/bot-users</a> . </li><li>  Workspace token - the key of the workspace.  It has the prefix xoxa. </li><li>  Legacy token - key authorized user.  It has the prefix xoxp.  More about them here <a href="https://api.slack.com/custom-integrations/legacy-tokens">https://api.slack.com/custom-integrations/legacy-tokens</a> .  It is not recommended to use them. </li><li>  Verification token - this slack key is sent when accessing your service.  With it, you can verify that it is your application that accesses the service.  Never used to call API methods. </li></ul><br>  All Slack API methods are well documented, contain information about supported keys.  The method description page also has a Tester tab for testing. <br><br>  <a href="https://api.slack.com/methods/chat.postMessage">https://api.slack.com/methods/chat.postMessage</a> <br><br><img src="https://habrastorage.org/webt/tx/eq/pw/txeqpwrnnxgmjv-1tad9kzznxze.png"><br><br>  At the end of the Slack theme, I‚Äôll add that, like in Telegram, you can create not only text messages, but also various interactive components: buttons, menus, and so on. <br><br><h3>  Bot for facebook </h3><br>  Creating a bot on Facebook is more complicated in my opinion than in Telegram and Slack, but on the whole almost the same.  You need to go to the <a href="https://developers.facebook.com/apps">developers.facebook.com/apps</a> page, click the ‚ÄúAdd a new application‚Äù button and enter a name, as well as an email address for feedback. <br><br><img src="https://habrastorage.org/webt/uf/_s/i7/uf_si7bj5hunupl3ue_yq9uhkam.png"><br><br>  After clicking the ‚ÄúCreate application ID‚Äù button, a settings page will open, where you need to specify the bot's personal page (you need to create it) in order to get the access key to the API methods. <br><br><img src="https://habrastorage.org/webt/9x/ni/th/9xnithoclartuv8cxrrrdnotsti.png"><br><br>  In the Webhook section, you will need to specify the https address of your service, come up with verification keys and enter it in the ‚ÄúConfirm token‚Äù field, as well as select the information to which you subscribe. <br><br><img src="https://habrastorage.org/webt/gc/la/cm/gclacmg7s0esnhgloke6xbxq0te.png"><br><br>  Here it is important to know the following, when you click ‚ÄúConfirm and Save‚Äù, Facebook will send a verification message with the fields hub.mode, hub.challenge plus hub.verify_token, which will contain your personal key.  Your service should be able to accept this message and return the hub.challenge as a success if your key was actually transferred to the hub.verify_token field. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Route(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"bot"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BotController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { [HttpGet] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Verify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mode = Request.Query[<span class="hljs-string"><span class="hljs-string">"hub.mode"</span></span>].FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> challenge = Request.Query[<span class="hljs-string"><span class="hljs-string">"hub.challenge"</span></span>].FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> token = Request.Query[<span class="hljs-string"><span class="hljs-string">"hub.verify_token"</span></span>].FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> challenge ?? <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; } }</code> </pre><br>  Suppose you subscribed only to the messages and sent the bot the message ‚Äúhello‚Äù.  In this case, to the https address you specified, Facebook will send a message of the following type. <br><br><img src="https://habrastorage.org/webt/up/le/ss/upless6mmwsexxgw6m88je9ifdc.png"><br><br>  Now what the code for processing incoming messages looks like.  In the example, the message is re-sent back to the user. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Route(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"bot"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BotController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { [HttpPost] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[FromBody] Letter letter</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = letter.entry[<span class="hljs-number"><span class="hljs-number">0</span></span>].messaging[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> token = ‚Äú ,     <span class="hljs-string"><span class="hljs-string">"; var uri = new Uri("</span></span>https:<span class="hljs-comment"><span class="hljs-comment">//graph.facebook.com/v2.6/me/messages?access_token=" + token); var request = (HttpWebRequest)WebRequest.Create(uri); request.ContentType = "application/json"; request.Method = "POST"; using (var requestWriter = new StreamWriter(request.GetRequestStream())) { requestWriter.Write($@" {{recipient: {{ id: {content.sender.id}}},message: {{text: ""{content.message.text}"" }}}}"); } var response = (HttpWebResponse)request.GetResponse(); } }</span></span></code> </pre><br><h3>  Bot framework </h3><br>  Our review will be incomplete if we don‚Äôt touch such a wonderful tool as the Bot Framework from Microsoft. <br><br>  First, the Bot Framework provides a unified API for working with different channels: Bing, Cortana, Email, Facebook, GroupMe, Kik, Skype, Skype for Business, Slack, SMS, Microsoft Teams. <br><br>  Secondly, you get an emulator (https://github.com/Microsoft/BotFramework-Emulator) to test your service, which does not require the https-address setting.  The emulator also allows you to check the already placed service at <a href="https://dev.botframework.com/bots">dev.botframework.com/bots</a> , although in this case you will need to specify the application ID and password. <br><br><img src="https://habrastorage.org/webt/my/lt/n5/myltn5ydrzgjwhoa-lwptdesvw8.png"><br><br>  There are, however, a number of unpleasant moments.  In particular, there is no support for .Net Core.  More about this is written here. <br>  <a href="https://github.com/Microsoft/BotBuilder/issues/572">github.com/Microsoft/BotBuilder/issues/572</a> <br>  <a href="https://designprincipia.com/microsoft-bot-framework-on-asp-net-core/">designprincipia.com/microsoft-bot-framework-on-asp-net-core</a> <br><br>  Let's return to our example with the re-sending of the message.  You will need to install the Bot Framework template. <br><br><img src="https://habrastorage.org/webt/rj/7o/z6/rj7oz6vmpqbdhatqn5_qc7mgjge.png"><br><br>  In this example, in response to a text message from the user (type ActivityTypes.Message) an instance of the class supporting the IDialog interface is created. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Route(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"api/[controller]"</span></span></span><span class="hljs-meta">)</span></span>] [BotAuthentication] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MessagesController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { [HttpPost] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;HttpResponseMessage&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[FromBody]Activity activity</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activity?.Type == ActivityTypes.Message) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Conversation.SendAsync(activity, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dialogs.RootDialog()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpResponseMessage(HttpStatusCode.OK); } }</code> </pre><br>  In our case, this is the RootDialog class with the StartAsync method, which organizes the task of sending an incoming message. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RootDialog</span></span> : <span class="hljs-title"><span class="hljs-title">IDialog</span></span>&lt;<span class="hljs-title"><span class="hljs-title">object</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDialogContext context</span></span></span><span class="hljs-function">)</span></span> { context.Wait(MessageReceivedAsync); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.CompletedTask; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageReceivedAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDialogContext context, IAwaitable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> activity = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Activity; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.PostAsync(activity.Text); context.Wait(MessageReceivedAsync); } }</code> </pre><br>  In my opinion, the most interesting feature of the Bot Framework is the Connector.  This is an API that allows you to organize communication between different channels.  More details can be found here: <a href="https://docs.microsoft.com/en-us/bot-framework/dotnet/bot-builder-dotnet-connector">docs.microsoft.com/en-us/bot-framework/dotnet/bot-builder-dotnet-connector</a> <br><br><h3>  Conclusion </h3><br>  If we compare the development of a bot and a web application, we can note the following: in both cases, the middle-layer query processing is equally required, but as far as the front-part is concerned, the difference is significant.  When you make a bot, you do not need to search for resources in order to develop an interface that can work in different browsers and operating systems, since  the interface is the responsibility of the messaging service developer.  And although you have no control over the API, in many cases the implementation of user interaction through a bot instead of a site may be more promising and save a lot of resources. <br><br><h3>  useful links </h3><br><h4>  Official instructions </h4><br><ul><li>  <a href="https://core.telegram.org/bots">Information on creating bots in Telegram</a> </li><li>  <a href="https://api.slack.com/apps">Information on bots in Slack</a> </li><li>  <a href="https://developers.facebook.com/docs/messenger-platform/getting-started/quick-start">Instructions for creating a bot on Facebook</a> </li><li>  <a href="https://docs.microsoft.com/en-us/bot-framework/overview-introduction-bot-framework">Bot Framework Documentation</a> </li><li>  <a href="https://developers.viber.com/docs/api/rest-bot-api">Information on Viber bots</a> </li><li>  <a href="https://vk.com/dev/bots">vk.com/dev/bots</a> and <a href="https://vk.com/dev/bots_docs">vk.com/dev/bots_docs</a> "- information on VK bots </li></ul><br><h4>  Sdk </h4><br><ul><li>  <a href="">Telegram API on .Net (Telegram.Bot nuget package)</a> </li><li>  <a href="https://github.com/TelegramBots/telegram.bot.examples">API examples telegram.bot</a> </li><li>  <a href="https://api.slack.com/community">Official page on API implementations in various languages, including C #</a> </li></ul><br><h4>  Additional instructions </h4><br><ul><li>  <a href="http://aftamat4ik.ru/pishem-bota-telegram-na-c/">The article "Write a Telegram bot in C #"</a> </li><li>  <a href="https://habrahabr.ru/sandbox/103396/">The article ‚ÄúHow to easily write a bot for Telegram on C #‚Äù</a> </li><li>  <a href="https://www.youtube.com/playlist%3Flist%3DPLgF-CyaX1p3FE55OTRNH-kOb16zqeBZCo">Cycle video on the Microsoft Bot Framework</a> </li><li>  <a href="https://habrahabr.ru/post/281559/">The article "Developing a chat bot for Facebook Messenger"</a> </li><li>  <a href="https://tutorials.botsfloor.com/facebook-chatbot-in-asp-net-2f9379a238b0">Facebook Chatbot in ASP.NET article</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/343846/">https://habr.com/ru/post/343846/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343836/index.html">EU GDPR: Compliance with the requirements of regulators in the field of cloud computing</a></li>
<li><a href="../343838/index.html">Analyze it - Lenta.ru</a></li>
<li><a href="../343840/index.html">Renga development team: how we reached the idyll, working without managers</a></li>
<li><a href="../343842/index.html">WD (Western Digital) plans to create a 40 TB disk, but is this enough?</a></li>
<li><a href="../343844/index.html">How programmers with PVS-Studio looked for project errors</a></li>
<li><a href="../343848/index.html">Gifts from M.Video: what's under the hood?</a></li>
<li><a href="../343850/index.html">On the results of the MERC-2017 contest: winners and comments</a></li>
<li><a href="../343852/index.html">Interfaces in C #</a></li>
<li><a href="../343854/index.html">ASO Monthly # 16: August 2017</a></li>
<li><a href="../343856/index.html">ITSM Digest: 20 materials on optimizing IT processes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>