<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Networks for the harshest. Part fifteen. QoS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="-15. About QoS. Now with the ability to pull requests . 

 And here we come to the topic of QoS. 

 Do you know why only now and why this will be the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Networks for the harshest. Part fifteen. QoS</h1><div class="post__text post__text-html js-mediator-article">  -15.  About QoS.  Now with the ability to <a href="https://linkmeup.gitbook.io/sdsm/">pull requests</a> . <br><br>  And here we come to the topic of QoS. <br><br>  Do you know why only now and why this will be the closing article of the entire course of SDCM?  Because QoS is unusually complex.  The hardest thing that was previously in the cycle. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is not some kind of magic archiver, which will cleverly compress traffic on the fly and push your gigabit into a hundred megabit uplink.  QoS is about how to sacrifice something unnecessary, cramming nevpihuemoe within the limits of what is permitted. <br><br>  QoS is so entangled in the aura of shamanism and inaccessibility that all young (and not only) engineers try to carefully ignore its existence, believing that it is enough to shower problems with money, and endlessly extending links.  True, until they realize that with such an approach, failure inevitably awaits them.  Either the business will start asking uncomfortable questions, or there will be a lot of problems almost unrelated to the width of the channel, but directly dependent on the effectiveness of its use.  Yeah, VoIP is actively waving a handle from behind the scenes, and multicast traffic sarcastically strokes your back. <br><br>  Therefore, let's just realize that QoS is necessary, it will have to get to know one way or another, and why not start now in a calm atmosphere. <br><br><img src="https://habrastorage.org/webt/sc/of/k6/scofk6lx2y49bzisp0pwsnrsywg.jpeg"><a name="habracut"></a><br><hr><br><h1>  Content </h1><br>  1. <b>What determines QoS?</b> <br><br><ul><li>  Losses </li><li>  Delays </li><li>  Jitter </li></ul><br>  2. <b>Three QoS models</b> <br><br><ul><li>  Best effort </li><li>  Integrated services </li><li>  Differentiated Services </li></ul><br>  3. <b>DiffServ mechanisms</b> <br><br>  4. <b>Classification and labeling</b> <br><br><ul><li>  Behavior Aggregate </li><li>  Multi-field </li><li>  Interface-Based </li></ul><br>  5. <b>Queues</b> <br><br>  6. <b>Congestion Avoidance (Congestion Avoidance)</b> <br><br><ul><li>  Tail Drop and Head Drop </li><li>  RED </li><li>  Wred </li></ul><br>  7. <b>Congestion Management</b> <br><br><ul><li>  First In, First Out </li><li>  Priority queuing </li><li>  Fair queuing </li><li>  Round robin </li></ul><br>  8. <b>Speed ‚Äã‚ÄãLimit</b> <br><br><ul><li>  Shaping </li><li>  Policing </li><li>  Leaky Bucket and Token Bucket Mechanisms </li></ul><br>  9. <b>Hardware QoS implementation</b> <br><hr><br><blockquote>  Before the reader dives into this hole, I will lay three installations in it: <br><br><ul><li>  Not all problems can be solved by expanding the band. </li><li>  QoS does not extend the band. </li><li>  QoS about managing limited resources. </li></ul></blockquote><br><h1>  1. What determines QoS? </h1><br>  The business expects from the network stack that it will simply perform its simple function well - to deliver the bitstream from one host to another: without loss and in a predictable time. <br><br>  All network quality metrics can be derived from this short sentence: <br><br><ul><li>  Losses </li><li>  Delays </li><li>  Jitter </li></ul><br>  These three characteristics determine the <a href="https://tools.ietf.org/html/rfc2549">quality of the network</a> regardless of its nature: packet, channel, IP, MPLS, radio, <a href="https://tools.ietf.org/html/rfc1149">pigeons</a> . <br><br><h2>  Losses </h2><br>  This metric tells how many of the packets sent by the source reached the addressee. <br>  The cause of losses can be a problem in the interface / cable, network overload, bit errors, blocking ACL rules. <br><br>  What to do in case of losses is decided by the application.  It can ignore them, as in the case of a telephone conversation, where the late packet is no longer needed, or to re-request it to be sent - this is what TCP does to ensure accurate delivery of the original data. <br><br><img src="https://habrastorage.org/webt/s9/vc/jj/s9vcjjwjb494cyrx19oby8ykvms.png" width="600"><br><br>  How to manage losses, if they are inevitable, in the chapter Congestion Management. <br><br>  How to use losses in the benefit in the chapter Prevention of overloads. <br><br><h2>  Delays </h2><br>  This is the time it takes the data to get from the source to the recipient. <br><br><img src="https://habrastorage.org/webt/m6/xo/qa/m6xoqapl9y6v422k8c4d--xtmvm.png" width="600"><br><br>  The cumulative delay is made up of the following components. <br><br><ul><li>  <b>Serialization Delay</b> - the time it <b>takes</b> for a node to decompose a packet into bits and place it on the link to the next node.  It is determined by the speed of the interface.  So, for example, transmission of a packet of 1500 bytes in size through an interface of 100 Mb / s will take 0.0001 s, and for 56 Kb / s - 0.2 s. </li><li>  <b>The delay in signal transmission in the medium</b> ( <b>Propagation Delay</b> ) is the result of the notorious limitation of the speed of propagation of electromagnetic waves.  Physics does not allow to get from New York to Tomsk on the surface of the planet in less than 30 ms (in fact, about 70 ms). </li><li>  <b>The delays introduced by QoS</b> are the languor of packets in queues ( <b>Queuing Delay</b> ) and the consequences of shaping ( <b>Shaping Delay</b> ).  Today we will talk about this a lot and tediously in the chapter Speed ‚Äã‚Äãcontrol. </li><li>  <b>Processing Delay</b> - the time to decide what to do with the packet: lookup, ACL, NAT, DPI - and its delivery from the input interface to the output.  But on the day when Juniper, in its M40, separated Control and Data Plane, the processing delay became neglected. </li></ul><br>  Delays are not so terrible for applications where rush is not required: file sharing, surfing, VoD, Internet radio stations, etc.  And on the contrary, they are critical for interactive: 200ms are already unpleasant to the ear during a telephone conversation. <br><br>  A delayed term, but not synonymous with <b>RTT</b> ( <b>Round Trip Time</b> ), is a round-trip way.  When pinging and tracing, you see RTT, and not one-way delay, although the values ‚Äã‚Äãdo have a correlation. <br><br><h2>  Jitter </h2><br>  The difference in delays between the delivery of consecutive packets is called jitter. <br><br><img src="https://habrastorage.org/webt/hv/-j/9z/hv-j9zu-h0eyuzkf9eaupcputhe.png" width="600"><br><br>  Like latency, jitter is irrelevant for many applications.  And even it would seem, what's the difference - the package was delivered, what more? <br><br>  However, it is important for interactive services. <br><br>  Take as an example the same telephony.  In fact, it is the digitization of analog signals divided into separate chunks of data.  The output is a fairly uniform stream of packets.  On the receiving side there is a small buffer of a fixed size, in which successively incoming packets are placed.  To restore an analog signal, you need a certain number of them.  Under conditions of floating delays, the next data chunk may not arrive in time, which is tantamount to loss, and the signal cannot be recovered. <br><br>  The greatest contribution to the variability of the delay makes just QoS.  About this, too, a lot and tedious in the same chapters Speed ‚Äã‚Äãlimit. <br><br><hr><br>  These are the three main characteristics of the quality of the network, but there are two others that also play an important role. <br><br><h2>  Unscheduled delivery </h2><br>  A number of applications such as telephony, <a href="http://lookmeup.linkmeup.ru/">NAS</a> , <a href="http://lookmeup.linkmeup.ru/">CES are</a> extremely sensitive to unordered packet delivery when they arrive at the recipient in a different order than they were sent.  This can lead to loss of connectivity, errors, damage to the file system. <br><br>  Although unordered delivery is not a formal QoS characteristic, it definitely refers to network quality. <br><br>  Even in the case of TCP tolerant to this kind of problems, duplicate ACKs and retransmitts occur. <br><br><img src="https://habrastorage.org/webt/yu/51/63/yu5163hdbesjbypr34w4w5puhbo.png" width="600"><br><br><h2>  Bandwidth </h2><br>  It is not distinguished as a network quality metric, since in fact its flaw results in the three mentioned above.  However, in our realities, when it should be guaranteed to some applications or, conversely, should be limited under the contract, for example MPLS TE reserves it throughout the entire LSP, it is worth mentioning it, at least as a weak metric. <br>  Speed ‚Äã‚Äãcontrol mechanisms are discussed in chapters Speed ‚Äã‚Äãlimit. <br><br><hr><br>  Why characteristics may deteriorate? <br><br>  So, we start with a very primitive view that a network device (whether it is a switch, a router, a firewall, whatever) is just another piece of pipe called a communication channel, the same as a copper wire or an optical cable. <br><br><img src="https://habrastorage.org/webt/r2/yh/hr/r2yhhr2urldnn3t6mqhhk6erz-u.png" width="600"><br><br>  Then all the packages fly through in the same order in which they came and do not experience any additional delays - there is nowhere to linger. <br><br>  But actually, each router recovers bits and packets from a signal, does something with them (we don‚Äôt think about it yet) and then converts the packets back into a signal. <br><br>  A delay in serialization appears.  But in general, it is not scary because it is constant.  Not scary as long as the width of the output interface is larger than the input. <br><br>  For example, at the entrance to the device is a gigabit port, and at the output is a radio relay line 620 MB / s connected to the same gigabit port? <br><br>  Nobody forbids bullet through a formally gigabit link gigabit traffic. <br>  Nothing can be done about this - 380 MB / s will be spilled on the floor. <br><br>  Here they are - the loss. <br><br>  But at the same time, I would very much like to see the worst part of it spill out - the video from youtube, and the executive director‚Äôs telephone conversation with the plant director was not interrupted and did not even cry. <br><br>  I wish the voice had a dedicated line. <br><br>  Or the input interfaces are five, and the output one, and at the same time, five nodes began to try to inject traffic to one recipient. <br><br>  Add a pinch of VoIP theory (an article about which no one has written) - it is very sensitive to delays and their variations. <br><br>  If for the TCP stream of video from youtube (at the time of writing the article <a href="https://habr.com/company/infopulse/blog/315172/">QUIC</a> - still remains an experiment), even seconds are absolutely free of delays due to buffering, the director will call the head of the technical department after the first such conversation with Kamchatka. <br>  In older times, when the author of the cycle was still doing lessons in the evenings, the problem was particularly acute.  Modem connections had a <a href="https://se7en.ru/post/4671.html">speed of 56k</a> . <br><br>  And when such a connection received a one-and-a-half-kilo packet, he occupied the entire line for 200 ms.  No one else could pass at this moment.  Vote?  No, have not heard. <br><br>  Therefore, the issue of MTU is so important - the package should not occupy the interface too long.  The less speedy it is, the less MTU is needed. <br><br>  These are the delays. <br><br>  Now the channel is free and the delay is low, in a second someone started downloading a large file and the delays grew.  Here it is - jitter. <br><br>  Thus, it is necessary that voice packets fly through the pipe with minimal delays, and youtube will wait. <br><br>  Available 620 MB / s should be used for voice, video, and B2B clients buying VPNs.  I wish that one traffic does not oppress the other, then you need a band guarantee. <br><br><hr><br>  All the above characteristics are universal regarding the nature of the network.  However, there are three different approaches to their provision. <br><br><h1>  2. Three QoS models </h1><br><ul><li>  Best Effort - no guarantee of quality.  Everyone is equal. </li><li>  IntServ - quality assurance for each stream.  Reserve resources from source to destination. </li><li>  DiffServ - there is no reservation.  Each node determines how to ensure the desired quality. </li></ul><br><h2>  Best Effort (BE) </h2><br>  <i>No guarantees.</i> <br><br>  The simplest approach to the implementation of QoS, from which IP networks began and which is practiced to this day - sometimes because it is sufficient, but more often because no one thought about QoS. <br><br>  By the way, when you send traffic to the Internet, it will be processed there as BestEffort.  Therefore, through VPN, prokinutnye over the Internet (as opposed to the VPN provided by the provider), can not very confident to go important traffic, such as a telephone conversation. <br><br>  In case of BE, all traffic categories are equal, no preference is given.  Accordingly, there is no guarantee for delay / jitter or band. <br><br>  This approach has a somewhat counterintuitive name - Best Effort, which is misleading the novice with the word ‚Äúbest‚Äù. <br><br>  However, the phrase ‚ÄúI will do my best‚Äù means that the speaker will try to do everything that he can, but does not guarantee anything. <br><br>  Nothing is required to implement BE ‚Äî this is the default behavior.  It is cheap in production, staff do not need deep specific knowledge, QoS in this case defies any configuration. <br><br>  However, this simplicity and static nature does not lead to the fact that the Best Effort approach is not used anywhere.  It finds application in networks with high bandwidth and no congestion and surges. <br><br>  For example, on transcontinental lines or in networks of some data centers where there is no oversubscription. <br>  In other words, in networks without overloads and where there is no need to treat any traffic in a special way (for example, telephony), BE is quite appropriate. <br><br><h2>  Intserv </h2><br>  <i>Advance reservation of resources for the stream from the source to the receiver.</i> <br><br>  In the growing unsystematic Internet, the fathers of the MIT, Xerox, ISI networks decided to add an element of predictability, while maintaining its efficiency and flexibility. <br><br>  So in 1994, the idea of ‚Äã‚ÄãIntServ was born in response to the rapid growth of real-time traffic and the development of multicast.  It was reduced then to IS. <br><br>  The name reflects the desire in the same network to simultaneously provide services for real-time and non-real-time traffic types, providing, first of all, the priority right to use resources through band reservation.  The possibility of reusing the band, on which everyone earns, and thanks to what the IP shot, at the same time remained. <br><br>  The reservation mission was assigned to RSVP, which reserves bandwidth on <b>each</b> network device for <b>each</b> stream. <br><br>  Roughly speaking, before setting up a Single Rate Three Color MarkerP session or starting data exchange, end hosts send an RSVP Path indicating the required bandwidth.  And if RSVP Resv is back to both of them, they can start communicating.  However, if there are no resources available, RSVP returns an error and the hosts cannot communicate or will follow the BE. <br><br>  Let the bravest of readers now imagine that for <b>any</b> stream on the Internet today a channel will be signaled in advance.  Considering that this requires non-zero CPU and memory costs on <b>each</b> transit node, postpones the actual interaction for a while, it becomes clear why IntServ turned out to be actually a stillborn idea - zero scalability. <br><br>  In a sense, the modern incarnation of IntServ is MPLS TE with the RSVP version RSVP TE adapted for tag transmission.  Although here, of course, not End-to-End and not per-flow. <br><br>  IntServ is described in <a href="https://tools.ietf.org/html/rfc1633">RFC 1633</a> . <br>  The document is in principle curious to evaluate how naive one can be in forecasts. <br><br><h2>  Diffserv </h2><br>  <i>DiffServ complex.</i> <br><br>  When it became clear at the end of the 90s that the IntServ IP end-to-end approach failed, the IETF convened a working group, Differentiated Services, in 1997, which developed the following requirements for a new QoS model: <br><br><ul><li>  No alarm (Adyos, RSVP!). </li><li>  Based on aggregated traffic classification, instead of focusing on flows, clients, etc. </li><li>  It has a limited and deterministic set of actions to handle the traffic of these classes of data. </li></ul><br>  As a result, the epoch-making <a href="https://tools.ietf.org/html/rfc2474">RFC 2474</a> ( <i>Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers</i> ) and <a href="https://tools.ietf.org/html/rfc2475">RFC 2475</a> ( <i>An Architecture for Differentiated Services</i> ) were born in 1998. <br><br>  And then all the way we will talk only about DiffServ. <br><br><blockquote>  It should be noted that the name DiffServ is not the antithesis of IntServ.  It reflects that we differentiate the services provided by various applications, or rather their traffic, in other words, we divide / differentiate these types of traffic. <br>  IntServ does the same thing - it distinguishes between the types of BE traffic and Real-Time traffic transmitted on the same network.  Both: both IntServ and DiffServ - refer to ways to differentiate services. </blockquote><br><hr><br><h1>  3. DiffServ mechanisms </h1><br>  What is DiffServ and why does it win against IntServ? <br><br>  If it is very simple, then the traffic is divided into classes.  A package at the entrance to each node is classified and a set of tools is applied to it, which processes packages of different classes differently, thus providing them with a different level of service. <br><br>  But it just <a href="">will not</a> . <br><br>  At the heart of DiffServ is the ideological concept of the IP traditionally held in the traditions of <b>PHB - Per-Hop Behavior</b> .  Each node on the path of traffic independently makes a decision on how to behave with respect to the incoming packet, based on its headers. <br><br>  The actions of a router with a packet are called a behavior model ( <b>Behavior</b> ).  The number of such models is deterministic and limited.  Different devices may have different behaviors with respect to the same traffic, so they are per-hop. <br><br>  <i>The concepts of <b>Behavior</b> and <b>PHB</b> I will use in the article as synonyms.</i> <br><blockquote>  There is a slight confusion.  PHB is, on the one hand, the general concept of independent behavior of each node, on the other - a specific model on a specific node.  With this we will understand. <br></blockquote><img src="https://habrastorage.org/webt/8w/jq/kq/8wjqkqc9e4jwrm1lokdaahlnod8.png" width="600"><br><br>  The behavior model is determined by the set of tools and their parameters: Policing, Dropping, Queuing, Scheduling, Shaping. <br><br>  Using existing behaviors, the network can provide various classes of service ( <b>Class of Service</b> ). <br><br>  That is, different categories of traffic can get a different level of service on the network by applying different PHBs to them. <br><br>  Accordingly, first of all, it is necessary to determine to which class of service the traffic belongs - classification ( <b>Classification</b> ). <br><br>  Each node independently classifies incoming packets. <br><br><img src="https://habrastorage.org/webt/_o/lp/jm/_olpjmv8pc3bclzzg9qtvh1_vke.png" width="700"><br><br>  After classification, a measurement occurs ( <b>Metering</b> ) - how many bits / bytes of the traffic of this class came to the router. <br><br>  Based on the results, the packages can be colored ( <b>Coloring</b> ): green (within the limits of the established limit), yellow (outside the limit), red (all along the coast). <br><br><img src="https://habrastorage.org/webt/3h/6g/xi/3h6gxiq2g_7lejnvonvxtft9pys.png" width="700"><br><br>  If necessary, then policing occurs (forgive me for such a tracing paper, there is a better option - write, I will change).  A polisher based on the color of the packet assigns an action to the packet ‚Äî transfer, discard, or remark. <br><br><img src="https://habrastorage.org/webt/ft/gk/2k/ftgk2klys-yvgdicuzs1i8zg3lo.png" width="700"><br><br>  After that, the packet should go into one of the queues ( <b>Queuing</b> ).  For each class of service, a separate queue is allocated, which allows them to be differentiated using different PHBs. <br><br>  But even before the packet enters the queue, it can be dropped ( <b>Dropper</b> ) if the queue is full. <br><br>  If he is green, he will pass, if yellow, then it is likely to be rejected, if the queue is full, and if red - this is a sure suicide bomber.  Conventionally, the probability of dropping depends on the color of the packet and the fullness of the queue where it is going to get. <br><br><img src="https://habrastorage.org/webt/er/q2/ks/erq2ksivfaq7yj2gch6ihcbezts.png" width="700"><br><br>  At the exit of the queue, the shaper ( <b>Shaper</b> ), whose task is very similar to the polisher task, is to limit traffic to the specified value. <br><br>  You can configure arbitrary shapers for individual queues or even within queues. <br>  On the difference between the shaper and the polisher in the chapter Speed ‚Äã‚Äãlimits. <br><br>  All queues should eventually merge into a single output interface. <br><br>  Remember the situation when on the road 8 lanes merge into 3. Without a traffic controller, this turns into chaos.  Separating by queues would not make sense if we had the same output as the output. <br><br>  Therefore, there is a special dispatcher ( <b>Scheduler</b> ), which cyclically takes out packets from different queues and sends them to the interface ( <b>Scheduling</b> ). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, a bunch of queues and the dispatcher is the most important QoS mechanism that allows you to apply different rules to different traffic classes, one providing a wide band, the other low delays, the third the absence of drops. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, the packets already go to the interface, where the packets are converted into a bitstream ‚Äî serialization ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serialization</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) and then the medium signal. </font></font><br><br><img src="https://habrastorage.org/webt/dy/i2/pk/dyi2pkpat1havyiz3ps3dmret-y.png" width="700"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In DiffServ, the behavior of each node, regardless of the rest, there are no signaling protocols that would report which QoS policy is on the network. At the same time within the network I would like the traffic to be processed in the same way. If only one node will behave differently, the entire QoS policy will go to waste.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To do this, firstly, on all routers, the same classes and PHBs are configured for them, and secondly, the </font><font style="vertical-align: inherit;">packet </font><font style="vertical-align: inherit;">marking ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Marking</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) is used - its belonging to a particular class is recorded in the header (IP, MPLS, 802.1q). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the beauty of DiffServ is that the next node can trust this marking when classifying. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such a zone of trust, in which the same traffic classification rules and certain behaviors apply, is called the DiffServ domain ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DiffServ-Domain</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><img src="https://habrastorage.org/webt/8o/7d/ex/8o7dexwfq0xawzyhsuix7-viewi.png" width="700"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, at the entrance to the DiffServ domain, we can classify the package on the basis of 5-Tuple or interface, mark ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remark / Rewrite</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) it is according to the rules of the domain, and further nodes will trust this marking and not make a complex classification. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, there is no explicit signaling in DiffServ, but a node can tell all of the following which class to provide to this package, expecting it to trust. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the junctions between the DiffServ-domains, you need to coordinate the QoS policy (or not). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The whole picture will look like this:</font></font><br><br><img src="https://habrastorage.org/webt/_-/7v/nt/_-7vntuvn9r1ugem7yenmxoj9fw.png" width="1000"><br><blockquote>   ,     . <br>    ( ). <br>     (CoS): , , . <br>      (Classification) ‚Äî        . <br>     (Remark) ‚Äî     . <br>     (PHB): Best Effort  Premium. <br>  ,   :     VIP Lounge,    ,      ,     -,   . <br>        ‚Äî  Best Effort,  ‚Äî Premium ,   ‚Äî Premium SUPER-POWER-NINJA-TURBO-NEO-ULTRA-HYPER-MEGA-MULTI-ALPHA-META-EXTRA-UBER-PREFIX! <br>    Premium   ,     ,     . <br><br>          . ,          ,   (Drop).            (Queuing).      ,  ,   (Scheduling),           (). <br><br>        ‚Äî    (Propagation),  ‚Äî   (Serialization),     ‚Äî Queuing,    ‚Äî Processing. ,    Processing Delay       . <br><br>         ‚Äî  PHB .        , ,  ,     ,     ‚Äî  DiffServ-domain. <br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you may have noticed, DiffServ is extremely (or infinitely) complex. But everything described above, we will analyze. In this article, I will not go into the nuances of the physical implementation (they can differ even on two cards of the same router), I will not talk about HQoS and MPLS DS-TE. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The threshold for entering the circle of engineers who understand the technology for QoS is much higher than for routing protocols, MPLS, or, forgive me, Radya, STP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And despite this, DiffServ has earned recognition and implementation on networks around the world, because, as they say, Highly Scaleble. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All further part of the article I will analyze only DiffServ. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below we will analyze all the tools and processes indicated in the illustration.</font></font><br><br><img src="https://habrastorage.org/webt/qb/21/kg/qb21kgaqnsm6-pi2qwe0rdniqq4.png" width="600"><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the course of disclosing the topic, I will show some things in practice. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will work with such a network: </font></font><br><br><img src="https://habrastorage.org/webt/zc/0o/zn/zc0ozndb8nmrqajljkf98pp79tk.png" width="900"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trisolarans is a client of a linkmeup provider with two connection points. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The yellow area is the DiffServ-domain of the network linkmeup, which has a single QoS policy. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linkmeup_R1 is a CPE device that is under the control of the provider, and therefore in the trusted zone. </font><font style="vertical-align: inherit;">OSPF is raised with it and the interaction takes place via pure IP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Within the MPLS + LDP + MP-BGP network core with L3VPN, stretched from Linkmeup_R2 to Linkmeup_R4. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All other comments I will give as needed. </font></font><br><br> <a href="https://docs.google.com/document/d/e/2PACX-1vRmqX4Zn20LhoAj-cmlZJq9XIB3YCE6VVgrh0Fa1E3cCW22R2S2xM4xIZu4PiTjBFvqulNLilmoaH7J/pub"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initial configuration file</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><hr><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. Classification and labeling </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inside his network, the administrator defines the classes of service that he can provide traffic. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, the first thing that each node does when receiving a packet is its classification. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are three ways:</font></font><br><br><ol><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Behavior Aggregate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just trust the package label in the header. </font><font style="vertical-align: inherit;">For example, the IP DSCP field. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is called so because under one label in the DSCP field, various categories of traffic are aggregated, which expect the same behavior in relation to itself. </font><font style="vertical-align: inherit;">For example, all SIP sessions will be aggregated into one class. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The number of possible classes of service, and hence the patterns of behavior, is limited. </font><font style="vertical-align: inherit;">Accordingly, it is impossible to distinguish a separate class for each category (or even more so for the stream) - it is necessary to aggregate.</font></font></li><li> <b>Interface-based</b> <br> ,     ,     . ,   ,          .      . </li><li> <b>MultiField</b> ( <b>MF</b> ) <br>     ‚Äî IP-, , MAC-.  ,  . <br><br> ,  ,     10.127.721.0/24   5000,    , ,  5-  . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The administrator determines the set of service classes that the network can provide and matches them with a numeric value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We do not trust anyone at the entrance to the DS-domain, so the classification is carried out by the second or third method: the class of service and the corresponding digital value are determined on the basis of addresses, protocols or interfaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the exit of the first node, this digit is encoded in the DSCP field of the IP header (or another field of the Traffic Class: MPLS Traffic Class, IPv6 Traffic Class, Ethernet 802.1p) ‚Äîremarking occurs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is customary to trust this marking inside the DS-domain, therefore transit nodes use the first classification method (BA) - the simplest. No complicated analysis of headings, we look only at the recorded number.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the junction of the two domains can be classified based on the interface or MF, as I described above, and you can trust the labeling of BA with reservations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, trust all values ‚Äã‚Äãexcept 6 and 7, and 6 and 7 re-mark to 5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This situation is possible in the case when the provider connects a legal entity that has its own labeling policy. </font><font style="vertical-align: inherit;">The provider does not object to keep it, but at the same time does not want traffic to fall into the class in which packets of network protocols are transmitted to it.</font></font><br><br><img src="https://habrastorage.org/webt/8o/7d/ex/8o7dexwfq0xawzyhsuix7-viewi.png" width="900"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Behavior Aggregate </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BA uses a very simple classification - I see a number - I understand the class. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So what's the number? </font><font style="vertical-align: inherit;">And what field is it recorded in?</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IPv6 Traffic Class </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MPLS Traffic Class </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ethernet 802.1p </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basically, the classification occurs on a switching header. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I call the switch a header, on the basis of which the device determines where to send the packet so that it gets closer to the receiver. </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, if an IP packet arrives at the router, the IP header and the DSCP field are analyzed. </font><font style="vertical-align: inherit;">If MPLS arrived, MPLS Traffic Class is analyzed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If an Ethernet + VLAN + MPLS + IP packet arrives on a regular L2 switch, then 802.1p will be analyzed (although this can be changed).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IPv4 TOS </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The QoS field accompanies us exactly the same as the IP. </font><font style="vertical-align: inherit;">The eight-bit TOS field ‚Äî Type Of Service ‚Äî was supposed to carry the packet priority. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even before the appearance of DiffServ </font></font><a href="https://tools.ietf.org/html/rfc791"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC 791</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INTERNET PROTOCOL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), the field was described as follows: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP Precedence (IPP) + DTR + 00. </font></font><br><br><img src="https://habrastorage.org/webt/fw/fe/of/fwfeofy_xr9dbft1vbap2djoszm.png" width="700"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, packet priority occurs, then the requirements for Delay, Throughput, Reliability (0 - no requirements, 1 - with requirements) . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last two bits must be zero.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Priority determined the following values ‚Äã‚Äã...</font></font></b> <div class="spoiler_text"> 111 ‚Äî Network Control <br> 110 ‚Äî Internetwork Control <br> 101 ‚Äî CRITIC/ECP <br> 100 ‚Äî Flash Override <br> 011 ‚Äî Flash <br> 010 ‚Äî Immediate <br> 001 ‚Äî Priority <br> 000 ‚Äî Routine <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A little later in </font></font><a href="https://tools.ietf.org/html/rfc1349"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC 1349</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type of Service in the Internet Protocol Suite</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) the TOS field was slightly redefined: The </font></font><br><br><img src="https://habrastorage.org/webt/95/dz/pm/95dzpm400ckireeowdta1q_7lvg.png" width="700"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">left three bits remained IP Precedence, the next four turned into TOS after adding the Cost bit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here's how to read the units in these TOS bits:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D - ‚Äúminimize </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elay‚Äù,</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T - "maximize </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hroughput",</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R - "maximize </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eliability",</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C - ‚Äúminimize </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ost‚Äù.</font></font></li></ul><br>  Misty descriptions did not contribute to the popularity of this approach. <br><br>  There was no systematic approach to QoS all the way, there were no clear recommendations on how to use the priority field, the description of the Delay, Throughput and Reliability bits was extremely vague. <br><br>  Therefore, in the context of DiffServ, the TOS field was once again redefined in <a href="https://tools.ietf.org/html/rfc2474">RFC 2474</a> ( <i>Definition of Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers</i> ): <br><br><img src="https://habrastorage.org/webt/n_/ie/zm/n_iezmmdhv2tg7qlbxqad7c_4_m.png" width="700"><br><br>  Instead of the IPP and DTRC bits, they entered a six-bit DSCP field - <b>Differentiated Services Code Point</b> , the two right bits were not used. <br><br>  From this point on, it was the DSCP field that should have become the main DiffServ label: a specific value (code) is written into it, which, within this DS domain, characterizes the specific service class required for a packet and its drop priority.  This is the same figure. <br><br>  The administrator can use all 6 bits of DSCP as he pleases, dividing up to a maximum of 64 classes of service. <br><br>  However, for the sake of compatibility with IP, Precedence has retained the role of the Class Selector for the first three bits. <br><br>  That is, as in IPP, the 3 bits of the Class Selector allow you to define 8 classes. <br><br><img src="https://habrastorage.org/webt/fw/vl/p0/fwvlp0wanilpj7_lrp8bxj7blqe.png" width="700"><br><br>  However, this is no more than an agreement, which, within its DS domain, the administrator can easily ignore and use all 6 bits at will. <br><br>  Further, I also note that according to the recommendations of the IETF, the higher the value recorded in the CS, the more demanding this traffic to the service. <br><br>  But this should not be perceived as an indisputable truth. <br><br>  If the first three bits define the traffic class, then the next three bits are used to indicate the priority of packet drop ( <b>Drop Precedence</b> or <b>Packet Loss Priority (PLP</b> ). <br><blockquote>  Eight classes - is it a lot or a little?  At first glance, it‚Äôs not enough - there are so many different kinds of traffic going on the network, and that‚Äôs the way I want to separate each protocol by class.  However, it turns out that eight is enough for all possible scenarios. <br>  For each class, you need to determine the PHB, which will process it somehow different from other classes. <br>  And with an increase in the divider, the dividend (resource) does not increase. <br>  I deliberately do not say what values ‚Äã‚Äãexactly which traffic class is described, since there are no standards here and they can formally be used at your discretion.  Below I will tell you which classes and their corresponding values ‚Äã‚Äãare recommended. <br></blockquote><div class="spoiler">  <b class="spoiler_title">ECN bits ...</b> <div class="spoiler_text">  The two-bit ECN field appeared only in <a href="https://tools.ietf.org/html/rfc3168">RFC 3168</a> ( <i>Explicit Congestion Notification</i> ).  The field was defined with the good purpose of informing the final hosts, explicitly, that someone is experiencing an overload on the way. <br>  For example, when packets are permanently delayed in the queues of the router and fill them, for example, by 85%, it changes the ECN value, telling the end host that it needs to slow down - something like Pause Frames on Ethernet. <br><br>  In this case, the sender must reduce the transmission rate and reduce the load on the affected node. <br><br>  In this case, theoretically, the support of this field by all transit nodes is not required.  That is, using ECN does not break the network that does not support it. <br><br>  The goal is good, but ECN didn‚Äôt find much use in life before.  Nowadays, mega-and hyperscales look at these two bits with <a href="https://tools.ietf.org/html/rfc8257">new interest</a> . <br><br>  ECN is one of the overload prevention mechanisms, which are described below. <br></div></div><br><hr><br><h4>  DSCP classification practice </h4><br>  Do not hurt a little practice. <br><br>  The scheme is the same. <br><br><img src="https://habrastorage.org/webt/zc/0o/zn/zc0ozndb8nmrqajljkf98pp79tk.png" width="900"><br><br>  To get started, just send an ICMP request: <br><br><pre><code class="hljs pgsql">Linkmeup_R1#ping ip <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> source <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">escape</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abort</span></span>. Sending <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>-byte ICMP Echos <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>, timeout <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> seconds: Packet sent <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a source address <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> !!!!! Success rate <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> percent (<span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">5</span></span>), round-trip min/avg/max = <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span> ms</code> </pre> <br>  <i>Linkmeup_R1.</i>  <i>E0 / 0.</i> <br><br><img src="https://habrastorage.org/webt/6g/zl/lp/6gzllpyfrbtsvqjd3sqn-rljc8g.png" width="600"><br>  <i><a href="https://yadi.sk/d/qunzFzOZ3YkE3W">pcapng</a></i> <br><br>  And now with the DSCP value set. <br><br><pre> <code class="hljs pgsql"> Linkmeup_R1#ping ip <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> source <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> tos <span class="hljs-number"><span class="hljs-number">184</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">escape</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abort</span></span>. Sending <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>-byte ICMP Echos <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>, timeout <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> seconds: Packet sent <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a source address <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">172.16</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> !!!!! Success rate <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> percent (<span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">5</span></span>), round-trip min/avg/max = <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span> ms</code> </pre> <br>  The value 184 is the decimal representation of the binary 10111000. Of these, the first 6 bits are 101110, that is, the decimal 46, and this is the class EF. <br><br><div class="spoiler">  <b class="spoiler_title">Table of standard values ‚Äã‚ÄãTOS for convenient popyushki ...</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/z5/fx/ij/z5fxijhtpv24gndpefezlypbdju.png" width="500"><br>  <i><a href="https://www.tucny.com/Home/dscp-tos">Read more</a></i> <br>  Below, in the chapter of the <a href="http://linkmeup.ru/uploads/sdsm-15-qos.html">IETF Recommendation,</a> I will explain where these numbers and names come from. <br></div></div><br>  <i>Linkmeup_R2.</i>  <i>E0 / 0</i> <br><br><img src="https://habrastorage.org/webt/y_/fn/gn/y_fngnyvicccbvsesftdw5lawrc.png" width="600"><br>  <i><a href="https://yadi.sk/d/dCu1DUFS3YkEA3">pcapng</a></i> <br><br>  A curious note: the addressee of the pop-ups in ICMP Echo reply sets the same class value as it was in the Echo Request.  This is logical - if the sender sent a packet with a certain level of importance, then, obviously, he wants to get it guaranteed back. <br><br>  <i>Linkmeup_R2.</i>  <i>E0 / 0</i> <br><br><img src="https://habrastorage.org/webt/wk/uu/ea/wkuueaujq2oqgrgd6cu960kqezu.png" width="600"><br>  <a href="https://docs.google.com/document/d/e/2PACX-1vRmqX4Zn20LhoAj-cmlZJq9XIB3YCE6VVgrh0Fa1E3cCW22R2S2xM4xIZu4PiTjBFvqulNLilmoaH7J/pub">DSCP classification configuration file.</a> <br><br><h3>  IPv6 Traffic Class </h3><br>  IPv6 is not much different than QoS from IPv4.  The eight-bit field, called the Traffic Class, is also split into two parts.  The first 6 bits - DSCP - play exactly the same role. <br><br><img src="https://habrastorage.org/webt/cu/xd/nf/cuxdnfexzlj8ls4zjd3qxwh8oa8.png" width="700"><br><br>  Yes, Flow Label appeared.  It is said that it could be used to further differentiate classes.  But this idea has nowhere found application in life. <br><br><h3>  MPLS Traffic Class </h3><br>  The DiffServ concept was focused on IP networks with IP header routing.  That's just bad luck - after 3 years <a href="https://tools.ietf.org/html/rfc3031">RFC 3031</a> ( <i>Multiprotocol Label Switching Architecture</i> ) was published.  And MPLS began to seize network providers. <br><br>  DiffServ was impossible not to spread to him. <br><br>  By luck, MPLS laid a three-bit EXP field just in case an experimental case.  And despite the fact that already long ago in <a href="https://tools.ietf.org/html/rfc5462">RFC 5462</a> ( <i>‚ÄúEXP‚Äù Field Renamed to ‚ÄúTraffic Class‚Äù Field</i> ) officially became the Traffic Class field, by inertia it is called IExPi. <br><br>  There is one problem with it - its length is three bits, which limits the number of possible values ‚Äã‚Äãto 9. It‚Äôs not just a little, it‚Äôs 3 binary orders less than the DSCP. <br><br><img src="https://habrastorage.org/webt/is/r0/tc/isr0tc7unhhkxs-bjevcbipjq6k.png" width="700"><br><br>  Considering that MPLS Traffic Class is often inherited from the DSCP IP packet, we have an archive with loss.  Or ... No, you do not want to know ... <a href="http://linkmeup.ru/blog/302.html">L-LSP</a> .  Uses a combination of Traffic Class + tag value. <br><blockquote>  In general, you must admit, the situation is strange - MPLS was developed as an IP help for quick decision making - the MPLS label is immediately detected in CAM by Full Match, instead of the traditional Longest Prefix Match.  That is, they knew about IP, and take part in switching, but did not foresee the normal priority field. <br></blockquote>  In fact, we have already seen above that only the first three bits of the DSCP are used to determine the traffic class, and the other three are Drop Precedence (or PLP - Packet Loss Priority). <br><br>  Therefore, in terms of service classes, we still have a 1: 1 correspondence, losing only information about Drop Precedence. <br><br>  In the case of MPLS, the classification, as in IP, can be based on the interface, MF, IP DSCP values ‚Äã‚Äãor MPLS Traffic Class. <br><br>  Marking indicates the entry of a value in the Traffic Class field of the MPLS header. <br><br>  A packet may contain several MPLS headers.  For the purposes of DiffServ, only the top one is used. <br><br>  There are three different scenarios of remarking when moving a packet from one pure IP segment to another via an MPLS domain: (this is just an excerpt from the <a href="http://linkmeup.ru/blog/302.html">article</a> ). <br><br><ol><li>  Uniform mode </li><li>  Pipe mode </li><li>  Short-Pipe Mode </li></ol><br><div class="spoiler">  <b class="spoiler_title">Modes of operation ...</b> <div class="spoiler_text"><br><h3>  Uniform mode </h3><br>  This is a flat end-to-end model. <br><br><img src="https://habrastorage.org/web/e50/932/53b/e5093253bcf94dc091f88500be2b6f9d.png" width="1000"><br><br>  In Ingress PE, we trust IP DSCP and copy ( <i>strictly speaking, display, but for simplicity we will say ‚Äúcopy‚Äù</i> ) its value in MPLS EXP (both tunnel and VPN headers).  The output from the Ingress PE packet is already processed in accordance with the value of the EXP field of the MPLS top header. <br><br>  Each transit P also processes packets based on the top EXP.  But at the same time, he can change it, if that is what the operator wants. <br><br>  The last but one node removes the transport label (PHP) and copies the EXP value to the VPN header.  No matter what was standing there - in Uniform mode, copying takes place. <br><br>  Egress PE removing the VPN label also copies the EXP value to IP DSCP, even if another one is written there. <br><br>  That is, if somewhere in the middle the value of the EXP tag in the tunnel header has changed, then this change will be inherited by the IP packet. <br><br><h3>  Pipe mode </h3><br><img src="https://habrastorage.org/web/5a1/f9a/a46/5a1f9aa46bb94ed88d62185535f5b41e.png" width="1000"><br><br>  If, on Ingress PE, we decided not to trust the DSCP value, then the EXP value that the operator wishes is inserted into the MPLS headers. <br><br>  But it is permissible to copy those that were in the DSCP.  For example, you can override the values ‚Äã‚Äã‚Äî copy everything up to EF, and CS6 and CS7 map to EF. <br><br>  Each transit P looks only at the EXP of the upper MPLS header. <br><br>  The last but one node removes the transport label (PHP) and <b>copies</b> the EXP value to the VPN header. <br><br>  Egress PE first processes the packet, based on the EXP field in the MPLS header, and only then removes it, while <b>not copying the</b> value in the DSCP. <br><br>  That is, regardless of what happened to the EXP field in the MPLS headers, IP DSCP remains unchanged. <br><br>  Such a scenario can be used when the operator has his own domain Diff-Serv, and he does not want client traffic to somehow influence him. <br><br><h3>  Short-Pipe Mode </h3><br><img src="https://habrastorage.org/web/f80/1c8/e2d/f801c8e2dac84ff1b376a5f68824d93e.png" width="1000"><br><br>  This mode can be viewed as a variation of Pipe-mode.  The only difference is that at the exit from the MPLS network, the packet is processed in accordance with its IP DSCP field, and not MPLS EXP. <br><br>  This means that the priority of a packet at the exit is determined by the client, and not by the operator. <br>  Ingress PE does not trust IP DSCP incoming packets <br>  Transit Ps look in the EXP header field. <br>  The penultimate P removes the transport label and copies the value to the VPN label. <br>  Egress PE first removes the MPLS label, then processes the packet in queues. <br><br>  Explanation from <a href="http://www.cisco.com/c/en/us/support/docs/multiprotocol-label-switching-mpls/mpls/47815-diffserv-tunnel.html">cisco</a> . <br></div></div><br><hr><br><h4>  MPLS Traffic Class classification practice </h4><br>  The scheme is the same: <br><br><img src="https://habrastorage.org/webt/zc/0o/zn/zc0ozndb8nmrqajljkf98pp79tk.png" width="900"><br>  <a href="https://docs.google.com/document/d/e/2PACX-1vTrtK-fnUH8KO8UjTlScnv4xT-5FAsp7mDITqtDjtFHDZXJYg4UPvQnhQ5B9JqydfNuY_1-Ho9_RjIH/pub">The configuration file is the same.</a> <br><br>  The network linkmeup has a transition from IP to MPLS on Linkmeup_R2. <br>  Let's see what happens with the marking when <b>pinging ip 172.16.2.2 source 172.16.1.1 tos 184</b> . <br><br>  <i>Linkmeup_R2.</i>  <i>E0 / 0.</i> <br><img src="https://habrastorage.org/webt/lj/at/14/ljat14wahqfc91ojgigmlrwayzo.png" width="600"><br>  <i><a href="https://yadi.sk/d/CN3OUB8y3Ykb3o">pcapng</a></i> <br><br>  So, we see that the initial EF tag in IP DSCP has been transformed into the value 5 of the EXP MPLS field (it‚Äôs the Traffic Class, remember this) of both the VPN header and the transport header. <br>  Here we are witnessing the Uniform mode of operation. <br><br><hr><br><h3>  Ethernet 802.1p </h3><br>  The lack of a priority field in 802.3 (Ethernet) is explained by the fact that Ethernet was originally planned solely as a solution for the LAN segment.  For modest money, you can get excess bandwidth, and the bottleneck will always be uplink - there is nothing to worry about prioritizing. <br><br>  However, it soon became clear that the financial attractiveness of Ethernet + IP brings this bundle to the level of the backbone and the WAN.  Yes, and cohabitation in one LAN-segment of torrents and telephony needs to be resolved. <br><br>  Fortunately, by this time, the 802.1q (VLAN) arrived, in which a 3-bit (again) field was allocated to priorities. <br><br>  In terms of DiffServ, this field allows you to define the same 8 traffic classes. <br><br><img src="https://habrastorage.org/webt/oh/_i/1l/oh_i1l1omqt1rk8agowdenx6x7o.png" width="600"><br><br><hr><br>  When receiving a packet, the network device of the DS-domain in most cases takes into consideration the header it uses for switching: <br><br><ul><li>  Ethernet Switch - 802.1p </li><li>  MPLS node - MPLS Traffic Class </li><li>  IP router - IP DSCP </li></ul><br>  Although this behavior can be changed: Interface-Based and Multi-Field classification.  And you can sometimes even explicitly say in the CoS field of which title to look. <br><br><hr><br><h2>  Interface-based </h2><br>  This is the easiest way to classify packages in the forehead.  Everything that has been poured into the specified interface is marked with a specific class. <br><br>  In some cases, this granularity is enough, so Interface-based is used in life. <br><br><h4>  Practice on Interface-based Classification </h4><br>  The scheme is the same: <br><br><img src="https://habrastorage.org/webt/zc/0o/zn/zc0ozndb8nmrqajljkf98pp79tk.png" width="900"><br><br>  Configuring QoS policies in the equipment of most vendors is divided into stages. <br><br><ol><li>  First, the classifier is determined: <br> <code>class-map match-all TRISOLARANS_INTERFACE_CM <br> match input-interface Ethernet0/2</code> <br>  All that comes on the interface Ethernet0 / 2. <br></li><li>  Next, a policy is created where the classifier and the necessary action are linked. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>-map TRISOLARANS_REMARK <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TRISOLARANS_INTERFACE_CM <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ip dscp cs7</code> </pre> <br>  If the packet satisfies the TRISOLARANS_INTERFACE_CM classifier, write the value CS7 in the DSCP field. <br><blockquote>  Here I am running ahead, using incomprehensible CS7, and then EF, AF.  Below you can read about these abbreviations and agreements.  In the meantime, it is enough to know that these are different classes with different levels of service. <br></blockquote></li><li>  And the final step is to apply the interface policy: <br><br><pre> <code class="hljs pgsql"> interface Ethernet0/<span class="hljs-number"><span class="hljs-number">2</span></span> service-<span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> TRISOLARANS_REMARK</code> </pre> <br><blockquote>  Here is a slightly redundant classifier, which will verify that the packet came to the interface e0 / 2, where we then apply the policy.  One could write match any: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span>-map match-<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> TRISOLARANS_INTERFACE_CM match <span class="hljs-keyword"><span class="hljs-keyword">any</span></span></code> </pre> <br>  However, the policy can actually be applied on the vlanif or on the output interface, so you can. <br></blockquote><br></li></ol><br>  We start the usual ping on 172.16.2.2 (Trisolaran2) with Trisolaran1: <br><br><img src="https://habrastorage.org/webt/sm/gh/5j/smgh5j3nxjmen6yspkxl8tu9so8.png" width="400"><br><br>  And in the dump between Linkmeup_R1 and Linkmeup_R2 we will see the following: <br><br><img src="https://habrastorage.org/webt/rh/qe/6z/rhqe6z4z98dxmkcrygfpb7zboee.png" width="600"><br>  <i><a href="https://yadi.sk/d/h2D-6_WR3ZHWyG">pcapng</a></i> <br><br>  <a href="https://docs.google.com/document/d/e/2PACX-1vSoH4VY5HIuVDeWCk2F7_3xTGMmXcyunODWK9_BHCcCfyoAipQZS4pej-tKNcH_6UOQYeQomDqQ6Jlx/pub">Interface-Based Classification Configuration File.</a> <br><br><h2>  Multi-field </h2><br>  The most common type of classification at the entrance to the DS-domain.  We do not trust the existing marking, but on the basis of the packet headers we assign a class. <br><br>  This is often a way to ‚Äúturn on‚Äù QoS altogether, in the case where senders do not affix a label. <br><br>  A rather flexible tool, but at the same time cumbersome - you need to create difficult rules for each class.  Therefore, inside the DS-domain is more relevant BA. <br><br><h4>  MF classification practice </h4><br>  The scheme is the same: <br><br><img src="https://habrastorage.org/webt/zc/0o/zn/zc0ozndb8nmrqajljkf98pp79tk.png" width="900"><br><br>  From the practical examples above, it is clear that network devices by default trust labeling of incoming packets. <br><br>  This is fine inside the DS domain, but unacceptable at the entry point. <br><br>  And now let's not blindly trust?  On <b>Linkmeup_R2</b> ICMP we will mark as EF (for example only), TCP as AF12, and everything else CS0. <br>  This will be the MF (Multi-Field) classification. <br><br><ol><li>  The procedure is the same, but now we‚Äôll match the ACLs that pull the right categories of traffic, so we‚Äôll first create them. <br><br>  On Linkmeup_R2: <br><br><pre> <code class="hljs pgsql"> ip <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-list extended TRISOLARANS_ICMP_ACL permit icmp <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> ip <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-list extended TRISOLARANS_TCP_ACL permit tcp <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> ip <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-list extended TRISOLARANS_OTHER_ACL permit ip <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span></code> </pre> <br></li><li>  Next, we define classifiers: <br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>-map match-<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> TRISOLARANS_TCP_CM match <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> TRISOLARANS_TCP_ACL <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>-map match-<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> TRISOLARANS_OTHER_CM match <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> TRISOLARANS_OTHER_ACL <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>-map match-<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> TRISOLARANS_ICMP_CM match <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> TRISOLARANS_ICMP_ACL</code> </pre> <br></li><li>  And now we define the rules of remarking in the policy: <br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>-map TRISOLARANS_ADMISSION_CONTROL <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TRISOLARANS_ICMP_CM <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ip dscp ef <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TRISOLARANS_TCP_CM <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ip dscp af11 <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TRISOLARANS_OTHER_CM <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ip dscp <span class="hljs-keyword"><span class="hljs-keyword">default</span></span></code> </pre> <br></li><li>  And we hang the policy on the interface.  At input, respectively, because the decision must be taken at the entrance to the network. <br><br><pre> <code class="hljs pgsql"> interface Ethernet0/<span class="hljs-number"><span class="hljs-number">1</span></span> service-<span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> TRISOLARANS_ADMISSION_CONTROL</code> </pre> <br></li></ol><br>  ICMP test from the final host Trisolaran1.  We deliberately do not specify a class - by default, 0. <br><br>  <b>I have already removed the policy with Linkmeup_R1, so the traffic comes with CS0 marking, not CS7.</b> <br><br><img src="https://habrastorage.org/webt/_f/si/90/_fsi9012_fo5a8z1x14fdtxqz0m.png" width="400"><br><br>  Here are two dumps next to, with Linkmeup_R1 and Linkmeup_R2: <br><br>  <i>Linkmeup_R1.</i>  <i>E0 / 0.</i> <br><img src="https://habrastorage.org/webt/cp/t5/ge/cpt5gersxbcrhjsba4lz8t-5z-i.png" width="600"><br>  <i><a href="https://yadi.sk/d/dT8QCu7n3YkjZ4">pcapng</a></i> <br><br>  <i>Linkmeup_R2.</i>  <i>E0 / 0.</i> <br><img src="https://habrastorage.org/webt/9x/0w/j7/9x0wj7gkztleiock6vnax33m-7c.png" width="600"><br>  <i><a href="https://yadi.sk/d/3OOzH2Ww3YkjZ9">pcapng</a></i> <br><br>  It can be seen that after the classifiers and remarking on Linkmeup_R2 on ICMP packets, not only the DSCP was changed to EF, but the MPLS Traffic Class became equal to 5. <br><br>  A similar test with telnet 172.16.2.2.  80 - so check TCP: <br><br><img src="https://habrastorage.org/webt/rd/f1/xo/rdf1xovczuma9nuziqbawyyuqji.png" width="400"><br><br>  <i>Linkmeup_R1.</i>  <i>E0 / 0.</i> <br><img src="https://habrastorage.org/webt/-i/nr/gj/-inrgjtler0zsvt2y3hq3cxvd8m.png" width="600"><br>  <i><a href="https://yadi.sk/d/M21gTk2f3Ykkaa">pcapng</a></i> <br><br>  <i>Linkmeup_R2.</i>  <i>E0 / 0.</i> <br><img src="https://habrastorage.org/webt/mk/z_/qz/mkz_qz44dywl9kr5uw3ohauu9qa.png" width="600"><br>  <i><a href="https://yadi.sk/d/GdyZtBI-3YkkZa">pcapng</a></i> <br><br>  CHITO - What And Required to Expect.  TCP is transmitted as AF11. <br><br>  The next test will check for UDP, which should go to CS0 according to our classifiers.  To do this, use iperf (bring it to Linux Tiny Core via Apps).  On the remote side <b>iperf3 -s</b> - we start the server, on the local <b>iperf3 -c -u -t1</b> - the client ( <b>-c</b> ), the UDP protocol ( <b>-u</b> ), test for 1 second ( <b>-t1</b> ). <br><br><img src="https://habrastorage.org/webt/zw/gu/sb/zwgusb4bqnq7prgq_yw5ue44pqo.png" width="400"><br><br>  <i>Linkmeup_R1.</i>  <i>E0 / 0.</i> <br><img src="https://habrastorage.org/webt/rm/sx/pq/rmsxpqgca2wmuhhcu5mcnvcth7y.png" width="600"><br>  <i><a href="https://yadi.sk/d/FG9eNhV93YkoD7">pcapng</a></i> <br><br>  <i>Linkmeup_R2.</i>  <i>E0 / 0</i> <br><img src="https://habrastorage.org/webt/yt/9q/gv/yt9qgv2qcqun9rpr8me4nuyghym.png" width="600"><br>  <i><a href="https://yadi.sk/d/t3hRvRMk3YkoDR">pcapng</a></i> <br><br>  From this point on, everything that comes into this interface will be classified according to the configured rules. <br><br><hr><br><h2>  Marking inside the device </h2><br>  Once again: MF, Interface-based or BA classification can occur at the entrance to the DS-domain. <br>  Between the DS-domain nodes, the packet in the header carries a sign about the class of service it needs and is classified by BA. <br><br>  Regardless of the method of classification after it, the package is assigned an internal class within the device, according to which it is processed.  The header is removed and the naked (no) packet travels to the exit. <br>  At the output, the inner class is converted to the CoS field of the new header. <br><br>  That is, Title 1 ‚áí Classification ‚áí Internal service class ‚áí Title 2. <br><br>  In some cases, you need to display the header field of one protocol in the header field of another, for example, the DSCP in the Traffic Class. <br><br>  This happens just through the intermediate internal marking. <br><br>  For example, DSCP Header ‚áí Classification ‚áí Internal Service Class ‚áí Traffic Class Header. <br><br>  Formally, inner classes can be called arbitrarily or simply numbered, and they only correspond to a specific queue. <br><br>  At the depth to which we are immersed in this article, it doesn‚Äôt matter what they are called, it‚Äôs important that a specific behavior model is put into correspondence with the specific values ‚Äã‚Äãof the QoS fields. <br><br>  If we are talking about specific implementations of QoS, then the number of service classes that a device can provide is no more than the number of available queues.  Often, there are eight of them (either under the influence of the IPP or under an unwritten agreement).  However, depending on the vendor, device, board, there may be more or less. <br><br>  That is, if there are 4 queues, then the service classes simply do not make sense to do more than four. <br><br>  We'll talk about this in more detail in the hardware chapter. <br><br><div class="spoiler">  <b class="spoiler_title">If you still really want a little specifics ...</b> <div class="spoiler_text"><blockquote>  The tables below may seem convenient for a first look at the relationship between the QoS fields and internal classes, but they are somewhat misleading, calling the classes names PHB.  Still, PHB is what behavior pattern is assigned to traffic of a certain class, whose name, roughly speaking, is arbitrary. <br><br>  Therefore, treat the tables below with skepticism (and therefore under the spoiler). </blockquote><br>  <i>On the example of Huawei</i> .  Here Service-Class is the innermost class of the package. <br><br>  That is, if the BA is classified at the input, then the DSCP values ‚Äã‚Äãwill be translated to the corresponding Service-Class and Color values. <br><br><img src="https://habrastorage.org/webt/h-/xh/sp/h-xhspe0wg3zymljrw4fdcd8v-u.png" width="500"><br><br>  Here it is worth paying attention to the fact that many DSCP values ‚Äã‚Äãare not used, and packets with such marking are actually processed as BE. <br><br>  Here is the reverse mapping table, which shows what DSCP values ‚Äã‚Äãwill be set for traffic when remarking at the output. <br><br><img src="https://habrastorage.org/webt/as/t4/49/ast449vrq3tmkbo_xhxoqmvayjm.png" width="500"><br><br>  Please note that only AF has color gradation.  BE, EF, CS6, CS7 - everything is just Green. <br><br>  This is a table for converting IPP, MPLS Traffic Class and Ethernet 802.1p fields into internal service classes. <br><br><img src="https://habrastorage.org/webt/d7/nz/up/d7nzupuudz6mpvapmunecfol43a.png" width="500"><br><br>  And back. <br><br><img src="https://habrastorage.org/webt/nc/qz/zr/ncqzzr58m-3acsu1gid9xkowfxy.png" width="500"><br><br>  Notice that any drop priority information is missing here. <br><br>  It should be repeated - this is only a specific example of the default matches from a <i>randomly</i> selected vendor.  For others it may be different.  On their network, administrators can configure completely different classes of services and PHB. <br><br></div></div><br>  In terms of PHB, there is absolutely no difference what is used for classification - DSCP, Traffic Class, 802.1p. <br><br>  Inside the device, they turn into traffic classes defined by the network administrator. <br>  That is, all these markings are a way to tell the neighbors what class of service they should assign to this package.  This is about how the BGP Community, which do not mean anything by themselves, until the policy of their interpretation is defined on the network. <br><br><hr><br><h2>  IETF recommendations (traffic categories, service classes and behaviors) </h2><br>  Standards do not standardize at all exactly which classes of service should exist, how to classify and label them, and which PHB to apply to them. <br><br>  It is at the mercy of vendors and network administrators. <br><br>  We have only 3 bits - we use as we want. <br><br>  It's good: <br><br><ul><li>  Each piece of hardware (vendor) independently selects which mechanisms to use for PHB - there is no signaling, there are no compatibility issues. </li><li>  The administrator of each network can flexibly distribute traffic to different classes, choose the classes themselves and the corresponding PHB. </li></ul><br>  This is bad: <br><br><ul><li>  At the boundaries of DS domains, conversion issues arise. </li><li>  In conditions of complete freedom of action - who is in the forest, who is a demon. </li></ul><br>  Therefore, the IETF in 2006 released a training manual on how to approach the differentiation of services: <a href="https://tools.ietf.org/html/rfc4594">RFC 4594</a> ( <i>Configuration Guidelines for DiffServ Service Classes</i> ). <br><br>  Further briefly the essence of this RFC. <br><br><h3>  Behavior Models (PHB) </h3><br>  <b>DF - Default Forwarding</b> <br>  <i>Standard shipment.</i> <br>  If the behavior class is not specifically assigned a behavior model, it will be processed according to Default Forwarding. <br><br>  This is the Best Effort - the device will do everything possible, but does not guarantee anything.  Dropping, reordering, unpredictable delays and floating jitter are possible, but this is not accurate. <br><br>  This model is suitable for undemanding applications, such as mail or file uploads. <br>  There is, by the way, PHB and even less certain - <a href="https://tools.ietf.org/html/draft-ietf-tsvwg-le-phb-00">A Lower Effort</a> . <br><br>  <b>AF - Assured Forwarding</b> <br>  <i>Guaranteed shipment.</i> <br>  This is an improved BE.  Here are some guarantees, such as strips.  Drops and floating delays are still possible, but to a much lesser extent. <br><br>  The model is suitable for multimedia: Streaming, video conferencing, online games. <br>  <a href="https://tools.ietf.org/html/rfc2597">RFC 2597</a> ( <i>Assured Forwarding PHB Group</i> ). <br><br>  <b>EF - Expedited Forwarding</b> <br>  <i>Emergency shipping.</i> <br>  All resources and priorities are thrown here.  This is a model for applications that need no loss, short delays, stable jitter, but they are not greedy for the band.  Like, for example, telephony or wire emulation service (CES - Circuit Emulation Service). <br><br>  Losses, disordering, and floating delays in EF are extremely unlikely. <br>  <a href="https://tools.ietf.org/html/rfc3246">RFC 3246</a> ( <i>An Expedited Forwarding PHB</i> ). <br><br>  <b>CS - Class Selector</b> <br>  These are behaviors designed to maintain backward compatibility with IP Precedence on networks that can do DS. <br><br>  In IPP, there are the following classes CS0, CS1, CS2, CS3, CS4, CS5, CS6, CS7. <br>  There is not always a separate PHB for all of them, usually two or three of them, and the rest are simply transmitted to the nearest DSCP class and receive the corresponding PHB. <br>  For example, a packet labeled CS 011000 may be classified as 011010. <br><br>  Of the CS, only CS6, CS7, which are recommended for NCP - Network Control Protocol and require a separate PHB, are preserved in the equipment. <br><br>  Like EF, PHB CS6,7 are designed for those classes that have very high requirements for delays and losses, but are to some extent tolerant of strip discrimination. <br>  The PHB challenge for CS6.7 is to provide a level of service that eliminates drops and delays even in the event of an extreme overload of the interface, chip, and queues. <br><hr><br><br>  It is important to understand that PHB is an abstract concept - and in fact they are realized through mechanisms available on real equipment. <br><br>  Thus, the same PHB defined in the DS domain may differ on Juniper and Huawei. <br><br>  Moreover, a single PHB is not a static set of actions, PHB AF, for example, can consist of several options that differ in the level of guarantees (band, permissible delays). <br><br><hr><br><h3>  Classes of service </h3><br>  The IETF took care of the administrators and defined the main categories of applications and their aggregating service classes. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will not be wordy here, just insert a couple of tablets from this Guideline RFC. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application categories: </font></font><br><br><img src="https://habrastorage.org/webt/an/hr/np/anhrnppkfmebfm7vaoarb1xv7s0.png" width="600"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requirements for network characteristics: </font></font><br><br><img src="https://habrastorage.org/webt/ih/5r/z2/ih5rz2jw4ifygst1mjgte9a_vc0.png" width="560"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, recommended class names and corresponding DSCP values: </font></font><br><br><img src="https://habrastorage.org/webt/jg/rp/4k/jgrp4kzhhhvz1-zygrsiexieeyy.png" width="560"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By combining the above classes in different ways (to fit the 8 available ones), you can get QoS solutions for different networks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most frequent is, perhaps, the following: An </font></font><br><br><img src="https://habrastorage.org/webt/su/ft/ed/suftedkuzswznewqbj3uslcncru.png" width="560"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">absolutely undemanding traffic is marked by a DF (or BE) class - it receives attention on the residual principle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHB AF serves classes AF1, AF2, AF3, AF4. They all need to provide a strip, to the detriment of delays and losses. Losses are controlled by the Drop Precedence bits, so they are called AFxy, where x is the class of service, and y is Drop Precedence.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EF needs some sort of minimum band guarantee, but more importantly, guarantee of delays, jitter and no loss. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CS6, CS7 require even less bandwidth, because it is a trick of service packets, in which bursts are still possible (BGP Update, for example), but losses and delays are unacceptable in it - what is the use of BFD with a 10 ms timer if Hello queues of 100 ms? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, 4 classes out of 8 available given under AF. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And despite the fact that they actually usually do this, I repeat that these are only recommendations, and nothing in your DS domain prevents you from assigning three classes of EF and only two classes - AF.</font></font><br><br><hr><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Short summary of the classification </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the entrance to the node, the packet is classified based on the interface, MF, or its labeling (BA). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Marking is the value of the DSCP fields in IPv4, the Traffic Class in IPv6 and in MPLS or 802.1p in 802.1q. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are 8 classes of service that aggregate various categories of traffic. Each class is assigned its own PHB that satisfies the requirements of the class. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to the IETF guidelines, the following classes of services are distinguished, these are CS1, CS0, AF11, AF12, AF13, AF21, CS2, AF22, AF23, CS3, AF31, AF32, AF33, CS4, AF41, AF42, AF43, CS5, EF, CS6, CS7 in order of increasing traffic importance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of these, you can choose a combination of 8 that can actually be encoded in the CoS fields. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most common combination is CS0, AF1, AF2, AF3, AF4, EF, CS6, CS7 with 3 color gradations for AF.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each class is assigned a PHB, of which there are 3 - Default Forwarding, Assured Forwarding, Expedited Forwarding in order of increasing severity. </font><font style="vertical-align: inherit;">A little apart is PHB Class Selector. </font><font style="vertical-align: inherit;">Each PHB can vary the parameters of the instruments, but more on that later.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In an unloaded network, QoS is not needed, they said. </font><font style="vertical-align: inherit;">Any QoS issues are resolved by link extensions, they said. </font><font style="vertical-align: inherit;">With Ethernet and DWDM, we are never threatened with overloading the lines, they said. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They are the ones who do not understand what QoS is. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But reality beats the VPN on RKN.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optics are not everywhere. </font><font style="vertical-align: inherit;">RRL - our reality. </font><font style="vertical-align: inherit;">Sometimes at the time of the accident (and not only) a narrow radio link wants to crawl through all the network traffic.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traffic bursts are our reality. </font><font style="vertical-align: inherit;">Short-term bursts of traffic easily clog the queue, forcing to discard very necessary packets.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telephony, video conferencing, online games - our reality. </font><font style="vertical-align: inherit;">If the queue is at least a little busy, delays begin to dance.</font></font></li></ol><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In my practice there were examples when telephony turned into Morse code on a network loaded by no more than 40%. </font><font style="vertical-align: inherit;">Just remarking it in EF solved the problem momentarily.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It's time to deal with tools that allow you to provide different services to different classes. </font></font><br><br><hr><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PHB Tools </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There are actually only three groups of QoS provisioning tools that actively handle packages: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Congestion Avoidance - what to do so that it is not bad. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Congestion Management - what to do when it is already bad. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rate Limiting - how not to put on the network more than expected, and not to release as much as they can not accept. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But all of them by and large would be useless if not for the queue. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Queues </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the amusement park you can not give someone priority, if you do not organize a separate queue for those who paid more. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same situation in the networks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If all traffic is in the same queue, you will not be able to pull important packets out of its middle to give them priority. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is why, after classification, packages are placed in the appropriate queue of this class. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then one queue (with voice data) will move quickly, but with a limited band, the other will be slower (streaming), but with a wide band, and some resources will fall on the residual principle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But within the limits of each separate turn the same rule operates - it is impossible to pull out a package from the middle - only from its headboard.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each queue has a certain limited length. On the one hand, this is dictated by hardware constraints, and on the other hand, it makes no sense to keep packets in the queue for too long. VoIP packet is not needed if it is delayed for 200ms. TCP will request a re-send, conditionally, after the expiration of the RTT (configured in sysctl). Therefore, dropping is not always bad. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Developers and designers of network equipment have to find a compromise between attempts to save the package as long as possible and, on the contrary, to prevent the waste of bandwidth, trying to deliver the package that no one else needs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In a normal situation, when the interface / chip is not overloaded, the buffer utilization is near zero. They absorb short-term bursts, but this does not cause them to be filled for a long time.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If more traffic arrives than the switching chip or output interface can handle, the queues begin to fill up. </font><font style="vertical-align: inherit;">And chronic utilization is higher than 20-30% - this is already a situation to which measures need to be taken.</font></font><br><br><hr><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Congestion Avoidance (Congestion Avoidance) </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the life of any router there comes a time when the queue is full. </font><font style="vertical-align: inherit;">Where to put the package, if you put it absolutely nowhere - everything is all, the buffer is over, absolutely, and it will not be, even if you search well, even if you pay extra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two ways here: discard either this package or those that have already been scored. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If those that are already in the queue, then consider that it is gone. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if this, then consider that he did not come. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These two approaches are called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tail Drop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Head Drop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tail Drop and Head Drop </font></font></h2><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tail Drop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the simplest queue management mechanism - discard all newly arrived packets that do not fit in the buffer. </font></font><br><br><img src="https://habrastorage.org/webt/gu/qu/lv/guqulvedyuzoyytzzbybxrzua9g.png" width="500"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Head Drop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> discards packets that have been in line for a very long time. It is better to throw them away than to try to save them, because they are most likely useless. But more current packages that arrived at the end of the queue will have more chances to arrive on time. Plus, Head Drop will allow you not to load the network with unnecessary packages. Naturally, the oldest packages are those in the head queue, hence the name of the approach.</font></font><br><br><img src="https://habrastorage.org/webt/6h/0d/rq/6h0drqorglxgq9mjocqjm_bpwby.png" width="500"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Head Drop has one more unobvious advantage: if the packet is dropped at the beginning of the queue, the recipient will soon find out about the overload on the network and inform the sender. In the case of Tail Drop, information about the dropped packet will reach, perhaps, hundreds of milliseconds later - while it comes from the tail of the queue to its head. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both mechanisms work with differentiation by queues. That is, in fact, it is not necessary for the entire buffer to overflow. If the 2nd stage is empty, and zero to the outset, then I will only discard packets from zero. </font></font><br><br><img src="https://habrastorage.org/webt/as/nl/l7/asnll7xgflrxk_mvdxgmglgf2fm.png" width="400"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tail Drop and Head Drop can work simultaneously.</font></font><br><br><img src="https://habrastorage.org/webt/bn/n1/wv/bnn1wvl9qene8f4xysetig6hemg.png" width="500"><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tail and Head Drop is a forehead congestion avoidance. I can even say - this is his absence. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do nothing until the queue is 100% full. And after that, all new arrivals (or long-delayed) packets begin to be discarded. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If to achieve the goal you do not need to do anything, then somewhere there is a nuance. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this nuance is TCP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us recall ( </font></font><a href="http://linkmeup.ru/blog/300.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deeper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://www.tcpipguide.com/free/index.htm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extremely deep</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) how TCP works - speech about modern implementations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a Sliding Window (Sliding Window or </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rwnd - Reciever's Advertised Window</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), which is controlled by the recipient, telling the sender how much you can send. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And there is an overload window ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWND - Congestion Window</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), which responds to network problems and is controlled by the sender. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The data transfer process begins with a slow start ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slow Start</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) with an exponential growth of CWND. With each confirmed segment, 1 MSS size is added to CWND, that is, it actually doubles in a time equal to RTT (data goes there, back ACK) (Reno / NewReno speech).</font></font><br><br>  For example, <br><br><img src="https://habrastorage.org/webt/5n/5a/nd/5n5andpbm8lvmyeaio0i565c_ek.png" width="200"><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exponential</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> growth continues to a value called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ssthreshold</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Slow Start Threshold), which is specified in the TCP configuration on the host. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linear</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> growth </font><font style="vertical-align: inherit;">begins </font><font style="vertical-align: inherit;">at 1 / CWND for each confirmed segment until either it stops at RWND or losses start (evidence of re-confirmation (Duplicated ACK) or no confirmation at all). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as a segment loss is detected, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP Backoff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> occurs </font><font style="vertical-align: inherit;">- TCP dramatically reduces the window, actually reducing the sending speed, - and the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast Recovery</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mechanism starts </font><font style="vertical-align: inherit;">:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lost segments are sent (fast retransmission), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the window shrinks twice </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the ssthreshold value also becomes half the window reached, </font></font></li><li><font style="vertical-align: inherit;"></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linear</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> growth </font><font style="vertical-align: inherit;">begins again </font><font style="vertical-align: inherit;">until the first loss</font></font></li><li>  Repeat. </li></ol><br><img src="https://habrastorage.org/webt/of/0p/ar/of0park6tnishwa25_v_dgzwaya.png" width="700"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loss can mean either a complete collapse of some network segment and then consider that it is gone, or an overload on the line (read buffer overflow and discard segment of this session). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is TCP's method of maximizing the utilization of available bandwidth and overloading. </font><font style="vertical-align: inherit;">And it is quite effective. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But what does Tail Drop lead to?</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose through the router is the path of thousands of TCP sessions. </font><font style="vertical-align: inherit;">At some point, session traffic reached 1.1 Gb / s, the output interface speed was 1 Gb / s.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traffic arrives faster than it is sent, buffers are filled </font></font><a href="https://dic.academic.ru/dic.nsf/efremova/149600/%25D0%2592%25D1%2581%25D0%25BA%25D0%25BB%25D0%25B5%25D0%25BD%25D1%258C"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">up</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tail Drop is activated until the dispatcher removes some packets from the queue. </font></font></li><li>           Fast Recovery (    Slow Start). </li><li>    ,  , Tail Drop . </li><li>   TCP-  ,          . </li><li>  . </li><li> Fast Recovery/Slow Start. </li><li>  Repeat. </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Learn more about changes in TCP mechanisms in </font></font><a href="https://tools.ietf.org/html/rfc2001"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC 2001</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP Slow Start, Congestion Avoidance, Fast Retransmit, and Fast Recovery Algorithms</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a typical illustration of a situation called global TCP global synchronization ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Global TCP Synchronization</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): </font></font><br><br><img src="https://habrastorage.org/webt/wr/co/oq/wrcooqd2fjrix9jbimh-8si97h4.png" width="500"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Global</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - because many sessions are established through this node. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronization</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because they suffer at the same time. And the situation will be repeated as long as there is an overload. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - because UDP, which does not have congestion control mechanisms, is not affected by it.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There would be nothing bad in this situation if it did not cause non-optimal use of the strip - the gaps between the teeth of the saw are money spent in vain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second problem is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP Starvation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - TCP depletion. While TCP slows down its speed to reduce the load (we will not be cunning - first of all, in order to transfer its data for sure), UDP sends all of its moral suffering over the datagram ‚Äî it sends as much as it can. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the amount of TCP traffic is decreasing, and UDP is growing (possibly), the next cycle is Loss - Fast Recovery happens on a lower threshold. UDP takes up the free space. Total TCP traffic drops.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to solve a problem, it is better to avoid it. </font><font style="vertical-align: inherit;">Let's try to reduce the load before it fills the queue, using Fast Recovery / Slow Start, which has just been against us.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RED - Random Early Detection </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what if we take the drops to smear over some part of the buffer? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relatively speaking, to start dropping random packets when the queue is 80% full, causing some TCP sessions to reduce the window and, accordingly, speed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if the queue is 90% full, we start randomly discarding 50% of the packets. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">90% - the probability increases up to Tail Drop (100% of new packages are discarded). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The mechanisms that implement such queue management are called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AQM - Adaptive (or Active) Queue Management</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is exactly how </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RED</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> works </font><font style="vertical-align: inherit;">. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Early Detection</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - we fix potential overload; </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Random</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - discard packets in random order.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes RED is decrypted (in my opinion semantically more correctly), like a Random Early Discard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphically, it looks like this: </font></font><br><br><img src="https://habrastorage.org/webt/1n/zs/5v/1nzs5vsexsokkaepdxe_mo-klsg.png" width="600"><br><br><img src="https://habrastorage.org/webt/lp/rl/m7/lprlm7iiurfwklhdnun20iqdoci.png" width="500"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before the buffer is filled, 80% of the packets are not discarded at all - the probability is 0%. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From 80 to 100 packets begin to be discarded, and the more, the higher the filling of the queue. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So the percentage grows from 0 to 30. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A side effect of RED is that aggressive TCP sessions will more likely slow down, simply because their packets are many and they are more likely to be dropped. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The inefficiency of using the strip RED decides that it dulls a much smaller portion of the sessions without causing such a serious drawdown between the teeth. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exactly for the same reason, UDP cannot occupy everything.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WRED - Weighted Random Early Detection </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But at the hearing of all, probably, still </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WRED</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The astute reader linkmeup has already suggested that this is the same RED, but weighted by queues. And he was not quite right. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RED operates within the same queue. It makes no sense to look back at EF if BE is overwhelmed. Accordingly, weighing by queues will not bring anything. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is where Drop Precedence works. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And within the same queue, packets with different priority drops will have different curves. The lower the priority, the more likely it is to clap. </font></font><br><br><img src="https://habrastorage.org/webt/ef/rg/_v/efrg_vx4xacb4uwjrkvcdutemho.png" width="600"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are three curves: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red - less priority traffic (in terms of dropping), yellow - more, green - maximum.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red traffic begins to be discarded when the buffer is full by 20%, from 20 to 40 it drops to 20%, then - Tail Drop. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yellow starts later - from 30 to 50, it is discarded up to 10%, then - Tail Drop. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Green is the least susceptible: from 50 to 100 it grows smoothly to 5%. Next - Tail Drop. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case of DSCP, this could be AF11, AF12 and AF13, respectively green, yellow and red. </font></font><br><br><img src="https://habrastorage.org/webt/jv/jm/9q/jvjm9qul8wyhrhncvx8iylnbl5s.png" width="600"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Very important here is that it works with TCP and it is absolutely not applicable to UDP. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Either the application using UDP ignores the loss, as in the case of telephony or streaming video, and this adversely affects what the user sees.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Either the application itself controls the delivery and asks to resend the same package. However, it is not at all obliged to ask the source to reduce the transmission rate. And instead of reducing the load, an increase due to retransmit is obtained. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is why only Tail Drop is used for EF. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For CS6, CS7 also uses Tail Drop, since it does not assume high speeds there and WRED will not solve anything. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For AF, apply WRED. AFxy, where x is the service class, that is, the queue to which it falls, and y is the drop priority ‚Äî that color. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For BE, the decision is made based on the traffic prevailing in this queue.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Within the same router, special internal packet marking is used, different from the one that the headers carry. </font><font style="vertical-align: inherit;">Therefore, MPLS and 802.1q, where it is not possible to code Drop Precedence, can be processed in queues with different drop priorities. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, the MPLS packet arrived at the node, it does not carry the Drop Precedence marking, however, by the results of the polysing it turned yellow and could be discarded before being placed in a queue (which may be determined by the Traffic Class field). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be remembered that the whole rainbow exists only inside the node. </font><font style="vertical-align: inherit;">There is no color concept in the line between neighbors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although it is possible to encode color in the Drop Precedence part of the DSCP.</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drops can also appear in an unloaded network, where seemingly no overflow of queues should exist. </font></font> How? <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reason for this may be short-term bursts - bursts - traffic. </font><font style="vertical-align: inherit;">The simplest example - 5 applications simultaneously decided to transfer traffic to a single end host. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The example is more complicated - the sender is connected via the 10 Gb / s interface, and the recipient is 1 Gb / s. </font><font style="vertical-align: inherit;">The medium itself allows you to craft packages faster on the sender. </font><font style="vertical-align: inherit;">The recipient's Ethernet Flow Control asks the nearest node to slow down, and packets begin to accumulate in buffers.</font></font><br></blockquote><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well, what to do when it became bad after all? </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Congestion Management </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When everything is bad, priority should be given to more important traffic. The importance of each package is determined at the classification stage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But what is bad? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optionally, all buffers must be clogged for applications to start experiencing problems. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simplest example is voice packs that crowd in large batches of large application packs that download a file. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will increase latency, ruin jitter, and possibly cause drop. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, we have problems with providing quality services in the absence of actual overloads. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This problem is designed to solve the mechanism of congestion management (Congestion Management). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The traffic of different applications is divided into queues, as we have already seen above.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But as a result, everything should merge into one interface again. </font><font style="vertical-align: inherit;">Serialization still happens sequentially. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How do different queues manage to provide different levels of services? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Differently withdraw packets from different queues. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Engaged in this dispatcher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will look at most of the existing dispatchers today, starting with the simplest:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FIFO - only one queue, all in BE, C - injustice. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PQ - oligarchs road, slaves give way. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FQ - all are equal. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DWRR - all are equal, but some are smoother. </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FIFO - First In, First Out </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simplest case, essentially the absence of QoS, is that all traffic is treated the same way - in one queue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Packages leave the queue exactly in the order in which they got there, hence the name: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first entered - first and out</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIFO is neither a dispatcher in the full sense of the word, nor is it a DiffServ mechanism at all, since it doesn‚Äôt actually share classes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the queue starts to fill up, delays and jitter begin to grow, you cannot control them, because you cannot pull an important packet out of the middle of the queue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aggressive TCP sessions with a packet size of 1500 bytes can occupy the entire queue, causing small voice packets to suffer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In FIFO, all classes are merged into CS0.</font></font><br><br><img src="https://habrastorage.org/webt/am/-w/0k/am-w0kosnvx3ucg3qpdbnou1blk.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, despite all these shortcomings, this is how the Internet works now. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most FIFO vendors still have a default dispatcher with one queue for all transit traffic and one more for locally generated service packets. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is simple, it is extremely cheap. If the channels are wide and the traffic is low, everything is fine. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The quintessence of the idea that QoS is for the poor expands the band, and customers will be satisfied, and your salary will grow multiply. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the only time when network equipment worked. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But very soon the world is faced with the fact that it just will not work.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the trend towards convergent networks, it became clear that different types of traffic (service, voice, multimedia, Internet surfing, file sharing) are fundamentally different network requirements. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIFO was not enough, so we created several queues and began to produce traffic control schemes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, a FIFO never leaves our lives: within each of the queues, packets are always processed according to the FIFO principle.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PQ - Priority Queuing </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second most complex mechanism and the attempt to divide the service into classes is a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">priority queue</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traffic is now decomposed into several queues according to its class ‚Äî priority (for example, although not necessarily the same BE, AF1-4, EF, CS6-7). The dispatcher goes through one queue after another. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, it skips all packets from the highest priority queue, then from less, then from less. And so in a circle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The dispatcher does not begin to withdraw low priority packets until the high priority queue is empty. </font></font><br><br><img src="https://habrastorage.org/webt/4g/l0/sl/4gl0slzp0q6kybjw14xpvvs5xt0.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If at the moment of processing of low-priority packets a packet arrives at a higher priority queue, the dispatcher switches to it and only after emptying it returns to the others. </font></font><br><br><img src="https://habrastorage.org/webt/xm/qk/v1/xmqkv1cbt_uidd4yj1nntt2jehq.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PQ works almost as much in the forehead as a FIFO.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is great for such types of traffic as protocol packets and voice, where delays are critical, and the total volume is not very large. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, you see, it is not necessary to hold BFD Hello due to the fact that several large video chunks came from YouTube? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But here lies the lack of PQ - if the priority queue is loaded with traffic, the dispatcher will never switch to others at all. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if some Doctor Evil, in search of methods to conquer the world, decides to mark all of his villainous traffic with the highest black mark, all the others will humbly wait, and then be discarded. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no need to talk about a guaranteed lane for each queue either.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">High-priority queues can be cut to the speed of the traffic processed in them. </font><font style="vertical-align: inherit;">Then others will not starve. </font><font style="vertical-align: inherit;">However, control is not easy.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following mechanisms go through all the queues in turn, taking a certain amount of data from them, thereby providing more honest conditions. </font><font style="vertical-align: inherit;">But they do it in different ways.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fq-fair queuing </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next contender for the role of an ideal dispatcher is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fair queuing mechanisms</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FQ - Fair Queuing </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Its history began in 1985, when John Nagle proposed to create a queue for each data stream. In spirit, this is close to the IntServ approach and this is easily explained by the fact that the ideas of the service classes, like DiffServ, did not yet exist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FQ retrieved the same amount of data from each queue in order. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Honesty is that the dispatcher operates with the number of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not packets, but the number of bits</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that can be transmitted from each queue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So an aggressive TCP stream cannot flood an interface, and everyone gets an equal opportunity. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In theory. FQ was never implemented in practice as a queue dispatching mechanism in network equipment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are three drawbacks:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first - the obvious - it is very expensive - to make a queue for each stream, count the weight of each packet and always worry about the bits and the size of the packet. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second - less obvious - all flows get equal opportunities in terms of bandwidth. And if I want unequal? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The third - unobvious - honesty is FQ absolute: everyone has equal delays too, but there are streams for which the delay is more important than the band. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, among the 256 streams there are voice, it means that each of them will be dealt with only once from the 256. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what to do with them is not clear. </font></font><br><br><img src="https://habrastorage.org/webt/o_/cg/au/o_cgau4ggmorq1cj28jn3hf26iq.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can see that due to the large packet size in the 3rd queue, in the first two cycles, one of the first two packets was processed.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The description of the mechanisms of bit-by-bit Round Robin and GPS is already outside of this article, and I refer the reader to </font></font><a href="https://intronetworks.cs.luc.edu/current/html/queuing.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an independent study</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WFQ - Weighted Fair Queuing </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second and partly the third flaws of the FQ attempted to close the WFQ, promulgated in 1989. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each queue was given weight and, accordingly, the right for one cycle to give traffic a multiple of weight. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The weight was calculated on the basis of two parameters: the IP Precedence and then the packet length, which is relevant then. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the context of WFQ, the more weight, the worse. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, the higher the IP Precedence, the lower the packet weight. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The smaller the package size, the less and its weight. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, high-priority packets of a small size receive the most resources, while low-priority giants wait.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the illustration below, the packages received such weights that first one package from the first stage is skipped, then two from the second, again from the first, and only then the third is processed. So, for example, it could happen if the size of the packets in the second queue is relatively small. </font></font><br><br><img src="https://habrastorage.org/webt/dd/z9/v7/ddz9v7nahrtmewfrul4mbflc5b0.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About the harsh machinery of WFQ, with its packet finish time, virtual time and the Wig Theorem, you can read in a </font></font><a href="http://www.mathcs.emory.edu/~cheung/Courses/558/Syllabus/11-Fairness/WFQ.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curious color document</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, this did not solve the first and third problems. The flow based approach was just as inconvenient, and streams requiring short delays and stable jitters did not receive them.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This, however, did not prevent WFQ from finding use in some (mostly old) Cisco devices. </font><font style="vertical-align: inherit;">There were up to 256 queues in which threads were placed on a hash basis from their headers. </font><font style="vertical-align: inherit;">A sort of compromise between the flow-based paradigm and limited resources.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CBWFQ - Class-Based WFQ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calling on the problem of complexity made CBWFQ with the arrival of DiffServ. Behavior Aggregate classified all categories of traffic into 8 classes and, accordingly, queues. This gave it a name and greatly simplified queuing service. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weight in CBWFQ has acquired a different meaning. Weight was assigned to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (not streams) manually in the configuration as desired by the administrator, because the DSCP field was already used for classification. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, the DSCP determined in which queue to place, and the configured weight - how many bands are available for this queue.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most importantly, it indirectly made life and low-latency flows, which were now aggregated into one (two, three, ...) queues, and received their finest hour much more often. </font><font style="vertical-align: inherit;">Life has become better, but still not good - there are no guarantees, and in general, in the WFQ, everyone is still equal in terms of delays. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the need to constantly monitor the size of the packets, their fragmentation and defragmentation, has not gone away.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CBWFQ + LLQ - Low-Latency Queue </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The final approach, the culmination of the bit-by-bit approach, is the integration of CBWFQ with PQ. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the queues becomes the so-called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (a queue with low latency), and while all other queues are being processed by the CBWFQ controller, the PQ controller is running between the LLQ and the others. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, while there are packets in the LLQ, the rest of the queues are waiting, increasing their delays. </font><font style="vertical-align: inherit;">As soon as the packets in the LLQ ran out, they went to process the rest. </font><font style="vertical-align: inherit;">There were packages in LLQ - they forgot about the rest, returned to it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inside LLQ, FIFO also works, so you shouldn‚Äôt shove anything there, no matter how you get, increasing buffer utilization and at the same time delays. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And yet, so that non-priority lines do not go hungry, the LLQ should be limited to the band. </font></font><br><br><img src="https://habrastorage.org/webt/c6/4m/vt/c64mvts-kr2ij0o_zf2kfxy2cbu.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here and the sheep are fed and the wolves are safe.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RR - Round-Robin </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hand in hand with FQ went and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One was honest, but not simple. </font><font style="vertical-align: inherit;">The other is quite the opposite. </font></font><br><br><img src="https://habrastorage.org/webt/8p/nh/de/8pnhdeko9l5nkiss6mbtxbg9jvk.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RR went through the queues, extracting an equal number of packets from them. </font><font style="vertical-align: inherit;">The approach is more primitive than FQ, and therefore unfair with respect to various threads. </font><font style="vertical-align: inherit;">Aggressive sources could easily flood a strip of 1500 byte packets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, it was very simple to implement - you do not need to know the size of the packet in the queue, fragment it and then collect it back. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, his injustice in the distribution of the band has blocked his path to the world - in the world of networks, a pure Round-Robin has not been implemented.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WRR - Weighted Round Robin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same fate and the WRR, which gave weight to the queues based on IP Precedence. </font><font style="vertical-align: inherit;">In WRR, not an equal number of packets was taken out, but a multiple of the queue weight. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It would be possible to give more weight to queues with smaller packets, but this was not dynamically possible to do.</font></font><br><br><img src="https://habrastorage.org/webt/lx/4b/an/lx4bancel1tl9stwbeay0s6n1ma.png" width="800"><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DWRR - Deficit Weighted Round Robin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And suddenly, an extremely curious approach was proposed in 1995 by M. Shreedhar and G. Varghese. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each queue has a separate </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">credit line</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in bits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When passing from the queue, as many packages are issued as long as there is enough credit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The size of the package that is in the queue head is deducted from the loan amount. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the difference is greater than zero, this packet is removed and the next one is checked. So until the difference is less than zero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even if the first package does not have enough credit, well, alas, seljava, it remains in the queue. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before the next pass, the credit of each queue is increased by a certain amount, called a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quantum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For different queues, the quantum is different - the larger the band to give, the larger the quantum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, all queues receive a guaranteed band, regardless of the size of the packets in it. </font></font><br><br><img src="https://habrastorage.org/webt/vr/hv/vk/vrhvvk-1opimw_vofynmrkosbv8.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would not understand from the explanation above how it works.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's draw the steps ...</font></font></b> <div class="spoiler_text">   : <br><br><ul><li> DRR ( W), </li><li> 4 , </li><li>  0-    500 , </li><li>  1- ‚Äî  1000, </li><li>  2-  1500, </li><li>   3-     4000, </li><li>  ‚Äî 1600 . </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/64d/911/64e/64d91164edc5867e9009f54de10a50da.png"><br><br><h5>  1 </h5><br> <b> 1.  0</b> <br>   ,     1600  () <br>    0- .  : <br>      ‚Äî  (1600 ‚Äî 500 = 1100). <br>  ‚Äî  ‚Äî  (1100 ‚Äî 500 = 600). <br>  ‚Äî  ‚Äî  (600 ‚Äî 500 = 100). <br>  ‚Äî    (100 ‚Äî 500 = -400).    . <br>   ‚Äî 100 . <br><br><img src="https://habrastorage.org/webt/9y/4x/al/9y4xalhqrwwayufvjfcxlfevl20.png"><br><br> <b> 1.  1</b> <br>    ‚Äî  (1600 ‚Äî 1000 = 600). <br>    (600 ‚Äî 1000 = -400).    . <br>   ‚Äî 600 . <br><br><img src="https://habrastorage.org/webt/yw/mr/qh/ywmrqhm_deusdb04dez-3gjermc.png"><br><br> <b> 1.  2</b> <br>    ‚Äî  (1600 ‚Äî 1500 = 100). <br>    (100 ‚Äî 1000 = -900).    . <br>   ‚Äî 100 . <br><br><img src="https://habrastorage.org/webt/aj/el/k6/ajelk6xd9tpkl70r5hgt6q9q2u0.png"><br><br> <b> 1.  3</b> <br>     . (1600 ‚Äî 4000 = -2400). <br>    . <br>   ‚Äî   1600 . <br><br><img src="https://habrastorage.org/webt/jw/fo/3e/jwfo3eobllx5--quzb9qqt3zt0c.png"><br><br> ,       : <br><br><ul><li>  0 ‚Äî 1500 </li><li>  1 ‚Äî 1000 </li><li>  2 ‚Äî 1500 </li><li>  3 ‚Äî 0 </li></ul><br>  : <br><br><ul><li>  0 ‚Äî 100 </li><li>  1 ‚Äî 600 </li><li>  2 ‚Äî 100 </li><li>  3 ‚Äî 1600 </li></ul><br><h5>  2 </h5><br>          ‚Äî   1600 . <br><br> <b> 2.  0</b> <br>    1700 (100 + 1600). <br>       ‚Äî   (1700 ‚Äî 3*500 = 200). <br>     . <br>   ‚Äî 200 . <br><br><img src="https://habrastorage.org/webt/4z/di/2s/4zdi2se_gcciq1rbfkqqzzrumsa.png"><br><br> <b> 2.  1</b> <br>    2200 (600 + 1600). <br>       ‚Äî   (2200 ‚Äî 2*1000 = 200). <br>    . <br>   ‚Äî 200 . <br><img src="https://habrastorage.org/webt/9e/1z/sl/9e1zsl63ko7jxqjjuv4snupl6kw.png"><br><br> <b> 2.  2</b> <br>    1700 (100 + 1600). <br>      ‚Äî   (2200 ‚Äî 1500 = 200). <br>   ‚Äî  . <br>   ‚Äî 200 . <br><br><img src="https://habrastorage.org/webt/xf/v5/ni/xfv5nifo1wqvxfrhjqlfoygdk1w.png"><br><br> <b> 2.  3</b> <br>    3200 (1600 + 1600). <br>       (3200 ‚Äî 4000 = -800) <br>   ‚Äî 3200 . <br><img src="https://habrastorage.org/webt/wn/wj/pe/wnwjpenhub6ir2d8vi69oxan8-s.png"><br><br> ,       : <br><br><ul><li>  0 ‚Äî 3000 </li><li>  1 ‚Äî 3000 </li><li>  2 ‚Äî 3000 </li><li>  3 ‚Äî 0 </li></ul><br>  : <br><br><ul><li>  0 ‚Äî 200 </li><li>  1 ‚Äî 200 </li><li>  2 ‚Äî 200 </li><li>  3 ‚Äî 3200 </li></ul><br><h5>  3 </h5><br>          ‚Äî 1600 . <br><br> <b> 3.  0</b> <br>    1800 (200 + 1600). <br>        ‚Äî   (1800 ‚Äî 3*500 = 300). <br>     . <br>   ‚Äî 300 . <br><br><img src="https://habrastorage.org/webt/lk/sk/tq/lksktqj1g_7q6m2p8jwq0olnfuw.png"><br><br> <b> 3.  1</b> <br>    1800 (200 + 1600). <br>    ‚Äî  (1800 ‚Äî 1000 = 800). <br>   ‚Äî 800 . <br><br><img src="https://habrastorage.org/webt/fg/bd/jd/fgbdjdmydatamvpzxome7reb5pc.png"><br><br> <b> 3.  2</b> <br>    1800 (200 + 1600). <br>    ‚Äî  (1800 ‚Äî 1500 = 300). <br>   ‚Äî 300 . <br><br><img src="https://habrastorage.org/webt/s1/a7/iv/s1a7iv6mpfy1kesgzuazx9hsgkk.png"><br><br> <b> 3.  3</b> <br>    3-  ! <br>    4800 (3200 + 1600). <br>    ‚Äî  (4800 ‚Äî 4000 = 800). <br>   ‚Äî 800 . <br><br><img src="https://habrastorage.org/webt/fm/fh/tn/fmfhtnvh1utrr0yovddsambv_fe.png"><br><br> ,       : <br><br><ul><li>  0 ‚Äî 4500 </li><li>  1 ‚Äî 4000 </li><li>  2 ‚Äî 4500 </li><li>  3 ‚Äî 4000 </li></ul><br>  : <br><br><ul><li>  0 ‚Äî 300 </li><li>  1 ‚Äî 800 </li><li>  2 ‚Äî 300 </li><li>  3 ‚Äî 800 </li></ul><br><img src="https://habrastorage.org/webt/q5/q9/pj/q5q9pjzqa1be-uluk_eucxwga9w.png"><br><br>     DRR.          . <br><br>    ,  . <br><br><img src="https://habrastorage.org/webt/5l/6o/nd/5l6onduvx4djvafmxj7bhsoxwwm.gif"><br><br>  DWRR  DRR   ,        ,   ,     . <br><br><hr><br>     DRR,        ‚Äî    ,   . <br><br>     :  ,     .           . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the DWRR, the question still remains with the guarantee of delays and jitter - its weight does not solve it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theoretically, here you can do as with CB-WFQ, adding LLQ. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, this is only one of the possible scenarios of the popularity of today.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PB-DWRR - Priority-Based DWRR </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually, PB-DWRR - Priority Based Deficit Weighted Round Robin is becoming almost mainstream today. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the same old evil DWRR, to which one more queue has been added - a priority queue, in which packets are processed with a higher priority. </font><font style="vertical-align: inherit;">This does not mean that it is given a larger band, but the fact that packages will be taken from there more often. </font></font><br><br><img src="https://habrastorage.org/webt/wg/6g/ui/wg6guiijtoscyckwdwr49gkp0fq.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are several approaches to implementing PB-DWRR. </font><font style="vertical-align: inherit;">In some of them, as in PQ, any packet arriving at the priority queue is immediately withdrawn. </font><font style="vertical-align: inherit;">In others, it is accessed every time the controller goes between queues. </font><font style="vertical-align: inherit;">Thirdly, a loan and a quantum are introduced for it, so that the priority queue could not squeeze the entire strip. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, we will not analyze them.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A short summary of the dispatch mechanisms </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For decades, mankind has tried to solve the most complicated problem of providing the necessary level of service and fair distribution of the strip. The main tool was queues, the only question was how to pick up packets from the queues, trying to stuff them into one interface. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting with the FIFO, it invented the PQ - the voice was able to coexist with surfing, but there was no talk of band guarantee. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There were several monstrous FQ, WFQ, which worked, if not per-flow, then almost like that. CB-WFQ came to a class society, but did not make it any easier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an alternative to him, RR developed. He turned into a WRR, and then DWRR. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in the depth of each dispatcher lives FIFO.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, as you can see, there is not some kind of universal dispatcher, which handled all classes as they require. </font><font style="vertical-align: inherit;">This is always a combination of controllers, one of which solves the problem of providing delays, jitter and no loss, and the other band allocation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBWFQ + LLQ or PB-WDRR or WDRR + PQ. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On real equipment, you can specify which queues to process by which dispatcher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBWFQ, WDRR and their derivatives are today's favorites. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PQ, FQ, WFQ, RR, WRR - we do not grieve or remember (unless, of course, we are preparing for the CCIE Clipper).</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So, dispatchers are able to guarantee speed, but how to limit it from above? </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Speed ‚Äã‚ÄãLimit </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The need to limit the speed of traffic at first glance is obvious - do not let the client out of the limits of his band according to the contract. </font></font><br><br>  Yes.  But not only.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose there is a 620 Mb / s RRL span connected via a 1Gb / s port. If the whole gigabit is shot at him, then somewhere on the RRL, which, quite likely, has no idea about queues and QoS, monstrous drops of a random nature will start, not tied to the real priorities of traffic. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, if you enable shaping on the router to 600 Mb / s, then EF, CS6, CS7 will not be discarded at all, and in the BE, AFx, the band and the drops will be distributed according to their weights. Up to RRL will reach 600 MB / s and we will get a predictable picture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another example is the admission control. For example, two operators have agreed to trust all labeling of each other, except CS7 - if something has come to CS7 - discard. For CS6 and EF - to give a separate queue with a guarantee of delay and no loss.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But, what if the ingenious partner began to pour torrents into these lines? </font><font style="vertical-align: inherit;">Goodbye telephony. </font><font style="vertical-align: inherit;">And the protocols will most likely begin to fall apart. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is logical in this case to agree with the partner about the band. </font><font style="vertical-align: inherit;">All that fits into the contract - skip. </font><font style="vertical-align: inherit;">What does not fit - discarded or transferred to another queue - BE, for example. </font><font style="vertical-align: inherit;">Thus we protect our network and our services. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two fundamentally different approaches to speed limiting: polishing and shaping. </font><font style="vertical-align: inherit;">They solve one problem, but in different ways. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the difference on the example of such a traffic profile:</font></font><br><br><img src="https://habrastorage.org/webt/5b/sj/st/5bsjstoglxkg7dspcxjrphdjsye.png" width="500"><br><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Traffic policing </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polising limits the speed by dropping excess traffic. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anything that exceeds the set value, policer cuts and throws out. </font></font><br><br><img src="https://habrastorage.org/webt/a3/dl/xa/a3dlxapkcptfnfejftde0qxycjc.png" width="500"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is cut is forgotten. The picture shows that the red packet is not in traffic after the polisher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this is how the selected profile will look like after the polisher: </font></font><br><br><img src="https://habrastorage.org/webt/jb/rw/52/jbrw52md7mynstgrt9-o1a1mo1s.png" width="500"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because of the severity of the measures taken, this is called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hard Policing</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, there are other possible actions. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polyser usually works in conjunction with a traffic meter. The meter paints packages, as you remember, in green, yellow or red. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, on the basis of this color already, the polisher may not discard the package, but place it in another class. These are soft measures - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soft Policing</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can be applied to both incoming traffic and outgoing traffic. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A distinctive feature of a polisher is its ability to absorb traffic spikes and determine the peak allowable speed due to the Token Bucket mechanism. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, in fact, everything that is above a given value is not cut off - it is allowed to go a little beyond it - short-term bursts or small excesses of the selected band are skipped. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The name ‚ÄúPolicing‚Äù is dictated by the rather strict attitude of the tool to excess traffic ‚Äî dropping or de-lowering to a lower class.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Traffic shaping </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shaping limits speed by buffering excess traffic. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All incoming traffic passes through the buffer. A shaper removes packets from this buffer at a constant rate. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the speed of packet arrival to the buffer is below the output, they do not linger in the buffer - they fly through. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if the rate of receipt is higher than the output, they begin to accumulate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The output speed is always the same. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, bursts of traffic are buffered and will be sent when it comes to their turn. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, along with scheduling in queues, shaping is the second tool </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contributing to the aggregate latency</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><img src="https://habrastorage.org/webt/in/gc/vh/ingcvhgya0fzfiw2sxbeiix7hfw.png" width="500"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The illustration clearly shows how a packet arriving at the time t2 buffer appears at the output at time t3. </font><font style="vertical-align: inherit;">t3-t2 is the delay introduced by the shaper. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shaper is usually applied to outgoing traffic. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the profile after the shaper. </font></font><br><br><img src="https://habrastorage.org/webt/iv/b7/sl/ivb7slyamvreja97npdjyr3ctwk.png" width="500"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The name ‚ÄúShaping‚Äù indicates that the tool gives shape to the traffic profile, smoothing it out. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main advantage of this approach is the optimal use of the available band - instead of dropping excessive traffic, we postpone it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main drawback - an unpredictable delay - when the buffer is full, the packets will languish in it for a long time. </font><font style="vertical-align: inherit;">Therefore, shaping is not suitable for all types of traffic. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shaping uses the Leaky Bucket mechanism.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shading vs polising </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The work of a polisher is similar to a knife, which, moving along the surface of the oil, cuts off with the sharp side of the tubercle. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The work of the shaper is similar to a roller, which smoothes the tubercles, distributing them evenly over the surface. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shaper tries not to drop packets while they are being buffered at the cost of increasing latency. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polyser does not introduce delays, but more readily discards packets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Applications that are not sensitive to delays, but for which losses are undesirable, should be limited to a shaper. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For those for whom a late packet is like a lost one, it is better to drop it immediately - then polysing.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shaper does not affect packet headers and their fate outside the node, while after polishing, the device can remake the class in the header. </font><font style="vertical-align: inherit;">For example, the packet had an AF11 class at the entrance, the metering painted it yellow inside the device, it remarked its class at AF12 at the exit ‚Äî on the next node it will have a higher drop probability.</font></font><br><br><img src="https://habrastorage.org/webt/za/y6/kh/zay6khb7cgviroz-zbumfppdtz8.png" width="600"><br><br><hr><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Practice of polising and shaping </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The scheme is the same: </font></font><br><br><img src="https://habrastorage.org/webt/zc/0o/zn/zc0ozndb8nmrqajljkf98pp79tk.png" width="900"><br><br> <a href="https://docs.google.com/document/d/e/2PACX-1vTrtK-fnUH8KO8UjTlScnv4xT-5FAsp7mDITqtDjtFHDZXJYg4UPvQnhQ5B9JqydfNuY_1-Ho9_RjIH/pub"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration file. </font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">see such a picture without restrictions: </font></font><br><br><img src="https://habrastorage.org/webt/mg/nz/mv/mgnzmvc_36gtmgf5t3vi0wob1uk.png" width="900"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will proceed as follows:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the input interface Linkmeup_R2 (e0 / 1) we configure polishing - this will be the input control. </font><font style="vertical-align: inherit;">Under the contract, we give 10 MB / s.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On the output interface Linkmeup_R4 (e0 / 2) we configure the shaping to 20 Mb / s. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start with the shaper on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linkmeup_R4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Match all:</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>-map match-<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> TRISOLARANS_ALL_CM match <span class="hljs-keyword"><span class="hljs-keyword">any</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shape to 20Mb / s: </font></font><br><br><pre> <code class="hljs swift"> policy-<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> <span class="hljs-type"><span class="hljs-type">TRISOLARANS_SHAPING</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRISOLARANS_ALL_CM</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shape</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">average</span></span></span><span class="hljs-class"> 20000000</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apply to the output interface: </font></font><br><br><pre> <code class="hljs kotlin"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ethernet0</span></span></span><span class="hljs-class">/2 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">service</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">policy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">output</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRISOLARANS_SHAPING</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All that must leave (output) interface Ethernet0 / 2, shape up to 20 Mb / s. </font></font><br><br> <a href="https://docs.google.com/document/d/e/2PACX-1vQ0FLKJi6_dxwvmvIWKISVSZIurHrw896wEBuXVTbkoo677VFS0S5cZv6FCJrBqhmAsaDChoUvR4172/pub"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shaper configuration file. </font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here's the result: </font></font><br><br><img src="https://habrastorage.org/webt/tz/1i/sr/tz1isrb6mnjnirkxe46wbzed2yu.png" width="900"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turns out a fairly smooth line of total capacity and ragged graphics for each individual stream. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that we limit the common strip with the shaper. </font><font style="vertical-align: inherit;">However, depending on the platform, individual streams can also be individually shaped, thus obtaining equal opportunities.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's set up polishing on Linkmeup_R2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will add a policer to the existing policy.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>-map TRISOLARANS_ADMISSION_CONTROL <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TRISOLARANS_TCP_CM police cir <span class="hljs-number"><span class="hljs-number">10000000</span></span> bc <span class="hljs-number"><span class="hljs-number">1875000</span></span> conform-action transmit exceed-action <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The interface policy has already been applied: </font></font><br><br><pre> <code class="hljs pgsql"> interface Ethernet0/<span class="hljs-number"><span class="hljs-number">1</span></span> service-<span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> TRISOLARANS_ADMISSION_CONTROL</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we indicate the average allowed speed of CIR (10Mb / s) and the allowed burst of Bc (1,875,000 bytes about 14.6 MB). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Later, explaining how a polisher works, I will tell you what CIR and Bc are and how to determine these values. </font></font><br><br> <a href="https://docs.google.com/document/d/e/2PACX-1vTl81fiPO4MFeznoyoCGOF_rHbt7p7jUS0WosHgPVNObZo_WtMwThneBdu1LUUG9A0OFxBtmKOYXOUE/pub"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polyser configuration file. </font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This picture is observed during polising. </font><font style="vertical-align: inherit;">Immediately see dramatic changes in the level of speed:</font></font><br><br><img src="https://habrastorage.org/webt/wg/vb/iv/wgvbiv6biiv27f99npxfupqjdla.png" width="900"><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But such a curious picture is obtained if we make the allowable burst size too small, for example, 10,000 bytes. </font></font><br><br><pre> <code class="hljs pgsql"> police cir <span class="hljs-number"><span class="hljs-number">10000000</span></span> bc <span class="hljs-number"><span class="hljs-number">10000</span></span> conform-action transmit exceed-action <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/3a/cn/l0/3acnl01957rqgxcsonokebamdim.png" width="900"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The overall speed immediately dropped to about 2Mb / s. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Be careful with setting up the bursts :) </font></font><br><br> <a href="https://drive.google.com/file/d/1YwKgZTynOpMJ__IapR-qzsRmh6BsJNKf/view%3Fusp%3Dsharing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test table.</font></font></a> <br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leaky Bucket and Token Bucket Mechanisms </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It sounds easy and understandable. </font><font style="vertical-align: inherit;">But how does it work in practice and is it implemented in hardware?</font></font><br><br>  Example. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is the limit of 400 MB / s a ‚Äã‚Äãlot (or a little)? </font><font style="vertical-align: inherit;">On average, the client uses only 320. But sometimes rises to 410 for 5 minutes. </font><font style="vertical-align: inherit;">And sometimes up to 460 for a minute. </font><font style="vertical-align: inherit;">And sometimes up to 500 for half a second. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a contractual provider, linkmeup can say - 400 and that's that! </font><font style="vertical-align: inherit;">Want more, connect to the tariff 1Gb / s + 27 anime channels. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And we can increase customer loyalty, if it does not interfere with others, allowing such bursts. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to allow 460Mb / s for just one minute, not 30 or forever? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to allow 500 MB / s, if the band is free, and press up to 400, if there are other consumers? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now take a break, pour a strong bucket. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start with a simpler mechanism used by the shaper - a flowing bucket.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leaky bucket algorithm </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leaky Bucket is a leaking bucket. </font></font><br><br><img src="https://habrastorage.org/webt/te/qj/jv/teqjjvam2gz-gwlvfcfr1osqj5q.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have a bucket with a hole of a given size at the bottom. Packages are poured into this bucket on top. And from the bottom they flow with a constant bit rate. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the bucket fills, new packages begin to be discarded. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The hole size is determined by the specified speed limit, which for Leaky Bucket is measured in bits per second. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The volume of the bucket, its fullness and output speed determine the delay introduced by the shaper. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For convenience, the bucket volume is usually measured in ms or Œºs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In terms of implementation, Leaky Bucket is a regular SD-RAM based buffer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even if the shaping is not explicitly configured, in the presence of bursts that do not pass into the interface, the packets are temporarily added to the buffer and transmitted as the interface is released. </font><font style="vertical-align: inherit;">This is also shaping. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leaky Bucket is used only for shaping and is not suitable for poliscing.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithm Token Bucket </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many believe that Token Bucket and Leaking Bucket are one and the same. </font><font style="vertical-align: inherit;">Only Einstein was more mistaken when he added the cosmological constant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Switching chips are not very well aware of what time is, they consider even worse how many bits they transmitted per unit of time. </font><font style="vertical-align: inherit;">Their job is to thresh. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is this approaching bit another 400,000,000 bits per second, or is it already 400,000,001? </font></font><br><br><img src="https://habrastorage.org/webt/kh/pu/i6/khpui6xw0sle9wconrc6ouoeedg.png" width="400"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASIC developers had a non-trivial engineering challenge. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">She was divided into two subtasks:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually speed limit by dropping excess packets based on a very simple condition. </font><font style="vertical-align: inherit;">It is carried out on switching chips.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating this simple condition, which deals with a more complex (more specialized) chip, leading the expense of time. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The algorithm that solves the second problem is called Token Bucket. </font><font style="vertical-align: inherit;">His idea is elegant and simple (no). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The task of Token Bucket is to allow traffic if it fits within the limit and discard / dye red if not. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the same time, it is important to allow bursts of traffic, as this is normal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if in Leaky Bucket bursts were absorbed by the buffer, then Token Bucket does not buffer anything.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Single Rate - Two Color Marking </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not pay attention to the name yet =) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have a bucket in which coins fall at a constant speed - 400 mega-coins per second, for example. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The volume of the bucket is 600 million coins. That is, it is filled in a half second. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nearby are two conveyor belts: one brings packages, the second - takes away. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To get on the conveyor belt, the package must pay. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coins for this he takes from the bucket in accordance with its size. Roughly speaking - how many bits - so many coins. </font></font><br><br><img src="https://habrastorage.org/webt/2m/lh/kz/2mlhkzj9j1vezkils69vlszdgc0.png" width="800"><br><br><img src="https://habrastorage.org/webt/hj/o5/nn/hjo5nn2u7omtuighgtohqpx1y1k.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the bucket is empty and the package is not enough coins, it is painted in red signal color and discarded. Alas, mudflows. At the same time, coins are not removed from the bucket.</font></font><br><br><img src="https://habrastorage.org/webt/d-/bf/q9/d-bfq9l2tnj90-58kvi38zl3ufy.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next package of coins may already be enough - firstly, the package may be smaller, and, secondly, more coins will attack during this time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the bucket is already full, all new coins will be thrown away. </font></font><br><br><img src="https://habrastorage.org/webt/cs/yn/yq/csynyq7ig1pfozdswqkxt59dt2e.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It all depends on the rate of arrival of packages and their size. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If it is consistently lower than or equal to 400 MB per second, then there will always be enough coins. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If higher, then some packets will be lost.</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A more specific example with gifs, as we all love. </font></font><br><br><img src="https://habrastorage.org/webt/o1/ds/ek/o1dsekpsi9nhg-plchkoivxrwm4.gif"><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a bucket with a capacity of 2500 bytes. </font><font style="vertical-align: inherit;">At the initial moment of time there are 550 tokens in it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the pipeline, three packets of 1000 bytes, which want to be sent to the interface. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In each time slot, 500 bytes are dropped into the bucket (500 * 8 = 4 000 bits / time quantum ‚Äî a limit to the polisher).</font></font></li><li>         500 .       .   1000 ,    1050  ‚Äî <b></b> .       . 1000    . <br>    50 . </li><li>          500  ‚Äî  550.     ‚Äî 1000 ‚Äî <b> </b> . <br>     ,   . </li><li>         500  ‚Äî  1050.    ‚Äî 1000 ‚Äî <b></b> . <br>      ,    . </li></ul><br>    2500   ,             2500  ‚Äî      .        MTU    ,      ,  ,  1,5-2 . <br><br>   <a href="https://en.wikiquote.org/wiki/Stephen_Hawking"></a> : <br><br> CBS = CIR (  )*1,5 ()/8 (  ) <br><br>       ,     (Bc),   ,     (1 875 000 )    .    (10 000 ),   ,     MTU,           . <br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why bucket volume? The bitstream is not always uniform, it is obvious. The 400 Mb / s limit is not an asymptote - traffic can cross it. The volume of stored coins allows small bursts to fly by without being discarded, but the average speed is kept at 400 MB / s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, a stable stream of 399 MB / s for 600 seconds will allow the bucket to fill to the brim. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further, the traffic can rise to 1000Mb / s and stay at this level for 1 second - 600 Mm (Megamonet) of the stock and 400 Mm / s of the guaranteed band. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Or the traffic can rise up to 410 Mb / s and stay that way for 60 seconds. </font></font><br><br><img src="https://habrastorage.org/webt/hq/yl/ib/hqylibyhmxkhepdt9mcf04m7rnk.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, the stock of coins allows you to slightly go beyond the limit for a long time or throw out a short but high burst. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now to the terminology.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The rate of arrival of coins in a bucket - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CIR - Committed Information Part Rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Guaranteed average speed). </font><font style="vertical-align: inherit;">Measured in bits per second. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The number of coins that can be stored in the bucket - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBS - Committed Burst Size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Maximum allowed burst size. </font><font style="vertical-align: inherit;">Measured in bytes. </font><font style="vertical-align: inherit;">Sometimes, as you may have noticed, is called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - The number of coins (Token) in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bucket </font><font style="vertical-align: inherit;">(CBS) at the moment.</font></font><br><br><img src="https://habrastorage.org/webt/nm/rr/iv/nmrrivc2sdktqp4cfyhwfayjuze.png" width="600"><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the article, I use the term " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", just as it is used in </font></font><a href="https://tools.ietf.org/html/rfc2697"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC 2697</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Single Rate Three Color Marker</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, there is another Tc, which describes the time interval when a new batch of coins is poured into a bucket.</font></font><br>  There should be a retreat. <br>    ,    ,     Token Bucket,    <b>TDM</b> (Time-Division Multiplexing) ‚Äî         . <br>          ‚Äî  , , . <br>          CIR .    . <br>   ,    ‚Äî   ,  ‚Äî   ,  ‚Äî   . <br>         ,      . <br>      (    Cisco) <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and the number of falling coins - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In this case, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bc = CIR * Tc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, at the beginning of each Tc interval, Bc coins are lowered into the bucket.</font></font><br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the easiest scenario. </font><font style="vertical-align: inherit;">It is called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Single Rate - Two Color</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Single Rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> means that there is only one average allowed speed, and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two Color</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - that you can paint traffic in one of two colors: green or red.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the number of available coins (bits) in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bucket is </font><font style="vertical-align: inherit;">more than the number of bits that you need to skip at the moment, the package is painted green ‚Äî a low probability of discarding later. </font><font style="vertical-align: inherit;">Coins </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are withdrawn</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the bucket.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otherwise, the package is painted in red - a high probability of a drop (or, more often, a momentary drop). </font><font style="vertical-align: inherit;">Coins thus buckets </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C is withdrawn</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Used for polysing in PHB CS and EF, where speeding is not expected, but if it happens, it is better to immediately drop it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further we will consider more difficult: Single Rate - Three Color.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Single Rate - Three Color Marking </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The disadvantage of the previous scheme is that there are only two colors. What if we do not want to discard everything that is above the average allowed speed, but want to be even more loyal? </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the TCM-sr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Single Rate - the Three the Color The Marking</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) enters the second bucket in - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . At this time, the coins are not placed in a bucket filled with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , are poured into </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><b><font style="vertical-align: inherit;">EBS is</font></b></font><br><br><img src="https://habrastorage.org/webt/xq/wq/fb/xqwqfblgko9sadvpv_zg2khhoma.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> added to CIR and CBS </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Excess Burst Size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - The allowed burst size during peaks. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Te</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the number of coins in a bucket </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/un/tb/1v/untb1vhnskpben6jqecdqinvx4q.png" width="600"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose a package of size </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> came through the pipeline.</font></font> Then <br><br><ol><li>     <b>C</b> ,      .   <b>C</b>  <b>B</b>  (: Tc ‚Äî B). </li><li>     <b>C</b>  ,   <b>E</b> .     ,     (  ),   <b>E</b>  <b>B</b> . <br><br><img src="https://habrastorage.org/webt/oi/my/if/oimyif_nplc0auqsknrlbtatqe0.png" width="800"><br></li><li>     <b>E</b>   ,     ,    . <br><br><img src="https://habrastorage.org/webt/tn/44/ct/tn44ctwmh8zxmekxrr9y6sv4avm.png" width="800"><br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note that for a specific package Tc and Te are </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not cumulative</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, a packet of 8000 bytes in size will not pass, even if </font><font style="vertical-align: inherit;">there are 3000 coins </font><font style="vertical-align: inherit;">in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bucket </font><font style="vertical-align: inherit;">, and in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 7000. In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not enough, in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not enough - we put a red stamp - shurui from here. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a very elegant scheme. All traffic that fits into the mean CIR + CBS limit (the author knows that it is impossible to directly add bits / s and bytes) - passes in green. At peak times when the customer has exhausted the coins in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bucket </font><font style="vertical-align: inherit;">, he still has the stock of Te in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bucket accumulated during idle time </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, you can skip a little more, but in the case of congestion, these are more likely to be discarded. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sr-TCM is described in </font></font><a href="https://tools.ietf.org/html/rfc2697"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC 2697</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Used for polysing in PHB AF. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, the last system is the most flexible and therefore complex - Two Rate - Three Color.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Two Rate - Three Color Marking </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tr-TCM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> model </font><font style="vertical-align: inherit;">was born from the idea that, not to the detriment of other users and types of traffic, why shouldn't the client be given a bit more pleasant opportunities, and even better to sell. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's tell him that he is guaranteed 400 Mb / s, and if there are free resources, then 500. Are you ready to pay 30 rubles more? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Added another bucket </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CIR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - guaranteed average speed. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the same allowed burst size (bucket volume </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Peak Information Rate - the maximum average speed. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EBS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the allowed burst size during peaks (Bucket Volume </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unlike sr-TCM, the tr-TCM now in each bucket is independently received coins. </font><font style="vertical-align: inherit;">In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - with CIR speed, in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - PIR. </font></font><br><br><img src="https://habrastorage.org/webt/xd/gk/_d/xdgk_dfz6sd-mw6lsw_adkipcve.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Which rules? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> byte </font><font style="vertical-align: inherit;">packet arrives </font><font style="vertical-align: inherit;">.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there are </font><font style="vertical-align: inherit;">not enough </font><font style="vertical-align: inherit;">coins in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bucket </font><font style="vertical-align: inherit;">, the bag is marked in red. </font><font style="vertical-align: inherit;">Coins </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can not be removed</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> Otherwise: </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If </font><font style="vertical-align: inherit;">there is not enough </font><font style="vertical-align: inherit;">coins in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bucket </font><font style="vertical-align: inherit;">, the package is marked yellow, and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coins </font><b><font style="vertical-align: inherit;">are removed</font></b><font style="vertical-align: inherit;"> from the </font><b><font style="vertical-align: inherit;">P</font></b><font style="vertical-align: inherit;"> bucket </font><font style="vertical-align: inherit;">.</font></font> Otherwise: </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The package is marked green and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coins </font><b><font style="vertical-align: inherit;">are removed</font></b><font style="vertical-align: inherit;"> from </font><b><font style="vertical-align: inherit;">both buckets</font></b><font style="vertical-align: inherit;"> .</font></font></li></ol><br><img src="https://habrastorage.org/webt/xz/ac/xl/xzacxlryw2kkvf1ms-nkgufteba.png" width="800"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, the rules in tr-TCM are different. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As long as traffic keeps within guaranteed speed, coins are taken out of both buckets. </font><font style="vertical-align: inherit;">Due to this, when the </font><font style="vertical-align: inherit;">coins run out </font><font style="vertical-align: inherit;">in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bucket </font><font style="vertical-align: inherit;">, they will remain in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but just enough to not exceed the PIR (if they were taken out only from </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> would fill more and give a much higher speed). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accordingly, if it is higher than guaranteed, but lower than the peak, coins are removed only from </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because there is </font><font style="vertical-align: inherit;">already nothing </font><font style="vertical-align: inherit;">in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C. </font></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tr-TCM monitors not only bursts, but also constant peak speeds. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tr-TCM is described in </font></font><a href="https://tools.ietf.org/html/rfc2698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC 2698</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Also used for polis in PHB AF. </font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speed ‚Äã‚ÄãSummary Summary </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">While shaping puts off traffic when it is exceeded, polishing discards it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shaping is not suitable for applications that are sensitive to delays and jitter. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To implement polishing in hardware, the algorithm is Token Bucket, for shaping - Leaky Bucket. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Token Bucket can be:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With one bucket - Single Rate - Two Color Marking. </font><font style="vertical-align: inherit;">Allows valid bursts.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With two buckets - Single Rate - Three Color Marking (sr-TCM). </font><font style="vertical-align: inherit;">Surplus from the C bucket (CBS) is poured into the bucket E. Allows acceptable and excess bursts.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With two buckets - Two Rate - Three Color Marking (tr-TCM). </font><font style="vertical-align: inherit;">Buckets C and P (PBS) are replenished independently at different speeds. </font><font style="vertical-align: inherit;">Allows peak speed and allowable and excess bursts.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sr-TCM focuses on traffic over limit. tr-TCM - at the rate at which it arrives. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Polising can be used on the input and output from the device. Shaping mainly at the exit. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For PHB CS and EF, Single Rate Two Color Marking is used. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For AF, sr-TCM or tr-TCM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For perhaps a better understanding, I recommend turning to the original RFC or reading </font></font><a href="http://blog.ine.com/2011/05/22/understanding-single-rate-and-dual-rate-traffic-policing/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><blockquote>  Token Bucket     . ,       ,   ,       ,       . <br>     ,         ‚Äî ,  .   ,    ,       ,    ‚Äî  . <br>      ,     .          ‚Äî   .         . <br></blockquote><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Above, I described all the basic QoS mechanisms, if not to go into hierarchical QoS. </font><font style="vertical-align: inherit;">The most complex system with numerous moving parts. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything is good (right?) It has sounded so far, but what is happening under the vanilla outer panel of the router? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Over the years, vendors added more and more new designs, developed complex chips, expanded buffers to keep pace with the growing volume of traffic and its new categories, on the one hand, and to solve the growing problems caused by the first item, on the other. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuing race. </font><font style="vertical-align: inherit;">You can not lose packages if a competitor does not lose them. </font><font style="vertical-align: inherit;">You can not abandon the functionality if the opponent is with him under the doors of the customer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ida in the den of proprietary!</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Hardware QoS implementation </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, I take on the ungrateful task. If you describe as simple as possible, there will always be those who say that everything is not so in reality. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you describe it as it is, the reader will drop the article, because it will turn into a drawing of a submarine, more precisely the drawings of three boats with pencils of different colors on one sheet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, I will make a disclaimer that in reality everything is not as it really is, and I will go according to the variant of a simple exposition. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forgive me, my companion perfectionist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What controls the behavior of the node and starts the appropriate mechanisms in relation to the package? The priority he carries in one of the headers?</font></font> Yes and no. <br><br><img src="https://habrastorage.org/webt/th/ie/l1/thiel1p000d6rgwchs-xo1hl4ys.png" width="250"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mentioned above, a standard switching header usually ceases to exist within a network device. </font></font><br><br><img src="https://habrastorage.org/webt/nj/h5/aq/njh5aquhoyypydjzrdttbespgr4.png" width="1000"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as the packet got on the switching chip, the headers are removed from it and sent for analysis, and the payload languishes in some kind of temporary buffer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on the headers, a classification occurs (BA or MF) and the decision to transfer is made. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In an instant, an internal header with package metadata is attached to the packet. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This metadata carries a lot of important information - the sender and recipient addresses, the output chip, the cell sequence number, if there was packet fragmentation and necessarily class marking (CoS) and drop priority (Drop Precedence). Only marking in the internal format - it may or may not coincide with the DSCP.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In principle, inside the box you can set an arbitrary marking length, without being tied to standards, and define the operation with the package very flexibly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At Cisco, the internal labeling is called QoS Group, at Juniper - Forwarding Class, Huawei is undecided: somewhere it calls internal priorities, somewhere local priorities, somewhere Service-Class, and somewhere simply CoS. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add in the names of comments for other vendors - I will add.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This internal marking is assigned based on the classification that the node has performed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important that, if it is not stated otherwise, the internal marking only works inside the node, but then it doesn‚Äôt appear on the label in the headers of the packet that will be sent from the node - it will remain the same.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, at the entrance to the DS-domain, after classification, a remarking into a certain class of service adopted in this network usually occurs. Then the internal marking is converted to the value adopted for this class on the network, and is written in the header of the packet being sent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The internal marking of CoS and Drop Precedence only defines the behavior inside this node and is not explicitly transmitted to neighbors, except for remarking of headers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CoS and Drop Precedence determine the PHB, its mechanisms and parameters: overload prevention, overload management, scheduling, remarking.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Through what circles pass the packets between the input and output interfaces I discussed in the </font></font><a href="http://linkmeup.ru/blog/312.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">previous article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Actually, it turned out to be unplanned, since at some point it became obvious that it was premature to talk about QoS without an understanding of the architecture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, let's repeat.</font></font><br><br><img src="https://habrastorage.org/webt/3k/s1/3e/3ks13e4uzagzrbopm5juuyun4j8.png" width="1000"><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The signal goes to the physical input interface and its chip (PIC). </font><font style="vertical-align: inherit;">A bitstream flows from it and then a packet with all the headers.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next to the input switching chip (FE), where the headers are separated from the packet body. </font><font style="vertical-align: inherit;">There is a classification and it is determined where the package should be sent further.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next to the input queue (TM / VOQ). </font><font style="vertical-align: inherit;">Already here, packages are laid out in different queues based on their class.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next to the switching factory (if there is one). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next to the output queue (TM). </font></font></li><li>      (FE),    . </li><li>     (,    ) (PIC). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the router must solve a complex equation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spread out all the classes, provide someone with a wide band, someone low latency, someone to ensure the absence of losses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And at the same time have time to skip all traffic if possible. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, you need to do shaping, possibly polishing. </font><font style="vertical-align: inherit;">If suddenly there is an overload, then cope with it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And that's not counting Lukap, processing ACL, statistics calculation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unenviable share. </font><font style="vertical-align: inherit;">But robots are driving, not man. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, there are only two places where the QoS mechanisms work - the switching chip and the Traffic Management / queue chip. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, on the switching chip, operations occur that require analysis or actions with headers.</font></font><br><br><ul><li>  Classification </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Polising </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remarking </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The rest is taken by TM. </font><font style="vertical-align: inherit;">These are mainly routine operations with a predefined algorithm and adjustable parameters:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Overload prevention </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Congestion management </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shaping </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TM is a smart buffer, usually based on SD-RAM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He is smart because, a) programmable, b) with queues he knows how to do all sorts of tricky things. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is often distributed ‚Äî SD-RAM chips are located on each interface card, and together they combine into a VOQ (Virtual Output Queue), which solves the problem Head of Line Blocking. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that if the switching chip or the output interface is flooded, then they ask the input chip to slow down and not send traffic for some time. If there is only one queue in all directions, then it is very disappointing that all the others suffer from one output interface. This is the Head of Line Blocking. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VOQ creates multiple virtual output queues for each existing output interface on the input interface board.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, these lines in modern equipment take into account the labeling of the package. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About VOQ described in sufficient detail in a series of notes </font></font><a href="https://forums.juniper.net/t5/forums/recentpostspage/post-type/message/category-id/Blogs/user-id/101479"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, the lines are actually placed, they are promoted, not the packages themselves, but only the records about them, are being withdrawn, etc. It makes no sense to do so many gestures with large arrays of bits. While QoS is being measured over the records, the packets are fine in the memory and retrieved from there by the address. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VOQ is a software queue (the English term Software Queue is more accurate). After it, immediately before the interface there is also a hardware queue, which always, strictly works on FIFO. To control any of its parameters is almost impossible (for example, Cisco allows you to adjust only the depth with the tx-ring-limit command).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just between software and hardware queue, you can run arbitrary dispatchers. It is in the program queue that Head / Tail-drop and AQM work, polishing and shaping. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The size of the hardware queue is very small (units of packages), because the dispatcher does all the work of putting in the line-rate. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, here you can make a lot of reservations, and in general, cross out everything with a red pen and say ‚Äúvendor X has everything wrong‚Äù.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would like to make one more note about service packages. They are handled differently than user transit packets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Being generated locally, they are not checked for compliance with ACL rules and speed limits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The packets from the outside, destined for the CPU, from the output switching chip fall into other queues ‚Äî to the CPU ‚Äî based on the protocol type. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, BFD has the highest priority, OSPF can wait a little longer, and ICMP and generally not afraid to drop. That is, the more important the packet is for network performance, the higher is its class of service when sent to the CPU. That is why seeing in ping or tracing varying delays on transit hops is normal - ICMP is not a priority for CPU traffic. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, protocol packets apply</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CoPP - Control Plane Protection</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (or Policing) - speed limits to avoid high CPU utilization - again, better predictable drops in low priority queues before problems start. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CoPP will help from both targeted DoS and abnormal network behavior (for example, loops) when a lot of broadcast traffic begins to arrive on the device.</font></font><br><br><hr><br><h1>  useful links </h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The best book on the theory and philosophy of QoS: </font></font><a href="https://www.amazon.com/QOS-Enabled-Networks-Foundations-Communications-Distributed/dp/1119109108/ref%3Dsr_1_2%3Fs%3Dbooks%26ie%3DUTF8%26qid%3D1532948422%26sr%3D1-2%26keywords%3DQOS-Enabled%2BNetworks%253A%2BTools%2Band%2BFoundations"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QOS-Enabled Networks: Tools and Foundations</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some excerpts from it can be read </font></font><a href="http://what-when-how.com/category/qos-enabled-networks/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but I would recommend reading it in and out without exchanging it.</font></font></li><li>         QoS  Huawei: <a href="http://support.huawei.com/enterprise/en/doc/EDOC1000079860">Special Edition QoS(v6.0)</a> .        PHB   . </li><li>    sr-TCM  tr-TCM  : <a href="http://blog.ine.com/2011/05/22/understanding-single-rate-and-dual-rate-traffic-policing/">Understanding Single-Rate and Dual-Rate Traffic Policing</a> . </li><li>  VOQ: <a href="https://forums.juniper.net/t5/forums/recentpostspage/post-type/message/category-id/Blogs/user-id/101479">What is VOQ and why you should care?</a> </li><li>  QoS  MPLS: <a href="https://www.networkworld.com/article/2298533/lan-wan/mpls-and-quality-of-service.html%3Fpage%3D2">MPLS and Quality of Service</a> . </li><li>     QoS   Juniper: <a href="https://www.saidvandeklundert.nl/qos.php">Juniper CoS notes</a> . </li><li>   QoS       TCP  UDP.       : <a href="http://www.tcpipguide.com/free/index.htm">The TCP/IP Guide</a> </li><li>    ,          ,       : <a href="http://linkmeup.ru/blog/300.html">         TCP</a> . </li><li>    ,        FQ: <a href="https://intronetworks.cs.luc.edu/current/html/queuing.html">Queuing and Scheduling</a> . <br>      ,     ,  <a href="https://intronetworks.cs.luc.edu/current/html/index.html">An Introduction to Computer Networks</a> ,  ,     Introduction,      .    . <br></li><li>  WFQ  ,    , , ,   ,    : Weighted Fair Queueing: a packetized approximation for FFS/GP. <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is also the LFI mechanism, which I didn‚Äôt touch upon, because it is not very important in our realities to have a stigabyte interface, but it may be interesting to get acquainted: </font></font><a href="https://www.ccexpert.us/traffic-shaping-2/link-fragmentation-and-interleaving.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link Fragmentation and Interleaving</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, of course, the RFC set ...</font></font></b> <div class="spoiler_text"><ul><li> <a href="https://tools.ietf.org/html/rfc791">tools.ietf.org/html/rfc791</a> ( <i>INTERNET PROTOCOL</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc1349">tools.ietf.org/html/rfc1349</a> ( <i>Type of Service in the Internet Protocol Suite</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc1633">tools.ietf.org/html/rfc1633</a> ( <i>Integrated Services in the Internet Architecture: an Overview</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc2474">tools.ietf.org/html/rfc2474</a> ( <i>Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc2475">tools.ietf.org/html/rfc2475</a> ( <i>An Architecture for Differentiated Services</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc2597">tools.ietf.org/html/rfc2597</a> ( <i>Assured Forwarding PHB Group</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc2697">tools.ietf.org/html/rfc2697</a> ( <i>A Single Rate Three Color Marker</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc2698">tools.ietf.org/html/rfc2698</a> ( <i>A Two Rate Three Color Marker</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc3031">tools.ietf.org/html/rfc3031</a> ( <i>Multiprotocol Label Switching Architecture</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc3168">tools.ietf.org/html/rfc3168</a> ( <i>The Addition of Explicit Congestion Notification (ECN) to IP</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc3246">tools.ietf.org/html/rfc3246</a> ( <i>An Expedited Forwarding PHB (Per-Hop Behavior)</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc3260">tools.ietf.org/html/rfc3260</a> ( <i>New Terminology and Clarifications for Diffserv</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc3662">tools.ietf.org/html/rfc3662</a> ( <i>A Lower Effort Per-Domain Behavior (PDB) for Differentiated Services</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc4594">tools.ietf.org/html/rfc4594</a> ( <i>Configuration Guidelines for DiffServ Service Classes</i> ) </li><li> <a href="https://tools.ietf.org/html/rfc5462">tools.ietf.org/html/rfc5462</a> ( <i>Multiprotocol Label Switching (MPLS) Label Stack Entry: ¬´EXP¬ª Field Renamed to ¬´Traffic Class¬ª Field</i> ) </li></ul><br></div></div><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This release has had many reviewers. </font></font><br>  Thank. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander </font></font><a href="https://habr.com/users/loxmatiymamont/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fatinu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><a href="https://habr.com/users/loxmatiymamont/" class="user_link"><font style="vertical-align: inherit;">LoxmatiyMamont</font></a><font style="vertical-align: inherit;"> ) for the introductory word and valuable advice on the expressiveness and clarity of the text. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Clipper (@ metallicat20) for peer review. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexandru Klimenko (@ v00lk) for harsh criticism and the most massive changes in recent days. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrei Glazkov (@glazgoo) for comments on structure, terminology and commas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artem Chernobay for KDPV. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anton Klochkov (@NAT_GTX) for contacts with Miran. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Miran (miran.ru) for organizing the server with Eve and broadcast. </font><font style="vertical-align: inherit;">Traditionally, my family, which, incidentally, this time suffered the least because of her absence near the most difficult moments.</font></font></div><p>Source: <a href="https://habr.com/ru/post/420525/">https://habr.com/ru/post/420525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420515/index.html">Diarization based on GMM-UBM model and MAP adaptation algorithm</a></li>
<li><a href="../420517/index.html">Implementation of integer FFT on the FPGA</a></li>
<li><a href="../420519/index.html">Popularization of science</a></li>
<li><a href="../420521/index.html">Now officially: TLS 1.3 is recognized as standard</a></li>
<li><a href="../420523/index.html">Analysis of binary options charts or how I once again proved to myself that freebies do not exist</a></li>
<li><a href="../420527/index.html">A smile can sound and it is contagious.</a></li>
<li><a href="../420529/index.html">Advanced use of Gita or how to retire half a year earlier?</a></li>
<li><a href="../420533/index.html">Emulate Property Literals with Java 8 Method Reference</a></li>
<li><a href="../420537/index.html">Another tale about how relatively megaphone relatively honestly rob money</a></li>
<li><a href="../420539/index.html">Custom approach to normalize and reset styles (custom-reset.css)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>