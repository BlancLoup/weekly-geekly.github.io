<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ideas about new features of ordinary / parallel programming (extension C ++)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear readers. 

 I suggest everyone who is interested to discuss some of the main ideas of classical and parallel programming in the C ++ exten...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ideas about new features of ordinary / parallel programming (extension C ++)</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear readers. <br><br>  I suggest everyone who is interested to discuss some of the main ideas of classical and parallel programming in the C ++ extension based on procedures / functions with re-entry planning (PPPV / FPPV).  In the minimum case, it is a procedure or function that has a static or dynamic execution plan. <a name="habracut"></a>  A plan is, generally speaking, a deck consisting of elements-structures, each of which has fields similar in type and name to the parameters of the corresponding function / procedure.  A plan can be replenished both from the outside (before calling a procedure / function, using some simple tricks), or from the inside (this is the main approach) with the help of special calls at the beginning of <b>plan_first (...)</b> or at the end of <b>plan_last (...) of the</b> plan . <br><br>  PPPV / FPPV is performed sequentially or in parallel, in accordance with the plan.  In <b>sequential mode,</b> it is called again for each element of the plan (the element is by default retrieved from the beginning of the plan) and fulfills it completely (until the natural completion of the PPPV / FDPV or before the return).  At each call, the parameters of the PPPV / FPVV are filled with data from the fields of the current element of the plan with the same name.  As it was already said, in the process of execution of any of the stages, new stages can be inserted into the plan, which will be implemented by the PPSP / FPPV further.  To support <b>parallel mode</b> (in the simplest case), in addition to the stages, special marker barriers can be inserted dividing the plan into groups.  With the help of the <b>plan_group_parallelize</b> directive, <b>you</b> can enable parallel execution of the current (located at the beginning of the plan) group, while it is considered as a group of tasks (task pool) from which processors / cores gather themselves into execution stages of the task.  With the help of the <b>plan_group_vectorize</b> directive, <b>you</b> can send a task group to a vector calculator, such as a multi-core video card (though some features may arise in the design of the program - for example, you may need to explicitly note which of the program blocks are intended only for a vector calculator, which are CPU, which is for both CPU and vector <br>  devices). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Already this basic approach provides, at a minimum: <br><br><ul><li>  another way of programming many tasks that use the stack, decks, the queue, and sometimes even an array. </li><li>  another approach to programming parallel processing for SMP systems and vector calculators (multi-core graphics cards). </li></ul><br>  In order not to complicate the understanding, I will immediately give a couple of examples. <br><br>  <b>Parallel summation of elements in the tree.</b>  <b>The reduction parameter is SumResult.</b> <br><br><pre><code class="cpp hljs">reenterable[ARR_SIZE] TreeSum(TreeNode * Cur, reduction(+) DataItem &amp; SumResult) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Cur==Root) plan_group_parallelize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Cur-&gt;Left) plan_last(Cur-&gt;Left,SumResult); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Cur-&gt;Right) plan_last(Cur-&gt;Right,SumResult); SumResult = Cur-&gt;Data; }</code> </pre> <br>  <b>Lee Wave Algorithm: Finding a path in a maze.</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NL = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> W = <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Labirint[NL][NL] = { {W,W,W,W,W,W,W,W,W,W}, {W,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,W}, {W,<span class="hljs-number"><span class="hljs-number">0</span></span>,W,W,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,W,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,W}, {W,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,W,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,W,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,W}, {W,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,W,W,<span class="hljs-number"><span class="hljs-number">0</span></span>,W,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,W}, {W,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,W,W,W,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,W}, {W,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,W}, {W,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,W}, {W,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,W}, {W,W,W,W,W,W,W,W,W,W}, }; <span class="hljs-comment"><span class="hljs-comment">/*       , , ,  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> OffsX[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,+<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> OffsY[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,+<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> FirstX = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> FirstY = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> LastX = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> LastY = <span class="hljs-number"><span class="hljs-number">4</span></span>; chain[NL*NL] FindLi(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> X, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Y, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Num) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> X, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Y) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Found = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; !Found &amp;&amp; i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> X1 = X+OffsX[i]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Y1 = Y+OffsY[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X1&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; X1&lt;NL &amp;&amp; Y1&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; Y1&lt;NL &amp;&amp; Labirint[Y1][X1]==<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> Labirint[Y1][X1] = Num; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X1==LastX &amp;&amp; Y1==LastY) <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> Found = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> plan_last(X1,Y1,Num+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Found) { clear_plan; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> X = LastX; Y = LastY; throw_last(X,Y); <span class="hljs-comment"><span class="hljs-comment">/*   ""   () */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (X!=FirstX || Y!=FirstY) { <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> PointFound = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; !PointFound &amp;&amp; i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> X1 = X+OffsX[i]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Y1 = Y+OffsY[i]; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X1&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; X1&lt;NL &amp;&amp; Y1&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; Y1&lt;NL &amp;&amp; Labirint[Y1][X1] &amp;&amp; Labirint[Y1][X1]&lt;Labirint[Y][X]) { <span class="hljs-comment"><span class="hljs-comment">/*         */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      ,     */</span></span> PointFound = <span class="hljs-number"><span class="hljs-number">1</span></span>; throw_first(X1,Y1); <span class="hljs-comment"><span class="hljs-comment">/*    ()   */</span></span> X = X1; Y = Y1; <span class="hljs-comment"><span class="hljs-comment">/*         */</span></span> } } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (plan_empty) <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"NO PATH\n"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } chain[NL*<span class="hljs-number"><span class="hljs-number">2</span></span>] OutLi(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> X, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Y) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"("</span></span>&lt;&lt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Y&lt;&lt;<span class="hljs-string"><span class="hljs-string">","</span></span>&lt;&lt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)X&lt;&lt;<span class="hljs-string"><span class="hljs-string">") "</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"Find the path in the simple labirint (Li algorithm) :\n"</span></span>; Labirint[FirstY][FirstX] = <span class="hljs-number"><span class="hljs-number">1</span></span>; plan_chain(<span class="hljs-number"><span class="hljs-number">0</span></span>,FindLi(FirstX,FirstY,<span class="hljs-number"><span class="hljs-number">2</span></span>),OutLi(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  And one more <b>abstract example of working with a multi-core video card</b> , which I will give without explanation.  Perhaps someone will be interested to guess how it works. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> plan vectorized #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; #pragma plan common begin #define N 5 #define threads 100 #pragma plan common end #pragma plan gpu begin #define addition 0.01 #pragma plan gpu end float MUL = 3.14; float * _OUT = NULL; reenterable void proc(bool init, int k, _global(1) float * mul, _global(threads) int * sizes, int n, _local(__planned__.n) float * out) { int i; if (init) { for (i = 0; i &lt; threads; i++) { plan_last(false, i, mul, sizes, sizes[i], out); out += sizes[i]; } plan_group_vectorize(NULL); } else for (i = 0; i &lt; n; i++) { *out = k*(*mul); #ifdef __GPU__ *out += addition; #endif out++; } } int main() { int * sizes = new int[threads]; int NN = 0; for (int i = 0; i &lt; threads; i++) { sizes[i] = 1 + i % 2; NN += sizes[i]; } _OUT = new float[NN]; cout&lt;&lt;"MAX group size = "&lt;&lt;vector_max_size(NULL)&lt;&lt;endl; proc(true, 0, &amp;MUL, sizes, 0, _OUT); for (int i = 0; i &lt; NN; i++) cout&lt;&lt;_OUT[i]&lt;&lt;" "; cout&lt;&lt;endl; delete[] _OUT; delete[] sizes; return 0; }</span></span></span></span></code> </pre><br>  Now, I‚Äôll note that if PPPV / PPPV is considered as an elementary node of the computational topology (graph) and define constructions that allow one PPPV / PPPV to replenish the plan of another (neighboring in the section) PPPV / PPPV, then you can work with quite complex computational topologies, both in the case of shared and in the case of separate memory (for example, on a cluster - there the transfer of plan elements according to the graph will be performed using simple network transfer operations).  The operations of replenishing the plan for another PPPV / FPPV are called <b>throw_first (...)</b> and <b>throw_last (...)</b> .  Their parameters are determined by the call parameters of the respective host PPPV / FPPV.  If any PPPV / FPVV has only one neighbor-receiver in the topology (for example, in the pipeline), then the parameters are the most common.  If there are several receiver neighbors, then one of the parameters is made special - addressable.  All of the same name (corresponding to one PPPV / FPPV) nodes of the graph topology are numbered, therefore, in the address parameter the name of the receiving PPPV / FPPV is indicated, followed by its number in square brackets.  For the time being, it is proposed to describe topologies either statically (with special constructions for a vector / pipeline or lists of arcs for an arbitrary graph) or semi-statically ‚Äî when the list of arcs is generated by special (generating code) inserts ‚Äî macromodules (they can be written, for example, in a philosophy similar to PHP ‚Äî insertions generate fragment of the program text, you can use any language depending on the tasks, even though PHP, even GNU Prolog).  Technically, the possibility of the usual dynamic generation of topology using calls of certain functions is not excluded. <br><br>  For full-fledged work, channels / lazy variables, transactional memory, barriers, semaphores, etc. can always be used additionally. <br><br>  I will give a few examples with different topologies. <br><br>  <b>Calculation on the pipeline of the minimum and maximum elements of the tree.</b> <br><br><pre> <code class="cpp hljs">chain[ARR_SIZE] TreeMax(TreeNode * Cur, reduction(max) DataItem &amp; MaxResult) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DataItem DummyMin; throw_last(Cur,DummyMin); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Cur==Root) plan_group_parallelize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Cur-&gt;Left) plan_last(Cur-&gt;Left,MaxResult); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Cur-&gt;Right) plan_last(Cur-&gt;Right,MaxResult); MaxResult = Cur-&gt;Data; } chain[ARR_SIZE] TreeMin(TreeNode * Cur, reduction(min) DataItem &amp; MinResult) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Cur==Root) plan_group_parallelize; MinResult = Cur-&gt;Data; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TreeMinMax</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataItem &amp; Min, DataItem &amp; Max)</span></span></span><span class="hljs-function"> </span></span>{ Max.fill(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); Min.fill(<span class="hljs-number"><span class="hljs-number">1000.0</span></span>); plan_parallel_chain(<span class="hljs-number"><span class="hljs-number">0</span></span>,TreeMax(Root,Max),TreeMin(Root,Min)); }</code> </pre><br>  <b>The example with the ‚Äúneedle-to-eye‚Äù topology can be used to test the performance of a specific implementation</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; bool stop; chain A(bool init) throw(bool init, int N) { stop = false; throw_first(false, 1); Sleep(2000); stop = true; } chain B(bool init, int N) throw(bool init, bool _stop, int N) { if (!init) { if (stop) throw_first(false, true, N); else throw_first(false, false, N+1); } } chain C(bool init, bool _stop, int N) throw(bool init, int N) { if (!init) { if (_stop) { cout&lt;&lt;N; plan_topology_quit(); /*    */ } else throw_first(false, N+1); } } int main() { plan_topology { /*    */ plan_parallel_chain(A(true)-&gt;B(true,0)-&gt;C(true,false,0)); /*    */ plan_parallel_reverse(C(true,false,0)-&gt;B(true,0)); /*    */ }/3; return 0; }</span></span></span></span></code> </pre><br>  Everything described above is implemented as a C ++ extension (Planning C).  There is a simple demo translator that implements, in addition to the above, some more interesting things. </div><p>Source: <a href="https://habr.com/ru/post/336458/">https://habr.com/ru/post/336458/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336446/index.html">Aliases bash for Laravel</a></li>
<li><a href="../336448/index.html">Programming Contest: JSDash (Preliminary Results)</a></li>
<li><a href="../336450/index.html">September 6, QIWI will gather back-end developers at QIWI SERVER PARTY</a></li>
<li><a href="../336452/index.html">7 Tips for a UX Machine Learner</a></li>
<li><a href="../336456/index.html">The story of the apocalypse of Runet and Yashka, the heir of Yandex</a></li>
<li><a href="../336460/index.html">Talk about Virtual Reality. Conversation number 1. Really about Virtuality</a></li>
<li><a href="../336462/index.html">Dagger 2.11 & Android. Part 2</a></li>
<li><a href="../336464/index.html">Dealing with complexity in an application layer network protocol</a></li>
<li><a href="../336466/index.html">We check the browser for support of certain CSS properties</a></li>
<li><a href="../336468/index.html">Creating a programming language using LLVM. Part 7: Language Expansion: Variable Variables</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>