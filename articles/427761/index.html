<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The implementation of the algorithm k-means (k-average) on the example of working with pixels</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Recently, it was necessary to write code to implement image segmentation using the k-means method. Well, google first thing to help. I found a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The implementation of the algorithm k-means (k-average) on the example of working with pixels</h1><div class="post__text post__text-html js-mediator-article">  Hello!  Recently, it was necessary to write code to implement image segmentation using the k-means method.  Well, google first thing to help.  I found a lot of information, as well as from a mathematical point of view (all sorts of complex mathematical scribbles there, you will understand what the fuck is written there), and some software implementations that exist on the English Internet.  Of course, these codes are beautiful - no doubt, but the very essence of the idea is hard to catch.  Somehow it‚Äôs all complicated there, confusing, and as long as you don‚Äôt write the code with your hands, you don‚Äôt understand anything.  In this article I want to show a simple, not productive, but, I hope, understandable implementation of this wonderful algorithm.  Okay, drove! <br><a name="habracut"></a><br>  So what is clustering in terms of our perception?  I will give an example, for example, there is a cute image with flowers from your grandmother‚Äôs dacha. <br><br><img src="https://habrastorage.org/webt/o2/0j/p5/o20jp5rx4sfpjieou7ipk8mfika.jpeg"><br><br>  The question is: to determine how many areas of this photo are filled with approximately one color.  Well, it‚Äôs not at all difficult: white petals - once, yellow centers - two (I am not a biologist, as they are called, I don‚Äôt know), greenery - three.  These areas are called clusters.  Cluster - combining data with common characteristics (color, position, etc.).  The process of determining and placing each component of any data in such clusters - areas is called clustering. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are many clustering algorithms, but the simplest of them is k-means, which will be discussed further.  K-means is a simple and efficient algorithm that is easy to implement using a software method.  The data that we will distribute across clusters is pixels.  As you know, a color pixel has three components - red, green and blue.  The overlay of these components creates a palette of existing colors. <br><br><img src="https://habrastorage.org/webt/gf/5u/b1/gf5ub1f-9xv56o7b86jsozumzlw.jpeg"><br><br>  In the computer's memory, each component of a color is characterized by a number from 0 to 255. That is, by combining different values ‚Äã‚Äãof red, green and blue, we get a color palette on the screen. <br><br>  On the example of pixels, we implement our algorithm.  K-means is an iterative algorithm, that is, it will give the correct result, after a certain number of repetitions of some mathematical calculations. <br><br><h3>  Algorithm </h3><br><ol><li>  You need to know in advance how many clusters you need to distribute the data.  This is a significant disadvantage of this method, but this problem is solved by improved implementations of the algorithm, but this is said to be a completely different story. </li><li>  We need to choose the initial centers of our clusters.  How?  Yes, at random.  What for?  To be able to bind each pixel to the center of the cluster.  The center is like a King, around which his subjects are gathered - pixels.  It is the ‚Äúdistance‚Äù from the center to the pixel that determines who will obey each pixel. </li><li>  Calculate the distance from each center to each pixel.  This distance is considered as the Euclidean distance between points in space, and in our case - as the distance between the three color components: <p><math> </math> $$ display $$ \ sqrt {(R_ {2} -R_ {1}) ^ 2 + (G_ {2} -G_ {1}) ^ 2 + (B_ {2} -B_ {1}) ^ 2} . $$ display $$ </p>  We count the distance from the first pixel to each center and determine the smallest distance between this pixel and the centers.  For the center, the distance to which is the smallest, recalculate the coordinates, as the arithmetic average between each component of the pixel - the king and the pixel - the subject.  Our center is shifted in space, according to calculations. </li><li>  After recalculating all the centers, we distribute the pixels into clusters, comparing the distance from each pixel to the centers.  A pixel is placed in a cluster, to the center of which it is located closer than to the other centers. </li><li>  It all starts over again, as long as the pixels remain in the same clusters.  Often this may not happen, since with a large amount of data the centers will move in a small radius, and the pixels on the edges of the clusters will jump to one or another cluster.  To do this, determine the maximum number of iterations. </li></ol><br><h3>  Implementation </h3><br>  I will implement this project in C ++.  The first file is ‚Äúk_means.h‚Äù, in it I defined the main data types, constants, and the main class for work is ‚ÄúK_means‚Äù. <br>  To characterize each pixel, we will create a structure that consists of three pixel components, for which I chose the double type for more accurate calculations, and also defined some constants for the program to work: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> KK = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  const int max_iterations = 100; //   typedef struct { double r; double g; double b; } rgb;</span></span></code> </pre> <br>  The K_means class itself: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K_means</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; pixcel; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q_klaster; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k_pixcel; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; centr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identify_centers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rgb k1, rgb k2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.r - k2.r),<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.g - k2.g), <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.b - k2.b), <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute_s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: K_means() : q_klaster(<span class="hljs-number"><span class="hljs-number">0</span></span>), k_pixcel(<span class="hljs-number"><span class="hljs-number">0</span></span>) {}; K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb *mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster); K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clustering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream &amp; os)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ~K_means(); <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k); };</code> </pre><br>  Let's run through the class components: <br><br>  vectorpixcel - vector for pixels; <br>  q_klaster - the number of clusters; <br>  k_pixcel - the number of pixels; <br>  vectorcentr - vector for clustering centers, the number of elements in it is determined by q_klaster; <br>  identify_centers () is a method for randomly selecting initial centers among input pixels; <br>  compute () and compute_s () built-in methods for calculating the distance between pixels and recalculating centers, respectively; <br>  three constructors: the first by default, the second for initializing pixels from an array, the third for initializing pixels from a text file (in my implementation, first the file is randomly filled with data, and then pixels are read from this file for the program to work, why not directly into a vector just need in my case); <br>  clustering (std :: ostream &amp; os) - clustering method; <br>  method and operator output overload for publishing results. <br><br>  Implementation methods: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::identify_centers() { srand((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)time(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)); rgb temp; rgb *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> rgb[q_klaster]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { temp = pixcel[<span class="hljs-number"><span class="hljs-number">0</span></span> + rand() % k_pixcel]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = i; j &lt; q_klaster; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp.r != mas[j].r &amp;&amp; temp.g != mas[j].g &amp;&amp; temp.b != mas[j].b) { mas[j] = temp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { i--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { centr.push_back(mas[i]); } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> []mas; }</code> </pre><br>  This is a method for selecting initial clustering centers and adding them to the centers vector.  A check is made on the repetition of centers and their replacement in these cases. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb * mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { pixcel.push_back(*(mas + i)); } q_klaster = n_klaster; k_pixcel = n; identify_centers(); }</code> </pre><br>  Implement a constructor to initialize pixels from an array. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os) : q_klaster(n_klaster) { rgb temp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (os &gt;&gt; temp.r &amp;&amp; os &gt;&gt; temp.g &amp;&amp; os &gt;&gt; temp.b) { pixcel.push_back(temp); } k_pixcel = pixcel.size(); identify_centers(); }</code> </pre><br>  In this constructor, we pass an input object for the ability to enter data from both the file and the console. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::clustering(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n :"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*             :        ,    -  ,    ,   ,        .*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_1(k_pixcel, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_2(k_pixcel, <span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n----------------  ‚Ññ"</span></span> &lt;&lt; iter &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ----------------\n\n"</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*  :          .      ,   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[j], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*     m_k      .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"    #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"  #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span>; centr[m_k].r = compute_s(pixcel[j].r, centr[m_k].r); centr[m_k].g = compute_s(pixcel[j].g, centr[m_k].g); centr[m_k].b = compute_s(pixcel[j].b, centr[m_k].b); os &lt;&lt; centr[m_k].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mas; } <span class="hljs-comment"><span class="hljs-comment">/*   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *mass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[k_pixcel]; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n  : "</span></span>&lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; k_pixcel; k++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[k], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   ‚Ññ"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*  .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } mass[k] = m_k; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ‚Ññ"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"     #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*            .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n    : \n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k_pixcel; i++) { os &lt;&lt; mass[i] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; check_1[i] = *(mass + i); } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itr = KK + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mass[j] == i) { os &lt;&lt; pixcel[j].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; mass[j] = ++itr; } } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mass; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : \n"</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">/*         ‚Äì  .*/</span></span> iter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_1 == check_2 || iter &gt;= max_iterations) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } check_2 = check_1; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n ."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre>  The main clustering method. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.k_pixcel; i++) { os &lt;&lt; k.pixcel[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - ‚Ññ"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.q_klaster; i++) { os &lt;&lt; k.centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n : "</span></span> &lt;&lt; k.q_klaster &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; k.k_pixcel &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> os; }</code> </pre><br>  The output of the initial data. <br><br><h4>  Sample output </h4><br><div class="spoiler">  <b class="spoiler_title">Sample output</b> <div class="spoiler_text">  <em>Initial pixels:</em> <em><br></em>  <em>255 140 50 - ‚Ññ0</em> <em><br></em>  <em>100 70 1 - ‚Ññ1</em> <em><br></em>  <em>150 20 200 - ‚Ññ2</em> <em><br></em>  <em>251 141 51 - ‚Ññ 3</em> <em><br></em>  <em>104 69 3 - ‚Ññ4</em> <em><br></em>  <em>153 22 210 - ‚Ññ5</em> <em><br></em>  <em>252 138 54 - ‚Ññ 6</em> <em><br></em>  <em>101 74 4 - ‚Ññ7</em> <em><br><br></em>  <em>Random initial clustering centers:</em> <em><br></em>  <em>150 20 200 - # 0</em> <em><br></em>  <em>104 69 3 - # 1</em> <em><br></em>  <em>100 70 1 - # 2</em> <em><br><br></em>  <em>Number of clusters: 3</em> <em><br></em>  <em>Number of pixels: 8</em> <em><br><br></em>  <em>Start of clustering:</em> <em><br><br></em>  <em>Iteration # 0</em> <em><br><br></em>  <em>Distance from pixel 0 to center # 0: 218.918</em> <em><br></em>  <em>Distance from pixel 0 to center # 1: 173.352</em> <em><br></em>  <em>Pixel Distance 0 to Center # 2: 176.992</em> <em><br></em>  <em>Minimum distance to center # 1</em> <em><br></em>  <em>We recount the center # 1: 179.5 104.5 26.5</em> <em><br></em>  <em>Distance from pixel 1 to center # 0: 211.189</em> <em><br></em>  <em>The distance from pixel 1 to the center # 1: 90.3369</em> <em><br></em>  <em>Distance from pixel 1 to center # 2: 0</em> <em><br></em>  <em>Minimum distance to center # 2</em> <em><br></em>  <em>We recount the center # 2: 100 70 1</em> <em><br></em>  <em>Distance from pixel 2 to the center # 0: 0</em> <em><br></em>  <em>Distance from pixel 2 to the center # 1: 195.225</em> <em><br></em>  <em>Distance from pixel 2 to the center # 2: 211.189</em> <em><br></em>  <em>Minimum distance to center # 0</em> <em><br></em>  <em>We recount the center # 0: 150 20 200</em> <em><br></em>  <em>Distance from pixel 3 to the center # 0: 216.894</em> <em><br></em>  <em>Distance from pixel 3 to the center. # 1: 83.933</em> <em><br></em>  <em>Distance from pixel 3 to the center # 2: 174.19</em> <em><br></em>  <em>Minimum distance to center # 1</em> <em><br></em>  <em>We recount the center # 1: 215.25 122.75 38.75</em> <em><br></em>  <em>Distance from pixel 4 to center # 0: 208.149</em> <em><br></em>  <em>The distance from pixel 4 to the center # 1: 128.622</em> <em><br></em>  <em>Pixel distance 4 to center # 2: 4.58258</em> <em><br></em>  <em>Minimum distance to center # 2</em> <em><br></em>  <em>We recount the center # 2: 102 69.5 2</em> <em><br></em>  <em>Distance from pixel 5 to the center # 0: 10.6301</em> <em><br></em>  <em>Distance from pixel 5 to the center # 1: 208.212</em> <em><br></em>  <em>Distance from pixel 5 to the center # 2: 219.366</em> <em><br></em>  <em>Minimum distance to center # 0</em> <em><br></em>  <em>We recount the center # 0: 151.5 21 205</em> <em><br></em>  <em>Distance from pixel 6 to center # 0: 215.848</em> <em><br></em>  <em>Distance from pixel 6 to the center # 1: 42.6109</em> <em><br></em>  <em>Distance from pixel 6 to the center. # 2: 172.905</em> <em><br></em>  <em>Minimum distance to center # 1</em> <em><br></em>  <em>We recount the center # 1: 233.625 130.375 46.375</em> <em><br></em>  <em>Distance from pixel 7 to center # 0: 213.916</em> <em><br></em>  <em>Distance from pixel 7 to center # 1: 150.21</em> <em><br></em>  <em>Distance from pixel 7 to center # 2: 5.02494</em> <em><br></em>  <em>Minimum distance to center # 2</em> <em><br></em>  <em>We recount center # 2: 101.5 71.75 3</em> <em><br><br></em>  <em>Perform pixel classification:</em> <em><br></em>  <em>Distance from pixel number 0 to the center # 0: 221.129</em> <em><br></em>  <em>Distance from pixel # 0 to center # 1: 23.7207</em> <em><br></em>  <em>Distance from pixel # 0 to center # 2: 174.44</em> <em><br></em>  <em>Pixel number 0 closest to the center # 1</em> <em><br></em>  <em>Distance from pixel number 1 to the center # 0: 216.031</em> <em><br></em>  <em>Distance from pixel number 1 to the center # 1: 153.492</em> <em><br></em>  <em>Distance from pixel number 1 to the center # 2: 3.05164</em> <em><br></em>  <em>Pixel number 1 closest to the center # 2</em> <em><br></em>  <em>Distance from pixel number 2 to the center # 0: 5.31507</em> <em><br></em>  <em>Distance from pixel number 2 to the center # 1: 206.825</em> <em><br></em>  <em>Distance from pixel number 2 to the center # 2: 209.378</em> <em><br></em>  <em>Pixel number 2 closest to the center # 0</em> <em><br></em>  <em>Distance from pixel number 3 to the center # 0: 219.126</em> <em><br></em>  <em>Distance from pixel number 3 to the center # 1: 20.8847</em> <em><br></em>  <em>Distance from pixel number 3 to the center # 2: 171.609</em> <em><br></em>  <em>Pixel number 3 closest to the center # 1</em> <em><br></em>  <em>Distance from pixel number 4 to the center # 0: 212.989</em> <em><br></em>  <em>Distance from pixel number 4 to the center # 1: 149.836</em> <em><br></em>  <em>Distance from pixel number 4 to the center # 2: 3.71652</em> <em><br></em>  <em>Pixel number 4 closest to the center # 2</em> <em><br></em>  <em>Distance from pixel number 5 to the center # 0: 5.31507</em> <em><br></em>  <em>Distance from pixel number 5 to the center # 1: 212.176</em> <em><br></em>  <em>Distance from pixel number 5 to the center # 2: 219.035</em> <em><br></em>  <em>Pixel number 5 closest to the center # 0</em> <em><br></em>  <em>Distance from pixel number 6 to the center # 0: 215.848</em> <em><br></em>  <em>Distance from pixel number 6 to the center # 1: 21.3054</em> <em><br></em>  <em>Distance from pixel number 6 to the center # 2: 172.164</em> <em><br></em>  <em>Pixel number 6 closest to the center # 1</em> <em><br></em>  <em>Distance from pixel number 7 to the center # 0: 213.916</em> <em><br></em>  <em>Distance from pixel number 7 to the center # 1: 150.21</em> <em><br></em>  <em>Distance from pixel number 7 to the center # 2: 2.51247</em> <em><br></em>  <em>Pixel number 7 closest to the center # 2</em> <em><br><br></em>  <em>Array of matching pixels and centers:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>Clustering result:</em> <em><br></em>  <em>Cluster # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Cluster # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Cluster # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>New centers:</em> <em><br></em>  <em>151.5 21 205 - # 0</em> <em><br></em>  <em>233.625 130.375 46.375 - # 1</em> <em><br></em>  <em>101.5 71.75 3 - # 2</em> <em><br><br></em>  <em>Iteration # 1</em> <em><br><br></em>  <em>Distance from pixel 0 to center # 0: 221.129</em> <em><br></em>  <em>Distance from pixel 0 to center # 1: 23.7207</em> <em><br></em>  <em>Distance from pixel 0 to center # 2: 174.44</em> <em><br></em>  <em>Minimum distance to center # 1</em> <em><br></em>  <em>We recount the center # 1: 244.313 135.188 48.1875</em> <em><br></em>  <em>Distance from pixel 1 to center # 0: 216.031</em> <em><br></em>  <em>The distance from pixel 1 to the center # 1: 165.234</em> <em><br></em>  <em>Distance from pixel 1 to the center # 2: 3.05164</em> <em><br></em>  <em>Minimum distance to center # 2</em> <em><br></em>  <em>We recount the center # 2: 100.75 70.875 2</em> <em><br></em>  <em>The distance from pixel 2 to the center # 0: 5.31507</em> <em><br></em>  <em>The distance from pixel 2 to the center # 1: 212.627</em> <em><br></em>  <em>The distance from pixel 2 to the center # 2: 210.28</em> <em><br></em>  <em>Minimum distance to center # 0</em> <em><br></em>  <em>We recount the center # 0: 150.75 20.5 202.5</em> <em><br></em>  <em>Distance from pixel 3 to center # 0: 217.997</em> <em><br></em>  <em>Distance from pixel 3 to the center. # 1: 9.29613</em> <em><br></em>  <em>Distance from pixel 3 to the center. # 2: 172.898</em> <em><br></em>  <em>Minimum distance to center # 1</em> <em><br></em>  <em>We recount the center # 1: 247.656 138.094 49.5938</em> <em><br></em>  <em>The distance from pixel 4 to the center # 0: 210.566</em> <em><br></em>  <em>Distance from pixel 4 to center # 1: 166.078</em> <em><br></em>  <em>Distance from pixel 4 to the center. # 2: 3.88306</em> <em><br></em>  <em>Minimum distance to center # 2</em> <em><br></em>  <em>We recount the center # 2: 102.375 69.9375 2.5</em> <em><br></em>  <em>Distance from pixel 5 to the center # 0: 7.97261</em> <em><br></em>  <em>Distance from pixel 5 to the center # 1: 219.471</em> <em><br></em>  <em>Distance from pixel 5 to the center. # 2: 218.9</em> <em><br></em>  <em>Minimum distance to center # 0</em> <em><br></em>  <em>We recount the center # 0: 151.875 21.25 206.25</em> <em><br></em>  <em>Distance from pixel 6 to center # 0: 216.415</em> <em><br></em>  <em>Distance from pixel 6 to the center # 1: 6.18805</em> <em><br></em>  <em>The distance from pixel 6 to the center # 2: 172.257</em> <em><br></em>  <em>Minimum distance to center # 1</em> <em><br></em>  <em>We recount the center # 1: 249.828 138.047 51.7969</em> <em><br></em>  <em>Distance from pixel 7 to center # 0: 215.118</em> <em><br></em>  <em>Distance from pixel 7 to the center. # 1: 168.927</em> <em><br></em>  <em>Distance from pixel 7 to the center. # 2: 4.54363</em> <em><br></em>  <em>Minimum distance to center # 2</em> <em><br></em>  <em>We recount the center # 2: 101.688 71.9688 3.25</em> <em><br><br></em>  <em>Perform pixel classification:</em> <em><br></em>  <em>Distance from pixel # 0 to center # 0: 221.699</em> <em><br></em>  <em>Distance from pixel number 0 to the center # 1: 5.81307</em> <em><br></em>  <em>Distance from pixel # 0 to center # 2: 174.122</em> <em><br></em>  <em>Pixel number 0 closest to the center # 1</em> <em><br></em>  <em>Distance from pixel number 1 to the center # 0: 217.244</em> <em><br></em>  <em>Distance from pixel number 1 to the center # 1: 172.218</em> <em><br></em>  <em>Distance from pixel number 1 to the center # 2: 3.43309</em> <em><br></em>  <em>Pixel number 1 closest to the center # 2</em> <em><br></em>  <em>Distance from pixel number 2 to the center # 0: 6.64384</em> <em><br></em>  <em>Distance from pixel number 2 to the center # 1: 214.161</em> <em><br></em>  <em>Distance from pixel number 2 to the center # 2: 209.154</em> <em><br></em>  <em>Pixel number 2 closest to the center # 0</em> <em><br></em>  <em>Distance from pixel number 3 to the center # 0: 219.701</em> <em><br></em>  <em>Distance from pixel number 3 to the center # 1: 3.27555</em> <em><br></em>  <em>Distance from pixel number 3 to the center # 2: 171.288</em> <em><br></em>  <em>Pixel number 3 closest to the center # 1</em> <em><br></em>  <em>Distance from pixel number 4 to the center # 0: 214.202</em> <em><br></em>  <em>Distance from pixel number 4 to the center # 1: 168.566</em> <em><br></em>  <em>Distance from pixel number 4 to the center # 2: 3.77142</em> <em><br></em>  <em>Pixel number 4 closest to the center # 2</em> <em><br></em>  <em>Distance from pixel number 5 to the center # 0: 3.9863</em> <em><br></em>  <em>Distance from pixel number 5 to the center # 1: 218.794</em> <em><br></em>  <em>Distance from pixel number 5 to the center # 2: 218.805</em> <em><br></em>  <em>Pixel number 5 closest to the center # 0</em> <em><br></em>  <em>Distance from pixel number 6 to the center # 0: 216.415</em> <em><br></em>  <em>Distance from pixel number 6 to the center # 1: 3.09403</em> <em><br></em>  <em>Distance from pixel number 6 to the center # 2: 171.842</em> <em><br></em>  <em>Pixel number 6 closest to the center # 1</em> <em><br></em>  <em>Distance from pixel number 7 to the center # 0: 215.118</em> <em><br></em>  <em>Distance from pixel number 7 to the center # 1: 168.927</em> <em><br></em>  <em>Distance from pixel number 7 to the center # 2: 2.27181</em> <em><br></em>  <em>Pixel number 7 closest to the center # 2</em> <em><br><br></em>  <em>Array of matching pixels and centers:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>Clustering result:</em> <em><br></em>  <em>Cluster # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Cluster # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Cluster # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>New centers:</em> <em><br></em>  <em>151.875 21.25 206.25 - # 0</em> <em><br></em>  <em>249.828 138.047 51.7969 - # 1</em> <em><br></em>  <em>101.688 71.9688 3.25 - # 2</em> <em><br><br></em>  <em>End of clustering.</em> <br></div></div><br>  This example is planned in advance, the pixels are selected specifically for demonstration.  The program needs two iterations to group the data into three clusters.  Looking at the centers of the last two iterations, you can see that they almost stayed in place. <br><br>  More interesting cases with random pixel generation.  Having generated 50 points that need to be divided into 10 clusters, I got 5 iterations.  Having generated 50 points that need to be divided into 3 clusters, I got all 100 maximum allowed iterations.  You can see that the more clusters, the easier it is for the program to find the most similar pixels and combine them into smaller groups, and vice versa - if there are few clusters and many points, the algorithm often ends only by exceeding the maximum allowed number of iterations, since some pixels constantly jump from one cluster to another.  Nevertheless, the bulk is still defined in their clusters finally. <br><br>  Well, now let's check the result of clustering.  Taking the result of some clusters from the example of 50 points on 10 clusters, I hammered the result of this data into Illustrator and this is what happened: <br><br><img src="https://habrastorage.org/webt/b2/fl/me/b2flmelfv6bqxeautb8s4ywwstm.jpeg"><br><br>  It can be seen that in each cluster any shades of color prevail, and here you need to understand that the pixels were chosen randomly; an analogue of such an image in real life is some kind of picture that was randomly sprinkled with all colors and it is difficult to isolate areas of similar colors. <br><br>  Suppose we have such a photo.  We can define an island as one cluster, but with an increase we see that it consists of different shades of green. <br><br><img src="https://habrastorage.org/webt/s8/qv/um/s8qvumchfqerkbdfo5gx7ijm4to.jpeg"><br><br>  And this is the 8th cluster, but in a smaller version, the result is similar: <br><br><img src="https://habrastorage.org/webt/dt/ia/eb/dtiaebsnf1uzpi69jqmbkvui5uo.jpeg"><br><br>  The full version of the program can be viewed on my <a href="https://github.com/dankor1498/K_means">GitHub</a> . </div><p>Source: <a href="https://habr.com/ru/post/427761/">https://habr.com/ru/post/427761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427749/index.html">Apple and Samsung for the first time fined slowing down old phones</a></li>
<li><a href="../427751/index.html">Ideas for Sublime by CudaText</a></li>
<li><a href="../427755/index.html">New release of GitLab 11.4 with review of merge requests and checkboxes of functions</a></li>
<li><a href="../427757/index.html">Backdoors in x86 assembly instructions microcode</a></li>
<li><a href="../427759/index.html">Solvability beltway problems in polynomial time</a></li>
<li><a href="../427763/index.html">MIT course "Computer Systems Security". Lecture 13: "Network Protocols", part 1</a></li>
<li><a href="../427767/index.html">Situation: Canada offered to introduce a streaming stream - we are discussing what the problem is</a></li>
<li><a href="../427771/index.html">MIT course "Computer Systems Security". Lecture 13: "Network Protocols", part 2</a></li>
<li><a href="../427773/index.html">I wrote a cross-browser tab extension, but don't do that.</a></li>
<li><a href="../427775/index.html">Disguised as a programmer bot corrects errors in the code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>