<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust and Swift (third, fourth, fifth and sixth parts)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue to translate a cycle in which the author simultaneously studies Rust and Swift and compares them to each other. You can find the translatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust and Swift (third, fourth, fifth and sixth parts)</h1><div class="post__text post__text-html js-mediator-article"><p>  I continue to translate a cycle in which the author simultaneously studies Rust and Swift and compares them to each other.  You can find the translation of the introduction and the first two parts <a href="https://habrahabr.ru/post/280274/">here</a> .  In this part we will talk about operator overloading, string manipulations and collections. <br><br></p><a name="habracut"></a><br><h4>  Operators, their overload and thoughts of brevity </h4><br><p>  I just got to the operators in Swift.  First question: are the operators a special syntax or is it just sugar for protocols?  Every modern language I use or have ever played with (Python, Ruby, Io, Elixir, and Rust are some examples from a wide variety of eras and styles) implements them simply as sugar for other language constructs. <br><br>  Picked up, I found out that the operators are functions (ok), given <del>  global space </del>  Swift module.  I say ‚Äúokay‚Äù instead of ‚Äúgood‚Äù, because the explanation is this: this is the only way to make the operators work as binary operators between existing types.  It misses the fact that in this case the reason lies in the structure of the language.  It seems that the protocols would fit perfectly here, but perhaps they, unlike the traits of Rust, are not able to cope with the problem to the full?  This is an open-ended question, and I have no idea how to answer it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Interestingly, Rust has a slightly smaller number of operators than Swift, even if not considered as mentioned in my previous post.  In Rust, as in Python, the prefix and postfix operators are completely absent, because the same results can be obtained in other simpler ways.  In Swift, these operators are partially saved, no doubt because most programmers who dealt with (Objective) C are well acquainted with them and their idioms. <br>  <em>Translator‚Äôs note: in Swift 2.2, the increment / decrement operators were removed, which were not originally in Rust.</em>  <em>Swift, on the other hand, allows you to create your own operators.</em> <br><br>  I also learned something new about operators in Rust: boolean operators <code>||</code>  and <code>&amp;&amp;</code> differ from bit <code>|</code>  and <code>&amp;</code> operators not only because the first group implements calculations according to a short scheme.  Of course, using the second group, you can perform bit operations, but the reference book emphasizes the difference in terms of the computation scheme.  This is quite justified, but I had never thought about it before. <br>  <em>Translator‚Äôs note: to be honest, I didn‚Äôt understand what the author wanted to say.</em> <br><br>  There is no ternary operator in Rust, which is related to the way the language works with expressions and statements.  In Swift, he is.  An interesting idea about the difference in linguistic design: Rust got rid of this operator, since the blocks of the <code>if</code> operator are expressions and, thus, it is redundant, and the creators of the language sought to remove unnecessary features.  (A discussion about abandoning the ternary operator and an interesting remark about JavaScript from Brendan Ike read <a href="https://github.com/rust-lang/rust/issues/1698">here</a> ).  I will make a reservation that this is not a criticism towards Swift, but simply a comment, although I really like the Rust approach using expressions. <br><br>  On the other hand, I really do not like the operator <code>??</code>  (nil coalescing operator).  It looks like a contraction for the sake of contraction, partly due to Swift's desire for brevity of optional types.  Sometimes brevity leads to a loss of clarity.  Excessive cuts complicate the language and force slowing down when reading each line. <br><br>  Boolean operators in the languages ‚Äã‚Äãbeing compared are no different and not surprising. <br><br>  I wonder how many times the word ‚Äúshort‚Äù or its synonym is used in the book about Swift?  I understand more and more clearly that brevity is one of the main goals of this language.  Maybe I just think so, but it's still a bit strange.  Brevity is good, but readability is much better. <br><br></p><br><h4>  Compromises in the structure of the language on the example of working with strings </h4><br><p>  Both Swift and Rust solve the problem of security and memory management, although they approach it differently: Swift through automatic reference counting, and Rust through the concept of ownership.  For everyday work, the Swift approach seems more advantageous to me for the same reason as Python or Ruby: <em>it's nice</em> when they do everything for you.  Rust gives a lot of opportunities, but at the same time makes you constantly think about ownership. <br><br>  In other words, there are trade-offs in all languages.  Although so far I like Rust more than Swift, I will no doubt find many points on which Swift will be better.  You can't get everything. <br><br>  I drew attention to this in part because Swift works with strings (or other types that are passed by value) much easier than in Rust.  The results are almost the same, but since in Swift all the lines are passed by value and never by reference, you just do not have to think that they will be modified. <br><br>  Of course, for this purpose in Rust there is a treyt Copy - I mean that Swift is a bit ‚Äúergonomic‚Äù. <br><br>  Interpolation of lines in Swift is very <em>convenient</em> .  This is the only thing I miss in Rust.  Its Python-style macro for formatting strings is good, but interpolating values ‚Äã‚Äã( <code>strings with \(variables)</code> or even <code>embedded expressions like \(2 + 4)</code> ) is just fine. <br><br>  In general, the Swift approach to strings is well thought out and pays due attention to detail, which greatly facilitates working with complex or "non-Western" languages.  I, as crazy about typography, really appreciate it. <br><br>  Moreover, since Swift strings handle all such boundary cases for Unicode, several standard string access patterns are lost, which makes it difficult (or makes it impossible?) To understand the internal structure of the string.  Depending on the circumstances, this can be both an advantage and a disadvantage.  As I said: compromises everywhere. <br><br>  In fact, as I read further, I realized that Swift handles Unicode strings quite elegantly and provides insight into the process, using separate methods for different implementations.  In particular, I appreciate that you can both work with the type <code>String</code> , and get direct access to the "code points" - and not to any one, but to any of UTF8, UTF16 or UTF32.  Trust Apple's experience: the text must be treated very carefully. <br><br>  The lines in Rust are not bad, but less intricate (presumably, this is done for the sake of simplifying their representation in memory).  In this language, a <code>String</code> or <code>str</code> always consists of Unicode scalar values ‚Äã‚Äã(UTF32) encoded as a sequence of UTF8 bytes.  In it, unlike Swift, there are no convenient methods for obtaining other implementations.  At the same time, I believe that in everyday programming this will rarely appear, and perhaps never at all.  It is important that both languages ‚Äã‚Äãstore scalar values. <br><br>  This is the first part in which I did not feel the obvious superiority of Rust over Swift.  Some of the compromises in the structure of these languages ‚Äã‚Äãare more pronounced here, and I appreciate that Swift's ‚Äúergonomics‚Äù are among them. <br><br></p><br><h4>  Advantages (and difficulties) of parallel language learning </h4><br><p>  I study Swift for a couple of weeks, and before that, for a month, I plunged into the depths of Rust.  Such an approach ‚Äî mastering two languages ‚Äã‚Äãalmost simultaneously ‚Äî is completely new to me, and there are good reasons for that.  It is not easy to learn a programming language, and in order to comprehend new knowledge, it is necessary to work a lot with it. <br><br>  I do it out of necessity.  I hope that I can develop an application on a very functional and effective cross-platform database of the Rust language, but I plan to release a native application for OS X only when everything is polished.  My desire to make the core of the application portable immediately excludes the use of Swift.  Honestly, this is facilitated by the fact that this is the language of Apple: I‚Äôm happy to use Apple‚Äôs tools on their platform, but I don‚Äôt want to constantly depend on the decisions of this company.  In addition, the experience in Rust can be useful in many other cases. <br><br>  So, I need to learn both languages. <br><br>  And although in a normal situation I would not recommend - and if you do not have sufficient experience in programming and knowledge of several languages, even frankly discourage you from using such a method - it seems to me that it is incredibly useful.  These languages ‚Äã‚Äãwere created at about the same time and drew inspiration from the same sources, their audience and goals partly coincide.  At the same time, as already shown in this cycle, in many respects they are quite different. <br><br>  The parallel study of two languages ‚Äã‚Äãhelped me to see which compromises each of them made, made me think about what caused their differences.  In particular, I think that now I understand better what is happening ‚Äúbehind the scenes‚Äù of these languages ‚Äã‚Äãand, I know, what to expect from them.  This, in turn, significantly influenced the speed of learning a language.  Of course, the fact that I know several languages ‚Äã‚Äãhas also played a role here, and recently I have been actively expanding my horizons: I read about Haskell, functional patterns in JavaScript, etc. <br><br>  Of course, in both languages ‚Äã‚ÄãI still have a long way to go.  Reading at night and on weekends and playing a little with each of them is not the same as holding your teeth into a project and looking for pain points.  Nevertheless, I am really glad that I study these languages ‚Äã‚Äãat the same time.  If you are ready to accept the challenge, you can also try.  You will be surprised how much you can learn. <br><br></p><br><h4>  Types of collections and the difference between syntax and semantics </h4><br><p>  I think the following sentence in many ways characterizes the Swift language design: </p><br><blockquote>  Although the two forms are identical from a functional point of view, a shorter form is preferred and is used in this manual with reference to the type of data set.  ‚ÄîThe Swift Programming Language (Swift 2 Prerelease) </blockquote><br><p>  The documentation for the various types in the Rust <code>std::collections</code> module is interesting and useful.  Highly recommend. <br><br>  While reading this chapter in the Swift tutorial, I noticed one thing: there are no named parameters in Rust, and there are some in Swift.  In both cases, this decision is justified, but it seems to me that this is one of the details that I would not most brag about in Rust.  Python spoiled me. <br>  Translator's Note: There is an <a href="https://github.com/rust-lang/rfcs/issues/323">RFC</a> for adding named parameters to Rust. <br><br>  The <code>Array</code> type in Swift is similar to the <code>Vec</code> type in Rust (which is usually created by the vec macro!).  Both containers can dynamically resize and store items on a heap, while arrays in Rust have a static size and are created on the stack.  The syntax for creating arrays in both languages ‚Äã‚Äãis very similar (although the result is different): </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> an_array: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">//    var an_array = [1, 2, 3] //   </span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> an_array: [<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//  let a_vector: Vec&lt;i32&gt; = vec![1, 2, 3]; // </span></span></code> </pre> <br><p>  This can be written shorter, since both languages ‚Äã‚Äãcan infer types, so you rarely have to write that way.  A more familiar option would be as follows: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> an_array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> an_array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> an_array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a_vector = <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p>  Rust also adds the concept of "slices", which provide access to parts of an array and represent a pointer to an array and size (number of elements). <br><br>  Operations with arrays in Swift are quite logical and surprisingly vivid.  In a good way, they remind me of list operations in Python. <br><br>  The Vec container in Rust has a rich API, and that's not bad.  I was a little surprised by the lack of a method for traversing elements, but then I discovered that it is present in the IntoIter structure in the same module for which the treater is implemented.  As a result, the corresponding method returns an instance of the <code>Enumerate</code> structure.  (I suspect that under the hood, the arrays in Swift simply implement the <code>Iterable</code> protocol, which in some way resembles the Rust approach.) <br><br>  This is an example of what I often say: Rust does not necessarily place everything in one object, but rather spreads the functionality across several related structures, associations, or traits.  This is a really powerful approach, but it does require some habit.  In this respect, Swift‚Äôs structures and semantics are much more similar to the languages ‚Äã‚ÄãI‚Äôm more used to, although the use of protocols gives more flexibility. <br><br>  Notice that I was talking about semantics, not syntax.  Swift and Rust are a great example of how very similar syntax can hide differences in semantics.  Another example: compare the syntax and semantics of JavaScript and Java - at first glance, they are syntactically similar, but nevertheless there is a gigantic abyss between their semantics. <br><br>  Both <code>Set</code> in Swift and its crude analogue of <code>HashSet</code> in Rust have a <code>contains</code> method that is very similar to the in keyword in Python.  There is nothing surprising in the fact that both types implement many similar methods.  This was probably to be expected, given the fact that the sets are a standard mathematical concept. <br><br>  Due to more strict typing, both Rust and Swift require specifying the types used in associative arrays ( <code>HashMap</code> in Rust and <code>Dictionary</code> in Swift), although, of course, both languages ‚Äã‚Äãcan infer types in certain cases.  You cannot mix the use of different types of keys as allowed in Python, but in practice this should not interfere with you for two reasons: </p><br><ol><li>  As a rule, it is not recommended to use keys of different types.  As for me, this often indicates that you should think more carefully about the types and data structures used. </li><li>  I wonder if it is possible in rare cases, when appropriate, to use the generic type in Rust or Swift.  I plan to clarify this issue later! </li></ol><br><p>  It would be great if Swift used a Python-like syntax ( <code>{'': ''}</code> ) to initialize the associative arrays.  However, I understand why this is impossible: curly brackets are already used for blocks, and in Python there is no such problem, since it uses indents.  But it is really convenient. <br><br>  I understand why Swift designers used brackets to initialize sequences ( <code>[...]</code> ): this greatly simplifies parsing.  As a result, at first glance it is difficult to understand what you are dealing with.  This can be an array, a set, or an associative array. <br><br>  This underlines the underestimated aspect of the design of programming languages ‚Äã‚Äã- readability.  As if we, programmers, did not like writing code, in reality we spend a lot, probably most of the time, on reading it.  Thus, although it is necessary to pay attention to the convenience of writing, it is also worth considering the ease of reading the code.  The syntax and conventions adopted in the language form a large part of this. <br><br>  The type of <code>Dictionary</code> in Swift is very similar to its counterpart in Python, up to the coincidence of the names of several methods.  This is true for <code>HashMap</code> in Rust.  This is not at all bad. <br><br></p><br><h4>  Afterword from the translator </h4><br><p>  I begin to doubt that taking on the translation of this series of articles was a good idea.  The author has interesting thoughts that pushed me to learn more about Swift.  On the other hand, he has too many superficial judgments, and he has to look for information himself.  If I supplement the translation with my own notes, as I periodically try to do, they will have to be written on almost every item.  The result is not a translation, but the devil knows what.  So, I‚Äôll probably dwell on these parts. </p></div><p>Source: <a href="https://habr.com/ru/post/280902/">https://habr.com/ru/post/280902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280892/index.html">How we scored on asynchrony when hiking on backends</a></li>
<li><a href="../280894/index.html">Wi-Fi module WF121 and HTTP server in addition</a></li>
<li><a href="../280896/index.html">Personal data of 50 million Turkish citizens leaked to the network</a></li>
<li><a href="../280898/index.html">Debugging Office Add-ins on iOS (iPad)</a></li>
<li><a href="../280900/index.html">RUVDS introduces new Huawei FusionSphere OpenStack virtualization systems</a></li>
<li><a href="../280904/index.html">man! (C => D => Rust)</a></li>
<li><a href="../280906/index.html">5th International Mobile Conference MBLT16 in a month</a></li>
<li><a href="../280908/index.html">Guiding Eyes transfers data to the IBM Cloud to improve the quality of care for blind people.</a></li>
<li><a href="../280910/index.html">Vulnerabilities in MyChat by NetworkSoftwareSolutions (fixed and none)</a></li>
<li><a href="../280912/index.html">PostgreSQL useful tricks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>