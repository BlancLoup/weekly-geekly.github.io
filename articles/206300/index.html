<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Actor Models 40 years</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="High-load systems built on the model of actors is a trend of the present time. Here is a far from complete list of articles on Habr√©, in which, to one...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Actor Models 40 years</h1><div class="post__text post__text-html js-mediator-article">  High-load systems built on the model of actors is a trend of the present time.  Here is a far from complete list of articles on Habr√©, in which, to one degree or another, this model or one of its implementations is mentioned, for example, <a href="http://habrahabr.ru/post/128772/">1</a> , <a href="http://habrahabr.ru/post/195562/">2</a> , <a href="http://habrahabr.ru/post/125717/">3</a> , <a href="http://habrahabr.ru/post/127696/">3</a> , <a href="http://habrahabr.ru/post/191916/">4</a> , <a href="http://habrahabr.ru/post/50561/">5</a> , <a href="http://habrahabr.ru/post/140368/">6</a> , <a href="http://habrahabr.ru/post/200338/">7</a> .  There is a good <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B2">Wikipedia</a> article telling about actors.  Unfortunately, after reading it, I still have a lot of questions, the answers to which I could find only in the original sources.  I want to present the results of this review to your attention. <br><a name="habracut"></a><br><h4>  What is the model of actors? </h4><br>  Are actors a set of practices, a development methodology, an architectural pattern, a marketing move? <br><br>  In my university course, like many, the concept of computability was defined through the Turing and Post machines.  The machine has a state - a set of values ‚Äã‚Äãof all the cells of the tape.  The calculation process is a sequence of machine steps, each of which changes its state.  Each step of the machine is the execution of one atomic indivisible action (operation).  Further I will call it the traditional model of computing. <br><br>  This interpretation of calculations leads to the concept of global time, when one and only one atomic operation can be performed at the same time.  This property is essentially used to prove the properties of various synchronization primitives in the case of multi-threaded programming on single-processor machines, for example, in the book <a href="http://www.cs.arizona.edu/~greg/">Gregory R. Andrews</a> <a href="http://www.cs.arizona.edu/~greg/mpdbook/">Basics of multi-threaded, parallel and distributed programming</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For multiprocessor machines or distributed systems, the requirement of global time is generally unacceptable.  Therefore, it is necessary to generalize the concept of computability to the case of parallel computations.  One of such generalizations is the model of actors. <br><br><h4>  How did it all begin? </h4><br>  The appearance of this model in the distant 70s was due to the strong belief that the next generation machines will be multiprocessing, and the programs will have artificial intelligence.  In 1973, <a href="http://carlhewitt.info/">Carl Hewitt</a> , Peter Bishop and Richard Steiger published an article: <a href="http://worrydream.com/refs/Hewitt-ActorModel.pdf">A Universal Modular Formalism For Artificial Intelligent</a> .  In this article, they introduced the concept of actor and explained that many classes of applications are a special case of the model of actors.  By the way, this year was the 40th anniversary! <br><br>  Actor is a universal abstraction of a computational entity, which, in response to a received message <br><ol><li>  Can send a finite number of messages to other actors, </li><li>  Create a finite number of actors </li><li>  Select a behavior to receive the next message. </li></ol><br><br><h4>  What are the fundamentally different actors from the traditional model of computing? </h4><br>  The difference between them is the same as between a telephone and sending a message by mail.  In the first case (this is a calculation based on global time), if several people try to call one phone number, then they begin to compete for access to the common shared resource - the addressee.  Office PBXs, multichannel phones, software for call-centers - all this (a la synchronization primitives) is needed in order to ensure efficient processing of incoming calls.  In the case of mailing, the sender of the letter (actor) simply sends the letter to the addressee without any delay due to the need to coordinate their actions with other senders.  But!  However, we do not know when the recipient will read our letter. <br><br><h4>  Who develops the theory of actors? </h4><br>  The two biggest specialists are Carl Hewitt and his student <a href="http://cs.illinois.edu/directory/profile/agha">Gul A. Agha</a> .  Hewitt mainly deals with the rigorous rationale that other approaches to computability are a special case of the actor model, and Agha is a different application for distributed systems. <br><br><h4>  Key results </h4><br>  Each of the results in itself is a topic for a separate large article, so I will only give a summary and a link to the source. <br><br>  Events in the model of actors form a partially ordered set.  The axiomatics of this set called Ordering Laws was described by Carl Hewitt and <a href="http://en.wikipedia.org/wiki/Henry_Baker_(computer_scientist)">Henry Baker</a> in the article <a href="http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-194.pdf">Actors and Continous Functionals</a> (1977).  There are a lot of axioms, and their point is to prove that the model of actors is suitable for use in practice, for example, that at any given time the number of messages addressed to one recipient is, of course. <br><br>  In 1985, Gul A. Agha, under the leadership of Hewitt, defended his thesis on <a href="https://dspace.mit.edu/handle/1721.1/6952">Actors: A Model Of Concurrent Computations in Distributed Systems</a> .  In the dissertation, Agha describes the syntax of a minimal programming language that supports actors, as well as a set of typical problems and methods for solving them (Chapter 4). <br><br>  Another important contribution to practical approaches to the implementation of the model of actors can be considered the article Phillip Haller and <a href="http://lampwww.epfl.ch/~odersky/">Martin Odersky</a> <a href="http://lampwww.epfl.ch/~odersky/papers/jmlc06.pdf">Event-Based Programming without Inversion Control</a> .  It proposed a new approach for the development of actor systems, which was used in Scala.  Its essence is that the resulting parallel program for writing is very similar to "regular sequential" programming. <br><br>  The same path, for example, was chosen for developing C #.  Here are the actors on C # 5: <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SavePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stream = File.AppendText(file)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> html = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient().DownloadStringTaskAsync(a); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> stream.WriteAsync(html); } }</code> </pre> <br><br>  Here, the <b>await</b> keyword implies an asynchronous call to the corresponding method and a return to the calculations when the answer is received. <br><br>  In 2011, Gul A. Aga and Karmani summed up many years of experience in the implementation of actor systems, describing the most common method of implementation.  They called it <a href="">Fog Cutter</a> .  True, Hewitt has repeatedly criticized such an architecture, for example, <a href="">here</a> and <a href="http://lambda-the-ultimate.org/node/4853">here.</a> The essence of criticism is that this is just one of the possible implementations of a particular case of a model that does not fully implement the entire actor model. <br><br>  Indeed, in the dissertation of the <a href="https://dspace.mit.edu/handle/1721.1/6935">Foundations of Actor Semantics</a> William Duglas Clinger (student of Carl Hewitt) shows that the actor model has unlimited non-determinism, while the Turing machine is boundedly non-deterministic.  From this, he and Carl Hewitt conclude that there are algorithms that can be implemented in the actor model, but cannot be implemented on a Turing machine.  Therefore, any attempt to implement the actor model on "ordinary" computers that implement Turing computability will result in the realization of only a special case of the actor model. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9da/4e8/75c/9da4e875c81f14851caa0b5c48cb075a.png"><br><br><h4>  A spoon of tar ... </h4><br>  In 1988, <a href="http://www.doc.ic.ac.uk/~rak/">Robert Kowalski</a> , the creator of the Prologue, advanced the thesis that ‚Äúcalculations can be grouped according to logical conclusions‚Äù.  This is true for sequential calculations and for some parallel models.  But in 1988, Hewitt and Agha published the article <a href="http://www.researchgate.net/publication/220993254_Guarded_Horn_Clause_Languages_Are_They_Deductive_and_Logical">Guarded Horn clause?</a>  in which it was shown that for the actor model this is incorrect in the following sense: the current state of the program can deductively not follow from the previous one.  What this means in practice: debugging a program based on the model of actors is not as effective as in the case of sequential programs. <br><br><h4>  Why functional languages? </h4><br>  Why do functional languages ‚Äã‚Äãarise wherever it comes to parallel programming?  To answer this question, consider a small example in C ++: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; ; ++i) { ++j; }</code> </pre><br>  Since this piece of code does not contain I / O operations, in order to allow another thread to execute its code on the same processor core, it is necessary to wait until the operating system's thread scheduler forcibly switches threads.  This can occur either when a call to a system function occurs in another thread, or upon a timer event.  By default, the timer event triggers <a href="http://habrahabr.ru/post/134559/">1 time in 15.6 ms</a> , <a href="http://habrahabr.ru/company/intel/blog/186998/">it</a> explains why you should not reduce this time to 1 ms.  It turns out that the imperative style allows you to write a "greedy" program that tries to single-handedly use all the processor resources, and we have limited resources to influence it. <br><br>  Rewrite this program through tail recursion. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cycle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; j)</span></span></span><span class="hljs-function"> </span></span>{ ++j; cycle(i+<span class="hljs-number"><span class="hljs-number">1</span></span>, j); }</code> </pre><br><br>  Forgive me admirers of functional programming languages ‚Äã‚Äãfor such a free interpretation, but my goal is only to demonstrate the idea. <br><br>  The loop iteration is replaced by a function call.  Suppose that the compiler embeds a code at the call point of each function to count the time spent executing the current thread and switching to another thread if necessary.  Now we have the opportunity to switch from one stream to another within nanoseconds.  The same idea allows to implement lightweight streams, for example, as in Erlang. <br><br>  For these properties, functional languages ‚Äã‚Äãare convenient to use where parallelism and real-time response is needed. <br><br><h4>  Rehabilitation of imperative languages </h4><br>  If you need a very fast response, then functional languages ‚Äã‚Äãare beyond competition, but what if during the processing of a request we have to contact the database, and the response time from it is about 50-100 ms, or we have to perform many calculations, that is, to perform many function calls .  The overhead costs associated with calculating the execution time and switching threads for each call make themselves felt, and imperative languages ‚Äã‚Äãare more efficient in this case.  To verify this, just look at the site <a href="http://benchmarksgame.alioth.debian.org/">benchmarksgame.alioth.debian.org</a> .  The site offers to measure the performance of programs written in different languages, comparing the solutions of the same problem.  Here are some examples of comparisons: <a href="http://benchmarksgame.alioth.debian.org/u64q/benchmark.php%3Ftest%3Drevcomp%26lang%3Dall%26data%3Du64q">reverse-complement</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/benchmark.php%3Ftest%3Dmandelbrot%26lang%3Dall%26data%3Du64">mandelbrot</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/benchmark.php%3Ftest%3Dregexdna%26lang%3Dall%26data%3Du64q">regex-dna</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/benchmark.php%3Ftest%3Dpidigits%26lang%3Dall%26data%3Du64q">pidigits</a> . <br><br>  At once I will make a reservation, firstly, these are only tests - it is not necessary to take them very seriously.  On the other hand, anyone who is dissatisfied with the position of their favorite programming language can offer their own solution and change the alignment of forces.  Secondly, I cited only those links where imperative languages ‚Äã‚Äãbenefit from a clear advantage, because my goal is only to illustrate the idea expressed a few paragraphs earlier about the overhead costs associated with the organization of parallelism. <br><br>  Another interesting observation is the implementation of the model of actors in imperative languages, as a rule, in tests above the functional Erlang.  Again, make a reservation, everyone knows that Erlang is good not in calculations, namely, where an instant response is needed, but this only once again confirms the idea of ‚Äã‚Äãoverhead costs. <br><br>  I will cite one metaphor: there are runners for long distances - marathon runners, and there are - for short - sprinters.  Some are required endurance at low average speed (relative to the sprinters), and the second - the maximum performance in a very short time (relative to the marathon).  Alas, it‚Äôs just physiologically impossible to show equally high results at sprint and marathon distances, simply because completely different properties are required from the muscles.  These runners are distinguished even by their figures: marathon runners are dry and sinewy, and sprinters are athletic and muscular. <br><br><h4>  5th generation of computer </h4><br>  Another confirmation that the parallel programming is not so simple, is a project to create a 5th generation of computers. <br><br>  In the 1980s, an attempt was made in Japan to create computers <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25BF%25D1%258C%25D1%258E%25D1%2582%25D0%25B5%25D1%2580%25D1%258B_%25D0%25BF%25D1%258F%25D1%2582%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25BF%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">of the 5th generation</a> .  The project was initiated again by the belief that the future is parallel computing, large databases and logical processing of large databases. <br><br>  It was spent 500 million dollars in the prices of the 80s.  The project lasted 10 years and ended in complete failure!  Parallel programs did not give significant performance advantages over single-threaded ones.  And for decades, Intel has taken the palm with its single-threaded processors.  And only when the processor manufacturers came up against the technological limitations of increasing the clock frequencies, the idea of ‚Äã‚Äãparallelism began to gain popularity again. <br><br><h4>  Approaches to the implementation of the model of actors </h4><br>  The performance issues discussed above, as well as the fact that Hewitt insistently emphasizes that neither threads, nor message queues, nor any known constructions are part of the model of actors, which led to a variety of ideas and ways of implementation. <br><br>  There are three directions: <br><ul><li>  New programming language.  This niche is occupied by functional languages.  A prime example: Erlang. </li><li>  Extensions to existing languages.  For example, Scala, C #.  It uses the idea of ‚Äã‚ÄãOdersky and Haller, which allows you to write parallel programs in the "usual style". </li><li>  Libraries for an existing language. </li></ul><br><br><h4>  In conclusion, two observations </h4><br><h5>  Belief in parallel computing. </h5><br>  You read the articles of the 70s: the future belongs to multiprocessor systems, artificial intelligence;  80s: the future belongs to multiprocessor systems, large databases, logical data processing, now: the future belongs to processors with a large number of cores, big data, cloud computing, and intelligent data analysis.  It is not difficult to draw analogies between the current situation and the forecasts of 40 years ago.  All this reminds an example from trainings on motivation about a donkey and a carrot.  We take a step to get closer to the cherished goal, and the goal is moving away from us as far as we are closer to it, but it is she who forces us to develop and move forward. <br><br><h5>  Ignoring on the one hand and criticism on the other. </h5><br>  When I first came across an actor model, and that was relatively recent.  I had a question - why I didn‚Äôt find out about her before.  Specially looked at books by Tanenbaum, Gregory Andrews, <a href="http://www.enterpriseintegrationpatterns.com/">Patterns of integration of corporate applications</a> , etc. - all of them give a lot of space to messaging concepts, but none of them say a word about the model of actors and Hewitt.  But when you read Hewitt or Agha, a lot of time is spent criticizing the traditional model of computing.  It seems that the actors simply ignore.  The same thing happens in programming: in the world of imperative programming, practically nothing is known about functional - as if it does not exist, at least it was until recently, and in the world of functional programming, imperative is criticized.  Can anyone have any thoughts, why did this happen? <br><br><h4>  What's next? </h4><br>  If this article is of interest, I plan to write a series of articles, for example: <br><ul><li>  Laws of ordering actors by <a href="http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-194.pdf">Actors and Continous Functionals</a> . </li><li>  An overview of the ideas set forth in the <a href="https://dspace.mit.edu/handle/1721.1/6952">Actors: A Model Of Concurrent Computations in Distributed Systems</a> dissertation. Gul A. Agha. </li><li>  Pros and cons of the Odersky <a href="http://lampwww.epfl.ch/~odersky/papers/jmlc06.pdf">Event-Based Programming</a> approach <a href="http://lampwww.epfl.ch/~odersky/papers/jmlc06.pdf">with Inversion Control</a> . </li><li>  Returning to the spoon, having degraded ... - a couple of my own ideas, already implemented and tested in practice, how to improve the reliability and resiliency of systems implemented according to the model of actors. </li></ul><br>  If there are wishes on the articles, I will be glad to hear. <br><br><h4>  PS </h4><br>  This article is based on one of my reports. <br><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/79856301&amp;xid=25657,15700022,15700186,15700191,15700253&amp;usg=ALkJrhjvZIOKplNcb3wI-JCTgNUwpGevZQ" width="560" height="315" frameborder="0" title="2013-11-09 03 Evgeny Tyumentsev.  Approaches to actors." webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe><br>  Pro actors story begins at the fifth minute. </div><p>Source: <a href="https://habr.com/ru/post/206300/">https://habr.com/ru/post/206300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206282/index.html">Ubiquiti NanoBridge M5: the first installation experience or wifi bridge out of the box</a></li>
<li><a href="../206288/index.html">Chelyabinsk mathematician published an attempt to prove P = NP</a></li>
<li><a href="../206290/index.html">Tesla Tower: electrical calculation</a></li>
<li><a href="../206294/index.html">How important it is to write good code</a></li>
<li><a href="../206296/index.html">View from the inside: the world around us - 4</a></li>
<li><a href="../206304/index.html">Suddenly. SugarSync finishes free accounts</a></li>
<li><a href="../206306/index.html">An example of solving a multiple regression problem using Python</a></li>
<li><a href="../206308/index.html">Save our souls: how reality shows affect people</a></li>
<li><a href="../206310/index.html">McLaren replaces wiper blades with a force field of sound waves</a></li>
<li><a href="../206312/index.html">Top 10 books to understand the stock market device</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>