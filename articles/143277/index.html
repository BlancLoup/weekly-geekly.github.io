<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accurate determination of the region by GPS coordinates</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When developing one application, there was a problem of access control for regions. 

 The problem of determining whether an object belongs to any reg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accurate determination of the region by GPS coordinates</h1><div class="post__text post__text-html js-mediator-article">  When developing one application, there was a problem of access control for regions. <br><br>  The problem of determining whether an object belongs to any region of Russia by its GPS coordinates has arisen <br><br>  The first thing we started using was the Google API, <br>  after they registered aliases for the returned rows and payment for access (to remove the limit on requests), everything worked. <br>  And everything was fine until Google changed the issue, for example, it was before: Moskovskaya oblast ', it became Moscow oblast' <br>  Here it was decided not to rely on Google, but to define the region on its own. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="http://cl.ly/330m361N2S0U0h071J0V/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202012-05-04%20%D0%B2%2011.27.43.png"><br><a name="habracut"></a><br><br>  The first thing that came to mind was: parse the returned Yandex data (in Yandex maps of version 1.x there was a module for working with regions) <br>  So did, it turned out 2 tables. <br>  The names of the regions were stored in one, in the second coordinates of the polygon, describing the region.  (83 - regions and 8500 - points) <br><br>  An algorithm was found to check whether a point lies in a polygon.  The code was rewritten from C to PHP, it makes no sense to understand how it works, it just works. <br><br>  $ sx, $ sy - coordinates of the point that we check <br>  $ coords - coordinates of points of a convex polygon (sorted in traversal order): <br>  $ coords = array ( <br>  array ('x' =&gt; 66.6634, 'y' =&gt; '66 .4433 '), <br>  etc. <br>  ) <br>  $ x, $ y - the names of the keys in the array <br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">into_poly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($sx, $sy, &amp;$coords, $x=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $y=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'y'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Profiler::start(<span class="hljs-string"><span class="hljs-string">'Detect collision'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">__FUNCTION__</span></span>); $pj=<span class="hljs-number"><span class="hljs-number">0</span></span>; $pk=<span class="hljs-number"><span class="hljs-number">0</span></span>; $wrkx=<span class="hljs-number"><span class="hljs-number">0</span></span>; $yu = <span class="hljs-number"><span class="hljs-number">0</span></span>; $yl = <span class="hljs-number"><span class="hljs-number">0</span></span>; $n = count($coords); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($pj=<span class="hljs-number"><span class="hljs-number">0</span></span>; $pj&lt;$n; $pj++) { $yu = $coords[$pj][$y]&gt;$coords[($pj+<span class="hljs-number"><span class="hljs-number">1</span></span>)%$n][$y]?$coords[$pj][$y]:$coords[($pj+<span class="hljs-number"><span class="hljs-number">1</span></span>)%$n][$y]; $yl = $coords[$pj][$y]&lt;$coords[($pj+<span class="hljs-number"><span class="hljs-number">1</span></span>)%$n][$y]?$coords[$pj][$y]:$coords[($pj+<span class="hljs-number"><span class="hljs-number">1</span></span>)%$n][$y]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($coords[($pj+<span class="hljs-number"><span class="hljs-number">1</span></span>)%$n][$y] - $coords[$pj][$y]) $wrkx = $coords[$pj][$x] + ($coords[($pj+<span class="hljs-number"><span class="hljs-number">1</span></span>)%$n][$x] - $coords[$pj][$x])*($sy - $coords[$pj][$y])/($coords[($pj+<span class="hljs-number"><span class="hljs-number">1</span></span>)%$n][$y] - $coords[$pj][$y]); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> $wrkx = $coords[$pj][$x]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($yu &gt;= $sy) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($yl &lt; $sy) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($sx &gt; $wrkx) $pk++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs($sx - $wrkx) &lt; <span class="hljs-number"><span class="hljs-number">0.00001</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((abs($sy - $yl) &lt; <span class="hljs-number"><span class="hljs-number">0.00001</span></span>) &amp;&amp; (abs($yu - $yl) &lt; <span class="hljs-number"><span class="hljs-number">0.00001</span></span>) &amp;&amp; (abs(abs($wrkx - $coords[$pj][$x]) + abs($wrkx - $coords[($pj+<span class="hljs-number"><span class="hljs-number">1</span></span>)%$n][$x]) - abs($coords[$pj][$x] - $coords[($pj+<span class="hljs-number"><span class="hljs-number">1</span></span>)%$n][$x])) &lt; <span class="hljs-number"><span class="hljs-number">0.0001</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($pk%<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br>  Call example: <br> <code>$coords = array( <br> array('lng'=&gt; 66.6634, 'lat' =&gt; '66.4433'), <br> array('lng'=&gt; 66.6534, 'lat' =&gt; '66.4433'), <br> array('lng'=&gt; 66.6434, 'lat' =&gt; '66.4433'), <br> array('lng'=&gt; 66.6334, 'lat' =&gt; '66.4433'), <br> ); <br> $in = into_poly(66.4455, 66.2255, &amp;$coords, $x='lng', $y='lat'); <br> <br></code> <br>  Returns true if the point lies inside the polygon. <br><br>  Now, just by looking at the areas for a point, we get the answer. <br><br>  Everything would be fine, but 8500 points of the regional boundaries for Russia are very few.  The spread will turn out + - 50 km <br><br>  To get more accuracy - we need more points of regional borders. <br>  Searching in the open spaces a resource was found that freely gives us these points: <a href="http://gis-lab.info/qa/rusbounds-rosreestr.html">gis-lab.info/qa/rusbounds-rosreestr.html</a> (thanks to the enthusiasts for your work) <br>  For some reason, I chose the KML format (probably because I knew how to open it - this is the format that Google Earth supports) <br>  I parsed the data and now the tables turned out to be fatter.  The table with the coordinates of the points of the regional boundaries has become 620,000 points (34 mb) <br><br>  Now, if we check by the old algorithm that a point belongs to a region polygon - on an old Core 2 Duo - about 70 seconds. <br>  Not an option.  The algorithm needs to be optimized: <br><br>  For example, Moscow: <br>  We have 2,064 points of the polygon (in fact, several polygons): <br><img src="http://cl.ly/330m361N2S0U0h071J0V/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202012-05-04%20%D0%B2%2011.27.43.png"><br><br>  But now it is enough for us to determine only the possibility that the point will be in this area.  Therefore, we use the algorithm for traversing points and constructing a convex polygon. <br>  <a href="http://algolist.manual.ru/maths/geom/convhull/gift.php">algolist.manual.ru</a> <br><br>  Here is its implementation in PHP: <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_points</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($mass, $x = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $y = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'y'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ $current=<span class="hljs-number"><span class="hljs-number">0</span></span>; $next=<span class="hljs-number"><span class="hljs-number">0</span></span>; $p1 = $mass[<span class="hljs-number"><span class="hljs-number">0</span></span>]; $mass2 = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-comment"><span class="hljs-comment">//   for ($i=1; $i&lt;count($mass); $i++){ if ( ($p1[$y] &gt; $mass[$i][$y]) || ($p1[$y] == $mass[$i][$y] &amp;&amp; $p1[$x] &lt; $mass[$i][$x]) ) { $p1 = $mass[$i]; $current = $i; } } $n = count($mass); $p0 = $p1; $p0[$x]--; $mass2[] = $mass[$current]; $first = $current; //    do{ $cmax_not_set=1; for ( $i=0; $i&lt;$n; $i++ ) { $key = $i; //      if ( $mass[$current][$x] == $mass[$key][$x] &amp;&amp; $mass[$current][$y] == $mass[$key][$y] ) continue; // 1  if ($cmax_not_set) { $next = $key; $cmax_not_set=0; continue; } $v1_x = $mass[$key][$x] - $mass[$current][$x]; $v1_y = $mass[$key][$y] - $mass[$current][$y]; $v2_x = $mass[$next][$x] - $mass[$current][$x]; $v2_y = $mass[$next][$y] - $mass[$current][$y]; // $c = $v1_x * $v2_y - $v1_y * $v2_x; if ( $c &gt; 0 ) $next = $key; // if ( ($c==0) &amp;&amp; ( self::_dist($mass[$current], $mass[$key], $x, $y) &gt; self::_dist($mass[$current], $mass[$next], $x, $y) ) ) $next = $key; } //     $mass2[] = $mass[$next]; $current = $next; }while($first != $next); return $mass2; }</span></span></code> </pre><br><br>  At the output we get an array of points of a convex polygon. <br>  For Moscow;  19 points: <br><img src="http://cl.ly/030S1B3t0I2L0d1t1o1R/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202012-05-04%20%D0%B2%2012.22.24.png"><br><br>  In the figure, the first layer marked all 2500 points of Moscow + layer, which we obtained after calculating a convex polygon. <br>  For each region we will generate such a region. <br><br>  Now we will refine our algorithm and we will first check the possibility that the point may lie in the region ‚Äî there may be several such regions. <br>  Now, after running all the areas, we will run the areas in which it is possible that the point lies, using the algorithm described above. <br>  Total: 0.177sec on a weak Core 2 Duo <br><br>  In fact, there is another difficulty - these are enclaves (Moscow lies inside the Moscow region, like Peter, it was decided to use priorities, first it is checked whether the point in Moscow lies, and then in the Moscow region) </div><p>Source: <a href="https://habr.com/ru/post/143277/">https://habr.com/ru/post/143277/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../143271/index.html">Guest from the 90s, Fujitsu Milan laptop</a></li>
<li><a href="../143273/index.html">Using eEPC notation to graphically describe business processes</a></li>
<li><a href="../143274/index.html">Notes ardent spammer (Chukchi not a reader!)</a></li>
<li><a href="../143275/index.html">Lake.js: jQuery plugin to reflect the illustrations as if in the lake water</a></li>
<li><a href="../143276/index.html">A typical error when installing COOKIE in PHP</a></li>
<li><a href="../143278/index.html">Certificate Planning for Exchange</a></li>
<li><a href="../143279/index.html">Jazz and java</a></li>
<li><a href="../143280/index.html">Startup preparation</a></li>
<li><a href="../143283/index.html">QML and QtQuick Webinars: Lists. Models and representations</a></li>
<li><a href="../143284/index.html">Platform for online tutoring in Russia: a view from the inside</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>