<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Casual C ++: isolating the C-style API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We all appreciate C ++ for easy integration with C code. And yet, these are two different languages. 


 Heritage C is one of the heaviest burdens for...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Casual C ++: isolating the C-style API</h1><div class="post__text post__text-html js-mediator-article"><p>  We all appreciate C ++ for easy integration with C code. And yet, these are two different languages. </p><br><p>  Heritage C is one of the heaviest burdens for modern C ++.  One cannot get rid of such a burden, but one can learn to live with it.  However, many programmers prefer not to live, but to suffer.  We will talk about this. </p><a name="habracut"></a><br><h2 id="ne-smeshivayte-c-i-biznes-logiku-na-c">  Do not mix C and business logic in C ++. </h2><br><p>  Not so long ago, I accidentally noticed a new insert in my favorite component.  My code has become a victim of tester-driven development. </p><br><blockquote>  <a href="https://en.wikipedia.org/wiki/Tester_Driven_Development">According to Wikipedia</a> , Tester-driven development is an anti-methodology of development, in which requirements are determined by bug reports or testers' testimonials, and programmers only treat symptoms, but do not solve real problems. </blockquote><p>  I shortened the code and translated it into C ++ 17.  Take a good look and think, is there anything left in the business logic: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> DocumentLoader::MakeDocumentWorkdirCopy() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code errorCode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::filesystem::exists(m_filepath, errorCode) || errorCode) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> DocumentLoadError(DocumentLoadError::NotFound(), m_filepath, errorCode.message()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Lock document HANDLE fileLock = CreateFileW(m_filepath.c_str(), GENERIC_READ, 0, // Exclusive access nullptr, // security attributes OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr //template file ); if (fileLock == INVALID_HANDLE_VALUE) { throw DocumentLoadError(DocumentLoadError::IsLocked(), m_filepath, "cannot lock file"); } CloseHandle(fileLock); } std::filesystem::copy_file(m_filepath, m_documentCopyPath); }</span></span></code> </pre> <br><p>  Let's describe in words what the function does: </p><br><ul><li>  if the file does not exist, an exception is thrown with the code NotFound and the path to the file </li><li>  otherwise, open the file with the specified read path, with exclusive access rights, without security attributes, open the existing one if possible, put the usual file attributes to it when creating the new file, do not use the template file </li><li>  and if the previous operation failed, close the file and throw an exception with the code IsLocked </li><li>  otherwise close the file and copy it. </li></ul><br><p>  Do not you think that something here falls out of the level of abstraction function? </p><br><p><img src="https://habrastorage.org/web/b56/c85/605/b56c856055254e6a90e52ebab79a7012.jpg" alt="Waste illustration"></p><br><p>  Do not mix layers of abstraction, code with different levels of logic detailing should be separated by the boundaries of a function, class, or library.  Do not mix C and C ++, these are different languages. </p><br><p>  In my opinion, the function should look like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> DocumentLoader::MakeDocumentWorkdirCopy() { boost::system::error_code errorCode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!boost::filesystem::exists(m_filepath, errorCode) || errorCode) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> DocumentLoadError(DocumentLoadError::NotFound(), m_filepath, errorCode.message()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!utils::ipc::MakeFileLock(m_filepath)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> DocumentLoadError(DocumentLoadError::IsLocked(), m_filepath, <span class="hljs-string"><span class="hljs-string">"cannot lock file"</span></span>); } fs::copy_file(m_filepath, m_documentCopyPath); }</code> </pre> <br><h2 id="pochemu-c-i-c-raznye">  Why are C and C ++ different? </h2><br><p>  To begin with, they were born at different times and they have different key ideas: </p><br><ul><li>  slogan C - "Trust the programmer", although many modern programmers can no longer be trusted </li><li>  C ++ slogan - "Do not pay for what you do not use," although you can actually pay dearly and simply for non-optimal use. </li></ul><br><p>  In C ++, errors are handled by exceptions.  How are they handled in C?  Who remembered the return codes is wrong: the standard for the C language <code>fopen</code> function does not return information about the error in the return codes.  Further, out-parameters in C are passed by pointer, and in C ++ the programmer can be scolded for this.  Further, in C ++ there is an RAII idiom for resource management. </p><br><p>  We will not list the other differences.  Just accept as the fact that we, C ++ programmers, write in C ++ and are forced to use the C-style API for: </p><br><ul><li>  OpenGL, Vulkan, cairo and other graphics APIs </li><li>  CURL and other network libraries </li><li>  winapi, freetype and other system level libraries </li></ul><br><p>  But using does not mean ‚Äúshoving in all places‚Äù! </p><br><h2 id="kak-otkryt-fayl">  How to open a file </h2><br><p>  If you are using ifstream, then an error handling attempt to open the file looks like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ifstream in; in.exceptions(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ios::failbit); in.open(<span class="hljs-string"><span class="hljs-string">"C:/path-that-definitely-not-exist"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; ex) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ex.what() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ifstream in; in.exceptions(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ios::failbit); in.open(<span class="hljs-string"><span class="hljs-string">"C:/"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; ex) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ex.what() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }</code> </pre> <br><p>  Since the first path does not exist, and the second is a directory, we will get exceptions.  But there is no file path or exact reason in the text of the error.  If you write such an error in the log, how will this help you? </p><br><p><img src="https://habrastorage.org/web/f01/46c/227/f0146c227f1d4a37af1d420093e9ec93.png" alt="Fstream error screenshot"></p><br><p>  Typical code using C-style API behaves worse: it does not even guarantee the security of exceptions.  In the example below, when throwing an exception from the insert <code>// ..  </code> file will never be closed. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    #if defined(_MSC_VER) #define _CRT_SECURE_NO_WARNINGS #endif int main() { try { FILE *in = ::fopen("C:/path-that-definitely-not-exist", "r"); if (!in) { throw std::runtime_error("open failed"); } // .. .. fclose(in); } catch (const std::exception&amp; ex) { std::cout &lt;&lt; ex.what() &lt;&lt; std::endl; } }</span></span></code> </pre> <br><p>  And now we take this code and show what C ++ 17 is capable of, even if we have a C-style API. </p><br><h2 id="a-pochemu-by-ne-sdelat-kak-sovetuet-oop">  Why not do as advised by the PLO? </h2><br><p>  Go ahead, try.  You will have another iostream, in which you cannot just take and find out how many bytes you managed to read from the file, because the read signature looks like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">basic_istream&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(char_type* s, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::streamsize count)</span></span></span></span>;</code> </pre> <br><p>  And if you still want to use iostream, please also call tellg: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      count   ,      filepath std::string GetFirstFileBytes(const std::filesystem::path&amp; filepath, size_t count) { assert(count != 0); //  ,     std::ifstream stream; stream.exceptions(std::ifstream::failbit); //  : C++17   ifstream //    string,    wstring stream.open(filepath.native(), std::ios::binary); std::string result(count, '\0'); //    count    stream.read(&amp;result[0], count); //  ,   ,  . result = result.substr(0, static_cast&lt;size_t&gt;(stream.tellg())); return result; }</span></span></code> </pre> <br><p>  The same problem in C ++ is solved by two calls, and in C - by one call to <code>fread</code> !  Among the many libraries offering C ++ wrapper for X, most create such restrictions or force you to write non-optimal code.  I'll show a different approach: procedural style in C ++ 17. </p><br><h2 id="shag-pervyy-raii">  Step One: RAII </h2><br><p>  Juniors do not always know how to create their own RAII for resource management.  But we know: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-comment"><span class="hljs-comment">// ,    struct FileDeleter { void operator()(FILE* ptr) { fclose(ptr); } }; } //  FileUniquePtr -   unique_ptr,  fclose using FileUniquePtr = std::unique_ptr&lt;FILE, detail::FileDeleter&gt;;</span></span></code> </pre> <br><p>  This feature allows you to wrap the function <code>::fopen</code> in the function <code>fopen2</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    #if defined(_MSC_VER) #define _CRT_SECURE_NO_WARNINGS #endif //   ,   Unicode    UNIX-. FileUniquePtr fopen2(const char* filepath, const char* mode) { assert(filepath); assert(mode); FILE *file = ::fopen(filepath, mode); if (!file) { throw std::runtime_error("file opening failed"); } return FileUniquePtr(file); }</span></span></code> </pre> <br><p>  This function still has three drawbacks: </p><br><ul><li>  it takes parameters by pointers </li><li>  the exception does not contain any details </li><li>  Unicode paths on Windows are not processed </li></ul><br><p>  If we call a function for a non-existent path and for a catalog path, we get the following exception texts: </p><br><p><img src="https://habrastorage.org/web/5da/d81/c26/5dad81c266b04836aebf4f184a75ae0a.png" alt="Error screenshot"></p><br><h2 id="shag-vtoroy-sobiraem-informaciyu-ob-oshibke">  Step Two: Collect Error Information </h2><br><p>  Firstly, we need to find out from the OS the reason for the error, secondly, we must indicate the path it originated in order not to lose the context of the error in the process of flying through the call stack. </p><br><p>  And here we must admit: not only the juniors, but also many midli and Signori do not know how to work with errno correctly and how much it is thread-safe.  We will write this: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    #if defined(_MSC_VER) #define _CRT_SECURE_NO_WARNINGS #endif //   ,   Unicode    UNIX-. FileUniquePtr fopen3(const char* filepath, const char mode) { using namespace std::literals; //   ""s. assert(filepath); assert(mode); FILE *file = ::fopen(filepath, mode); if (!file) { const char* reason = strerror(errno); throw std::runtime_error("opening '"s + filepath + "' failed: "s + reason); } return FileUniquePtr(file); }</span></span></code> </pre> <br><p>  If we call a function for a non-existent path and for a catalog path, we will get more accurate exception texts: </p><br><p><img src="https://habrastorage.org/web/959/899/366/959899366e024b31838805ac54793387.png" alt="Screenshot of the detailed error"></p><br><h2 id="shag-tretiy-eksperimentiruem-s-filesystem">  Step Three: Experimenting with the Filesystem </h2><br><p>  C ++ 17 brought many small improvements, and one of them is the <code>std::filesystem</code> module.  It is better than <code>boost::filesystem</code> : </p><br><ul><li>  it solved the problem of 2038, but in boost :: filesystem is not solved </li><li>  there is an unambiguous way to get the UTF-8 path, but a number of libraries (for example, SDL2) require exactly the UTF-8 path </li><li>  the <code>boost::filesystem</code> implementation contains dangerous games with pointer dereferencing, there are many Undefined Behavior </li></ul><br><p>  For our case, filesystem brought the universal, non-encoding-sensitive class path.  This allows you to transparently handle Unicode paths on Windows: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  VS2017  filesystem    experimental #include &lt;cerrno&gt; #include &lt;cstring&gt; #include &lt;experimental/filesystem&gt; #include &lt;fstream&gt; #include &lt;memory&gt; #include &lt;string&gt; namespace fs = std::experimental::filesystem; FileUniquePtr fopen4(const fs::path&amp; filepath, const char* mode) { using namespace std::literals; assert(mode); #if defined(_WIN32) fs::path convertedMode = mode; FILE *file = ::_wfopen(filepath.c_str(), convertedMode.c_str()); #else FILE *file = ::fopen(filepath.c_str(), mode); #endif if (!file) { const char* reason = strerror(errno); throw std::runtime_error("opening '"s + filepath.u8string() + "' failed: "s + reason); } return FileUniquePtr(file); }</span></span></code> </pre> <br><p>  It seems to me obvious that such code is difficult to write and that one of experienced engineers in the general library should write it once.  Junior in such a jungle is not worth climbing. </p><br><h2 id="zaglyadyvaya-v-buduschee-mir-bez-preprocessora">  Looking to the future: a world without a preprocessor </h2><br><p>  Now I will show you the code, which in June 2017, most likely, will not compile any compiler.  In any case, in VS2017, constexpr if is not yet implemented, but for some reason GCC 8 compiles the if branch and gives the following error: </p><br><p><img src="https://habrastorage.org/web/d7d/4d5/767/d7d4d5767676499ca02d9a9f38170fd0.png" alt="Compilation Error Screenshot"></p><br><p>  Yes, yes, it's about constexpr if from C ++ 17, which offers a new way to conditionally compile the source code. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FileUniquePtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fopen5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fs::path&amp; filepath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* mode)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::literals; assert(mode); FILE *file = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   path::value_type -   wchar_t,  wide- //  Windows      UTF-16,   . // : wchar_t   UTF-16   Windows. if constexpr (std::is_same_v&lt;fs::path::value_type, wchar_t&gt;) { fs::path convertedMode = mode; file = _wfopen(filepath.c_str(), convertedMode.c_str()); } //    ,    UTF-8    Unicode else { file = fopen(filepath.c_str(), mode); } if (!file) { const char* reason = strerror(errno); throw std::runtime_error("opening '"s + filepath.u8string() + "' failed: "s + reason); } return FileUniquePtr(file); }</span></span></code> </pre> <br><p>  This is an amazing opportunity!  If modules and a few more features are added to C ++, we can forget the C preprocessor as a bad dream and write new code without it.  In addition, with modules, compilation (without linking) will be much faster, and leading IDEs will respond to auto-completion with less delay. </p><br><h2 id="plyusy-procedurnogo-stilya">  Pros of procedural style </h2><br><p>  Although the PLO rules in the industry, and in the academic code it is a functional approach, the procedural style fans still have something to rejoice about. </p><br><ul><li>  procedural style is easier to understand, it is easier for juniors and most of the short examples on the net are written on it </li><li>  You can wrap C functions with almost no <code>fopen4</code> in semantics: our <code>fopen4</code> function still uses flags, mode and other C-style tricks, but reliably manages resources, collects all error information and carefully takes parameters </li><li>  documentation of the fopen function is still relevant for our wrapper, this greatly facilitates the search, understanding and reuse by other programmers </li></ul><br><p>  I recommend all the functions of the standard C library, WinAPI, CURL or OpenGL to wrap in a similar procedural style. </p><br><h2 id="podvedyom-itogi">  Let's sum up </h2><br><p>  In C ++ Russia 2016 and C ++ Russia 2017, a wonderful speaker, Mikhail Matrosov, showed everyone why there‚Äôs no need to use cycles and how to live without them: </p><br><ul><li>  <a href="http://cpp-russia.ru/%3Fpage_id%3D999">Casual C ++: boost and STL</a> </li><li>  <a href="http://2017.cppconf.ru/talks/mikhail-matrosov">Everyday C ++: Algorithms and Iterators</a> </li></ul><br><p>  As far as we know, the inspiration for Michael was the 2013 report <a href="http://sean-parent.stlab.cc/papers-and-presentations">"C ++ Seasoning"</a> by Sean Parent.  The report highlighted three rules: </p><br><ul><li>  do not write low-level for and while loops <br><ul><li>  use algorithms and other tools from STL / Boost </li><li>  if off-the-shelf tools do not fit, wrap the cycle in a separate function </li></ul></li><li>  do not work with new / delete directly <br><ul><li>  more about this - in the report of Mikhail Matrosov <a href="http://cpp-russia.ru/%3Fpage_id%3D608">C + + without new and delete</a> </li></ul></li><li>  do not use low-level synchronization primitives, such as mutex and thread </li></ul><br><p>  I would add one more, fourth rule of everyday C ++ code.  Do not write in CBC Plus.  Do not mix business logic and C language. </p><br><ul><li>  Wrap C in at least one layer of insulation. </li><li>  If we are talking about asynchronous code, wrap in two layers: the first isolates the C, the second hides the synchronization primitives and scheduling tasks on the threads </li></ul><br><p>  The reasons are well illustrated in this article.  We formulate them like this: </p><br><blockquote>  Only a true hero can write an absolutely reliable C / C ++ code.  If you need a hero every day at work, you have a problem. </blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/331100/">https://habr.com/ru/post/331100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331090/index.html">Shallow immersion or data recovery from the hard drive after flooding the office</a></li>
<li><a href="../331092/index.html">Cricket Lee and Paul Vixie's Webinar on Network Security with DNS RPZ</a></li>
<li><a href="../331094/index.html">Security Week 24: 95 fixes from Microsoft, the router merges the data with LEDs, for MacOS there is a runner service</a></li>
<li><a href="../331096/index.html">Better to hear once than read seven times</a></li>
<li><a href="../331098/index.html">Create applications using Firebird, jOOQ and Spring MVC</a></li>
<li><a href="../331104/index.html">This question must be addressed by the architect. Or not?</a></li>
<li><a href="../331114/index.html">A quick setup option for a wholesale company management system</a></li>
<li><a href="../331116/index.html">New plug-in for Sennheiser headsets and free upgrade to 3CX v15.5</a></li>
<li><a href="../331118/index.html">Catch data big and small! (Overview of Data Science courses from the Cognitive Class)</a></li>
<li><a href="../331120/index.html">How to write the most awful backend for a mobile application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>