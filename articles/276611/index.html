<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Criticism of the article ‚ÄúHow to write in C in 2016‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: 

 This publication is the third and last article of the cycle, which arose spontaneously after the publication of the translatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Criticism of the article ‚ÄúHow to write in C in 2016‚Äù</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/912/cef/249/912cef2490e34fc9b508ba86d30284fc.jpg"><br>  <i>From the translator:</i> <br><br>  <i>This publication is the third and last article of the cycle, which arose spontaneously after the publication of the <a href="https://habrahabr.ru/company/inoventica/blog/275685/">translation of the</a> article <a href="https://matt.sh/howto-c">"How to C in 2016"</a> in the blog <a href="http://inoventica-services.ru/">Inoventica Services</a> .</i>  <i>Here, some of the theses set forth in the original are criticized and a complete ‚Äúpicture‚Äù of opinions about the issues raised by the author of the first publication and the methods of writing code in C. is finally formed. ImpureThought was provided to the English-language original, for which a special thanks to him.</i>  <i>With the second publication, a tip to the text of which gave, as I think, a <a href="https://habrahabr.ru/users/coderush/" class="user_link">CodeRush</a> user familiar to many, can be found <a href="https://habrahabr.ru/post/275823/">here</a> .</i> <br><br>  Matt (on whose website the author‚Äôs last name is not listed, at least as far as I know) published the article ‚ÄúC Programming in 2016‚Äù, which later appeared on Reddit and Hacker News, it was on the last resource that I discovered it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Yes, one can endlessly "discuss" C programming, but there are aspects with which I clearly disagree.  This critical article is written from the standpoint of constructive discussion.  It is quite possible that in some cases Matt is right, but I am mistaken. <br><br>  I am not quoting Matt's entire publication.  In particular, I decided to drop some points with which I agree.  Let's start. <br><a name="habracut"></a><br><blockquote>  The first rule of C programming - do not use it if you can do with other tools. </blockquote><br>  I do not agree with this statement, but this is too broad a topic for discussion. <br><br><blockquote> When programming in C, the <code>lang</code> defaults to C99, and therefore no additional options are required. </blockquote><br>  It depends on the <code>clang</code> version: <code>clang 3.5</code> by default works with C99, <code>clang 3.6</code> - with C11.  I'm not sure how tough it is when using out of the box. <br><br>  If you need to use a specific standard for gcc or clang, do not complicate, use std = cNN -pedantic. <br><br><blockquote>  By default, <code>gcc-5</code> requests <code>-std=gnu11</code> , but in practice you need to specify c99 or c11 without GNU. </blockquote><br>  Well, except that if you do not want to use specific gcc extensions, which, in principle, are quite suitable for these purposes. <br><br><blockquote>  If you find something like <code>char</code> , <code>int</code> , <code>short</code> , <code>long</code> or <code>unsigned</code> in the new code, here are some bugs. </blockquote><br>  You, of course, excuse me, but this is nonsense.  In particular, int is the most acceptable type of integer data for the current platform.  If we are talking about fast, unsigned integers of at least 16 bits, there is nothing wrong with using int (or you can refer to the <code>int_least16_t</code> option, which will do a great job with functions of the same type, but IMHO is much more detailed than worth it). <br><br><blockquote>  In modern programs it is necessary to specify <code>#include &lt;stdint.h&gt;</code> and only then choose standard data types. </blockquote><br>  The fact that <code>int</code> not spelled <code>¬´std¬ª</code> does not mean that we are dealing with something non-standard.  Types such as <code>int</code> , <code>long</code> and others are built into the C language. And typedefs, recorded in <code>&lt;stdint.h&gt;</code> , appear later as additional information.  This does not make them less ‚Äústandard‚Äù than built-in types, although they are in some way inferior to the latter. <br><br><blockquote>  <code>float</code> - 32-bit floating point standard <br>  <code>double</code> - 64-bit floating point standard </blockquote><br>  <code>float</code> and <code>double</code> are quite common IEEE types for 32 and 64-bit floating-point standards, in particular, on modern systems, you should not dwell on this when programming in C. I worked on systems where float was used on 64 bits. <br><br><blockquote>  Please note: no more <code>char.</code>  Usually in the C programming language, the <code>char</code> command is not only named, but also used incorrectly. </blockquote><br>  Unfortunately, the merging of parameters and bytes when programming in C is inevitable, and here we are just stuck.  The char type is consistently equal to one byte, where the ‚Äúbyte‚Äù is at least 8 bits. <br><br><blockquote>  Software developers continually use the char command to refer to "byte", even when unsigned byte operations are performed.  Much more correctly for individual unsigned byte / octet values ‚Äã‚Äãspecify <code>uint8_t</code> , and for a sequence of unsigned byte / octet values ‚Äã‚Äãselect <code>uint8_t *</code> . </blockquote><br>  If bytes are implied, enable <code>unsigned char</code> .  If talking about octets, select <code>uint8_t</code> .  In the case when <code>CHAR_BIT &gt; 8</code> , <code>uint8_t</code> cannot be created, which means that it will not work and compile the code (perhaps this is what you need).  If we work with objects of at least 8 bits, use <code>uint_least8_t</code> .  If bytes are octets, add something like this to the code: <br><br><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;limits.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#if</span></span> <span class="hljs-type"><span class="hljs-type">CHAR_BIT</span></span> != <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#error</span></span> <span class="hljs-comment"><span class="hljs-comment">"This program assumes 8-bit bytes"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span></code> </pre> <br>  Note: POSIX requests <code>CHAR_BIT == 8</code> . <br><br><blockquote>  in the C programming language, string literals <code>("hello")</code> look like <code>char *</code> . </blockquote><br>  No, string literals are specified with char [].  In particular, for "hello" this is char [6].  Arrays are not pointers. <br><br><blockquote>  Do not try to write code using <code>unsigned</code> .  Now you know how to write a decent code without the unreasonable conventions of C with numerous data types that not only make the content unreadable, but also call into question the effectiveness of using the finished product. </blockquote><br>  Many types of C are assigned names consisting of several words.  And there is nothing wrong with that.  If you are too lazy to type extra characters, this does not mean that it is worth stuffing the code with all sorts of abbreviations. <br><br><blockquote>  Who would like to introduce unsigned long long int if you can restrict <code>uint64_t</code> to a simple <code>uint64_t</code> ? </blockquote><br>  On the one hand, you can use unsigned long long, meaning int.  At the same time, knowing that these are different things and that the type is <code>unsigned long long</code> , at least 64-bit, and it may be present or absent indents.  <code>uint64_t</code> designed exactly for 64 bits, and without bits of indents;  This type is not necessarily registered in this or that code. <br><br>  <code>unsigned long long</code> embedded type in C. Anyone familiar with this programming language is familiar. <br><br>  Or try <code>uint_least64_t</code> , which may be identical or different from <code>unsigned long long</code> . <br><br><blockquote>  The types <code>&lt;stdint.h&gt;</code> much more specific and precise in meaning, they better convey the intentions of the author, are compact - not least important for exploitation and readability. </blockquote><br>  Of course, the types <code>intN_t</code> and <code>uintN_t</code> much more specific.  But not all codes are important.  Do not specify what is unimportant for you.  Choose <code>uint64_t</code> only when you really need exactly 64 bits - no more, no less. <br><br>  Sometimes types with exact length are required, for example, when it is necessary to adapt to a specific format (Sometimes emphasis is placed on the byte order, alignment of elements, etc.). &lt;Stdint.h&gt; in C does not allow for the description of specific parameters).  Most often, it is enough to specify a specific range of values, for which the built-in types [u] int_leastN_t or [u] int_leastN_t are suitable. <br><br><blockquote>  The correct type for pointers in this case is <code>uintptr_t</code> , it is specified by the files <code>&lt;stdint.h&gt;</code> . </blockquote><br>  What a terrible mistake. <br><br>  Let's start with small errors: <code>uintptr_t</code> is set by <code>&lt;stdint.h&gt;</code> , not <code>&lt;stddef.h&gt;</code> . <br><br>  This, if ever, talk about specifics.  Calling a command where <code>void*</code> cannot be converted to another integer type without data loss is unlikely to determine <code>uintptr_t</code> (Such cases are extremely rare, if they exist at all). <br><br><blockquote>  Instead: <br><br><pre> <code class="hljs lisp">long diff = (<span class="hljs-name"><span class="hljs-name">long</span></span>)ptrOld - (<span class="hljs-name"><span class="hljs-name">long</span></span>)ptrNew<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br></blockquote><br>  Yes, things are not done that way. <br><br><blockquote>  Use: <br><br><pre> <code class="hljs lisp">ptrdiff_t diff = (<span class="hljs-name"><span class="hljs-name">uintptr_t</span></span>)ptrOld - (<span class="hljs-name"><span class="hljs-name">uintptr_t</span></span>)ptrNew<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br></blockquote><br>  But this option is no better. <br><br>  If you want to emphasize the difference of types, write: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">ptrdiff_t</span></span> diff = ptrOld - ptrNew;</code> </pre> <br>  If you need to focus on bytes, choose something like: <br><br><pre> <code class="hljs lisp">ptrdiff_t diff = (<span class="hljs-name"><span class="hljs-name">char*</span></span>)ptrOld - (<span class="hljs-name"><span class="hljs-name">char*</span></span>)ptrNew<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  If <code>ptrOld</code> and <code>ptrNew</code> do not indicate the necessary parameters, or simply jump from the end of the object, it will be difficult to track how the pointer causes the command to subtract data.  The transition to <code>uintptr_t</code> guarantees at least a relative result, although it can hardly be called very useful.  Comparison or other arithmetic operations with pointers are permissible only when writing code for high-level systems, otherwise it is important that the studied pointers refer to the end of a certain object or jump from it (Exception: == and! = Work fine for pointers that refer to different objects). <br><br><blockquote>  In such situations, it is rational to refer to intptr_t, an integer data type corresponding to values ‚Äã‚Äãequal to a word on your platform. </blockquote><br>  And no.  The concept of "equal to the word" is very abstract.  <code>intptr_t</code> signed integer type that successfully converts <code>void*</code> to <code>intptr_t</code> and back without losing data.  And it can be a value greater than <code>void*</code> . <br><br><blockquote>  On 32-bit platforms, <code>intptr_t</code> transformed to <code>int32_t</code> . </blockquote><br>  It happens, but not always. <br><br><blockquote>  On 64-bit platforms, <code>intptr_t</code> takes the form <code>int64_t</code> . </blockquote><br>  And again, it is likely, but not necessary. <br><br><blockquote>  Essentially, <code>size_t</code> is something like an ‚Äúinteger value capable of storing huge array indices. </blockquote><br>  Nooo. <br><br><blockquote>  and, therefore, he is able to fix impressive indicators of bias in the program being created. </blockquote><br>  Yes, this type of data allows you to save information about the size of the largest object involved when starting the program (there is also an opinion that this is also <i>optional</i> , but for the sake of practice we can assume that this is exactly what happens).  It can fix the main memory offset if all offsets are made within the same object. <br><br><blockquote>  In any case, on modern platforms, <code>size_t</code> has practically the same characteristics as <code>uintptr_t</code> , and therefore, on 32-bit versions, <code>size_t</code> transformed into <code>uint32_t</code> , and on 64-bit <code>uint64_t</code> - into <code>uint64_t</code> . </blockquote><br>  Most likely, but not necessarily. <br><br>  More specifically, <code>size_t</code> can be used to preserve the size of any individual object, while <code>uintptr_t</code> sets any pointer value, and, accordingly, with their help, you no longer confuse the byte addresses of various objects.  Most modern systems work with indivisible address lines, and therefore, theoretically, the maximum object size is equal to the total memory capacity.  C programming standards require strict compliance with this requirement.  For example, you may encounter a situation where on a 64-bit system objects do not exceed 32 bits. <br><br>  Highlighting the word ‚Äúmodern‚Äù, we automatically omit both old alternatives (like x86, on which we used segmented addressing with near and far pointers), and do not touch on possible future products, which may also include compatibility with C standards, although they go beyond the definition of "Modern". <br><br><blockquote>  Do not refer to data types during operation.  Always use appropriate type pointers. </blockquote><br>  This is one of the options, but not the only successful solution (And, for sure, you will agree that you still need to mention void * for "% p"). <br><br><blockquote>  The initial pointer value is% p (in modern compilers it is displayed in hexadecimal; initially sends a pointer to <code>void *</code> ) </blockquote><br>  Excellent advice - only the output format is set by the launch parameters.  Usually this is a hexadecimal value, but do not think that there is no other. <br><br><pre> <code class="hljs lisp"> printf(<span class="hljs-string"><span class="hljs-string">"Local number: %"</span></span> PRIdPTR <span class="hljs-string"><span class="hljs-string">"\n\n"</span></span>, someIntPtr)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  The name <code>someIntPtr</code> implies the type <code>int*</code> , actually sets the type <code>intptr_t</code> . <br><br>  There may be variations on the theme, which means that you do not need to learn endless combinations of macro names: <br><br><pre> <code class="hljs perl">some_signed_type n; some_unsigned_type u; <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"n = %jd, u = %ju\n"</span></span>, (intmax_t)n, (uintmax_t)u);</code> </pre> <br>  <code>intmax_t</code> and <code>uintmax_t</code> , as a rule, 64-bit.  Their transformations are much more economical than physical I / O. <br><br><blockquote>  Note:% falls into the body of the format string, while the type pointer remains outside. </blockquote><br>  All of this is part of the format string.  Macros are set as string literals combined with adjacent string literals. <br><br><blockquote>  Modern compilers support <code>#pragma once</code> </blockquote><br>  But no one says that you are obligated to use this directive.  Even in the instructions of the processors, such recommendations are not voiced.  And in the ‚ÄúHeaders with Once‚Äù section, not a word about #pragma once;  but it is described <code>#ifndef</code> .  In the next section, "Alternatives to the #ifndef Packer" flashed #pragma once, but in this case it‚Äôs just noted that this is not a portable option. <br><br><blockquote>  This function is supported by all compilers, and on different platforms, and is much more efficient mechanism than manually entering the security code for the header. </blockquote><br>  And who gives such recommendations?  The <code>#ifndef</code> directive may not be perfect, but is reliable and portable. <br><br><blockquote>  IMPORTANT: If internal structure is provided in your structure, the {0} method will not reset the additional bytes intended for this purpose.  So, for example, it happens if a struct thing has 4 bytes of padding after <code>counter</code> (on a 64-bit platform), because structures are filled in increments equal to one word.  If you need to zero the entire structure including unused bytes of indents, specify <code>memset(&amp;localThing, 0, sizeof(localThing))</code> , since <code>sizeof(localThing) == 16 bytes</code> , even though only 8 + 4 = 12 bytes are available. </blockquote><br>  The task is complicated.  Usually there is no reason to pay special attention to the bytes of indents.  If you still want to devote your precious time to them, use <code>memset</code> to reset them.  Although I will note that clearing structures using <code>memset</code> , even taking into account that whole elements will indeed be assigned a value of zero, does not guarantee the same effect for floating-point types or pointers ‚Äî they must be equal to 0.0 and <code>NULL</code> , respectively (although most systems function perfectly works). <br><br><blockquote>  In C99, variable length arrays appeared </blockquote><br>  No, initializers for VLA (variable length arrays) are not provided in C99.  But Matt, in fact, does not write about the VLA initializers, mentioning only the VLAs themselves. <br><br>  Variable-length arrays are a controversial phenomenon.  Unlike malloc, they do not involve error detection in the allocation of resources.  So, if you need to allocate N number of data bytes, you will need: <br><br><pre> <code class="hljs cpp">{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(N); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buf == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* allocation failed */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(buf); }</code> </pre> <br>  at least in general, it is safer than: <br><br><pre> <code class="hljs objectivec">{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[N]; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Yes, mistakes when using VLA are fraught with serious problems.  But the same can be said, practically, about every function in any programming language. <br><br>  And with the old fixed-length arrays, similar questions arose.  As long as you check the size before creating the array, the VLA with variable N is as harmless as an array of fixed length of the same size.  As a rule, to describe fixed-length arrays, a value greater than the number of supposed elements is chosen, since part of it is necessary to store actual data.  With VLA, you can allocate exactly as much space as the components require.  And here I agree with Matt‚Äôs recommendation. <br><br>  In addition to one aspect: in C11, you can select the VLA at will.  I doubt that most C11 compilers, in fact, will perceive arrays of variable length as optional, except in the case of small embedded systems.  True, this feature is worth remembering if you plan to write the most portable code. <br><br><blockquote>  If the function works with * arbitrary ** source data and a certain length, do not limit the type of this parameter.  * <br><br>  Knowingly erroneous: <br></blockquote><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processAddBytesOverflow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { bytes[<span class="hljs-number"><span class="hljs-number">0</span></span>] += bytes[i]; } }</code> </pre> <br><blockquote>  Instead, use: <br></blockquote><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processAddBytesOverflow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *input, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *bytes = input; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { bytes[<span class="hljs-number"><span class="hljs-number">0</span></span>] += bytes[i]; } }</code> </pre> <br>  I agree, <code>void*</code> an ideal type for fixing parameters of an arbitrary fragment of memory.  Take at least the <code>mem*</code> function in the standard library (But len ‚Äã‚Äãshould be <code>size_t</code> , not <code>uint32_t</code> ). <br><br><blockquote>  By declaring the source data type as void *, and re-assigning or once again referring to the actual data type that is needed right in the function body, you will protect users, because they don‚Äôt have to think about what is happening in your library. </blockquote><br>  A small note: this is not spelled out in Matt‚Äôs function.  Here we see the implicit conversion of <code>void*</code> to <code>uint8_t*</code> . <br><br><blockquote>  In this example, some readers are faced with the problem of alignment. </blockquote><br>  And they were wrong.  If we work with a specific piece of memory, like a sequence of bytes, it is always safe. <br><br><blockquote>  C99 provides us with the whole set of functions <code>&lt;stdbool.h&gt;</code> , where <code>true</code> is 1 and <code>false - 0</code> . </blockquote><br>  Yes, and besides, you can set the <code>bool</code> , which is used as an alias for the built-in <code>_Bool</code> type. <br><br><blockquote>  In the case of successful / unsuccessful return values, the functions should return <code>true</code> or <code>false</code> , rather than the return type <code>int32_t</code> , which requires manual input of 1 and 0 (or, even worse, 1 and -1; how to figure it out: 0 - <code>success</code> , and 1 - <code>failure?</code> or 0 - <code>success</code> , and -1 - <code>failure?</code> )). </blockquote><br>  There is a widespread algorithm, in particular, on systems like Unix, when, if successful, the function returns 0, and if it fails, some non-zero value (often -1).  In many situations, variable non-zero results indicate different types of errors.  Adding new functions to ready-made interfaces, it is important to follow the aforementioned standard (0 is equivalent to success, since, in general, there is only one option for the effective operation of the function, but there may be many errors in it). <br><br>  The function created for analyzing certain conditions should return <code>true</code> or <code>false</code> .  Just do not confuse them with successful / unsuccessful outcomes of running the code. <br><br>  The function <code>bool</code> necessarily assigned a name in the form of an assertion.  In English, this will be the wording that answers the yes / no question.  For example, <code>is_foo()</code> and <code>has_widget()</code> function designed for a specific action, in the case with which it is important for you to know how successful it can be performed, is likely to be specified by another statement.  In some languages ‚Äã‚Äãit is reasonable to resort to adding / subtracting exceptions.  On C, you have to follow certain unspoken rules, including setting a zero value for a positive result of a function. <br><br><blockquote>  The only product that in 2016 will allow formatting products developed in C is clang-format.  Native clang-format settings are an order of magnitude higher than any other automatic C-code formatter. </blockquote><br>  I myself have not used clang-format.  I just have to meet him. <br><br>  But I would like to voice a few key points regarding the formatting of the C-code: <br><br><ul><li>  We put open brackets at the end of the line; </li><li>  Instead of tab, use spaces; </li><li>  4 columns in one level; </li><li>  Our curly brackets are all (with the exception of some cases when, in order to improve readability, it is easier to list tasks directly in a line); </li><li>  <b>Follow the instructions of the project you are working on.</b> </li></ul><br>  I rarely turn to automatic formatting tools.  Maybe nothing? <br><br><blockquote>  Never use <code>malloc</code> <br>  Get used to <code>calloc</code> . </blockquote><br>  Here's another.  Attempting to reset all bits of the allocated memory is reduced to a very arbitrary process, and, as a rule, this is not the best idea.  If the code is written correctly, you will not be able to call this or that object without first assigning the corresponding value to it.  Using <code>calloc</code> , you will encounter the fact that any bug in the code will be equal to zero, which means that it will be easy to confuse a system error with unnecessary data.  Does this sound like code enhancement? <br><br>  Resetting the memory often results in an error in the program code triggering sequential algorithms;  By definition, this can not be called the correct course of launch.  But the successive errors are much more difficult to track. <br><br>  Yes, if the code was written without errors.  But if you are pursuing a defensive strategy when you create a code, you may want to assign a certain value from the category of <i>invalid</i> memory to the allocated memory. <br><br>  On the other hand, if zeroing all the bits solves the problem, you can try to use <code>calloc</code> . <br><br><hr><br>  PS <br>  <em>We also invite readers next week to visit our cloud data center with a guided tour.</em> <em>    <a href="https://habrahabr.ru/company/inoventica/blog/276933/"></a></em> . <br></div><p>Source: <a href="https://habr.com/ru/post/276611/">https://habr.com/ru/post/276611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276597/index.html">Binding Request Traker 4.x on Ubuntu to ldap using the example of ActiveDirectory</a></li>
<li><a href="../276599/index.html">What brings the idea (Objective-C) - target-action on the blocks and a lot of runtime</a></li>
<li><a href="../276603/index.html">Evgeny Kaspersky spoke about cybercrime at Innopolis University [video]</a></li>
<li><a href="../276607/index.html">Performance and memory profiling from multiple viewing angles</a></li>
<li><a href="../276609/index.html">Package Manager opkg. Offline installation of packages in the root file system image</a></li>
<li><a href="../276613/index.html">Notes of a true architect: just about the most important thing (Part 2)</a></li>
<li><a href="../276617/index.html">Chakra officially adopted by Node.js</a></li>
<li><a href="../276619/index.html">Analysis of Android Malvari Matryoshka</a></li>
<li><a href="../276621/index.html">Mitap SPB .NET Community # 9</a></li>
<li><a href="../276623/index.html">Through a filtering proxy using a script in the name of the moon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>