<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Add range operator in PHP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the picture - Ancient Psychic Tandem War Elephant ¬© Adventure Time 

 This article will discuss the process of implementing a new operator in PHP. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Add range operator in PHP</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/comment_images/267/47f/9aa/26747f9aa08e3c35e15e0bab3e4da469.png" alt="image"><br>  <sub>In the picture - Ancient Psychic Tandem War Elephant ¬© <a href="http://adventuretime.wikia.com/wiki/Ancient_Psychic_Tandem_War_Elephant">Adventure Time</a></sub> <br><br>  This article will discuss the process of implementing a new operator in PHP.  To do this, the following steps will be performed: <br><br><ul><li>  <b>Update of the lexical analyzer</b> : he will know about the syntax of the new operator, which will then allow turning it into a token. </li><li>  <b>Updating the parser</b> : the system will know where this operator can be used, and at the same time what its priority and associativity is. </li><li>  <b>Updating the compilation stage</b> : processing (traverse) the abstract syntax tree (AST) and extracting operation codes from it occurs here. </li><li>  <b>Zend virtual machine update</b> : during script execution, it is used to process the interpretation of a new opcode for an operator. </li></ul><br>  In general, this article will briefly review a few internal aspects of PHP.  I express my deep gratitude to <a href="https://github.com/nikic/">Nikita Popov</a> for help in finalizing this article. <br><a name="habracut"></a><br><h1>  Range operator </h1><br>  This is the name of the operator that we will add to PHP.  It is denoted by two characters: |&gt;.  For the sake of simplicity, its semantics will be defined as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  The increment step will always be equal to one. </li><li>  Operands can be integer or floating point. </li><li>  If min = max, then a singleton array containing min will be returned. </li></ol><br>  These points will be discussed in the last section, <b>‚ÄúUpdating the Zend Virtual Machine,‚Äù</b> when we introduce semantics. <br><br>  If at least one item is not executed, then the <code>Error</code> exception will be thrown.  I.e: <br><br>  If the operand is not integer or floating point. <br>  If min&gt; max. <br>  If the range (max - min) is too large. <br><br>  Examples: <br><br><pre> <code class="php hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> |&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3] 2.5 |&gt; 5; // [2.5, 3.5, 4.5] $a = $b = 1; $a |&gt; $b; // [1] 2 |&gt; 1; // Error exception 1 |&gt; '1'; // Error exception new StdClass |&gt; 1; // Error exception</span></span></code> </pre><br><h1>  Update lexical analyzer </h1><br>  First, you need to register a new token in the analyzer.  This is necessary so that when selecting tokens from the source code to the token <code>T_RANGE</code> , |&gt; is returned.  For this you have to update the file <a href="">Zend / zend_language_scanner.l</a> .  Add the following code to it (in the section where all tokens are declared, approximately the 1200th line): <br><br><pre> <code class="cpp hljs">&lt;ST_IN_SCRIPTING&gt;<span class="hljs-string"><span class="hljs-string">"|&gt;"</span></span> { RETURN_TOKEN(T_RANGE); }</code> </pre><br>  The analyzer is now in <code>ST_IN_SCRIPTING</code> mode.  This means that it will only define a sequence of |&gt; characters.  Between braces is a code on C, which will be executed when it detects |&gt; in the source code.  In this example, the <code>T_RANGE</code> token is <code>T_RANGE</code> . <br><br><blockquote>  <b>Retreat.</b>  If we modify the lexical analyzer, then for its regeneration we need Re2c.  For normal PHP builds, this dependency is not needed. </blockquote><br>  The <code>T_RANGE</code> identifier must be declared in the <a href="">Zend / zend_language_parser.y file</a> .  To do this, add to the end of the section where the remaining token identifiers are declared (approximately line 220): <br><br><pre> <code class="cpp hljs">%token T_RANGE <span class="hljs-string"><span class="hljs-string">"|&gt; (T_RANGE)"</span></span></code> </pre><br>  Now PHP recognizes the new statement: <br><br><pre> <code class="php hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> |&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Parse error: syntax error, unexpected '|&gt;' (T_RANGE) in...</span></span></code> </pre><br>  But since its use is not described, we get a parsing error.  In the next part we will fix it. <br><br>  Now we need to regenerate the <b>ext / tokenizer / tokenizer_data.c file</b> as a <b>tokenizer</b> extension in order to be able to work with the new token.  This extension simply provides an interface between the analyzer and the user environment via the <code>token_get_all</code> and <code>token_name</code> .  At the moment he is in happy ignorance regarding the <code>T_RANGE</code> token: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">echo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">token_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token_get_all(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'&lt;?php 1|&gt;2;'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">][</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// UNKNOWN</span></span></code> </pre><br>  To regenerate <b>ext / tokenizer / tokenizer_data.c,</b> go to the <b>ext / tokenizer folder</b> and execute the tokenizer_data_gen.sh file.  Then go back to the root folder of php-src and rebuild PHP.  Check the extension of the tokenizer: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">echo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">token_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token_get_all(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'&lt;?php 1|&gt;2;'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">][</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// T_RANGE</span></span></code> </pre><br><h1>  Parser update </h1><br>  The parser needs to be updated so that it can check where the new <code>T_RANGE</code> token is used in the PHP scripts.  Also the parser is responsible for: <br><br><ul><li>  prioritization and associativity of the new operator, </li><li>  generating a new node in the abstract syntax tree. </li></ul><br>  All this is done using the <a href="">Zend / zend_language_parser.y</a> grammar file, which contains token declarations and production rules that Bison will use to generate the parser. <br><br><blockquote>  <b>Retreat</b> .  Priority sets the rules for grouping expressions.  For example, in the expression 3 + 4 * 2, the * character has a higher priority than +, therefore the expression will be grouped as 3 + (4 * 2). <br><br>  Associativity describes the behavior of an operator during chain building: whether the operator can be embedded in the chain, and if so, how it will be grouped within a specific expression.  Suppose a ternary operator has left-sided associativity, then it will be grouped and executed from left to right.  That is the expression <br><br> <code>1 ? 0 : 1 ? 0 : 1; // 1</code> <br> <br>  will be executed as <br><br> <code>(1 ? 0 : 1) ? 0 : 1; // 1</code> <br> <br>  If we correct this and prescribe right-sided associativity, the expression will be executed as follows: <br><br> <code>$a = 1 ? 0 : (1 ? 0 : 1); // 0</code> <br> <br>  There are non-associative operators that cannot be embedded in chains at all.  Let's say the&gt; operator.  So this expression will be erroneous: <br><br> <code>1 &lt; $a &lt; 2;</code> </blockquote> <br>  Since the range operator will perform calculations in an array, it will be meaningless to use it as an operand for yourself (for example, 1 |&gt; 3 |&gt; 5).  So let's make it non-associative.  At the same time, we assign it the same priority as the combined comparison operator ( <code>T_SPACESHIP</code> ).  This is done by adding the token <code>T_RANGE</code> to the end of the next line (approximately 70th): <br><br><pre> <code class="cpp hljs">%nonassoc T_IS_EQUAL T_IS_NOT_EQUAL T_IS_IDENTICAL T_IS_NOT_IDENTICAL T_SPACESHIP T_RANGE</code> </pre><br>  Now, to work with the new operator, you need to update the rule <code>expr_without_variable</code> .  Add the following code to it (for example, right before the rule <code>T_SPACESHIP</code> , approximately the 930th line): <br><br><pre> <code class="cpp hljs">| expr T_RANGE expr { $$ = zend_ast_create(ZEND_AST_RANGE, $<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre><br>  Symbol |  used as <b>or</b> .  This means that any of the listed rules may comply.  If a match is found, the code inside the curly brackets will be executed.  $$ refers to the result node where the value of the expression is stored.  The <code>zend_ast_create</code> function <code>zend_ast_create</code> used to create our AST node for a new operator.  The node name is <code>ZEND_AST_RANGE</code> , it contains two values: $ 1 refers to the left operand ( <b>expr</b> T_RANGE expr), $ 3 refers to the right operand (expr T_RANGE <b>expr</b> ). <br><br>  Now we need to set the AST constant <code>ZEND_AST_RANGE</code> .  To do this, update the <a href="">Zend / zend_ast.h file</a> by simply adding a constant under the list of two child nodes (for example, under <code>ZEND_AST_COALESCE</code> ): <br><br><pre> <code class="cpp hljs">ZEND_AST_RANGE,</code> </pre><br>  Now the execution of our range operator will only suspend the interpreter: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> |&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><h1>  Compile Update </h1><br>  As a result of the parser, we get the AST tree, which is then viewed in reverse order.  Initialization of the execution of functions is carried out as you visit each node of the tree.  The initialized functions send operation codes that are later interpreted by the Zend virtual machine. <br><br>  Compilation is done in <a href="">Zend / zend_compile.c</a> .  Let's add the name of our new AST node ( <code>ZEND_AST_RANGE</code> ) to the large branch operator in the <code>zend_compile_expr</code> function (for example, immediately after <code>ZEND_AST_COALESCE</code> , roughly the <code>ZEND_AST_COALESCE</code> line): <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_AST_RANGE: zend_compile_range(result, ast); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre><br>  Now somewhere in the same file you need to declare the function <code>zend_compile_range</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_compile_range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(znode *result, zend_ast *ast)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* {{{ */</span></span></span><span class="hljs-function"> </span></span>{ zend_ast *left_ast = ast-&gt;child[<span class="hljs-number"><span class="hljs-number">0</span></span>]; zend_ast *right_ast = ast-&gt;child[<span class="hljs-number"><span class="hljs-number">1</span></span>]; znode left_node, right_node; zend_compile_expr(&amp;left_node, left_ast); zend_compile_expr(&amp;right_node, right_ast); zend_emit_op_tmp(result, ZEND_RANGE, &amp;left_node, &amp;right_node); } <span class="hljs-comment"><span class="hljs-comment">/* }}} */</span></span></code> </pre><br>  Let's start with dereferencing the left and right operands of the <code>ZEND_AST_RANGE</code> node into the <code>left_ast</code> and <code>right_ast</code> pointer <code>right_ast</code> .  Next, we declare two znode variables in which the result of compiling the AST nodes of each of the two operands will be stored.  This is the recursive part of processing the tree and compiling its nodes into opcodes. <br><br>  Now, using the <code>zend_emit_op_tmp</code> function, <code>zend_emit_op_tmp</code> generate the <code>ZEND_RANGE</code> with its two operands. <br><br>  Let's briefly discuss the operation codes and their types in order to better understand the meaning of using the <code>zend_emit_op_tmp</code> function. <br><br>  Operation codes are instructions that are executed by the virtual machine.  Each of them has: <br><br><ul><li>  Name (integer constant). </li><li>  The node op1 (optional). </li><li>  The op2 node (optional). </li><li>  Result node (optional).  Usually used to store the temporary value of the operation, which corresponds to the code. </li><li>  Extended value (optional).  This is an integer value used to distinguish between forms of behavior for overloaded opcodes. </li></ul><br><blockquote>  <b>Retreat</b> .  Opcodes for PHP scripts can be found using: <br><br><ul><li>  PHPDBG: <code>sapi/phpdbg/phpdbg -np* program.php</code> </li><li>  Opcache </li><li>  <a href="https://pecl.php.net/package/vld">Vulcan Logic Disassembler (VLD)</a> Extensions: <code>sapi/cli/php -dvld.active=1 program.php</code> </li><li>  If the script is short and simple, then you can use <a href="https://3v4l.org/">3v4l</a> </li></ul></blockquote><br>  <code>znode_op</code> nodes ( <code>znode_op</code> structures) can be of different types: <br><br><ul><li>  <code>IS_CV</code> ( <b>C</b> ompiled <b>V</b> ariables).  These are simple variables (like $ a), cached in simple arrays to bypass searches in a hash table.  They appeared in PHP 5.1 as the optimization of compiled variables (Compiled Variables).  In VLD, they are denoted by! N (n is an integer). </li><li>  <code>IS_VAR</code> .  For all complex expressions that play the role of variables (like $ a-&gt; b).  May contain <code>zval IS_REFERENCE</code> , in VLD are denoted by $ n (n is integer). </li><li>  <code>IS_CONST</code> .  For literal values ‚Äã‚Äã(for example, explicitly spelled strings). </li><li>  <code>IS_TMP_VAR</code> .  Temporary variables are used to store the intermediate result of an expression (and therefore not for long).  They can participate in reference counting (refcount) (in PHP 7), but cannot contain <code>zval IS_REFERENCE</code> , because temporary variables cannot be used as references.  In VLD, denoted by ~ n (n is integer). </li><li>  <code>IS_UNUSED</code> .  Usually used to designate an op node as unused.  But sometimes <code>znode_op.num</code> can store data for use by the virtual machine. </li></ul><br>  This brings us back to the function <code>zend_emit_op_tmp</code> , which will generate a <code>zend_op</code> type <code>IS_TMP_VAR</code> .  We need this because our operator will be an expression, and the value (array) produced by it will be a temporary variable that can be used as an operand for another opcode (for example, <code>ASSIGN</code> from <code>$var = 1 |&gt; 3;</code> ). <br><br><h1>  Zend Virtual Machine Update </h1><br>  To handle the execution of our new opcode, you need to update the virtual machine.  This involves updating the <b>zend / zend_vm_def.h file</b> .  Add to the very end: <br><br><pre> <code class="cpp hljs">ZEND_VM_HANDLER(<span class="hljs-number"><span class="hljs-number">182</span></span>, ZEND_RANGE, CONST|TMP|VAR|CV, CONST|TMP|VAR|CV) { USE_OPLINE zend_free_op free_op1, free_op2; zval *op1, *op2, *result, tmp; SAVE_OPLINE(); op1 = GET_OP1_ZVAL_PTR_DEREF(BP_VAR_R); op2 = GET_OP2_ZVAL_PTR_DEREF(BP_VAR_R); result = EX_VAR(opline-&gt;result.var); <span class="hljs-comment"><span class="hljs-comment">// if both operands are integers if (Z_TYPE_P(op1) == IS_LONG &amp;&amp; Z_TYPE_P(op2) == IS_LONG) { // for when min and max are integers } else if ( // if both operands are either integers or doubles (Z_TYPE_P(op1) == IS_LONG || Z_TYPE_P(op1) == IS_DOUBLE) &amp;&amp; (Z_TYPE_P(op2) == IS_LONG || Z_TYPE_P(op2) == IS_DOUBLE) ) { // for when min and max are either integers or floats } else { // for when min and max are neither integers nor floats } FREE_OP1(); FREE_OP2(); ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION(); }</span></span></code> </pre><br>  The opcode number should be one greater than the previous maximum value, so you can take 182. To quickly find out the last maximum number, look in the <b>Zend / zend_vm_opcodes.h file</b> , there is a constant <code>ZEND_VM_LAST_OPCODE</code> at the end. <br><br><blockquote>  <b>Retreat</b> .  The above code contains several pseudo- <code>USE_OPLINE</code> ( <code>USE_OPLINE</code> and <code>GET_OP1_ZVAL_PTR_DEREF</code> ).  These are not real C-macros during the generation of the virtual machine, they are replaced by the <b>Zend / zend_vm_gen.php script</b> , unlike the procedure performed by the preprocessor during the compilation of the source code.  So if you want to see their definitions, then refer to the <b>Zend / zend_vm_gen.php file</b> . </blockquote><br>  The <code>ZEND_VM_HANDLER</code> contains the definition of each opcode.  It can have five parameters: <br><br><ol><li>  Opcode number (182). </li><li>  Opcode name ( <code>ZEND_RANGE</code> ). </li><li>  The correct types of the left operand (CONST | TMP | VAR | CV) (see <code>$vm_op_decode</code> in <b>Zend / zend_vm_gen.php</b> ). </li><li>  The correct types of the right operand (CONST | TMP | VAR | CV) (see <code>$vm_op_decode</code> in <b>Zend / zend_vm_gen.php</b> ). </li><li>  An optional extended value flag for overloaded codes (see <code>$vm_ext_decode</code> at <b>Zend / zend_vm_gen.php</b> ). </li></ol><br>  Given the above, we can see: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// CONST enables for 1 |&gt; 5.0; // TMP enables for (2**2) |&gt; (1 + 3); // VAR enables for $cmplx-&gt;var |&gt; $var[1]; // CV enables for $a |&gt; $b;</span></span></code> </pre><br><blockquote>  <b>Retreat</b> .  If one or both operands are not used, they are marked with ANY. </blockquote><br><blockquote>  <b>Retreat</b> .  <code>TMPVAR</code> appeared in ZE 3. It handles the same types of opcode nodes as <code>TMP|VAR</code> , but generates different code.  <code>TMPVAR</code> generates one method for processing <code>TMP</code> and <code>VAR</code> , which reduces the size of the virtual machine, but requires more conditional logic.  And <code>TMP|VAR</code> generates separate methods for processing <code>TMP</code> and <code>VAR</code> , which increases the size of the virtual machine, but requires less conditional structures. </blockquote><br>  We turn to the "body" of our definition of opcode.  We start by calling the <code>USE_OPLINE</code> pseudo- <code>USE_OPLINE</code> to declare the variable opline (zend_op structure).  It will be used to read operands (using pseudo- <code>GET_OP1_ZVAL_PTR_DEREF</code> like <code>GET_OP1_ZVAL_PTR_DEREF</code> ) and prescribe the return value of the opcode. <br><br>  Next, we declare two variables <code>zend_free_op</code> .  These are simple <a href="">zval pointers</a> declared for each operand we use.  They are needed during the test, if an operand needs release.  Then we declare four <code>zval. op1</code> variables <code>zval. op1</code>  <code>zval. op1</code> and <code>op2</code> pointers to these <code>zval</code> 's, they contain operand values.  We declare the <code>result</code> variable to store the results of the opcode operation.  Finally, we declare <code>tmp</code> to store the intermediate value of a looping operation in a range (range looping operation).  This value will be copied to the hash table at each iteration. <br><br>  The variables <code>op1</code> and <code>op2</code> initialized with the pseudo- <code>GET_OP1_ZVAL_PTR_DEREF</code> and <code>GET_OP2_ZVAL_PTR_DEREF</code> .  Also, these macros are responsible for <a href="http://lxr.php.net/xref/PHP_7_0/Zend/zend_vm_gen.php">initializing the variables free_op1 and free_op2</a> .  The constant <code>BP_VAR_R</code> passed to the above macros is a type flag.  Its name stands for <i>BackPatching Variable Read</i> , which is used when <a href="">reading compiled variables</a> .  And in the end we dereference <code>opline</code> and assign <code>result</code> its value for further use. <br><br>  Now let's fill in the ‚Äúbody‚Äù of the first <code>if</code> , provided that <code>min</code> and <code>max</code> are integers: <br><br><pre> <code class="cpp hljs">zend_long min = Z_LVAL_P(op1), max = Z_LVAL_P(op2); zend_ulong size, i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min &gt; max) { zend_throw_error(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"Min should be less than (or equal to) max"</span></span>); HANDLE_EXCEPTION(); } <span class="hljs-comment"><span class="hljs-comment">// calculate size (one less than the total size for an inclusive range) size = max - min; // the size cannot be greater than or equal to HT_MAX_SIZE // HT_MAX_SIZE - 1 takes into account the inclusive range size if (size &gt;= HT_MAX_SIZE - 1) { zend_throw_error(NULL, "Range size is too large"); HANDLE_EXCEPTION(); } // increment the size to take into account the inclusive range ++size; // set the zval type to be a long Z_TYPE_INFO(tmp) = IS_LONG; // initialise the array to a given size array_init_size(result, size); zend_hash_real_init(Z_ARRVAL_P(result), 1); ZEND_HASH_FILL_PACKED(Z_ARRVAL_P(result)) { for (i = 0; i &lt; size; ++i) { Z_LVAL(tmp) = min + i; ZEND_HASH_FILL_ADD(&amp;tmp); } } ZEND_HASH_FILL_END(); ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();</span></span></code> </pre><br>  We begin by defining the variables <code>min</code> and <code>max</code> .  They are declared as <code>zend_long</code> , which should be used when declaring long integers (just like <code>zend_ulong</code> used to define long integers without a sign).  The size is then declared using <code>zend_ulong</code> , which contains the size of the array to be generated. <br><br>  Next, a check is performed: if <code>min &gt; max</code> , an <code>Error</code> exception is thrown.  If you pass <code>Null</code> as the first argument in <code>zend_throw_error</code> , the default exception class is <code>Error</code> .  With inheritance, you can fine-tune this exception by creating a new class entry in <a href="">Zend / zend_exceptions.c</a> .  But we will talk more about this another time.  If this exception occurs, we call the pseudo- <code>HANDLE_EXCEPTION</code> , which proceeds to the execution of the next opcode. <br><br>  Now we calculate the size of the array to be generated.  It should be one less than the actual size, since there is a chance of overflow if <code>min = ZEND_LONG_MIN (PHP_INT_MIN)</code> and <code>max = ZEND_LONG_MAX (PHP_INT_MAX)</code> . <br><br>  After that, the calculated size is compared with the constant <code>HT_MAX_SIZE</code> to make sure that the array <code>HT_MAX_SIZE</code> into the hash table.  The total size of the array must not be greater than or equal to <code>HT_MAX_SIZE</code> .  Otherwise, we again generate an <code>Error</code> exception and exit the virtual machine. <br><br>  We know that <code>HT_MAX_SIZE = INT_MAX + 1</code> .  If the resulting value is greater than <code>size</code> , then we can increase the latter without fear of overflow.  This is what we take as the next step so that the <code>size</code> value matches the size of the range. <br><br>  Now we change the type of the zval <code>tmp  IS_LONG</code> .  Then, using the macro <code>array_init_size</code> initialize <code>result</code> .  This macro assigns the <code>result'</code> type <code>IS_ARRAY_EX</code> , allocates memory for the <code>zend_array</code> structure (hash table), and sets up the corresponding hash table.  Then, the <code>zend_hash_real_init</code> function allocates memory for the Bucket structures containing each element of the array.  The second argument, 1, indicates that we want to make it a packed hash table (packed hashtable). <br><br><blockquote>  <b>Retreat</b> .  A packed hash table is essentially an actual array, that is, an array that is accessed using integer keys (as opposed to typical associative arrays in PHP).  This optimization was implemented in PHP 7. The reason for this innovation is that in PHP, many arrays are indexed with integers (keys in ascending order).  Packed hash tables provide direct access to the hash table pool.  If you are interested in the details of the new implementation of hash tables, then refer to the <a href="http://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html">article by Nikita</a> . </blockquote><br><blockquote>  <b>Retreat</b> .  The <code>_zend_array</code> structure has two <code>zend_array</code> : <code>zend_array</code> and <code>HashTable</code> . </blockquote><br>  Fill the array with the macro <code>ZEND_HASH_FILL_PACKED</code> ( <a href="">definition</a> ), which essentially keeps track of the current bucket for later insertion.  During array generation, the intermediate result (array element) is stored in zval'e <code>tmp</code> .  The macro <code>ZEND_HASH_FILL_ADD</code> creates a copy of <code>tmp</code> , inserts it into the current bucket of the hash table, and proceeds to the next bucket for the next iteration. <br><br>  Finally, the <code>ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION</code> macro (appeared in ZE 3 as a replacement for the individual <code>CHECK_EXCEPTION()</code> and <code>ZEND_VM_NEXT_OPCODE()</code> calls embedded in ZE 2) checks if an exception has occurred.  It did not occur, and the virtual machine moves to the next opcode. <br><br>  Let's now consider the <code>else if</code> block: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min, max, size, i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Z_TYPE_P(op1) == IS_LONG) { min = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) Z_LVAL_P(op1); max = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) Z_DVAL_P(op2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Z_TYPE_P(op2) == IS_LONG) { min = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) Z_DVAL_P(op1); max = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) Z_LVAL_P(op2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { min = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) Z_DVAL_P(op1); max = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) Z_DVAL_P(op2); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min &gt; max) { zend_throw_error(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"Min should be less than (or equal to) max"</span></span>); HANDLE_EXCEPTION(); } size = max - min; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt;= HT_MAX_SIZE - <span class="hljs-number"><span class="hljs-number">1</span></span>) { zend_throw_error(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"Range size is too large"</span></span>); HANDLE_EXCEPTION(); } <span class="hljs-comment"><span class="hljs-comment">// we cast the size to an integer to get rid of the decimal places, // since we only care about whole number sizes size = (int) size + 1; Z_TYPE_INFO(tmp) = IS_DOUBLE; array_init_size(result, size); zend_hash_real_init(Z_ARRVAL_P(result), 1); ZEND_HASH_FILL_PACKED(Z_ARRVAL_P(result)) { for (i = 0; i &lt; size; ++i) { Z_DVAL(tmp) = min + i; ZEND_HASH_FILL_ADD(&amp;tmp); } } ZEND_HASH_FILL_END(); ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();</span></span></code> </pre><br><blockquote>  <b>Retreat</b> .  We use <code>long double</code> in cases where simultaneous use of integer operands and floating point is possible.  The fact is that <code>double</code> precision is only 53 bits, so when using this type, any integer greater than 2 <sup>53</sup> will not be accurately represented.  And a <code>long double</code> accuracy of at least 64 bits, so that it allows you to accurately use 64-bit integers. </blockquote><br>  The above code is very similar in logic to the previous one.  The main difference is that we now process the data as floating-point numbers.  It belongs: <br><br><ol><li>  to get them from the macro <code>Z_DVAL_P</code> , </li><li>  assignment of type <code>IS_DOUBLE  tmp</code> , </li><li>  and also to insert zval'a (type double) with the help of macro <code>Z_DVAL</code> . </li></ol><br>  Finally, we need to handle cases in which either <code>min</code> , <code>max</code> , or both are neither integer nor floating point.  As stated in the second paragraph of the semantics of our range operator, only integer and floating point are supported as operands.  In all other cases, the exception <code>Error</code> should be thrown.  Let's insert the following code in the <code>else</code> block: <br><br><pre> <code class="cpp hljs">zend_throw_error(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported operand types - only ints and floats are supported"</span></span>); HANDLE_EXCEPTION();</code> </pre><br>  Now we have finished defining our opcode, it's time to regenerate the virtual machine.  To do this, we run the <b>Zend / zend_vm_gen.php file</b> , and he will use the <b>Zend / zend_vm_def.h file</b> to regenerate <b>Zend / zend_vm_opcodes.h</b> , <b>Zend / zend_vm_opcodes.c</b> and <b>Zend / zend_vm_execute.h</b> . <br><br>  We will rebuild PHP to make sure that our range operator works: <br><br><pre> <code class="cpp hljs">var_dump(<span class="hljs-number"><span class="hljs-number">1</span></span> |&gt; <span class="hljs-number"><span class="hljs-number">1.5</span></span>); var_dump(PHP_INT_MIN |&gt; PHP_INT_MIN + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Output: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">-9223372036854775808</span></span>) [<span class="hljs-number"><span class="hljs-number">1</span></span>]=&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">-9223372036854775807</span></span>) }</code> </pre><br>   - !     .   pretty printer   AST (    ). Pretty printer       ,       <code>assert()</code> : <br><br><pre> <code class="cpp hljs">assert(<span class="hljs-number"><span class="hljs-number">1</span></span> |&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// segfaults</span></span></code> </pre><br><blockquote> <b></b> .   <code>assert()</code>  pretty printer   ,          .      ,         (  pretty printer  ).  ,     PHP 7. </blockquote><br>   ,       <a href="">Zend/zend_ast.c</a> ,   <code>ZEND_AST_RANGE</code>  .       ( 520- ),      170 (    zend_language_parser.y): <br><br><pre> <code class="cpp hljs">* <span class="hljs-number"><span class="hljs-number">170</span></span> non-associative == != === !== |&gt;</code> </pre><br><br>    <code>ZEND_AST_RANGE</code>    <code>zend_ast_export_ex</code>  <code>case</code> (  case <code>ZEND_AST_GREATER</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_AST_RANGE: BINARY_OP(<span class="hljs-string"><span class="hljs-string">" |&gt; "</span></span>, <span class="hljs-number"><span class="hljs-number">170</span></span>, <span class="hljs-number"><span class="hljs-number">171</span></span>, <span class="hljs-number"><span class="hljs-number">171</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_AST_GREATER: BINARY_OP(<span class="hljs-string"><span class="hljs-string">" &gt; "</span></span>, <span class="hljs-number"><span class="hljs-number">180</span></span>, <span class="hljs-number"><span class="hljs-number">181</span></span>, <span class="hljs-number"><span class="hljs-number">181</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ZEND_AST_GREATER_EQUAL: BINARY_OP(<span class="hljs-string"><span class="hljs-string">" &gt;= "</span></span>, <span class="hljs-number"><span class="hljs-number">180</span></span>, <span class="hljs-number"><span class="hljs-number">181</span></span>, <span class="hljs-number"><span class="hljs-number">181</span></span>);</code> </pre><br>  pretty printer   <code>assert()</code>  : <br><br><pre> <code class="cpp hljs">assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; <span class="hljs-number"><span class="hljs-number">1</span></span> |&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Warning: assert(): assert(false &amp;&amp; 1 |&gt; 2) failed...</span></span></code> </pre><br><h1>  Conclusion </h1><br>      ,    .  ,     Zend   PHP-,                PHP  .           . ,         ‚Äî ,  ‚Äî ,        (,    ). </div><p>Source: <a href="https://habr.com/ru/post/276331/">https://habr.com/ru/post/276331/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276321/index.html">Multiprocess Firefox 44.b, Electrolysis Optimization</a></li>
<li><a href="../276323/index.html">Migrate NAS from vfiler NetApp to EMC VNX</a></li>
<li><a href="../276325/index.html">Attackers use Gcat backdoor for cyber attacks on Ukrainian energy companies</a></li>
<li><a href="../276327/index.html">Linux kernel support 2.6.32 LTS ends in February</a></li>
<li><a href="../276329/index.html">Quantum morris</a></li>
<li><a href="../276333/index.html">Using or Using?</a></li>
<li><a href="../276335/index.html">HPE Aruba - Corporate-grade Wi-Fi</a></li>
<li><a href="../276339/index.html">Taming of the Shrew</a></li>
<li><a href="../276341/index.html">Microsoft Azure Stack TP1</a></li>
<li><a href="../276343/index.html">BlueZ bracelet control</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>