<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>React Component Testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ovidiu Chereshes, the author of the article, the translation of which we are publishing today, wrote thousands of tests of user interfaces. He says th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>React Component Testing</h1><div class="post__text post__text-html js-mediator-article">  Ovidiu Chereshes, the author of the article, the translation of which we are publishing today, wrote thousands of tests of user interfaces.  He says that testing should instill in the developer confidence that his programs work exactly as he expects, and that they will continue to do their work even after they are modified and expanded.  However, testing user interfaces seldom gives confidence.  Instead, it often leads to frustration and thoughts about the unproductiveness of program work. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/784/656/3c3784656e9e51204bd864351f55d32e.png" alt="image"></div><br>  He says that he raises the question of testing interfaces written in React, since he has encountered problems typical of this process years before the wide distribution of this framework, and spent a lot of time solving them.  He thinks that he was able to find the tools and working methods that make testing React components as simple as creating them. <br><br>  He will begin the story with two basic principles, understanding of which is important for finding the right approach to testing, further examples will be given and one useful tool will be presented that can make life easier for those who have to test React applications. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF"><b>Principle # 1:</b> consider the failure of abstraction component = f (props, state)</font> </h2><br>  In theory, the construction given in the title looks beautiful, however, everything goes awry, if, relying on this abstraction, try to test the real components.  As soon as you try to separately load the component, the following becomes clear: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs lisp">component=f(<span class="hljs-name"><span class="hljs-name">props</span></span>, state, context)</code> </pre> <br>  Or, more precisely, it turns out like this: <br><br><pre> <code class="hljs lisp">component=f(<span class="hljs-name"><span class="hljs-name">props</span></span>, state, Redux, Router, Theme, Intl, etc)</code> </pre> <br>  However, even such a construction is still far from reality.  Namely, this is what it is about: <br><br><pre> <code class="hljs lisp">component=f(<span class="hljs-name"><span class="hljs-name">props</span></span>, state, context, globals)</code> </pre> <br>  Of course, these are not global variables, perhaps only some monster will use them.  I mean global APIs. <br><br><pre> <code class="hljs pgsql">component=f(props, state, context, <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>, localStorage, <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> size)</code> </pre> <br>  As you can see, the reality is much more interesting than the theory. <br><br>  Testing React components is a matter that involves the constant solution of complex problems.  However, very few say about this.  Official examples of testing are shown on the simplest components, but as for the "monsters" of the world of components, they mostly do not write anything.  Today, together we will look at these monsters in the eye and talk about a new simple API that allows you to "pacify" any component and perfectly combines with existing tools like Jest and Enzyme. <br><br>  The above text is a fragment of a speech with which I once wanted to get to the conference.  I did not get there (it is appropriate to include sad music here), but every word here matters and I still want to talk about it. <br><br>  The following examples, by default, use Jest and Enzyme, but neither the one nor the other is necessary to apply the techniques that I will discuss. <br><br><h2>  <font color="#3AC1EF">Simple sample test</font> </h2><br>  The usual test case you can come across is quite simple.  Perhaps this is a button with a callback function: <br><br><pre> <code class="hljs lisp">const UnrealisticComponent = ({ onReply }) =&gt; ( <span class="hljs-name"><span class="hljs-name">&lt;button</span></span> onClick={() =&gt; onReply('Ja')}&gt;Alles gut?&lt;/button&gt; )</code> </pre> <br>  Now let's check if the component works as expected from it: <br><br><pre> <code class="hljs pgsql">const onReply = jest.fn(); const <span class="hljs-keyword"><span class="hljs-keyword">wrapper</span></span> = shallow(&lt;UnrealisticComponent onReply={onReply} /&gt;) test(<span class="hljs-string"><span class="hljs-string">'kindly asks if everything is alright'</span></span>, () =&gt; { expect(<span class="hljs-keyword"><span class="hljs-keyword">wrapper</span></span>.text()).toBe(<span class="hljs-string"><span class="hljs-string">'Alles gut?'</span></span>) }) test(<span class="hljs-string"><span class="hljs-string">'receives positive response upon click'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">wrapper</span></span>.find(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).simulate(<span class="hljs-string"><span class="hljs-string">'click'</span></span>) expect(onReply).toHaveBeenCalledWith(<span class="hljs-string"><span class="hljs-string">'Ja'</span></span>) })</code> </pre> <br>  As you can see, everything is very simple and clear, and the component is quite trivial.  However, everything changes if you try to test this component.  Imagine the simplest component used for authentication, which has a field for entering a username and a submit button.  In the field enter the name, click on the button, this causes the query <code>fetch</code> with the entered data.  The request is completed, the name is transferred to the Redux storage and cached in <code>localStorage</code> .  In general, all this is also not so difficult. <br><br>  Now we will try to send this component to the test rendering.  Unfortunately, the test will not even start.  We will see the following: <br><br><pre> <code class="hljs pgsql">Could <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> find "store" <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> either the context <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> props <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Connect</span></span>‚Ä¶ ReferenceError: <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> defined ReferenceError: localStorage <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> defined</code> </pre> <br>  Usually at such times programmers call on the higher forces for help. <br><br>  Here you can point out that this example is conditional, and that in a serious application there would be some kind of abstraction for authentication, which should be tested.  However, as we will soon see, this has nothing to do with component testing.  We need the ability to write tests that, when used for multilevel tests of an evolving application, do not have to be rewritten all the time. <br><br>  At the moment, based on your experience, you can make two serious observations to the above example: <br><br><ol><li>  Are you really testing ‚Äúcontainers‚Äù? <br></li><li>  Do your components interact with global APIs (fetch, for example)? <br></li></ol><br>  Yes.  Why not?  And besides, I do not use shallow rendering. This brings us to the following principle. <br><br><h2>  <font color="#3AC1EF"><b>Principle number 2:</b> remember the dangers of auxiliary elements of the application, linking its components together</font> </h2><br>  Components, even when using a simple component model of React, are complex entities that are far from normal functions.  Therefore, there is a temptation to allocate them into separate modules, making them as isolated as possible from the rest of the systems.  However, the smaller these modules, the more code is needed to tie the project together, and the more room is open for integration errors. <br><br>  For example, we usually export components without their wrappers, in order to test only the components themselves.  This state of affairs is considered normal, as higher-order components have already been tested and we can test their internal mechanisms.  We test reducers, actions and selectors.  What can I say, you should even <code>mapStateToProps</code> and <code>mapDispatchToProps</code> to ensure that the project code is as completely as possible.  I, at one time, followed a similar approach, but once I understood its main shortcomings.  Here they are: <br><br><ul><li>  Testing takes more effort than implementation.  Here you can only wish good luck to new developers.  On the first day, they will write their first component, and it will take them another three days to write tests for it. <br></li><li>  Testing prevents refactoring.  For me, this is probably the main problem.  In the process of writing code, we often, as they say, dig a grave for ourselves, and there is no better way to turn a typical project into a rigid unwieldy structure than meticulous testing of each function. <br></li><li>  Increases the likelihood of errors.  It is enough to forget to test some trifle (like some kind of selector) and the whole component may not work properly, although the tests it passes are normal. <br></li><li>  Unsynchronized input and output data.  A component can correctly respond to some properties, and <code>mapStateToProps</code> can produce the correct data based on a certain state, but the exported component will fail if its input and output data do not match. <br></li></ul><br>  It is tempting, in search of comfort, to turn to neat little modules.  But if we test only the basic parts of the application, we lose sight of the complexity of the project - the very connecting parts, thanks to which it works.  In addition, the programmer may succumb to the attractive idea of ‚Äã‚Äãtransferring concern for testing the integration of components to other professionals, such as those involved in quality control.  However, end-to-end testing is a ‚Äúairbag‚Äù that operates at a much higher level. <br><br>  The fewer subsystems that bind the application together, are left outside of the component tests, the more I am sure that the testing is correct, and, besides, the reusability of the modules that make up the application.  A real module is one that we plan, for example, to transfer and reuse to someone.  It carries a certain meaning for the end user.  It is precisely such constructions that we need to test, and not what is easier to test. <br><br>  However, what about the complexity of setting up a test environment? <br><br><h2>  <font color="#3AC1EF">About the component testing environment</font> </h2><br>  Most of the code in the test files and most of the effort involved in preparing them is set up by the providers and the layout data for the ‚Äúintelligent‚Äù components.  Writing statements is, after connecting the components, a trifle.  In this regard, I have a question: how to simplify the setup of the test environment and give developers the opportunity to deal, mainly, in creating statements to test the behavior of components?  If only there was a simple way to simulate the states of the components, supplying some conditional data to their inputs ... <br><br>  And, in fact, there is such a way.  Infrastructure elements (fixtures) of the <a href="https://github.com/react-cosmos/react-cosmos">Cosmos</a> library are designed to simulate any input values ‚Äã‚Äãand render the component in any combination of states.  And, since all this has been used for a long time only in the Playground interface, it becomes obvious that the use of Cosmos, in addition, can replace the complex setup of the test environment.  Before us, as a result, something like the sentence ‚Äútwo in one‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/430/fea/df1/430feadf14684d2e2b0d8f168913c39e.png"><br>  <i><font color="#999999">Cosmos playground</font></i> <br><br><h2>  <font color="#3AC1EF">Cosmos library features</font> </h2><br>  First, let's remember what the JSX tags look like (or how the <code>React.createElement</code> command <code>React.createElement</code> ). <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">disabled</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{true}</span></span></span><span class="hljs-tag">&gt;</span></span>Click me maybe<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Before us is an ad.  In this case, it reads like this: we need a <code>Button</code> element (button) with <code>{ disabled: true }</code> properties and a <code>Click me maybe</code> child object. <br><br>  Cosmos infrastructure elements can be thought of as something like the ‚Äústeroid-charged‚Äù components of React.  In addition to information about the components, properties, and child objects, such elements can receive data about the local state, the state of Redux, or the URL of the router.  In addition, infrastructure elements can mimic the <code>fetch</code> , <code>XHR</code> or <code>localStorage</code> . <br><br>  All of these features are available through plug-ins that make the infrastructure elements a platform for simulating component states. <br><br>  Infrastructure elements are ordinary JS objects, like this: <br><br><pre> <code class="hljs pgsql">{ props: {} url: <span class="hljs-string"><span class="hljs-string">'/dashboard'</span></span>, localStorage: {   <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Dan'</span></span> }, reduxState: {}, <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>: [   {     matcher: <span class="hljs-string"><span class="hljs-string">'/api/login'</span></span>,     response: {       <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Dan'</span></span>     }   } ] }</code> </pre> <br>  After you get used to writing such code, you will not only get component-oriented development tools, but also greatly simplify your task of writing component tests.  All this will help you recently released <a href="https://github.com/react-cosmos/react-cosmos">Cosmos Test API</a> . <br><br>  Here, for example, looks like testing the Cosmos interface using the Cosmos Test API. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/588/43b/d68/58843bd68df616f9e673c020cd4e44d3.png"><br>  <i><font color="#999999">Testing at Cosmos</font></i> <br><br>  But how does the work with the API look like?  Before trying it, it will be useful to read the <a href="https://github.com/react-cosmos/react-cosmos">documentation</a> . <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> createTestContext <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-cosmos-test/enzyme'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fixture <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./logged-in.fixture'</span></span>; const { mount, getWrapper, get } = createTestContext({ fixture }); beforeEach(mount); test(<span class="hljs-string"><span class="hljs-string">'welcomes logged in user by name'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { expect(getWrapper(<span class="hljs-string"><span class="hljs-string">'.welcome'</span></span>).text()).toContain(<span class="hljs-string"><span class="hljs-string">'Dan'</span></span>); }); test(<span class="hljs-string"><span class="hljs-string">'redirects to home page after signing out'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { getWrapper(<span class="hljs-string"><span class="hljs-string">'.logout-btn'</span></span>).simulate(<span class="hljs-string"><span class="hljs-string">'click'</span></span>); expect(get(<span class="hljs-string"><span class="hljs-string">'url'</span></span>)).toBe(<span class="hljs-string"><span class="hljs-string">'/'</span></span>); });</code> </pre> <br>  All this is done so that, with a minimum number of auxiliary elements, to comply with the standard approaches to testing.  I'm not quite happy with the naming scheme used here, this ‚Äúcontext‚Äù, but I am pleased to inform you that the API has been tested by many programmers and tested at ScribbleLive, which I am currently consulting. <br><br>  And now, so to speak, under a curtain, I will tell a couple of interesting cases from my practice. <br><br>  So, even in already quite mature projects with an established code base, I usually write specialized prototypes when implementing new application components.  Instead of connecting, from the very beginning, to the Redux repository, I can start working from a local state and bring the new functionality to the working level.  More than once, I went to a fully tested prototype and then ported the local state to Redux, without rewriting a single test. <br><br>  Once, the <code>Form</code> component without a state has been used on many screens.  This is a pleasant abstraction, but each instance required a data mapping template and procedures associated with its life cycle.  The project needed refactoring.  I created an abstraction for repeating operations with these forms and called it <code>FormConnect</code> .  After that, I reworked more than a dozen screens without rewriting a single test.  Why?  Because, in terms of software work with them, these screens have not changed. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  As you can see, Cosmos API can significantly improve the situation in the field of complex testing of components of React-projects.  In addition, the pursuit of such a system architecture, during the implementation of which the tests, when making changes to the system, does not have to be constantly rewritten, allows for project flexibility and user experience.  We hope that the ideas of the author of the material and the Cosmos API will be useful to you in testing React-applications. <br><br>  <b>Dear readers!</b>  How do you test projects created using React? </div><p>Source: <a href="https://habr.com/ru/post/345236/">https://habr.com/ru/post/345236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345226/index.html">10 RecSys materials on recommendation systems that everyone should read</a></li>
<li><a href="../345228/index.html">How we raiffeisen.ru redesigned</a></li>
<li><a href="../345230/index.html">Who needs these CRM systems?</a></li>
<li><a href="../345232/index.html">The history of the Nigerian developer: from programming on the button phone to work in the startup MIT</a></li>
<li><a href="../345234/index.html">DIY. Spying on visitors</a></li>
<li><a href="../345238/index.html">10 of the most important English words of 2017 according to Merriam-Webster</a></li>
<li><a href="../345240/index.html">Servlet 4.0: We do more faster. Server push</a></li>
<li><a href="../345242/index.html">How a non-refundable cost error can ruin a game developer</a></li>
<li><a href="../345244/index.html">The backend of the World in Conflict game server is publicly available.</a></li>
<li><a href="../345246/index.html">Finding the 3rd item from the end of a linked list in Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>