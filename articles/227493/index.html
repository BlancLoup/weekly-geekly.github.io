<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mojolicious Documentation: Lost Chapters</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Update: article updated to comply with Mojolicious 6.0. 

 Mojolicious is a great modern Perl web framework. Among the shortcomings, I can name only t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mojolicious Documentation: Lost Chapters</h1><div class="post__text post__text-html js-mediator-article">  <b>Update:</b> article updated to comply with Mojolicious 6.0. <br><br>  <a href="http://mojolicio.us/">Mojolicious</a> is a <a href="http://mojolicio.us/">great</a> modern Perl web framework.  Among the shortcomings, I can name only two: backward compatibility policy and documentation. <br><br>  This series of articles assumes that the reader is already superficially familiar with the framework, and he has a need to understand the details that are either not described in the documentation or described in insufficient detail and understandable.  <a href="http://mojolicio.us/perldoc">Official documentation is</a> <i>ideal</i> for initial familiarization (in English). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Content </h4><br><ol><li>  <a href="https://habr.com/ru/post/227493/">disadvantages</a> </li><li>  <a href="https://habr.com/ru/post/227493/">Routing: internal device</a> </li><li>  <a href="https://habr.com/ru/post/227493/">Routing: setting</a> </li><li>  <a href="https://habr.com/ru/post/227493/">HTTP request options</a> </li><li>  <a href="https://habr.com/ru/post/227493/">Parsing</a> </li><li>  <a href="https://habr.com/ru/post/227493/">Tips &amp; Tricks</a> <br><ol><li>  <a href="https://habr.com/ru/post/227493/">Support for non-blocking CGI applications</a> </li><li>  <a href="https://habr.com/ru/post/227493/">How Mojo :: UserAgent works when testing your application</a> </li><li>  <a href="https://habr.com/ru/post/227493/">ojo and Mojolicious :: Lite</a> </li><li>  <a href="https://habr.com/ru/post/227493/">Environment variables</a> </li></ol><br></li></ol><br><h5>  Other articles in this series </h5><br><ul><li>  <a href="http://habrahabr.ru/post/228141/">Asynchronous: sync using Mojo :: IOLoop :: Delay</a> </li></ul><br><br><a name="shortcomings"></a><h4>  disadvantages </h4><br>  In the official <a href="http://mojolicio.us/perldoc/Mojolicious/Guides/FAQ">FAQ</a> it is written: "... we will always be able to make it out."  For a start, the second phrase contradicts the first.  Further, here is a quote from <a href="http://mojolicio.us/perldoc/Mojolicious/Guides/Contributing">Guides :: Contributing</a> "It can be changed for a period of at least 3 months.".  Honestly, <b>3 months</b> is a ridiculous period when it comes to backward compatibility, but it seems that even this period is not always respected (support for ‚ÄúX-Forwarded-HTTPS‚Äù was made deprecated <a href="https://metacpan.org/source/SRI/Mojolicious-5.0/Changes">two months ago</a> and deleted a <a href="https://metacpan.org/source/SRI/Mojolicious-5.0/Changes">month ago</a> - yes, it was ‚ÄúMajor release‚Äù is therefore not <i>formally</i> broken, but the <i>general relation to backward compatibility</i> is quite significant).  How many developers update the framework more than once every 3 months, and even then carefully read Changes or the logs of their application for deprecated warnings?  At the same time, during the last year approximately 20 functions / features were deprecated.  In practice, of course, everything is not as bad as it sounds - something breaks not so often (for me personally, over the last year only the replacement of <code>$app-&gt;secret()</code> by <code>$app-&gt;secrets()</code> ) has touched me.  But the fact remains - backward compatibility is broken, often broken, and without really good reasons: for example, in the case of <code>secret()</code> nothing prevented adding to the code <pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">secret</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>-&gt;secrets([<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>]) }</code> </pre>  or simply add support for additional parameters to the <code>secret()</code> instead of adding the new function <code>secrets()</code> implementing the necessary feature without breaking the compatibility at all. <br><br>  As for the documentation, many consider it excellent, even one of the serious advantages of Mojolicious, but not a disadvantage.  The problem with documentation is that it‚Äôs all focused on <i>examples.</i>  This is really cool when you start learning the framework.  This saves a lot of time when you need to make a feature and you quickly google an example of a similar feature in the official guides.  But as soon as you go beyond the standard tasks and there is a need to understand how something works ideologically or architecturally, <b>what specific parameters this function can take and what exactly it can return in different situations</b> - it turns out that for many Mojolicious modules such documentation is missing basically.  And not because this information belongs to ‚Äúundocumented possibilities‚Äù - almost all of this is mentioned briefly here and there in various examples, and therefore it is considered ‚Äúdocumented‚Äù.  Often there are <b>several ways to access certain data</b> (request parameters, response body, etc.), but it is not described how they differ from each other and in what situations it is more correct to use in what ways.  And the last - the <b>alphabetical order of the</b> functions in the dock, seriously ?!  No, I understand, all people are different and for sure it is convenient for someone, but it‚Äôs still an order of magnitude easier for many to understand the documentation in which functions are grouped by task.  <i>(Although in the code, especially when reading it through the browser, where it is not so convenient to use the search as in Vim, the alphabetical order of functions suddenly turned out to be quite convenient - except for new / DESTROY / AUTOLOAD - it‚Äôs still better to place them at the beginning.)</i> As a result, to understand you have to read the code (some prefer to watch the tests instead!), which is not so easy - firstly, it is not a standard of readability: the author likes to use pearl chips, which allow you to write code compactly (and often this code works faster), but readability is  worse;  secondly, the active use of both the inheritance and the exchange of events between objects complicates the understanding of what is happening inside the 104 classes that make up Mojolicious-5. <br><br>  With the problem of backward compatibility, we can do little (although, probably, we can make a plugin for Mojolicious, which will emulate it as far as possible).  But the second problem is not difficult to solve - you can write the missing documentation yourself.  As I study Mojolicious, I plan to describe some things that, in an amicable way, should be in the official documentation, hence the name of this article. <br><a name="habracut"></a><br><h4>  $ self </h4><br>  In Mojolicious documentation, <code>$self</code> often used, which does not add readability ‚Äî there are too many classes in the framework, and not always looking at <code>$self</code> it is easy to figure out which class this object is in this example.  Therefore, I will use instead of <code>$self</code> in the examples: <br><pre> <code class="perl hljs">$app <span class="hljs-comment"><span class="hljs-comment"># YourApp ‚Üí Mojolicious $r # Mojolicious::Routes ($app-&gt;routes) $c # YourApp::SomeController ‚Üí Mojolicious::Controller $ua # Mojo::UserAgent</span></span></code> </pre><br><a name="routing_internals"></a><h4>  Routing: internal device </h4><br>  The first thing you need to understand about the device routing in Mojolicious is that it is implemented as a tree of nodes, and the structure of this tree is (almost) in no way connected with the hierarchy of the path in the url.  Consider an example: <br><pre> <code class="perl hljs">$r-&gt;get(<span class="hljs-string"><span class="hljs-string">"/a/b/c/d"</span></span>) -&gt;to(<span class="hljs-string"><span class="hljs-string">text=&gt;</span></span><span class="hljs-string"><span class="hljs-string">"1"</span></span>); $ab = $r-&gt;route(<span class="hljs-string"><span class="hljs-string">"/a"</span></span>)-&gt;route(<span class="hljs-string"><span class="hljs-string">"/b"</span></span>); $ab-&gt;get(<span class="hljs-string"><span class="hljs-string">"/c"</span></span>) -&gt;to(<span class="hljs-string"><span class="hljs-string">text=&gt;</span></span><span class="hljs-string"><span class="hljs-string">"2-1"</span></span>); $ab-&gt;get(<span class="hljs-string"><span class="hljs-string">"/c/d"</span></span>) -&gt;to(<span class="hljs-string"><span class="hljs-string">text=&gt;</span></span><span class="hljs-string"><span class="hljs-string">"2-2"</span></span>); $r-&gt;get(<span class="hljs-string"><span class="hljs-string">"/a/b/c/d/e"</span></span>) -&gt;to(<span class="hljs-string"><span class="hljs-string">text=&gt;</span></span><span class="hljs-string"><span class="hljs-string">"3"</span></span>);</code> </pre><br>  As a result, the following tree will be built: <br><pre> $ r {}
  ‚îú‚îÄ / a / b / c / d {text =&gt; "1"}
  ‚îú‚îÄ / a‚îÄ‚îÄ‚îÄ / b‚îÄ‚î¨‚îÄ / c {text =&gt; "2-1"}
  ‚îÇ ‚îî‚îÄ / c / d {text =&gt; "2-2"}
  ‚îî‚îÄ / a / b / c / d / e {text =&gt; "3"}
</pre><br>  And this is how it will work: <br><pre> GET / a / b =&gt; 404 Not Found
 GET / a / b / c =&gt; "2-1"
 GET / a / b / c / d =&gt; "1"
 GET / a / b / c / d / e =&gt; "3"
 GET / a / b / c / d / e / f =&gt; 404 Not Found
</pre><br>  As you can guess, the tree is scanned sequentially (inwards), until the first successful match with the current query - so if you have nodes in the routing definition that match the same queries, then watch carefully where they are in the order, in which they coincide with queries, it may not coincide with the order in which they are written in code. <br><br>  The second thing you need to understand is that only leaves (terminal nodes) of the tree will process incoming requests, all intermediate (internal) nodes will not process requests, regardless of how they were created (via <code>route()</code> , normal <code>get()</code> , etc.) and whether the request handler is set for them ( <code>"controller#action"</code> or <code>{cb=&gt;\&amp;handler}</code> , etc.). <br><br>  For example, create a tree using <code>get()</code> : <br><pre> <code class="perl hljs">$r-&gt;get(<span class="hljs-string"><span class="hljs-string">"a"</span></span>, {<span class="hljs-string"><span class="hljs-string">text=&gt;</span></span><span class="hljs-string"><span class="hljs-string">"A"</span></span>})-&gt;get(<span class="hljs-string"><span class="hljs-string">"b"</span></span>, {<span class="hljs-string"><span class="hljs-string">text=&gt;</span></span><span class="hljs-string"><span class="hljs-string">"B"</span></span>});</code> </pre><br><pre> GET / a =&gt; 404 Not Found
 GET / a / b =&gt; "B"
</pre><br>  Or we will not create any nodes at all, but instead simply configure an already existing root node: <br><pre> <code class="perl hljs">$app-&gt;routes-&gt;to(<span class="hljs-string"><span class="hljs-string">text=&gt;</span></span><span class="hljs-string"><span class="hljs-string">"wow"</span></span>);</code> </pre><br><pre> GET / =&gt; "wow"
</pre><br>  The only case where the handler specified by the intermediate node is used is if this node is under.  Such nodes are created via <code>under()</code> , or an existing node can be made under by calling <code>inline(1)</code> .  After determining the terminal node that should process the current request, handlers of all the under-nodes will be sequentially called from the root of the tree to the terminal.  These handlers must return true or false (you can even asynchronously) - if they return false, subsequent handlers, including the terminal node handler, will not be called. <br><br>  Further, any tree node may contain the following information: <br><ol><li>  HTTP method (s) </li><li>  path pattern (pattern), may include placeholders <pre> <code class="perl hljs"><span class="hljs-string"><span class="hljs-string">"/something/:name/:id"</span></span></code> </pre></li><li>  constraints for allowed values ‚Äã‚Äãof placeholders <pre> <code class="perl hljs"><span class="hljs-string"><span class="hljs-string">name =&gt;</span></span> [<span class="hljs-string"><span class="hljs-string">"alex"</span></span>,<span class="hljs-string"><span class="hljs-string">"nick"</span></span>], <span class="hljs-string"><span class="hljs-string">id =&gt;</span></span> qr/^\d+$/</code> </pre><ul><li>  special limitation: is it possible to add extensions to the path template and which ones <pre> <code class="perl hljs"><span class="hljs-string"><span class="hljs-string">format =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-string"><span class="hljs-string">format =&gt;</span></span> [<span class="hljs-string"><span class="hljs-string">"json"</span></span>,<span class="hljs-string"><span class="hljs-string">"xml"</span></span>]</code> </pre></li></ul><br></li><li>  conditions - any functions that will be called after matching the path with the template to perform any additional checks (eg http-headers) and return true / false to allow or prohibit the use of this node to process the current request <pre> <code class="perl hljs"><span class="hljs-string"><span class="hljs-string">agent =&gt;</span></span> qr/Firefox/</code> </pre></li><li>  default parameters (defaults) - here you can set control parameters (controller / action / cb / ...), and default values ‚Äã‚Äãfor placeholders (which make these placeholders optional) and any other values ‚Äã‚Äãthat should be in <code>$c-&gt;stash()</code> when processing the request </li><li>  the explicit name of this node - for example.  for use in <code>url_for</code> <br><ul><li>  if you do not specify it, it will be generated automatically. </li></ul><br></li></ol>  All this data (except for the node name) is ‚Äúinherited‚Äù by nested nodes (unless they override them explicitly), which allows you to create and use intermediate nodes solely to set all of this default data for nested nodes.  By the way, nodes can be created without giving them any parameters at all, even a path template ‚Äî in this case, it will be the same as that of the parent node. <br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#  defaults     . $r-&gt;to("users#"); #    /resource   . $b = $r-&gt;route("/resource", format =&gt; 0); #   $b     $b     #         /resource. #    get()    ,    #     ,    , ..  /resource. $b-&gt;get()-&gt;over(agent=&gt;qr/Firefox/)-&gt;to("#ff_only"); $b-&gt;get()-&gt;to("#not_ff");</span></span></code> </pre><br>  As far as I understand, there is most likely no difference between setting default values ‚Äã‚Äãvia <code>$app-&gt;defaults</code> and through the root node <code>$app-&gt;routes-&gt;to</code> (maybe some hooks work completely before routing, and then the values ‚Äã‚Äãfrom <code>$app-&gt;defaults</code> will be available and may not be available from the root node). <br><br>  There are several other nuances, for example: the under-node does not process requests even if it is a terminal node, the root node handles the format value a little differently than all other nodes ... but I don‚Äôt think this is important for a general understanding, so I won‚Äôt go into details. <br><br>  I have not yet figured out how to connect a separate Mojolicious application to the current one through <code>$r-&gt;any("/path")-&gt;to(app=&gt;$otherapp)</code> , maybe there are additional nuances. <br><br><a name="routing_setup"></a><h4>  Routing: setting </h4><br>  There is a difference between Mojolicious and Mojolicious :: Lite - in Mojolicious :: Lite, under (together with a group) works a little differently than under Mojolicious.  Here I will describe the functions of Mojolicious (more precisely, Mojolicious :: Routes :: Route). <br><br>  All parameters of all functions are optional (except <code>over()</code> , <code>to()</code> and <code>via()</code> - they return the current value when called without parameters). <br><br><ul><li>  Simple low-level functions: <br><ul><li>  <code>$r-&gt;route()</code> creates a new node, parameters: <br><ul><li>  path pattern (first scalar with an odd number of parameters) </li><li>  restrictions, including format (pairs of parameters) </li></ul><br></li><li>  <code>$r-&gt;via()</code> sets the HTTP method (s) <br><ul><li>  method (s) (list or link to list) </li></ul><br></li><li>  <code>$r-&gt;over()</code> sets the conditions <br><ul><li>  conditions (pairs of parameters or a link to an array of pairs of parameters) </li></ul><br></li><li>  <code>$r-&gt;to()</code> sets default parameters <br><ul><li>  handler (application or package, controller and / or action) (the first scalar with an odd number of parameters) </li><li>  default parameters (parameter pairs or a link to the hash) </li></ul><br></li></ul><br></li><li>  Heaped harvesters for the lazy: <br><ul><li>  <code>$r-&gt;under()</code> creates an under-node <br><ul><li>  all parameters are like <code>get()</code> </li></ul><br></li><li>  <code>$r-&gt;any()</code> creates a node for any HTTP methods <br><ul><li>  the first parameter can be set method (s) (link to array) </li><li>  other parameters are like <code>get()</code> </li></ul><br></li><li>  <code>$r-&gt;get()</code> creates a node for the HTTP GET method <br><ul><li>  path pattern (first of scalar parameters) </li><li>  condition (scalar plus the parameter following it) </li><li>  node name (scalar which is the last parameter) </li><li>  handler function (reference to function; sets the default value of the parameter ‚Äúcb‚Äù) </li><li>  restrictions, including format (link to array) </li><li>  default parameters (link to hash) </li></ul><br></li><li>  <code>$r-&gt;post()</code> creates a node for the HTTP POST method <br><ul><li>  all parameters are like <code>get()</code> </li></ul><br></li><li>  <code>$r-&gt;put()</code> creates a node for the HTTP PUT method <br><ul><li>  all parameters are like <code>get()</code> </li></ul><br></li><li>  <code>$r-&gt;delete()</code> creates a node for the HTTP DELETE method <br><ul><li>  all parameters are like <code>get()</code> </li></ul><br></li><li>  <code>$r-&gt;patch()</code> creates a node for the HTTP PATCH method <br><ul><li>  all parameters are like <code>get()</code> </li></ul><br></li><li>  <code>$r-&gt;options()</code> creates a node for the HTTP OPTIONS method <br><ul><li>  all parameters are like <code>get()</code> </li></ul><br></li></ul><br></li></ul><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#      Mojolicious $r-&gt;get("/users/:id", [ format =&gt; 0 ], agent =&gt; qr/Firefox/, { id =&gt; -1, controller =&gt; "users" }, [ id =&gt; qr/^\d+$/ ], headers =&gt; { "X-Secret" =&gt; "letmeit" }, \&amp;cb, { action =&gt; "list" }, "my_cool_route", ); #        get() $r-&gt;route("/users/:id", id =&gt; qr/^\d+$/, format =&gt; 0) -&gt;via("GET") -&gt;over(agent =&gt; qr/Firefox/, headers =&gt; { "X-Secret" =&gt; "letmeit" }) -&gt;to(id =&gt; -1, controller =&gt; "users", action =&gt; "list", cb =&gt; \&amp;cb) -&gt;name("my_cool_route");</span></span></code> </pre><br><br><a name="params"></a><h4>  HTTP request options </h4><br>  There are not just a lot of ways to get to the request parameters, but <i>a lot</i> .  At the same time, not all of them are worth using them - in some cases, the parameters obtained from different places are mixed together, and it‚Äôs impossible to understand where it comes from. <br><br>  Mojolicious has 4 types of parameters: <br><ol><li>  <b>GET</b> - obtained from query string in url, and the HTTP request method can be any - GET, POST, etc. </li><li>  <b>POST</b> ‚Äî received from the body of a POST request of the type <code>application/x-www-form-urlencoded</code> or type <code>multipart/form-data</code> ‚Äî but in this case only ordinary parameters are taken, except for files </li><li>  <b>UPLOAD</b> - files received from the body of a POST request of the type <code>multipart/form-data</code> </li><li>  <b>ROUTE</b> - values ‚Äã‚Äãcut from the url path using <a href="">placeholders</a> in routing, excluding those <a href="https://metacpan.org/pod/Mojolicious::Controller">reserved for stash</a> </li></ol><br>  Further, it should be noted that the same parameter can be passed several times, moreover, it can be transmitted <i>several times in each of the ways</i> - GET, POST, UPLOAD, and when defining routing we can mention the same placeholder several times .  For GET, POST and UPLOAD, all transferred values ‚Äã‚Äãof one parameter are saved, but for ROUTE only one is used, the <i>last</i> value if one placeholder is specified several times. <br><br>  Most often in examples <code>$c-&gt;param</code> is mentioned - let's see where the values ‚Äã‚Äãreturned by this function come from <b>(in Mojolicious up to 5.47)</b> : <br><ul><li>  <code>scalar $c-&gt;param()</code> - returns undef </li><li>  <code>@names = $c-&gt;param()</code> - returns the names of all GET, POST, UPLOAD and ROUTE parameters </li><li>  <code>$value = $c-&gt;param("name")</code> - returns: <br><ol><li>  the last value of the placeholder "name" if it is, otherwise </li><li>  the first value of UPLOAD "name" if it is, otherwise </li><li>  the first value of POST "name" if it is, otherwise </li><li>  the first value of the GET "name" if it is, otherwise </li><li>  undef </li></ol><br></li><li>  <code>@values = $c-&gt;param("name")</code> - returns: <br><ol><li>  the last value of the placeholder "name" if it is, otherwise </li><li>  all UPLOAD "name" values, if any, otherwise </li><li>  all values ‚Äã‚Äãof POST "name" after which all values ‚Äã‚Äãof GET "name" if they are, otherwise </li><li>  () </li></ol><br></li></ul>  Personally, I prefer to write the most clear code, and I do not like such "magic" functions, which will return the parameter, but it is completely unknown where it comes from.  Of course, in some cases <i>you need</i> to ignore the fact that the parameters are transferred by GET or POST, but what <code>$c-&gt;param</code> does is already beyond good and evil (for example, if you were expecting a GET / POST parameter , and get UPLOAD, then instead of the <i>string</i> value <i>,</i> get the <i>object</i> Mojo :: Upload).  Everything is good in moderation, even the magic sloth functions that create the wow factor that Mojolicious so much like to implement. <br><br>  Here is a list of functions that are recommended to restrict access to the parameters of the HTTP request: <br><ul><li>  Get the value of placeholder from the url path: <br><pre> <code class="perl hljs">$value = $c-&gt;stash( <span class="hljs-string"><span class="hljs-string">"name"</span></span> ) <span class="hljs-comment"><span class="hljs-comment"># ROUTE</span></span></code> </pre><br></li><li>  Get the names and all values ‚Äã‚Äãof all parameters: <br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment"># HASHREF:     : # -  (    ) # -     (    ) $params = $c-&gt;req-&gt;params-&gt;to_hash #  POST,  GET $params = $c-&gt;req-&gt;query_params-&gt;to_hash # GET $params = $c-&gt;req-&gt;body_params-&gt;to_hash # POST # ARRAYREF:    ,  Mojo::Upload $uploads = $c-&gt;req-&gt;uploads # UPLOAD</span></span></code> </pre><br></li><li>  Get the names of all parameters: <br><pre> <code class="perl hljs">@names = @{ $c-&gt;req-&gt;params-&gt;names } <span class="hljs-comment"><span class="hljs-comment"># POST  GET @names = @{ $c-&gt;req-&gt;query_params-&gt;names } # GET @names = @{ $c-&gt;req-&gt;body_params-&gt;names } # POST @names = keys %{{ map { $_-&gt;name =&gt; 1 } @{ $c-&gt;req-&gt;uploads } }} # UPLOAD</span></span></code> </pre><br></li><li>  Get the last value of a single parameter: <br><pre> <code class="perl hljs">$c-&gt;req-&gt;params-&gt;param( <span class="hljs-string"><span class="hljs-string">"name"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">#  POST,  GET $c-&gt;req-&gt;query_params-&gt;param( "name" ) # GET $c-&gt;req-&gt;body_params-&gt;param( "name" ) # POST $c-&gt;req-&gt;upload( "name" ) # UPLOAD</span></span></code> </pre><br></li><li>  Get all the values ‚Äã‚Äãof one parameter: <br><pre> <code class="perl hljs">$c-&gt;req-&gt;params-&gt;every_param( <span class="hljs-string"><span class="hljs-string">"name"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">#  POST,  GET $c-&gt;req-&gt;query_params-&gt;every_param( "name" ) # GET $c-&gt;req-&gt;body_params-&gt;every_param( "name" ) # POST $c-&gt;req-&gt;every_upload( "name" ) # UPLOAD</span></span></code> </pre><br></li></ul>  This approach will ensure clarity and consistency of the code.  But, for completeness, here‚Äôs a list of remaining features: <ul><li>  Alternative options for calling the above functions: <br><ul><li>  <code>$c-&gt;req-&gt;param</code> is the same as <code>$c-&gt;req-&gt;params-&gt;param</code> </li><li>  <code>$c-&gt;req-&gt;url-&gt;query</code> is the same as <code>$c-&gt;req-&gt;query_params</code> </li></ul><br></li><li>  Instead of <code>to_hash</code> you can use <code>pairs</code> - it returns a link to the array where the names and values ‚Äã‚Äãof all parameters go successively, and one name may occur several times, but all values ‚Äã‚Äãare scalars. </li></ul><br><a name="parsing"></a><h4>  Parsing </h4><br>  This is not entirely from my dictionary, but I cannot find another description: in terms of parsing the downloaded pages of mojo, it‚Äôs just nice!  The documentation for this part of Mojo is much better.  However, there is something to add. <br><br>  The fact is that Mojo is not just a server-side web framework, but a web framework in general - for both the server and the client.  Therefore, modules that implement the format of HTTP messages are used by both the server and the client ‚Äî and they have very different needs for processing these messages.  As a result, when you need to do something and climb into the documentation, at this moment you are interested in either server functionality or client functionality - and you see not only that, both, and so carefully sorted in alphabetical order.  As a result, it is quite difficult to find the necessary function, and there is a need for a visual cheat sheet, where there will be functions only for the client or only for the server, preferably grouped by some adequate criterion. <br><br>  The result was the following tablet.  This is the first alpha version :) so if something is not clear or there are ideas for improvement - write, we will finish it with joint efforts.  A few notes: <br><ul><li>  Even with a pumping error, <code>$tx-&gt;res</code> will be available (with a 404 stub). </li><li>  The tree in <code>$dom</code> has a root node, and the node with the <code>html</code> tag (if it was in the downloaded page) is a descendant of the root node.  Because of this, <code>to_string</code> and <code>content</code> on the root node return the same thing. </li><li>  When referring to non-existent elements (or for example, if a collection was expected and one element was found through the collection method is called <code>$dom-&gt;child_tag_name</code> ), the pearl throws an exception ‚Äúthere is no such method‚Äù - in other words, it is almost always necessary to include the parser in <code>eval</code> . </li><li>  It is very simply unintentionally to get a collection of collections instead of a collection of nodes, or a collection in which some of the elements are empty - the methods of the <code>flatten</code> and <code>compact</code> collections will help here. </li><li>  The parameter <code>"*"</code> means a string with CSS selector. </li></ul><br><pre> <code class="perl hljs">$tx = $ua-&gt;get($url); <span class="hljs-comment"><span class="hljs-comment"># Mojo::Transaction::HTTP ‚Üí Mojo::Transaction $tx-&gt;error # undef  {message=&gt;'‚Ä¶',‚Ä¶} $tx-&gt;success # undef  $tx-&gt;res $tx-&gt;req # Mojo::Message::Request ‚Üí Mojo::Message $tx-&gt;res # Mojo::Message::Response ‚Üí Mojo::Message $tx-&gt;redirects # [ Mojo::Transaction::HTTP, ‚Ä¶ ] $res = $tx-&gt;res; # Mojo::Message::Response ‚Üí Mojo::Message $res-&gt;error # undef  {message=&gt;'Parse error',‚Ä¶} $res-&gt;to_string # "‚Ä¶" (headers+content) $res-&gt;is_status_class(200); # bool $res-&gt;code # 404 $res-&gt;message # "Not Found" $res-&gt;headers # Mojo::Headers $res-&gt;cookies # [ Mojo::Cookie::Response, ‚Ä¶ ] $res-&gt;cookie('name') # Mojo::Cookie::Response ‚Üí Mojo::Cookie $res-&gt;body # "‚Ä¶" $res-&gt;text # "‚Ä¶" (decoded body using charset) $res-&gt;dom # Mojo::DOM $res-&gt;json # Mojo::JSON $headers = $res-&gt;headers; # Mojo::Headers $headers-&gt;names # [ "Content-Type", "Server", ‚Ä¶ ] $headers-&gt;to_hash # { "Content-Type" =&gt; "‚Ä¶", ‚Ä¶ } $headers-&gt;header('Server') # "‚Ä¶" $headers-&gt;$standard_header_name # "‚Ä¶" (shortcuts for useful headers) $dom = $res-&gt;dom; # Mojo::DOM $dom-&gt;to_string # "‚Ä¶" ( ,  ) $dom-&gt;content # "‚Ä¶" (  ) $dom-&gt;type # "‚Ä¶" ( : root,tag,text,comment,‚Ä¶) $dom-&gt;tag # "‚Ä¶"  "" ( ) $dom-&gt;attr # {name=&gt;"val",‚Ä¶} $dom-&gt;attr('name') # "val" $dom-&gt;{name} #  $dom-&gt;attr("name") $dom-&gt;all_text # "‚Ä¶" (  ) $dom-&gt;all_text(0) # "‚Ä¶" (  ,   ) $dom-&gt;text # "‚Ä¶" (  ) $dom-&gt;text(0) # "‚Ä¶" (  ,   ) $dom-&gt;root # Mojo::DOM ( ) $dom-&gt;parent # Mojo::DOM  undef (-) $dom-&gt;next # Mojo::DOM  undef ( -) $dom-&gt;next_node # Mojo::DOM  undef ( -) $dom-&gt;previous # Mojo::DOM  undef ( -) $dom-&gt;previous_node # Mojo::DOM  undef ( -) $dom-&gt;matches('*') # true/false (    ) $dom-&gt;at('*') # Mojo::DOM  undef (  ) $dom-&gt;find('*') # Mojo::Collection ( ) $dom-&gt;ancestors # Mojo::Collection (-) $dom-&gt;ancestors('*') # Mojo::Collection ( -) $dom-&gt;following # Mojo::Collection ( -) $dom-&gt;following("*") # Mojo::Collection (  -) $dom-&gt;following_nodes # Mojo::Collection ( -) $dom-&gt;preceding # Mojo::Collection ( -) $dom-&gt;preceding("*") # Mojo::Collection (  -) $dom-&gt;preceding_nodes # Mojo::Collection ( -) $dom-&gt;children # Mojo::Collection (-) $dom-&gt;children('*') # Mojo::Collection ( -) $dom-&gt;descendant_nodes # Mojo::Collection ( ) $dom-&gt;child_nodes # Mojo::Collection ( -) $dom-&gt;[0] #  $dom-&gt;child_nodes-&gt;[0] $res-&gt;dom('*') #  $dom-&gt;find('*')</span></span></code> </pre><br><br><a name="tips"></a><h4>  Tips &amp; Tricks </h4><br><a name="nb_cgi"></a><h5>      CGI </h5><br>      Mojolicious-           cgi: <a href="https://gist.github.com/powerman/5456484">https://gist.github.com/powerman/5456484</a> <br><br><a name="ua_server"></a><h5>   Mojo::UserAgent     </h5><br>   ,     <code>$ua</code>       ,   TCP-  -  ‚Äî  :      <code>$app</code> ,    Mojo::UserAgent,  ,     ,     url,       ,   <code>$app</code> . <br><br>   ¬´ ¬ª  ,     Mojolicious::Lite.        ,      -     Mojo::UserAgent ‚Äî   ¬´ ¬ª   .    : <br><pre> <code class="perl hljs">Mojo::UserAgent::Server-&gt;app($app);</code> </pre><br><a name="ojo_lite"></a><h5> ojo  Mojolicious::Lite </h5><br>   <a href="https://metacpan.org/pod/ojo">ojo</a>  ,     ojo   Mojolicious::Lite,     Mojolicious: <br><pre> <code class="bash hljs">$ perl -Mojo -E <span class="hljs-string"><span class="hljs-string">'get "/", {text=&gt;"wow\n"}; app-&gt;start'</span></span> get / wow</code> </pre><br><a name="env"></a><h5>  Environment variables </h5><br> Mojolicious          <code>MOJO_</code> ‚Äî      , ..        Mojolicious,    : <br><ul><li> <code>MOJO_MODE</code> ‚Äî       - ,      ,       ,      : <br><ul><li>  <code>$app-&gt;mode</code> </li><li>   - </li><li>     <code>exception</code>  <code>not_found</code>   (     <code>MOJO_MODE</code> , . ¬´exception.$mode.html.ep¬ª) </li><li> <code>$app-&gt;log-&gt;level</code>     ¬´debug¬ª  ¬´info¬ª   <code>MOJO_MODE</code>  ¬´development¬ª </li><li>  ,  <code>${mode}_mode()</code>    <code>startup()</code> <i>( ,     )</i> . </li></ul><br></li><li> <code>MOJO_LOG_LEVEL</code> ‚Äî       ¬´warn¬ª    Mojolicious::Lite,       . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/227493/">https://habr.com/ru/post/227493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227483/index.html">Why the growth of quality causes the growth of poor quality, or whether the main function</a></li>
<li><a href="../227485/index.html">Why do you still wear "silly" clothes?</a></li>
<li><a href="../227487/index.html">Anonymity in the era of social networks: what to do when your ‚Äúprivacy level‚Äù falls below zero</a></li>
<li><a href="../227489/index.html">The most popular ideas of robots on Kickstarter</a></li>
<li><a href="../227491/index.html">Cocos2d gas shader</a></li>
<li><a href="../227497/index.html">OpenVZ Critical Vulnerability</a></li>
<li><a href="../227499/index.html">Astro tracker for two evenings</a></li>
<li><a href="../227501/index.html">Oculus buys a group of top industrial designers</a></li>
<li><a href="../227507/index.html">The life cycle of tasks in Redmine for a small development team. Our experience and useful tips</a></li>
<li><a href="../227509/index.html">Google enters the smart home market by opening the Nest thermostats API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>