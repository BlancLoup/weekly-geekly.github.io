<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JSON Schema and its use for validating JSON documents in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article describes the JSON Schema standard and its use to verify compliance with a given format in C ++ using the valijson library tools . 

 A b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JSON Schema and its use for validating JSON documents in C ++</h1><div class="post__text post__text-html js-mediator-article">  This article describes the JSON Schema standard and its use to verify compliance with a given format in C ++ using the <a href="https://github.com/tristanpenman/valijson">valijson</a> library <a href="https://github.com/tristanpenman/valijson">tools</a> . <br><br><h5>  A bit of history </h5><br>  First, let us recall what led to the widespread displacement of JSON-ohm XML, and that this was bad.  XML was originally created as a <em>metalanguage</em> <em>markup of</em> documents, allowing the use of a unified parser code and validator documents.  Being the first standard of this kind, and even came during the period of rapid introduction of digital corporate information systems, XML served as the basis for countless standards for data serialization and interaction protocols, i.e.  storage and transmission of structured data.  Whereas it was created primarily for marking documents. <br><a name="habracut"></a><br>  Being <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25B8%25D1%2582%25D0%25B5%25D1%2582%25D0%25BE%25D0%25BC">developed by committees</a> , the XML standard has been supplemented with many extensions that allow, in particular, <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25BE_%25D0%25B8%25D0%25BC%25D1%2591%25D0%25BD_(XML)">to avoid name conflicts</a> and perform <a href="https://ru.wikipedia.org/wiki/XQuery">complex queries</a> in XML documents.  And, most importantly, since the resulting jumble of tags turned out to be completely unreadable by any person, the <a href="https://ru.wikipedia.org/wiki/XML_Schema">XML Schema</a> standard was developed and widely implemented, which makes it possible to completely strictly describe the valid content of each document on the same XML for subsequent automatic verification. <br><br>  Meanwhile, more and more developers under the influence of emerging interactive web-technologies began to get acquainted with the JavaScript language, and they began to realize that it‚Äôs not necessary to study hundreds of pages of XML specifications to represent structured objects in text form.  And when Douglas Crockford proposed to standardize a subset of JavaScript to serialize objects (but not markup documents!) Without reference to language, the idea was supported by the community.  Currently, JSON is one of two (along with XML) languages ‚Äã‚Äãsupported by all popular programming technologies.  The same YAML, designed to make JSON more convenient and human-readable, due to its complexity (i.e., its breadth of possibilities) is not so widespread (in my company there were problems with working with YAML from MATLAB not so long ago, whereas with JSON everything is fine) . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, having started to use JSON for data presentation in large quantities, the developers were faced with the need to manually check the contents of the documents, each time re-inventing the validation logic in each language.  People familiar with the XML Schema, it could not enrage.  And gradually, a similar standard JSON Schema did form and lives at <a href="http://json-schema.org/">http://json-schema.org/</a> . <br><br><h5>  JSON Schema </h5><br>  Consider an example of a simple, but exponential, scheme defining a dictionary of 2D or 3D geometric points in the space (-1, 1) x (-1, 1) x (-1, 1) with keys consisting of numbers: <br><br><pre><code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"patternProperties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"^[0-9]+$"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minimum"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-string"><span class="hljs-string">"x"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/definitions/point_coord"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"y"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/definitions/point_coord"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"z"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/definitions/point_coord"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span>: [<span class="hljs-string"><span class="hljs-string">"value"</span></span>, <span class="hljs-string"><span class="hljs-string">"x"</span></span>, <span class="hljs-string"><span class="hljs-string">"y"</span></span>] } } <span class="hljs-string"><span class="hljs-string">"additionalProperties"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"definitions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"point_coord"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minimum"</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maximum"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } } }</code> </pre> <br>  If Crockford is forgiven for annoying quotes, it should be clear from this document that we agree to deal with an object (dictionary), the keys of which must consist of numbers (see regular expression), whose values ‚Äã‚Äãmust have fields x, y, value, and the field z, where value is a non-negative number, and x, y, z all have a certain type of point_coord, corresponding to a number from -1 to +1.  Even assuming that JSON Schema does not provide other capabilities (which is far from the truth), this should be enough for many usage scenarios. <br><br>  But this is the case if a validator is implemented for your language / platform.  In the case of XML, this question could hardly arise. <br><br>  On the <a href="http://json-schema.org/">http://json-schema.org/</a> site you can find a <a href="http://json-schema.org/implementations.html">list of</a> validation <a href="http://json-schema.org/implementations.html">software</a> .  And here in this place the immaturity of JSON-Schema (and its site) makes itself felt.  For C ++, there is one (seemingly interesting) library <a href="https://bitbucket.org/gallen/libvariant">libvariant</a> that is validated only part-time and also released under the malicious LGPL license (goodbye, iOS).  For C, we also have <a href="https://github.com/netmail-open/wjelement">one option</a> , and also under the LGPL. <br><br>  However, an acceptable solution exists and is called <a href="https://github.com/tristanpenman/valijson">valijson</a> .  This library has everything we need (scheme validation and BSD license), and even more, independence from the JSON parser.  Valijson allows you to use any json parser through an adapter (bundled adapters for jsoncpp, json11, rapidjson, picojson and boost :: property_tree), thus not requiring you to switch to a new json library (or drag another one along).  Plus, it consists only of header files (header only) and does not require compilation.  The obvious minus is only one, and that is not for everyone - dependence on boost.  Although <a href="https://github.com/tristanpenman/valijson/issues/15">there is hope</a> for deliverance even from this shortcoming. <br><br>  Let us consider, by the example of a document, the creation of a JSON schema and the validation of this document. <br><br><h5>  Scheme Example </h5><br>  Suppose we have a table of some striped objects for which a specific striped coloring is given (in the form of a sequence of 0 and 1 corresponding to black and white). <br><br><pre> <code class="hljs objectivec">{ <span class="hljs-string"><span class="hljs-string">"0inv"</span></span>: { <span class="hljs-string"><span class="hljs-string">"width"</span></span>: <span class="hljs-number"><span class="hljs-number">0.11</span></span>, <span class="hljs-string"><span class="hljs-string">"stripe_length"</span></span>: <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-string"><span class="hljs-string">"code"</span></span>: <span class="hljs-string"><span class="hljs-string">"101101101110"</span></span> }, <span class="hljs-string"><span class="hljs-string">"0"</span></span>: { <span class="hljs-string"><span class="hljs-string">"width"</span></span>: <span class="hljs-number"><span class="hljs-number">0.05</span></span>, <span class="hljs-string"><span class="hljs-string">"stripe_length"</span></span>: <span class="hljs-number"><span class="hljs-number">0.11</span></span>, <span class="hljs-string"><span class="hljs-string">"code"</span></span>: <span class="hljs-string"><span class="hljs-string">"010010010001"</span></span> }, <span class="hljs-string"><span class="hljs-string">"3"</span></span>: { <span class="hljs-string"><span class="hljs-string">"width"</span></span>: <span class="hljs-number"><span class="hljs-number">0.05</span></span>, <span class="hljs-string"><span class="hljs-string">"stripe_length"</span></span>: <span class="hljs-number"><span class="hljs-number">0.11</span></span>, <span class="hljs-string"><span class="hljs-string">"code"</span></span>: <span class="hljs-string"><span class="hljs-string">"010010110001"</span></span> }, ... }</code> </pre><br>  Here we have a dictionary with numeric keys, to which the ‚Äúinv‚Äù suffix can be assigned (for inverted bar codes).  All values ‚Äã‚Äãin the dictionary are objects and must have the fields ‚Äúwidth‚Äù, ‚Äústripe_length‚Äù (strictly positive numbers) and ‚Äúcode‚Äù (a string of zeroes and units of length 12). <br><br>  We start to make a scheme, specifying restrictions on the format of the names of top-level fields: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"comment"</span></span>: <span class="hljs-string"><span class="hljs-string">"Schema for the striped object specification file"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"patternProperties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"^[0-9]+(inv)?$"</span></span>: { } }, <span class="hljs-attr"><span class="hljs-attr">"additionalProperties"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  Here we used the patternProperties construct, which permits / specifies values ‚Äã‚Äãwhose keys satisfy the regular expression.  We also specified (additionalProperties = false) that unspecified keys are prohibited.  Using additionalProperties, you can not only enable or disable unspecified fields, but also impose restrictions on their values ‚Äã‚Äãby specifying a type specifier as a value, like so: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"additionalProperties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"pattern"</span></span>: <span class="hljs-string"><span class="hljs-string">"^Comment: .*$"</span></span> } }</code> </pre><br>  Next, we describe the type of the value of each object in the dictionary: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"width"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minimum"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclusiveMinimum"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"stripe_length"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minimum"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclusiveMinimum"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"pattern"</span></span>: <span class="hljs-string"><span class="hljs-string">"^[01]{12}$"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span>: [<span class="hljs-string"><span class="hljs-string">"width"</span></span>, <span class="hljs-string"><span class="hljs-string">"stripe_length"</span></span>, <span class="hljs-string"><span class="hljs-string">"code"</span></span>] }</code> </pre><br>  Here we explicitly enumerate the allowed fields (properties), requiring their presence (required), not prohibiting (by default) any additional properties.  Our numeric properties are strictly positive, and the code string must match the regular expression. <br><br>  In principle, it remains only to insert the description of the type of an individual object into the above-described table schema.  But before you do this, we note that we have duplicated the specification of the fields "width" and "stripe_length".  In the real code from which the example was taken, there are even more such fields, so it would be useful to determine this type once and then refer to it as an attribute.  This is what the link mechanism ($ ref) is for.  Pay attention to the definitions section in the final scheme: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"comment"</span></span>: <span class="hljs-string"><span class="hljs-string">"Schema for the striped object specification file"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"patternProperties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"^[0-9]+(inv)?$"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"width"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/definitions/positive_number"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"stripe_length"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/definitions/positive_number"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"pattern"</span></span>: <span class="hljs-string"><span class="hljs-string">"^[01]{12}$"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span>: [<span class="hljs-string"><span class="hljs-string">"width"</span></span>, <span class="hljs-string"><span class="hljs-string">"stripe_length"</span></span>, <span class="hljs-string"><span class="hljs-string">"code"</span></span>] } }, <span class="hljs-attr"><span class="hljs-attr">"additionalProperties"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"definitions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"positive_number"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minimum"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclusiveMinimum"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } }</code> </pre><br>  Save it to a file and start writing a validator. <br><br><h5>  Application valijson </h5><br>  As a json-parser we use <a href="https://github.com/open-source-parsers/jsoncpp">jsoncpp</a> .  We have the usual function of loading a json document from a file: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;json-cpp/json.h&gt; Json::Value load_document(std::string const&amp; filename) { Json::Value root; Json::Reader reader; std::ifstream ifs(filename, std::ifstream::binary); if (!reader.parse(ifs, root, false)) throw std::runtime_error("Unable to parse " + filename + ": " + reader.getFormatedErrorMessages()); return root; }</span></span></span></span></code> </pre><br>  The minimum validator function telling us about the location of all validation errors looks like this: <br><br><pre> <code class="hljs rust">#include &lt;valijson/adapters/jsoncpp_adapter.hpp&gt; #include &lt;valijson/schema.hpp&gt; #include &lt;valijson/schema_parser.hpp&gt; #include &lt;valijson/validation_results.hpp&gt; #include &lt;valijson/validator.hpp&gt; void validate_json(Json::Value <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; root, Json::Value <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; schema_js) { using valijson::Schema; using valijson::SchemaParser; using valijson::Validator; using valijson::ValidationResults; using valijson::adapters::JsonCppAdapter; JsonCppAdapter doc(root); JsonCppAdapter schema_doc(schema_js); SchemaParser parser(SchemaParser::kDraft4); Schema schema; parser.populateSchema(schema_doc, schema); Validator validator(schema); validator.setStrict(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); ValidationResults results; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!validator.validate(doc, &amp;results)) { std::stringstream err_oss; err_oss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Validation failed."</span></span> &lt;&lt; std::endl; ValidationResults::Error error; int error_num = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (results.popError(error)) { std::string context; std::vector&lt;std::string&gt;::iterator itr = error.context.begin(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; itr != error.context.end(); itr++) context += *itr; err_oss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error #"</span></span> &lt;&lt; error_num &lt;&lt; std::endl &lt;&lt; <span class="hljs-string"><span class="hljs-string">" context: "</span></span> &lt;&lt; context &lt;&lt; std::endl &lt;&lt; <span class="hljs-string"><span class="hljs-string">" desc: "</span></span> &lt;&lt; error.description &lt;&lt; std::endl; ++error_num; } throw std::runtime_error(err_oss.<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>()); } }</code> </pre><br>  Note that in this example, jsoncpp connects as <code>#include &lt;json-cpp/json.h&gt;</code> , while <code>valijson/adapters/jsoncpp_adapter.hpp</code> in the current version of valijson assumes that jsoncpp connects as <code>#include &lt;json/json.h&gt;</code> .  So do not be surprised if the compiler does not find <code>json/json.h</code> , and just correct <code>valijson/adapters/jsoncpp_adapter.hpp</code> . <br><br>  Now we can upload and validate documents: <br><br><pre> <code class="cpp hljs">Json::Value <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doc = load_document(<span class="hljs-string"><span class="hljs-string">"/path/to/document.json"</span></span>); Json::Value <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> schema = load_document(<span class="hljs-string"><span class="hljs-string">"/path/to/schema.json"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { validate_json(doc, schema); ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; e) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Exception: "</span></span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Everything, we learned to validate json-documents.  But note that now we have to think about where to store the schemes!  After all, if a document changes every time and is obtained, for example, from a web request or from a command line argument, the schema is unchanged and should be supplied with the application.  And for small programs without a developed mechanism for loading static resources, the need to introduce one represents a significant barrier to the introduction of validation through schemes.  It would be great to compile the schema with the program, because changing the schema will in any case require changing the code processing the document. <br><br>  This is possible and even quite convenient if we have C ++ 11 at our disposal.  The solution is primitive, but it works great: we just define a string constant with our schema.  And in order not to take care of the quotes inside the string, we use <a href="http://en.cppreference.com/w/cpp/language/string_literal">raw string literal</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   R"(raw string)" static std::string const MY_SCHEMA = R"({ "comment": "Schema for pole json specification", "type": "object", "patternProperties": { "^[0-9]+(inv)?$": { ... ... } } ... })"; //  json   Json::Value json_from_string(std::string const&amp; str); { Json::Reader reader; std::stringstream schema_stream(str); Json::Value doc; if (!reader.parse(schema_stream, doc, false)) throw std::runtime_error("Unable to parse the embedded schema: " + reader.getFormatedErrorMessages()); return doc; } //    doc (validate_json  ) validate_json(doc, json_from_string(MY_SCHEMA));</span></span></code> </pre><br>  Thus, we have a convenient cross-platform cross-language validation mechanism for json documents, the use of which in C ++ does not require linking external libraries with inconvenient licenses, nor fiddling with ways to static resources.  This thing can really save a lot of power, and, importantly, help to finally kill XML as an object presentation format, because it is inconvenient for both people and machines. </div><p>Source: <a href="https://habr.com/ru/post/276305/">https://habr.com/ru/post/276305/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276295/index.html">Some areas of file system development</a></li>
<li><a href="../276297/index.html">A little bit about software architectures</a></li>
<li><a href="../276299/index.html">Deep learning and brain work: When will technological singularity</a></li>
<li><a href="../276301/index.html">27% of all recorded malware appeared in 2015</a></li>
<li><a href="../276303/index.html">Skeletal 2D animation in Unity using Puppet2D plugin</a></li>
<li><a href="../276307/index.html">Records from the Web Standards Days conference - Moscow 2015</a></li>
<li><a href="../276309/index.html">How to train CCIE</a></li>
<li><a href="../276311/index.html">EMET 5.5 released</a></li>
<li><a href="../276313/index.html">Authentication via ESIA OAuth2</a></li>
<li><a href="../276315/index.html">XAML Developer Chips: Conditional Converter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>