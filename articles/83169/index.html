<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Expressions in C # - impress yourself!</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NET 4.0 is just around the corner and will bring a bunch of everything new, necessary and not very cool and super cool. However, in the good old .NET...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Expressions in C # - impress yourself!</h1><div class="post__text post__text-html js-mediator-article">  .NET 4.0 is just around the corner and will bring a bunch of everything new, necessary and not very cool and super cool.  However, in the good old .NET 3.5 there are many different interesting features that are not used in everyday work, but sometimes they make life easier for developers.  One of these great pieces is Expressions. <br><a name="habracut"></a><br> <a title="ImageShack - Image And Video Hosting" href="http://img69.imageshack.us/i/treeec.png/"><img src="http://img69.imageshack.us/img69/4917/treeec.png" align="right"></a> <br><br>  Expressions (or, more correctly, expression trees) is nothing but an expression tree, familiar from university times, when you just learned to program.  Here is a napyrmer, a tree for expressing 2 + 3 * 4. <br><br><br>  System.Linq.Expressions is, in principle, the same trees, only larger and more complex (there are 56 different expressions in .NET, starting with simple mathematic expressions, ending with list initialization and calling methods). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Expressions can be built in two ways - in compile-time, and in run-time.  In compile-time, the compiler will automatically parse our code and assemble Expression from it.  For example, for this line: <br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">Expression&lt;Func&lt; <font color="#0000ff">string</font> , <font color="#0000ff">int</font> &gt;&gt; ex = s =&gt; s.Replace( <font color="#A31515">"x"</font> , <font color="#A31515">"yy"</font> ).Length*2;</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  the compiler will actually issue the following code: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">ParameterExpression CS$0$0000; <br> Expression&lt;Func&lt; <font color="#0000ff">string</font> , <font color="#0000ff">int</font> &gt;&gt; ex = Expression.Lambda&lt;Func&lt; <font color="#0000ff">string</font> , <font color="#0000ff">int</font> &gt;&gt;(Expression.Multiply(Expression.Property(Expression.Call(CS$0$0000 = Expression.Parameter( <font color="#0000ff">typeof</font> ( <font color="#0000ff">string</font> ), <font color="#A31515">"s"</font> ), (MethodInfo) methodof( <font color="#0000ff">string</font> .Replace), <font color="#0000ff">new</font> Expression[] { Expression.Constant( <font color="#A31515">"x"</font> , <font color="#0000ff">typeof</font> ( <font color="#0000ff">string</font> )), Expression.Constant( <font color="#A31515">"yy"</font> , <font color="#0000ff">typeof</font> ( <font color="#0000ff">string</font> )) }), (MethodInfo) methodof( <font color="#0000ff">string</font> .get_Length)), Expression.Constant(2, <font color="#0000ff">typeof</font> ( <font color="#0000ff">int</font> ))), <font color="#0000ff">new</font> ParameterExpression[] { CS$0$0000 }); <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Thus, we get access to the internal structure of the expression and we can match it to some external language - in particular, LINQ to SQL works in this way, which parses the resulting expression (I said that the LINQ query is actually a call chain and is also translated into ?) and executes the corresponding T-SQL query.  I will not tell you how this is done - this requires a new article. <br><br><br>  I want to tell you about the second way to build expressions - in run-time.  For example, we are faced with the task of writing a deserializer that will collect an object based on a set of ‚Äúproperty name‚Äù: ‚Äúvalue‚Äù pairs.  The standard way to solve the problem is reflection, which is known to be very slow.  Here is the code of the creator through reflection (I will not explain, everything should be clear): <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">internal</font> <font color="#0000ff">class</font> ReflectionCreator&lt;T&gt;:ICreator&lt;T&gt; <br> { <br> <font color="#0000ff">private</font> <font color="#0000ff">readonly</font> <font color="#2B91AF">List</font> &lt;PropertyInfo&gt; _infos; <br> <br> <font color="#0000ff">public</font> ReflectionCreator() <br> { <br> _infos = <font color="#0000ff">new</font> <font color="#2B91AF">List</font> &lt;PropertyInfo&gt;( <font color="#0000ff">typeof</font> (T).GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetProperty)); <br> } <br> <font color="#0000ff">public</font> T Create(Dictionary&lt; <font color="#0000ff">string</font> , <font color="#0000ff">object</font> &gt; props) <br> { <br> <font color="#0000ff">var</font> newObject = Activator.CreateInstance&lt;T&gt;(); <br> <font color="#0000ff">foreach</font> ( <font color="#0000ff">var</font> propertyInfo <font color="#0000ff">in</font> _infos) <br> { <br> <font color="#0000ff">object</font> <font color="#0000ff">value</font> ; <br> <font color="#0000ff">if</font> (props.TryGetValue(propertyInfo.Name, <font color="#0000ff">out</font> <font color="#0000ff">value</font> )) <br> { <br> propertyInfo.SetValue(newObject, <font color="#0000ff">value</font> , <font color="#0000ff">null</font> ); <br> } <br> } <br> <font color="#0000ff">return</font> newObject; <br> } <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  This creator spends 0.001 seconds to create a creator and 1.20 seconds to create 10,000 objects (yes, creating a creator ...).  Long, but not fatal.  But let's take a look at the expressions. <br><br>  Consider the problem closer.  If we were faced with the task of writing a deserializer for a particular class, for example, for the Foo class: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">class</font> Foo <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">string</font> Name { <font color="#0000ff">get</font> ; <font color="#0000ff">set</font> ; } <br> <font color="#0000ff">public</font> <font color="#0000ff">int</font> Value { <font color="#0000ff">get</font> ; <font color="#0000ff">set</font> ; } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  we could just construct the necessary functor, like this: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">Func&lt;Dictionary&lt; <font color="#0000ff">string</font> , <font color="#0000ff">object</font> &gt;, Foo&gt; fooCreator = <br> d =&gt; <font color="#0000ff">new</font> Foo <br> { <br> Name = d.GetValue&lt; <font color="#0000ff">string</font> &gt;( <font color="#A31515">"Name"</font> ), <br> Value = d.GetValue&lt; <font color="#0000ff">int</font> &gt;( <font color="#A31515">"Value"</font> ) <br> }; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Where GetValue () is an extension method for a dictionary: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">static</font> <font color="#0000ff">class</font> DictionaryExtension <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> TType GetValue&lt;TType&gt;( <font color="#0000ff">this</font> Dictionary&lt; <font color="#0000ff">string</font> , <font color="#0000ff">object</font> &gt; d, <font color="#0000ff">string</font> name) <br> { <br> <font color="#0000ff">object</font> <font color="#0000ff">value</font> ; <br> <font color="#0000ff">return</font> d.TryGetValue(name, <font color="#0000ff">out</font> <font color="#0000ff">value</font> ) ? (TType) <font color="#0000ff">value</font> : <font color="#0000ff">default</font> (TType); <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><br>  We already know that, in principle, any piece of code can be represented as an expression tree simply by replacing Func &lt;&gt; with Expression &lt;Func &lt;&gt;&gt;.  Let's take a look at what the compiler will show us when we wrap this functor in an expression (I apologize for the sheet, but it's hard to explain without it): <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a></code> <ol><li>  ParameterExpression CS0 = Expression.Parameter ( <font color="#0000ff">typeof</font> (Dictionary &lt; <font color="#0000ff">string</font> , <font color="#0000ff">object</font> &gt;), <font color="#A31515">"d"</font> ); </li><li>  <font color="#0000ff">var</font> fooCreator = Expression.Lambda &lt;Func &lt;Dictionary &lt; <font color="#0000ff">string</font> , <font color="#0000ff">object</font> &gt;, Foo &gt;&gt; </li><li>  ( </li><li>  Expression.MemberInit </li><li>  ( </li><li>  Expression.New </li><li>  ( </li><li>  (ConstructorInfo) methodof (Foo..ctor), </li><li>  <font color="#0000ff">new</font> Expression [0] </li><li>  ), </li><li>  <font color="#0000ff">new</font> MemberBinding [] </li><li>  { </li><li>  Expression.Bind </li><li>  ( </li><li>  (MethodInfo) methodof (Foo.set_Name), </li><li>  Expression.Call </li><li>  ( </li><li>  <font color="#0000ff">null</font> </li><li>  (MethodInfo) methodof (DictionaryExtension.GetValue), </li><li>  <font color="#0000ff">new</font> Expression [] </li><li>  { </li><li>  CS0, </li><li>  Expression.Constant ( <font color="#A31515">"Name"</font> , <font color="#0000ff">typeof</font> ( <font color="#0000ff">string</font> )) </li><li>  } </li><li>  ) </li><li>  ), </li><li>  Expression.Bind </li><li>  ( </li><li>  (MethodInfo) methodof (Foo.set_Value), </li><li>  Expression.Call </li><li>  ( </li><li>  <font color="#0000ff">null</font> </li><li>  (MethodInfo) methodof (DictionaryExtension.GetValue), </li><li>  <font color="#0000ff">new</font> Expression [] </li><li>  { </li><li>  CS0, </li><li>  Expression.Constant ( <font color="#A31515">"Value"</font> , <font color="#0000ff">typeof</font> ( <font color="#0000ff">string</font> )) </li><li>  } </li><li>  ) </li><li>  ) </li><li>  } </li><li>  ), </li><li>  <font color="#0000ff">new</font> ParameterExpression [] {CS0} </li><li>  ); </li></ol>  <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font> </blockquote><br><br><br>  Let's try to figure it out. <br>  1. The parameter for our expression (which is logical, because our fuctor also accepts one parameter). <br>  2. Our expression is a lambda expression from the functor. <br>  4. We initialize class members <br>  6-10. ... calling the constructor without parameters <br>  11. ... and with the following set of initializers: <br>  13-15.  Foo.name <br>  16. ... whose value is obtained as the result of a method call <br>  18. ... static <br>  19. ... DictionaryExtension.GetValue (note that calling the extension-method is no different from calling the static method) <br>  20. ... with parameters <br>  22. ... d, which will be passed to us as a parameter of the functor <br>  23. ... and the string constant parameter "Name", which is nothing but the name of the property <br>  27-40.  All the same for Foo.Value <br>  43. Actually, the parameter for the functor itself. <br><br><br>  I think it is quite understandable that we can repeat this code, only in place of the MemberBindings [] hard-code array, substitute our own, assembled for this type.  After this, we will only have to somehow execute this expression.  To do this, LambdaExpression has a great Compile () method that compiles our functor from this expression. <br><br><br>  Here is the code of our new creator: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">class</font> ExpressionCreator&lt;T&gt; : ICreator&lt;T&gt; <br> { <br> <font color="#0000ff">private</font> <font color="#0000ff">readonly</font> Func&lt;Dictionary&lt; <font color="#0000ff">string</font> , <font color="#0000ff">object</font> &gt;, T&gt; _creator; <br> <br> <font color="#0000ff">public</font> ExpressionCreator() <br> { <br> <font color="#0000ff">var</font> type = <font color="#0000ff">typeof</font> (T); <br> <font color="#0000ff">var</font> newExpression = Expression.New(type); <br> <font color="#0000ff">var</font> dictParam = Expression.Parameter( <font color="#0000ff">typeof</font> (Dictionary&lt; <font color="#0000ff">string</font> , <font color="#0000ff">object</font> &gt;), <font color="#A31515">"d"</font> ); <br> <font color="#0000ff">var</font> list = <font color="#0000ff">new</font> <font color="#2B91AF">List</font> &lt;MemberBinding&gt;(); <br> <font color="#0000ff">var</font> propertyInfos = type.GetProperties(BindingFlags.Instance | <br> BindingFlags.Public | <br> BindingFlags.SetProperty); <br> <font color="#0000ff">foreach</font> ( <font color="#0000ff">var</font> propertyInfo <font color="#0000ff">in</font> propertyInfos) <br> { <br> Expression call = Expression.Call( <br> <font color="#0000ff">typeof</font> (DictionaryExtension), <br> <font color="#A31515">"GetValue"</font> , <font color="#0000ff">new</font> [] {propertyInfo.PropertyType}, <br> <font color="#0000ff">new</font> Expression[] <br> { <br> dictParam, <br> Expression.Constant(propertyInfo.Name) <br> }); <br> <br> MemberBinding mb = Expression.Bind(propertyInfo.GetSetMethod(), call); <br> list.Add(mb); <br> } <br> <br> <font color="#0000ff">var</font> ex = Expression.Lambda&lt;Func&lt;Dictionary&lt; <font color="#0000ff">string</font> , <font color="#0000ff">object</font> &gt;, T&gt;&gt;( <br> Expression.MemberInit(newExpression, list), <br> <font color="#0000ff">new</font> [] {dictParam}); <br> _creator = ex.Compile(); <br> } <br> <font color="#0000ff">public</font> T Create(Dictionary&lt; <font color="#0000ff">string</font> , <font color="#0000ff">object</font> &gt; props) <br> { <br> <font color="#0000ff">return</font> _creator(props); <br> } <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  We, in fact, repeat the code created by the compiler, but dynamically process all the properties of any given object.  (The construction is completely analogous to the one above). <br><br><br>  The new creator creates 0.01 second (which is 10 times slower than that of reflection, but the designer is called only once) and spends 0.017 seconds to create 10,000 objects (which is 70 times faster). <br><br><br>  By the way, if you create a foo object directly <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">internal</font> <font color="#0000ff">class</font> DirectCreator : ICreator&lt;Foo&gt; <br> { <br> <font color="#0000ff">public</font> Foo Create(Dictionary&lt; <font color="#0000ff">string</font> , <font color="#0000ff">object</font> &gt; props) <br> { <br> <font color="#0000ff">return</font> <font color="#0000ff">new</font> Foo <br> { <br> Name = props.GetValue&lt; <font color="#0000ff">string</font> &gt;( <font color="#A31515">"Name"</font> ), <br> Value = props.GetValue&lt; <font color="#0000ff">int</font> &gt;( <font color="#A31515">"Value"</font> ) <br> }; <br> } <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  then it turns out just two times faster than through expressions. <br><br><br>  Here such things allow us to do Expression trees. <br><br><br>  The source code can be found here: <a href="http://docs.google.com/leaf%3Fid%3D0B7F9ExjGEio4YjQ4YWU3YWEtOGVmOS00ZTFjLWEzODYtMjE4MjFmMWJlZGE0%26hl%3Den">tyts</a> . <br><br><br></div><p>Source: <a href="https://habr.com/ru/post/83169/">https://habr.com/ru/post/83169/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../83160/index.html">Exit Motorola Devour is scheduled for March</a></li>
<li><a href="../83163/index.html">What needs to be done for the widespread adoption of IPv6?</a></li>
<li><a href="../83164/index.html">SEO and information security</a></li>
<li><a href="../83166/index.html">Help when attacking the server?</a></li>
<li><a href="../83167/index.html">Wooden toys-2 or Pitonim on your smartphone</a></li>
<li><a href="../83170/index.html">QUnit. Testing javascript code</a></li>
<li><a href="../83174/index.html">What RAID controller do you use and why (and in more detail in the comments)?</a></li>
<li><a href="../83176/index.html">S90 revision or how to make them ‚Äúsing‚Äù at minimal cost</a></li>
<li><a href="../83177/index.html">Overview of interesting programs from Microsoft Research</a></li>
<li><a href="../83178/index.html">Sites in the web studio portfolio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>