<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Security firmware on the example of the Intel Management Engine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article , the course of researching the safety of firmware industrial switches was described. We have shown that the detected architec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Security firmware on the example of the Intel Management Engine</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f91/dfa/3e8/f91dfa3e858848589dd9cd7e56afd868.png"><br><br>  In the <a href="https://habrahabr.ru/company/dsec/blog/276345/">previous article</a> , the course of researching the safety of firmware industrial switches was described.  We have shown that the detected architectural flaws make it easy to fake firmware images, update switches with them and execute their code on them (and in some cases on clients connecting to switches).  In addition, we have described the possibilities of pinning injected code on devices.  They stressed the low quality of the firmware code and the lack of protection mechanisms against exploitation of binary vulnerabilities. <br>  We promised to give a real example of a strong security model for firmware, where modifying executable code is a very nontrivial task for a potential attacker. <br><br>  Meet <b>the Intel Management Engine subsystem</b> , the most mysterious component of the architecture of modern x86 platforms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h1>  Introduction </h1><br><br>  For a start, thoroughly investigate the subject area.  What is it, where did it come from and why? <br><br>  In 2005, Intel introduced Active Management Technology (AMT) version 1.0 - a solution for remote administration (management, inventory, updating, diagnostics, troubleshooting, etc.) and the protection of destructive computer systems, a kind of analogue technology Intelligent Platform Management Interface (IPMI) used in servers. <br><br><img src="https://habrastorage.org/files/30c/e6d/aba/30ce6dabac5045a7b191e38a3416ce2e.png"><br>  [drawing taken <a href="http://vpro.by/intel-amt-istoriya-poyavleniya-i-razvitiya-funkcionala">from here</a> ] <br><br>  The architecture of AMT 1.0 is based on the microcontroller (Management Engine) integrated into the chipset and endowed with very impressive features, for example: <br><ul><li>  out-of-band access to the network interface (Ethernet), which it shares with the main CPU, but with its own data link controller, monitors all incoming network traffic from which it cuts (using Packet Filter) packets intended for him.  For the OS (the presence and state of which, by the way, does not affect the work of AMT) this traffic is no longer visible; </li><li>  internal web server with TLS encryption; </li><li>  access to peripheral equipment, receiving and storing in non-volatile memory (in the same place as its firmware) information about it. </li></ul><br><br>  And this microcontroller starts working when power is applied to the motherboard of the computer system (i.e. when the computer is connected to the electrical network, even before the user presses the Power button). <br><br><br>  So, the Management Engine is always enabled, but using the AMT capabilities requires activation (implies setting a password, network parameters, ...) in the BIOS setup, or rather in the MEBx setup: <br><br><img src="https://habrastorage.org/files/0f1/4f1/4de/0f14f14deec2420b87c713f742e7cf18.png"><br>  [screenshot taken <a href="http://www.itoxy.com/2011/04/how-to-connect-remotely-to-your-pc-even.html">from here</a> ] <br><br>  It is commendable that the default password (‚Äúadmin‚Äù) when you first log in must be changed to a new one that meets certain requirements: at least 8 characters, among which must be at least one digit, one capital letter and one special.  symbol. <br><br>  After setting up an AMT-compatible computer system, remote administrator <br>  network functions become available (to use them, you must enter a login and password): <br><ul><li>  hardware inventory; </li><li>  web interface (via HTTP over port 16992); </li><li>  Serial Over LAN (SOL) - virtual COM-port through the network, which allows you to turn on / restart / turn off the computer, access the setup menu BIOS; </li><li>  IDE-Redirection (IDE-R) - option to redirect downloads from a local boot device to a remote (pre-prepared system image). </li></ul><br><br>  AMT 1.0 was implemented on the Intel 82573E series Gigabit Ethernet Controller network module integrated into the South Bridge (Input / Output Controller Hub, ICH). <br><br>  Then, in 2006, starting with AMT version 2.0, the microcontroller was transferred to the north bridge of the chipset (Graphics and Memory Controller Hub, GMCH).  It was then that the subsystem was named in the Intel Management Engine (ME) version 2.0. <br><br><img src="https://habrastorage.org/files/7ee/6ea/1f0/7ee6ea1f00dd4fc9b5823d658d8a92c1.gif"><br>  [drawing taken <a href="http://www.3dnews.ru/editorial/idfm06s_due/page-2.html">from here</a> ] <br><br>  At the same time, the Intel vPro brand appeared, which denoted a complex of technologies implemented on the basis of Intel ME: AMT, Trusted Execution Technology (TXT) and Virtualization Technology (VT).  Later this list includes Identity Protection Technology (IPT) and Anti-Theft (AT). <br><br>  At the same time, Intel ME was provided with even more impressive features, including full access to all the contents of the computer‚Äôs internal memory via an internal DMA controller, and later it became possible to monitor the video stream displayed on the monitor (though only when using the integrated graphics core) . <br><br>  Gradually, more and more various system functions were added to this subsystem (some were previously used by the BIOS) to ensure the operability of the computer platform: <br><ol><li>  part of the functions of the Advanced Control and Power Interface (ACPI) and Alert Standard Format (ASF); </li><li>  Quiet System Technology (QST); </li><li>  Integrated Clock Control (ICC); </li><li>  Trusted Platform Module (TPM); </li><li>  ... </li></ol><br>  and other technologies. <br><br>  AMT also did not stand still and was actively developing: the composition of the protocols used was changed (for example, HTTPS support was added via port 16993), in version 6.0, Remote Desktop feature appeared for the remote administrator, also known as KVM (Keyboard Video Mouse), and so on. <br><br>  You can read more about the development of Intel AMT <a href="http://vpro.by/intel-amt-istoriya-poyavleniya-i-razvitiya-funkcionala">here</a> . <br><br><br>  However, due to the high cost of implementation, this subsystem was present, with a few exceptions, only on motherboards with Intel Q chipsets: <br><table><tbody><tr><th>  GMCH </th><th>  Ich </th><th>  ME / AMT version </th></tr><tr><td>  Q965 </td><td>  ICH8 </td><td>  ME 2.x (AMT 2.x) </td></tr><tr><td>  GM965 / GME965 / GL960 / GLE960 / PM965 </td><td>  ICH8M </td><td>  ME 2.5.x (AMT 2.5.x) &lt;- first appearance on laptops </td></tr><tr><td>  Q35 </td><td>  ICH9 </td><td>  ME 3.x (AMT 3.x) </td></tr><tr><td>  GM45 / PM45 </td><td>  ICH9M </td><td>  ME 4.x (AMT 4.x) &lt;- only on laptops </td></tr><tr><td>  Q45 </td><td>  ICH10 </td><td>  ME 5.x (AMT 5.x) </td></tr></tbody></table><br><br>  Then why all this specific hardware with a vPro nameplate, which few (in the Russian Federation) acquired because of the high cost (and other reasons)? <br><br>  The fact is that, starting in 2010, together with the transfer of part of the functional blocks of the north bridge (graphics core, memory controller, ...) into the CPU case, the Intel ME subsystem was built into all Intel-made chipsets.  At the same time, the ME controller remained in the chipset case - in the Platform Controller Hub (PCH).  These are chipsets 5 series and higher. <br><br>  So, the chronology of subsequent versions for desktops and laptops: <br><table><tbody><tr><th>  PCH </th><th>  ME / AMT version </th></tr><tr><td>  5 series chipset </td><td>  ME 6.x (AMT 6.x) </td></tr><tr><td>  6 series chipset </td><td>  ME 7.x (AMT 7.x) </td></tr><tr><td>  7 series chipset </td><td>  ME 8.x (AMT 8.x) </td></tr><tr><td>  8 series chipset </td><td>  ME 9.x (AMT 9.x) </td></tr><tr><td>  9 series chipset </td><td>  ME 9.5.x / 10.x (AMT 9.5.x / 10.x) </td></tr><tr><td>  100 series chipset </td><td>  ME 11.x (AMT 11.x) </td></tr></tbody></table><br><br>  Note: AMT functionality remains available only on Q chipsets, i.e.  only on equipment with a vPro nameplate. <br><br><br>  Think only desktops and laptops?  No, Intel is the answer! <br><br>  The same fate befell the server platforms from Intel: the subsystem is built into them, but under a different name - Intel Server Platform Services (SPS).  There was an appearance in the SoC (System-on-a-Chip) under the name Intel Trusted Execution Engine (TXE). <br><br><br>  As a result, the architecture of each modern mobile / laptop / desktop / server computer platform with Intel's chipset / SoC includes the most secretive (from the system user) and the preferred execution environment - the Intel ME subsystem.  Not surprisingly, developing this architecture, Intel was forced to seriously work on its protection against compromise. <br><br>  Let us take a breath and consider the architecture of this subsystem in order to understand the applied security model.  Suddenly it will help calm down? <br><br><br><h1>  Intel ME Architecture </h1><br><br>  The Intel Management Engine (ME) is a subsystem built into computer platforms that provides hardware and software support for various Intel technologies. <br><br>  As already mentioned, the first versions of this subsystem were based on Intel's two-case chipsets.  Then the ARCtangent-A4 was used as the base model of the ME controller with the standard ARC32 command system. <br><br><img src="https://habrastorage.org/files/00a/7d6/745/00a7d6745a1d477c818ca6a748b3dbb9.png"><br>  [picture taken from book 1] <br><br><br>  ARCtangent-A5 / ARC600 with a compact ARCompact command system (ARC16 / 32) has already been used in single-chip chipsets. <br><br><img src="https://habrastorage.org/files/72f/c26/50d/72fc2650d7d247a391f1b47b318caaac.png"><br>  [picture taken from book 1] <br><br><br>  In the Intel SoC (where this subsystem is called Intel TXE), SPARC is used as the base model for the ME controller. <br><br><br>  ARC, SPARC, and some, yes?  Reversion will be uncomfortable! <br><br>  It's okay, Intel took care of this: in the latest platforms (Skylake, 100 series chipsets, Intel ME 11.x), the ME controller has an ... x86 architecture! <br>  Yes, yes, there is another x86 in the chipsets. <br><br><br>  However, the composition of the components of the Intel ME subsystem (since version 2.0) has not changed.  It: <br><ol><li>  <b>ME controller</b> - built-in chipset 32-bit microcontroller type RISC, having internal ROM and SRAM; </li><li>  <b>The ME region in the SPI flash memory</b> , which stores the ME controller firmware developed and signed by Intel (therefore, it is the <i>Intel ME firmware</i> ); </li><li>  <b>ME UMA</b> - hidden from everyone except the ME controller area (16 - 32 MB) in the computer‚Äôs RAM, which it uses as a runtime-memory for locating and launching the firmware; </li><li>  <b>Management Engine Interface (MEI)</b> , formerly known as the <b>Host Embedded Controller Interface (HECI)</b> , is a set of registers in the PCI configuration space and an area in the MMIO, which is an interface for exchanging information with the ME controller (in fact, the only communication channel of software running on CPU, with Intel ME subsystem); </li><li>  <b>Separate MAC</b> -channel controller, providing the out-of-band ME controller with access to a common physical network interface for remote administration of a computer system; </li><li>  <b>Some modules in the BIOS</b> that are responsible for platform initialization and report the results of their work to the ME controller via the MEI. </li></ol><br><br>  In the case of the Intel vPro nameplate, the Intel ME subsystem also includes the BIOS BIOS <b>BIOS Extenstion Module (MEBx)</b> , providing a graphical interface (shown above), as well as enabling and configuring AMT via MEI. <br><br><br>  Thus, we have the execution environment ring -3 (as it is conventionally called) - 1 piece.  Its privilege is due to the abilities with which the ME controller is endowed (described above), and the secrecy is completely lacking the ability to control software (and even hardware, in production versions of the boards) by means. <br><br><img src="https://habrastorage.org/files/af2/2d2/f87/af22d2f8776a41fe80c7d43e3d2b5a1f.jpg"><br><br><br><h1>  ME controller architecture </h1><br><br>  Inside the ME controller, in addition to the ARC / SPARC / x86 microprocessor: <br><ul><li>  ME ROM - non-volatile write once memory in which the start code of the ME controller is stored; </li><li> ME SRAM - RAM used by a ME controller when ME UMA is unavailable, for example, in the early stages of work; </li><li>  code cache and data cache to improve performance when working with memory; </li><li>  C-Link (Controller Link) - bus that allows the ME-controller to interact with peripheral hardware in S5 (System shutdown) / S3 (Sleep mode); </li><li>  Various hardware blocks: </li><li><ul><li>  high precision timer and WDT; </li><li>  interrupt controller; </li><li>  memory controllers and DMA; </li><li>  HECI / MEI interface; </li><li>  RNG, accelerator of cryptographic functions and compression functions. </li></ul></li></ul><br><br><img src="https://habrastorage.org/files/a9a/69b/953/a9a69b9538294a1cbe7f6b23dc4b0dbf.png"><br>  [picture taken from book 2] <br><br><br>  It's time to figure out how the code that manages all this wealth is protected from modifications. <br><br><br><h1>  Intel ME Firmware </h1><br><br>  Intel ME firmware, depending on the content, are of two types: <br><ul><li>  1.5 MB, trimmed versions; </li><li>  5 MB full versions. </li></ul><br><br>  The type of firmware determines the composition of the application modules that implement certain technologies (for example, AMT, IPT, etc.).  Although there is a basic part, the same for different firmware: <br><ol><li>  Bring Up, the first module launched from the firmware; </li><li>  Kernel, ThreadX RTOS Core; </li><li>  Some drivers and services. </li></ol><br><br>  A general description of the contents of the Intel ME firmware can be found in book 2 from the list of references, but more detailed information about the structures (analyzed analytically) can be found, for example, in <a href="https://github.com/skochinsky/me-tools/blob/master/me_unpack.py">this script</a> to unpack the Intel ME firmware. <br><br>  Let's go in order. <br><br><br>  There are several regions in SPI flash: <br><ol><li>  Flash Descriptors, which stores pointers to all other regions, as well as read / write privileges for users of this memory.  Note that usually these descriptors do not allow the ME region to be overwritten by everyone except the ME controller itself; </li><li>  GbE (Gigabit Ethernet); </li><li>  ME, ME controller firmware is stored here; </li><li>  BIOS; </li><li>  3PDS (Third Party Data Storage), optional region. </li></ol><br><br><img src="https://habrastorage.org/files/e68/f62/5c2/e68f625c24744e3eb8a03bfef9b36df5.png"><br>  [picture taken <a href="https://recon.cx/2014/slides/Recon%25202014%2520Skochinsky.pdf">from here</a> ] <br><br><br>  Now take a look at the ME region itself, here is an example of the content from its beginning: <br><br><img src="https://habrastorage.org/files/0ab/4d9/f9e/0ab4d9f9e93942c987e96a585f93778a.png"><br><br>  This is the Flash Partition Table (FPT) - a table of ME firmware sections.  It stores pointers to various types (code, data, virtual area, ...) sections and their parameters.  The integrity of this table is controlled by one byte of the checkum at an offset of 1Bh. <br><br>  We are interested in executable partitions, i.e.  those that store executable code.  There are usually several of them, consider one of them: <br><br><img src="https://habrastorage.org/files/1ef/8d9/bf2/1ef8d9bf2b3c4c75ac54460ba8c32161.png"><br><br>  At the beginning of the code section is the manifest, which consists of a header (with service data and EDS) and a table of modules. <br>  In the given dump you can see a 2048-bit public RSA key (module at offset 80h relative to the beginning of the section and exponent at offset 180h).  This is followed by a 256 byte signature. <br><br>  With its private key, Intel signs part of the manifest header and module table (see the following dump), applying the received signature and public key for verification. <br><br>  And here is a fragment of the module table of the section in question: <br><br><img src="https://habrastorage.org/files/603/bb8/58f/603bb858f93f4926ac747b95981ecd73.png"><br><br>  This table contains the headers of the modules, where some parameters and the SHA256 hash sum (at offset 14h inside the header) are indicated. <br><br><br>  Generating your own RSA-2048 key pair and signing the partition with them will not work, since the integrity of the attached public key is verified by the start code in the ME ROM, which stores the SHA256 hash sum of the Intel public key. <br><br><br>  As a result, the verification scheme of the ME firmware code section can be summarized in the figure: <br><br><img src="https://habrastorage.org/files/596/dbb/058/596dbb058cbf4213a80d7d048034c99d.jpg"><br><br>  Each code section is verified by this scheme. <br><br>  This is more than enough to protect the firmware from counterfeiting.  It is impossible to overwrite the ME region of the SPI flash memory programmatically (remember the permissions in Flash Descriptors), the hardware will of course allow to bypass this limitation, but the authentication control cannot be turned off. <br><br><br>  Finally, we will look at protecting against binary vulnerabilities. <br><br>  We saw that all the executable ME firmware code is divided into modules for different purposes: <br><br><img src="https://habrastorage.org/files/037/f0b/881/037f0b881b86439e9d33fbf4c3eb26f6.png"><br>  [picture taken from book 1] <br><br>  The ME controller has two modes of operation: privileged and user (analogous to kernel mode and user mode for the CPU).  Privileged mode distinguishes, first of all, the ability to access hardware resources and the ability to access addresses outside the allocated memory range for this module. <br><br>  Each module starts and runs in the specified (in the header of this module) mode. <br><br><img src="https://habrastorage.org/files/eda/a46/c11/edaa46c11814478381638ce366ffba9d.png"><br>  [picture taken from book 1] <br><br>  After parsing the entire ME region, you can see that the privileged mode is used by the RTOS core and some drivers.  Services and application modules, as expected, are given only user mode. <br><br><br><h1>  Conclusion </h1><br><br>  We showed that the Intel ME subsystem is an integral part of the architecture of modern computer platforms (based on Intel chipsets / SoC).  Obviously, its compromise provides a potential attacker with unlimited control over the platform: access to all the contents of the RAM (system memory, hypervisor memory, SMRAM, ACRAM, allocated memory for the graphics core - GFX UMA), out-of-band access to the network interface (monitoring of all network traffic), remote control as part of the standard AMT functionality, overwriting any SPI flash memory regions.  A bonus to this is the complete lack of detection capabilities. <br><br>  This is a good reason for having Intel ME serious security.  We believe that vendors of any embedded network equipment should strive for the described security model.  It is characterized by the following principles: <br><ul><li>  a ban on the use of a default password, forcing to set a strong password (corresponding to certain requirements); </li><li>  use of encryption functions in network protocols; </li><li>  control of the integrity and authenticity of the entire executable firmware code; </li><li>  protection mechanisms against exploitation of binary vulnerabilities. </li></ul><br><br>  I will comment in advance on possible calls to use computer platforms based on CPUs and AMD chipsets: they have a very similar technology, called the Platform Security Processor (PSP).  Presented not long ago, in 2013.  Not much is known about it so far, but something can be read <a href="https://habrahabr.ru/post/268423/">here</a> . <br><br><br><hr><br><br><h3>  Bibliography </h3><br><br>  1. A. Kumar, "Active Platform Management Demystified: Unleashing the Power of Intel VPro (TM) Technology", 2009, Intel Press. <br><br>  2. Xiaoyu Ruan, "Platform Embedded Security Technology Revealed: Safeguarding the Future of Computing with Intel Embedded Security and Management Engine", 2014, APress. </div><p>Source: <a href="https://habr.com/ru/post/278549/">https://habr.com/ru/post/278549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278537/index.html">libuniset2 is a library for creating ACS. It is better to see once ... Part 2 (Running the simulator)</a></li>
<li><a href="../278539/index.html">Preparing for the CISA exam. Business Continuity Practices</a></li>
<li><a href="../278541/index.html">We invite you to a round table on gaming industry trends.</a></li>
<li><a href="../278545/index.html">Complex hardware nodes, simultaneous parallel execution and kernel / system runtime</a></li>
<li><a href="../278547/index.html">6 secrets of Bitbucket</a></li>
<li><a href="../278551/index.html">fsharpConf 2016 - Live Broadcast of the F # Virtual Conference</a></li>
<li><a href="../278553/index.html">How we fought parsers</a></li>
<li><a href="../278555/index.html">Security Week 09: DROWN attack, HackingTeam returns, impressions from RSA Conference 2016</a></li>
<li><a href="../278557/index.html">Three small but useful buns in Laravel 5.2.22</a></li>
<li><a href="../278559/index.html">New resource about Intel technologies for game developers on Unity3D.com</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>