<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microsoft Dryad vs Apache Hadoop. Uncomplicated Big Data Battle</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="UPD: changed the title of the article, because I wrote the last heading while I was a lunatic (joke, of course). 



 Last week, 2 posts about the Mic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microsoft Dryad vs Apache Hadoop. Uncomplicated Big Data Battle</h1><div class="post__text post__text-html js-mediator-article">  UPD: changed the title of the article, because  I wrote the last heading while I was a lunatic (joke, of course). <br><br><p>  Last week, 2 posts about the Microsoft Research - Dryad framework of distributed computing appeared on Habr√©.  In particular, the concepts and architecture of the key components of Dryad ‚Äî the <a href="https://habr.com/post/182164/">Dryad</a> execution environment and the <a href="https://habr.com/post/182282/">DryadLINQ</a> query language ‚Äî were described in detail. <br></p><br><p>  The logical conclusion of the cycle of articles about Dryad seems to be a comparison of the Dryad framework with other tools MPP-applications familiar to developers: <i>relational DBMS</i> (including parallel ones), <i>GPU computing</i> and <i>the <a href="http://0xcode.in/hadoop-insight">Hadoop</a> platform</i> . <br></p><br><img alt="RDBMS vs Hadoop vs Dryad" src="https://habrastorage.org/storage2/010/7a1/493/0107a1493a8c217da2fa0b4365cf2fc7.png"><br><br><a name="habracut"></a><div class="spoiler">  <b class="spoiler_title">Lyrical digression (or when you write something about Microsoft products)</b> <div class="spoiler_text">  In the last article of the cycle I mentioned all the theses below.  But since the reader is not obliged to read all my articles (and even more so to remember what I wrote), I consider it appropriate to repeat. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I <i>do not suggest</i> , <i>nor do I discourage the</i> use of Dryad in my research projects (since only an academic license is now available). <br>  Dryad is an <i>‚Äúinternal‚Äù product to</i> all of us known <s>evil</s> corporation, the development of which [product and evil] is the <i>internal affair of</i> this corporation (which is quite fair). <br><br>  The fact that Dryad is proprietary software is not (I speak for myself) studying the principles and architecture of this platform less interesting or useful for professional development (again for myself).  If you have something different, then <s>this is not</s> your business. <br></div></div><br>  In the first part, using Dryad as an example, a general review will be made of the advantages of distributed computing frameworks, which provide developers with high-level abstractions, over lower-level computation parallelization tools - MPI and GPU calculations. <br><br>  Such a comparison in isolation from the context (ie, a specific task) is incorrect, but it is acceptable for our purpose - to show cases of the appropriate use of distributed application execution frameworks. <br><br>  The second part will be compared with RDBMS and parallel DBMS.  Of course, the publication volume does not allow comparing Dryad separately with MySQL and separately with SQL Server 2012 Parallel Data Warehouse (and why?).  Therefore, the ‚Äúaverage hospital temperature‚Äù of the DBMS is taken for analysis: let's discuss the common problems of solutions based on relational databases and consider Dryad as a continuation of the best ideas of the DBMS world. <br><br>  In the final part, a comparison will be made with the Hadoop software platform (the latter can either not know or admire). <br><br>  Hadoop has 2 big advantages (of course, more) - a <i>new framework</i> (about it later), providing an API for implementing your own distributed algorithms, and a <i>rich ecosystem</i> .  Paradoxically, these are the main drawbacks of Hadoop: a new beta framework (the start of development is 2008), and without installing many components from the Hadoop ecosystem (installation, training, support), using Hadoop in the enterprise segment is not a trivial task. <br><br>  Therefore, comparing Dryad comes with the <i>release branch of plain Hadoop</i> and an endless look at the opportunities provided by the Hadoop ecosystem, and how this problem (if any) will be solved in Hadoop v2.0. <br><br><h2>  1. Dryad vs GPU.  Dryad vs mpi <br></h2><br><p>  Taking into account the availability of the academic license of Dryad, I became interested in the possibility of using the Dryad framework in calculations for research (I am a graduate student).  But historically, in an academic environment (my university, for sure), the main platforms for ‚Äúscientific computing‚Äù are MPI (Message Passing Interface) and GPU computing. <br></p><br><p>  Unlike MPI, the Dryad platform is based on a <em>shared-nothing architecture</em> that does not have shared (different processes) data and, as a result, <em>does not need to use synchronization primitives</em> .  This makes the Dryad cluster not only potentially more scalable, but also more time-efficient for solving problems that use data-parallel algorithms. <br></p><br><p>  In addition, <em>infrastructure tasks</em> such as monitoring execution, handling failures are usually <em>the responsibility of the MPI developer</em> , while in Dryad the listed tasks are the responsibility of the framework. <br></p><br><p>  Speaking of GPU computing, it is worth noting that, unlike Dryad, development under <em>GPU is quite strongly related to the hardware level</em> at which the application is launched.  NVidia and AMD provide their own SDK for development for their graphics cards (CUDA and APP, respectively).  Obviously, these are various incompatible development platforms. <br></p><br><p>  Corporation <del>  of evil </del>  Microsoft attempted to unify the development process for the GPU, releasing C ++ AMP.  But this fact is too much proof that when developing for a GPU, the developer must ‚Äúlook back‚Äù at the hardware of the graphics adapter.  Moreover, the ‚Äúroots‚Äù of the hardware level penetrate the code so deeply that it may be difficult to launch the application even when changing the model of a graphics card, not to mention changing the vendor.  Naturally, this creates additional difficulties both when debugging and when migrating to a more productive / suitable for a specific task hardware platform. <br></p><br><p>  All this, ultimately, forces the researcher to address <i>infrastructure issues</i> related to hardware, debugging, deployment, and support, <i>instead of solving applied issues in the</i> subject area of ‚Äã‚Äãthe study. <br></p><br><p>  The Dryad framework, unlike the GPU, hides the hardware level from the developers of distributed applications, although it does have quite specific hardware platform requirements for running a distributed application (the requirements were discussed in the <a href="https://habr.com/post/182164/">first article of the</a> cycle). <br></p><br><h2>  2. Dryad vs Parallel DB <br></h2><br><p>  The main fundamental difference between Dryad and a DBMS is the <em>absence of strong connectivity between the storage layers, the execution layer and the</em> Dryad <em>program model</em> , and the presence of such connectivity for the DBMS.  This distinction is demonstrated on <br>  <a href="">illustration</a> in the introduction. <br></p><br><p>  Nevertheless, Dryad "absorbed" many of the ideas of the world, both traditional and parallel DBMS. <br></p><br><p>  So, like many <em>parallel DBMSs</em> (Teradata, IBM DB2 Parallel Edition), Dryad uses a shared-nothing architecture, sharding (horizontal partitioning), dynamic repartitioning, partitioning strategies: hash-partitioning, range partitioning and round-robin. <br></p><br><p>  From the world of <em>traditional DBMS</em> , the concepts of query optimizer and execution plan were taken.  These concepts were extremely transformed: the result of the work of the DryadLINQ scheduler is the execution graph (EPG, Execution Plan Graph), which is dynamically changed based on policies and collected during the execution of statistics. <br></p><br><p>  Like all DBMSs, Dryad uses a data query language.  In Dryad, the DryadLINQ programming model plays the role of a query language.  <em>But unlike SQL, DryadLINQ:</em> <br>  + was originally <em>designed to work with data structures and complex types</em> ; <br>  + is a <em>high-level abstraction</em> that does not associate the application level with the level <br>  storage; <br>  + has <em>native support for common programming patterns</em> , such as iterations; <br>  - does not support transactions and update operations. <br></p><br><p>  In addition, SQL is not fundamentally suitable for describing machine learning algorithms, parsing sequences of facts (logs, genomic databases), graph analysis.  Also, Dryad is ineffective for solving problems based on algorithms that require random-access data access. <br></p><br><p>  Below is a table comparing solutions based on relational database management systems and based on distributed computing frameworks. <br></p><br><img alt="RDBMS vs Hadoop and Dryad" src="https://habrastorage.org/getpro/habr/post_images/d08/e53/e8b/d08e53e8b0809502a44f72275881e5f6.png"><br><br><p>  In the conclusion of the comparison, I note: the greatest obstacle to the wide distribution of solutions based on parallel DBMS is the cost of the solution, which, in general, amounts to hundreds of thousands of dollars.  How much would cost a solution based on the Dryad-cluster can only be assumed;  in my opinion, we are talking about the amount much lower. <br></p><br><h2>  3. Dryad vs Hadoop <br></h2><br><p>  <em>The map / reduce paradigm is an extremely elegant way of describing data parallel algorithms.</em>  The emergence of Hadoop, which provided the execution infrastructure and software model for writing map / reduce-applications, was a revolutionary leap in solving Big Data problems. <br></p><br><img alt="Dryad vs Hadoop vs MPI" src="https://habrastorage.org/getpro/habr/post_images/f5b/98b/263/f5b98b2636b616fe8d770f8b1393c3e6.png"><br><p>  * Directed Acyclic Graph (English Directed Acyclic Graph). </p><br><p>  ** Only beta version is available (as of June 2013). </p><br><p>  *** Any CLS-compatible PL with static typing. </p><br><p>  **** Infrastructure for deploying Hadoop cluster and executing Hadoop tasks. </p><br><p>  ***** Only available when installing third-party components of the Hadoop ecosystem. </p> <br><br><h3>  3.1.  Hadoop <br></h3><br><p>  <em>The ideologists and developers of Hadoop, discarding everything superfluous, made a simple, understandable to the maximum circle of developers, an extremely effective and equally limited platform for developing MPP applications.</em> <br></p><br><p>  Hadoop is perfect for map / reduce and so far does not stand up to scrutiny when developing for other distributed algorithms (waiting for YARN).  Hence, a huge number of Hadoop support tools, based both on the Hadoop MapReduce computing framework (such as, Pig), and representing separate computing frameworks (Hive, Storm, Apache Giraph).  And all these tools provide often duplicate <i>solutions for problems of a narrow nature</i> (in fact, bypassing restrictions) instead of providing a <i>single universal tool for solving</i> both log parsing and PageRank counting and graph analysis. <br></p><br><p>  Naturally, installing, configuring and maintaining the entire Hadoop ecosystem that is necessary for solving everyday analytics tasks are considerable time and, as a result, financial costs that go to solving <em>infrastructure</em> problems, not <em>business and / or researcher tasks</em> .  As a partial solution to this problem, distributors of the Hadoop platform appeared in assembled form (the largest of them are Cloudera and Hortonworks).  But this is still <em>not a solution to the</em> problem - this is <em>another confirmation of</em> its presence. <br></p><br><p>  An evolutionary leap will be (for the time being in the future tense) a software framework <a href="https://habr.com/post/161437/">YARN</a> , <em>providing developers with the components and API needed to develop distributed algorithms</em> other than map / reduce.  YARN also solves many of the problems of Hadoop v1.0, including low resource utilization and scalability threshold, which are now at ~ 4K compute nodes (while Dryad already worked on 10K nodes in 2011). <br></p><br><p>  As of May 2013, YARN is not yet in the release version.  Considering the ‚Äúslowness‚Äù of the Apache community, it is necessary to take into account the high probability that the time interval between the release of the release version of YARN and the release versions of distributed algorithms other than map / reduce, written using the YARN API, may be years. <br></p><br><h3>  3.2.  Dryad <br></h3><br><p>  The Dryad framework initially allowed developers to implement arbitrary distributed algorithms.  Thus, <em>the Hadoop MapReduce (v1.0) software model is only a special case of the more general Dryad software model</em> . <br></p><br><p>  We will not delve into the problems of Hadoop with Join operations, the efficiency of calculating PageRank, <a href="http://www.codeinstinct.pro/2012/08/hadoop-design.html">other limitations of</a> the Hadoop platform, and ways to solve them, as this is clearly beyond the scope of the article.  Instead, we will discuss the possibilities of the Dryad framework, which have no analogues in the Hadoop platform. <br></p><br><p>  Dryad has an impressive list of tools for <em>planning the execution of a distributed application</em> , described in previous articles of the cycle.  So there is a <em>parallel compiler</em> that converts expressions written in DryadLINQ into an execution graph - EPG.  The EPG passes the optimization stage both before execution ( <em>static optimizer</em> ) and during execution ( <em>dynamic optimization</em> based on policies and statistics collected during execution). <br></p><br><p>  The parallel compiler, the execution graph and the static / dynamic graph optimization feature make the planning / execution of a distributed application open for improvements and optimizations. <br></p><br><p>  The concept of a <em>directed acyclic graph</em> allows you to solve many problems related to <em>fault tolerance, monitoring, planning and resource management</em> , in much more elegant ways than is implemented in Hadoop (I wrote about this in the first article of the cycle). <br></p><br><div class="spoiler">  <b class="spoiler_title">Processing failures of computational nodes, processing "slow" nodes, dynamic aggregation in Dryad (illustration)</b> <div class="spoiler_text"><img alt="Dryad. Fault tolerance" src="https://habrastorage.org/getpro/habr/post_images/4ef/73a/097/4ef73a097843bb424e6cad8d37f473a8.png"><br>  Failure processing of compute nodes allows you to not restart the entire stage again. <br><br><img alt="Dryad. Slow vertex" src="https://habrastorage.org/getpro/habr/post_images/81d/f84/33a/81df8433a6c45dc25f92997573ca3fea.png"><br>  Processing "slow" compute nodes allows you not to "wait" for the nodes that have "completed" the work, the slowest node (for example, to start the Reduce phase) <br><br><img alt="Dryad. Dynamic aggregation" src="https://habrastorage.org/getpro/habr/post_images/8de/1b6/396/8de1b63969a64a864c8eaa980b5ee7d7.png"><br>  Dynamic aggregation in Dryad avoids degradation of network bandwidth before the next stage (for example, convolution). <br><br></div></div><br><p>  Another interesting feature that Hadoop lacks is the <em>abstraction of the notion of channel</em> .  Due to the introduced abstraction, the channel in Dryad can be either TCP, or a temporary file and shared memory FIFO.  That allows in such algorithms as the calculation of PageRank, to exchange data between iterations through channels with low latency (for example, shared memory FIFO).  While in Hadoop, data transfer between iterations will always go over TCP channels that have a rather high latency compared to shared memory.  (There is information that this behavior was corrected in YARN, but I haven‚Äôt yet seen a working confirmation.) <br></p><br><img alt="PageRank Execution Plan" src="https://habrastorage.org/getpro/habr/post_images/2c1/701/5b2/2c17015b2951ebabfd67f984beaf7e6e.png"><br>  Source of illustration [7] <br><br><p>  Some architectural solutions from Dryad (one of which was discussed in the previous article, ‚Äúattaching‚Äù metadata to execution graphs) and native support of the framework for high-level PL with static typing allowed the development of Dryad applications with <em>extremely strictly typed data</em> .  While for developers under Hadoop, the usual practice is parsing the input data and further (not the safest) conversion to the expected type. <br></p><br><h3>  3.3.  Practice <br></h3><br><p>  Below are listings of arithmetic mean calculating applications for Hadoop and Dryad using low-level APIs. <br></p><br><p>  Listing 1. Calculation of arithmetic mean in Hadoop (Java).  Source [1]. <br></p><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// InitialReduce: input is a sequence of raw data tuples; // produces a single intermediate result as output static public class Initial extends EvalFunc&lt;Tuple&gt; { @Override public void exec(Tuple input, Tuple output) throws IOException { try { output.appendField(new DataAtom(sum(input))); output.appendField(new DataAtom(count(input))); } catch(RuntimeException t) { throw new RuntimeException([...]); } } } // Combiner: input is a sequence of intermediate results; // produces a single (coalesced) intermediate result static public class Intermed extends EvalFunc&lt;Tuple&gt; { @Override public void exec(Tuple input, Tuple output) throws IOException { combine(input.getBagField(0), output); } } // FinalReduce: input is one or more intermediate results; // produces final output of aggregation function static public class Final extends EvalFunc&lt;DataAtom&gt; { @Override public void exec(Tuple input, DataAtom output) throws IOException { Tuple combined = new Tuple(); if(input.getField(0) instanceof DataBag) { combine(input.getBagField(0), combined); } else { throw new RuntimeException([...]); } double sum = combined.getAtomField(0).numval(); double count = combined.getAtomField(1).numval(); double avg = 0; if (count &gt; 0) { avg = sum / count; } output.setValue(avg); } } static protected void combine(DataBag values, Tuple output) throws IOException { double sum = 0; double count = 0; for (Iterator it = values.iterator(); it.hasNext();) { Tuple t = (Tuple) it.next(); sum += t.getAtomField(0).numval(); count += t.getAtomField(1).numval(); } output.appendField(new DataAtom(sum)); output.appendField(new DataAtom(count)); } static protected long count(Tuple input) throws IOException { DataBag values = input.getBagField(0); return values.size(); } static protected double sum(Tuple input) throws IOException { DataBag values = input.getBagField(0); double sum = 0; for (Iterator it = values.iterator(); it.hasNext();) { Tuple t = (Tuple) it.next(); sum += t.getAtomField(0).numval(); } return sum; }</span></span></code> </pre> <br><p>  Listing 2. Calculate the arithmetic average in Dryad (C #).  Source [1]. <br></p><pre> <code class="hljs java"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitialReduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; g)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPair(g.Sum(), g.Count()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Combine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IEnumerable&lt;IntPair&gt; g)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPair(g.Select(x =&gt; x.first).Sum(), g.Select(x =&gt; x.second).Sum()); } [AssociativeDecomposable(<span class="hljs-string"><span class="hljs-string">"InitialReduce"</span></span>, <span class="hljs-string"><span class="hljs-string">"Combine"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PartialSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; g)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InitialReduce(g); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Average</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; g)</span></span></span><span class="hljs-function"> </span></span>{ IntPair <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> = g.Aggregate(x =&gt; PartialSum(x)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span>.second == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">final</span></span>.first / (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">final</span></span>.second; }</code> </pre><br><h3>  3.4.  Developer Accessibility <br></h3><br><p>  Dryad is a proprietary system with a hazy future (or rather no such) at all, rather closed from the professional community.  In contrast, Hadoop is an open-source project with a huge community, a clear licensing method, and several large distributors (Cloudera, Hortonworks, etc.). <br></p><br><p>  In conclusion, the chapter on comparison with Hadoop, I note that getting a Hadoop cluster into its use at the current level of cloud services development is not difficult: Amazon Web Services provides Hadoop cluster through its <a href="http://www.codeinstinct.pro/2012/09/amazon-elastic-mapreduce-overview.html">Amazon Elastic MapReduce service</a> , and the Windows Azure cloud platform - through <a href="http://www.codeinstinct.pro/2012/12/hdinsight.html">Microsoft HDInsight</a> service . <br></p><br><p>  With the advent of the bunch ‚ÄúHadoop + {WA |  AWS} "The availability of the Hadoop platform for startups and researchers has become extremely high.  There is no need to talk about the availability of Dryad: there are no commercial licenses, almost no one talked about academic use. <br></p><br><p>  Hadoop is the de facto standard for working with Big Data.  There is an expectation that after the future release of YARN no one will have any doubt that the platform has become deserved by this standard.  As for the project, Dryad seems to have reincarnations, one of them is <a href="http://research.microsoft.com/en-us/projects/naiad/">Naiad</a> (incremental Dryad);  and the principles laid down in Dryad, for sure, have been continued not only in Microsoft Research projects, but also in the open-source community. <br></p><br><h2>  Conclusion <br></h2><br><p>  The Dryad framework, having in its basis the <em>concept of a directed acyclic graph</em> , imposed on this concept the <em>latest ideas of the world of frameworks of distributed execution of applications of traditional and parallel DBMS</em> .  <em>Sharing responsibilities</em> related to the execution environment, distributed storage and software model between the individual modules allowed Dryad to remain an extremely flexible system;  and <em>tight integration with the existing software stack</em> for .NET developers (.NET Framework, C #, Visual Studio) significantly reduces the time required to start working with the framework. <br></p><br><p>  <em>A simple and elegant concept, innovative ideas, beautiful architecture and a familiar technology stack make Dryad an effective tool for working with Big Data.</em>  More efficient than hardware-specific GPU computing;  poorly scalable solutions based on traditional DBMS;  expensive and limited to the primitiveness of the SQL language solutions based on parallel DBMS.  Dryad surpasses the ‚Äúlooped‚Äù Hadoop on the map / reduce model, which suffers before the emergence of YARN, sometimes from single points of failure, sometimes from low utilization of resources, or from the inertia of its own community. <br></p><br><p>  At the same time, all the obvious advantages of Dryad are easily leveled by the nature of this product - this <em>is Microsoft‚Äôs proprietary product for internal use</em> , which Microsoft alone decides the fate of. <br></p><br><p>  But this does not prevent <em>Dryad from</em> being what it is - a <em>new interesting look, an innovative vision of Microsoft Research's distributed application execution systems.</em> <br></p><br><h2>  List of sources <br></h2><br>  [1] Y. Yu, PK Gunda, M. Isard.  <i>Distributed Aggregation for Data-Parallel Computing: Interfaces and Implementations</i> , 2009. <br>  [2] M. Isard, M. Budiu, Y. Yu, A. Birrell, and D. Fetterly.  <i>Dryad: Distributed data-parallel programs from sequential building blocks</i> .  In Proceedings of the European Conference on Computer Systems (EuroSys), 2007. <br>  [3] Tom White.  <i>Hadoop: The Definitive Guide, 3rd Edition.</i>  O'Reilly Media / Yahoo Press, 2012. <br>  [4] Arun C Murthy.  <a href="http://developer.yahoo.com/blogs/hadoop/next-generation-apache-hadoop-mapreduce-3061.html"><i>The Next Generation of Apache Hadoop MapReduce</i></a> .  Yahoo 2011 <br>  [5] D. DeWitt and J. Gray.  <i>Parallel database systems: The future of high performance database processing.</i>  Communications of the ACM, 36 (6), 1992. <br>  [6] David Tarditi, Sidd Puri, and Jose Oglesby.  <i>Accelerator: using data-parallelism to program GPUs for general-purpose uses.</i>  International Conference on Architectural Support for Programming Languages ‚Äã‚Äãand Operating Systems (ASPLOS), Boston, MA, October 2006. <br>  [7] Jinyang Li.  <i>Dryad / DryadLinq Slides adapted from those of Yuan Yu and Michael Isard</i> , 2009. </div><p>Source: <a href="https://habr.com/ru/post/182688/">https://habr.com/ru/post/182688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182674/index.html">Android is behind the ‚ÄúInternet of Things‚Äù - and it's everywhere</a></li>
<li><a href="../182676/index.html">Access to hidden UEFI BIOS settings from Insyde</a></li>
<li><a href="../182678/index.html">Creating a multiplayer realtime game on node.js</a></li>
<li><a href="../182684/index.html">Bees can communicate through weak electric fields</a></li>
<li><a href="../182686/index.html">Bruce Schneier: The Illusion of Security</a></li>
<li><a href="../182690/index.html">We optimize Boid's on Unity</a></li>
<li><a href="../182698/index.html">Edward Snowden: an informant who gave secrets to the NSA</a></li>
<li><a href="../182702/index.html">How to test the finalizer code (c #)</a></li>
<li><a href="../182704/index.html">Infographics - Tor, HTTPS and Security</a></li>
<li><a href="../182706/index.html">Camjacking, like the evolution of Clickjacking, or ‚ÄúGyulchatay! Open your face! ‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>