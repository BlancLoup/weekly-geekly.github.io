<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Remove "4D video" using a depth-sensor and Delaunay triangulation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi Habr! This is a note about a small hobby project that I did in my free time. I will tell you how to use simple algorithms to turn depth maps from d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Remove "4D video" using a depth-sensor and Delaunay triangulation</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/web/b83/a96/f64/b83a96f643824c8aa4fe61f21a9ae3e2.gif"></div><br><br>  Hi Habr!  This is a note about a small hobby project that I did in my free time.  I will tell you how to use simple algorithms to turn depth maps from depth sensors into a fun kind of content - dynamic 3D scenes (also called 4D video, volumetric capture or free-viewpoint video).  My favorite part in this paper is the Delaunay triangulation algorithm, which allows you to turn sparse clouds of points into a dense polygonal mesh.  I invite everyone who is interested in reading about algorithms, samopisnye bicycles in C ++ 11, and, of course, look at the three-dimensional seals. <br><br>  For starters: this is what happens when using the RealSense R200: <a href="https://skfb.ly/6snzt">skfb.ly/6snzt</a> (wait a few seconds to load the textures, and then use the mouse to rotate the scene).  There is more under the cut! <br>  Holders of limited rates, be careful.  The article has a lot of different images and illustrations. <br><a name="habracut"></a><br>  <i>Disclaimer: in this article there will not be a word about artificial intelligence, blockchain or gravitational waves.</i>  <i>It's just a small toy, which I wrote mostly to refresh C ++ and OpenGL.</i>  <i>All expectations are formed, let's go!</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Some time ago I got into the hands of a device with a 3D sensor, namely the <a href="">Google Tango Development Kit</a> tablet with the <a href="https://en.wikipedia.org/wiki/3D_scanner">structured light</a> technology.  Naturally, my hands were itching to program something for this interesting device. <br><br>  Just about the same time I first met a new kind of content - 4D video.  By ‚Äú4D video‚Äù I understand three-dimensional scenes that evolve over time in a non-trivial way, i.e.  their behavior cannot be described by a simple model, such as skeletal animation or blendsheep.  In short, something like this: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SkJG-uFU2yA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Such content seemed very interesting to me;  I decided to experiment with it a bit and write my application to generate 4D videos.  Of course, I do not have a studio and resources like Microsoft Research, and there is only one sensor, so the results will be much more modest.  But that won't stop amateur programming, right?  That I succeeded, I will tell in this article. <br><br><div class="spoiler">  <b class="spoiler_title">About the title of the article</b> <div class="spoiler_text">  Admittedly, the name ‚Äú4D video‚Äù is not the best.  The first question: why "4D", and not "3D".  After all, the usual video is not called three-dimensional just because the flat picture changes with time.  Indeed, in serious works the term ‚Äúfree viewpoint video‚Äù is usually used.  But for the title it‚Äôs too boring, and I decided to leave click 4D (although 11D cinemas are still far away). <br><br><img src="https://habrastorage.org/web/474/be5/c08/474be5c0846f47e28218bfa8462185ff.jpg"><br></div></div><br><br>  Most of the audience is undoubtedly familiar with 3D sensors.  The most massive device in this category is the well-known Kinect, a very successful product from Microsoft.  However, despite the relative prevalence, for many people, depth-sensors remain something outlandish.  It will be useful for us to understand the principle of their work before starting to write applications. <br><br>  With Google Tango and other structured light devices, everything is relatively clear.  An infrared illuminator built into the device projects an irregular pattern of light points onto the scene, something like this picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/9e9/daa/a53/9e9daaa5327049d2ba1fb3ce8b9c3828.jpg" width="480"></div><br><br>  Then the special software turns the distortions of this pattern on the image from the IR camera (caused by the various shapes of objects) into a series of 3D measurements.  For each spot of light in the picture, the algorithm restores the spatial coordinates, and at the output we get a 3D cloud of points.  Inside, of course, everything is much more interesting, but this is a topic for a whole separate article. <br><br>  Well, you need to check how it works in practice!  For a couple of evenings, a simple <a href="">grabber application</a> for the Tango-tablet on Android was written on my knee, and here I have my very first dataset. <br><br><div style="text-align:center;"><img width="480" src="https://habrastorage.org/web/431/572/6d6/4315726d67f34a8d8f1ff1180bbc7e78.png"></div><br>  Although the first version of the grabber was very raw, the main thing was achieved: the coordinates of the points were recorded in a binary file.  The screenshot shows what a cloud of points looks like from one frame in the Meshlab program. <br><br>  Ok, point cloud is already interesting.  However, the point cloud is a very ‚Äúsparse‚Äù view of the scene, because the resolution of modern structured light sensors is rather low (usually around 100x100 pixels, plus or minus).  And in general, in the world of computer graphics, a different representation of 3D objects and scenes, namely polygonal grids, or meshes, is much more familiar. <br><br>  If you think about it, the task of getting a mesh through a cloud of points from a single 3D camera is quite simple, much simpler than arbitrary meshing in 3D.  For this, we do not need any <a href="https://en.wikipedia.org/wiki/Marching_cubes">marching cubes</a> or a <a href="http://www.cs.jhu.edu/~misha/Code/PoissonRecon/Version9.01/">reconstruction of Poisson</a> .  Recall that the points were obtained using a single IR camera and are naturally projected back onto the focal plane: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/0eb/1dd/e9e/0eb1dde9e6514aa4b01f52479ea0d101.gif"></div><br><br>  Now we can solve the problem in 2D, forgetting for a while about the Z-coordinate.  To get polygons you only need to triangulate a set of points on a plane.  Once this is done, we project the vertices back to 3D using the <a href="https://en.wikipedia.org/wiki/Pinhole_camera_model">internal parameters of the</a> IR camera and the known depth at each point.  Triangulation will dictate the connectivity between the vertices, i.e.  we interpret each triangle as a mesh face.  Thus, on each frame you get a real 3D model of the scene, which can be rendered in OpenGL, opened in Blender, etc. <br><br>  So, all that remains to be done is to find the triangulation for points on each frame.  There are lots of ways to triangulate a set of points in 2D, and in fact any triangulation will give us some kind of mesh.  But exactly one method is optimal for building a polygonal mesh - Delaunay triangulation. <br><br>  This interesting construction has been mentioned many times on Habr√©, but I‚Äôll still write a few words.  All of us have seen Voronoi diagrams.  The Voronoi diagram for a set of points S is such a partition of the plane into cells, where each cell contains all the points closest to one of the elements of S. <br><br><img width="260" src="https://habrastorage.org/web/8ba/e0d/937/8bae0d93754645d99869553c36214eaa.png"><img width="260" src="https://habrastorage.org/web/e06/b99/04b/e06b9904b00b4ac6967fc6626ae40d52.jpg"><br><img width="520" src="https://habrastorage.org/web/f0b/c0d/e72/f0bc0de72b724920b6ae8e4d1fea3836.jpg"><br><br>  And Delaunay triangulation is such a triangulation, which in the sense of graph theory is <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B9%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584">dual to</a> the Voronoi diagram: <br><br><div style="text-align:center;"><img width="260" src="https://habrastorage.org/web/ce4/7cd/e5b/ce47cde5b7ea45c69d62416da0d4d19c.png"></div><br><br>  Delone triangulations have many remarkable properties, but these two are especially interesting to us: <br><br><ol><li>  The circle described around any of the triangles does not contain points of the set, except for the vertices of the triangle itself. </li><li>  Delaunay triangulation maximizes the minimum angle among all the angles of all triangles, thereby avoiding degenerate and ‚Äúthin‚Äù triangles. </li></ol><br>  Property # 2 quite intuitively follows from # 1.  Indeed, in order for the circumscribed circles to contain extraneous points, they must be as small as possible, and the radius of the circle for ‚Äúthin‚Äù triangles (close to degenerate), on the contrary, is very large.  Thus, the Delaunay triangulation maximizes the number of ‚Äúgood‚Äù triangles far from degenerate.  And that means our mesh should look good. <br><br>  No sooner said than done, we write Delaunay triangulation.  There are many well-known algorithms, <a href="https://e-maxx.ru/algo/voronoi_diagram_2d_n4">the simplest ones</a> start somewhere with <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>n</mi><mn>4</mn></msup><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.032ex" height="2.901ex" viewBox="0 -935.7 2596.9 1249" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMAIN-28" x="763" y="0"></use><g transform="translate(1153,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMAIN-34" x="849" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMAIN-29" x="2207" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>4</mn></msup><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> O (n ^ 4) </script>  .  But once people have learned to count these triangulations as <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.309ex" height="2.66ex" viewBox="0 -832 4008 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6C" x="1753" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6F" x="2052" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-67" x="2537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6E" x="3018" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMAIN-29" x="3618" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-2"> O (nlogn) </script>  , we just can not be slower! <br><br>  As in many other similar problems, the algorithm is based on the principle of ‚Äúdivide and conquer‚Äù.  We will sort the points by x and y coordinates, and then recursively generate and merge triangulations until we have one large graph.  It is enough to show this piece of code so that it becomes clear what is happening here: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> numRight = numPoints / <span class="hljs-number"><span class="hljs-number">2</span></span>, numLeft = numPoints - numRight; EdgeIdx lle; <span class="hljs-comment"><span class="hljs-comment">// CCW convex hull edge starting at the leftmost vertex of left triangulation EdgeIdx lre; // CW convex hull edge starting at the rightmost vertex of left triangulation EdgeIdx rle; // CCW convex hull edge starting at the leftmost vertex of right triangulation EdgeIdx rre; // CW convex hull edge starting at the rightmost vertex of right triangulation triangulateSubset(lIdx + numLeft, numRight, rle, rre); triangulateSubset(lIdx, numLeft, lle, lre); mergeTriangulations(lle, lre, rle, rre, le, re);</span></span></code> </pre> <br>  In principle, everything can disperse. <br><br>  Not really, because the fun begins in the mergeTriangulations function.  Indeed, if we have divided our set in half a sufficient number of times, we are left with pieces of two or three points, with which we will somehow sort things out: <br><br><div style="text-align:center;"><img width="240" src="https://habrastorage.org/web/fd3/4c1/8a8/fd34c18a8e874103a40c365ddaec4fb7.gif"></div><br><br>  And then what? <br><br><div class="spoiler">  <b class="spoiler_title">About illustrations</b> <div class="spoiler_text">  Hereinafter I will accompany the description with GIF-animations that were generated by my program, as well as with illustrations from one good article.  When describing the algorithm, I will largely repeat this <a href="http://www.geom.uiuc.edu/~samuelp/del_project.html">article</a> , so if you have any questions, you can safely consult with it. <br></div></div><br>  In fact, too, nothing complicated.  In each sheet of recursion we have already received a valid solution of the subtask.  It remains to go up the stack, merging the left and right partitions into a single unit along the way.  But this should be done carefully, because  far from each method of merging will give us Delone triangulation at the output. <br><br>  The algorithm of Gibas and Stolfi offers a very elegant solution to this problem.  The idea is to use property # 1, which I mentioned above, but in order. <br>  First, some notation;  let's call the left triangulation L, and the right R. Then the edges belonging to the left triangulation will be called LL, since  they begin and end at points of the left subset.  The edges of the right triangulation are called RR, and the edges that we add between the left and right half are called LR, just like in the illustration: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/1a6/1b8/63c/1a61b863c8b3443a8b90b7531af1ccf3.gif"></div><br><br>  As you can see, here we have already ‚Äústarted‚Äù starting triangles and edges in triangulation from as many as four triangles.  All edges that were present in the previous step are marked as LL or RR, and all new edges are marked LR.  The merging process at this step is not shown, since it is rather trivial and will not allow to show the features of the algorithm.  But the next step will be more interesting, let's consider it.  Here is our task before the start of the merger: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/d18/cac/1fd/d18cac1fda3c47a48e43dfbde71fd77b.gif"></div><br><br>  Note that the ‚Äúouter‚Äù edges in the left and right half (such as 1-2, 2-5, 5-4, 6-8) form the convex hulls of their subset of points.  It is clear that such edges always belong to the Delaunay triangulation, and indeed any triangulation.  Note also that when merging two non-intersecting partitions, we will always need to add exactly two new edges in order to complete the convex hull of the unified set (roughly speaking, to ‚Äúcover‚Äù the points with new edges from above and below).  Great, we already have two new LR-edges!  Choose one of them, the bottom one, and call it ‚Äúbase‚Äù (in the code - base). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/9f5/ec4/e19/9f5ec4e19ac842928c7c512c0a8864c0.gif"></div><br><br>  Now we have to add the next edge adjacent to base, with one of its ends coinciding with the end of base, and the other end is a point from either L or R. Actually, we need to decide which of the two options is correct.  Let's start on the right side.  The first candidate will be a point associated with the right end of the base RR-edge with the smallest angle clockwise relative to the base.  The next candidates in turn will be the points R connected to the right vertex of the base RR-edges with an increasing angle value relative to the base, as shown in the illustration: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/8ae/9f7/71d/8ae9f771d94746b99bbe327b8adcb7d4.gif"></div><br><br>  Now for each candidate you need to check two conditions: <br><br><ol><li>  The angle between the base and the candidate should not exceed 180 degrees (we are only interested in points that are ‚Äúhigher‚Äù than the base). </li><li>  The circle described around the base and the candidate point must not contain the next candidate point. </li></ol><br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/379/d5e/1a7/379d5e1a72174becb64f991f0b3455fc.gif"></div><br><br>  Depending on the configuration of the vertices, there may be several options: <br><br><ul><li>  There was a candidate point that satisfies both criteria.  Great, this will be our choice for the right side. </li><li>  If requirement # 1 is not fulfilled (angle &lt;180 degrees), then we have already reached the ‚Äútop‚Äù, and there is no longer a need to choose points from the right side.  We consider only the left triangulation. </li><li>  The most interesting case is the condition # 1, but not # 2 (see illustration).  In this case, we need to remove the RR-edge that connects the base with the candidate point and repeat the search again. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/web/d68/1b4/00b/d681b400b40f49abb86f51e474df8589.gif"></div><br><br>  Naturally, the process for the left half is completely symmetrical. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/7b2/e18/fc4/7b2e18fc49164a6689e6b8cc3729e6b6.gif"></div><br><br>  Thus, with each addition of a new LR edge, we select a candidate point from the left and right half.  If neither there nor there was a suitable point, then we have completed the merger and need to go further up the stack.  If there is one point (only on the left or just on the right), we add an LR-edge with an end in it.  If points were found on both sides, we repeat the test with a circle: we build the circumscribed circle around the base and the candidate points from L and R. We select the point whose circumference does not contain the candidate from the opposite half.  Fact: such a point will always be unique, unless the four vertices form a rectangle.  In this case, you can choose any of the options. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/232/c88/5ec/232c885ec6384eb7a3e8422e4139ab7e.gif"></div><br><br>  In this example, we select a candidate from L, because the corresponding circle does not contain a candidate point from R. <br><br>  After a new LR edge is added, it becomes a new ‚Äúbase‚Äù (base).  Repeat base update until we reach the top edge of the convex hull: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/ad8/0b5/218/ad80b521856f48fa9a87b46fc6a15a71.gif"></div><br>  It turns out that if our algorithm accurately follows the described rules, then after merging the left and right half we get a valid Delaunay triangulation for L‚à™R. <br><br>  "I found this truly miraculous proof, but the fields of this book are too narrow for him."  In fact, if you're wondering where all the statements <a href="http://www.sccg.sk/~samuelcik/dgs/quad_edge.pdf">came</a> from, for example about the need to remove edges, I recommend exploring the <a href="http://www.sccg.sk/~samuelcik/dgs/quad_edge.pdf">work of Gibas and Stolfi</a> , key lemmas numbered 9.2, 9.3, 9.4, 8.3. <br><br>  Well, now let's put everything together and see what happens: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/b4b/621/55a/b4b62155a8834025859113e5181236af.gif"></div><br><br>  This is a visualization of the work of the algorithm, which I got.  Here, the base edge is marked orange, the LL candidate is green, the RR candidate is blue.  Red marked edges that do not meet criterion # 2 and will be deleted. <br><br>  While the description of the algorithm is still fresh in memory, it is very easy to understand that it is really executed in <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.309ex" height="2.66ex" viewBox="0 -832 4008 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6C" x="1753" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6F" x="2052" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-67" x="2537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6E" x="3018" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMAIN-29" x="3618" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-3"> O (nlogn) </script>  .  Indeed, we have order <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.332ex" height="2.419ex" viewBox="0 -780.1 1865 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6F" x="298" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-67" x="784" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6E" x="1264" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-4"> logn </script>  merge operations;  even if on each of them we are forced to remove and rebuild all edges in general, the number of actions will still be of the order <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6E" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-5"> n </script>  (since it is a triangulation, and not an arbitrary graph, the number of edges is linear with respect to the number of points).  In fact, on most real-world tasks, speed is better than <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.309ex" height="2.66ex" viewBox="0 -832 4008 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6C" x="1753" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6F" x="2052" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-67" x="2537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMATHI-6E" x="3018" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/333532/&amp;xid=17259,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXMJlN2mdqmyIdw3QIfRz924dhBQ#MJMAIN-29" x="3618" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-6"> O (nlogn) </script>  and close to linear;  we need some especially patient dataset to force the algorithm to rebuild triangulation from scratch at each merging stage. <br><br>  Another remark is that it is easy to obtain from the obtained triangulation both the convex hull and the Voronoi diagram for the corresponding set of points.  Pleasant bonus. <br><br>  It is interesting to say a few words about the data structure that I used to work with the graph.  Usually, graphs are represented as lists or adjacency matrices, but in this problem we are interested not only in connectivity, but also in some geometric properties of the graph.  Here's what I got: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TriEdge</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> origPnt; <span class="hljs-comment"><span class="hljs-comment">// index of edge's origin point EdgeIdx symEdge; // index of pair edge, with same endpoints and opposite direction EdgeIdx nextCcwEdge; // next counterclockwise (CCW) edge around the origin EdgeIdx prevCcwEdge; // previous CCW edge around the origin (or next CW edge) };</span></span></code> </pre> <br>  This is in some way a trimmed version of the structure that Gibas and Stolfi offer.  As they say, all ingenious is simple.  For each edge we store the point from which it ‚Äúgoes out‚Äù (origin), the index of its pair edge directed in the opposite direction, as well as the indices of the next and previous edge ‚Äúaround‚Äù the origin point.  In fact, we get a doubly linked list, but since we maintain the relative position of the edges around their ends, many steps of the algorithm are simply encoded elementarily. <br><br>  In <a href="https://www.cs.cmu.edu/~quake/triangle.html">some other works it is</a> proposed to store not the edges, but triangles at once.  I tried to experiment with this option, and I can say that the amount of code grows many times, because  it is necessary to introduce numerous crutches for special cases (degenerate triangles, points at infinity, etc.).  And although this option has a potential advantage in terms of memory usage, I strongly recommend using double-linked edge lists.  Working with them at times is more pleasant. <br><br>  I think from now on you can stop pretending that someone is interested in the details of the implementation of the algorithm.  You can just relax and pozalipat these wonderful animations. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/613/64a/b08/61364ab087054dae8c826c233a53ac16.gif"></div><br><br>  How about a regular grid? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/e52/91c/72f/e5291c72fb3c477da9f268b9a63452f3.gif"></div><br><br>  Here the points were successfully divided into subsets and did not have to remove any edges at all.  But this is not always the case. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/b83/a96/f64/b83a96f643824c8aa4fe61f21a9ae3e2.gif"></div><br><br>  Already more interesting.  The number of points on the lattice side became odd and because of this, the algorithm is forced to make quite a few corrections.  How about a circle of dots? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/817/3e1/fe3/8173e1fe350243c8b80f9003b26e4818.gif"></div><br><br>  Interesting!  But I like it better with a dot in the center: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/934/43a/711/93443a7116b84070a14eaa70a5007311.gif"></div><br><br>  I think by this point the article contains a sufficient number of GIF-animations.  In order for readers with <a href="https://geektimes.ru/post/290377/">traffic restrictions to</a> have at least a little bit of Internet after downloading this article, I uploaded the rest of the animations to video hosting. <br><br>  <strong>It is recommended to stick in 1080p and 60fps, this is the original video resolution.</strong>  <strong>And it is better to expand to the full screen, otherwise the edges of the graph are alias.</strong> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/G3US_HTZ1-o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  I realize that these videos are far from being interesting to everyone, but they have the same effect on me as the ‚Äúpipeline‚Äù screensaver in older versions of Windows.  Hard to break away. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6WLeexsfNCg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  These animations were the main reason why the article was written for so long.  Note to self: next time it‚Äôs dangerous to do debugger and traces, it‚Äôs dangerous to do debug visualizations :) If someone wants to look at the work of the algorithm on other configurations of points, write in the comments, I‚Äôll be happy to generate more animations. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xIRqUAZsOdg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Having fun with visualization was fun, but it's time to remember why the algorithm was originally created.  We were going to generate a polygon mesh from the data from the depth-sensor.  Well, let's take a cloud of points from the sensor, project it onto the camera plane and launch the triangulation algorithm. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-qH7y5U7ycE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>  (Do not ask me how much this video was rendered. Poor ffmpeg.) <br><br>  So, great!  Although at this stage we only have a graph of points and edges, we can generate an array of triangles from it in an elementary way.  It remains only to filter ugly polygons stretched along the Z-coordinate, which appear on the borders of the objects and make a simple OpenGL player: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bf1bJuOdQ6k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Here you can clearly see that the first version of the grabber was very raw: half the frames did not have time to register, because of this, the picture freezes.  In short, hardly a directing masterpiece.  But it does not matter - the algorithms are finally alive!  For me, it was a real ‚Äútrain arrival‚Äù! <br><br>  After that, I shot a couple more clips, I uploaded them to the Sketchfab resource in the timeframe animation format, it seems to me more interesting. <br><br>  <a href="https://skfb.ly/6soGq">Dataset # 2 in WebGL</a> <br>  <a href="https://skfb.ly/6soGr">Dataset # 3 in WebGL</a> <br><br>  Well, the pipeline has earned and it has become clear that further development limits the possibilities of iron.  Indeed, the Tango tablet allows you to shoot only at a very low frame rate (5 fps), but the main idea was to capture the dynamic nature of the scenes.  There is another significant limitation: in Tango, RGB and IR cameras are not synchronized, that is, frames are received at different points in time.  This is not critical for, say, scanning static objects, since  Tango SDK allows you to find the conversion between the RGB and IR positions for adjacent frames using the built-in tracking based on the high-frequency accelerometer and fisheye camera.  But with moving objects, this does not help at all, and for me the lack of synchronization meant that the mesh would not be able to pull the texture. <br><br>  Fortunately, I had another device - <a href="">Intel RealSense R200</a> .  Miraculously, the R200 does not have both disadvantages, since  It develops up to 60 (!) fps and has excellent synchronization of all its cameras.  So I decided to write a grabber application for the R200 (this time in <a href="">C ++</a> , not Java) and continue the experiments. <br><br>  Immediately it became clear that there was a small problem with my pipeline.  With the increased resolution and high shooting frequency that the R200 allows, there was already not enough performance to generate a mesh on every frame in realtime.  Profiling showed that the bottleneck is of course triangulation.  The original version was written quite ‚Äúrelaxedly‚Äù, with dynamic memory allocation, using STL, etc.  In addition, the first version worked with coordinates of type float, although in my task the points always have integer coordinates (positions in pixels in the picture).  So it is not surprising that, from the asymptotic point of view, a good algorithm worked on my laptop for up to 30 milliseconds on a test frame from Tango (about 12,000 points).  The potential for acceleration was obvious and I enthusiastically sat down to optimize.  Events developed something like this: <br><br><ul><li>  First of all, floating-point numbers set off for the altar of speed.  All algorithms (where possible) switched to integer calculations. </li><li>  The second in line was the dynamic allocation of memory.  Now all the memory for the algorithm was allocated once, ‚Äúfor the worst case,‚Äù and then reused.  Not the most effective solution in terms of memory consumption (in the spirit of ACM ICPC), but this gave a significant acceleration. </li><li>  A remarkable <a href="https://www.cs.cmu.edu/~quake/robust.html">test</a> was found on the project site for a numerical simulation of earthquakes to find a point inside the circumscribed circle of a triangle: <br><br>  Here is its implementation: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FORCE_INLINE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inCircle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> px, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> py)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// reduce the computational complexity by substracting the last row of the matrix // ref: https://www.cs.cmu.edu/~quake/robust.html const int p1p_x = x1 - px; const int p1p_y = y1 - py; const int p2p_x = x2 - px; const int p2p_y = y2 - py; const int p3p_x = x3 - px; const int p3p_y = y3 - py; const int64_t p1p = p1p_x * p1p_x + p1p_y * p1p_y; const int64_t p2p = p2p_x * p2p_x + p2p_y * p2p_y; const int64_t p3p = p3p_x * p3p_x + p3p_y * p3p_y; // determinant of matrix, see paper for the reference const int64_t res = p1p_x * (p2p_y * p3p - p2p * p3p_y) - p1p_y * (p2p_x * p3p - p2p * p3p_x) + p1p * (p2p_x * p3p_y - p2p_y * p3p_x); assert(std::abs(res) &lt; std::numeric_limits&lt;int64&gt;::max() / 100); return res &lt; 0; }</span></span></code> </pre> </li></ul><br>  These three events gave a very significant acceleration, from 30000+ to 6100 microseconds per frame.  But it was possible to accelerate more: <br><br><ul><li>  Made some small functions __forceinline, 6100 -&gt; 5700 microseconds, a rare case when the compiler did not guess. </li><li>  Removed #pragma pack (push, 1) for TriEdge structure.  And why did I decide that packing will be faster?  5700 -&gt; 4800 microseconds. </li><li>  Replaced std :: sort for points with self-written sorting, similar to radix.  4800-&gt; 3700 microseconds. </li></ul><br>  Total it turned out to speed up the code almost 10 times, and I think this is not the limit.  By the way, I was not too lazy to collect code for Android, and on a similar ARM task, the Tango processor worked for about 10 milliseconds per frame, i.e.  100 fps!  In short, it turned out even a little overkill, but if someone needs a very fast ‚Äúintegral‚Äù Delone triangulation, then welcome to the repository. <br><br>  Now my algorithms were ready for the R200, and here is the first dataset I took: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7gJUIYt-Lew" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  It was naturally followed by others.  I will not attach the video of my OpenGL viewer, I think it's more interesting to look directly at Sketchfab: <a href="https://skfb.ly/6s6Ar">skfb.ly/6s6Ar</a> <br><br>  It is recommended to open no more than one clip at a time, since  Sketchfab loads all dataset frames into memory at once, and in general the viewer is not very fast.  By the way, here is the promised 4D cat (Vasya): <br><br><ul><li>  <a href="https://skfb.ly/6s6AC">skfb.ly/6s6AC</a> </li><li>  <a href="https://skfb.ly/6s6AJ">skfb.ly/6s6AJ</a> </li></ul><br>  Dog Totoshka was not very happy that they shine a laser at him.  But he had no choice: <br><br><ul><li>  <a href="https://skfb.ly/6s6AP">skfb.ly/6s6AP</a> </li><li>  <a href="https://skfb.ly/6s6BH">skfb.ly/6s6BH</a> </li></ul><br>  There are a few more clips in my account on Sketchfab.  Of course, the quality of the models can be improved if you carefully filter the noise from the sensor, you can reduce the number of points, so that the player on the site does not brake so much, etc.  But as they say, there is no limit to perfection;  I already spent a lot of time on this pet project. <br><br>  And in general, given the aggressive offensive of AR and VR, I am sure that the developers will not devour attention to these tasks.  More volumetric content like CG is found on the web: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/915/9e6/a7f/9159e6a7f5044cdcb3718c411583f0ed.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/web/d76/914/cd0/d76914cd0c024cc98cb01a1166388ac5.gif"></div><br>  and shot in real life: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SH3MKjwgI80" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Agree, it looks very impressive!  In general, there is no need to worry about the future of free-viewpoint video. <br><br>  Finally, all the code written for this project is available on <a href="https://github.com/alex-petrenko/4dvideo">Github</a> under a free license.  Although the generated 4D videos were hardly impressive, the algorithms still have the potential for further use and development. <br>  The main advantage of the approach described in the article is that the 3D scene is generated on the fly in realtime, in the player itself.  Because of this, in compressed form, videos can take up very little space, in fact almost as much as a similar traditional video. <br><br>  Indeed, the usual RGB video we need only for textures, and the 3D coordinates of the points can be saved as sparse depth maps and also encoded into a video file, already in grayscale.  Thus, for rendering one frame in 3D, we need only frames from two videos and some metadata (camera parameters, etc.).  Based on this, you can make a cool application, say, Skype in augmented reality.  The interlocutor removes the depth-camera, and your iPhone renders the talking 3D head in real time using ARKit.  Almost like holograms from Star Wars. <br><br>  There is another option that can be useful to users of Tango.  The fact is that Tango SDK provides data in the form of point clouds in 3D (as I described above), while for many algorithms you want to have a dense depth map (depth map).  The most common way to obtain it is to project points onto the focal plane and interpolate the depth values ‚Äã‚Äãbetween adjacent points where it is known.  So the combination of Delaunay + OpenGL triangulation allows you to do this interpolation accurately and efficiently.  Due to the fact that rasterization occurs on the GPU, you can generate depth maps in high resolution, even on a smartphone. <br><br>  But this is all the lyrics.  So far, I'm just very glad that I finished the article.  If you have any thoughts or feedback, I suggest to discuss in the comments. <br><br><h4>  Image credits </h4><br><ul><li>  <a href="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi diagram</a> </li><li>  <a href="http://www.flong.com/projects/zoo/">Voronoi faces</a> </li><li>  <a href="https://ru.pinterest.com/pin/364862007282864701/">Voronoi giraffe</a> </li><li>  <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">Voronoi-Delaunay duality</a> </li><li>  <a href="http://www.geom.uiuc.edu/~samuelp/del_project.html">Algorithm</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/333532/">https://habr.com/ru/post/333532/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333522/index.html">Yandex opens CatBoost machine learning technology</a></li>
<li><a href="../333524/index.html">Skyeng API contest - first participants</a></li>
<li><a href="../333526/index.html">SDN with Red Hat OpenStack Platform: OpenDaylight Integration</a></li>
<li><a href="../333528/index.html">How thousands of Eve Online players help decipher the human body</a></li>
<li><a href="../333530/index.html">Cross-platform IoT: Using the Azure CLI and Azure IoT Hub</a></li>
<li><a href="../333540/index.html">E-democracy or how to collect and process data on voting (and turnout) for renovation in Moscow</a></li>
<li><a href="../333544/index.html">How To Make Progressive Web Apps: A Beginner's Guide</a></li>
<li><a href="../333546/index.html">Translation of the Appium Essentials book. Chapter 6</a></li>
<li><a href="../333548/index.html">Testing the Mobile Delphi Application Database</a></li>
<li><a href="../333552/index.html">You don't know a damn thing in colors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>