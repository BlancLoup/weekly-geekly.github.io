<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Digital filtering on FPGA - Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 This is the second publication on the topic ‚ÄúDigital filtering on FPGA‚Äù. The second part will be devoted to the practical implementation of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Digital filtering on FPGA - Part 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/28e/7a5/657/28e7a5657c9542279502ca05ad355d71.png"><br><br>  Hello! <br><br>  This is the second publication on the topic ‚ÄúDigital filtering on FPGA‚Äù.  The second part will be devoted to the practical implementation of FIR filters on FPGAs.  In the process of preparing the material, I realized that it would swell to unprecedented sizes, but I did not want to divide it into several parts.  Therefore, all the subtleties of the theory and synthesis of FIR filters will be in one article, divided into interrelated sections.  I will begin the review with the theoretical part, in particular, I will tell you about the features and methods of calculating the filter coefficients.  Consider in detail the creation of FIR filters in various environments - MATLAB, CoreGENERATOR, Vivado HLS.  All interested in asking under the cat. <br><a name="habracut"></a><br><h4>  Part 2. FIR filter </h4><br><h4>  <b>Theory</b> </h4><br>  Consider a simple example of implementing FIR filters.  As is known, there are two large classes of filters - IIR, with <b>infinite impulse response</b> and FIR, with <b>finite impulse response</b> .  Let us dwell on the second type: FIR filters (FIR - ‚Äúfinite impulse response‚Äù).  An FIR filter is a linear digital filter whose main feature is its time-limited impulse response, that is, from a certain point in time it becomes zero.  As a rule, most FIR filters are executed without feedback, therefore almost all FIR filters are non-recursive. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is how the implementation of the FIR filter looks in general, in particular - on the FPGA. <br><img src="https://habrastorage.org/files/2b0/73c/87c/2b073c87ca7048eaa7fb5da1599305aa.png"><br><br>  All FIR filters are described by the following equations: <br><img src="https://habrastorage.org/files/168/2af/555/1682af555b834034bc0bb03611a7ab68.png"><br>  where <b>y (n)</b> is the output signal (function of the current and past values ‚Äã‚Äãat the input), <b>x (n)</b> is the input action, <b>h (k)</b> is the impulse response coefficients, <b>N</b> is the filter length (the number of filter coefficients), <b>H (z)</b> is filter transfer characteristic. <br><br>  <i>What is the secret of FIR filters?</i> <br>  The most important feature of FIR filters is the ability to obtain accurate <u>linear phase response</u> .  The reader has a logical question - ‚Äúwhy is this necessary?‚Äù.  Let us dwell on this moment in more detail.  The signal undergoes various transformations as it passes through the filter.  In particular, the amplitude and phase of the signal vary depending on the frequency response of the filter (amplitude, frequency response and phase, phase response).  For multi-frequency signals, it is unacceptable that during the passage of processing units, the phase of the signal is distorted.  Moreover, if the frequency response in the passband is practically constant, then there are problems with the phase response.  To estimate phase distortions, it is convenient to introduce the concepts of phase and group delays. <br>  The phase delay is the amount of delay for each of the frequency components of the signal.  Defined as the phase angle divided by the frequency.  Group delay is the average time delay of the entire multi-frequency signal.  It is defined as the phase derivative with respect to frequency.  Mathematically, phase and group delays are written as follows: <br><img src="https://habrastorage.org/files/6a2/c31/4e0/6a2c314e039c49c2ad88f03a71e2b4b3.png"><br>  From the formula for group delay, the linearity condition of the phase response filter becomes obvious.  If the phase response is linear, then the group delay after taking the derivative is equal to a constant, that is, constant for all frequency components.  It is logical that the filter with nonlinear frequency response will introduce distortion in the phase of the signal. <br>  Thus, the linearity of the phase response is one of the most important features of FIR filters.  Let us dwell on the study of this class of filters. <br><br><h4>  <b>FIR filters with linear phase response</b> </h4><br>  To ensure the linearity of the phase response, the <b>symmetry condition of the</b> impulse response (or coefficients) of the filter must be met.  Simply put, the FIR filter with linear phase response is symmetric.  There are 4 types of filters that differ in the parity of the order of the filter N and the type of symmetry (positive or negative).  For example, for filters with negative symmetry, a phase shift of 90 <sup>¬∞</sup> can be obtained.  Such filters are used to design differentiators and the Hilbert transform.  The impulse response curve of the FIR filter is constructed according to the <b>~ sin (x) / x</b> law, regardless of the type of filter (low pass filter, high pass filter, PF, RF, differentiator).  To solve practical problems, it is often not necessary to think about what type of filter is chosen.  I will not give the proof of the condition of symmetry of the coefficients, but a curious reader can find it himself in various literature, the links to which I cite at the end of the article. <br><br><h4>  <b>Designing FIR filters</b> </h4><br>  The ‚Äúcalculation of the FIR filter‚Äù in most cases means the search for its <u>coefficients</u> by the values ‚Äã‚Äãof the frequency response.  I can not recall cases when the inverse problem would be solved with the exception of academic interest. <br><br>  When creating a new digital FIR filter, any engineer goes through certain stages of development *: <br><ul><li>  <b>Filter specification</b>  Sets the filter type (low pass filter, high pass filter, band pass, notch), the number of N coefficients, the required frequency response, with tolerances for nonlinearity in the attenuation band and the passband, and so on. </li><li>  <b>The calculation of the coefficients</b> .  By any available means and methods, filter coefficients are computed that satisfy the specifications from the previous paragraph. </li><li>  <b>Analysis of the consequences of a finite bit depth</b> .  At this stage, the effect of quantization effects on the filter coefficients, intermediate and output data is evaluated. </li><li>  <b>Implementation</b> .  At this stage, a filter is developed in an accessible programming language or the filter is implemented by creating ready-made IP cores. </li></ul><br>  * - development stages may be somewhat different, but the essence is always the same. <br><br>  <b>Filter specification</b> <br><br>  At this stage, the engineer searches for compromise solutions for implementing the required filter with the necessary parameters.  There are not many of them, but one often has to sacrifice one parameter in order to achieve the required values ‚Äã‚Äãin other quantities. <br><ul><li>  <b>Apass</b> - bandwidth irregularity, </li><li>  <b>Astop</b> - attenuation level in the suppression band, </li><li>  <b>Fpass</b> - bandwidth <b>cutoff</b> frequency </li><li>  <b>Fstop</b> - the limiting frequency of the attenuation band, </li><li>  <b>N</b> is the order of the filter (the number of filter coefficients). </li></ul><br>  In practice, the Apass and Astop parameters are set in decibels (dB), and the distance between Fpass and Fstop expresses the width of the filter transition band.  It is logical that the value of Apass should be as low as possible, Apass as much as possible, and the ratio Fpass / Fstop ideally tends to one (perfectly rectangular frequency response).  The number of coefficients is not in vain entered into the filter specification.  As will be shown later, the parameters of the frequency response of the filter, as well as the amount of FPGA resources, depend on the order of the filter N and the width of the coefficients. <br><br>  <b>Calculation of filter coefficients</b> <br><br>  You can write several books and scientific articles on this topic, but in this article we will not consider in detail all the methods.  There are many methods for calculating filter coefficients - the method of weighting by window functions, the method of frequency sampling, various optimal (according to Chebyshev) methods using the Remez algorithm, etc.  All methods are unique in their characteristics and give some results.  For the windowing method, the <b>Gibbs effect</b> , which introduces non-uniformity and outliers into the frequency response of the filter between the calculated points of the function, becomes a negative manifestation.  You can fight it endlessly, but in practice they introduce tolerances for irregularities in the passband and suppression band. <br><br>  The main method for calculating coefficients for many filters is the modified Remez algorithm, the <b><a href="https://en.wikipedia.org/wiki/Parks%25E2%2580%2594McClellan_filter_design_algorithm">Parks-McClellan algorithm</a></b> .  At its core, it is an indirect iterative method for finding optimal values ‚Äã‚Äãwith a Chebyshev filter characteristic.  A feature of the method is to minimize errors in the attenuation and transmission band by the Chebyshev approximation of the impulse response.  It is logical that the greater the number of coefficients, the smaller the non-uniformity of the frequency response and the more rectangular it is. <br>  The final result depends on the choice of method, but they all boil down to the same goals - minimizing emissions in the passband and increasing the ‚Äúsquareness‚Äù of the frequency response. <br><br>  <b>Final Impact Analysis</b> <br><br>  <i>The width of the coefficients</i> - the main factor on which depends the type of frequency response.  In modern FPGAs, the width of the coefficients can be chosen any, but reasonable numbers lie in the range from 16 to 27 bits.  For high filter orders, it is often required to provide a large dynamic range of the discharge grid, but if this cannot be done, sooner or later quantization errors begin to appear.  Because of the limited bitness of the coefficients, the frequency response is modified, and in some cases it is distorted so much that you have to sacrifice the parameters from the frequency specification to achieve an acceptable result.  Anyway, the bitness of the representation of the coefficients directly affects the maximum possible attenuation of Astop.  Therefore, when using a too limited bit grid of coefficients, it is sometimes impossible to achieve the desired suppression even with huge filter orders! <br><br>  The bit length of the intermediate data and the arithmetic overflow are factors that also determine the type of frequency response and the result at the filter output.  In many FPGAs, the problem is eliminated using high-capacity batteries in DSP units.  For example, in the FPGA Xilinx 6 and 7 series in the cells of DSP48E1 48-bit batteries and multipliers are used.  The following figure shows the standard DSP48E1 unit on which FIR filters are implemented. <br><img src="https://habrastorage.org/files/21d/dfb/dbf/21ddfbdbf45d4174b819304b0141f5a9.png"><br>  The built-in DSP blocks of modern FPGAs are designed in such a way as to most conveniently carry out DSP tasks.  First of all - to implement FIR filters. <br><br>  <b>Implementation</b> <br><br>  To implement the simplest filters, very few logical operations are required.  The main node with which the FIR filter is implemented is the FPGA DSP block.  All mathematical operations occur in this block - multiplication of input samples with filter coefficients, input signal delay, data summation.  Modern DSP nodes contain a preliminary adder, so even the summation operations for filters with a symmetrical EI can be done inside this node.  In addition to the DSP block, the filter needs memory to store the coefficients (distributed or block).  More filter does not use anything.  The figure shows the implementation of an FIR filter using multipliers, batteries, delay lines, and memory for storing coefficients. <br><br><img src="https://habrastorage.org/files/4db/040/093/4db0400938484825b74d0535e8118249.png"><br><br><h4>  <b>Calculation of the filter in MATLAB</b> </h4><br>  There are many applications in which you can calculate the filter and search for its coefficients.  For example, LABView, Scope FIR, FDATool from MATLAB or the free analogue of Octave.  Perhaps the most convenient means of calculating the FIR filter is MATLAB.  To run the filter creation and analysis tool, you need to type the keyword <b>fdatool</b> in the environment command window.  A window like this will appear (depending on the version of MATLAB, it may have a slightly different look): <br><img src="https://habrastorage.org/files/ffb/12f/ce6/ffb12fce61954e0eb02a4dae2b46f505.png"><br><br>  The main parameters are set in the <b>Filter Specifications</b> window.  Depending on the filter settings, certain parameters may appear in the main window area. <br><ul><li>  <b>Filter Order</b> - determines the filter order (minimum or user-defined) **. </li><li>  <b>Frequency Specifications</b> - defines the frequency parameters of the filter characteristics. </li><li>  <b>Magnitude Specifications</b> - defines the amplitude parameters of the filter characteristics. </li><li>  <b>Density Factor</b> - for Equiripple type, sets the grid of points by which the frequency response of the filter is approximated. </li></ul><br>  ** - in FDATool, the order of the filter N is one more than the specified one (if you set N = 7, then the utility calculates 8 coefficients) !!! <br><br>  <b>Response type</b> - the type of the transfer characteristic of the filter.  In this field, select any filter that exists in nature, for example: <br><ul><li>  <b>Lowpass</b> - low pass filter, </li><li>  <b>Raised cosine</b> - raised cosine filter, </li><li>  <b>Highpass</b> - high pass filter, </li><li>  <b>Bandpass</b> - bandpass filter </li><li>  <b>Bandstop</b> - notch (blocking) filter, </li><li>  <b>Differentiator</b> - differentiator, </li><li>  <b>Nyquist</b> - <b>Nyquist</b> filter, </li><li>  <b>Multiband</b> - multiband filter, </li><li>  <b>Hilbert transformer</b> - Hilbert's converter, </li><li>  <b>Arbitrary magnitude</b> - filters with arbitrary frequency response. </li></ul>  etc. <br><br>  Moreover, depending on the type of filter, the analysis tool will indicate restrictions on the type of filter and will offer to enter the correct value of N. <br><br>  <b>Design Method</b> ‚Äî selects the filter design method and its type (IIR or FIR).  Available options for IIR filters: <br><ul><li>  <b>Butterworth</b> - filters with Butterworth characteristic, </li><li>  <b>Chebyshev Type I, II</b> - Chebyshev filters, </li><li>  <b>Elliptic</b> - elliptic filter, </li><li>  <b>Maximally flat</b> - a filter with the most flat response in the passband, </li></ul>  etc. <br><br>  For FIR filters are available options ***: <br><ul><li>  <b>Equiripple</b> - a filter with a uniformly pulsating frequency response, </li><li>  <b>Least-squares</b> - least squares filter, </li><li>  <b>Window</b> - window-weighted filter with various functions ****, </li><li>  <b>Complex Equiripple</b> - complex filter with uniformly pulsating frequency response, </li><li>  <b>Maximally flat</b> - a filter with the most flat response in the passband, </li></ul>  etc. <br><br>  *** - <b>Equiripple</b> and <b>Window</b> filters are of the greatest practical interest. <br>  **** - when this option is selected, an access panel to window functions and their parameters appears. <br><br>  For the Equiripple method, the simplest calculation of an FIR filter is performed using a modified Remez algorithm.  The user sets the parameters from the specification for the filter and immediately sees the result.  In the case of unsatisfactory results, you can change one or several filter parameters at any time and get another frequency response.  The calculation is carried out until the required characteristics are obtained.  If it was not possible to achieve the values ‚Äã‚Äãfor the task, then sooner or later it will be necessary to sacrifice one or another value from the specification, or significantly increase the order of the filter N. <br><br>  Several window functions are available for the Window method: <b>Bartlett, Blackman, Blackman-Harris, Chebyshev, Flat Top, Gaussian, Hamming, Hann, Kaiser, Rectangular</b> , etc., up to user-defined window functions (User-defined).  All these functions have their own characteristics and can give different parameters of the frequency response of the FIR filter.  Some window functions are calculated without parameters, and some filters are set through certain parameters affecting the frequency response of the filter. <br>  Of all the window functions presented, in my opinion, the <b>Kaiser</b> window is the most convenient.  To build the frequency response, you only need to set one Beta parameter, which affects the level of suppression in the attenuation band and the squareness of the frequency response. <br><br>  At the bottom left of the main working area, the FDATool tool contains additional tabs in which you can specify the filter type (decimator or interpolator), the name of the model to insert into Simulink, the type and length of the coefficients and input data, and much more.  For practical purposes, the most basic tabs are <b>Design Filter</b> ‚Äî it calculates the filter, and <b>Quantinization Parameters</b> ‚Äî in this tab, you can specify the type and bitness of the data. <br>  On the top panel there are buttons with which you can view the frequency response and phase response of the filter, group and phase delay, pulse and transient characteristics, a map of filter zeros and poles, calculated coefficients, etc. <br><br><div class="spoiler">  <b class="spoiler_title">Screenshots of the FDATool workspace</b> <div class="spoiler_text">  Graph of frequency response and phase response of the filter: <br><img src="https://habrastorage.org/files/777/34e/041/77734e041c904b8a81df6a8057a50f48.png"><br><br>  Graph of the impulse response of the filter: <br><img src="https://habrastorage.org/files/b72/88a/99e/b7288a99ebb04f32876eb8529a4442e1.png"><br><br>  Chart of zeros and poles: <br><img src="https://habrastorage.org/files/2a5/da6/d5d/2a5da6d5d9214ad9a4bc6b2f48f1ddef.png"><br></div></div><br>  In addition to all this, FDATool allows you to import and export filter models and calculated coefficients.  For example, you can calculate a filter and send its model to Simulink as a model on standard primitives.  You can calculate the coefficients and save them in a separate file, for example, as a file with the extension * .h (header). <br><br><div class="spoiler">  <b class="spoiler_title">Header file * .h with filter coefficients</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Discrete-Time FIR Filter (real) * ------------------------------- * Filter Structure : Direct-Form FIR * Filter Length : 128 * Stable : Yes * Linear Phase : Yes (Type 2) * Arithmetic : fixed * Numerator : s16,15 -&gt; [-1 1) * Round Mode : convergent */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* General type conversion for MATLAB generated C-code */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"tmwtypes.h"</span></span></span><span class="hljs-meta"> const int BL = 128; const int16_T B[128] = { -18, 0, 19, 39, 58, 75, 88, 97, 100, 96, 85, 68, 44, 16, -16, -50, -83, -113, -139, -157, -166, -164, -152, -128, -94, -51, 0, 55, 111, 164, 211, 248, 272, 280, 269, 240, 192, 126, 45, -47, -146, -245, -339, -421, -483, -521, -528, -501, -434, -329, -183, 0, 217, 462, 728, 1006, 1288, 1564, 1823, 2056, 2254, 2409, 2517, 2571, 2571, 2517, 2409, 2254, 2056, 1823, 1564, 1288, 1006, 728, 462, 217, 0, -183, -329, -434, -501, -528, -521, -483, -421, -339, -245, -146, -47, 45, 126, 192, 240, 269, 280, 272, 248, 211, 164, 111, 55, 0, -51, -94, -128, -152, -164, -166, -157, -139, -113, -83, -50, -16, 16, 44, 68, 85, 96, 100, 97, 88, 75, 58, 39, 19, 0, -18 };</span></span></code> </pre> <br></div></div><br>  In addition, you can create a coefficient file * .COE in a special format for Xilinx.  To do this, select the type of coefficients with a fixed point and set their width.  Then click <i>Targets -&gt; Xilinx Coefficient (.COE) File</i> , as a result of which the contents of the file are displayed in the main MATLAB window - global settings and coefficients in HEX format. <br><br><div class="spoiler">  <b class="spoiler_title">Example * .coe file</b> <div class="spoiler_text"><pre> <code class="css hljs">; <span class="hljs-selector-tag"><span class="hljs-selector-tag">XILINX</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CORE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Generator</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">tm</span></span>)<span class="hljs-selector-tag"><span class="hljs-selector-tag">Distributed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Arithmetic</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">FIR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">filter</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">coefficient</span></span> (<span class="hljs-selector-class"><span class="hljs-selector-class">.COE</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">File</span></span> ; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Generated</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">by</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MATLAB</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">R</span></span>) 8<span class="hljs-selector-class"><span class="hljs-selector-class">.3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">and</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">the</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DSP</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">System</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Toolbox</span></span> 8<span class="hljs-selector-class"><span class="hljs-selector-class">.6</span></span>. ; ; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Generated</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">on</span></span>: 06<span class="hljs-selector-tag"><span class="hljs-selector-tag">-Dec-2015</span></span> 15<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:35</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:35</span></span> ; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Radix</span></span> = 16; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Coefficient_Width</span></span> = 18; <span class="hljs-selector-tag"><span class="hljs-selector-tag">CoefData</span></span> = 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">ffeb</span></span>, 00018, 00049, 00067, 0005<span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>, 00029, 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">ffd2</span></span>, 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">ff79</span></span>, 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">ff46</span></span>, 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">ff59</span></span>, ...</code> </pre><br></div></div><br>  It is seen that when a single impulse is fed to the input, nothing else is formed at the output, as the filter impulse response (graph from Simulink). <br><img src="https://habrastorage.org/files/c43/08d/440/c4308d4409034ac6b66d5d299a5e9316.png"><br><br><h4>  <b>Xilinx FIR Compiler</b> </h4><br>  As in the case of the CIC filter, I will provide a detailed description of the means for creating FIR filters from Xilinx.  I note that the description contains not just a translation from a datasheet, but comments and recommendations from the personal experience and experience of my colleagues. <br><br>  <b>FIR Compiler - Tab 1:</b> <br><img src="https://habrastorage.org/files/c2b/6fc/31e/c2b6fc31e1914896a964d299f5f81dbd.png"><br><br>  <b>Component name</b> - the name of the component (the Latin letters az, the numbers 0-9 and the symbol "_" are used). <br>  I recommend using meaningful names in which the main filter parameters are encrypted.  For example, <i>xfir128t_d1_b18_4c_w6_a7</i> is a filter made for Xilinx, N = 128 (taps), decimation is not used, the width of the coefficients is 18, four channels, the Kaiser window function with the parameter beta = 6, the FPGA chip is Artix-7. <br><br>  <b>Filter Coefficients:</b> <br><ul><li>  <b>Select source</b> - select the source of the coefficients ( <b>Vector</b> - a vector specified manually or <b>COE File</b> - a file with a set of coefficients).  It is preferable to use overloaded <b>* .COE</b> files. </li><li>  <b>Coefficient Vector</b> - a vector of coefficients set by hand. </li><li>  <b>Coefficient File</b> is a vector of coefficients read from a file. </li><li>  <b>Number of Coefficient Sets</b> - the number of actually used DSP blocks for processing coefficients.  The number of coefficients must be divided completely by the specified value.  A useful option when operating at a high frequency relative to the sampling frequency, allows you to significantly save FPGA resources. </li><li>  <b>Number of Coefficient (per set)</b> - the number of coefficients processed at a time by DSP blocks.  The value in the field is automatically set when reading the number of coefficients and the previous parameter. </li></ul><br>  <b>Filter Specification:</b> <br><ul><li>  <b>Filter type</b> - filter type: simple / interpolating / decimator / polyphase. </li><li>  <b>Rate Change Type</b> - change processing speed.  May be integer or fractional. </li><li>  <b>Interpolation / Decimation Rate Value</b> - interpolation / decimation coefficient. </li><li>  <b>Zero Pack Factor</b> - for interpolating filters, the parameter determines the number of zeros inserted between the coefficients. </li><li>  <b>Number of channels</b> - the number of independent filtering channels: 1-64. </li></ul><br>  <b>Hardware Oversampling Specification:</b> These parameters affect the output sampling rate, the number of cycles required for data processing.  The level of parallelism within the kernel and the amount of resources occupied also depend on these parameters. <br><ul><li>  <b>Select format</b> - selects the frequency ratio of the filter: Frequency Specification / Sample period. </li><li>  <b>Frequency Specification</b> - Frequency specification: the user sets the sampling rate and the frequency of data processing. </li><li>  <b>Sample period</b> - Clock specification: the user sets the ratio of the processing frequency to the clock frequency of the data. </li><li>  <b>Input Sampling Frequency</b> - input sampling rate: *. </li><li>  <b>Clock frequency</b> - filter processing frequency: *****. </li><li>  <b>Input Sampling period</b> - the ratio of the processing frequency to the frequency of the input clock signal: *****. </li></ul><br>  ***** - the range depends on the general settings and the sampling rate R. <br><br>  <b>FIR Compiler - Tab 2:</b> <br><img src="https://habrastorage.org/files/244/5d6/c2d/2445d6c2d6374ba997042763f48da07a.png"><br><br>  <b>Filter Architecture</b> - sets the implemented architecture of the filter. <br><ul><li>  <b>Systolic Multiply Accumulate</b> - an accumulated systolic filter, </li><li>  <b>Transpose Multiply Accumulate</b> - tunable filter with accumulation, </li><li>  <b>Distributed Arithmetic</b> - filter on FPGA distributed logic. </li></ul><br>  <b>Coefficient Options</b> - parameters for coefficients <br><ul><li>  <b>Use Reloadable Coeffcients</b> - use <b>reloadable</b> coefficients.  Useful option to implement in one filter overload frequency characteristics. </li><li>  <b>Coefficient Structure</b> - structure of coefficients, 5 types: asymmetric, symmetric, negatively symmetric, half-strip and with the Hilbert transform.  By default, the FIR compiler tries to determine the type of coefficients (inferred). </li><li>  <b>Coefficient Type</b> - type of coefficients: signed or unsigned. </li><li>  <b>Quantization</b> - sets the rounding method: integer coefficients, rounding to the nearest integer or maximum dynamic range (scales the coefficients relative to the maximum). </li><li>  <b>Coefficient Width</b> - the width of the coefficients.  The value in this field affects the frequency response of the filter, which can be observed in the corresponding window (Freq. Response). </li><li>  <b>Best Precision Fraction Length</b> - automatically sets the best ratio for the whole and fractional parts of the discharge grid. </li><li>  <b>Coefficient Fractional Bits</b> - defines the position for separating the whole part from the fractional in the bit grid of the coefficients representation. </li></ul><br>  <b>Datapath Options</b> - input options <br><ul><li>  <b>Number of Paths</b> - determines the number of parallel channels for processing.  The number of DSP cores is proportional to the value in this field.  For this option, several independent data streams are input to the filter, while for the Number of Channels parameter, the data is received at one input and processed sequentially. </li><li>  <b>Input Data Type</b> - data type at the input of the filter (signed or unsigned). </li><li>  <b>Input Data Width</b> - the width of the input data. </li><li>  <b>Input Data Fractional Bits</b> - determines the number of bits per fractional part of the input data representation.  The value in this field does not affect the implementation of the filter!  (a fixed-point number can be represented as you please: with a fractional part or without it, but the result is the same). </li><li>  <b>Output Rounding Mode</b> - output rounding mode: full precision, discarding the least significant bits, rounding to the whole up / down, rounding to even / odd.  In many tasks, this parameter is not required to change and you can leave Full Precision - full accuracy. </li><li>  <b>Output Width</b> - the width of the output filter. </li><li>  <b>Output Fractional Bits</b> - the number of bits that define the fractional part of the output.  The field is informative and does not affect the implementation of the filter. </li><li>  <b>Allow Rounding Approximation</b> - for Symmetric Rounding Mode, the option allows approximation when rounding without additional resource costs (automatic determination of the sign bit in a word). </li><li>  <b>Registered Output</b> - the active option adds an additional register to the filter output to increase the performance (maximum processing frequency) of the filter. </li></ul><br>  <b>FIR Compiler - Tab 3:</b> <br><img src="https://habrastorage.org/files/ae2/146/d13/ae2146d131fa4e6092580225bd2d10d6.png"><br><br>  <b>Optimization Goal</b> - defines the optimization goal when creating a filter (Area - by area, Speed ‚Äã‚Äã- by speed).  In most cases, it is possible to simultaneously achieve maximum speed and minimum resource expenditures, but in specific cases, when specifying Speed, the filter optimally places the internal registers in the critical paths between logical functions. <br><ul><li>  <b>SCLR</b> - synchronous filter reset (a logical unit at the input resets). </li><li>  <b>Use Deterministic SCLR Behavior</b> - defines the behavior of the internal data of the Multiply-Accumulate filter type during the reset process.  With the active option, the reset signal clears the internal registers, data memory and storage coefficients. </li><li>  <b>ND</b> - "New data", the input signal that determines the flow of data to the input of the filter.  Together with the RFD signal allow you to organize batch processing.  As a rule, the ND and RFD signals are connected to the control signals of the FIFO. </li><li>  <b>CE</b> - ‚ÄúClock Enable‚Äù, filter enable signal.  At a low level at the input of this signal, any processing inside the filter is suspended, regardless of whether new data arrive or not. </li><li>  <b>DATA_VALID</b> - signal of validity of the output data.  This option is useful only in multi-channel mode (Number of Channels&gt; 1). </li></ul><br>  <b>Memory Options</b> - global settings for selecting the type of memory for storing input data, filter coefficients, intermediate and output data.  Choosing block memory instead of distributed memory, in some cases, you can save logical FPGA resources hundreds of times! <br>  For Data / Coefficient / Input / Output Buffer Type, <i>Auto / Block / Distributed</i> modes are possible. <br>  <b>Preference for Other Storage</b> - defines the type of memory for intermediate data.  Also available modes are Auto / Block / Distributed. <br><br>  <b>DSP Slice Column Options</b> - defines the settings for the distribution of DSP blocks between the FPGA columns.  For some filter architectures, for example, with symmetric coefficients, Multi-Colomn Support mode is not available, so you need to monitor the possible implementation of the filter. <br><ul><li>  <b>Device Column Lengths</b> - determines the length of the columns of DSP blocks.  Useful informative field in which you can pre-define the upper limit of the order of the filter and the maximum number of implemented filters. </li><li>  <b>Column Configuration</b> - determines the configuration and position of DSP blocks in columns.  It is necessary to work with this parameter carefully, since a large delay may occur when the filter is broken between several columns, therefore the maximum clock frequency will drop. </li><li>  <b>Inter-column Pipe Length</b> - determines the number of additional registers between columns of DSP blocks to eliminate the negative effect of the propagation delay. </li></ul><br>  <b>FIR Compiler - Tab 4:</b> <br><img src="https://habrastorage.org/files/a6f/f1b/21e/a6ff1b21e26c4d4191eaf45883aa057a.png"><br><br>  <b>Summary</b> - this tab in the form of a list reflects the final filter settings (number of channels, filter order, frequency parameters, input, output and intermediate data width, coefficient width, filter delay, number of DSP blocks used, presence of control signals, etc.) . <br><br>  On the left side of the FIR Compiler window there are three useful additional tabs: <br><ul><li>  <b>IP-symbol</b> - a schematic view of an IP block with active I / O ports. </li><li>  <b>Freq.</b>  <b>response</b> - frequency response of the FIR filter. </li><li>  <b>Implementation Details</b> - an estimate of the occupied resources of the DSP and RAMB, the total delay, the number of coefficients and the order of their loading. </li></ul><br><h4>  <b>Abstract example</b> </h4><br>  <b>Condition</b> <br>  We will calculate the wideband preprocessing filter with the following parameters: <br><ul><li>  Fs sampling rate: 250 MHz, </li><li>  Fpass filter cutoff frequency: 55 MHz </li><li>  Squareness coefficient:&gt; 0.88 (Fpass / Fstop), </li><li>  Bandwidth Suppression (Apass): &lt;0.5 dB, </li><li>  Attenuation in the attenuation band (Astop):&gt; 50 dB. </li></ul>  Implement six independent filtering channels on the Artix-7 XC7A100T-FGG484 microcircuit.  The coefficients IMH - overloaded, symmetric and independent for each channel of the filter. <br><br>  <b>Decision</b> <br><br>  <b>Step 1: FPGA Resource Assessment</b> <br>  You need to understand how much crystal resources are available to implement such a filter.  In the DS180, you can find that the chip has 240 DSP48E1 blocks arranged in three columns (this is important!).  It is known from TZ that the EM is symmetrical, which means that the filter of order N will require N / 2 blocks DSP48E1.  Therefore, on the selected chip, it is possible to implement 2 filters with a characteristic length of N = 240, or 6 filters with a length of N = 80. For practical purposes, when processing signals, the length of the EM is chosen to be a multiple of the power of two.  For example, N = 64, 128, or 256. Or, N = (128 + 64), (32 + 16 + 8).  In our case, it is necessary to implement 6 filters on 240 DSP blocks.  Given the symmetry for each filter, it is possible to use a length of N &lt;81 coefficients.  Suppose that to achieve the filter parameters N = 80 = 64 + 16 coefficients suffice. <br><br>  <b>Step 2: Find Filter Ratios</b> <br><br>  Run FDATool and enter the filter parameters from the specification into the required fields (remember that the order of N is set to 1 less than the true order of the filter).  Mode 1 - <i>Equiripple</i> .  For the cutoff frequency Fpass = 55 MHz and squareness ratio&gt; 0.85, we find the barrier frequency Fstop &lt;62.5 MHz.  The following figure shows the calculation of the filter according to the required parameters: <br><img src="https://habrastorage.org/files/d6a/de1/ba7/d6ade1ba7b5844dfaf4ce0af433b9f71.png"><br><br>  As you can see, the filter satisfies all the listed requirements. <br>  <i>Mode 2 - Window</i> .  Suddenly, just before the delivery of the project, your abstruse customer got a thought in his head.  ‚ÄúI want 70 dB suppression, all other things being equal!‚Äù  The element base is selected, the board is divorced and assembled, the FPGA is installed, the project has been debugged for several months and there is no possibility to deliver something to redo.  What to do?  Design your own FIR filter a week before the project is completed?  Search for other methods of suppressing the frequency response?  Redo the board and install FPGA fatter?  Unreal!  The main thing - do not panic.  Equiripple method does not save.  Go to the window mode Window.  When choosing my favorite Kaiser window, you can achieve better filter performance.  For example, to provide the necessary suppression in the attenuation band Astop = 80 dB (parameter Beta = 8).  But for the window method, one should take into account that in the attenuation band, quantization effects can manifest themselves in the decay band because of the insufficient bitness of the coefficients. <br><img src="https://habrastorage.org/files/7d5/c36/6d2/7d5c366d229a4acbbf0b9480160ab662.png"><br><br>  Further, in a known manner, upload the calculated coefficients to the * .COE file for further work. <br><br>  <b>Step 3: Implementation</b> <br><br>  The number of channels and coefficients was chosen in such a way that the DSP48E1 resources in the FPGA are 100% occupied.  The number of occupied resources for 6 channels in the figure below: <br><img src="https://habrastorage.org/files/cc1/358/9e4/cc13589e4eb0447e95af92e1f5488e0e.png"><br><br>  Do not be afraid that the project will not work at 250 MHz.  How it will work.  PlanAhead loves to be reinsured and indicates values ‚Äã‚Äãbelow real.  The results of the wiring of six channels FIR filters. <br><br><div class="spoiler">  <b class="spoiler_title">Beautiful drawings layout project</b> <div class="spoiler_text">  Schematic view of the part of the IP kernel FIR filter: <br><img src="https://habrastorage.org/files/e6a/0c1/4a7/e6a0c14a7eaa4d0890f4dd4cfa4e5110.png"><br><br>  PCB layout in FPGA Editor (Zoom bottom): <br><img src="https://habrastorage.org/files/29f/29f/d49/29f29fd494d245e088ba35bbdfad3711.png"><br><br>  Board layout in FPGA Editor: <br><img src="https://habrastorage.org/files/698/5e5/5e7/6985e55e79a34c5fb8a915c708c163ad.png"><br></div></div><br><h4>  <b>Practical advice</b> </h4><br>  Of course, the transition to the Window does not always save, and in practice there are several other methods that somehow simplify the life of the developer. <br><ol><li>  Determine in advance the possible decimation of the signal (with respect to the sampling frequency and the cut-off frequency in the signal spectrum).  Use cheap CIC filters for decimation.  After decimation, it is possible to reduce the number of DSP blocks used by the crystal. </li><li>  Determine the ratio of the sampling rate and the processing frequency in the FPGA chip.  If the processing frequency is several times higher than the sampling rate, you can save the same amount of resources by the FIR filter implementation. </li><li>  Implement the filter on the distributed logic of the FPGA, if it is possible and not critical from the point of view of processing frequencies.  This method is very difficult to implement and will not work stably for large orders of the filter N. </li><li>  To implement filters with symmetric IC, it is preliminary to estimate the size of the columns of DSP blocks and the number of these columns in the FPGA.  To implement long filters with a symmetric IC, a cascade connection of DSP blocks is required and when placing the filter inside the FPGA in one column, the DSP cells may not be enough.  On the other hand, when implementing independent filter channels, there may simply not be enough columns if only one filter can fit in each column.  It is necessary either to reduce the length of the characteristic, or to make two small filters with a smaller number of coefficients. ****** </li><li>  For modern FPGA crystals (Altera and Xilinx), when implementing a filter with a symmetric EM, use a preliminary adder in the DSP node, and not on distributed logic.  An internal pre-adder saves not only logical cells, but also crystal trace resources!  ******* </li></ol>  ****** - For Xilinx, the filter is guaranteed not to be divorced if the filter with symmetrical EI does not fit into one column (in PlanAhead, columns of DSP blocks are highlighted in green).  On Altera - did not check.  I would be glad if someone will share their experiences. <br>  ******* - for FPGA chips manufactured by Xilinx 7 series and older, this method saves only if the digit capacity of the coefficients does not exceed 18. For Uber-modern as of 2015-2016, Xilinx Ultra-Scale chips are possible implement a preliminary adder with a coefficient of 24 coefficients. <br><br><h4>  <b>Vivado hls</b> </h4><br>  Modern methods for creating nodes tasks of digital signal processing on the FPGA are reduced to two principles: <br><ul><li>  reduction of design time (the concept of " <i>time-to-market</i> "), </li><li>  reduction of the entry threshold (popularization of FPGA among C ++ developers). </li></ul><br>  Both principles did not come about by chance and are primarily due to the constant increase in the logical capacity of the FPGA.  Xilinx declares that the old programming methods (in VHDL and Verilog) no longer cope with modern tasks, and there is a high probability that in the future programming on FPGA will be conducted exclusively in high-level languages ‚Äã‚Äãsuch as C and C ++.  Xilinx a few years ago announced a new design tool called Vivado HLS and offers all large projects to partially or fully transfer to a new level.  Development on Vivado HLS is reduced to the fact that you can get away from the concept of " <i>clock frequency</i> " and develop complex algorithms without reference to the FPGA, and all the optimization under the FPGA is already done at the last stage of the project.  Let's see what can be done with the help of the new environment and develop the simplest FIR filter in Vivado HLS. <br><br>  As an example, I took one of the labs from Xilinx, in which, as a first approximation, all the power of modern tools is shown.  The main development with the help of Vivado HLS is based on interrelated tasks: writing code and optimizing it for speed (Speed) and occupied area (Area) with the help of directives. <br><br>  Xilinx proposes the following design behavior: <br><ul><li>  - C Validation / Simulation ( <i>Project -&gt; Run C Simulation</i> ): writing an algorithm, debugging a project, identifying errors in the code, comparing data with a standard, etc. </li><li>  - C Synthesis ( <i>Solution -&gt; Run C Synthesis</i> ): project synthesis from C-code to RTL form and analysis of the received data: performance evaluation (latency, trip count, speed etc.), resource estimation, received input / output interface. * </li><li>  - RTL Verification ( <i>Solution -&gt; Run C / RTL Cosimulation</i> ): reuse the C-model of the main () test to analyze the RTL model (self-checking). </li><li>  - IP Creation ( <i>Solution -&gt; Export RTL</i> ): creation of an IP core for further use in the main project (Xilinx ISE, Vivado, etc.) </li></ul>  * - The power of Vivado HLS in creating unique solutions ( <b>solutions</b> ) differing in the ways of optimization.  The correct approach is to create a set of solutions and choose the best, rather than debugging one single! <br><br>  <i>How to make different decisions?</i>  Use <b>directives</b> is a tool for optimizing projects in Vivado HLS.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Directives can be added to the source code ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) or to a separate directive </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source file</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - suitable for setting directives that WILL NOT be changed during project creation. </font><font style="vertical-align: inherit;">For example, the directives for the interface ports I / O do not change. </font><font style="vertical-align: inherit;">In the draft, these directives are indicated by the prefix: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#HLS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Directive file</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - suitable for setting conditions and constraints that affect speed and placement optimization. </font><font style="vertical-align: inherit;">As a rule, a project can compare several solutions in different solutions and choose the optimal one. </font><font style="vertical-align: inherit;">In the project, these directives are indicated by the prefix: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% HLS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will give an example of the source for the simplest FIR filter. </font><font style="vertical-align: inherit;">Pay attention to the directives in the source code.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIR Filter C ++ for Vivado HLS</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"fir.h"</span></span></span><span class="hljs-meta"> void fir ( data_t *y, coef_t c[N], data_t x ) { </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;b&gt;#pragma HLS&lt;/b&gt; INTERFACE ap_ovld port=y &lt;b&gt;#pragma HLS&lt;/b&gt; INTERFACE ap_vld port=x &lt;b&gt;#pragma HLS&lt;/b&gt; RESOURCE variable=c core=RAM_1P_BRAM static data_t shift_reg[N]; acc_t acc; data_t data; int i; acc=0; Shift_Accum_Loop: for (i=N-1;i&gt;=0;i--) { if (i==0) { shift_reg[0]=x; data = x; } else { shift_reg[i]=shift_reg[i-1]; data = shift_reg[i]; } acc+=data*c[i];; } *y=acc; }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Directives in a separate file are as follows: </font></font><br><pre> <code class="html hljs xml">set_directive_unroll "fir/Shift_Accum_Loop" set_directive_array_partition -type complete -dim 1 "fir" shift_reg</code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> During the optimization process, the developer often has to compare different performance and resource results. </font><font style="vertical-align: inherit;">Therefore, most of the directives are often written to a separate file. </font><font style="vertical-align: inherit;">If the developer is confident that a specific optimization is needed for all solutions, then it can be added to the source code! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the FIR project we will create three different solutions:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> without the use of directives (the synthesizer uses a minimum of resources - sequential data processing), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> using port directives (the synthesizer optimizes the I / O interface), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> using the UNROLL directive (for expanding the FOR loop and parallel processing of each iteration of the loop). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result of the synthesis in Vivado, you can carry out a full analysis of the occupied resources and maximum performance, see the interface of input / output ports for the created kernel. </font><font style="vertical-align: inherit;">In addition, you can see how certain functions are executed, how many resources they occupy and how many clock cycles are executed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparison of three solutions:</font></font><br><img src="https://habrastorage.org/files/bbd/e75/247/bbde752475314e81af7887affd000816.png"><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The results of the synthesis project in Vivado HLS</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Directives: </font></font><br><img src="https://habrastorage.org/files/b0a/5e9/f65/b0a5e9f65ce84fdcb783fe4502122837.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance </font></font><br><img src="https://habrastorage.org/files/8d2/5d1/7cb/8d25d17cb746417490d84546e0cfc5c0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tab: Resources tab:</font></font><br><img src="https://habrastorage.org/files/9c3/dc8/cf9/9c3dc8cf9bf442139ae59fb273bcb2a5.png"><br><br><ul><li>   x    y    .   c   ,        RAM; </li><li>   ; </li><li>   shift_reg      ; </li><li>     ,       (   ). </li></ul><br>  : <br><img src="https://habrastorage.org/files/d3e/1f4/b99/d3e1f4b992864b2fbfa911a29723a527.png"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The process of creating a new project and all the design steps will not be described, since the article has already grown to unprecedented size. </font><font style="vertical-align: inherit;">But if you are interested in the topic of using Vivado HLS in my projects - I will be happy to share my experience. </font><font style="vertical-align: inherit;">You can also use the help of habrauzer </font></font><a href="https://habrahabr.ru/users/urock/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">urock</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In this case, he is a master!</font></font><br><br><h4>  <b>Conclusion</b> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On this I would like to summarize. </font><font style="vertical-align: inherit;">The article describes the basic principles of creating FIR filters on FPGAs. </font><font style="vertical-align: inherit;">General conclusions on the article:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FIR filters are linear non-recursive filters that are fairly simple to implement on modern FPGAs and processors. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Filter order = impulse response length = number of coefficients = number of delay lines. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> May have accurate linear phase response, constant group and phase delays. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For linear phase response, symmetrical filter coefficients are required. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Do not forget about the Gibbs effect when calculating the filter coefficients. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When calculating the coefficients, use modern tools and do not reinvent the wheel. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the length of the filter N exceeds reasonable limits (for example, more than 512), use the fast convolution algorithm through double FFT. </font></font></li><li>       . </li><li>           . </li><li>         . </li><li>     ,        . </li><li>        .  ,   . </li></ul><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"> Altera FIR Design: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/RJ3BU2v27tg%3Ffeature%3Doembed&amp;xid=25657,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiBEU-qQLfeCxd23Sr03HFQjGMXXQ" frameborder="0" allowfullscreen=""></iframe><br><br> Xilinx HLS FIR Design 1: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/UNu6Qh3fQGw%3Ffeature%3Doembed&amp;xid=25657,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhj9NsIOKwJYYALDeYGmyYjUq67uVg" frameborder="0" allowfullscreen=""></iframe><br><br> Xilinx HLS FIR Design 2: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/k2bJRUzhjdE%3Ffeature%3Doembed&amp;xid=25657,15700002,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgV7VMhJSHueHCwFeSHgTpOCIOBJQ" frameborder="0" allowfullscreen=""></iframe><br></div></div><br> <b></b> <br><ol><li> <a href="http://habrahabr.ru/post/128140/">  </a> </li><li> <a href="http://www.dsplib.ru/content/filters/fir/fir.html">  DSPLIB</a> </li><li> <a href="https://www.altera.co.jp/ja_JP/pdfs/literature/ug/fircompiler_ug.pdf">Altera FIR Compiler</a> </li><li> <a href="http://www.xilinx.com/support/documentation/ip_documentation/fir_compiler_ds534.pdf">Xilinx FIR Compiler</a> </li><li> <a href="http://www.xilinx.com/support/documentation/user_guides/ug479_7Series_DSP48E1.pdf">Xilinx DSP48E1 (7 Series)</a> </li><li> <a href="http://www.xilinx.com/support/documentation/user_guides/ug579-ultrascale-dsp.pdf">Xilinx DSP48E2 (Ultra-Scale)</a> </li><li> <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D1%2581_%25D0%25BA%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25B8%25D0%25BC%25D0%25BF%25D1%2583%25D0%25BB%25D1%258C%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B9_%25D1%2585%25D0%25B0%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25B5%25D1%2580%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25BE%25D0%25B9">Wikipedia FIR</a> </li><li> <a href="https://en.wikipedia.org/wiki/Parks%25E2%2580%2593McClellan_filter_design_algorithm">Parks-McClellan algorithm</a> </li><li> <a href="http://www.mathworks.com/help/signal/ug/opening-fdatool.html">MATLAB Tutorial 1</a> </li><li> <a href="http://www.mathworks.com/help/signal/examples/introduction-to-the-filter-design-and-analysis-tool-fdatool.html">MATLAB Tutorial 2</a> </li><li> <a href="http://opencores.org/project,cascaded_fir_filter">OpenCores FIR 1</a> </li><li> <a href="http://opencores.org/project,lowpowerfir">OpenCores FIR 2</a> </li><li> <a href="http://opencores.org/project,fir_wishbone">OpenCores FIR 3</a> </li></ol><br>  <i>To be continued...</i> </div><p>Source: <a href="https://habr.com/ru/post/274847/">https://habr.com/ru/post/274847/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274835/index.html">Create a hardware keyboard logger</a></li>
<li><a href="../274837/index.html">Installing Quartus II Web Edition for Linux</a></li>
<li><a href="../274839/index.html">MIPSfpga: outside of canon</a></li>
<li><a href="../274841/index.html">Minesweeper on FPGA</a></li>
<li><a href="../274843/index.html">‚ÄúStupid‚Äù watches on FPGA</a></li>
<li><a href="../274849/index.html">How we started production, or my software development experience for a Siemens Simatic PLC</a></li>
<li><a href="../274851/index.html">Mikhail Romanovich Shura-Bura - the patriarch of domestic programming and its development</a></li>
<li><a href="../274853/index.html">Community DevCamp reports are available.</a></li>
<li><a href="../274855/index.html">Dangerous video: how I found a vulnerability in video hosting and did not die after 7 days</a></li>
<li><a href="../274857/index.html">New in Wolfram Language | Analytical solution of partial differential equations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>