<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We implement secure VPN protocol</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Again the topic of VPN, confidential data transfer, security and cryptography. Now, in the post-Snowden era, it has become fashionable to rivet safe, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We implement secure VPN protocol</h1><div class="post__text post__text-html js-mediator-article">  Again the topic of VPN, confidential data transfer, security and cryptography.  Now, in the post-Snowden era, it has become fashionable to rivet safe, respectful privacy, unbreakable, protected from special services and censorship programs.  However, this article is not just another marketing campaign, but rather a demonstration of how cryptographic primitives are used and what you should pay attention to when developing such software. <br><br> <a href="http://habrahabr.ru/company/ivi/blog/256365/"><img src="https://habrastorage.org/files/589/707/b5d/589707b5d7eb48fbb62dadafdfb27fbc.jpg"></a> <br><br>  The result of this work is to create a working client server suitable for review by developers (that is, some high-level language code) that is productive enough to be used in an industrial environment with a high security threshold: <a href="http://www.cypherpunks.ru/govpn/"><b>GoVPN</b></a> . <br><a name="habracut"></a><br>  What is not satisfied with the mass of known existing solutions in the form of <a href="http://www.openssh.com/">SSH</a> (it can work with TUN / TAP devices and be used for VPN), <a href="https://ru.wikipedia.org/wiki/TLS">TLS</a> , <a href="https://ru.wikipedia.org/wiki/OpenVPN">OpenVPN</a> or <a href="https://ru.wikipedia.org/wiki/IPsec">IPsec</a> ?  The complexity of both the protocol and the code.  Hence the complexity of the review, the security question.  Dependence on US organizations that dictate which algorithms can be used.  Only SSH out of the box offers such fast, secure, security-independent algorithms like <a href="https://ru.wikipedia.org/wiki/Salsa20">ChaCha20</a> , <a href="https://en.wikipedia.org/wiki/Poly1305-AES">Poly1305</a> and <a href="https://en.wikipedia.org/wiki/Curve25519">Curve25519</a> .  TLS-libraries and the protocol themselves massively showed a bad side because of its complexity.  OpenVPN, when it does not use <a href="https://en.wikipedia.org/wiki/Pre-shared_key">PSK</a> (pre-shared key - a key known in advance to both sides), also depends on TLS with all the consequences. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#fd004c">Transport protocol</font> </h2><br>  To solve the problem of creating a simple VPN, modern operating systems offer such a convenient piece as <a href="https://ru.wikipedia.org/wiki/TUN/TAP"><b>TUN / TAP</b></a> : virtual network interfaces.  It is very simple to write a client server application that reads frames from the interface, wrapping them in UDP packets and sending them to the remote side.  But we want to ensure the confidentiality of the transmitted data, authentication by both sides of the connection (to make sure that they pretend to be what we expect). <br><br>  The entire protocol consists of two parts globally: the handshake process and the transport.  The handshake will be considered as a black box at the exit from which we will receive: an IP address with the opposite port for sending UDP packets and a common symmetric encryption key.  With a handshake, any communication begins, and it is enough to authenticate the parties only at this stage. <br><br>  The transport is responsible for encrypted (ensuring the confidentiality of the payload) transmission of messages and their reception with decryption.  As the algorithm / encryption function, choose <a href="https://ru.wikipedia.org/wiki/Salsa20"><b>Salsa20</b></a> (or a variant of this algorithm ChaCha20).  At the moment, it has very good cryptographic security (no fatal flaws in cryptanalysis have been identified), the highest performance and ease of implementation in the code.  This is a stream cipher: that is, we can assume that the result of its work is a pseudo-random sequence of bytes, which must be <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE_%25D0%25BC%25D0%25BE%25D0%25B4%25D1%2583%25D0%25BB%25D1%258E_2">XOR</a> with data that requires encryption. <br><br>  With stream ciphers you should be very careful.  Unlike block ones, they are much more difficult to analyze (that is why popular block ciphers are now all block ones), and if at least somewhere the key (and, accordingly, pseudo-random output of this function) was used twice, this instantly leads to the <a href="https://en.wikipedia.org/wiki/Stream_cipher_attack">possibility of easy decryption of</a> previously intercepted messages key.  However, there are also nice simple sides: the size of the plaintext is equal in length to the size of the encrypted one, no need to think about <a href="https://en.wikipedia.org/wiki/Padding_(cryptography)">additions</a> (up to the multiplicity of the cipher block size), about various encryption <a href="https://en.wikipedia.org/wiki/Cipher_block_chaining">modes</a> (CBC, ECB, CTR, and others). <br><br>  Salsa20 accepts, besides a key with data, also nonce: a number that must be used only once for a given key.  Using twice is fatal.  As nonce, we use a simple, constantly incremented counter.  Every incoming packet increases it.  This requires storing the state of the transport connection on both sides.  Alternatively, it would be possible to use a pseudo-random number generator (PRNG) and access it every time, but it is much slower and finding a quality one (which, while running a single-key cipher, is guaranteed not to spit out the same number) PRNG is problematic.  The receiving party for decryption should also know this nonce.  If the packets were not lost and reached guaranteed in the specified order, then it is sufficient to simply store the nonce state of the opposite side counter and increment it with the arrival of the packet.  But UDP packets are lost and therefore we prescribe a nonce value for each packet at the beginning. <br><br>  This is already a workable protocol that ensures the confidentiality of data transmission, however, it is vulnerable to attacks inherent in all stream ciphers: ciphertext can be consciously changed and the <a href="https://en.wikipedia.org/wiki/Bit-flipping_attack">required substitution of plaintext</a> can be made after decryption.  To prevent them, it is necessary to authenticate the transmitted data packets: confirm and make sure that this is the exact data set that was transmitted.  As a rule, <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BC%25D0%25B8%25D1%2582%25D0%25BE%25D0%25B2%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BA%25D0%25B0">message authentication codes</a> (MAC - message authentication code) are used.  The input MAC accepts the key and the data to be authenticated, and the output receives the so-called tag attached to the message during transmission. <br><br>  We choose <a href="https://en.wikipedia.org/wiki/Poly1305-AES"><b>Poly1305</b></a> as the MAC.  Like Salsa20 from the same author, it has the highest security ceiling, performance and ease of implementation.  Poly1305 has a different API in different libraries, but in the simplest case, we can assume that its keys are disposable and one key is used to authenticate only one message.  As a key, you can have some kind of secret (known only to two sides) part with a counter attached to it.  But it has become a normal practice to generate an authentication key for each message based on the Salsa20 PRNG output of this packet.  That is, at the time of packet encryption, we take the first 256 bits of the Salsa20 output and use them as the authentication key for Poly1305.  To encrypt them, of course, no longer use.  Since the internal state of Salsa20 is 512 bits, then for every fireman we also ignore the next 256 bits of output.  Yes, this is a loss of performance, but insignificant, and giving a simple (and therefore potentially more reliable in terms of security) code.  This is already a practiced practice in SSH and TLS protocols. <br><br>  In this way, we get an authenticated encryption mode that can actually be used in practice.  The only thing that is slightly complemented is obfuscation / scrambling of the transmitted nonce.  From the point of view of security, there are no complaints about it, but we are looking to ensure that, ideally, our protocol is indistinguishable from noise, from random data, in order to make life difficult for the receiving DPI traffic analysis systems. <br><br>  Nonce is a 64 bit data block.  Ideally, you can just encrypt it, turning it into a kind of noise.  We already have the Salsa20 cipher, however, it is a PRF function (pseudorandom function is a pseudo-random function), and we want to have a PRP (pseudorandom permutation) pseudo-random permutations): just mix the bits.  You can make PRP from PRF and <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2582%25D1%258C_%25D0%25A4%25D0%25B5%25D0%25B9%25D1%2581%25D1%2582%25D0%25B5%25D0%25BB%25D1%258F">Luby-Rackoff</a> proved it.  However, we still introduce another primitive: the <a href="https://ru.wikipedia.org/wiki/XTEA">XTEA</a> block cipher function.  The choice fell on her because of the ease of implementation, so as not to write her own network of Feistel from Salsa20.  XTEA is not the fastest, not the safest (although it has a high threshold), but this is all not so critical due to the fact that it will be called exactly once when sending a packet.  Since nonce is not repeated, then you don‚Äôt need to think about encryption modes, initialization vectors and the like.  Since nonce is a multiple of the size of the cipher block, no addition is needed. <br><br>  In our case, the nonce encryption key will be Salsa20 output with zero (which is not used by both parties) nonce.  It is calculated only once (after a handshake) and remains so permanently. <br><br>  There remains the last thing to remember: what to do with a replay attack.  Its essence is that nobody forbids to intercept a packet and resend it.  There are a lot of solution options: remembering packages and looking at whether duplications occur (this requires memory), looking at time stamps (this requires good clock synchronization), or, in our case, just remembering the last nonce of the opposite side.  All packets with nonce below the last will be ignored.  Unfortunately, due to the nature of UDP packets in the process of transmission, they may be reordered and therefore their losses will occur with this approach.  In our implementation (this doesn‚Äôt concern the protocol as such) we optionally allow some window of allowable variations of nonce values: a compromise between absolute protection against repeated packets and a relatively small window when such an attack can be carried out in practice. <br><br>  The resulting transport protocol looks like this: <br><br><img src="https://habrastorage.org/files/910/258/66c/91025866c82e4c9681bd17b2e6476f6b.png"><br><br><h2>  <font color="#fd004c">Handshake</font> </h2><br>  Now let's look at the handshake protocol, as a result of which the most important thing is to obtain a common encryption key and trust in the opposite side (authenticate it).  As a result, this part of the protocol will work only once, for a total of four packets, but the entire protocol security completely depends on this stage of the handshake. <br><br>  We do not use and do not want to use PSK for encryption: a long-lived key is, of course, simple, but if it is lost, compromised, we will be able to decrypt all previously intercepted traffic.  I want to have such a property as <a href="https://ru.wikipedia.org/wiki/Perfect_forward_secrecy">perfect direct secrecy</a> .  For this, we each time, for each new session, at each connection, generate new keys.  They are temporary, session and are only in the memory of programs and are forgotten when they are turned off.  In addition, there are restrictions on the maximum size of data that should be encrypted with one key.  For Salsa20, this border is quite large, but for peace of mind, it is worth remembering about it and, for example, exchanging keys (a handshake from scratch) every N gigabytes of encrypted traffic. <br><br>  In order for both parties to agree on the use of the same key, it is necessary to use a key exchange protocol / algorithm, such as <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BB_%25D0%2594%25D0%25B8%25D1%2584%25D1%2584%25D0%25B8_%25E2%2580%2594_%25D0%25A5%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0"><b>Diffie-Hellman</b></a> .  From the user's point of view, the essence of his work is simple: both parties generate a pair from a public and private key, exchange public parts over an unprotected communication channel, make calculations and they have a shared secret key.  Having intercepted the public parts of the keys it is nontrivial to find out their private parts or to find out the resulting common. <br><br>  In our protocol, we will use <a href="https://en.wikipedia.org/wiki/Curve25519"><b>Curve25519</b></a> : again, one of the simplest from the point of view of implementation in the program, which has excellent (possibly at the moment and unsurpassed) cryptographic security, amazing performance.  The algorithm is based on working with elliptic curves and therefore has a compact public key size: 256 bits.  The private key is generated simply by taking 256 bits of data from the PRNG operating system.  Curve25519 this function, roughly speaking, allows to multiply points on a curve.  The public key is obtained by multiplying the point, which is a private key, with a constant string inserted into the code.  The shared secret is obtained by multiplying the point of the private key on one side with the point of the public key opposite. <br><br>  By transmitting one packet with a public key from each side, we are able to establish a common key, a shared secret.  However, we do not authenticate the parties: we do not know with whom we communicate.  Very often, modern protocols make key exchange, then they are used to encrypt the communication channel, and already use a separate authentication protocol: for example, transferring passwords using either CHAP or using asymmetric cryptography such as RSA.  First, it means a large number of round-trip-packages over the network, which is not very fast.  Secondly, if asymmetric cryptography is used, then it is resource-intensive and complex. <br><br>  In our protocol, we use the parties' shared authentication key.  In fact, the password, but only high entropy.  If the task would be to authenticate only the client, then on top of the channel encrypted with the session key it would be possible to simply send this password and compare it with what is in the database.  However, if there is an attacker's server, he will know the password.  You can use the <a href="https://ru.wikipedia.org/wiki/CHAP"><b>CHAP</b></a> protocol: it is simple, fast, but the attacker's server learns the hash from the password / key.  On the one hand, the loss is not great, but this makes it possible to attack already on the hash function. <br><br>  The best choice for us is the <a href="https://en.wikipedia.org/wiki/Encrypted_key_exchange"><b>EKE</b></a> : Encrypted Key Exchange - encrypted key exchange.  This is a subtype of the PAKE protocol family: password authenticated key exchange - a key exchange that is authenticated by passwords.  The essence of the protocols is that it is at the time of the key exchange that one or two parties are authenticated.  In the simplest case, each of the two DH packets is symmetrically encrypted; a common password known to each other is used as the key.  If the password does not match, then the parties receive incorrectly decrypted public keys, which, when multiplied, will not give a matching common key. <br><br>  At the same time, there is such a property as zero-knowledge proof (zero-knowledge proof), in which the attacker will not know a bit of information about the PSK key: he receives encrypted data (noise) and the only thing he can do is try to decrypt it, but he cannot find out if he found the public key correctly (whether he decrypted it), since it is also a noise.  It is this property that is decisive in our choice of the DH-EKE protocol and is not in possession of the popular SSH, TLS, and others - they all have attacks on either asymmetric cryptography, or on hash functions, or on symmetric ciphers. <br><br>  All the same Salsa20 is used for encryption.  Since he has a nonce at the entrance, which should never be repeated, each time we generate a random nonce <b>R</b> for it and send it along with the encrypted public key DH from the client. <br><br><pre><code class="hljs pgsql">R, enc(PSK, R, ClientDHPubKey) <span class="hljs-comment"><span class="hljs-comment">--&gt; Server</span></span></code> </pre> <br>  The server, knowing the common authentication key, is able to correctly decrypt the message and immediately calculate the shared secret. <br><br><pre> <code class="hljs erlang-repl">R, enc(PSK, R, ClientDHPubKey) --&gt; Server enc(PSK, R+<span class="hljs-number"><span class="hljs-number">1</span></span>, ServerDHPubKey) --&gt; Client</code> </pre><br>  To authenticate the parties, we will transmit random numbers ( <b>RS</b> from the server side) and expect to receive them again in response after re-encryption: <br><br><pre> <code class="hljs erlang-repl">R, enc(PSK, R, ClientDHPubKey) --&gt; Server enc(PSK, R+<span class="hljs-number"><span class="hljs-number">1</span></span>, ServerDHPubKey), enc(K, R, RS) --&gt; Client enc(K, R+<span class="hljs-number"><span class="hljs-number">1</span></span>, RS) --&gt; Server</code> </pre><br>  The client, after receiving the public key of the server, is able to calculate the common key <b>K</b> , respectively, correctly decrypt the RS, encrypt it, and send it to the server.  The server compares the RS with what it sent (the state should be stored in memory) and thus make sure that the client really knows the PSK.  For server authentication, a similar action is taken with a random number from the <b>RC</b> client: <br><br><pre> <code class="hljs erlang-repl">R, enc(PSK, R, ClientDHPubKey) --&gt; Server enc(PSK, R+<span class="hljs-number"><span class="hljs-number">1</span></span>, ServerDHPubKey), enc(K, R, RS) --&gt; Client enc(K, R+<span class="hljs-number"><span class="hljs-number">1</span></span>, RS + RC) --&gt; Server enc(K, <span class="hljs-number"><span class="hljs-number">0</span></span>, RC) --&gt; Client</code> </pre><br>  In the latter case, as nonce, we use zero, but we can use R + 2 or something else like that.  Not fundamentally: just not repeated when using a single key, and the key K is already unique for each session.  The client, having received the correctly decrypted RC from the server, makes sure that he and the server actually have a common key and that the server knows the PSK. <br><br>  Shared key K may not have the best entropy.  Curve25519 still has not all 256 bits involved, respectively, its cryptographic strength is slightly less than the symmetric analogue of the 128-bit threshold.  In addition, the dishonest party can use specially created public keys, which, when multiplied, can give weak K keys: in theory, this is not excluded, although in practice it was not noticed for Curve25519.  But nevertheless, paranoid moods can be satisfied by separately generating with each party a qualitative high-entropy key and transmitting it in packets encrypted with a K-key.  The resulting shared key, which will already be used in the transport protocol, is obtained by the XOR of the parts created by the client and server.  If any side is dishonorable, then all the same one high-entropy part of the key is enough for a good key.  In the final diagram below, part of the client key is designated as <b>SC</b> , and the server, <b>SS</b> . <br><br>  And the final touch is to send the client ID.  This part is not related to protocol security: it is solely for ease of administration.  When we have several clients, you need to somehow determine which PSK keys you need to use.  It is possible to distinguish between clients and servers by ports, but we decided to send the identifier explicitly.  The identifier is not secret information, but by sending it in an explicit form, we do not have anonymity and give the opportunity to use the DPI and clearly see which user is making the connection. <br><br>  Currently, the identifier is sent as an encrypted R (which is already present in the original handshake packet from the user), where the client identifier is used as the key.  XTEA is used as a cipher.  Since R is different each time, then again, there is no need to think about initialization vectors, encryption modes.  The server cannot determine deterministically at once what key was used to encrypt it and it simply goes through all the client identifiers known to it and finds someone whose decryption result matches R. A symmetric cipher is a quick operation and therefore the costs are irrelevant here, in fact, by orders of magnitude smaller than DH work.  In this case, we, of course, provide the attacker with both plain text and ciphertext, but XTEA cryptanalysis shows that there is nothing to worry about.  In the worst case, the attacker finds out the client ID, but not the PSK key. <br><br>  The final version of the handshake looks like this: <br><br><img src="https://habrastorage.org/files/226/ae1/400/226ae140045e444a820c7ad863cc5372.png"><br><br><h2>  <font color="#fd004c">What else to do or fix?</font> </h2><br>  At the moment, the handshake packets have an explicit label (ends in zero bytes): the server can immediately understand that this is not a transport packet.  If we want to confront DPI, then we need to remove this label and make handshake packets indistinguishable from noise.  <b>Fixed in <a href="http://www.cypherpunks.ru/govpn/News.html">version 2.3</a></b> <br><br>  The protocol during the handshake and PSK key generation depends on the quality of the PRNG.  If PRNG is predictable, weak, then there is no need to talk about security.  Running software under a closed proprietary operating system and using the word "security" is meaningless.  Popular Microsoft Windows and Apple OS X are known to have sources of entropy and PRNG that are unsuitable for cryptography.  We could build our own PRNG, for example, on the basis of <a href="https://www.schneier.com/fortuna.html"><b>Fortuna</b></a> , but this is only a delay in the inevitable key leakage, since the OS still has full access to the program memory and no one guarantees that the information from them is not used for loopholes.  <b>Fixed in <a href="http://www.cypherpunks.ru/govpn/News.html">version 3.4</a></b> : third-party EGD-compatible PRNG sources can be used. <br><br>  The protocol provides confidentiality, authenticity of the payload, two-way zero-knowledge authentication of the parties, but data on the size and time of occurrence of packets flow into the network.  This can be solved by their fragmentation and the addition of "noise": outsiders, not related to the real packet traffic.  <b>Fixed in <a href="http://www.cypherpunks.ru/govpn/News.html">version 3.0</a></b> <br><br>  Read also the continuation of the article <a href="http://habrahabr.ru/company/ivi/blog/257431/">Let's realize an even more secure VPN protocol</a> ! <br><br>  All the best, do not switch! <br><br>  ¬© Sergey Matveev, Python and Go developer ivi.ru <br><br>  Our previous publications: <br>  <font color="#fd004c">"</font> <a href="http://habrahabr.ru/company/ivi/blog/240237/">Unnecessary items or how we balance between servers</a> <br>  <font color="#fd004c">¬ª</font> <a href="http://habrahabr.ru/post/249359/">Blowfish on guard ivi</a> <br>  <font color="#fd004c">¬ª</font> <a href="http://habrahabr.ru/post/247813/">Non-personalized recommendations: the association method</a> <br>  <font color="#fd004c">"</font> <a href="http://habrahabr.ru/post/237349/">By cities and villages or as we balance between CDN nodes</a> <br>  <font color="#fd004c">"</font> <a href="http://habrahabr.ru/post/236253/" title="b706a658aa01">I am Groot.</a>  <a href="http://habrahabr.ru/post/236253/" title="b706a658aa01">We do our analytics on events</a> <br>  <font color="#fd004c">¬ª</font> <a href="http://habrahabr.ru/post/236065/">All on one or as we built CDN</a> </div><p>Source: <a href="https://habr.com/ru/post/256365/">https://habr.com/ru/post/256365/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256355/index.html">godebug - cross-platform debugger for Go</a></li>
<li><a href="../256357/index.html">IT resources under control</a></li>
<li><a href="../256359/index.html">The correct bonus for your new server</a></li>
<li><a href="../256361/index.html">New spam: How scammers use interactive robots from the cloud</a></li>
<li><a href="../256363/index.html">Google suggests strengthening JSON with Jsonnet</a></li>
<li><a href="../256367/index.html">PKCS7 file structure</a></li>
<li><a href="../256373/index.html">CCTV on OS X</a></li>
<li><a href="../256377/index.html">Hacken und minen</a></li>
<li><a href="../256379/index.html">First sales experience at Unity Asset Store</a></li>
<li><a href="../256381/index.html">RS analysis (analysis of the fractal structure of time series)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>