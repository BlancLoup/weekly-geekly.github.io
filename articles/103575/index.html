<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>HTML5 for web designers. Part 2: The HTML5 Model</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="HTML5 for web designers 


1. Brief history of markup language 
2. HTML5 model 
3. Multimedia 
4. Forms 2.0 
5. Semantics 
6. HTML5 and modern conditi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>HTML5 for web designers. Part 2: The HTML5 Model</h1><div class="post__text post__text-html js-mediator-article"><blockquote><h6>  HTML5 for web designers </h6><br><ol><li>  <a href="http://habrahabr.ru/blogs/webstandards/103256/" title="First part">Brief history of markup language</a> </li><li>  <b>HTML5 model</b> </li><li>  <a href="http://habrahabr.ru/blogs/webstandards/104458/">Multimedia</a> </li><li>  <a href="http://habrahabr.ru/blogs/webstandards/104502/">Forms 2.0</a> </li><li>  Semantics </li><li>  HTML5 and modern conditions </li></ol><br></blockquote><br>  The Great French Revolution was a time of radical political and social transformation.  They also touched upon <i>time</i> as such: at a certain period of their existence, the French Republic lived according to a new system - there were 10 hours, one hundred minutes each, per day.  Obviously, she was much more logical and ‚Äúmore correct‚Äù than the usual sixties. <br><br>  However, she was a complete failure.  No one used it. <br><br>  The same can be said about XHTML 2. W3C only once again proved what the lesson of post-revolutionary France taught us: to change people's habits on the orders is very, very difficult. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  Principles of the model </h4><br>  With the goal of avoiding the mistakes of the past, the WHATWG primarily identified a set of principles that should follow the process of working on HTML5.  One of the key: "Maintain what already exists."  This is another reason why for HTML5 there is no clear date of entry into action. <br><br>  While XHTML 2 intended to score on everything that came before it, and start a new way, HTML5 is an add-on for existing specifications.  Much of HTML 4.01 is preserved and maintained. <br><br>  Some of the other principles are: ‚ÄúDo not reinvent the wheel‚Äù and ‚ÄúPave the lightly trodden paths‚Äù.  The latter means that if there is some widespread and popular way for web designers to solve a particular problem or problem ‚Äî even if it‚Äôs not the best ‚Äî it should be taken into account and added to the specification.  You can also say: "Do not repair what is not broken." <br><br>  Many of these principles may be familiar to you if you have previously dealt with <a href="http://microformats.org/" title="Off site">microformats</a> .  In the HTML5 environment, the same pragmatic approach is adopted without too much exalting the theory. <br><br>  This philosophy is formulated in principle about the ‚ÄúOrder of the importance of the components,‚Äù which says: ‚ÄúIn resolving any conflict, you need to think first of all about users, then about coders, then about implementers, then about the authors of specifications, then about theoretical purity and correctness "". <br><br>  Ian Hickson many times drew attention to the fact that browser developers ("implementers") can greatly influence what goes into HTML5, and what does not.  If a browser refuses to include support for a specific feature, it makes no sense to add it to the specification, otherwise it will simply not be related to reality.  In this regard, according to the <i>order of importance of the components</i> , we, web designers, have even more influence.  If we consider part of the specification unnecessary or incorrect and will not use it, it will also cease to be related to reality and will require revision. <br><br><h4>  Without extremes </h4><br>  Developing HTML5 involves constant internal tension and contradiction.  On the one hand, the specification must be sufficiently functional and powerful to become a reliable platform for creating web applications.  On the other hand, HTML5 should be able to maintain the already existing content of the network, even if there is a complete mess in the code there by the current.  If the specification deviates too much in one direction, the fate of XHTML2 awaits it.  If to another, the &lt;font&gt; tag and the tables as a means of marking will again become the cornerstone, because with their help, in the end, a huge number of existing web pages have been built. <br><br>  Because it is so important to adhere to a clear and balanced balance of things that requires a pragmatic and cold-blooded approach. <br><br><h4>  Error processing </h4><br>  The HTML5 specification does not just tell browsers how to display the standards-compliant layout ‚Äî for the first time in the history of this language, it also defines the ways in which they should work with a bad layout. <br><br>  So far, the browser developers themselves have decided how they will handle the errors.  In most cases, they simply followed the path followed by the most popular browser, which is largely a waste of time.  Instead of adding support for new features, they copied their competitors' approaches to processing incorrect code. <br><br>  The decision to introduce standards for this procedure in HTML5 is very ambitious.  Even if the set of tags and attributes in this version was no different from the fact that in HTML 4.01, the development of a single set of error handling rules by the 2012th year would have been like Sisyphean work. <br><br>  These rules, however, will be of little interest to web designers (after all, we all write valid, well-structured code, right?), But they are extremely important for browser developers.  While all past specifications were written only for coders, HTML5 is written for coders and implementers.  Keep this in mind if you decide to familiarize yourself with it directly - this explains why it is so dimensionlessly large and includes so many details and nuances that it is more like the notes of some trainspotter who is interested in recounting the contents of the personal collection of brands during a simultaneous game in chess with three opponents. <br><br><h4>  Spit it out, Doc (tayp) </h4><br>  <i>A doctype</i> (doctype, Document Type Declaration) is the traditional way to specify the type of markup language that is used on this page. <br><br>  This is what the doctype for HTML 4.01 looks like: <br><br><pre> <code class="hljs xml"><code class="html"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3c.org/TR/html4/strict.dtd"&gt;</span></span></code></code> </pre><br><br>  So for XHTML 1.0: <br><br><pre> <code class="hljs xml"><code class="html"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict //EN" "http://www.w3c.org/TR/xthml1/DTD/xhtml1-strict.dtd"&gt;</span></span></code></code> </pre><br><br>  It is completely unreadable for a person, but, whatever one may say, such a way is simply to say ‚ÄúThis page is written in HTML 4.01‚Äù or ‚ÄúThis page is written in XHTML 1.0‚Äù in its own way. <br><br>  We can assume that for HTML5 there should be something like that with the number five stuck somewhere.  Oddly enough, no: <br><br><pre> <code class="hljs xml"><code class="html"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span></code></code> </pre><br><br>  Finally it will be possible to learn by heart. <br><br>  But, damn, how is that?  There is no version number indicated, so how do we denote subsequent HTML incarnations?  When I first saw this new kind of doctype, I thought, ‚ÄúWhat the hell, they really want to say that this is the final version of the markup language, after which nothing will ever be necessary?‚Äù <br><br>  In fact, the idea is simple and very pragmatic.  The goal of HTML5 is to support existing HTML 4.01 and XHTML 1.0 pages, and this doctype will suffice.  New versions of HTML, in turn, will have to support HTML5, which is why it is completely meaningless to include the serial number in it constantly. <br><br>  In general, the doctypes themselves are not so important.  Let's say you wrote a page with a doctype from HTML 4.01, and then you took and added elements from another specification - let it be HTML 3.2, let HTML5, not the essence.  The browser still does not go anywhere and will process them as best they can.  Browsers support elements and features, not doctypes. <br><br>  The latter were designed primarily for validators, not for browsers.  The only case when they pay attention to the doctype is when you need to decide which rendering method to use - internal individual or consistent with the standards. <br><br>  So the only purpose of the doctype for HTML5 is to make sure that the browser will process the code following it, following the standard.  But for validation, its presence or absence does not matter. <br><br><h4>  There is no need to complicate </h4><br>  HTML5 has simplified not only the doctype. <br><br>  If you want to mark the encoding for your page, the best way to do this is to make sure that the server gives the correct value to the Content-Type.  To be completely sure, you can use the &lt;meta&gt; tag.  So it was before: <br><br><pre> <code class="hljs xml"><code class="html"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">http-equiv</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Content-Type"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/html; charset=UTF-8"</span></span></span><span class="hljs-tag">&gt;</span></span></code></code> </pre><br><br>  So this is in HTML5: <br><br><pre> <code class="hljs xml"><code class="html"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">charset</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"UTF-8"</span></span></span><span class="hljs-tag">&gt;</span></span></code></code> </pre><br><br>  As in the case with the doctype, there is nothing superfluous here - just what will be enough for the browser to understand what it is about. <br><br>  The &lt;script&gt; tag can also be allowed to lose weight.  Often, the type parameter is added to it with the value <i>text / javascript</i> : <br><br><pre> <code class="hljs xml"><code class="html"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code></code> </pre><br><br>  Browsers do not need it.  They already understand that the code is written in JavaScript - the most popular scripting language on the web (yes, to hide: the <i>only</i> scripting language): <br><br><pre> <code class="hljs xml"><code class="html"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code></code> </pre><br><br>  Similarly, there is no point in the type parameter with a <i>text / css</i> value when you attach a style sheet.  You can simply write: <br><br><pre> <code class="hljs xml"><code class="html"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"stylesheet"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file.css"</span></span></span><span class="hljs-tag">&gt;</span></span></code></code> </pre><br><br><h4>  Syntax: do as you used to </h4><br>  Some programming languages, such as Python, are very demanding on the design of the code: even the use of spaces in certain situations is necessary to comply with the rules.  Other languages, say JavaScript, do not pay attention to formatting - the same beating of the beginning of a line with spaces will not affect the code in any way. <br><br>  If you want to kindle a fierce holivar and thus organize a fun evening program for yourself, fill the room with programmers and say the words ‚Äúare spaces in the code‚Äù.  Do not forget popcorn. <br><br>  This question lies at the root of a deep philosophical dilemma: should the language be forced to follow a certain style of code design, or can the coders themselves be allowed to decide how they write it? <br><br>  In the markup for web pages, spaces and indents are not significant.  You can add each new element from a new line, do tabbing, insert empty lines - browsers and validators do not care.  However, many other liberties are not allowed everywhere. <br><br>  Before XHTML 1.0, it didn‚Äôt matter if you wrote the names of tags in upper or lower case.  It didn‚Äôt matter whether the quotes were parameter values ‚Äã‚Äãor not.  For many elements it didn‚Äôt even matter whether you added a closing tag or not. <br><br>  XHTML 1.0 follows XML syntax: tags are always lowercase, parameter values ‚Äã‚Äãare only in quotes, all container elements are necessarily closed.  And singles too - there should be a slash before the closing bracket (&lt;br&gt; ‚Üí &lt;br /&gt;). <br><br>  In HTML5, you decide for yourself: upper case is lower case, quotes are without quotes, closed or not.  As you like best. <br><br>  I have been using the XHTML 1.0 doctype for many years, and I like the fact that it requires you to follow clear rules to get an organized and valid code.  Now, using HTML5, I can continue to do as I want and used to. <br><br>  I understand why many people do not like this frivolity of HTML5.  Some people think that it throws us back in the times of the bad practices of the sloppy code, and moreover, they think that HTML5 encourages this style of markup.  I do not think so, but I see a cause for concern.  It is as if a programming language with syntactically important spaces between lines suddenly became less demanding. <br><br>  Personally, I calmly relate to such freedom of choice in HTML5, as I have already got used to follow the style of the code I am writing on my own.  It would be great, however, to have for this language such a tool, which in the programming world is called ‚Äúlint-tool‚Äù, a program that analyzes markup and indicates common and potentially ‚Äúdangerous‚Äù code design practices, as well as inconsistencies in the style of writing it. .  This is somewhat different from the validator, which the code will check, starting only from the doctype.  The first who will be able to develop a service that combines both, will definitely deserve the honor and respect of the global community of web designers. <br><br><h4>  We don't say that here. </h4><br>  In previous versions of HTML, as soon as a certain element or parameter was excluded from the specification, it went through a ‚Äúwithdrawal‚Äù process.  Web designers were advised to stop using the <i>seized</i> items, not to send them postcards on the websites and not to mention them at all in a decent company. <br><br>  In HTML5, there are no elements or parameters that have been <i>removed</i> , only <i>obsolete</i> instead. <br><br>  No, this is not a politically correct version of the name for the same concept - there is an important difference between a <i>withdrawn</i> and an <i>obsolete one</i> in this case. <br><br>  Since HTML5 has set itself the task of being backward compatible with previous versions, the specification must recognize previously used elements, even if HTML5 no longer includes them.  This leads to a somewhat ambiguous situation, when the specification simultaneously says ‚Äúcoders, do not use these elements‚Äù and ‚Äúbrowsers, here‚Äôs how these elements need to be rendered ...‚Äù.  If any item were <i>removed</i> , it would not be mentioned in the specification at all.  But since it is simply <i>deprecated</i> , it is included for browsers. <br><br>  If you just do not develop your own browser, for you there is no difference between the <i>withdrawn</i> and <i>obsolete</i> elements - you just do not use them and do not invite to visit. <br><br>  But if you still persist in applying them, your page in terms of standards compliance will be <i>inconsistent</i> .  Browsers will display it without problems, but knowledgeable people will not approve this practice. <br><br><h5>  Separation will be without sorrow </h5><br>  Recognized as obsolete tags: <i>frame</i> , <i>frameset</i> and <i>noframes</i> .  They will not be missed. <br><br>  The <i>acronym</i> tag is <i>obsolete</i> , which will finally put an end to the holivar and controversies that have lasted for years.  Do not mourn him, just use the <i>abbr</i> tag instead.  And yes, I know the difference between abbreviation and acronym: acronyms are abbreviations that are spelled out as a word, and not by letter (for example, NATO).  Not every abbreviation is an acronym, but every acronym is an abbreviation, so one tag is enough. <br><br>  The <i>font</i> , <i>big,</i> and <i>center</i> elements are also outdated, and, in fact, it happened a long time ago - even with the advent of CSS, where similar effects can be assigned faster and easier.  For the same reasons, there are no more <i>bgcolor</i> , <i>cellspasing</i> , <i>cellpadding</i> and <i>valign</i> parameters with us.  Use CSS instead. <br><br>  Not all, however, of the design elements were written into obsolete.  Some were sent to retraining courses and got a second chance. <br><br><h4>  Substitution of concepts </h4><br>  The <i>big</i> element is obsolete, but <i>small</i> is not.  Such inconsistency is justified by the fact that the value of the latter has been revised.  It is no longer a physical ‚Äúmake the text smaller‚Äù, but a semantic ‚Äúsmall print‚Äù.  Well, you understand - the terms of use, footnotes for "stars" and so on. <br><br>  It is clear that in 9 cases out of 10 this ‚Äúsmall print‚Äù will be really small;  the point is that the role of the element is now more semantic than the design. <br><br>  Element <i>b</i> used to mean simply ‚Äúbold text‚Äù.  Now it is ‚Äúa text that is stylistically distinguished from the mainstream, but does not carry additional semantic significance.‚Äù  When semantic significance is still present, it is more likely that <i>strong</i> will do. <br><br>  Also, the element <i>i</i> now does not mean "italic".  This is ‚Äúspoken by another intonation or with a different mood.‚Äù  Again, without much meaning or emphasis.  To emphasize significance, use the <i>em</i> element. <br><br>  These changes may sound like just a play on words.  And there is.  But behind this there is a specific task - to ensure the independence of HTML5 from the devices on which it is processed.  When you say ‚Äúbold‚Äù or ‚Äúitalics,‚Äù these concepts only make sense visually ‚Äî when text is displayed on screen or paper.  But it is also necessary to think about devices that display information in a non-visual format, for example, intended to be read from the screen to help blind people.  Plus, the described changes in the definitions encourage us to better understand and apply the rules of semantics, and not just visual design. <br><br><h5>  ... end of quotation </h5><br>  The value of the cite element was also slightly changed.  If earlier it meant ‚Äúlink to source‚Äù, now it is ‚Äúsource header‚Äù.  Very often, when quoting a source, there will be just the title of a book, a film or anything that we refer to.  However, it can also be the name of a person.  In HTML5, however, using personal names inside the cite element is contrary to the specification. <br><br>  This is explained as follows: browsers make the contents of the <i>&lt;cite&gt; tag</i> italic.  Work titles are usually in italics.  Names of people are not italicized.  Therefore, the cite element should not be used to refer to a specific person. <br><br>  In my opinion, this is simply wrong.  I understand that HTML5 should pay attention to the features of the browsers, but in this case it is like a horse driving a jockey. <br><br>  Fortunately, no validator will be able to determine what is inside the <i>&lt;cite&gt; tag</i> , so nothing prevents web designers from being guided by common sense here and putting there what is considered necessary. <br><br><h5>  &lt;a&gt; on steroids </h5><br>  While all previous rethinking of the meaning of elements is based solely on the substitution of concepts and the play on words, there is one element that has received really noticeable changes. <br><br>  Without a doubt, the a element is the most important in all HTML.  It is he who turns the text into hypertext and makes possible the existence of a world wide web as such. <br><br>  Before that, it was always just a string element.  That is, if you want to link the heading and the next paragraph with the text at the same time, you will have to use a twice. <br><br><pre> &lt;h2&gt; &lt;a href="/about"&gt; About Me &lt;/a&gt; &lt;/ h2&gt;
 &lt;p&gt; &lt;a href="/about"&gt; Find Out What I Live &lt;/a&gt; &lt;/ p&gt;
</pre><br>  In HTML5, these multiple elements can be wrapped into one &lt;a&gt; tag: <br><br><pre> &lt;a href="/about"&gt;
	 &lt;h2&gt; About Me &lt;/ h2&gt;
	 &lt;p&gt; Find out what I live &lt;/ p&gt;
 &lt;/a&gt;
</pre><br>  The only restriction: you can not push inside <i>&lt;a&gt;</i> another one <i>&lt;a&gt;</i> . <br><br>  In fact, of course, this could have been done before, and browsers supported this practice, but until recently it was not legalized.  If you think about it, it looks, however, somewhat strange - it is not browsers that implement the capabilities of the new specification, but the specification documents the capabilities of the browsers. <br><br><h4>  New toys: API for JavaScript </h4><br>  If you need style documentation, you go and read the specification for CSS.  If you need markup documentation, you take the HTML specification.  But where to go if you need to learn about <i>js js api</i> such as <i>document.write</i> , <i>innerHTML</i> and <i>window.history</i> ?  The JavaScript specification is dedicated to programming, you will not find any of the browser APIs there. <br><br>  So far, browsers have developed their own JS APIs, sometimes looking over their shoulders to see how competitors are doing there.  HTML5 will finally document these APIs and set a common standard. <br><br>  It may seem strange that the specification of the markup language will include documentation on JavaScript, but do not forget that HTML5 started with the project Web Apps 1.0, and JS is an integral component of web applications. <br><br>  Entire sections of the specification are devoted to the new API, designed to develop these.  <i>UndoManager</i> allows you to monitor the sequence of changes in the document.  There is a section affecting working with web applications offline, using <i>cache manifest</i> .  <i>Drag-n-Drop is</i> also described in detail. <br><br>  As always, if there are already existing implementations somewhere, the specification relies on them rather than reinventing the bicycle.  For example, the API for <i>drag-n-drop</i> in Internet Explorer has existed for a long time and served as the basis for what is included in HTML5.  It is worth noting, however, that the Microsoft APIs, to put it mildly, are quite problematic, and sometimes reinventing a bicycle can be justified, especially if all you have is a bicycle with square wheels, no saddle and half a steering wheel. <br><br>  HTML5 APIs are very powerful things that open up great possibilities.  But they are not my path, I would prefer to leave this topic for more advanced developers who will tell about it better than me.  In addition, it is worthy of a separate book. <br><br>  In the meantime, we have lots of exciting things in HTML5 itself.  And the excitement about them begins with the next chapter. </div><p>Source: <a href="https://habr.com/ru/post/103575/">https://habr.com/ru/post/103575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../103556/index.html">ViewSonic ViewPads Details</a></li>
<li><a href="../103558/index.html">Dynamic calls: method comparison</a></li>
<li><a href="../103565/index.html">Chumby Hacker Board</a></li>
<li><a href="../103572/index.html">How to catch the "flow", and how to make it not break</a></li>
<li><a href="../103573/index.html">Debian GNU / Linux 5.0.6 released</a></li>
<li><a href="../103576/index.html">The Japanese introduced advanced Tamagotchi</a></li>
<li><a href="../103577/index.html">Wolframalpha + Wikipedia = Galois / Wiki</a></li>
<li><a href="../103578/index.html">Kaspersky still hangs when updating</a></li>
<li><a href="../103580/index.html">In the US, put the "Nigerian" spammer for 12 years</a></li>
<li><a href="../103582/index.html">Creating QuickAction Conversations in Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>