<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ECMAScript 6 Promises</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√© already met articles about the wonderful technology Promises, which in the future will become part of the ECMAScript 6 standard, however, the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ECMAScript 6 Promises</h1><div class="post__text post__text-html js-mediator-article">  On Habr√© already met articles about the wonderful technology Promises, which in the future will become part of the ECMAScript 6 standard, however, these articles did not contain a detailed description of why they are so useful and what are their advantages.  In order to fill this gap, I decided to write this article. <a name="habracut"></a><br><br>  <b>Attention!</b>  This article is not an exhaustive guide.  This is rather a PR of good and useful technology, luring, showing positive sides.  The article is a compilation of several other articles, links below. <br><br><h1>  So what is a Promise? </h1><br><ul><li>  Promise is an object used as a stub for the result of a certain delayed (and possibly asynchronous) calculation. </li><li>  A way to write sequentially / concurrently running asynchronous code as synchronous </li><li>  Part of ECMAScript 6 standard </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Important basics </h1><br><ul><li>  Promise Constructor is the implementation of the <a href="https://blog.domenic.me/the-revealing-constructor-pattern">Revealing Constructor Pattern pattern</a> </li><li>  "Static" methods </li><li>  Promise.resolve (val) and Promise.reject (val) </li><li>  Promise.all and Promise.race </li><li>  The concept of ‚ÄúThenable‚Äù object </li><li>  In a nutshell, it's an object that has methods .then () and .catch () </li></ul><br><br><h1>  Promise States </h1><br><ol><li>  <b>Fulfilled</b> - the calculation was successful </li><li>  <b>Rejected</b> - error in the calculation (any) </li><li>  <b>Pending</b> - the calculation has not yet completed (not fulfilled and not rejected) </li><li>  <b>Settled</b> - the calculation is complete (no matter how) </li></ol><br><br><h1>  Examples </h1><br>  So, take a piece of synchronous code <br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">'a'</span></span>; a = a + <span class="hljs-string"><span class="hljs-string">'b'</span></span>; a = a + <span class="hljs-string"><span class="hljs-string">'c'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br>  And let's make it look like a Promise from the outside: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">'a'</span></span>; a = a + <span class="hljs-string"><span class="hljs-string">'b'</span></span>; a = a + <span class="hljs-string"><span class="hljs-string">'c'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(a); }</code> </pre><br>  The next step is to divide each step of the calculation: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'a'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-string"><span class="hljs-string">'b'</span></span>; }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-string"><span class="hljs-string">'c'</span></span>; }); }</code> </pre><br>  Now each step can be made asynchronous, with the entire execution still being consistent. <br>  Let's go ahead, replace one of the steps with ‚Äúas if an asynchronous function returning Promise‚Äù: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getB</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(a + <span class="hljs-string"><span class="hljs-string">'b'</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'a'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getB(a); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-string"><span class="hljs-string">'c'</span></span>; }); }</code> </pre><br>  The built-in functionality allows returning to then (cb ()) either an error (throw new Error ()) or a value (return a + 'c';) or the next Promise. <br><br><h2>  Parallelism </h2><br>  Imagine that you first need to perform asynchronous action 1, then in parallel 2 and 3, and then 4. <br><pre> <code class="javascript hljs">asyncAction1() .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res1</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([async2(res1), async3(res1)]); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// an array of values var res2 = arr[0], res3 = arr[1]; return asyncAction4(res2, res3); }) .then(‚Ä¶);</span></span></code> </pre><br><br><h2>  Error processing </h2><br>  The most wonderful thing about Promises is error handling.  It does not matter at what stage and in what depth of nesting an error occurred, whether it is a reject or just an exception thrown, all this can be caught and processed, or it can be passed further. <br><pre> <code class="javascript hljs">asyncAction() .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rejection</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,   -   if (rejection.code == 'foo') return 'foo'; //  ,    throw rejection; }) .then(‚Ä¶) .then(‚Ä¶) .catch(‚Ä¶);</span></span></code> </pre><br>  Here we need to make a remark that if we set <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(...), p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(...) p3 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([p1, p2]); p3.then(...).catch(...);</code> </pre><br>  Catch will catch everything that went wrong (and it doesn't matter what or how) in p1, p2, p3 and any nested calls, which is wildly convenient.  Reverse - if catch () is not present, the error will be silently swallowed.  However, Q-type libraries, as a rule, have the ability to specify an error handler for uncaught errors, where they can be displayed in the console or something else can be done. <br><br><h2>  A word about anti-patterns </h2><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anAsyncCall</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise = doSomethingAsync(); promise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ somethingComplicated(); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise; }</code> </pre><br>  With a flick of the wrist, we lost the second Promise.  The fact is that each .then () or .catch () call creates a new Promise, so if you create a new one and return the old one, the new one will hang somewhere in the air and no one will know what the result of the calculation is.  How to fight - just return the new Promise: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise.then(...);</code> </pre><br><br><h1>  Useful nishtyaki </h1><br><br><h2>  Execution delay </h2><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delay</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ms</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(resolve, ms); } };</code> </pre><br>  Usage example <br><pre> <code class="javascript hljs">delay(<span class="hljs-number"><span class="hljs-number">5000</span></span>).then(‚Ä¶);</code> </pre><br><br><h2>  Simplest timeout </h2><br>  Since the Promise can only be settled once (the rest is ignored), you can write something like <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promise, ms</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ promise.then(resolve); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Timeout'</span></span>)); }, ms); }); } timeout(asyncAction(), <span class="hljs-number"><span class="hljs-number">5000</span></span>).then(‚Ä¶).catch(‚Ä¶);</code> </pre><br>  Who first got up - that and sneakers. <br><br><h2>  Slightly improved timeout </h2><br>  A slightly more obvious example of a timeout is through the "static" function Promise.race (). <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([ asynchronousAction(), delay(<span class="hljs-number"><span class="hljs-number">5000</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Timed out'</span></span>); }) ]) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ ... }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ ... });</code> </pre><br><br><h1>  Important note about asynchrony </h1><br><ol><li>  The library controls the execution process, respectively, it manages how the result is delivered - synchronously or asynchronously. </li><li>  At the same time, the Promises / A + specification requires that the last mode is always used - asynchronous </li><li>  Thus, we can always rely on the immediate execution of promise.then (). Catch () code, etc., and not care that some of their callbacks will eat up all the CPU time (with reservations, of course) </li></ol><br><br><h1>  Why Promises Better Callbacks </h1><br><ul><li>  They are part of the standard - smart people thought and developed everything for our convenience. </li><li>  <i>"Practically"</i> do not affect performance ( <a href="http://thanpol.as/javascript/promises-a-performance-hits-you-should-be-aware-of">http://thanpol.as/javascript/promises-a-performance-hits-you-should-be-aware-of</a> ) </li><li>  Try to handle a non-trivial execution flow on callbacks, preferably with error handling, unless you write your implementation of Promises, the code will most likely be impossible to read and understand </li><li>  All Promises / A + compatible libraries can accept each other objects (Angular works great with Q / Native Promise / RSVP objects, etc.) </li><li>  And Promise is better than Deferred, because the latter is two concepts in one, which is certainly bad, and besides this, the Revealing Constructor pattern almost guarantees that Promise is settled only within the framework of this constructor (well, or you are angry with yourself Pinocchio) </li></ul><br><br><h1>  disadvantages </h1><br><ol><li>  Not suitable for recurring events (true, Promises were not written in order) </li><li>  Not suitable for streams (likewise) </li><li>  The current implementation in browsers does not allow monitoring progress (they are also going to be included in the standard) </li></ol><br><br><h1>  JQuery note </h1><br>  The implementation of ‚ÄúThennable‚Äù in jQuery is slightly different from the standard one - there is exactly one argument in the callback, in jQuery there are more arguments in jQuery, which does not prevent us from using the object obtained from jQuery in the native implementation.  As a rule, more than the first argument, nothing from jQuery is needed.  Plus there is a design: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsPromise = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve($.ajax(<span class="hljs-string"><span class="hljs-string">'/whatever.json'</span></span>));</code> </pre><br><br><h1>  Read links </h1><br><ul><li>  <a href="http://www.html5rocks.com/en/tutorials/es6/promises">http://www.html5rocks.com/en/tutorials/es6/promises</a> </li><li>  <a href="">https://github.com/tildeio/rsvp.js</a> </li><li>  <a href="https://github.com/jakearchibald/es6-promise">https://github.com/jakearchibald/es6-promise</a> </li><li>  <a href="http://www.2ality.com/2014/10/es6-promises-api.html">http://www.2ality.com/2014/10/es6-promises-api.html</a> </li><li>  <a href="https://blog.domenic.me/the-revealing-constructor-pattern">https://blog.domenic.me/the-revealing-conctorctor-pattern</a> </li><li>  <a href="http://taoofcode.net/promise-anti-patterns">http://taoofcode.net/promise-anti-patterns</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/242767/">https://habr.com/ru/post/242767/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242753/index.html">Raspberry Pi - what can be done on the basis of ‚Äúraspberry‚Äù? Part 2</a></li>
<li><a href="../242757/index.html">Effective Navigation Simplification, Part 1: Information Architecture</a></li>
<li><a href="../242761/index.html">Gaming desktop ASUS ROG G20AJ review</a></li>
<li><a href="../242763/index.html">Headphones: a great overview from Marco Arment</a></li>
<li><a href="../242765/index.html">Why have cloud technologies become popular, what is innovation?</a></li>
<li><a href="../242771/index.html">What mobile apps can I give to an online store and a retail company in general? Figures in the studio ...!</a></li>
<li><a href="../242773/index.html">Real time ecommerce</a></li>
<li><a href="../242775/index.html">Watch November 12 and 13 live broadcast of the virtual event Connect (); for developers!</a></li>
<li><a href="../242779/index.html">New Raspberry Pi model introduced: Model A + priced at $ 20</a></li>
<li><a href="../242781/index.html">H.265 / HEVC. Intel Architecture Optimization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>