<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Black magic of metaprogramming: how macros work in Rust 1.15</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article we met with one of the most interesting features of the Rust language - procedural macros. 


 As promised, today I will talk abou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Black magic of metaprogramming: how macros work in Rust 1.15</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/55d/01f/76a/55d01f76a48d425792b64dbf23251d60.png" align="left">  In the <a href="https://habrahabr.ru/post/321564/">last article</a> we met with one of the most interesting features of the Rust language - procedural macros. </p><br><p>  As promised, today I will talk about how to write such macros on my own and what is their fundamental difference from the notorious preprocessor macros in C / C ++. </p><br><p>  But first, let's go through release 1.15 and talk about other innovations, since for many they were no less in demand. </p><a name="habracut"></a><br><h3 id="chto-mozhno-pochitat">  What can you read? </h3><br><p>  Rust language develops very intensively.  Naturally, publishers do not have time and do not undertake to publish books, as they become obsolete even before the paint dries on the pages. </p><br><p>  Therefore, most of the current documentation is presented in electronic form.  The traditional source of information is the <a href="https://doc.rust-lang.org/book/">Book</a> , in which you can find most of the answers to the questions of beginners.  For very frequent questions there is <a href="https://www.rust-lang.org/en-US/faq.html">a FAQ section</a> . </p><br><p>  For those who already have programming experience in other languages, and generally adult enough to understand on their own, <a href="http://rust-lang.github.io/book/">another book</a> will do.  It is assumed that she gives better material and should replace the first book.  And for those who like to learn from examples, <a href="http://rustbyexample.com/">Rust by Example</a> will do. </p><br><p>  People familiar with C ++ may be interested in a book, or rather a <a href="https://locka99.gitbooks.io/a-guide-to-porting-c-to-rust">porting guide</a> , trying to provide material in comparison with C ++ and focusing on the differences of languages ‚Äã‚Äãand on what problems Rust solves better. </p><br><p>  If you are interested in the history of language development and the view from the other side of the barricades, I highly recommend the blogs <a href="https://aturon.github.io/blog/">Aaron Turon</a> and <a href="http://smallcultfollowing.com/babysteps/">Niko Matsakis</a> .  The guys write in a very lively language and talk about current problems of the language and how they are supposed to be solved.  Often from these blogs you will learn much more relevant information than from other sources. </p><br><p>  Finally, if you are not afraid of dragons and dark corners, you can take a look at <a href="https://doc.rust-lang.org/nomicon/">Rustonomicon</a> .  Only I warn you, after reading this book, you will not be able to look at Rust in the same way.  However, I was distracted ... </p><br><h1 id="novoe-v-rust-115">  New in Rust 1.15 </h1><br><p>  Since the release of 1.14 about 6 weeks have passed.  During this time, 1443 patches (not weak, right?) That fix bugs and add new features managed to enter the new release.  And just the other day, <a href="https://blog.rust-lang.org/2017/02/09/Rust-1.15.1.html">hotfix 1.15.1 appeared</a> , with minor but important fixes. </p><br><p>  For details, you can refer to <a href="https://blog.rust-lang.org/2017/02/02/Rust-1.15.html">the announcement page</a> or to the detailed <a href="">description of the changes (changelog)</a> .  Here we concentrate on the most noticeable changes. </p><br><h2 id="cargo-uzhe-vzroslyy">  Cargo is already an adult </h2><br><p>  The compiler build system and the standard Rust library were <a href="https://github.com/rust-lang/rust/pull/37817">rewritten</a> to Rust itself using Cargo, the standard package manager and build system adopted in the Rust ecosystem. </p><br><p>  From now on, Cargo is the default build system.  It was a long process, but it finally bore fruit.  The authors claim that the new build system has been used since last December in the master repository branch and so far everything is going well. </p><br><p> Now the file with the name <code>build.rs</code> , lying on the same level with <code>Cargo.toml</code> <a href="http://doc.crates.io/build-script.html">will be interpreted</a> as a build script. </p><br><p>  Already even <del>  <a href="https://github.com/rust-lang/rust/pull/39431">wound up</a> </del>  <a href="https://github.com/rust-lang/rust/pull/39431">already</a> pull request to remove all makefiles;  integration is scheduled for release 1.17. </p><br><p>  All this prepares the ground for the direct use of packages from <a href="https://crates.io/">crates.io</a> for building a compiler, as in any other project.  It is also a good demonstration of the possibilities of Cargo. </p><br><h2 id="novye-arhitektury">  New architectures </h2><br><p>  Rasta has <code>i686-unknown-openbsd</code> <a href="https://forge.rust-lang.org/platform-support.html">Tier 3</a> support for <code>i686-unknown-openbsd</code> , <code>MSP430</code> , and <code>ARMv5TE</code> .  Recently it became known that <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-November/107177.html">support for the</a> AVR microcontroller architecture <a href="http://lists.llvm.org/pipermail/llvm-dev/2016-November/107177.html">appears</a> in the LLVM 4.0 release.  Rust developers are aware of this and already <del>  <a href="https://github.com/rust-lang/rust/issues/37609">getting ready</a> </del>  <a href="https://github.com/rust-lang/rust/issues/37609">Almost everything was done to integrate the</a> new version of LLVM and the new architecture. </p><br><p>  Moreover, there are already projects using <a href="https://github.com/rust-embedded">Rust in an embedded</a> environment.  The compiler developers are <a href="https://internals.rust-lang.org/t/roadmap-2017-needs-of-no-std-embedded-developers/4096">polling the community</a> to find out the needs of this still small but important group of users. </p><br><h2 id="bystree-vyshe-silnee">  Faster!  Above!  Stronger! </h2><br><p>  The compiler has become <a href="">faster</a> .  And recently, it was also <a href="https://internals.rust-lang.org/t/incremental-compilation-beta/4721">announced</a> that the incremental compilation system has entered a beta testing phase.  On my projects, the compile time after minor changes decreased from ~ 20 to ~ 4 seconds, although the final linking still takes a decent amount of time.  So far, incremental compilation works only in nightly builds and is highly dependent on the nature of the dependencies, but progress is good. </p><br><p>  The <code>slice::sort()</code> algorithm was rewritten and became <a href="https://github.com/rust-lang/rust/pull/38192">much, much, much faster</a> .  This is now a hybrid sort, implemented under the influence of <a href="https://en.wikipedia.org/wiki/Timsort">Timsort</a> .  Previously, normal merge sorting was used. </p><br><p>  In C ++, we can define overlapping template specialization for some type, but for now we can‚Äôt impose restrictions on what types can be used to specialize this template.  Work in this direction is underway, but so far everything is very difficult. </p><br><p>  Stable Rust has always been able to set type <a href="http://rustbyexample.com/generics/bounds.html">constraints</a> , but more recently it has been possible to define, or rather block, a generalized implementation with a more specific one, if it sets more stringent constraints.  This allows you to optimize the code for special cases without breaking the generic interface. </p><br><p>  In particular, in release 1.15, <a href="https://github.com/rust-lang/rust/pull/38182">a</a> specialized implementation of the <code>extend()</code> method for <code>Vec&lt;T&gt;</code> was <a href="https://github.com/rust-lang/rust/pull/38182">added</a> , where <code>T: Copy</code> , which uses simple linear copying of memory regions, which led to significant acceleration. </p><br><p>  In addition, implementations of the <code>chars().count()</code> , <code>chars().last()</code> , and <code>char_indices().last()</code> methods were accelerated. </p><br><h2 id="podderzhka-ide">  IDE support </h2><br><p>  This is not yet in stable Rust, but nevertheless the news is too significant to keep silent about it.  The fact is that recently the developers of the Rust Language Server have <a href="http://www.jonathanturner.org/2017/01/rls-alpha-release.html">announced the release of an alpha version of</a> their offspring. </p><br><p>  <a href="http://langserver.org/">Language Server Protocol</a> is a standard protocol that allows editors and development environments to communicate in the same language as compilers.  It abstracts such operations as auto-completion of input, transition to definition, refactoring, work with buffers, etc. </p><br><p>  This means that any editor or IDE that supports LSP will automatically receive support for all LSP-compatible languages. </p><br><p>  Already, you can try the basic features on compatible editors, only the authors strongly advise you to be careful about your data, because the code is still quite raw. </p><br><h2 id="makrosy-v-rust">  Macros in Rust </h2><br><p>  Let's return to our sheep. </p><br><p>  From the very beginning, programmers wanted to write less and get more.  At different times, different things were understood by this, but conditionally, there are two methods to reduce the code: </p><br><ul><li>  Selection of logically complete pieces of code for reuse </li><li>  Selection of dependent code fragments that mean nothing outside their context </li></ul><br><p>  The first principle is more consistent with the traditional decomposition of programs: the separation of code into functions, methods, classes, etc. </p><br><p>  Macros, inclusions and other preprocessing can be attributed to the second.  There are three mechanisms for this in the Rust language: </p><br><ul><li>  Common Macros </li><li>  Procedural macros </li><li>  Compiler plugins </li></ul><br><p>  Ordinary macros (in the documentation <em>macro for example</em> ) are used when you want to avoid repetition of the same code, but allocating it to a function is irrational or impossible.  Macros <code>vec!</code>  or <code>println!</code>  are examples of such macros.  They are set in a declarative way.  They work on the principle of matching and substitution on the model.  The implementation is based on the <a href="https://www.cs.indiana.edu/ftp/techreports/TR206.pdf">work of 1986</a> , from which they received their full name. </p><br><p>  Procedural macros are the first attempt to stabilize the compiler plugin interface.  Unlike ordinary declarative macros, procedural macros are a fragment of Rust code that is executed during the compilation of a program and the result of which is a set of tokens.  The compiler will interpret these tokens as the result of macro substitution. </p><br><p>  At the moment, the compiler only provides for the use of procedural macros to support custom <code>derive</code> attributes.  In the future, the number of scenarios will be expanded. </p><br><p>  <a href="https://doc.rust-lang.org/book/compiler-plugins.html">Compiler plugins</a> are the most powerful, but complex and unstable (in the sense of API) tool that is available only in nightly compiler builds.  The documentation provides an example of a Roman numerals support plugin as numeric literals. </p><br><h3 id="primer-makrosa">  Macro example </h3><br><p>  Because macros are not limited to the lexical context of a function, they can generate definitions for higher-level entities as well.  For example, a macro can define a whole <strong><code>impl</code></strong> block, or a method together with a name, a list of parameters and the type of the return value. </p><br><p>  Macro inserts are possible in almost all places of the module hierarchy: </p><br><ul><li>  inside expressions </li><li>  in <strong><code>trait</code></strong> and <strong><code>impl</code></strong> blocks </li><li>  in the bodies of functions and methods </li><li>  in the body of the module </li></ul><br><p>  Macros are often used in libraries when it is necessary to define structures of the same type, for example, the <strong><code>impl</code></strong> series for standard data types. </p><br><p>  For example, in the standard Rust library, macros <a href="">are used</a> to compactly declare the implementation of the <code>PartialEq</code> type for various combinations of slices, arrays and vectors: </p><br><div class="spoiler">  <b class="spoiler_title">Careful brain!</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> __impl_slice_eq1 { ($Lhs: ty, $Rhs: ty) =&gt; { __impl_slice_eq1! { $Lhs, $Rhs, <span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span> } }; ($Lhs: ty, $Rhs: ty, $Bound: ident) =&gt; { <span class="hljs-meta"><span class="hljs-meta">#[stable(feature = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rust1"</span></span></span><span class="hljs-meta">, since = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1.0.0"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>, A: $Bound, B&gt; <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>&lt;$Rhs&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> $Lhs <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> A: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>&lt;B&gt; { <span class="hljs-meta"><span class="hljs-meta">#[inline]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: &amp;$Rhs) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[..] == other[..] } <span class="hljs-meta"><span class="hljs-meta">#[inline]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ne</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: &amp;$Rhs) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[..] != other[..] } } } } __impl_slice_eq1! { <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;A&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;B&gt; } __impl_slice_eq1! { <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;A&gt;, &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> [B] } __impl_slice_eq1! { <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;A&gt;, &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [B] } __impl_slice_eq1! { Cow&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, [A]&gt;, &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> [B], <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span> } __impl_slice_eq1! { Cow&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, [A]&gt;, &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [B], <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span> } __impl_slice_eq1! { Cow&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, [A]&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;B&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span> }</code> </pre> </div></div><br><p>  We will consider a more illustrative example.  Namely, the <a href="">implementation of the</a> macro <code>vec!</code>  which acts as a constructor for <code>Vec</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> vec { <span class="hljs-comment"><span class="hljs-comment">//     : vec![0; 32] ( $elem:expr; $n:expr ) =&gt; ( $crate::vec::from_elem($elem, $n) ); //   : vec![1, 2, 3] ( $($x:expr),* ) =&gt; ( &lt;[_]&gt;::into_vec(box [$($x),*]) ); //    : vec![1, 2, 3, ] ( $($x:expr,)* ) =&gt; ( vec![$($x),*] ) }</span></span></code> </pre> <br><p>  A macro works like a <strong><code>match</code></strong> construct, but at compile time.  The input for it is a fragment of the program's syntax tree.  Each branch consists of a match pattern and a lookup expression, separated by <code>=&gt;</code> . </p><br><p>  The matching pattern resembles regular expressions with possible quantifiers <code>*</code> and <code>+</code> .  In addition to metavariables, the indicated types ( <em>designator</em> ) are indicated through a colon.  For example, the type <code>expr</code> corresponds to the expression, <code>ident</code> to any identifier, and <code>ty</code> type identifier.  More information about the syntax of macros is written in the <a href="https://doc.rust-lang.org/reference.html">manual for macros</a> and <a href="https://doc.rust-lang.org/book/macros.html">documentation</a> , and in the <a href="https://locka99.gitbooks.io/a-guide-to-porting-c-to-rust/content/">porting guide</a> you can find the <a href="https://locka99.gitbooks.io/a-guide-to-porting-c-to-rust/content/features_of_rust/macros.html">actual analysis of the macro</a> <code>vec!</code>  with a description of each branch. </p><br><p>  Specifying types of metavariables allows you to more accurately determine the region of applicability of the macro, as well as to catch possible errors. </p><br><p>  Upon encountering the use of a macro in the code, the compiler will select the branch that is appropriate for the given case and replace the macro construct in the tree with the corresponding substitution expression.  If there is no suitable construction in the macro body, the compiler will generate a meaningful error message. </p><br><h3 id="chistota-i-poryadok">  Cleanliness and tidiness </h3><br><p>  The macro in Rust must be written to generate lexically correct code.  This means that not every character set can be a valid macro.  This avoids <a href="http://stackoverflow.com/questions/14041453/why-are-preprocessor-macros-evil-and-what-are-the-alternatives">many of the problems</a> associated with using the preprocessor in C / C ++. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SQUARE(a) a*a int x = SQUARE(my_list.pop_front()); int y = SQUARE(x++);</span></span></code> </pre> <br><p>  In a seemingly innocuous code fragment, instead of one element, we pulled out two, calculated not the result we expected, but also provoked an undefined behavior with the last line.  Three serious errors on two lines of code are a bit too much. </p><br><p>  Of course, the example is synthetic, but we all know perfectly well how a constant change of requirements and people in a team can confuse even once good code. </p><br><p>  The root of evil lies in the fact that the C / C ++ preprocessor operates at the text level, and the compiler has to parse the program already corrupted by the preprocessor. </p><br><p>  In contrast, macros in Rust are parsed and used by the compiler itself and work at the level of the program's syntax tree.  Therefore, the problems described above cannot arise in principle. </p><br><p>  Macros in Rust: </p><br><ul><li>  do not obscure variables </li><li>  do not violate the procedure of parsing conditions </li><li>  do not give hidden side effects </li><li>  do not lead to indefinite behavior </li></ul><br><p>  Such macros are called <a href="https://en.wikipedia.org/wiki/Hygienic_macro">hygienic</a> .  One consequence is that a macro cannot declare a variable visible outside of it. </p><br><p>  But within the macro, you can start variables that are guaranteed not to intersect with the variables above the code.  For example, the above macro <code>vec!</code>  can be rewritten using an intermediate variable.  For simplicity, consider only the main branch: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> vec { ( $($x:expr),* ) =&gt; { { <span class="hljs-comment"><span class="hljs-comment">//  - let mut result = Vec::new(); //     $x    $(result.push($x);)* //  result     result } }; }</span></span></code> </pre> <br><p>  So the code </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vector = <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p>  after macro substitution will be converted to </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vector = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); result.push(<span class="hljs-number"><span class="hljs-number">1</span></span>); result.push(<span class="hljs-number"><span class="hljs-number">2</span></span>); result.push(<span class="hljs-number"><span class="hljs-number">3</span></span>); result };</code> </pre> <br><h3 id="procedurnye-makrosy">  Procedural macros </h3><br><p>  When the capabilities of ordinary macros are not enough, procedural ones go into battle. </p><br><p>  As mentioned above, procedural macros are so called, because instead of a simple substitution, they can return a completely arbitrary set of tokens, which is the result of executing a certain procedure, or rather, a function.  We will study this function. </p><br><p>  As a guinea pig, let's take an implementation of the automatically output constructor <code>#[derive(new)]</code> from the <a href="https://github.com/nrc/derive-new">corresponding library</a> . </p><br><p>  From the user's point of view, the usage will look like this: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> derive_new; <span class="hljs-meta"><span class="hljs-meta">#[derive(new)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _ = Bar::new(<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>.to_owned()); }</code> </pre> <br><p>  That is, having defined the attribute <code>#[derive(new)]</code> we asked the compiler to self-infer ... but what exactly?  Where does the compiler understand exactly what method we expect to get?  Let's figure it out. </p><br><p>  To get started, let's look at the <a href="">source code of the</a> library, fortunately it is not so big: </p><br><div class="spoiler">  <b class="spoiler_title">Many beeches (75 lines)</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![crate_type = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"proc-macro"</span></span></span><span class="hljs-meta">]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> proc_macro; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> syn; <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> quote; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> proc_macro::TokenStream; <span class="hljs-meta"><span class="hljs-meta">#[proc_macro_derive(new)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derive</span></span></span></span>(input: TokenStream) -&gt; TokenStream { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> input: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = input.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ast = syn::parse_macro_input(&amp;input).expect(<span class="hljs-string"><span class="hljs-string">"Couldn't parse item"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = new_for_struct(ast); result.to_string().parse().expect(<span class="hljs-string"><span class="hljs-string">"couldn't parse string to tokens"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_for_struct</span></span></span></span>(ast: syn::MacroInput) -&gt; quote::Tokens { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = &amp;ast.ident; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (impl_generics, ty_generics, where_clause) = ast.generics.split_for_impl(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doc_comment = <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"Constructs a new `{}`."</span></span>, name); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> ast.body { syn::Body::Struct(syn::VariantData::Struct(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> fields)) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> args = fields.iter().map(|f| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f_name = &amp;f.ident; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ty = &amp;f.ty; quote!(#f_name: #ty) }); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inits = fields.iter().map(|f| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f_name = &amp;f.ident; quote!(#f_name: #f_name) }); quote! { <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> #impl_generics #name #ty_generics #where_clause { <span class="hljs-meta"><span class="hljs-meta">#[doc = #doc_comment]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(#(args),*) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { #name { #(inits),* } } } } }, syn::Body::Struct(syn::VariantData::Unit) =&gt; { quote! { <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> #impl_generics #name #ty_generics #where_clause { <span class="hljs-meta"><span class="hljs-meta">#[doc = #doc_comment]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { #name } } } }, syn::Body::Struct(syn::VariantData::Tuple(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> fields)) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (args, inits): (<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt;) = fields.iter().enumerate().map(|(i, f)| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f_name = syn::Ident::new(<span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"value{}"</span></span>, i)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ty = &amp;f.ty; (quote!(#f_name: #ty), f_name) }).unzip(); quote! { <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> #impl_generics #name #ty_generics #where_clause { <span class="hljs-meta"><span class="hljs-meta">#[doc = #doc_comment]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(#(args),*) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { #name(#(inits),*) } } } }, _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"#[derive(new)] can only be used with structs"</span></span>), } }</code> </pre> </div></div><br><p>  And now let's sort it out by bone and try to understand what it does. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![crate_type = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"proc-macro"</span></span></span><span class="hljs-meta">]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> proc_macro; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> syn; <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> quote; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> proc_macro::TokenStream;</code> </pre> <br><p>  In the first lines of the library, the special translation unit type <code>proc-macro</code> , which says that it will not be anyhow, but a plug-in for the compiler.  Then the necessary <code>proc_macro</code> and <code>syn</code> libraries are <code>proc_macro</code> with all the tools.  The first one sets the main types, the <a href="https://crates.io/crates/syn">second</a> one provides the means of parsing the Rust code into an <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">abstract syntax tree</a> (AST).  In turn, <a href="https://crates.io/crates/quote">the quote library</a> provides a very important <code>quote!</code>  which we will see in action a little later. </p><br><p>  Finally, the necessary type of <code>TokenStream</code> , as it appears in the function prototype. </p><br><p>  The following is the function itself, which acts as an entry point to the procedural macro: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[proc_macro_derive(new)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derive</span></span></span></span>(input: TokenStream) -&gt; TokenStream { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> input: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = input.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ast = syn::parse_macro_input(&amp;input).expect(<span class="hljs-string"><span class="hljs-string">"Couldn't parse item"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = new_for_struct(ast); result.to_string().parse().expect(<span class="hljs-string"><span class="hljs-string">"couldn't parse string to tokens"</span></span>) }</code> </pre> <br><p>  Pay attention to the <code>proc_macro_derive(new)</code> attribute, which tells the compiler that this function is responsible for <code>#[derive(new)]</code> . </p><br><p>  At the input, it receives a set of tokens from the compiler that make up the macro body.  At the output, the compiler expects to get another set of tokens that are the result of the macro.  Thus, the <code>derive()</code> function works as a kind of filter. </p><br><p>  The body of the function is very simple.  First we convert the input set of tokens to a string, and then parse the string as an abstract syntax tree.  The most interesting thing happens inside the function call <code>new_for_struct()</code> , which takes AST at the input, and gives the quoted tokens (more on that later).  Finally, the received tokens are converted back to a string (do not ask me why this is so), they are sent to <code>TokenStream</code> and are given as a result of the macro to the compiler. </p><br><p>  To be honest, I also do not understand why to shuffle the data back and forth through the lines and why it was impossible to immediately make a sane interface, but oh well.  Perhaps in the future the situation will change. </p><br><p>  Let's see what the <code>new_for_struct()</code> function <code>new_for_struct()</code> .  But first, we will look at the structures for which we may need to generate constructors. </p><br><p>  So, at the entrance we can submit: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//   #[derive(new)] struct Normal { x: i32, y: String, } //  tuple struct #[derive(new)] struct Tuple(i32, i32, i32); // - #[derive(new)] struct Empty;</span></span></code> </pre> <br><p>  It is clear that the syntax trees for all three options will be different.  And this needs to be considered when generating the <code>new()</code> method.  Actually, all that <code>new_for_struct()</code> does is look at the passed AST tree, determine with which option it is dealing with the given moment and generates the necessary substitution.  And if they don‚Äôt know what to say to her, she starts to panic. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_for_struct</span></span></span></span>(ast: syn::MacroInput) -&gt; quote::Tokens { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = &amp;ast.ident; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (impl_generics, ty_generics, where_clause) = ast.generics.split_for_impl(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doc_comment = <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"Constructs a new `{}`."</span></span>, name); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> ast.body { syn::Body::Struct(syn::VariantData::Struct(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> fields)) =&gt; { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }, syn::Body::Struct(syn::VariantData::Unit) =&gt; { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }, syn::Body::Struct(syn::VariantData::Tuple(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> fields)) =&gt; { <span class="hljs-comment"><span class="hljs-comment">/* tuple struct */</span></span> } _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"#[derive(new)] can only be used with structs"</span></span>), } }</code> </pre> <br><p>  Let's look at the code that generates the substitution for a regular structure.  Here, the code is already inconvenient to break up, so I will insert comments directly into the text: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//         : //        let args = fields.iter().map(|f| { let f_name = &amp;f.ident; let ty = &amp;f.ty; quote!(#f_name: #ty) }); //   ,  : let inits = fields.iter().map(|f| { let f_name = &amp;f.ident; quote!(#f_name: #f_name) }); // ,        : quote! { impl #impl_generics #name #ty_generics #where_clause { #[doc = #doc_comment] pub fn new(#(args),*) -&gt; Self { #name { #(inits),* } } } }</span></span></code> </pre> <br><p>  The whole trick here is in the <code>quote!</code> Macro <code>quote!</code>  which allows you to <em>quote</em> code snippets, substituting for itself a set of corresponding tokens.  Pay attention to metavariables beginning with a lattice.  They are inherited from the lexical context in which the quotation is located. </p><br><p>  If it is still not clear how it works, take a look at the result of applying the procedural macro to the <code>Normal</code> structure described above. </p><br><p>  The structure itself again: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(new)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Normal</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  The result of applying a procedural macro: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Constructs a new `Normal`. impl Normal { pub fn new(x: i32, y: String) -&gt; Self { Normal { x: x, y: y } } }</span></span></code> </pre> <br><p>  Suddenly, everything falls into place.  It turns out that we just personally generated the <strong><code>impl</code></strong> block for the structure, added the associated constructor function <code>new()</code> with the documentation (!), Two parameters <code>x</code> and <code>y</code> corresponding types and with the implementation that returns our structure, sequentially initializing its fields with values ‚Äã‚Äãfrom its parameters. </p><br><p>  Since Rust can understand from the context what the <code>x</code> and <code>y</code> correspond to before and after the colon, everything compiles successfully. </p><br><p>  As an exercise, I propose to disassemble the remaining two branches on your own. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  The potential for procedural macros is only to be discovered.  The examples indicated in the <a href="https://habrahabr.ru/post/321564/">last article</a> are only the tip of the iceberg and the most straightforward use case.  There are much more interesting projects, such as <a href="http://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/">a garbage collector project</a> implemented entirely by the lexical means of the Rust language. </p><br><p>  I hope that the article was useful to you.  And if, after reading it, you also want to play around with the Rust language, I will consider my task fully completed :) </p><br><p>  <em>The material was prepared jointly with Daria Schetinina.</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/321620/">https://habr.com/ru/post/321620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321604/index.html">Seminar "How much does the data center operation cost?", February 21, OST data center</a></li>
<li><a href="../321606/index.html">Home Assistant or another ‚Äúbrain‚Äù for a project like ‚ÄúSmart Home‚Äù</a></li>
<li><a href="../321612/index.html">Evening class: resizing elements to pure JS</a></li>
<li><a href="../321614/index.html">The tale of an internship in a small company or how Kontur and I competed [Part I]</a></li>
<li><a href="../321618/index.html">Motion Detection Based on OpenCV Bioinspired Module</a></li>
<li><a href="../321622/index.html">Corporations and startups: successful cooperation models</a></li>
<li><a href="../321626/index.html">How to start a startup and not break your own life</a></li>
<li><a href="../321628/index.html">Aggressive energy saving when running on Windows on battery</a></li>
<li><a href="../321630/index.html">Another Brainfuck interpreter</a></li>
<li><a href="../321632/index.html">OpenPapyrus: [yet another] ERP-system open source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>