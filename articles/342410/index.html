<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing x86-64 JIT compiler from scratch in stock Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I will show how to write a rudimentary, native x86-64 just-in-time compiler (JIT) in CPython, using only embedded modules. 

 The cod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing x86-64 JIT compiler from scratch in stock Python</h1><div class="post__text post__text-html js-mediator-article">  In this article, I will show how to write a rudimentary, native x86-64 <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">just-in-time compiler (JIT)</a> in CPython, using only embedded modules. <br><br>  The code is intended for UNIX-based systems such as macOS and Linux, but it should be easy to broadcast to other systems, such as Windows.  All code is published on <a href="https://github.com/cslarsen/minijit">github.com/cslarsen/minijit</a> . <br><br>  The goal is to generate new versions of the assembler code below in runtime and execute them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs perl"><span class="hljs-number"><span class="hljs-number">48</span></span> b8 ed ef be ad de movabs $0xdeadbeefed, %rax <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">48</span></span> 0f af c7 imul %rdi,%rax c3 retq</code> </pre> <br>  Basically, we will deal with the left part of the code ‚Äî the byte sequence <code>48 b8 ed ...</code> and so on.  These 15 bytes in <a href="https://en.wikipedia.org/wiki/Machine_code">machine code</a> constitute the x86-64 function, which multiplies its argument by the constant <a href="https://en.wikipedia.org/wiki/Magic_number_(programming)"><code>0xdeadbeefed</code></a> .  At the JIT stage, functions with different such constants will be created.  This contrived form of <a href="https://en.wikipedia.org/wiki/Run-time_algorithm_specialisation">specialization</a> should demonstrate the basic mechanics of JIT compilation. <br><a name="habracut"></a><br>  The main strategy is to load the standard C library using the built-in python module <a href="https://docs.python.org/3/library/ctypes.html"><code>ctypes</code></a> . From there, we will get access to system functions for interacting with the virtual memory manager.  Use <a href="http://man7.org/linux/man-pages/man2/mmap.2.html"><code>mmap</code></a> to get a block of memory aligned to the page border.  Alignment is necessary for code execution.  For this reason, we do not take the usual <code>malloc</code> function, since it can return a memory that extends beyond the page boundary. <br><br>  We use the <a href="http://man7.org/linux/man-pages/man2/mprotect.2.html"><code>mprotect</code></a> function to mark the memory block as read-only and executable.  After that, it should be possible to call our freshly compiled code block with ctypes. <br><br><h1>  Template part </h1><br>  Before you do anything, you need to load the standard C library. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sys.platform.startswith(<span class="hljs-string"><span class="hljs-string">"darwin"</span></span>): libc = ctypes.cdll.LoadLibrary(<span class="hljs-string"><span class="hljs-string">"libc.dylib"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># ... elif sys.platform.startswith("linux"): libc = ctypes.cdll.LoadLibrary("libc.so.6") # ... else: raise RuntimeError("Unsupported platform")</span></span></code> </pre> <br>  There are other ways to do this, for example <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes.util &gt;&gt;&gt; libc = ctypes.CDLL(ctypes.util.find_library(<span class="hljs-string"><span class="hljs-string">"c"</span></span>)) &gt;&gt;&gt; libc &lt;CDLL <span class="hljs-string"><span class="hljs-string">'/usr/lib/libc.dylib'</span></span>, handle <span class="hljs-number"><span class="hljs-number">110</span></span>d466f0 at <span class="hljs-number"><span class="hljs-number">103725</span></span>ad0&gt;</code> </pre> <br>  To determine the page size, call <a href="http://man7.org/linux/man-pages/man3/sysconf.3.html"><code>sysconf(_SC_PAGESIZE)</code></a> .  The <code>_SC_PAGESIZE</code> is 29 on macOS, but 30 on Linux.  We just hard-code them in our program.  You can find the page size by examining the system header files or writing a simple C program for output.  A more reliable and elegant solution is to use the <a href="https://github.com/cffi/cffi"><code> cffi</code></a> instead of ctypes, because it can automatically parse header files.  However, since we set the goal to use the standard CPython distribution, we will continue to work with ctypes. <br><br>  We need some extra constants for <code>mmap</code> and so on.  They are written below.  Maybe you have to look for them for other UNIX options. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sys.platform.startswith(<span class="hljs-string"><span class="hljs-string">"darwin"</span></span>): libc = ctypes.cdll.LoadLibrary(<span class="hljs-string"><span class="hljs-string">"libc.dylib"</span></span>) _SC_PAGESIZE = <span class="hljs-number"><span class="hljs-number">29</span></span> MAP_ANONYMOUS = <span class="hljs-number"><span class="hljs-number">0x1000</span></span> MAP_PRIVATE = <span class="hljs-number"><span class="hljs-number">0x0002</span></span> PROT_EXEC = <span class="hljs-number"><span class="hljs-number">0x04</span></span> PROT_NONE = <span class="hljs-number"><span class="hljs-number">0x00</span></span> PROT_READ = <span class="hljs-number"><span class="hljs-number">0x01</span></span> PROT_WRITE = <span class="hljs-number"><span class="hljs-number">0x02</span></span> MAP_FAILED = <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-comment"><span class="hljs-comment"># voidptr actually elif sys.platform.startswith("linux"): libc = ctypes.cdll.LoadLibrary("libc.so.6") _SC_PAGESIZE = 30 MAP_ANONYMOUS = 0x20 MAP_PRIVATE = 0x0002 PROT_EXEC = 0x04 PROT_NONE = 0x00 PROT_READ = 0x01 PROT_WRITE = 0x02 MAP_FAILED = -1 # voidptr actually else: raise RuntimeError("Unsupported platform")</span></span></code> </pre> <br>  Although this is not a strict requirement, it is very useful to pass on the ctypes the types of functions that we are going to use.  Thus, exceptions will be raised in the case of mixing invalid types.  For example: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Set up sysconf sysconf = libc.sysconf sysconf.argtypes = [ctypes.c_int] sysconf.restype = ctypes.c_long</span></span></code> </pre> <br>  This tells ctypes that the <code>sysconf</code> function takes a four-byte integer, but produces a long integer.  After that you can find out the current page size with the following command: <br><br><pre> <code class="python hljs">pagesize = sysconf(_SC_PAGESIZE)</code> </pre> <br>  The machine code that we are going to generate will be interpreted as unsigned 8-bit bytes, so we register the unsigned pointer type to these bytes: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># 8-bit unsigned pointer type c_uint8_p = ctypes.POINTER(ctypes.c_uint8)</span></span></code> </pre> <br>  Below are just laid out the other types of functions that we will use.  For bug reports, it‚Äôs good that the <a href="http://man7.org/linux/man-pages/man3/strerror.3.html"><code>strerror</code></a> function <a href="http://man7.org/linux/man-pages/man3/strerror.3.html"><code>strerror</code></a> .  Use <a href="http://man7.org/linux/man-pages/man3/munmap.3p.html"><code>munmap</code></a> to destroy the machine code block when we <a href="http://man7.org/linux/man-pages/man3/munmap.3p.html"><code>munmap</code></a> done with it.  So the operating system will be able to reuse this memory. <br><br><pre> <code class="python hljs">strerror = libc.strerror strerror.argtypes = [ctypes.c_int] strerror.restype = ctypes.c_char_p mmap = libc.mmap mmap.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int, ctypes.c_int, ctypes.c_int, <span class="hljs-comment"><span class="hljs-comment"># Below is actually off_t, which is 64-bit on macOS ctypes.c_int64] mmap.restype = c_uint8_p munmap = libc.munmap munmap.argtypes = [ctypes.c_void_p, ctypes.c_size_t] munmap.restype = ctypes.c_int mprotect = libc.mprotect mprotect.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int] mprotect.restype = ctypes.c_int</span></span></code> </pre> <br>  At this stage it is difficult to justify using Python instead of C. In the case of C, we do not need the above generic code.  But Python will give much more freedom in further experiments. <br><br>  Now we are ready to write the <code>mmap</code> wrapper. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size)</span></span></span><span class="hljs-function">:</span></span> ptr = mmap(<span class="hljs-number"><span class="hljs-number">0</span></span>, size, PROT_WRITE | PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ptr == MAP_FAILED: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> RuntimeError(strerror(ctypes.get_errno())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr</code> </pre> <br>  This function uses <code>mmap</code> to allocate memory aligned to the page borders.  We mark PROT as readable and writeable, and mark it as private and anonymous.  The latter means that other processes will not be able to see this section of memory and that it does not have file support.  <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">The Linux mmap tutorial on Linux</a> covers this topic <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">in</a> more detail (just be sure to open the manual specifically for your system).  If the <code>mmap</code> call fails, we cause a Python error. <br><br>  To mark a memory as executable: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_executable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block, size)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mprotect(block, size, PROT_READ | PROT_EXEC) != <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> RuntimeError(strerror(ctypes.get_errno()))</code> </pre> <br>  With this <code>mprotect</code> call <code>mprotect</code> we mark the <code>mprotect</code> as readable and executable.  If we want, we can also make it writable, but some systems will refuse to execute code from memory that is open for writing.  This is sometimes called the <a href="https://en.wikipedia.org/wiki/W%255EX">security feature W ^ X.</a> <br><br>  To destroy the memory block, do the following: <br><br><pre> <code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block, size)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> munmap(block, size) == <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> RuntimeError(strerror(ctypes.get_errno()))</code> </pre> <br><h1>  Fun part </h1><br>  Now we are finally ready to write insanely simple JIT code! <br><br>  Recall the assembler listing from the beginning of the article: this is a small function ‚Äî without a local stack frame ‚Äî that multiplies the number at the input to a constant.  In Python, we would write it like this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_multiplication_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(constant)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> n: n * constant</code> </pre> <br>  This is a really contrived example, but it corresponds to the definition of JIT.  In the end, we really create native code in runtime and execute it.  It is easy to present more advanced examples, such as <a href="https://en.wikipedia.org/wiki/Brainfuck">Brainfuck</a> JIT compilation into x86-64 machine code.  Or use AVX instructions for lightning-fast math vectorization operations. <br><br>  The disassembly of the machine code at the beginning of the article was actually accomplished by compiling and disassembling the following C code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; uint64_t multiply(uint64_t n) { return n*0xdeadbeefedULL; } If you want to compile it yourself, use something like $ gcc -Os -fPIC -shared -fomit-frame-pointer \ -march=native multiply.c -olibmultiply.so</span></span></span></span></code> </pre> <br>  Here I optimized for size ( <code>-Os</code> ) to generate minimal machine code, position-independent ( <code>-fPIC</code> ) to prevent the use of hops in absolute addresses, without any frame pointers ( <code>-fomit-frame-pointer</code> ) to remove unnecessary installation code stack (but it may be necessary for more advanced functions) and using the native instruction set of the existing processor ( <code>-march=native</code> ). <br><br>  We could pass <code>-S</code> and get the disassembler listing, but we are interested in the <i>machine code</i> , so instead we use a tool like <code>objdump</code> : <br><br><pre> <code class="hljs perl">$ objdump -d libmultiply.so ... <span class="hljs-number"><span class="hljs-number">0000000000000</span></span>f71 &lt;_multiply&gt;: f71: <span class="hljs-number"><span class="hljs-number">48</span></span> b8 ed ef be ad de movabs $0xdeadbeefed,%rax f78: <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> f7b: <span class="hljs-number"><span class="hljs-number">48</span></span> 0f af c7 imul %rdi,%rax f7f: c3 retq</code> </pre> <br>  If you are not very familiar with assembler, I will explain how this function works.  At first, the <code>movabs</code> function simply places the <i>immediate</i> number (immediate number) in the RAX register.  <i>Direct</i> - this is such a jargon in assembler to refer to something that is specified directly in the machine code.  In other words, this is the built-in argument for the <code>movabs</code> instruction.  So now the RAX register contains the constant <code>0xdeadbeefed</code> . <br><br>  Also - according to the <a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">AMD64</a> convention - the first integer argument will be in the RDI register, and the return value in RAX.  So the RDI register contains a multiplier.  This is the essence of the <code>imul</code> , which multiplies RAX and RDI, putting the result in RAX.  Finally, we retrieve the 64-bit return address from the stack and proceed to it with the RETQ command.  At this level, it is easy to imagine how <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">programming</a> can be implemented <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">in the transmission of continuations</a> . <br><br>  Please note that the constant <code>0xdeadbeefed</code> is in reverse byte format (little-endian).  You need to remember to do the same in the code. <br><br>  Now we are ready to put everything into the Python function. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_multiplier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block, multiplier)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Encoding of: movabs &lt;multiplier&gt;, rax block[0] = 0x48 block[1] = 0xb8 # Little-endian encoding of multiplication constant block[2] = (multiplier &amp; 0x00000000000000ff) &gt;&gt; 0 block[3] = (multiplier &amp; 0x000000000000ff00) &gt;&gt; 8 block[4] = (multiplier &amp; 0x0000000000ff0000) &gt;&gt; 16 block[5] = (multiplier &amp; 0x00000000ff000000) &gt;&gt; 24 block[6] = (multiplier &amp; 0x000000ff00000000) &gt;&gt; 32 block[7] = (multiplier &amp; 0x0000ff0000000000) &gt;&gt; 40 block[8] = (multiplier &amp; 0x00ff000000000000) &gt;&gt; 48 block[9] = (multiplier &amp; 0xff00000000000000) &gt;&gt; 56 # Encoding of: imul rdi, rax block[10] = 0x48 block[11] = 0x0f block[12] = 0xaf block[13] = 0xc7 # Encoding of: retq block[14] = 0xc3 # Return a ctypes function with the right prototype function = ctypes.CFUNCTYPE(ctypes.c_uint64) function.restype = ctypes.c_uint64 return function</span></span></code> </pre> <br>  At the bottom, we return the function type ctypes for use in this code.  This is a somewhat arbitrary placement, but I thought it would be good to put it next to the machine code. <br><br><h1>  The final part </h1><br>  Now we have the main parts that can be combined.  First, select one page of memory: <br><br><pre> <code class="python hljs">pagesize = sysconf(_SC_PAGESIZE) block = create_block(pagesize)</code> </pre> <br>  Then generate the machine code.  As a multiplier, choose the number 101. <br><br><pre> <code class="python hljs">mul101_signature = make_multiplier(block, <span class="hljs-number"><span class="hljs-number">101</span></span>)</code> </pre> <br>  Now we mark the section of memory as executable and read-only: <br><br><pre> <code class="python hljs">make_executable(block, pagesize)</code> </pre> <br>  We take the address of the first byte in the memory block. We submit it to the called function ctypes with the correct type: <br><br><pre> <code class="python hljs">address = ctypes.cast(block, ctypes.c_void_p).value mul101 = mul101_signature(address)</code> </pre> <br>  To get the block's memory address, use ctypes to pass it to a null pointer and retrieve its value.  Finally, we initialize the real function from this address with the help of the <code>mul101_signature</code> constructor. <br><br>  Voila!  Now we have a piece of <i>native code</i> that can be called from Python.  If you are in the REPL environment, you can do it directly: <br><br> <code>&gt;&gt;&gt; print(mul101(8)) <br> 808</code> <br> <br>  Note that this small multiplication function is slower than native Python calculations.  This is mainly due to the ctypes alien library, the use of which carries a lot of overhead: every time you call a function, you need to check which dynamic types you pass to it, then unpack them and convert them, and then do the same with the return value.  So it makes sense to use an assembler or if you have access to some new Intel instructions, or to compile something like Brainfuck into native code. <br><br>  In the end, if you want, you can let the system reuse the memory in which the function is located.  Keep in mind that after this, the process is likely to fail if you try to access the code again.  So it's probably better to delete all references to Python at the same time: <br><br><pre> <code class="python hljs">destroy_block(block, pagesize) <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> block <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> mul101</code> </pre> <br>  If you run the code in its full form from <a href="https://github.com/cslarsen/minijit">the GitHub repository</a> , you can specify a multiplication constant directly on the command line: <br><br> <code>$ python mj.py 101 <br> Pagesize: 4096 <br> Allocating one page of memory <br> JIT-compiling a native mul-function w/arg 101 <br> Making function block executable <br> Testing function <br> OK mul(0) = 0 <br> OK mul(1) = 101 <br> OK mul(2) = 202 <br> OK mul(3) = 303 <br> OK mul(4) = 404 <br> OK mul(5) = 505 <br> OK mul(6) = 606 <br> OK mul(7) = 707 <br> OK mul(8) = 808 <br> OK mul(9) = 909 <br> Deallocating function</code> <br> <br><h1>  JIT debugging </h1><br>  If you want to continue learning with the help of this small program, then soon there will be an idea to disassemble the generated machine code.  Alternatively, you can simply use gdb or lldb, but you need to know where to start.  There is such a trick: just output the hex value of the block address while waiting for the key to be pressed: <br><br><pre> <code class="hljs lisp">print(<span class="hljs-string"><span class="hljs-string">"address: 0x%x"</span></span> % address) print(<span class="hljs-string"><span class="hljs-string">"Press ENTER to continue"</span></span>) raw_input()</code> </pre> <br>  Then just run the program in the debugger and during a pause, disassemble the memory area.  Of course, there is also the possibility of step-by-step debugging of the assembly code, if you want to see what is happening.  Sample lldb session: <br><br><pre> <code class="hljs swift">$ lldb python ... (lldb) run mj.py <span class="hljs-number"><span class="hljs-number">101</span></span> ... (lldb) <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-type"><span class="hljs-type">Process</span></span> <span class="hljs-number"><span class="hljs-number">19329</span></span> resuming ... address <span class="hljs-number"><span class="hljs-number">0x1002fd000</span></span> <span class="hljs-type"><span class="hljs-type">Press</span></span> <span class="hljs-type"><span class="hljs-type">ENTER</span></span> to <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  At this point, press CTRL + C to return to the debugger, then disassemble the code from the memory area: <br><br><pre> <code class="hljs go">(lldb) x/<span class="hljs-number"><span class="hljs-number">3i</span></span> <span class="hljs-number"><span class="hljs-number">0x1002fd</span></span>000 <span class="hljs-number"><span class="hljs-number">0x1002fd</span></span>000: <span class="hljs-number"><span class="hljs-number">48</span></span> b8 <span class="hljs-number"><span class="hljs-number">65</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> movabsq $<span class="hljs-number"><span class="hljs-number">0x65</span></span>, %rax <span class="hljs-number"><span class="hljs-number">0x1002fd</span></span>00a: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">0f</span></span> af c7 imulq %rdi, %rax <span class="hljs-number"><span class="hljs-number">0x1002fd</span></span>00e: c3 retq</code> </pre> <br>  Note that 65 to hex is 101 in the decimal system, that is, the command line argument that we entered above. <br><br>  If you need a disassembler only in Python, I recommend the <a href="http://www.capstone-engine.org/lang_python.html">Capstone</a> module. <br><br><h1>  What's next? </h1><br>  A good exercise would be JIT compiling <a href="https://en.wikipedia.org/wiki/Brainfuck">Brainfuck programs</a> into native code.  If you want to do this right away, I opened the GitHub repository at <a href="https://github.com/cslarsen/brainfuck-jit">github.com/cslarsen/brainfuck-jit</a> .  I even did <a href="https://speakerdeck.com/csl/how-to-make-a-simple-virtual-machine">a Speaker Deck presentation</a> .  It shows JIT compilation and optimization, but instead of the approach from this article, GNU Lightning is used to compile native code.  But it should be extremely easy to use examples without GNU Lightning or generate your own code.  An interesting observation on the Brainfuck project: if you simply JIT compile all the Brainfuck instructions one by one, you will not get much performance gains even in native code.  The entire performance increase occurs at the stage of <i>code optimization</i> , where you fill in one or more x86 instructions with integer operations.  Another candidate for such a compilation is <a href="">the Forth language</a> . <br><br>  Before you seriously tackle the expansion of this JIT compiler, take a look at <a href="https://github.com/Maratyszcza/PeachPy">the PeachPy project</a> .  This is a much more advanced project than ours, it includes a disassembler and supports, as it were, the entire set of x86-64 instructions, right down to <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> . <br><br>  As mentioned above, there are many overheads when using ctypes to call functions.  To eliminate some of them, you can use the <code>cffi</code> module, but the fact remains: if you want to repeatedly call very small JIT functions, then usually it is faster to do it in pure Python. <br><br>  What other great uses are there?  I have met some mathematical libraries in Python that are switching to vector operations to improve performance.  But I can imagine other things.  For example, tools for compressing and decompressing native code, accessing virtualization primitives, and so on.  I know that some <a href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter">BPF</a> tools and regex modules also perform JIT compilation of queries for faster data processing. <br><br>  What is interesting in this exercise is that we are entering the territory outside the pure assembler.  For example, it comes to mind how different instructions are disassembled into identical symbols.  So, the RETQ instruction has a different opcode than the regular RET instruction, because it processes 64-bit values.  Maybe it does not matter when programming in assembler, because such details do not always matter, but it is worth remembering the difference.  I saw how gcc, lldb and objdump issued a slightly different listing of the disassembler for the RETQ and MOVABSQ instructions in the same code. <br><br>  One more note.  I mentioned that the native Brainfuck compiler I made initially produces a not-so-fast code.  It needs to be optimized.  That is, the code does not automatically get faster from the fact that you have AVX, CUDA or something else.  The cruel truth is that the gcc compiler contains a large base of optimizations that are almost impossible to reproduce manually.  For more information, I would recommend the <a href="http://www.fefe.de/source-code-optimization.pdf">classic lecture by Felix von Leitner on source code optimization</a> . <br><br><h1>  What about the actual compilation? </h1><br>  Several people wrote in the <a href="https://news.ycombinator.com/item%3Fid%3D15665581">comments</a> that they expected a more detailed description of the stage where the compilation was actually performed.  This is a fair comment.  As I said, this is indeed a very limited form of compilation, where we practically do nothing with the code at runtime ‚Äî we just insert a constant.  <i>Maybe</i> I will write a continuation of the article, in which we consider a pure compilation stage.  Be in touch! </div><p>Source: <a href="https://habr.com/ru/post/342410/">https://habr.com/ru/post/342410/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342400/index.html">Targeting the Odnoklassniki Moderator application</a></li>
<li><a href="../342402/index.html">Web application on Node and Vue, part 4: code reuse</a></li>
<li><a href="../342404/index.html">Javascript: the path to code clarity</a></li>
<li><a href="../342406/index.html">Kali Linux: packages modification, kernel build, and ISO image creation exercises</a></li>
<li><a href="../342408/index.html">Russian AI Cup 2017 - beta test report, start of the championship. StarCraft wanted, got weird Total War</a></li>
<li><a href="../342412/index.html">Kubernetes success stories in production. Part 5: Monzo Digital Bank</a></li>
<li><a href="../342420/index.html">A new Alina has been detected - a malware for POS terminals.</a></li>
<li><a href="../342424/index.html">Atmega328p + ENC28J60 = Bridge between UART and Ethernet</a></li>
<li><a href="../342426/index.html">How to create graphics for VR - Google recommendations</a></li>
<li><a href="../342428/index.html">1000 ++ way to run commands on a remote computer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>