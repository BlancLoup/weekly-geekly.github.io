<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intel Software Guard Extensions tutorial. Part 4, the enclave</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the fourth installment of the Intel Software Guard Extensions (Intel SGX) tutorial series, we will create an enclave and its interface. We will loo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intel Software Guard Extensions tutorial. Part 4, the enclave</h1><div class="post__text post__text-html js-mediator-article">  In the fourth installment of the Intel Software Guard Extensions (Intel SGX) tutorial series, we will create an enclave and its interface.  We will look at the boundaries of the enclave, defined in <a href="https://habrahabr.ru/company/intel/blog/318012/">Part 3</a> , and define the necessary functions of the bridge, consider the influence of the bridge‚Äôs functions on the object model, and create the project infrastructure necessary to integrate the enclave into our application.  Instead of an ECALL enclave, we still use stubs;  We will move on to the full integration of the enclave in the fifth part of this series. <br><br><img src="https://habrastorage.org/files/bfc/3cb/493/bfc3cb4933524b1b9bfe94976956aa99.jpg"><br><a name="habracut"></a><br>  Along with this part of the series, source code is provided: an enclave stub and interface functions;  This code is available for download. <br><br><h2>  <font color="#0071c5">Application architecture</font> </h2><br>  Before designing the enclave interface, you need to think about the overall architecture of the application.  As we discussed in the <a href="https://habrahabr.ru/company/intel/blog/312002/">first part</a> , the enclaves are implemented as dynamic-link libraries (DLLs in Windows * and shared libraries in Linux *) and must be linked only with 100% native C code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the same time, the graphical user interface of the Tutorial Password Manager program is written in C #.  A mixed assembly written in C ++ / CLI is used to switch from managed to unmanaged code, but although this assembly contains its own code, it does not consist of 100% of its own code and therefore cannot directly interact with the Intel SGX enclave.  Attempts to embed untrusted enclave bridge functions in C ++ / CLI assemblies will result in unrecoverable errors: <br><br><pre><code class="hljs vhdl">Command <span class="hljs-literal"><span class="hljs-literal">line</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span> D8045: cannot compile C <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Enclave_u</span></span>.c'; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the /clr option</code> </pre> <br>  This means that it is necessary to place the functions of an untrusted bridge in a separate DLL library consisting entirely of its own code.  As a result, there will be at least three DLL libraries in our application: the C ++ / CLI core, the enclave bridge, and the enclave itself.  This structure is shown in Fig.  one. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/548/6bf/b3c/5486bfb3c58b478aa59da68a71a58d43.png"></div><br>  <i><font color="#999999">Figure 1. Components of a mixed enclave application.</font></i> <br><br><h3>  <font color="#0071c5">Further improvements</font> </h3><br>  Since the functions of the bridge of the enclave must be in a separate DLL library, we will take the next step: we will place all functions directly interacting with the enclave into this library.  This separation of application levels will simplify the management of the program and its debugging, as well as increase the ease of integration by reducing the impact on other modules.  If a class or module performs a specific task with a clearly defined boundary, changes to other modules are less likely to affect it. <br><br>  In our case, the <i>PasswordManagerCoreNative</i> class should not be burdened with the additional task of creating enclave instances.  This class only needs to know if the platform supports the Intel SGX extensions to perform the corresponding function. <br><br>  As an example, the following code snippet shows the <i>unlock ()</i> method: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PasswordManagerCoreNative::vault_unlock(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LPWSTR wpassphrase) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rv; UINT16 size; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *mbpassphrase = tombs(wpassphrase, <span class="hljs-number"><span class="hljs-number">-1</span></span>, &amp;size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mbpassphrase == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NL_STATUS_ALLOC; rv= vault.unlock(mbpassphrase); SecureZeroMemory(mbpassphrase, size); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mbpassphrase; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }</code> </pre> <br>  This is a very simple method: it takes a user passphrase in the form of wchar_t, converts it into a variable-length encoding (UTF-8), then calls the <i>unlock ()</i> method in the storage object.  Instead of cluttering up this class and this method with enclave functions, it is better to add enclave support to this method by adding one line: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PasswordManagerCoreNative::vault_unlock(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LPWSTR wpassphrase) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rv; UINT16 size; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *mbpassphrase = tombs(wpassphrase, <span class="hljs-number"><span class="hljs-number">-1</span></span>, &amp;size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mbpassphrase == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NL_STATUS_ALLOC; <span class="hljs-comment"><span class="hljs-comment">// Call the enclave bridge function if we support Intel SGX if (supports_sgx()) rv = ew_unlock(mbpassphrase); else rv= vault.unlock(mbpassphrase); SecureZeroMemory(mbpassphrase, size); delete[] mbpassphrase; return rv; }</span></span></code> </pre> <br>  Our goal is to free this class from working with the enclave to the greatest extent.  Other necessary additions for the <i>PasswordManagerCoreNative</i> class: support for the Intel SGX flag and methods for setting and getting this flag. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PASSWORDMANAGERCORE_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PasswordManagerCoreNative</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _supports_sgx; <span class="hljs-comment"><span class="hljs-comment">// Other class members ommitted for clarity protected: void set_sgx_support(void) { _supports_sgx = 1; } int supports_sgx(void) { return _supports_sgx; }</span></span></code> </pre> <br><h2>  <font color="#0071c5">Design of the enclave</font> </h2><br>  The general plan of the application is ready, so you can do the design of the enclave and its interface.  To do this, let us return to the class diagram of the application kernel, which we first described in the third part ‚Äî it is shown in Fig.  2. Objects in the enclave are shaded green, and untrusted components are blue. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/122/350/ce8/122350ce87be4143919c3d6626657c85.png"></div><br>  <i><font color="#999999">Figure 2. Class diagram in Tutorial Password Manager with Intel Software Guard Extensions.</font></i> <br><br>  Only one connection crosses the enclave border: the connection between the <i>PasswordManagerCoreNative</i> object and the <i>Vault</i> .  This means that most of our ECALLs are just shells of class methods in <i>Vault</i> .  You also need to add additional ECALL to manage the infrastructure of the enclave.  One of the difficulties in the development of an enclave is that ECALL, OCALL and the bridge functions must be native C code, and we widely use C ++ components.  After starting the enclave, we also need functions that fill the gap between C and C ++ (objects, constructors, overloads, and others). <br><br>  The shells and functions of the bridge will be in its own DLL library, which we will call EnclaveBridge.dll.  For clarity, we will supply the wrapper function with the prefix ‚Äúew_‚Äù (enclave wrapper), and the bridge functions that form ECALL with the prefix ‚Äúve_‚Äù (vault enclave). <br><br>  Calls from <i>PasswordManagerCoreNative</i> to the corresponding method in Vault will follow the path shown in Figure.  3 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a2c/749/87f/a2c74987f5204f5180c37e84c2b4963f.png"></div><br>  <i><font color="#999999">Figure 3. The way to perform bridge and ECALL functions.</font></i> <br><br>  The method in <i>PasswordManagerCoreNative</i> calls the wrapper function in EnclaveBridge.dll.  This shell, in turn, calls one or more ECALLs that go into the enclave and call the corresponding class method in the <i>Vault</i> object.  After all of the ECALL is completed, the wrapper function returns to the caller in <i>PasswordManagerCoreNative</i> and gives it the return value. <br><br><h3>  <font color="#0071c5">Logistics enclave</font> </h3><br>  When creating an enclave, you first need to decide on a system to manage the enclave itself.  The enclave must be running, and the resulting enclave ID must be provided to ECALL functions.  Ideally, all this should be transparent to the top levels of the application. <br><br>  The easiest solution for Tutorial Password Manager is to use global variables in the EnclaveBridge DLL to post information about the enclave.  This solution is constrained: in the enclave there can only be one active stream at a time.  This is a reasonable solution, since the performance of the Password Manager will still not increase when using multiple threads to work with the repository.  Most actions are controlled by the user interface, they do not constitute a significant load on the CPU. <br><br>  To solve the transparency problem, each wrapper function must first call the function to check if the enclave is running and start it if it is not already running.  The logic is pretty simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENCLAVE_FILE _T(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Enclave.signed.dll"</span></span></span><span class="hljs-meta">) static sgx_enclave_id_t enclaveId = 0; static sgx_launch_token_t launch_token = { 0 }; static int updated= 0; static int launched = 0; static sgx_status_t sgx_status= SGX_SUCCESS; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Ensure the enclave has been created/launched. static int get_enclave(sgx_enclave_id_t *eid) { if (launched) return 1; else return create_enclave(eid); } static int create_enclave(sgx_enclave_id_t *eid) { sgx_status = sgx_create_enclave(ENCLAVE_FILE, SGX_DEBUG_FLAG, &amp;launch_token, &amp;updated, &amp;enclaveId, NULL); if (sgx_status == SGX_SUCCESS) { if ( eid != NULL ) *eid = enclaveId; launched = 1; return 1; } return 0; }</span></span></span></span></code> </pre> <br>  First, each wrapper function calls the <i>get_enclave ()</i> function, which checks whether the enclave is running, using a static variable.  If so, then this function (if necessary) places the enclave ID in the pointer <i>eid</i> .  This step is optional because the enclave identifier is also stored in the global variable <i>enclaveID</i> , and you can use it directly. <br><br>  What happens if the enclave is lost due to a power failure or due to an error that causes a crash?  To do this, we check the return value of ECALL: it indicates the success or failure of the operation itself ECALL, and not the function called in the enclave. <br><br><pre> <code class="cpp hljs">sgx_status = ve_initialize(enclaveId, &amp;vault_rv);</code> </pre> <br>  The return value of the function called in the enclave, if any, is passed through a pointer provided as the second argument to ECALL (these function prototypes are automatically created by the Edger8r program).  You should always check the return value of an ECALL.  Any result other than SGX_SUCCESS indicates that the program could not successfully enter the enclave, and the requested function was not started.  (Note that we also defined <i>sgx_status</i> as a global variable. This is another simplification due to the single-threaded architecture of our application). <br><br>  We will add a function that analyzes the error returned by the ECALL function and checks the state of the enclave (lost, crash): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lost_enclave</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sgx_status == SGX_ERROR_ENCLAVE_LOST || sgx_status == SGX_ERROR_ENCLAVE_CRASHED) { launched = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  These are correctable errors.  In the upper levels, there is no logic to cope with these conditions, but we provide it in the EnclaveBridge DLL to support further program development. <br><br>  Also note the lack of a function to destroy the enclave.  While the password manager application is open on the user's system, there is an enclave in memory, even if the user has locked his vault.  This is not the right way to work with enclaves.  Enclaves consume resources from a pool that is far from unlimited, even when idle.  We will deal with this problem in a subsequent release of this series when we talk about sealing data. <br><br><h2>  <font color="#0071c5">Enclave Definition Language</font> </h2><br>  Before turning to the device of the enclave, let's talk a little about the syntax of the Enclave Definition Language (EDL).  The enclave bridge functions, both ECALL and OCALLs, have prototypes in the EDL file with the following general structure: <br><br><pre> <code class="cpp hljs">enclave { <span class="hljs-comment"><span class="hljs-comment">// Include files // Import other edl files // Data structure declarations to be used as parameters of the function prototypes in edl trusted { // Include file if any. It will be inserted in the trusted header file (enclave_t.h) // Trusted function prototypes (ECALLs) }; untrusted { // Include file if any. It will be inserted in the untrusted header file (enclave_u.h) // Untrusted function prototypes (OCALLs) }; };</span></span></code> </pre> <br>  ECALL prototypes are in the trusted part, and OCALL are in the untrusted part.  The EDL syntax is similar to the C syntax, and the EDL function prototypes are very similar to, but not identical to, the C function prototypes.  In particular, the parameters of the bridge function and return values ‚Äã‚Äãare limited to some fundamental data types, and the EDL includes additional keywords and syntax for defining enclave behavior.  The <a href="https://software.intel.com/en-us/sgx-sdk">Intel Software Guard Extensions (Intel SGX) SDK User Guide</a> describes the EDL syntax and tutorial on how to create an example enclave exclusively and exclusively.  We will not repeat everything that is written there, but simply discuss the elements of this language related to our application. <br><br>  When parameters are passed to the enclave functions, they are placed in the protected memory space of the enclave.  For parameters passed as values, no additional action is required, since the values ‚Äã‚Äãare placed in the protected enclave stack, as for calling any other functions.  For pointers, the situation is completely different. <br><br>  For parameters passed as pointers, the data referenced by the pointer must be passed into and out of the enclave.  Boundary procedures that perform this data transfer must ‚Äúknow‚Äù two things: <br><br><ol><li>  In which direction should the data be copied: to the bridge function, from the bridge function or in both directions? </li><li>  What is the size of the data buffer referenced by the pointer? </li></ol><br><h3>  <font color="#0071c5">Pointer direction</font> </h3><br>  When providing the function of an index parameter, you must specify the direction using keywords in square brackets: [in], [out] or [in, out], respectively.  The meaning of these keywords is shown in table 1. <br><table><tbody><tr><th width="110">  Direction </th><th>  ECALL </th><th>  OCALL </th></tr><tr><td>  in </td><td>  The buffer is copied from the application to the enclave.  Changes will only affect the buffer inside the enclave. </td><td>  The buffer is copied from the enclave to the application.  Changes will only affect the buffer outside the enclave. </td></tr><tr><td>  out </td><td>  The buffer will be allocated inside the enclave and initialized with zero values.  It will be copied to the original buffer when the ECALL exits. </td><td>  The buffer will be allocated outside the enclave and initialized with zero values.  This untrusted buffer will be copied to the original buffer when the OCALL exits. </td></tr><tr><td>  in, out </td><td>  Data is copied back and forth. </td><td>  Just like in ECALL. <br></td></tr></tbody></table>  <i><font color="#999999">Table 1. Direction parameters of pointers and their values ‚Äã‚Äãin ECALL and OCALL.</font></i> <br><br>  Note that the direction is relative to the called function of the bridge.  For the function ECALL, [in] means ‚Äúcopy the buffer to the enclave‚Äù, but for OCALL the same parameter means ‚Äúcopy the buffer to an untrusted function‚Äù.  (There is also a <i>user_check</i> parameter that can be used in place of them, but it does not belong to the subject of our discussion. For information on its purpose and use, see the SDK documentation.) <br><br><h3>  <font color="#0071c5">Buffer size</font> </h3><br>  Boundary procedures calculate the total buffer size in bytes as follows: <br><br><pre> <code class="hljs">  = element_size * element_count</code> </pre> <br>  By default, for boundary procedures, the value of <i>element_count</i> is 1, and <i>element_size is</i> calculated based on the element referenced by the pointer parameter, for example, for an integer pointer, <i>element_size</i> will be: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)</code> </pre> <br>  For a single element of a fixed data type, such as int or float, no additional information is required in the prototype of the EDL function.  For the void pointer, you must specify the size of the element, otherwise an error will occur during compilation.  For arrays, char and wchar_t strings, and other types where the data buffer exceeds one element, you must specify the number of elements in the buffer, otherwise only one element will be copied. <br><br>  Add <i>count</i> or <i>size</i> (or both) to the keywords in square brackets.  They can be given a constant value or one of the parameters of the function.  In most cases, the <i>count</i> and <i>size</i> functionality is the same, but it is recommended to use them in the right context.  Strictly speaking, size should be specified only when passing a void pointer.  In other cases, you should use count. <br><br>  When passing a string C and wstring (char array or wchar_t array with terminating NULL), you can use the <i>string</i> or <i>wstring</i> parameter instead of <i>count</i> or <i>size</i> .  In this case, the boundary procedures will determine the size of the buffer, getting the length of the string directly. <br><br><pre> <code class="cpp hljs">function([in, size=<span class="hljs-number"><span class="hljs-number">12</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *param); function([in, count=len] <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buffer, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len); function([in, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cstr);</code> </pre> <br>  Please note that you can use <i>string</i> or <i>wstring</i> only if the direction is [in] or [in, out].  If only the [out] direction is specified, the string has not yet been created, so the boundary procedure cannot get the size of the buffer.  If you specify [out, string], an error will occur during compilation. <br><br><h2>  <font color="#0071c5">Bridge Shell and Functions</font> </h2><br>  You can now define the shells and functions of the bridge.  As mentioned above, most of our ECALLs are just shells of class methods in <i>Vault</i> .  The class definition for public member functions is shown below: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PASSWORDMANAGERCORE_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vault</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Non-public methods and members ommitted for brevity public: Vault(); ~Vault(); int initialize(); int initialize(const char *header, UINT16 size); int load_vault(const char *edata); int get_header(unsigned char *header, UINT16 *size); int get_vault(unsigned char *edate, UINT32 *size); UINT32 get_db_size(); void lock(); int unlock(const char *password); int set_master_password(const char *password); int change_master_password(const char *oldpass, const char *newpass); int accounts_get_count(UINT32 *count); int accounts_get_info(UINT32 idx, char *mbname, UINT16 *mbname_len, char *mblogin, UINT16 *mblogin_len, char *mburl, UINT16 *mburl_len); int accounts_get_password(UINT32 idx, char **mbpass, UINT16 *mbpass_len); int accounts_set_info(UINT32 idx, const char *mbname, UINT16 mbname_len, const char *mblogin, UINT16 mblogin_len, const char *mburl, UINT16 mburl_len); int accounts_set_password(UINT32 idx, const char *mbpass, UINT16 mbpass_len); int accounts_generate_password(UINT16 length, UINT16 pwflags, char *cpass); int is_valid() { return _VST_IS_VALID(state); } int is_locked() { return ((state&amp;_VST_LOCKED) == _VST_LOCKED) ? 1 : 0; } };</span></span></code> </pre><br>  There are several problem functions in this class.  Some of them are obvious: for example, this is the constructor, destructor and overload for <i>initialize ()</i> .  These are the C ++ components that we need to call using the C functions. Some problems are not as obvious as they are inherent in the device functions.  Some of these problematic methods were incorrectly created on purpose so that we could look at certain problems in this tutorial, but other methods were incorrectly created without any far-reaching goals, it just happened.  We will solve these problems sequentially by submitting both prototypes for shell functions and EDL prototypes for proxy / bridge procedures. <br><br><h3>  <font color="#0071c5">Constructor and destructor</font> </h3><br>  In the non-Intel SGX code branch, the <i>Vault</i> class is a member of <i>PasswordManagerCoreNative</i> .  This is not possible in the Intel SGX code branch.  However, an enclave may include C ++ code if the bridge functions themselves are functions of C. <br><br>  Since we have limited the enclave to one thread, the Vault class can be made a static global object in the enclave.  This greatly simplifies the code and eliminates the need to create bridge functions and logic to create instances. <br><br><h3>  <font color="#0071c5">Overloading the initialize () method</font> </h3><br>  There are two prototypes of the <i>initialize ()</i> method: <br><br><ol><li>  The no argument method initializes the Vault object for a new password store with no content.  This is the first-time password repository. </li><li>  The two-argument method initializes the Vault object from the vault file header.  This is the existing password repository that the user opens (and then tries to unlock). </li></ol><br>  This method is divided into two shell functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ENCLAVEBRIDGE_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ew_initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ENCLAVEBRIDGE_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ew_initialize_from_header</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *header, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hsize)</span></span></span></span>;</code> </pre> <br>  The corresponding ECALL functions are defined as: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_initialize</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_initialize_from_header</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([in, count=len] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *header, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>;</code> </pre> <br><h3>  <font color="#0071c5">get_header ()</font> </h3><br>  This method has a fundamental problem.  Here is the prototype: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_header</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *header, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *size)</span></span></span></span>;</code> </pre> <br>  This function performs the following tasks: <br><br><ol><li>  It receives a header block for the storage file and places it in the buffer pointed to by the header.  The caller must allocate enough memory to store this data. </li><li>  If you pass the NULL pointer in the header parameter, then for uint16_t, to which the pointer is pointing, the header block size is set, so the calling method knows how much memory needs to be allocated. </li></ol><br>  This is a fairly common compression technique in some programmer communities, but for enclaves, a problem arises: when passing a pointer to ECALL or OCALL, the boundary functions copy the data referenced by the pointer into or out of the enclave (or in both directions).  These boundary functions need the size of the data buffer to know how many bytes to copy.  In the first case, a valid pointer with a variable size is used, which is not difficult, but in the second case, we have a NULL pointer and a size equal to zero. <br><br>  One could come up with an EDL prototype for the ECALL function, in which it would all work, but usually clarity is more important than brevity.  Therefore, it is better to divide the code into two ECALL functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_get_header_size</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([out] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *sz)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_get_header</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([out, count=len] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *header, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>;</code> </pre> <br>  The wrapper function of the enclave will provide the necessary logic so that we do not need to change other classes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ENCLAVEBRIDGE_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ew_get_header</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *header, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vault_rv; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!get_enclave(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NL_STATUS_SGXERROR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( header == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) sgx_status = ve_get_header_size(enclaveId, &amp;vault_rv, size); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sgx_status = ve_get_header(enclaveId, &amp;vault_rv, header, *size); RETURN_SGXERROR_OR(vault_rv); }</code> </pre> <br><h3>  <font color="#0071c5">accounts_get_info ()</font> </h3><br>  This method works like <i>get_header ()</i> : passes a NULL pointer and returns the size of the object in the corresponding parameter.  However, this method is not distinguished by grace and convenience due to the set of arguments parameters.  It is better to divide it into two shell functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ENCLAVEBRIDGE_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ew_accounts_get_info_sizes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mbname_sz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mblogin_sz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mburl_sz)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ENCLAVEBRIDGE_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ew_accounts_get_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mbname, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mbname_sz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mblogin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mblogin_sz, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mburl, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mburl_sz)</span></span></span></span>;</code> </pre> <br>  And two related ECALL functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_accounts_get_info_sizes</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, [out] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mbname_sz, [out] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mblogin_sz, [out] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mburl_sz)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_accounts_get_info</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, [out, count=mbname_sz] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mbname, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mbname_sz, [out, count=mblogin_sz] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mblogin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mblogin_sz, [out, count=mburl_sz] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mburl, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mburl_sz )</span></span></span></span>;</code> </pre> <br><h3>  <font color="#0071c5">accounts_get_password ()</font> </h3><br>  This is the most problematic code in the entire application.  Here is the prototype: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accounts_get_password</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UINT32 idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **mbpass, UINT16 *mbpass_len)</span></span></span></span>;</code> </pre> <br>  The first thing that catches your eye: it passes a pointer to a pointer to mbpass.  This method allocates memory. <br><br>  Clearly this is not the best idea.  No other method in the Vault class allocates memory, so it is internally inconsistent, and the API violates the convention because it does not provide a method to free memory on behalf of the caller.  At the same time, there is also a problem peculiar only to enclaves: the enclave cannot allocate memory in untrusted space. <br><br>  This can be handled in a wrapper function.     ,    ECALL,        ,           <i>Vault</i> ,              <i>PasswordManagerCoreNative</i> .      :     ,  ‚Äî   ,     .  PasswordManagerCoreNative     ,   -    (       Intel SGX). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ENCLAVEBRIDGE_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ew_accounts_get_password_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *len)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ENCLAVEBRIDGE_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ew_accounts_get_password</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mbpass, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>;</code> </pre> <br>   EDL    : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_accounts_get_password_size</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, [out] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mbpass_sz)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_accounts_get_password</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, [out, count=mbpass_sz] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mbpass, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mbpass_sz)</span></span></span></span>;</code> </pre> <br><h3> <font color="#0071c5">load_vault()</font> </h3><br>   <i>load_vault()</i>   .        : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_vault</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *edata)</span></span></span></span>;</code> </pre> <br>           <i>Vault</i> .   <i>Vault</i>   ,  ,     . <br><br>      ,        .       ECALL,    ,          ,       .     . <br><br>  -     : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ENCLAVEBRIDGE_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ew_load_vault</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *edata)</span></span></span></span>;</code> </pre> <br>    ECALL       ,              EDL: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ve_load_vault</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([in, count=len] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *edata, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span></code> </pre> <br>        ,  -    .                    ECALL. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ENCLAVEBRIDGE_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ew_load_vault</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *edata)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vault_rv; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dbsize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!get_enclave(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NL_STATUS_SGXERROR; <span class="hljs-comment"><span class="hljs-comment">// We need to get the size of the password database before entering the enclave // to send the encrypted blob. sgx_status = ve_get_db_size(enclaveId, &amp;dbsize); if (sgx_status == SGX_SUCCESS) { // Now we can send the encrypted vault data across. sgx_status = ve_load_vault(enclaveId, &amp;vault_rv, (unsigned char *) edata, dbsize); } RETURN_SGXERROR_OR(vault_rv); }</span></span></code> </pre><br><h2> <font color="#0071c5">   </font> </h2><br>  <a href="https://habrahabr.ru/company/intel/blog/318012/"> </a>  ,   <i>PasswordManagerCoreNative</i>       wchar_t  char.    ,      wchar_t? <br><br>        .  Windows   wchar_t     API- Win32,      <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a> .   UTF-16    16 :      ,   ASCII,  ,  ,        .    UTF-16   ,       16 ,      ASCII. <br><br>            ,           ASCII.    ,       .   Tutorial Password Manager  ,   .NET,    <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> . UTF-8 ‚Äî    ,               8  .      ASCII        UTF-16    ASCII.  ,   UTF-8      ,    UTF-16,       ,    ,    . <br><br>                    (  ,       ,         ). <br><br><h2>  <font color="#0071c5">Code example</font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mentioned above, this section provides </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample code for download</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The attached archive includes the source code for the Tutorial Password Manager Bridge DLL and the enclave DLLs. </font><font style="vertical-align: inherit;">The functions of the enclave are just stubs for now, they will be filled in the fifth part.</font></font><br><br><h2>  <font color="#0071c5">In further releases</font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the fifth part of this tutorial, we will complete the creation of the enclave, for which we will transfer the Crypto, DRNG and Vault classes to the enclave and combine them with ECALL functions. </font></font> Follow the news! </div><p>Source: <a href="https://habr.com/ru/post/318628/">https://habr.com/ru/post/318628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318614/index.html">IBM and BMW are working together to create a smart car</a></li>
<li><a href="../318618/index.html">The most difficult problem of computer science</a></li>
<li><a href="../318620/index.html">Experience in building Infrastructure-as-Code in VMware. Part 1.1: Dynamic Inventory</a></li>
<li><a href="../318622/index.html">Titan Quest redesign for smartphones and tablets</a></li>
<li><a href="../318626/index.html">How IT professionals work. Andrei Aksenov, founder of the Sphinx project</a></li>
<li><a href="../318630/index.html">New Year's Eve Mobile Applications Promotion Test</a></li>
<li><a href="../318632/index.html">Extended regularization of neural networks in online stores - with the help of ... napalm</a></li>
<li><a href="../318634/index.html">Integration of FATFS library for organizing reading of a disk device on iOS</a></li>
<li><a href="../318636/index.html">Post about the most important thing</a></li>
<li><a href="../318638/index.html">TechnoLive: Player and game, interface as a link, Olga Schubert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>