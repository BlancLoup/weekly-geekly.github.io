<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>In-Memory OLTP in SQL Server 2014. Part II</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part, we briefly reviewed the basic SQL Server in-memory processing capabilities applied to analytics and transactional and applications,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>In-Memory OLTP in SQL Server 2014. Part II</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/225167/">first part,</a> we briefly reviewed the basic SQL Server in-memory processing capabilities applied to analytics and transactional and applications, focusing on the latter, since in-memory OLTP (Hekaton) is the most significant innovation in SQL Server 2014. In this article we will continue our review. functionality of Hecaton on the example of a previously created database. <br><a name="habracut"></a><br>  Since we are talking about transactional processing in memory, it is useful to recall the acronym ACID: atomicity, integrity, isolation and residuality (effect), specifically letter I. Since it is expensive to achieve complete isolation, isolation levels that allow some degree of compromise are maintained in the DBMS .  This is a classic of the genre.  As you approach the ideal, SQL Server supports: dirty read (violations of the form are allowed: the first transaction changes data, the second reads changes, the first rolls back, it turns out that the second read the non-existent), read committed (perhaps a non-repeating read: the first transaction may change the data in read scale second, and second time second transaction reads already changed data), repeatable read (first transaction cannot change records at second scale, but can insert new ones - phantoms), serializable (most strict - phantoms do not  go away).  Once upon a time, when the pages in SQL Server were 2 kilobytes, it only supported page locks, so the last two levels were synonymous.  Full write lock support appeared in 7.0 (1998).  In 2005, a snapshot of Isolation was added to the listed levels, which, strictly speaking, is not an isolation level, but turns SQL Server from a blocker into a versioner.  Just snapshot is the main for Hecaton, because optimistic concurrency is the most natural approach when working with objects in memory.  It means in its essence, since  record versions are not stored in tempdb in this case.  Each write operation has a continuously increasing transaction number used for subsequent reads.  Uncommitted records are stored in memory, but are not visible until a commit, therefore there are no dirty reads.  Old records are deleted during the garbage collection process and free up memory. <br>  Also in Hecaton, Repeatable Read is supported, which (unlike the disk version) does not block anyone.  When a re-read occurs somewhere at the end of a transaction, if the records have changed, the transaction is canceled with the error 41305 ‚ÄúThe current transaction failed to complete the message‚Äù.  Serializable works the same way - in case of phantoms, the transaction is canceled. <br>  The isolation level is specified in the ATOMIC block of a natively compiled stored procedure (see below) or in the table hint of a T-SQL query.  Alternatively, with the help of the MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT database option, which, when accessing tables in memory, raises Read UnCommitted / Committed to Snapshot.  If usual to write <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRAN <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> dbo.UserSession <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ShoppingCartId=<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> SessionId=<span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><br>  there will be an error Msg 41333, Level 16, State 1, Line 3 <br>  The following transactions are compiled in the procedures underneath the transaction. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the T-SQL script, the isolation level is set by the hint: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRAN <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> dbo.UserSession <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ShoppingCartId=<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> SessionId=<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> dbo.ShoppingCart <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> TotalPrice=<span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ShoppingCartId=<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>(s) affected) (<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>(s) affected)</code> </pre><br><br>  Theoretically, Read Committed for memory optimized tables is also supported, but only in the case of autocommit (single statement) transactions. <br>  The cost of blocking is minimal, for which, in fact, everything was started. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRAN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> dbo.ShoppingCart <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">GETUTCDATE</span></span>(),<span class="hljs-number"><span class="hljs-number">50.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> resource_type, resource_description, object_name(resource_associated_entity_id), request_mode, request_type, request_status <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.dm_tran_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> request_session_id = @@SPID</code> </pre><br><br>  Please note that Hecaton "hangs" only Schema Stability on the table.  There are no X and IX in mention: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d8/829/281/6d8829281ba29e0a7635e2eb40cec4cb.png"><br>  Pic1 <br><br>  Let us compare for comparison what happens in the case of traditional tables.  Create a similar disk table, insert the same rowset as prefilling and repeat the transaction: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.ShoppingCart_Disk ( ShoppingCartId <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, UserId <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, CreatedDate datetime2 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, TotalPrice money, <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> ixUserid nonclustered (UserId)) ... <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TRAN <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> dbo.ShoppingCart_Disk <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">GETUTCDATE</span></span>(),<span class="hljs-number"><span class="hljs-number">50.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> resource_type, resource_description, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> resource_type <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> object_name(resource_associated_entity_id) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span>(resource_associated_entity_id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sysname) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, resource_associated_entity_id, request_mode, request_type, request_status <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.dm_tran_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> request_session_id = @@SPID</code> </pre><br><br>  What is called, feel the difference: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/b6f/4dc/8bdb6f4dc10068912261eb997ae04d7b.png"><br>  Pic2 <br><br>  Minimal blocking is one of the obvious advantages of Hecaton.  The application will benefit from the transfer to memory if it is made in the style of OLTP, i.e.  characterized by relatively short transactions with a high percentage of competition from multiple connections, and the problem is that locks or physical locks hang for a long time and do not release resources.  Porting will be easier if stored procedures are used, and performance problems can be distinguished into a relatively small subset of tables / stored procedures.  Of course, not all scenarios win.  The limiting case is one table of one record, which everyone updates with a new value.  The desire to shove anything and everything into memory will lead to the fact that it will end stupidly.  By the way, they often ask the question: what will happen if Hecaton consumes all the memory allocated to him?  In general, it is clear that there is nothing good: Msg 701, Level 17, State 103. There is a pool of default for the query.  What to do in this case is usually nothing.  SQL Server clears the memory pretty quickly, and on the release I have not yet managed to drive it into a stupor, which can only be treated with a restart (as opposed to PP).  Garbage collection is designed to be non-blocking and cooperative, which means that despite a special thread for this purpose, most of the work is done by user processes that check and mark entries for later removal from time to time and then delete.  Specialized flow is enabled when user activity is very small. <br>  How to avoid overflow in the process?  Obviously, it is correct to evaluate reality when tables are transferred to memory, especially since nobody canceled sp_spaceused. <br>  You can use the Memory Optimization Advisor, which performs static analysis of the schema, indexes, etc. for potential problems, and more intelligent AMR (Analysis, Migrate and Report) for dynamic analysis on the nature of use (takes statistics from <br>  Performance Data Warehouse).  You can preemptively limit Hecaton using the resource controller: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESOURCE</span></span> POOL mem_optpool <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MAX_MEMORY_PERCENT =   ) EXEC sp_xtp_bind_db_resource_pool <span class="hljs-string"><span class="hljs-string">'mydatabase'</span></span>, <span class="hljs-string"><span class="hljs-string">'mem_optpool'</span></span></code> </pre><br>  The influence of the Resource Governor applies only to the memory allocated by the In-Memory OLTP allocators, i.e.  if there are no memory optimized objects in the database, the memory is not removed from the resource pool.  The in-memory OLTP engine is integrated into a common SQL Server Memory Manager, which you can verify by running <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, memory_node_id, pages_kb/<span class="hljs-number"><span class="hljs-number">1024</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pages_MB <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.dm_os_memory_clerks <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'%xtp%'</span></span></code> </pre><br>  The first friend will be the memory allocated by the system, the last (memory_node = 64) is the dedicated administrative connection, and between them the user databases with MEMORY_OPTIMIZED_DATA. <br><br>  As noted in the first part, it is completely unnecessary to thrust the entire base into memory.  Possible combined queries between tables in memory and familiar tables, for example, <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> m1.ShoppingCartId, m2.UserId, d.CreatedDate, d.TotalPrice <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ShoppingCart m1 <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> ShoppingCart_Disk d <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> m1.ShoppingCartId = d.ShoppingCartId <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> UserSession m2 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> d.ShoppingCartId = m2.ShoppingCartId <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ShoppingCart <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> ShoppingCart <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ShoppingCart_Disk <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> TotalPrice = m.TotalPrice <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ShoppingCart_Disk d <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> ShoppingCart m <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> d.ShoppingCartId = m.ShoppingCartId <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> m.UserID &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span></code> </pre><br>  Script 1 <br><br>  In addition to tables, stored procedures can be stored in memory.  Such procedures can work only with in-memory tables.  The procedure is necessarily created with the SCHEMABINDING option, which means that the tables referenced by the procedure cannot be modified or deleted before it.  Traditional default procedures are performed with the EXECUTE AS CALLER option.  For procedures in memory, it is not supported.  The options are: EXECUTE AS OWNER, EXECUTE AS 'user_name' or EXECUTE AS SELF (creator).  There are other limitations as well. See <a href="http://msdn.microsoft.com/ru-ru/library/dn246937(v%3Dsql.120).aspx">BOL</a> , ‚ÄúStored procedures compiled into native code.‚Äù <br>  The body of the procedure is in the BEGIN ATOMIC block from the ANSI SQL standard, and at the moment this is its only use in T-SQL.  It differs from BEGIN TRAN in that it automatically rolls back on an error, while TRY / CATCH and ROLLBACK must be used in a transaction, since  About SET XACT_ABORT ON there are nuances.  The construction options are the TRANSACTION ISOLATION LEVEL = SNAPSHOT |  REPEATABLEREAD |  SERIALIZABLE and LANGUAGE, as which you can use any language from sys.languages.  It defines the date | time format and the language of the system messages. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> dbo.usp_InsertSampleCarts @StartId <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, @InsertCount <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> NATIVE_COMPILATION, SCHEMABINDING, <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> OWNER <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> ATOMIC <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> = N<span class="hljs-string"><span class="hljs-string">'us_english'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @StartId <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @StartId = <span class="hljs-keyword"><span class="hljs-keyword">isnull</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(ShoppingCartId), <span class="hljs-number"><span class="hljs-number">0</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.ShoppingCart <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @i <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHILE</span></span> @i &lt; @InsertCount <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.ShoppingCart <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (@StartId + @i, <span class="hljs-keyword"><span class="hljs-keyword">RAND</span></span>() * <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">GETUTCDATE</span></span>(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @i += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span></code> </pre><br>  Script 2 <br><br>  As in the case of tables, a native compilation takes place for the procedures, which turns the interpreted T-SQL commands into C code and then into machine code, so if we now repeat the query Script 4 from the <a href="http://habrahabr.ru/post/225167/">previous part</a> , we will see that the 3rd dll, corresponding to the newly created procedure. <br><br>  Performance is the key to using objects in memory.  For comparison, we will create a similar stored procedure of the traditional storage method, which will also insert the specified number of records in the same way, but into the disk table: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> dbo.usp_InsertSampleCarts_Disk @StartId <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, @InsertCount <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @StartId <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @StartId = <span class="hljs-keyword"><span class="hljs-keyword">isnull</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(ShoppingCartId), <span class="hljs-number"><span class="hljs-number">0</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.ShoppingCart <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @i <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHILE</span></span> @i &lt; @InsertCount <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> dbo.ShoppingCart_Disk <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (@StartId + @i, <span class="hljs-keyword"><span class="hljs-keyword">RAND</span></span>() * <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">GETUTCDATE</span></span>(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @i += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span></code> </pre><br>  Script 3 <br><br>  And put in and out there with a million entries: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> NOCOUNT <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; DBCC FREEPROCCACHE <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> NO_INFOMSGS; DBCC DROPCLEANBUFFERS <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> NO_INFOMSGS exec dbo.usp_InsertSampleCarts <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span> exec dbo.usp_InsertSampleCarts_Disk @InsertCount = <span class="hljs-number"><span class="hljs-number">1000000</span></span></code> </pre><br><br>  As they say, the difference is obvious: <br><br><img src="//habrastorage.org/files/ca0/f89/e43/ca0f89e43e2a4087b992dcc8780cc7b0.png"><br>  Pic.3 <br><br>  Of the features it should be noted that SQL Server 2014 does not support automatic recompilation of native stored procedures.  The plan is fixed.  Parameter sniffing is not used, all parameters rely unknown.  Instead of recompilation, you may have to delete and recreate the procedure when the data changes (to generate a new plan).  It may be enough recompilation that occurs when the server starts, moves to the backup node, etc.  It is clear that the newer the statistics on the tables, the more correctly the plan will be constructed, and the statistics, as we remember from the first part, are not automatically updated.  Must be done manually using UPDATE STATISTICS or sp_updatestats.  The latter always updates statistics for memory-optimized tables (for normal tables, as needed). <br><br>  From visual things let's see more difference in journaling.  In the classic version, if we write a million records to a table with a nonclustered index (and updates touch some column of this index), we will get two million log entries, which naturally affects the performance.  In addition (write-ahead logging), all of this is put into the log buffer immediately and in loaded systems leads to high competition for the buffer.  In the case of Hekaton, uncommitted transactions are not flushed to disk at all, so there is no need to store undo information or aggressively insert into the log buffer.  Index operations are not logged ‚Äî they are not stored between restarts.  Only one consolidated log entry is created during commit, which contains the necessary information about all the details of the changes, for all the entries affected by the transaction.  We look. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> @lsn <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-number"><span class="hljs-number">46</span></span>) = (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>([<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> LSN]) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.fn_dblog(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) exec dbo.usp_InsertSampleCarts_Disk @InsertCount = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.fn_dblog(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> LSN] &gt; @lsn <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> LSN] <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>([<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Length</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.fn_dblog(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> LSN] &gt; @lsn <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> @lsn = (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>([<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> LSN]) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.fn_dblog(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) exec dbo.usp_InsertSampleCarts <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.fn_dblog(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> LSN] &gt; @lsn <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> LSN] <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>([<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Length</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.fn_dblog(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> LSN] &gt; @lsn</code> </pre><br><br><img src="//habrastorage.org/files/1c2/859/987/1c285998755e4c3783447c5f6676831d.png"><br>  Pic.4 <br><br>  And we see that the insertion of 100 records in the case of in-memory tables is logged in the form of only two log entries of the type LOP_HK (Log Operation Hekaton).  As already noted, these records are consolidated.  You can see what they are really revealed in using the new undocumented function that I borrowed from Kalen Delaney.  As the Current LSN, we set the values ‚Äã‚Äãfrom the corresponding column of the third resultset in Figure 4: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">current</span></span> lsn], [<span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>], operation, operation_desc, tx_end_timestamp, total_size, object_name(table_id) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> TableName <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.fn_dblog_xtp(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> LSN] = <span class="hljs-string"><span class="hljs-string">'00000027:000001dd:0002'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">current</span></span> lsn], [<span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>], operation, operation_desc, tx_end_timestamp, total_size, object_name(table_id) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> TableName <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.fn_dblog_xtp(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> LSN] = <span class="hljs-string"><span class="hljs-string">'00000027:000001dd:0001'</span></span></code> </pre><br><br><img src="//habrastorage.org/files/e7d/782/92a/e7d78292a9224f1b9c2bc5a40f0ec52d.png"><br>  Pic.5 <br><br>  The first record, as we see, consists of 102 records: begin tx, 100 inserts, commit.  Despite this, their total volume (see the second and fourth results of Fig.4) is 10 times more compact than in the case of a disk table.  If you take a non-durable table (DURABILITY = SCHEMA_ONLY), there will be no journaling at all. </div><p>Source: <a href="https://habr.com/ru/post/225935/">https://habr.com/ru/post/225935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225925/index.html">Civilization V with all additions released for Linux</a></li>
<li><a href="../225927/index.html">Devconf 2014 - Laravel practical workshop - for the first time in Russia</a></li>
<li><a href="../225929/index.html">TDD study through intensive practice</a></li>
<li><a href="../225931/index.html">ANGULARJS + REQUIREJS</a></li>
<li><a href="../225933/index.html">IBM received a patent for a new technology to combat Internet fraud</a></li>
<li><a href="../225945/index.html">We kill the "bell" from Google Chrome in the tray</a></li>
<li><a href="../225947/index.html">SwiftKey for Android. Now free</a></li>
<li><a href="../225951/index.html">Google bought Skybox microsatellite company for 500 million</a></li>
<li><a href="../225961/index.html">Managing Mozilla Firefox via GPO</a></li>
<li><a href="../225963/index.html">Attack on the black box. Reverse engineering of virtualized and mutated code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>