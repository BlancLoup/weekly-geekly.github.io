<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagger2 and architectural component "ViewModel"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ViewModel is a component from a set of libraries called Android Architecture Components , which were presented on Google I / O 2017. ViewModel is desi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagger2 and architectural component "ViewModel"</h1><div class="post__text post__text-html js-mediator-article"><p>  ViewModel is a component from a set of libraries called <a href="https://developer.android.com/topic/libraries/architecture/index.html">Android Architecture Components</a> , which were presented on Google I / O 2017. ViewModel is designed to store and manage data associated with the view, as well as the ability to ‚Äúrelive‚Äù the re-creation of activations (for example, flipping the screen). </p><br><p>  On Habr√© was already a good <a href="https://habrahabr.ru/post/334942/">article</a> devoted to the ViewModel, where you can get acquainted with this topic in more detail. </p><br><p> This article will look at the options for injecting (providing) dependencies to the <code>ViewModel</code> component using Dagger 2. The problem is that getting the ViewModel must be done in a special way, which in turn imposes some restrictions that are associated with providing dependencies to the <code>ViewModel</code> class itself, and providing the <code>ViewModel</code> as a dependency.  This article may also be of interest to those interested in the practical application of such Dagger functionality as multibinding. </p><a name="habracut"></a><br><p>  A special way to get the <code>ViewModel</code> is as follows: </p><br><p>  In the beginning, we need to get a <code>ViewModelProvider</code> , which will be associated with an activation or a fragment, and this also determines the lifetime of the <code>ViewModel</code> . </p><br><pre> <code class="java hljs">ViewModelProvider provider = ViewModelProviders.of(&lt;Activity|Fragment&gt;[, ViewModelProvider.Factory]);</code> </pre> <br><p>  The second parameter is used to specify the factory that will be used to create the ViewModel instance; it is not necessary, if we do not specify it, the default factory will be used.  The factory by default supports the creation of instances of classes that are the heirs of the <code>ViewModel</code> (with a constructor without arguments) and classes that are the heirs of the <code>AndroidViewModel</code> (with the designer with one argument - the type <code>Application</code> ). </p><br><p>  If we want to create a <code>ViewModel</code> instance with its own arguments in the constructor (which are not supported by the factory default), then we need to implement our own factory. </p><br><p>  After we got the <code>ViewModelProvider</code> , we can already get the <code>ViewModel</code> : </p><br><pre> <code class="java hljs">ProductViewModel productVM = provider.get(ProductViewModel.class);</code> </pre> <br><p>  From the above description follows: </p><br><ul><li>  To be able to provide dependencies in the <code>ViewModel</code> as constructor arguments, we need to implement our own factory. </li><li>  We can use the default factory, but we can also provide dependencies in the <code>ViewModel</code> using a component that we can get from the Application. </li><li>  In order to get the <code>ViewModel</code> correctly, we need to have access to the activation or a fragment and the retrieval must be done through the <code>ViewModelProviders</code> class. </li></ul><br><p>  There are different ways to provide dependencies in the <code>ViewModel</code> , and each of the methods has its pros and cons, so several options will be considered. </p><br><h4 id="variant-s-fabrikoy-po-umolchaniyu">  Default Factory Option </h4><br><p>  Let's start with the definition of the module and the subcomponent that will be used for the injection into the activit: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivityModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ProductViewModel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">productViewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AppCompatActivity activity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ViewModelProviders.of(activity).get(ProductViewModel.class); } }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Subcomponent</span></span>(modules = {ActivityModule.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivitySubComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Subcomponent</span></span>.Builder <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Builder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@BindsInstance</span></span> <span class="hljs-function"><span class="hljs-function">Builder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">with</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AppCompatActivity activity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ActivitySubComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MainActivity mainActivity)</span></span></span></span>; }</code> </pre> <br><p>  The presence of such a module and a subcomponent allows us to query the model via <code>@Inject</code> instead of <code>ViewModelProviders.of(activity).get(ProductViewModel.class)</code> inside our activit. </p><br><p>  When using the default factory, instances of our <code>ViewModel</code> will be created by this factory and we cannot request dependencies in <code>ViewModel</code> through the designer, so we inject dependencies through the component.  In order not to litter the root component, we will create a subcomponent specifically for the twist of models. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Subcomponent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModelSubComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Subcomponent</span></span>.Builder <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Builder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ViewModelSubComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProductViewModel productViewModel)</span></span></span></span>; }</code> </pre> <br><p>  Define our root component: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = {AppModule.class}) <span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>.Builder <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Builder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@BindsInstance</span></span> <span class="hljs-function"><span class="hljs-function">Builder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withApplication</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Application application)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AppComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } ViewModelSubComponent.<span class="hljs-function"><span class="hljs-function">Builder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewModelSubComponentBuilder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; ActivitySubComponent.<span class="hljs-function"><span class="hljs-function">Builder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activitySubComponentBuilder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  <code>AppModule</code> - will contain the dependencies that our view models need (for example, <code>ProductDetailsFacade</code> ). </p><br><p>  Create an Application that will contain the root component and the subcomponent for the view of models: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> AppComponent appComponent; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ViewModelSubComponent viewModelSubComponent; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(); appComponent = DaggerAppComponent .builder() .withApplication(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .build(); viewModelSubComponent = appComponent .viewModelSubComponentBuilder() .build(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AppComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAppComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> appComponent; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ViewModelSubComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getViewModelSubComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewModelSubComponent; } }</code> </pre> <br><p>  Now we can inject dependencies in the <code>ViewModel</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AndroidViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> ProductFacade productFacade; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProductViewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Application application)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(application); <span class="hljs-comment"><span class="hljs-comment">// ,   . //    ((App)application) .getViewModelSubComponent() .inject(this); } //methods }</span></span></code> </pre> <br><p>  Instead of inject, you can use the provide methods on the component. </p><br><p>  Inject <code>ViewModel</code> in activit: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> ProductViewModel productViewModel; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); <span class="hljs-comment"><span class="hljs-comment">// ,   . //    ((App) getApplication()) .getAppComponent() .activitySubComponentBuilder() .with(this) .build() .inject(this); } }</span></span></code> </pre> <br><p>  The advantages of this method: </p><br><ul><li>  Minimal knowledge of Dagger 2. </li><li>  Only the basic Dagger 2 features are used (can be used on earlier versions of the library). </li><li>  Using the standard factory provided by <code>ViewModel</code> . </li></ul><br><p>  Disadvantages: </p><br><ul><li>  Inject method for each <code>ViewModel</code> (or the availability of a method for each dependency of the component). </li><li>  Inject inside <code>ViewModel</code> . </li></ul><br><h4 id="variant-s-sobstvennoy-fabrikoy">  Option with own factory </h4><br><p>  Create a pair of view models, where we will provide dependencies through the constructor: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> UserFacade userFacade; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserViewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserFacade userFacade)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userFacade = userFacade; } <span class="hljs-comment"><span class="hljs-comment">//methods } public class UserGroupViewModel extends ViewModel { private UserGroupFacade userGroupFacade; @Inject public UserGroupViewModel(UserGroupFacade userGroupFacade) { this.userGroupFacade = userGroupFacade; } //methods }</span></span></code> </pre> <br><p>  We will create our own key annotation, which we will use to make our view of models into the collection for the use of multibinding.  You can read about multibindig <a href="https://habrahabr.ru/post/336414/">here</a> . </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>(ElementType.METHOD) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@MapKey</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> ViewModelKey { Class&lt;? extends ViewModel&gt; value(); }</code> </pre> <br><p>  Define the module where we will be adding our view models to the collection: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModelModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-meta"><span class="hljs-meta">@IntoMap</span></span> <span class="hljs-meta"><span class="hljs-meta">@ViewModelKey</span></span>(UserViewModel.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> ViewModel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userViewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserViewModel userViewModel)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-meta"><span class="hljs-meta">@IntoMap</span></span> <span class="hljs-meta"><span class="hljs-meta">@ViewModelKey</span></span>(UserGroupViewModel.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> ViewModel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groupViewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserGroupViewModel groupViewModel)</span></span></span></span>; }</code> </pre> <br><p>  Let's go over to writing our factory for providing <code>ViewModel</code> using multi-siding: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DemoViewModelFactory</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModelProvider</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Factory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;Class&lt;? extends ViewModel&gt;, Provider&lt;ViewModel&gt;&gt; viewModels; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DemoViewModelFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;Class&lt;? extends ViewModel&gt;, Provider&lt;ViewModel&gt;&gt; viewModels)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewModels = viewModels; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends ViewModel&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; modelClass)</span></span></span><span class="hljs-function"> </span></span>{ Provider&lt;ViewModel&gt; viewModelProvider = viewModels.get(modelClass); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (viewModelProvider == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"model class "</span></span> + modelClass + <span class="hljs-string"><span class="hljs-string">" not found"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) viewModelProvider.get(); } }</code> </pre> <br><p>  <code>Provider&lt;ViewModel&gt;</code> allows us to use delayed initialization with a model view, as well as a new instance model view every time. <br>  Without multi-siding, we could have a huge if / else block. </p><br><p>  <code>Application</code> class: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = {AppModule.class, ViewModelModule.class}) <span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>.Builder <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Builder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@BindsInstance</span></span> <span class="hljs-function"><span class="hljs-function">Builder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withApplication</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Application application)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AppComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MainActivity mainActivity)</span></span></span></span>; }</code> </pre> <br><p>  Providing the <code>ViewModel</code> to our activites: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> DemoViewModelFactory viewModelFactory; UserViewModel userViewModel; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ((App) getApplication()) .getAppComponent() .inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); userViewModel = ViewModelProviders.of(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, viewModelFactory) .get(UserViewModel.class); } }</code> </pre> <br><p>  The advantages of this method: </p><br><ul><li>  We can use <code>@Inject</code> over the constructor in the <code>ViewModel</code> and thereby get the dependencies, and also add the <code>ViewModel</code> to the dependency graph.  No need to write under each twist model inject method. </li><li>  One simple factory for all models. </li><li>  Easy to add a new view of the model in the factory. </li></ul><br><p>  Disadvantages: </p><br><ul><li>  By mistake, you can query the model not through the factory (not via <code>ViewModelProviders.of()</code> , but with <code>@Inject MyViewModel</code> ).  Not quite comfortable getting a view of a model. </li><li>  <code>multibinding  Provider&lt;&gt;</code> version of Dagger. </li></ul><br><p>  If we requested the model via <code>@Inject</code> , then we would simply receive the model instance (because it is already in the dependency graph) and it would not be associated with the activation life cycle or fragment and would not be able to ‚Äúsurvive‚Äù for example, flipping the screen. In order for this to work, we need to create through the factory. <br>  We cannot add a model view to the graph twice  we cannot do the following: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivityModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// , .. UserViewModel     //(@Inject  ) @Provides public UserViewModel productViewModel( DemoViewModelFactory viewModelFactory, AppCompatActivity activity) { return ViewModelProviders .of(activity, viewModelFactory) .get(UserViewModel .class); } }</span></span></code> </pre> <br><p>  To circumvent this limitation, you can enter an interface for the model and request a view of the model on the interface: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivityModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> UserViewModelInterface </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">productViewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DemoViewModelFactory viewModelFactory, AppCompatActivity activity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ViewModelProviders .of(activity, viewModelFactory) .get(ProductViewModelImplementation.class); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> UserViewModelInterface userViewModel; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ((App) getApplication()) .getAppComponent() .activitySubComponentBuilder() .with(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .build() .inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><p>  At the time of this writing, dagger 2.11 and architectural components of version 1.0.0-alpha9 were used.  As you can see, the architectural components at the time of this writing have an alpha version.  Perhaps in the future there will be other methods for obtaining a view of the model. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/337320/">https://habr.com/ru/post/337320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337310/index.html">Mathematical modeling of traffic flows</a></li>
<li><a href="../337312/index.html">11 free cyrillic fonts</a></li>
<li><a href="../337314/index.html">Object to iterate, iterator and generator</a></li>
<li><a href="../337316/index.html">Accidental deletion of root files</a></li>
<li><a href="../337318/index.html">Our way to the green cart</a></li>
<li><a href="../337324/index.html">FullStack 2017 in London: details</a></li>
<li><a href="../337328/index.html">How we taught the Yandex.Taxi application to predict a destination</a></li>
<li><a href="../337330/index.html">What programming language to choose to work with data?</a></li>
<li><a href="../337334/index.html">How to name a brand: 5 options. Choose the best</a></li>
<li><a href="../337336/index.html">About choosing a name for the game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>