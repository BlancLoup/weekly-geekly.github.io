<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Taskurotta or process management in a distributed system</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, habrauzer! 

 We have the task of linking various services and existing systems into managed processes. The speed is needed not by spa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Taskurotta or process management in a distributed system</h1><div class="post__text post__text-html js-mediator-article">  Good afternoon, habrauzer! <br><br>  We have the task of linking various services and existing systems into managed processes.  The speed is needed not by space (that is, not by the response of stock quotes to create a response), but there are a lot of processes and components (systems) that need to be used also appear fairly decent.  I do not want to do p2p binding.  I want something beautiful and manageable. <br><br>  After reviewing the market, it was decided to make a replica based on Amazon Simple Workflow, since we cannot use it directly.  The properties of the framework that suit us: <br><a name="habracut"></a><br><ul><li>  Low threshold of start (a good programmer is expensive now).  The low threshold here is more in terms of the beginning of programming, since everything is done at a high level - almost at the level of interaction with interfaces.  But in order to adequately manage the process asynchronously, one must of course increase the experience </li><li>  When saving the parameters of the tasks and the results of the execution, we get the analysis and the basis for the regression testing of executors of the tasks of the process </li><li>  Concentration of process control logic in specific locations (in the Coordinator).  This may not be obvious at first glance, but this is a great blessing in comparison with a possible alternative, when each actor has his own logic - what other components should be further called up (transfer control).  Often leads to the complexity of the system and the inability to reuse components </li></ul><br>  This is the minimum that I would like, but as practice shows, there are more pluses.  The project was named <a href="http://taskurotta.org/">Taskurotta</a> in honor of ‚ÄúTask‚Äù - a task, and a Finnish gopher, who still does not see, but he is.  Open source is available on <a href="https://github.com/taskurotta">GitHub</a> .  The project was implemented using Hazelcast to form a common memory space and runtime between servers, Dropwizard for fast and convenient implementation of REST services and friends from Amazon who were the first and made an excellent product inspiring us to develop our own.  With the documentation is still difficult, but we will soon fix it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's move from theory to what is now on a real example. <br><br><blockquote>  Suppose we need to develop an application that sends a string message to the user.  At the entrance we get a user id and character set.  From his profile (by Id) we get data about preferences - to receive messages by email or phone number.  Phone number and email are also available in the profile.  Next, send the message to the desired transport.  In case the sending failed (due to a wrong address or number), it is necessary to mark this in the profile to prevent retry attempts in the future. </blockquote><br><br>  Let's add to this non-functional requirement that the services sending messages already exist are on other subnets and need to be reused. <br><br>  PS: All the source code of the example described is also available on the GitHub <a href="https://github.com/taskurotta/taskurotta-getstarted">taskurotta \ taskurotta-getstarted</a> <br><br><br>  Taskurotta allows you to implement system components (Actors) that interact with each other in a way familiar to the developer ‚Äî by calling each other‚Äôs methods, but in an asynchronous manner.  Actors are divided into two types - Performers and Coordinators.  Artists must clearly carry out their tasks.  They are the most independent modules, and accordingly - the most reusable.  Artists can interact with the outside world (any input / output streams) by performing the task in such a way and for as long as required.  On the other hand, the Coordinators do not carry out tasks related to the outside world.  They should work as quickly as possible and not stumble on direct interaction with the database, network and other potentially unstable components.  Their duty is to assign tasks to performers, coordinate their actions and thereby ensure the implementation (description) of the process.  Coordinators can assign tasks to other coordinators, realizing the paradigm of reusable subprocesses. <br><br>  The task of the Coordinator as soon as possible to distribute the currently known tasks.  Those.  it should not be blocked waiting for the result.  It should build dependencies between tasks known to it and, if necessary, form asynchronous points for determining further actions. <br><br>  For our process, the Coordinator should do the following: <br><br><ol><li>  Request a user profile </li><li>  Wait for a profile </li><li>  Send message to user </li><li>  Wait for the departure result </li></ol><br><br>  To encode this sequence of actions with the help of an automaton of states, methods of changing one message by several performers and other usual ones, but in bony ways we will not  We will do it simply and beautifully with the help of the Promise entity and our system that monitors the actions of the Coordinator. <br><br><pre><code class="java hljs">Promise&lt;Profile&gt; profilePromise = userProfileService.get(userId); Promise&lt;Boolean&gt; sendResultPromise = decider.sendToTransport(profilePromise, message);</code> </pre> <br><br>  In the example it is clear that as a result of calling the services we get not a real object, but a certain Promise - a link to the result of the task.  We can pass this Promise as an argument to other services (i.e., tasks).  Calls of other services will be intercepted by the system (i.e. there will be no real synchronous call) and the dependency between them will be built.  Tasks will not be submitted for execution to services until all their Promise arguments are ready, i.e.  until all the necessary preliminary tasks are completed. <br><br>  Thus, the process is managed jointly by the coordinator and our system.  The coordinator builds dependencies between tasks, and the system assumes, among other things, the function of waiting for the execution of preliminary tasks and the subsequent launch of tasks dependent on them. <br><br>  Let's now reveal what asynchronous points determine the next steps. <br><br><blockquote>  We need to make sure that the sending of the notification was successful and if not, then we need to block the sending of notifications to the user. <br></blockquote><br><br>  In this case, after sending the notification and before further action, it is necessary to analyze the result of sending.  Those.  wait for the task to perform, analyze and, depending on the result, block or not.  To solve this problem, the coordinator has the opportunity to create a task for himself ‚Äî that is,  the point of defining further actions to which the necessary Promise should be transferred.  Below is how it looks. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String userId, String message)</span></span></span><span class="hljs-function"> </span></span>{ Promise&lt;Profile&gt; profilePromise = userProfileService.get(userId); Promise&lt;Boolean&gt; sendResultPromise = decider.sendToTransport(profilePromise, message); decider.blockOnFail(userId, sendResultPromise); } <span class="hljs-meta"><span class="hljs-meta">@Asynchronous</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blockOnFail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String userId, Promise&lt;Boolean&gt; sendResultPromise)</span></span></span><span class="hljs-function"> </span></span>{ logger.info(<span class="hljs-string"><span class="hljs-string">".blockOnFail(userId = [{}], sendResultPromise = [{}])"</span></span>, userId, sendResultPromise); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sendResultPromise.get()) { userProfileService.blockNotification(userId); } }</code> </pre><br><br>  The start () method is the start of the process.  Next comes the setting of three tasks.  The first to receive the profile, the second and the third Coordinator sets himself for further analysis of the result (calling the sendToTransport and blockOnFail methods).  Thus, the Coordinator is waiting for the solution of the first task, but without blocking.  As soon as the task is solved, the Taskurotta system calls the coordinator's sendToTransport method, passing to it a ready-made Promise object, from which real data can be obtained using the get () method.  After the sendToTransport task is completed, the blockOnFail task is started where we set the task for the userProfileService service to block messages for the userId if an error occurred while sending a notification. <br><br>  Using the points for defining further actions, you can implement various process behaviors: <br><ul><li>  Parallelization to different branches </li><li>  Further merging of independent process streams at one point using Promise and @NoWait annotations </li><li>  Asynchronous recursion </li><li>  Parallelization of the execution of similar tasks, for example, verifying the EDS of all files and waiting for the results of execution at one decision point </li><li>  etc. </li></ul><br>  PS: The blockOnFail task is called through the decider object.  This is an artificial object that intercepts the call, but does not really call the blockOnFail method.  We need to set a task, and not to call it synchronously. <br><br>  Since according to the scenario we already have the Contractors for sending email and sms, we can only create the Contractor for working with the profile.  This Contractor has two tasks: <br><br><ol><li>  Return the profile by user ID </li><li>  Make a mark in the profile about the impossibility of sending messages for a specific user </li></ol><br><br>  We start by declaring its interface.  Coordinator will work with this interface.  Hereinafter, for compactness, comments and other non-essential parts of the code are omitted. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Worker</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Profile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String userId)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blockNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String userId)</span></span></span></span>; }</code> </pre><br><br>  The <code>@Worker</code> defines this interface as the Contractor.  An annotation has optional attributes defining its name and version (of a contract).  By default, the name is the full name of the interface, and the version is ‚Äú1.0‚Äù.  Performers of different versions can work simultaneously for different processes without any conflicts. <br><br>  Let us turn to the implementation of the interface. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileServiceImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(UserProfileServiceImpl.class); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Profile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String userId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProfileUtil.createRandomProfile(userId); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blockNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String userId)</span></span></span><span class="hljs-function"> </span></span>{ logger.info(<span class="hljs-string"><span class="hljs-string">".blockNotification(userId = [{}]"</span></span>, userId); } }</code> </pre><br><br>  Here we have lowered the initialization of the profile manager (ProfileUtil).  It can work with DB, LDAP or other registry.  This example shows us that the Contractor receives tasks (calls) and delegates them to the real module. <br><br>  This completes the creation of the Contractor. <br><br>  To solve the task set before us, the Coordinator must send a link to the user profile that has not yet been received (the Promise object) to the point where the next steps will be determined.  There he will choose a transport or will not send anything if the sending of messages for this user is already blocked. <br><br>  However, the executor interface, like the executor himself, receives and delivers the result synchronously, and therefore does not have the execution results in the declaration in the form of a Promise object, but returns a clean data object.  This is right.  The performer does not need to know how to use it.  For example, our Contractor for obtaining a profile can be used if the user ID is already known, or if it is not known and you need to send a link to another task that receives this ID from somewhere.  Thus, we come to the interface of interaction with the Contractor.  This interface is defined by the Coordinator himself for his needs.  Those.  it is defined in the package (project) of the Coordinator.  Add an interface with the Contractor to work with the profile: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@WorkerClient</span></span>(worker = UserProfileService.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileServiceClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Promise&lt;Profile&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String userId)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blockNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String userId)</span></span></span></span>; }</code> </pre><br><br>  We see an interface annotated with <code>@WorkerClient</code> .  The annotation parameter refers to the class of the real interface of the Contractor.  In this way, a connection is established between the existing interface and the required interface for a specific Coordinator.  Let's call this interface the ‚ÄúContractor‚Äôs client interface‚Äù.  This client interface must contain all the methods necessary for the coordinator (you can not declare not used) and with the identical signature of the arguments.  Any argument can be a type of Promise, if you want to pass the result of an unfinished task as an argument. <br><br>  Now we come to the most interesting - the creation of a coordinator.  First, the coordinator interface is presented below, using which Taskurotta customers will run the processes they need. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Decider</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotificationDecider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Execute</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String userId, String message)</span></span></span></span>; }</code> </pre><br><br>  This interface is defined as <code>@Decider</code> ‚Äî i.e.  as the coordinator.  This annotation has the same properties as the <code>@Worker</code> annotation ‚Äî the name and version.  By default, the full name of the interface is taken as the name, and the version is ‚Äú1.0‚Äù. <br><br>  The start method is marked as <code>@Execute</code> .  This means that through this method you can start the process. <br><br>  Now go to the implementation coordinator <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotificationDeciderImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotificationDecider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(NotificationDeciderImpl.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> UserProfileServiceClient userProfileService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MailServiceClient mailService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SMSServiceClient smsService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NotificationDeciderImpl decider; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String userId, String message)</span></span></span><span class="hljs-function"> </span></span>{ logger.info(<span class="hljs-string"><span class="hljs-string">".start(userId = [{}], message = [{}])"</span></span>, userId, message); Promise&lt;Profile&gt; profilePromise = userProfileService.get(userId); Promise&lt;Boolean&gt; sendResultPromise = decider.sendToTransport(profilePromise, message); decider.blockOnFail(userId, sendResultPromise); } <span class="hljs-meta"><span class="hljs-meta">@Asynchronous</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Promise&lt;Boolean&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendToTransport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Promise&lt;Profile&gt; profilePromise, String message)</span></span></span><span class="hljs-function"> </span></span>{ logger.info(<span class="hljs-string"><span class="hljs-string">".sendToTransport(profilePromise = [{}], message = [{}])"</span></span>, profilePromise, message); Profile profile = profilePromise.get(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (profile.getDeliveryType()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SMS: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> smsService.send(profile.getPhone(), message); } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EMAIL: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mailService.send(profile.getEmail(), message); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.asPromise(Boolean.TRUE); } <span class="hljs-meta"><span class="hljs-meta">@Asynchronous</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blockOnFail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String userId, Promise&lt;Boolean&gt; sendResultPromise)</span></span></span><span class="hljs-function"> </span></span>{ logger.info(<span class="hljs-string"><span class="hljs-string">".blockOnFail(userId = [{}], sendResultPromise = [{}])"</span></span>, userId, sendResultPromise); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sendResultPromise.get()) { userProfileService.blockNotification(userId); } } }</code> </pre><br><br>  In this code, we also lowered the initialization of private objects.  The complete and working example code can be viewed in the <a href="https://github.com/taskurotta/taskurotta-getstarted">taskurotta-getstarted project</a> .  Here we just note that the values ‚Äã‚Äãof private fields are obtained through a special factory of proxies of objects for the Coordinator. <br><br>  In the sample implementation, there are two waiting points for the results of the implementation of unfinished tasks by the coordinator.  This is the sendToTransport and blockOnFail method.  These methods will only be called when all their Promise arguments are ready, <br>  those.  completed the corresponding tasks. <br><br>  Field objects of the type MailServiceClient and SMSServiceClient are also client interfaces to the respective Contractors.  Their initialization can also be viewed in the taskurotta-getstarted project. <br><br>  At the moment we have all the Implemented Performers and the Coordinator.  Let's proceed directly to the launch of the Actors (i.e. Performers and Coordinators). <br><br>  Tasks can be executed both inside application servers and as a separate java application (this example uses the version of a separate application from the taskurotta \ bootstrap module).  What a separate application does: <br><br><ul><li>  It is registered on the Taskurotta server. </li><li>  Runs a pool of N threads to perform tasks. </li><li>  Receives tasks from Taskurotta servers </li><li>  Runs their execution </li><li>  Sends result to Taskurotta server </li></ul><br><br>  To launch a separate java application, the bootstrap package is used, and more specifically, the ru.taskurotta.bootstrap.Main class is used.  As an argument, it needs to pass the location of the configuration file in YAML format. <br><br>  How to try to run it?  Very simple.  Below is a step-by-step build of the server, the actors and their launch from the source code.  Be careful, minor changes are necessary if you do not have linux. <br><br>  Suppose you already have: <br><ul><li>  jdk 1.7 </li><li>  maven 3 </li><li>  git </li></ul><br><br>  we will collect the Taskurotta server <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/taskurotta/taskurotta.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> taskurotta/</code> </pre><br><br>  Run the build.  To speed up disable tests. <br><br><pre> <code class="bash hljs">mvn clean install -DskipTests</code> </pre><br><br>  Now we will launch a cluster of two nodes (we use one machine for demonstration purposes and therefore different ports in the launch parameters).  In a real environment, you can run the required number of machines with the same configuration. <br><br>  We start the first cluster node: <br><br><pre> <code class="bash hljs">java -Xmx64m -Ddw.http.port=8081 -Ddw.http.adminPort=9081 -Ddw.logging.file.currentLogFilename=<span class="hljs-string"><span class="hljs-string">"assemble/target/server1.log"</span></span> -jar assemble/target/assemble-0.4.0-SNAPSHOT.jar server assemble/src/main/resources/hz.yml</code> </pre><br><br>  We start the second node (We intentionally limit the memory in order to detect its possible leaks at an early stage. In the configuration of this example, no database is used, so more memory is needed for large volumes). <br><br><pre> <code class="bash hljs">java -Xmx64m -Ddw.http.port=8082 -Ddw.http.adminPort=9082 -Ddw.logging.file.currentLogFilename=<span class="hljs-string"><span class="hljs-string">"assemble/target/server2.log"</span></span> -jar assemble/target/assemble-0.4.0-SNAPSHOT.jar server assemble/src/main/resources/hz.yml</code> </pre><br><br>  When both servers connect to each other, the log will look like this message: <br><br><pre> <code class="bash hljs"> Members [2] { Member [192.168.1.2]:7777 Member [192.168.1.2]:7778 this }</code> </pre><br><br>  Open the console in the browser.  <a href="http://localhost:8081/index.html">http: // localhost: 8081 / index.html</a> - the first node or <a href="http://localhost:8082/index.html">http: // localhost: 8082 / index.html</a> - the second node. <br><br>  You can use any node to work with the console.  They display mostly the same information.  Currently, not all console functions function in this configuration (without a database).  Everything works in configuration with oracle and mongodb.  See the deployment options in the <a href="http://taskurotta.org/">documentation</a> . <br><br>  Now let's run our process.  We clone taskurotta-getstarted repository for this. <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/taskurotta/taskurotta-getstarted.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> taskurotta-getstarted/ mvn clean install</code> </pre><br><br>  In order for the actors to start working, it is necessary to start the processes.  Run them for example 91 pieces. <br><br><pre> <code class="bash hljs">java -cp target/getstarted-process-1.0-SNAPSHOT.jar ru.taskurotta.example.starter.NotificationModule http://localhost:8081 91</code> </pre><br><br>  Check in the console <a href="http://localhost:8081/index.html">http: // localhost: 8081 / index.html</a> .  Select the "Queues" tab.  We will see that the coordinator has 91 tasks, which corresponds to the 91st running process. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/ac0/7be/98bac07be4e61e17adfde316fc8bb652.jpg" alt="image"><br><br>  Now run the coordinator.  In the YAML configuration file, only he is defined - without executors.  Therefore, after the launch, all the tasks of the process will not be completed and we will see the tasks of the performers standing in line. <br><br><pre> <code class="bash hljs">java -Xmx64m -jar target/getstarted-process-1.0-SNAPSHOT.jar -f src/main/resources/config-decider.yml</code> </pre><br><br>  In the configuration file, the first node of our cluster is defined as the Taskurotta server for the coordinator <br><br><pre> <code class="markdown hljs"> spreader: - Spreader: class: ru.taskurotta.example.bootstrap.SimpleSpreaderConfig instance: endpoint: "http://localhost:8081" threadPoolSize: 10 readTimeout: 0 connectTimeout: 3000</code> </pre><br><br>  You can update the list of queues in the console and see that there are tasks awaiting executors. <br><br>  Now let's run the executors (leave the coordinator to work) and for demonstration we will send them to the second node of the cluster.  Since the cluster nodes form a shared memory and an environment for performing internal tasks, it does not matter which server will receive a request from the executor. <br><br><pre> <code class="bash hljs">java -Xmx64m -jar target/getstarted-process-1.0-SNAPSHOT.jar -f src/main/resources/config-workers.yml</code> </pre><br><br>  The executors have the second cluster node for interaction: <br><br><pre> <code class="markdown hljs"> spreader: - Spreader: class: ru.taskurotta.example.bootstrap.SimpleSpreaderConfig instance: endpoint: "http://localhost:8082" threadPoolSize: 10 readTimeout: 0 connectTimeout: 3000</code> </pre><br><br>  As a result, all processes must fully work out and this is evident from the queues in the management console. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e2b/704/44d/e2b70444d6369303bc90c53801232b61.jpg" alt="image"><br><br>  So far, and all what I would like to share at the moment.  We will welcome suggestions and constructive criticism. </div><p>Source: <a href="https://habr.com/ru/post/206188/">https://habr.com/ru/post/206188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206172/index.html">Ten major events of 2013</a></li>
<li><a href="../206178/index.html">Cloud hosting for a simple site</a></li>
<li><a href="../206180/index.html">Dell Powervault MD3 Storage Arrays</a></li>
<li><a href="../206182/index.html">Transformation of threats in the information space: from technological to social. Part II</a></li>
<li><a href="../206186/index.html">Open Terminal Client - First Step</a></li>
<li><a href="../206192/index.html">DIY mini-desktop</a></li>
<li><a href="../206198/index.html">A passion for programming. Chapter 10. Fall in Love or Throw It</a></li>
<li><a href="../206200/index.html">Video calls through the browser - how to make technology work for your company</a></li>
<li><a href="../206202/index.html">Skeptics list</a></li>
<li><a href="../206204/index.html">How we created the single on Ubuntu Studio 13.10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>