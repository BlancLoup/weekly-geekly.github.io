<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java and time: part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is written in continuation of the first part and is devoted to the new Date Time API , which was introduced in Java 8. I initially wanted...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java and time: part two</h1><div class="post__text post__text-html js-mediator-article">  This article is written in continuation of the <a href="http://habrahabr.ru/post/274811/">first part</a> and is devoted to the <a href="https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html">new Date Time API</a> , which was introduced in Java 8. I initially wanted to arrange this topic separately, because it is quite large and serious.  I myself have not fully started to use this API in projects, so we will understand together along the way.  In principle, there is no urgent need to switch to the new API, moreover, many have not yet started Java 8 projects, which means that there is still time to master. <br><br>  In the article I will try not to slip into the banal translation of regular documentation, I would like to concentrate more on what seemed to me especially important. <br><a name="habracut"></a><br><h1>  Story </h1><br>  As for working with time, there have been complaints about the standard Java library for a long time.  The criticized version of the API was developed a very long time ago and when designing it, serious mistakes were made.  Alternatively, many have used the third-party Joda-time library.  I myself am not a very big fan of Joda-time for several reasons: <br><ul><li>  the standard library classes cannot be avoided anyway, in 99% of cases their functionality copes with the task, but I don‚Äôt want to multiply entities beyond necessity; </li><li>  The joda-time library does not use the standard database of time zones from the JVM, so during the next maneuver, legislators have to remember that you need to update tzdata not only in JDK, but <a href="http://joda-time.sourceforge.net/tz_update.html">also in joda-time</a> . </li></ul><br><h1>  Comparison </h1><br>  It‚Äôs probably worth starting with the fact that it didn‚Äôt suit many in the old API.  And right there, in order not to waste time, I will immediately indicate that the new API has changed for the better. <br><br>  Dividing classes into packages: <br><ul><li>  In the old API, classes for working with time are wrapped in java.util and java.sql packages - among a large number of other classes.  In addition, there are also java.util.concurrent.TimeUnit and java.text.DateFormat classes with successors. </li><li>  In the new API, a separate java.time package is allocated for working with time. </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Class Names: <br><ul><li>  The names of the classes in the old API do not reflect the essence of what is happening.  In the old API there are two classes that can mark a point on the time axis: java.util.Date and java.util.Calendar.  The java.util.Date class denotes the time in milliseconds on Unix-time, and not the date at all (it is so named because of the same reasons that the time on the command line is issued by the / bin / date utility).  The java.util.Calendar class is also not a calendar at all, it has a state in the form of a time zone, calendar and temporary fields. </li><li>  In the new API, class names are given more meaningfully.  There are classes similar to those already mentioned: java.time.Instant and java.time.ZonedDateTime.  There are also many other classes for more specialized use. </li></ul><br><br>  Immutability and thread safety: <br><ul><li>  The java.util.Date class is not immutable and is burdened by a large number of unnecessary methods that, although already marked as obsolete, are unlikely to be removed in the foreseeable future.  The mutability of java.util.Date causes some to clone the instances of java.util.Date ‚Äî so that the enemy does not get through: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserBean</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Date created; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date created)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.created = (Date) created.clone(); } }</code> </pre> <br>  The java.util.Calendar class is also modifiable.  Although this does not cause any special problems, since the majority understands that it has an internal state that is changing, and it is somehow not very accepted to pass it on to arguments. <br><br>  Since the classes in the old API are editable, you need to use them in a multi-threaded environment with caution.  In particular, java.util.Date can be recognized as ‚Äúefficiently‚Äù thread-safe if you don‚Äôt call its obsolete methods. <br><br></li><li>  All classes in the new API are immutable and as a result flow-safe. </li></ul><br><br>  Accuracy: <br><ul><li>  Representation accuracy in time is one millisecond.  For most practical tasks, this is more than enough, but sometimes you want to have higher accuracy. </li><li>  The new API submission time is one nanosecond, which is a million times more accurate. </li></ul><br><br>  Store time and date stamps: <br><ul><li>  Classes for time and date stamps (java.sql.Date and java.sql.Time) are not a pure representation of time and date stamps, because they are inherited from java.util.Date and in one way or another store the full Unix-time value with ignoring part of it. values. </li><li>  In the new API, the corresponding java.time.LocalDate and java.time.LocalTime classes store clean tuples (yyyy, MM, dd) and (HH, mm, dd), respectively, and there is no unnecessary information or logic in these classes.  Also introduced is the java.time.LocalDateTime class which stores both tuples. </li></ul><br><br>  Specify time zone: <br><ul><li>  In the old API, many actions where an indication of a time zone is necessary can be performed without specifying it.  In this case, the time zone is taken by default, and the programmer may not even guess that he missed something. </li><li>  In the new API, all actions where an indication of a time zone is necessary require it explicitly: either as a method argument or the time zone is displayed directly in the method name.  In other words, the default time zone is nowhere used by default. </li></ul><br><br>  Testing: <br><ul><li>  The old API is very difficult to use in tests in which you need to test the behavior of logic over time (this is described in detail in the previous article). </li><li>  The new API introduced a special abstract class java.time.Clock, a single instance of which can be injected into the context or simply passed to its logic.  By redefining this class for tests, you can control the flow of time for your code during its execution. </li></ul><br><br>  Month numbering: <br><ul><li>  In the old API, the month numbers come with 0, which is very unintuitive. </li><li>  In the new API, the numbers of months come with 1. A new <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Month.html">java.time.Month</a> enumeration has <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Month.html">appeared</a> . </li></ul><br><br>  Tagging: <br><ul><li>  In java.util.Calendar set the year-month-day-hour-minute-second, but to reset the milliseconds it was necessary to make a separate call. </li><li>  In java.time.ZonedDateTime, all fields are set at once, including nanoseconds. </li></ul><br><br>  Duration designation: <br><ul><li>  In the old API, there are no classes for defining duration and time intervals.  Typically, simple long and storage durations are used in the form of milliseconds. </li><li>  The new API defines special classes for duration and periods. </li></ul><br><h1>  Fears </h1><br>  It‚Äôs also probably worth telling that I‚Äôm definitely not going to call it ‚Äúimpairment,‚Äù but I‚Äôll carefully call it ‚Äúapprehension‚Äù: <br><ul><li>  If earlier there were two actively used classes: java.util.Date and java.util.Calendar, now there are more classes, plus a hierarchy of interfaces and abstract classes has been added to them. </li><li>  Partly because of the large number of new classes, some nuances of work appeared that I managed to find in just a few hours of research and which we will talk about later. </li><li>  The new API does not control the correctness of operations in compile-time.  Many problems with the lack of a time zone will only appear in runtime - as will be seen later in the examples.  I would prefer a less flexible but more stringent contract. </li><li>  during the work, a greater number of objects are generated.  For example, retrieving the current time point via Instance.now () besides the java.time.Instance instance itself creates another java.time.Clock for each request, although this is not good at all - in the current implementation it would be enough to call System.currentTimeMillis ( ).  Also, intermediate objects are created with many other actions.  But I do not think that for a typical backend this will present any problem - neither memory consumption nor execution time.  Hardcore players still keep time for a long time or even pack it in an int. </li><li>  the problem (is it a problem?) with regard to leap second was not solved at all.  In fact, the new library still does not go a step further from Unix-time and relies on the external translation of the second hand back.  At the same time, the past still loses a second each time and moves forward.  We have not received the library for accurate scientific calculations. </li></ul><br><br>  I will tell you more about these and other cases that alerted me in the examples. <br><br><h1>  Time zones </h1><br>  Let's start as usual with time zones.  The new <a href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html">java.time.ZoneId</a> class denotes a time zone.  Its two subclasses java.time.ZoneRegion and <a href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneOffset.html">java.time.ZoneOffset</a> implement two types of time zones: a time zone according to geographic principle and a time zone according to a simple offset from UTC, UT or GMT.  The translation rules for arrows are placed in a separate <a href="https://docs.oracle.com/javase/8/docs/api/java/time/zone/ZoneRules.html">java.time.zone.ZoneRules</a> class, an instance of which is available through the java.time.ZoneId # getRules method. <br><br>  In general, besides the specified refactoring, I did not find any special fundamental changes here, except that the rules for translating arrows now provide more methods for requesting information.  Therefore, everything written in the <a href="http://habrahabr.ru/post/274811/">old article</a> is also valid for new classes of temporary zones, except that the methods differ somewhat in name. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testZoneId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// case-1 ZoneId zid1 = ZoneId.of("Europe/Moscow"); Assert.assertEquals("ZoneRegion", zid1.getClass().getSimpleName()); // case-2 ZoneId zid2 = ZoneId.of("UTC+4"); Assert.assertEquals("ZoneRegion", zid2.getClass().getSimpleName()); // case-3 ZoneId zid3 = ZoneId.of("+03:00:00"); Assert.assertEquals("ZoneOffset", zid3.getClass().getSimpleName()); // case-4 ZoneId zid4 = ZoneId.ofOffset("UTC", ZoneOffset.of("+03:00:00")); Assert.assertEquals("ZoneRegion", zid4.getClass().getSimpleName()); }</span></span></code> </pre><br><br>  It is not very clear why case-4, which actually requests the same as case-3, creates java.time.ZoneRegion as a result, and not java.time.ZoneOffset. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testZoneUTC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ZoneId zid1 = ZoneOffset.UTC; Assert.assertEquals(<span class="hljs-string"><span class="hljs-string">"ZoneOffset"</span></span>, zid1.getClass().getSimpleName()); ZoneId zid2 = ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Z"</span></span>); Assert.assertEquals(<span class="hljs-string"><span class="hljs-string">"ZoneOffset"</span></span>, zid2.getClass().getSimpleName()); Assert.assertSame(ZoneOffset.UTC, zid2); ZoneId zid3 = ZoneId.of(<span class="hljs-string"><span class="hljs-string">"UTC"</span></span>); Assert.assertEquals(<span class="hljs-string"><span class="hljs-string">"ZoneRegion"</span></span>, zid3.getClass().getSimpleName()); }</code> </pre><br><br>  For the UTC time zone, a special constant java.time.ZoneOffset # UTC has been entered, but nevertheless the request for ZoneId.of (‚ÄúUTC‚Äù) in the new API already produces an object of class java.util.ZoneRegion, and not this constant. <br><br><h1>  Clock </h1><br>  " <a href="http://phoenix.dubna.ru/el-bib/sazonov/saz-html/saz-2.htm">Time is a clock</a> " - as claimed by some physicists.  And this phrase is the key to the new API, where the <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Clock.html">java.time.Clock</a> class is the cornerstone.  And just like some of our watches, time for us can be: constant (non-existent), late, running with varying degrees of accuracy, moving the hands differently in different time zones.  In general, in the new API, you can use (or define yourself) practically any course of time, including for testing tests. <br><br>  A standard java.time.Clock instance can be created only by factory static methods (the class itself is abstract). <br><br>  A standard java.time.Clock instance always knows about the time zone in which it was created (although this is sometimes unnecessary). <br><br>  Let's go through the factory methods: <br><ul><li>  java.time.Clock # systemDefaultZone - the method creates a system clock in the time zone by default. </li><li>  java.time.Clock # systemUTC - the method creates a system clock in the UTC time zone. </li><li>  java.time.Clock # system - the method creates a system clock in the specified time zone. </li><li>  java.time.Clock # fixed - the method creates a clock of constant time, that is, the clock does not go, but stands still. </li><li>  java.time.Clock # offset - method creates a proxy over the specified clock, which shifts time by the specified value. </li><li>  java.time.Clock # tickSeconds - the method creates a system clock in the specified time zone, the value of which is rounded to whole seconds. </li><li>  java.time.Clock # tickMinutes - the method creates a system clock in the specified time zone, the value of which is rounded to full minutes. </li><li>  java.time.Clock # tick - the method creates a proxy over the specified clock, which rounds the time to the specified period. </li><li>  java.time.Clock # withZone - the method creates a copy of the current clock in another time zone. </li></ul><br><br>  You can override <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Clock.html">java.time.Clock</a> and write any logic of time output, for example, a clock that gives random time for each request, why not? <br><br>  The java.time.Clock object has only three working methods: <br><ul><li>  java.time.Clock # getZone - request the time zone in which the clock operates. </li><li>  java.time.Clock # millis - request the current time in milliseconds on Unix-time </li><li>  java.time.Clock # instant - request the current time in the most general sense (in fact - in nanoseconds on Unix-time) </li></ul><br><br>  Now a little criticism: <br><ul><li>  I would start a clean java.time.Clock interface and a separate factory java.time.Clocks - but I do not insist. </li><li>  For some reason, the time zone is necessarily imposed on the clock.  The clock itself is not needed at all: neither java.time.Clock # millis, nor java.time.Clock # instant is used.  The time zone of the clock is requested in the factory methods {Zoned, Local, Offset} DateTime, but it was there that could be transferred as a separate parameter in the method, and not stored in ballast in java.time.Clock. </li><li>  Unfortunately, there is no MockClock class for manual time management for tests, you have to write it yourself - this is not a problem, but it would be better if it were right away. </li><li>  The clock does not have a java.time.Clock # ticks method for measuring timeless nanosecond ticks (similar to java.lang.System # nanoTime).  On the one hand, the absence of such a method is understandable, because it does not apply to the calculation of time.  But on the other hand, it refers to the measurement of the duration of operations.  Therefore, for managing timeless ticks (and measuring duration accordingly) in tests it would be nice if the method for ticks were also in this interface, if only because the manual advance of time in MockClock by default would promote both ticks and time . </li></ul><br><br><h1>  Instant </h1><br>  <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html">java.time.Instant</a> is the new java.util.Date, only immutable, with nanosecond precision and the correct name.  Inside it stores <a href="https://ru.wikipedia.org/wiki/UNIX-%25D0%25B2%25D1%2580%25D0%25B5%25D0%25BC%25D1%258F">Unix-time</a> in the form of two fields: long with the number of seconds, and int with the number of nanoseconds within the current second. <br><br>  The value of both fields can be requested directly, and you can also ask to calculate the Unix-time representation that is more familiar to the old API in the form of milliseconds: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testInstantFields</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Instant instant = Clock.systemDefaultZone().instant(); System.out.println(instant.getEpochSecond()); System.out.println(instant.getNano()); System.out.println(instant.toEpochMilli()); }</code> </pre><br><br>  As well as java.util.Date (if used correctly), an object of the java.time.Instant class does not know anything about the time zone. <br><br>  Separately it is necessary to say about the java.time.Instant.toString () method.  If earlier java.util.Date.toString () worked taking into account the current locale and the default time zone, the new java.time.Instant.toString () always forms a textual representation in the UTC time zone and the same ISO-8601 format - this applies and output variables in the IDE when debugging: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testInstantString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Instant instant1 = Clock.system(ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Paris"</span></span>)).instant(); System.out.println(instant1.toString()); Instant instant2 = Clock.systemUTC().instant(); System.out.println(instant2.toString()); Instant instant3 = Clock.systemDefaultZone().instant(); System.out.println(instant3.toString()); }</code> </pre><br><pre> 2016-01-06T15: 22: 53.403Z
 2016-01-06T15: 22: 53.417Z
 2016-01-06T15: 22: 53.423Z
</pre><br><br><h1>  Basic interfaces </h1><br>  Let's look at the basic <a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html">java.time.temporal.TemporalAccessor</a> interface.  The TemporalAccessor interface is a directory for requesting individual partial information on the current point or label and all temporary classes of the new API implement it. <br><br>  Ask for the Unix-time value of java.time.Instant: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span>(expected = DateTimeException.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testTemporalAccessor2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ TemporalAccessor ta = Clock.systemUTC().instant(); <span class="hljs-comment"><span class="hljs-comment">// java.time.DateTimeException: Invalid value for InstantSeconds \ // (valid values -9223372036854775808 - 9223372036854775807): 1451983908 System.out.println(ta.get(ChronoField.INSTANT_SECONDS)); }</span></span></code> </pre><br><br>  We get an exception with a completely inexplicable message: <br><pre> java.time.DateTimeException: Invalid value for InstantSeconds \
                          (valid values ‚Äã‚Äã-9223372036854775808 - 9223372036854775807): 1451983908
</pre><br><br>  After a bit of a jogging, the reason for the exception becomes clear: theoretically, the result may not fit into the int range (although it currently fits).  The INSTANT_SECONDS field must be requested as long.  We will correct the request, along the way we will request additional meta-information: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testTemporalAccessor3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ TemporalAccessor ta = Clock.systemUTC().instant(); System.out.println(ta.getLong(ChronoField.INSTANT_SECONDS)); ValueRange vr = ta.range(ChronoField.INSTANT_SECONDS); System.out.println(vr.getMinimum()); System.out.println(vr.getMaximum()); System.out.println(ta.isSupported(ChronoField.INSTANT_SECONDS)); System.out.println(ta.isSupported(ChronoField.CLOCK_HOUR_OF_DAY)); }</code> </pre><br><pre> 1452094053
 -9223372036854775808
 9223372036854775807
 true
 false
</pre><br><br>  The CLOCK_HOUR_OF_DAY field is not supported by the Instant type.  This is completely expected, since to find out the hour of the day at a time point we need to specify a time zone, which is not in java.time.Instant.  Let's try all the same to request this value: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span>(expected = UnsupportedTemporalTypeException.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testTemporalAccessor1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ TemporalAccessor ta = Clock.systemUTC().instant(); <span class="hljs-comment"><span class="hljs-comment">// java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: ClockHourOfDay System.out.println(ta.getLong(ChronoField.CLOCK_HOUR_OF_DAY)); }</span></span></code> </pre><br><br>  That's right - when we request an hour of the day, we get an exception.  It's great that the request method did not use the default time zone (which is not in the new API). <br><br>  In addition to querying individual fields, you can query values ‚Äã‚Äãusing more complex algorithms-strategies that inherit the <a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalQuery.html">java.time.TemporalQuery</a> interface: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testTemporalAccessor4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ TemporalAccessor ta = Clock.systemUTC().instant(); ZoneId zoneId1 = ta.query(TemporalQueries.zone()); ZoneId zoneId2 = TemporalQueries.zone().queryFrom(ta); Assert.assertEquals(zoneId1, zoneId2); TemporalUnit unit1 = ta.query(TemporalQueries.precision()); TemporalUnit unit2 = TemporalQueries.precision().queryFrom(ta); Assert.assertEquals(unit1, unit2); }</code> </pre><br><br>  <a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html">java.time.temporal.Temporal</a> - the interface is a successor of the TemporalAccessor interface.  Enters forward and backward point / tag shift operations, the operation of replacing a portion of temporal information, as well as the operation to calculate the distance to another time point / mark.  It is implemented by almost all the ‚Äúfull-fledged‚Äù temporary classes of the new API. <br><br>  We try to move the label a day ahead and calculate the difference: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testTemporal1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Temporal t1 = Clock.systemUTC().instant(); Temporal t2 = t1.plus(<span class="hljs-number"><span class="hljs-number">1</span></span>, ChronoUnit.DAYS); Assert.assertEquals(Duration.ofDays(<span class="hljs-number"><span class="hljs-number">1</span></span>).getSeconds(), t2.getLong(ChronoField.INSTANT_SECONDS) - t1.getLong(ChronoField.INSTANT_SECONDS)); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">24</span></span>, t1.until(t2, ChronoUnit.HOURS)); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">24</span></span>, Duration.between(t1, t2).get(ChronoUnit.HOURS)); }</code> </pre><br><br>  Since all classes have finally become immutable, the results of the operations must not be forgotten to be assigned to another variable, since the original does not change during the operation - everything is the same as java.lang.String or java.math.BigDecimal. <br><br>  Let's try to change the hour of the day in java.time.Instant: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span>(expected = UnsupportedTemporalTypeException.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testTemporal2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Temporal t = Clock.systemUTC().instant(); <span class="hljs-comment"><span class="hljs-comment">// java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: HourOfDay t.with(ChronoField.HOUR_OF_DAY, 2); }</span></span></code> </pre><br><br>  Expectedly we get our hands, because a time zone is necessary for this operation. <br><br>  <a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html">java.time.temporal.TemporalAdjuster</a> - interface of the time point / tag correction strategy, for example, moving on the first day of the current code.  Previously, you had to write your own auxiliary classes for working with java.util.Calendar fields - now you can put all the code in the form of a strategy, if you don‚Äôt have it yet in the standard delivery: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testTemporalAdjuster</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ZonedDateTime zdt = ZonedDateTime.of(<span class="hljs-number"><span class="hljs-number">2005</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>)); ZonedDateTime zdt1 = zdt.with(TemporalAdjusters.firstDayOfYear()); ZonedDateTime zdt2 = (ZonedDateTime) TemporalAdjusters.firstDayOfYear().adjustInto(zdt); Assert.assertEquals(zdt1, zdt2); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">2005</span></span>, zdt1.get(ChronoField.YEAR)); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">1</span></span>, zdt1.get(ChronoField.MONTH_OF_YEAR)); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">1</span></span>, zdt1.get(ChronoField.DAY_OF_MONTH)); }</code> </pre><br><br>  Now you can go to the temporary classes. <br><br><h1>  LocalTime, LocalDate, LocalDateTime </h1><br>  <a href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalTime.html">java.time.LocalTime</a> is a tuple (hour, minute, second, nanosecond) <br>  <a href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html">java.time.LocalDate</a> is a tuple (year, month, day of month) <br>  <a href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html">java.time.LocalDateTime</a> - both tuples together <br><br>  I would also <a href="https://docs.oracle.com/javase/8/docs/api/java/time/MonthDay.html">refer</a> specific classes for storing a part of information to the same classes: <a href="https://docs.oracle.com/javase/8/docs/api/java/time/MonthDay.html">java.time.MonthDay</a> , <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Year.html">java.time.Year</a> , <a href="https://docs.oracle.com/javase/8/docs/api/java/time/YearMonth.html">java.time.YearMonth</a> <br><br>  All these classes are united by the fact that they contain timestamps or parts of them, but they cannot determine the time points on the time axis themselves (even LocalDateTime) - since none of them have a time zone or even an offset. <br><br>  These classes, like all the others, support the java.lang.Comparable interface, but you need to understand that this is exactly a comparison of timestamps, not time points: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLocalDateTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ZonedDateTime zdt1 = ZonedDateTime.of(<span class="hljs-number"><span class="hljs-number">2015</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>)); ZonedDateTime zdt2 = ZonedDateTime.of(<span class="hljs-number"><span class="hljs-number">2015</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/London"</span></span>)); Assert.assertEquals(-<span class="hljs-number"><span class="hljs-number">1</span></span>, zdt1.compareTo(zdt2)); LocalDateTime ldt1 = zdt1.toLocalDateTime(); LocalDateTime ldt2 = zdt2.toLocalDateTime(); Assert.assertEquals(+<span class="hljs-number"><span class="hljs-number">1</span></span>, ldt1.compareTo(ldt2)); }</code> </pre><br><br>  It must be said that despite the inevitable parallels in use between java.time.LocalTime and java.sql.Time, as well as between java.time.LocalDate and java.sql.Date are totally different classes.  In the old API, the classes java.sql.Time and java.sql.Date are descendants of java.util.Date, which means that their interpretation (getting the hour value for example) depends on the time zone in which the object of this class was created and on the time zone in which this object will be read.  In the new API, the java.time.LocalTime and java.time.LocalDate classes are honest tuples of values, and the time zone does not participate in any way when writing and reading the hour value. <br><br>  However, the time zone is necessary when creating them from a time point, since the interpretation of the days and hours depends on it: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span>(expected = DateTimeException.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLocalDateTimeCreate1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Clock clock = Clock.system(ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// java.time.DateTimeException: Unable to obtain LocalDateTime \ // from TemporalAccessor: 2016-01-11T15:15:03.180Z of type java.time.Instant LocalDateTime ldt = LocalDateTime.from(clock.instant()); }</span></span></code> </pre><br><br>  An exception is thrown, due to the fact that the time zone is simply nowhere to take (in Instant it does not exist, and we do not take the zone by default).  But it can be obtained either from the java.time.Clock, or you can transfer it additionally: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLocalDateTimeCreate2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Clock clock = Clock.system(ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>)); LocalDateTime ldt1 = LocalDateTime.ofInstant(clock.instant(), ZoneId.of(<span class="hljs-string"><span class="hljs-string">"UTC"</span></span>)); System.out.println(ldt1); LocalDateTime ldt2 = LocalDateTime.now(clock); System.out.println(ldt2); }</code> </pre><br><br>  Now everything works, but the ease with which you can make a mistake is somewhat alarming. <br><br>  In the comments to the <a href="http://habrahabr.ru/post/274811/">previous article it was</a> mentioned that the real paranoids should also indicate the calendar during operations with calendar values ‚Äã‚Äã(which includes the creation of objects of all time classes except Instant).  The new API has several calendars, which are called chronologies: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testChronology</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Clock clock = Clock.system(ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>)); ZonedDateTime zdt = ZonedDateTime.now(clock); ChronoLocalDateTime dt1 = IsoChronology.INSTANCE.localDateTime(zdt); System.out.println(dt1); <span class="hljs-comment"><span class="hljs-comment">// 2016-01-11T18:48:15.145 ChronoLocalDateTime dt2 = JapaneseChronology.INSTANCE.localDateTime(zdt); System.out.println(dt2); // Japanese Heisei 28-01-11T18:48:15.145 ChronoLocalDateTime dt3 = ThaiBuddhistChronology.INSTANCE.localDateTime(zdt); System.out.println(dt3); // ThaiBuddhist BE 2559-01-11T18:48:15.145 }</span></span></code> </pre><br><br>    ,      <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO-8601</a>  <a href="https://docs.oracle.com/javase/8/docs/api/java/time/chrono/IsoChronology.html">IsoChronology</a> (    ), ,  ,  API  . <br><br><h1> ZonedDateTime </h1><br> <a href="https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html">java.time.ZonedDateTime</a> ‚Äî  java.util.Calendar.          ,   ,         . <br><br>   ZonedDateTime  LocalDateTime: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span>(expected = DateTimeException.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testZoned1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ LocalDateTime ldt = LocalDateTime.of(<span class="hljs-number"><span class="hljs-number">2015</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// java.time.DateTimeException: Unable to obtain ZonedDateTime from TemporalAccessor: 2015-01-10T00:00 of type java.time.LocalDateTime ZonedDateTime zdt = ZonedDateTime.from(ldt); }</span></span></code> </pre><br><br>       ,    ( LocalDateTime)   ,     -  API   (  ). <br><br>  : <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testZoned2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ LocalDateTime ldt = LocalDateTime.of(<span class="hljs-number"><span class="hljs-number">2015</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); ZonedDateTime zdt = ZonedDateTime.of(ldt, ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>)); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see how strict the ZonedDateTime is with respect to incorrectly specified dates. </font><font style="vertical-align: inherit;">In java.util.Calendar there is a lenient switch that can be configured for both ‚Äústrict‚Äù and ‚Äúsoft‚Äù mode. </font><font style="vertical-align: inherit;">In the new API, there is no such switch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">February 29 is not in a leap year will not pass:</font></font><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span>(expected = DateTimeException.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLenient2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// java.time.DateTimeException: Invalid date 'February 29' as '2005' is not a leap year ZonedDateTime.of(2005, 2, 29, 2, 30, 0, 0, ZoneId.of("Europe/Moscow")); }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 60th second can not be specified: </font></font><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span>(expected = DateTimeException.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLenient3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// java.time.DateTimeException: Invalid value for SecondOfMinute (valid values 0 - 59): 60 ZonedDateTime.of(2005, 2, 20, 2, 30, 60, 0, ZoneId.of("Europe/Moscow")); }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the indication of the label at the time of the transfer of the arrows to summer time passes successfully, and the result differs from the expected. </font><font style="vertical-align: inherit;">In strict mode java.util.Calendar is not missed (see the </font></font><a href="http://habrahabr.ru/post/274811/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">previous article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLenient1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ZonedDateTime zdt = ZonedDateTime.of(<span class="hljs-number"><span class="hljs-number">2005</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">27</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>)); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">3</span></span>, zdt.getLong(ChronoField.HOUR_OF_DAY)); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">30</span></span>, zdt.getLong(ChronoField.MINUTE_OF_HOUR)); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I will not write anything about operations in ZonedDateTime - you can see the documentation. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OffsetTime, OffsetDateTime </font></font></h1><br> <a href="https://docs.oracle.com/javase/8/docs/api/java/time/OffsetTime.html">java.time.OffsetTime</a> ‚Äî  LocalTime + ZoneOffset <br> <a href="https://docs.oracle.com/javase/8/docs/api/java/time/OffsetDateTime.html">java.time.OffsetDateTime</a> ‚Äî  LocalDateTime + ZoneOffset <br><br>  ,         (  ‚Äî  <em></em> ,    ),   OffsetDateTime     ZonedDateTime. OffsetDateTime        ,        ,            . <br><br>    ,         ( <a href="http://www.w3schools.com/jsref/jsref_gettimezoneoffset.asp"> JavaScript</a> ).        ,    <a href="https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html">ZonedDateTime</a> ‚Äî        .   ,    OffsetDateTime         . <br><br><h1>   </h1><br>     API         : java.time.Instant, java.time.ZonedDateTime  java.time.OffsetTime. <br><br>             java.time.ZonedDateTime,        . <br><br>             : <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWinterDay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ZonedDateTime zdt1 = ZonedDateTime.of(<span class="hljs-number"><span class="hljs-number">2005</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// case #1 - ok ZonedDateTime zdt2 = zdt1.plusDays(1); Assert.assertEquals(25, Duration.between(zdt1, zdt2).toHours()); // case #2 - ok ZonedDateTime zdt3 = zdt1.plus(1, ChronoUnit.DAYS); Assert.assertEquals(25, Duration.between(zdt1, zdt3).toHours()); // case #3 - ok OffsetDateTime odt1 = zdt1.toOffsetDateTime(); OffsetDateTime odt2 = zdt2.toOffsetDateTime(); Assert.assertEquals(25, Duration.between(odt1, odt2).toHours()); // case #4 - ??? OffsetDateTime odt3 = zdt1.toOffsetDateTime(); OffsetDateTime odt4 = odt3.plus(1, ChronoUnit.DAYS); Assert.assertEquals(24, Duration.between(odt3, odt4).toHours()); // case #5 - ok Instant instant1 = Instant.from(zdt1); Instant instant2 = Instant.from(zdt2); Assert.assertEquals(25, Duration.between(instant1, instant2).toHours()); // case #6 - ??? Instant instant3 = Instant.from(zdt1); Instant instant4 = instant3.plus(1, ChronoUnit.DAYS); Assert.assertEquals(24, Duration.between(instant3, instant4).toHours()); // case #7 - ??? LocalDateTime localDateTime1 = LocalDateTime.from(zdt1); LocalDateTime localDateTime2 = localDateTime1.plus(1, ChronoUnit.DAYS); Assert.assertEquals(24, Duration.between(localDateTime1, localDateTime2).toHours()); // case #8 - ??? LocalDateTime localDateTime3 = LocalDateTime.from(zdt1); LocalDateTime localDateTime4 = LocalDateTime.from(zdt2); Assert.assertEquals(24, Duration.between(localDateTime3, localDateTime4).toHours()); }</span></span></code> </pre><br><br>  case#1  case#2     ZonedDateTime    ,           25 . <br><br>  case#3 ,  OffsetDateTime        ,   case#4 ,            . <br><br>     case#5  case#6 ‚Äî   ,  Instant      ,      . <br><br>  case#7  case#8 ‚Äî ,  LocalDateTime       ,      . <br><br>        ,        API ( -  ).     .   ‚Äî       Java-.   API     ,        java.util.Calendar,  ,        ‚Äî     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps it was worth banning most operations with time in all classes except ZonedDateTime, since only he is aware of the arrow translations. </font><font style="vertical-align: inherit;">It might be worthwhile to prohibit the calculation of Duration using LocalDateTime, since without a time zone it does not define a time point. </font><font style="vertical-align: inherit;">I am not ready now to somehow seriously discuss the possibility or impossibility of such solutions, but I have a feeling of danger from the new API.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Period, Duration </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The new API has two classes for determining duration. </font></font><br><br> <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Period.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">java.time.Period</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - description of the calendar duration (period) in the form of a tuple (year, month, day). </font></font><br><br> <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">java.time.Duration</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - description of the exact duration in the form of an integer number of seconds and fractions of the current second in the form of nanoseconds. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The difference between the two can be shown in the example with the day of the transfer of hands to winter time. </font><font style="vertical-align: inherit;">Due to the switch back, this calendar day consists of 25 hours.</font></font><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDuration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Period period = Period.of(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); Duration duration = Duration.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, ChronoUnit.DAYS); ZonedDateTime zdt1 = ZonedDateTime.of(<span class="hljs-number"><span class="hljs-number">2005</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>)); ZonedDateTime ztd2 = zdt1.plus(period); Assert.assertEquals(ZonedDateTime.of(<span class="hljs-number"><span class="hljs-number">2005</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>)), ztd2); ZonedDateTime ztd3 = zdt1.plus(duration); Assert.assertEquals(ZonedDateTime.of(<span class="hljs-number"><span class="hljs-number">2005</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>)), ztd3); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When adding Period.of (0, 0, 1), we correctly move to the next calendar day. </font><font style="vertical-align: inherit;">In the case of adding Duration.of (1, ChronoUnit.DAYS), we actually add 24 hours and do not switch to the next calendar day.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Formatting and parsing </font></font></h1><br>   API    ,  java.text.SimpleDateFormat   -.  - ,  SimpleDateFormat      - . <br><br>   API   . <br><br> <a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html">java.time.format.DateTimeFormatter</a> ‚Äî      . <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFormat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="hljs-string"><span class="hljs-string">"yyyy/MM/dd HH:mm:dd z"</span></span>, Locale.ENGLISH); ZonedDateTime zdt1 = ZonedDateTime.of(<span class="hljs-number"><span class="hljs-number">2005</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>)); String text = zdt1.format(formatter); System.out.println(text); TemporalAccessor ta = formatter.parse(text); <span class="hljs-comment"><span class="hljs-comment">// java.time.format.Parsed ZonedDateTime zdt2 = ZonedDateTime.from(ta); Assert.assertEquals(zdt1, zdt2); }</span></span></code> </pre><br><br>    JavaDoc  ,    API     .  ,       ,   java.time.Temporal (java.time.format.Parsed  ),    ,     ,      ,   . <br><br><h1>   </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will give the class diagram of the new API. </font><font style="vertical-align: inherit;">Some minor classes are not shown, as well as the implementation of such interfaces as java.util.Serializable and java.lang.Comparable.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basic interfaces</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/429/d6e/76f/429d6e76f6be458c85062e9ba93f744c.png"><br></div></div><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Era</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/9bf/c57/5ac/9bfc575ac388464380a2a50704d1e6b9.png"><br></div></div><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time zone</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/f02/19d/00a/f0219d00a1194ff58fd101798f46c671.png"><br></div></div><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durations and periods</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/c77/3ce/f2b/c773cef2ba174d328a31493d6d5ef7af.png"><br></div></div><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chronology</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/baf/f1f/69a/baff1f69ab8e4a5f811db35772b836a0.png"><br><img src="https://habrastorage.org/files/f25/681/66d/f2568166d11e4d60a2b41127bdf9ffe0.png"><br></div></div><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temporary classes</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/0ac/788/045/0ac7880450534a40992ce70c5be97e02.png"><br><img src="https://habrastorage.org/files/67c/753/d69/67c753d6944345ecb90e25ccc5637f13.png"><br></div></div><br><br><h1>  Compatibility </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the exchange of information between the old and new API implemented several methods. </font><font style="vertical-align: inherit;">Moreover, it is implemented quite competently: the old API knows about the new API, but the new API does not know anything about the old API at all. </font><font style="vertical-align: inherit;">Purely theoretically, this will allow one to throw out all the old classes, but I doubt that this will happen in our life.</font></font><br><br><img src="https://habrastorage.org/files/da9/f02/820/da9f02820be34e1fb0b00de69dbc9e01.png"><br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testTimeZoneCompat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ZoneId zoneId1 = ZoneId.of(<span class="hljs-string"><span class="hljs-string">"Europe/Moscow"</span></span>); TimeZone timeZone = TimeZone.getTimeZone(zoneId1); ZoneId zoneId2 = timeZone.toZoneId(); Assert.assertEquals(zoneId1, zoneId2); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDateCompat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Instant instant1 = Clock.systemUTC().instant(); Date date = Date.from(instant1); Instant instant2 = date.toInstant(); Assert.assertEquals(instant1, instant2); }</code> </pre><br><br>    :        java.util.Date       ,   API  ,    .   ,            java.lang.System#currentTimeMillis,       ,   . <br><br><h1>  findings </h1><br>        API.      ,        :            ZonedDateTime,        runtime      .  ,  API   .     ‚Äî   . </div><p>Source: <a href="https://habr.com/ru/post/274905/">https://habr.com/ru/post/274905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274889/index.html">Calculating the binomial coefficients ... manually</a></li>
<li><a href="../274895/index.html">Elephant and Pug, or LCD connection to Attiny13A</a></li>
<li><a href="../274897/index.html">Total standardization</a></li>
<li><a href="../274899/index.html">Vulnerability in Trend Micro products allows any website to execute arbitrary Windows command</a></li>
<li><a href="../274903/index.html">Why is it so difficult to improve email</a></li>
<li><a href="../274907/index.html">–ï–ì–ê–ò–° - increase of information security of workplaces</a></li>
<li><a href="../274909/index.html">Dolphin Smalltalk 7 is dedicated to Open Sourse</a></li>
<li><a href="../274911/index.html">Calculation of binomial coefficients ... still programmatically</a></li>
<li><a href="../274913/index.html">Call service via video site with 3CX</a></li>
<li><a href="../274915/index.html">Automatic control of the lifetime of common C ++ - QML objects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>