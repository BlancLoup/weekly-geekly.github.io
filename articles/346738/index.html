<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On data locality in hyperconvergent systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are concepts that are commonly used in professional communication and in marketing, implying that they are strictly defined and everyone underst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On data locality in hyperconvergent systems</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/2h/rb/u-/2hrbu-6kbkttc0rpub0qbfnoibi.jpeg"><br><br>  There are concepts that are commonly used in professional communication and in marketing, implying that they are strictly defined and everyone understands them the same way.  But it often turns out that a number of terms around which there is a lively discussion in the IT community have not had precise definitions and no, and of course, they have all forgotten to agree on their common meaning. <br><a name="habracut"></a><br>  For example, the concept of "enterprise readiness".  Since we started talking seriously about the automation of enterprises, it is used with confidence both in technical documentation and with the support of sales by everyone.  But he has no strict definition!  There is a general understanding of ‚Äúenterprise-ready systems,‚Äù or ‚Äúenterprise-wide systems,‚Äù as solutions that are ready for use by large organizations from arbitrary branches of human activity.  Often, very expensive solutions are often called enterprise-ready solutions ‚Äî costing more than a million dollars, for example.  It would seem - a curiosity.  But this curiosity sets the level of discussion. <br><br><h3>  Reliability, availability, maintainability </h3><br>  Speaking of IT solutions "enterprise-level", under the "enterprise" understand any large organizations and management companies, but not IT companies.  This is important because such organizations focus on certain standards and serial IT products, it is important for them that they can independently use the solutions they acquire;  they are critical to the resiliency and reliability of the IT systems.  Therefore, we prefer to call hardware and software solutions designed to work in large organizations and characterized by: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  reliability (reliability): long time between failures; </li><li>  high availability (availability): even in the event of a failure of one of the components, the systems must continue to function without a noticeable decrease in performance; </li><li>  serviceability: i.e.  the possibility of a sufficiently rapid restoration or replacement of a failed component at the lowest cost from both the operator organization and the supplier. </li></ul><br>  And it is not invented by us.  Back in the 1960s.  IBM has used the abbreviation ‚ÄúRAS‚Äù in its mainframe advertisements - Reliability, Availability, Serviceability.  Other characteristic properties can be distinguished, but, in one way or another, they can easily be reduced to RAS.  This is where the main expectations of large organizations from IT are concentrated. <br><br>  However, reliability, availability and maintainability are also understood in different ways.  In particular, there is some private opinion that the mandatory requirement of high availability of the system is the property of data locality.  But after all, the locality of the data does not have a strict definition!  The idea of ‚Äã‚Äãdata locality is that the data must physically be ‚Äúsomewhere close‚Äù to the place where they are processed.  Of course, each manufacturer implements data locality in its own way.  It's funny that it is the implementation of local data that causes the most questions - although in relation to enterprise readiness as a whole, as we see, this property is not even of the second, but of the third order.  But since it is this property of enterprise-ready-systems that generates such fierce disputes, let's find out which solutions for ensuring local data exist in the context of readiness for loads and operation in the ‚Äúenterprise scale‚Äù. <br><br><h3>  Data locality </h3><br>  First you need to understand the concept of data locality and examples of its implementation in various classes of infrastructure and platform systems. <br><br>  What level of data locality are we talking about?  About the locality of data in relation to the processor sockets?  Or about the organization of interaction between geographically distributed data centers?  Let's agree that we are talking about hyperconvergent systems, i.e.  about x86-based virtualization complexes without external storage systems - today, they are becoming the de facto standard for implementing virtualized infrastructure for large and medium-sized organizations. <br><br>  So, the hyperconvergent system is, in fact, a set of nodes that run virtual machines.  Virtual machines store data on the internal drives of virtualization hosts.  The data locality property implies that each virtual machine writes data to drives located on the same physical node as the virtual machine ‚Äî in order not to overload the network.  In the future, this data will be copied to other nodes to provide redundant data storage, but the virtual machine reads in ‚Äúits‚Äù physical node. <br><br><img src="https://habrastorage.org/webt/te/fi/lp/tefilpy7gw8ttquymsnsgtzlwqw.png"><br>  <em><strong>Fig.</strong></em>  <em><strong>1. The</strong> hyperconvergent system combines resources from several nodes into a computational pool, and delegates local storage of nodes to a single storage pool.</em>  <em>The virtual machine VM <sub>1</sub> , located on the first node, writes the first replica of its data blocks to local drives.</em> <br><br>  But what if the node fails?  The virtual machine will, of course, be moved to another physical node.  But should there, to this virtual machine, "move" all its data?  The main advantage of this approach is that the virtual machine can read its data more locally than through the network.  The main disadvantage is that data transfer overloads the network, and, as experience shows, quite significantly.  Therefore, in our implementation, which we used in the hyper-perverse computing platform "Skala-R", we deliberately did not start rebuilding the repository with automatic virtual machine data transfer.  At the same time, we did not proceed from the speculative ideas of what data locality is, but from the actual system availability indicators, to which Scala-R corresponds. <br><br><img src="https://habrastorage.org/webt/z8/vt/db/z8vtdbrcz7fwmwmgdn8pb_vxdpe.png"><br>  <em><strong>Fig.</strong></em>  <em><strong>2.</strong> When a node fails, virtual machines from it, including VM <sub>1</sub> , migrate to another node, the first replica for VM <sub>1</sub> volume is now written to the local drives of the second node - this is its new locality.</em>  <em>But do you need to automatically rebuild the entire storage pool so that the maximum number of data blocks of VM <sub>1 is</sub> on the drives of the second node?</em> <br><br>  Why do we do that?  Because we believe that IT infrastructure should not be redundant, its complexity and final cost should be justified, and its behavior - predictable.  As examples of good practices, you can cite the implementation of monitoring and management systems such as HP OpenView, IBM Tivoli, BMC Patrol - they could proactively perform proactive and corrective actions in certain situations, but by default these features were disabled and only a system administrator was alerted. <br><br>  We consider such a policy to be very reasonable, and the analogy with the policies of the behavior of hyperconvergent systems is seen as direct here.  Migrating virtual machines from a failed host to others is a natural, predictable action required to ensure high availability.  The transfer of local data, which inevitably increases the load on the network, from our point of view, should be left to the discretion of the operator. <br><br><h3>  Interstitial Locality in Hyper-Converged Systems </h3><br>  Indeed, is data locality required for system operation across the enterprise, and if it is needed, in which implementation variant?  In the early 2010s.  early hyperconvergent systems were designed for reasons of independence from the performance of the network infrastructure.  The most common network solution in organizations' data centers was Gigabit Ethernet, and for the first systems, such as the pioneers of this market, Simplivity and Nutanix, inter-nodal locality was considered the most important feature.  These solutions implemented the function of preferred writing to local devices, preferable reading from a local device, and automatic rebuilding of the entire storage network during live migration of a virtual machine to another node. <br><br>  In software-defined storage networks (software-defined storage, SDS), the best effect was achieved when they were jointly used with virtualization platforms, when blocks of virtual machine volumes were located on the same nodes where these machines are running, preferably reading from a local device. storage.  One of the historically first SDSs that implemented inter-node locality was Parallels Storage (now Virtuozzo Storage).  It also formed the basis of the software-defined network of the Skala-R hyperconvergent complex (the R-Storage component). <br><br>  But with the transition to 10-gigabit networks, many manufacturers of hyperconvergent systems, such as Maxta, Atlantis, systems based on VMWare vSAN, and others, refused to implement inter-node locality.  Most of the existing SDSs, including Microsoft S2D, Dell-EMC ScaleIO, RedHat CephFS, and RedHat GlusterFS, do not implement cross-site locality, and VMWare implements locality in vSAN as a local hot-data cache and <a href="https://storagehub.vmware.com/export_to_pdf/understanding-data-locality-in-vmware-vsan">negates the need for inter-site locality</a> .  This is motivated by low latency in a modern 10-gigabit network and the potential damage to the balance of the storage system while observing the rules of inter-node locality. <br><br>  Even in Nutanix, which made a special emphasis on inter-nodal locality in early implementations, since 2015 it has been implemented <a href="http://www.joshodgers.com/2015/08/04/nos-4-5-delivers-increased-read-performance-from-sata/">much thinner</a> - if the delay from remote reading is lower than from local, then reading from a remote replica is done, and the full restructuring of the volume is not performed when migrating a virtual machine (‚ÄúCold‚Äù blocks remain in place, that is, the relocalization of a block that is on a remote node is carried out at the first reading). <br><br>  At the same time, most hyperconvergent systems are currently delivered without a network solution!  For our part, we made the Mellanox network solution for RoCE networks, having a capacity of 56 Gbit / s and providing unloading functions for the central processors (CPU offload), an integrated part of the Skala-R complex.  Duplicated switches provide reliability, their properties provide a reliable reserve of bandwidth even in scenarios with mass migration of virtual machines, the failure of even the entire switch does not lead to reduced availability. <br><br>  As for inter-node locality, it was noted that it was inherited by Scala-R from the Parallels Storage implementation: virtual machine data blocks are written preferably to local devices, and reading is done locally.  But the significance of this property for Scala-R is small ‚Äî the network solution we use virtually eliminates the network factor in terms of performance. <br><br>  Implemented in the "Scale-R" and the function of rebuilding the storage based on locality, but it does not start automatically during a live migration of machines.  ‚ÄúAutomation‚Äù would be easy to implement, but the analysis of the operating experience of the system did not confirm the feasibility of such a solution.  For example, in a situation of a planned or emergency reboot of one of the nodes (which happens to Scala-R much less frequently than in the case of Nutanix and Simplivity), which takes 1-2 minutes, automatic rebuilding of the storage will not make any sense and at the same time noticeable performance degradation.  If the virtual machine remains on the new node after migration, its new data will in any case be recorded on local devices.  One way or another, the system administrator always has complete information for making decisions about re-migrating machines, rebuilding the storage network, or intermediate measures. <br><br><h3>  Conclusion </h3><br>  So, how effective is data locality for hyperconvergent systems?  In the general case, inter-site locality is useful in software-defined storage networks, because it helps reduce interworking, reduce network load, and improve overall system performance.  But the automatic storage tuning function when migrating virtual machines is not only not necessary - in conditions of relatively large virtual machines, it is rather harmful. <br><br>  In general, inter-node locality is not related to enterprise readiness and operation (in terms of RAS).  This is only an additional feature, and the higher the performance of network solutions, the lower its value. </div><p>Source: <a href="https://habr.com/ru/post/346738/">https://habr.com/ru/post/346738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346728/index.html">23 Shorts by ReactJS - short video tutorials not only for beginners</a></li>
<li><a href="../346730/index.html">New technology accelerates WAN networks up to 40 Gbps</a></li>
<li><a href="../346732/index.html">GopherCon Russia 2018: the conference will be held on March 17 in Moscow</a></li>
<li><a href="../346734/index.html">Probabilistic Seismic Hazard Analysis</a></li>
<li><a href="../346736/index.html">Major events in 2018: development</a></li>
<li><a href="../346742/index.html">Using Grafana with DeviceHive IoT Platform</a></li>
<li><a href="../346744/index.html">First meeting with the ss team</a></li>
<li><a href="../346746/index.html">Reference application based on containers and microservice architecture</a></li>
<li><a href="../346748/index.html">Pentestit Corporate Laboratories: Practical Information Security Skills</a></li>
<li><a href="../346750/index.html">How we spent the day at Veeam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>