<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.Net Core, AppDomain, WCF, RPC marshalling TCP / Ip your bike</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, in .Net Core, at the moment, there is no AppDomain, and WCF is only a SOAP client .Net Core, WCF and ODATA clients . 

 Of course, the ta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.Net Core, AppDomain, WCF, RPC marshalling TCP / Ip your bike</h1><div class="post__text post__text-html js-mediator-article">  As you know, in .Net Core, at the moment, there is no AppDomain, and WCF is only a SOAP client <a href="https://habrahabr.ru/post/310152/">.Net Core, WCF and ODATA clients</a> . <br><br>  Of course, the task can be solved via Web Api with WebSockets to trigger events.  But, I just propose an alternative solution for marshaling over TCP / IP and creating objects and calling server-side methods using Reflection. <br><br>  Here is the remote call of methods and properties.  An example is taken from here <a href="https://professorweb.ru/my/csharp/charp_theory/level6/6_4.php">Basics of operator overloading</a> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      string typeStr = typeof(Console).AssemblyQualifiedName; var _Console = wrap.GetType(typeStr);//       // "Hello from Client"      _Console.WriteLine("Hello from Client"); //      TestDllForCoreClr.MyArr //   TestDll.dll var MyArr = wrap.GetType("TestDllForCoreClr.MyArr", "TestDll"); //      //      var Point1 = MyArr._new(1, 12, -4); // new MyArr(1, 12, -4); var Point2 = MyArr._new(0, -3, 18); // new MyArr(0, -3, 18); //     PointX     Console.WriteLine("  : "+Point1.x+" "+Point1.y+" "+Point1.z); Console.WriteLine("  : "+Point2.x+" "+Point2.y + " "+ Point2.z); var Point3 = Point1 + Point2; Console.WriteLine("\nPoint1 + Point2 = " + Point3.x + " " + Point3.y + " " + Point3.z); Point3 = Point1 - Point2; Console.WriteLine("Point1 - Point2 = "+ Point3.x + " " + Point3.y + " " + Point3.z); Point3 = -Point1; Console.WriteLine("-Point1 = " + Point3.x + " " + Point3.y + " " + Point3.z); Point2++; Console.WriteLine("Point2++ = "+ Point2.x + " " + Point2.y + " " + Point2.z); Point2--; Console.WriteLine("Point2-- = " + Point2.x + " " + Point2.y + " " + Point2.z);</span></span></code> </pre> <a name="habracut"></a><br>  Only the wrap.GetType and MyArr._new and _Console methods are not native.  Everything else is one-to-one work with objects in C #. <br><br>  In fact, Point1 and Point2 and Point3 are the heirs of DynamicObject with overridden TryXXX methods, and inside of them the method type is packed, the name of the method and parameters is in the Stream and transferred to the Server using TCP / IP protocol, where it is unpacked and the method that Searched by type, method name and parameters.  After receiving the result, the same procedure but, only from the server to the client. <br><br>  The solution itself is very close with the COM out process interaction on IDispatch.  I remember with pleasure dealt with <a href="http://compress.ru/article.aspx%3Fid%3D10688">TSocketConnection</a> internals. <br><br>  But, unlike Idispatch, overloading methods and operators, calling Generic methods with type inference or specifying Generic arguments are used.  Support for extension methods for classes that are in the same assembly and for Linq methods. <br><br>  Also support for asynchronous methods and subscription to events, ref and out parameters, access by index [], support for iterators in foreach. <br><br>  Unlike Web Api, you do not need to write specifically the server code Controller, Hub s. <br>  This is close to the <a href="https://habrahabr.ru/post/242209/">AppDomain c Remouting</a> but, unlike Remoting, each class is analogous to MarshalByRefObject.  That is, we can create any object on the server side and return a link to it (some languages ‚Äã‚Äãfrom numbers only support double). <br><br>  When calling methods, only the following types of parameters are directly serialized: numbers, strings, date, Guid and byte [].  For other types, you need to create them on the server side, and references to them are already passed in the method parameters. <br><br>  So examples can be looked at TypeScript which is close to C # in syntax <br>  <a href="https://habrahabr.ru/post/320960/">CEF, ES6, Angular 2, TypeScript using .Net Core classes.</a>  <a href="https://habrahabr.ru/post/320960/">Creating a cross-platform GUI for .Net using CEF</a> <br><br>  <a href="https://habrahabr.ru/post/321452/">CEF, Angular 2 using .Net Core class events</a> <br><br>  Calling the server-side method can be viewed here. <a href="https://habrahabr.ru/post/304482/">Cross-platform use of .Net classes from unmanaged code.</a>  <a href="https://habrahabr.ru/post/304482/">Or analogue IDispatch on Linux</a> . <br><br>  In this article, I will focus on the features of using DinamicObject, marshaling to call object and static methods of remote objects. <br><br>  The first thing we start off with is loading the correct assembly and getting the type.  In the first example, we obtained a type by the full name of the type, by the name of the type and the name of the assembly. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//     //    //public static Assembly GetAssembly(string FileName, bool IsGlabalAssembly = false) // IsGlabalAssembly == true?      typeof(string).GetTypeInfo().Assembly.Location //    Server var assembly = wrap.GetAssembly("TestDll"); //      var @TestClass = assembly.GetType("TestDllForCoreClr.TestClass"); //    ,      . ,      //   //public static Type GetType(string type, string FileName = "", bool IsGlabalAssembly = false) //var @TestClass = wrap.GetType("TestDllForCoreClr.TestClass", "TestDll");</span></span></code> </pre> <br>  Now, having a reference to the type, you can create an object by calling the _new method or call the New wrapper method. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> TO = @TestClass._new(<span class="hljs-string"><span class="hljs-string">"Property from Constructor"</span></span>);</code> </pre> <br>  or <br><br><pre> <code class="cs hljs">wrap.New(@TestClass,<span class="hljs-string"><span class="hljs-string">"Property from Constructor"</span></span>);</code> </pre><br>  You can construct Generic types: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Dictionary2 = wrap.GetType(<span class="hljs-string"><span class="hljs-string">"System.Collections.Generic.Dictionary`2"</span></span>, <span class="hljs-string"><span class="hljs-string">"System.Collections"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DictionaryIntString = wrap.GetGenericType(Dictionary2, <span class="hljs-string"><span class="hljs-string">"System.Int32"</span></span>, <span class="hljs-string"><span class="hljs-string">"System.String"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dict = wrap.New(DictionaryIS);</code> </pre> <br>  In wrap.New and wrap.GetGenericType, you can pass references to types or their string representation.  For strings, the main thing is that the assemblies are loaded. <br><br>  The next option is to copy the object to the server.  This is important because the Tcp / IP exchange rate is about 15,000 calls per second, with a permanent connection and only 2000 when connecting for each <a href="http://ru.stackoverflow.com/questions/630653/tcp-ip-%25D1%2581%25D0%25BA%25D0%25BE%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%258C-%25D0%25BE%25D0%25B1%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25B0/634019">TCP / IP</a> request, the <a href="http://ru.stackoverflow.com/questions/630653/tcp-ip-%25D1%2581%25D0%25BA%25D0%25BE%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%258C-%25D0%25BE%25D0%25B1%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25B0/634019">exchange rate</a> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ClientDict = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;() { [<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">""</span></span>, [<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-string"><span class="hljs-string">""</span></span>, [<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-string"><span class="hljs-string">""</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//     Json  . //   . var dict = connector.CoryTo(ClientDict);</span></span></code> </pre><br>  Now dict is a link to the dictionary on the server side, and can be passed in parameters. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//       //public V GenericMethod&lt;K, V&gt;(Dictionary&lt;K, V&gt; param1, K param2, V param3) resGM = TO.GenericMethod(dict, 99, "Hello"); Console.WriteLine("      " + resGM);</span></span></code> </pre> <br>  We can use indexes to access and set values. <br><br><pre> <code class="cs hljs">Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"dict[2] "</span></span> + dict[<span class="hljs-number"><span class="hljs-number">2</span></span>]); dict[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-string"><span class="hljs-string">""</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"dict[2] "</span></span> + dict[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre><br>  We can use an iterator <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dict.Values) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Dict Values "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>);</code> </pre><br>  Now I will turn your attention to the difference in syntax.  First of all, it is a call to Generic methods with setting Generic arguments, ref and out parameters, an asynchronous call. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//     // public V GenericMethodWithRefParam&lt;,V &gt;( param, V param2, ref string param3) //      ref . ,   . //    RefParam,     Value      var OutParam = new ClientRPC.RefParam("TroLoLo"); resGM = TO.GenericMethodWithRefParam(5, "GenericMethodWithRefParam", OutParam); Console.WriteLine($@"      Ref {resGM} {OutParam.Value}"); //       var GenericArgs = new object[] { "System.String", "System.String" }; //          : // var @Int32 = wrap.GetType("System.Int32"); //var GenericArgs = new object[] {@Int32, "System.String" }; //            //      //    // resGM = TO.GenericMethodWithRefParam&lt;String,String&gt;(null, "GenericMethodWithRefParam", ref OutParam) resGM = TO.GenericMethodWithRefParam(GenericArgs, null, "GenericMethodWithRefParam", OutParam); Console.WriteLine($@"      Ref {resGM} {OutParam.Value}"); // Test return null resGM = TO.GenericMethodWithRefParam(GenericArgs, null, null, OutParam); Console.WriteLine($@"      Ref {resGM} {OutParam}");</span></span></code> </pre><br>  The RefParam class is needed to write the changed parameter in the Value field. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RefParam</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> Value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefParam</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Value = Value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefParam</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Value = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Value?.ToString(); } }</code> </pre><br>  To call an asynchronous method: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public async Task&lt;V&gt; GenericMethodAsync&lt;K, V&gt;(K param, string param4 = "Test") var GenericArgs = new object[] { "System.Int32", "System.String" }; object resTask = await TO.async.GenericMethodAsync(GenericArgs , 44);</span></span></code> </pre> <br>  It is necessary to add the word <b>async</b> before the name of the asynchronous method <br><br>  If you have a Task, then you can wait for the execution by calling: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res =<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> wrap.<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.ReturnParam(task);</code> </pre> <br>  Another difference from the real code is that we cannot directly use overload == <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myObject1 == myObject2) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"    =="</span></span>);</code> </pre><br>  Instead, we must explicitly call <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myObject1.Equals(myObject2)) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  Equals"</span></span>);</code> </pre><br>  or, if there is an overload, operator == <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (MyArr.op_Equality(myObject1,myObject2)) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  op_Equality"</span></span>);</code> </pre><br>  There is support for objects that support System.Dynamic.IDynamicMetaObjectProvider.  These are ExpandoObject, DinamicObject, JObject, etc. <br><br>  Take for tests the following object: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetExpandoObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExpandoObject(); res.Name = <span class="hljs-string"><span class="hljs-string">"Test ExpandoObject"</span></span>; res.Number = <span class="hljs-number"><span class="hljs-number">456</span></span>; res.toString = (Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;)(() =&gt; res.Name); res.Sum = (Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;)((x, y) =&gt; x + y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br>  Now you can use it: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> EO = TO.GetExpandoObject(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" ExpandoObject  "</span></span> + EO.Name); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" ExpandoObject  "</span></span> + EO.Number); <span class="hljs-comment"><span class="hljs-comment">//   var Delegate = EO.toString; Console.WriteLine("  toString " + Delegate()); //    //  ExpandoObject     Console.WriteLine("  toString " + EO.toString()); var DelegateSum = EO.Sum; Console.WriteLine("  Sum " + DelegateSum(3,4)); //    //  ExpandoObject     Console.WriteLine("  Sum " + EO.Sum(3,4)); //  ExpandoObject }</span></span></code> </pre><br>  As you can see from the example, not only methods and properties are supported, but also delegates.  Often you need to bring objects to the interfaces.  For this is the keyword _as. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] sa = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] { <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//     var ServerSa = Connector.CoryTo(sa); //   IEnumerable   var en = ServerSa._as("IEnumerable"); var Enumerator = en.GetEnumerator(); while(Enumerator.MoveNext()) Console.WriteLine(Enumerator.Current); //     var @IEnumerable = wrap.GetType("System.Collections.IEnumerable"); var @IEnumerator = wrap.GetType("System.Collections.IEnumerator"); //    ,     en = ServerSa._as(@IEnumerable); Enumerator = en.GetEnumerator(); //       IEnumerator Enumerator = Enumerator._as(@IEnumerator); while (Enumerator.MoveNext()) Console.WriteLine(Enumerator.Current);</span></span></code> </pre> <br>  We now turn to semi-automatic serialization. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dict = connector.CoryTo(ClientDict);</code> </pre> <br>  Inside connector.CoryTo, Json is serialized. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">dynamic</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoryTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     //      string type = obj.GetType().AssemblyQualifiedName; var str = JsonConvert.SerializeObject(obj); return CoryTo(type, str); }</span></span></code> </pre> <br>  It is necessary that the assembly of a serializable type be loaded on the server.  Explanation below. <br><br>  Also on the client there can be no assembly with a serializable type.  Therefore for serialization we can use <a href="http://www.newtonsoft.com/json/help/html/CreatingLINQtoJSON.htm">JObject</a> <br>  <a href="http://www.newtonsoft.com/json/help/html/CreateJsonAnonymousObject.htm">Anonymous types</a> . <br><br>  <a href="http://www.newtonsoft.com/json/help/html/SerializationGuide.htm">Jsonobject</a> <br><br>  We can specify the type, as a string or as a reference to the type and object to be serialized. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">dynamic</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoryTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = JsonConvert.SerializeObject(obj); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CoryTo(type, str); }</code> </pre> <br>  And in the end, send to the server: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// type     Type AutoWrapClient    //     public dynamic CoryTo(object type, string objToStr) { object result; var res = AutoWrapClient.TryInvokeMember(0, "JsonToObject", new object[] { type, objToStr }, out result, this); if (!res) throw new Exception(LastError); return result; }</span></span></code> </pre> <br>  It should be noted that for deserialization on the server string, an assembly with a type must be loaded on the server side. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestSerializeObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ClientRPC.TCPClientConnector connector</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      var obj = new TestDllForCoreClr.TestClass("   "); dynamic test = null; try { //     test = connector.CoryTo(obj); } //    //         CoryTo catch (Exception) { Console.WriteLine(" " + connector.LastError); var assembly = wrap.GetAssembly("TestDll"); test = connector.CoryTo(obj); } Console.WriteLine(test.ObjectProperty); }</span></span></code> </pre> <br>  Also, assemblies that are not in the Core CLR directory or are not NuGet packages must be manually downloaded: <br><br><div class="spoiler">  <b class="spoiler_title">Build Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Assembly </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadAssembly</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Dir = AppContext.BaseDirectory; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Dir, fileName); Assembly assembly = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> asm = System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName(path); assembly = Assembly.Load(asm); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { assembly = System.Runtime.Loader.AssemblyLoadContext.Default.LoadFromAssemblyPath(path); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"   "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> assembly; }</code> </pre><br></div></div><br>  In order to copy the server object to the client, you need to use the following method: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objFromServ = connector.CoryFrom&lt;Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;&gt;(dict); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"dict[2] "</span></span> + objFromServ[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre><br>  JObject can be used if this type is not available on the client using: <br><br><pre> <code class="cs hljs"> connector.CoryFrom&lt;<span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span>&gt;(</code> </pre> <br>  Well, in the end.  proceed to connect to the server. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LoadLocalServer) { <span class="hljs-comment"><span class="hljs-comment">//   dotnet.exe c Server.dll,  . connector = ClientRPC.TCPClientConnector.LoadAndConnectToLocalServer(GetParentDir(dir, 4) + $@"\Server\Server\bin\Release\netcoreapp1.1\Server.dll"); } else { //          //         //   5  connector = new ClientRPC.TCPClientConnector("127.0.0.1", port, false); //  Tcp/IP          . port = ClientRPC.TCPClientConnector.GetAvailablePort(6892); connector.Open(port, 2); }</span></span></code> </pre> <br>  Inside LoadAndConnectToLocalServer we start the dotnet.exe process with the address of the Server.dll file: <br><br><div class="spoiler">  <b class="spoiler_title">Server process load code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TCPClientConnector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadAndConnectToLocalServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port = <span class="hljs-number"><span class="hljs-number">1025</span></span>; port = GetAvailablePort(port); ProcessStartInfo startInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProcessStartInfo(<span class="hljs-string"><span class="hljs-string">"dotnet.exe"</span></span>); startInfo.Arguments = <span class="hljs-string"><span class="hljs-string">@""""</span></span>+ FileName+ <span class="hljs-string"><span class="hljs-string">$@""" </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{ port}</span></span></span><span class="hljs-string">"</span></span>; Console.WriteLine(startInfo.Arguments); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> server = Process.Start(startInfo); Console.WriteLine(server.Id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TCPClientConnector(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, port); port++; port = GetAvailablePort(port); connector.Open(port, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> connector; }</code> </pre> <br></div></div><br>  Now we can get proxy. <br><br><pre> <code class="cs hljs"> wrap = ClientRPC.AutoWrapClient.GetProxy(connector);</code> </pre> <br>  And using it to get types, call static methods, create objects, call methods of objects, and so on. <br><br>  At the end of the work with the server, you need to disconnect from it and, if we started the process, then unload it. <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//    AutoWrapClient     GC.Collect(); GC.WaitForPendingFinalizers(); Console.WriteLine("Press any key"); Console.ReadKey(); //        ,  50  //   connector.ClearDeletedObject(); //   ,   , Tcp/Ip    connector.Close(); //     , //    if (LoadLocalServer) connector.CloseServer(); Console.WriteLine("Press any key"); Console.ReadKey();</span></span></code> </pre> <br>  As for events, you can see the article <a href="https://habrahabr.ru/post/321452/">CEF, Angular 2 using the events of the classes .Net Core</a> . <br><br>  It describes the process of working with events .Net objects.  The only thing that the module code for the client can be obtained: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @DescribeEventMethods = wrap.GetType(<span class="hljs-string"><span class="hljs-string">"NetObjectToNative.DescribeEventMethods"</span></span>, <span class="hljs-string"><span class="hljs-string">"Server"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> CodeModule = @DescribeEventMethods.GetCodeModuleForEvents(@EventTest);</code> </pre> <br><br>  Please note that when you subscribe to an event with two or more parameters.  is created <br>  anonymous class with fields with the appropriate names and types of parameters.  So for the event: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; EventWithTwoParameter;</code> </pre> <br>  A wrapper will be created: <br><br><pre> <code class="cs hljs">Target.EventWithTwoParameter += (arg1,arg2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EventWithTwoParameter!=<span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> EventWithTwoParameterObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> {arg1=arg1,arg2=arg2}; EventWithTwoParameter(EventWithTwoParameterObject); } };</code> </pre><br>  CodeModule will contain the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  value:  //   // arg1:System.String // arg2:System.Int32 static public void EventWithTwoParameter(dynamic value) { Console.WriteLine("EventWithTwoParameter " + wrap.toString(value)); //    . Console.WriteLine($"EventWithTwoParameter arg1:{value.arg1} arg2:{value.arg2}"); value(ClientRPC.AutoWrapClient.FlagDeleteObject); }</span></span></code> </pre> <br>  You can read about using dynamic compilation here. <a href="https://habrahabr.ru/post/309340/">Net Core, 1C, dynamic compilation, Scripting API</a> . <br><br>  As for the security of <a href="http://stackoverflow.com/questions/38374796/analog-system-security-permissions-in-net-core">Analog System.Security.Permissions in .NET Core</a> , it is advised to run the process under a certain user account with certain rights. <br><br>  It is regrettable that in C # there are no pseudo-interfaces for speakers, an analogue of type annotation in TypeScript d.ts, for static code checking and IntelliSense. <br><br>  But you can write the usual code, altering it to a remote one.  with minimal gestures. <br><br>  The sources here are <a href="https://github.com/Serginio1/RPCProjectsForGitHub">RPCProjects</a> . <br><br>  Before running the examples, compile the projects and copy the TestDll.dll folder in the Server \ bin \ Release \ netcoreapp1.1 \ and Client \ bin \ Release \ netcoreapp1.1 \ directories from the TestDll \ bin \ Release \ netcoreapp1.1 \ folder. <br><br>  If the article is of interest, then in the next article I will sign for the mechanisms for exchanging and invoking methods on the server. <br><br>  <b>PS</b> Actively get rid of russish in code, but it is still quite a lot.  If the project is interesting, I will finally clean up the Russian code. </div><p>Source: <a href="https://habr.com/ru/post/323096/">https://habr.com/ru/post/323096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323084/index.html">What you need to know to use omnichannel communications?</a></li>
<li><a href="../323086/index.html">Creating images on CSS makes a maker-up better, or What to do during long winter evenings</a></li>
<li><a href="../323090/index.html">Uninvented stories about EastBanc Technologies in photos</a></li>
<li><a href="../323092/index.html">Recreating subdatasheet in table on AngularJS</a></li>
<li><a href="../323094/index.html">Booking.com search architecture</a></li>
<li><a href="../323100/index.html">IceCash 2.0 Web Workstation Cashier and AIS for exchanging data with cash registers for Linux to Python</a></li>
<li><a href="../323102/index.html">Another way to localize applications</a></li>
<li><a href="../323106/index.html">Accelerate Node.js with Rust</a></li>
<li><a href="../323108/index.html">Two providers simultaneously or Dual ISP with VRF on Cisco | Part 2</a></li>
<li><a href="../323110/index.html">Protect a remote terminal server or two-factor authentication of RDG clients using Azure MFA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>