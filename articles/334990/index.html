<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to octree</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is octree? If you absolutely do not know this concept, then I recommend reading the article on Wikipedia (it will take about five minutes). It gi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to octree</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/743/8d4/db9/7438d4db9a93c3bf5caf8148b6562337.png"><br><br>  What is octree?  If you absolutely do not know this concept, then I recommend reading the <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BA%25D1%2582%25D0%25BE%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE" rel="external nofollow">article on Wikipedia</a> (it will take about five minutes).  It gives a sufficient <i>idea</i> , but it will hardly be enough to understand what they are used for and how to implement them. <br><br>  In this article I will try to talk about all the steps needed to create a data structure of oktotreev, using the example of explaining concepts, illustrations and code.  I will also describe my decisions that I took at each of the stages.  Do not think that this article will be the only correct guide to the implementation of oktotreev, but it should give you a good foundation and you can use it for reference. <br><a name="habracut"></a><br><h2>  Required knowledge </h2><br>  When writing this article, I assumed that the reader: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Well versed in programming in a language with syntax in the style of C (I will use C # with XNA). </li><li>  Already programmed some <a href="https://www.gamedev.net/articles/programming/general-and-gameplay-programming/data-structures-for-pre-college-programmers-trees-and-heaps-r2988/">tree data structure</a> , for example, a <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0" rel="external nofollow">binary search tree</a> , is familiar with recursion, its strengths and weaknesses. </li><li>  Knows how collision detection with boundary rectangles, spheres and truncated pyramids is implemented. </li><li>  Understands in standard data structures (arrays, lists, etc.), he understands that there is such a <a href="https://ru.wikipedia.org/wiki/%25C2%25ABO%25C2%25BB_%25D0%25B1%25D0%25BE%25D0%25BB%25D1%258C%25D1%2588%25D0%25BE%25D0%25B5_%25D0%25B8_%25C2%25ABo%25C2%25BB_%25D0%25BC%25D0%25B0%25D0%25BB%25D0%25BE%25D0%25B5" rel="external nofollow">big ‚ÄúO‚Äù</a> (you can also read about the big ‚ÄúO‚Äù in <a href="https://www.gamedev.net/page/resources/_/technical/general-programming/writing-fast-code-introduction-to-algorithms-and-big-o-r3442">this GDnet article</a> ). </li><li>  Works on a project that has features that need collision checking. </li></ol><br><h2>  Stage preparation </h2><br>  Suppose we create a very large-scale game in which thousands of physical objects of different types, shapes and sizes can be contained, and some of them must collide with each other.  In each frame, we will have to determine which objects intersect with each other and somehow handle these intersections.  How to do this so that the game speed does not fall? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b0/e37/da8/1b0e37da806b195acc009845b19f73c5.png"><br><br><h2>  Brute-force collision detection </h2><br>  The simplest solution is to compare each object with all objects in the world.  This can usually be done in two <em>for</em> loops.  The code will look something like this: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(gameObject myObject <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ObjList) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(gameObject otherObject <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ObjList) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(myObject == otherObject) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       if(myObject.CollidesWith(otherObject)) { //   } } }</span></span></code> </pre> <br>  Graphically, this can be represented as: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c1a/4ae/4a6/c1a4ae4a624e6824475d7165bf3488a5.png"><br><br>  Each red line is a cost check for intersections in the CPU. <br><br>  Naturally, such code should terrify you, because it will be executed O (N <sup>2</sup> ) times.  If we have 10,000 objects, we will have to perform 100,000,000 collision checks (one hundred million).  No matter how fast your processor is and how much you have improved the mathematical code - such a program will slow down in the computer.  If the game works with 60 frames per second, then 60 * 100 million calculations will be performed per second!  This is a complete insanity. <br><br>  If this can be avoided, let's not do that, at least for large sets of objects.  This will be acceptable <i>only</i> if, say, a check is performed for only 10 objects (100 checks).  If you know in advance that there will be few objects in the game (for example, asteroids), then perhaps you can easily do a brute force and you can completely abandon the octree tree.  If you start to notice performance problems due to too many collision checks per frame, you can use very simple optimizations: <br><br>  <strong>1.</strong> How many calculations are required for your collision calculation procedure?  Maybe the square root calculation is hidden somewhere in it (for example, in distance checking)?  Do you perform detailed collision checking (intersection of pixels, triangles, etc.)?  There is a standard technique: first perform a rough check of collisions, and then go to a more detailed one.  You can add objects describing their rectangular or spherical boundary and check the intersection between the boundaries, and then perform a detailed test that requires more mathematical calculations and resources. <br><br><blockquote>  To compare the distances between objects, use the square check of the distance between objects to avoid calculating the square root.  To calculate the square root, the approximation by the Newton method is usually used and it can be very costly. </blockquote><br>  <strong>2.</strong> Is it possible to do without calculating fewer collision checks?  If the game runs at 60 frames per second, can I miss a few frames?  If the behavior of some objects is deterministic, then their collisions can be calculated in advance (for example, between a billiard ball and a table board).  Is it possible to reduce the number of objects for which the scan is performed?  Try to split objects into different lists.  In one list may be "stationary" objects.  Their collisions between each other can never be checked.  In the other list there can be ‚Äúmoving‚Äù objects for which it is necessary to check collisions with all other moving and all stationary objects.  This can reduce the number of required collision checks to an acceptable level in terms of performance. <br><br>  <strong>3.</strong> Is it possible to refuse to check the collisions of some objects when performance problems arise?  For example, a particle of smoke <i>can</i> interact with a surface object and follow its contours to create a beautiful effect, but this should not interfere with the gameplay.  If the number of checks exceeds a certain limit, then you can stop the calculation of collisions for smoke particles.  However, ignoring the movement of <i>important</i> game objects will also destroy the gameplay (for example, player‚Äôs bullets will no longer interact with monsters).  That is, it will be useful to keep a list of priorities for collision checks.  First, collisions with a high priority are processed, and if the limit is not exceeded, then collisions with a low priority can be processed.  When the limit is reached, the game must discard all remaining items in the priority list or postpone their check for the future. <br><br>  <strong>4.</strong> Is it possible to use a faster, but still easy way to recognize collisions in order to get rid of O (N <sup>2</sup> ) at run time?  If you eliminate objects for which collisions have already been checked, then you will reduce the execution time to O (N (N + 1) / 2), which is much faster, but still quite simple to implement (technically, it is still O (N <sup>2</sup> ) ).  From a software development point of view, you can spend as a result more time than it costs to squeeze performance drops out of an improvement in a bad algorithm and an incorrectly chosen data structure.  The cost-benefit ratio becomes increasingly disadvantageous and it is time to choose a more suitable data structure for handling collision recognition. <br><br>  As a solution to the problem of collision recognition at runtime, space partitioning algorithms are actively used.  They select a small part of the speed in advance, but logarithmically reduce the number of collision checks.  The initial development time and CPU costs are easily outweighed by the benefits of scalability and increased speed. <br><br><h2>  Space partitioning concept </h2><br>  Let's take a step back and before moving on to the octodrees, consider the idea of ‚Äã‚Äãsplitting the space and trees as a whole.  If you do not understand this concept, then you will not be able to implement it in code. <br><br>  In the implementation of a simple iteration above, we took each object in the game and compared its position with the positions of all the other objects to check if they were touching.  All these objects are spatially located in the game world.  If we create a shape that restricts the game world and find out which of the objects are contained in this shape, then we will have an area of ‚Äã‚Äãspace with a list of objects contained in it.  In our case, it will contain all the objects of the game. <br><br>  We can notice that one object is at one end of the world, and the other is at the opposite, so we don‚Äôt need to calculate collision checks between them in each frame.  This will be a waste of precious processor time.  Let's try to do something interesting!  If we divide the world exactly in half, we can create three separate lists of objects. <br><br>  The first list, List A, will contain all the objects on the left side of the world. <br><br>  The second list, List B, contains objects from the right side of the world. <br><br>  Some objects may touch the dividing line between the parts, that is, be on either side of it.  For such objects, we will create a third list, List C. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ecd/ae8/e2a/ecdae8e2ab6040554e9e30f73cfd986c.png"><br><br>  It can be noted that with each division we spatially reduce the world in half and collect a list of objects in the resulting half.  To store these lists, we can create a binary search tree.  The concept of such a tree would look something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f71/d6a/d25/f71d6ad255bea6c9d98a28b35fee4af1.png"><br><br>  The tree data structure in pseudocode looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BinaryTree</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,      private List m_objectList; //         private BinaryTree m_left, m_right; //     (   ). private BinaryTree m_parent; }</span></span></code> </pre> <br>  We know that all objects in List A will never intersect with objects in List B, so almost half of the collision checks can be abandoned.  We still have objects in List C that can touch objects in Lists A and B, so we will need to check all List C objects for collisions with all objects in Lists A, B and C. <br><br>  If we continue to divide the world into smaller and smaller parts, then we will continue to reduce the number of checks, each time by half.  This is the basic idea of ‚Äã‚Äãpartitioning space.  There are many ways to split the world into a tree-like data structure ( <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2580%25D0%25B0%25D0%25B7%25D0%25B1%25D0%25B8%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25B0" rel="external nofollow">binary partitioning of space (BSP)</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_%25D0%25BA%25D0%25B2%25D0%25B0%25D0%25B4%25D1%2580%25D0%25B0%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2" rel="external nofollow">quadrant trees</a> , <a href="https://ru.wikipedia.org/wiki/K-%25D0%25BC%25D0%25B5%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">K-dimensional trees</a> , octree <a href="https://ru.wikipedia.org/wiki/K-%25D0%25BC%25D0%25B5%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">trees</a> , etc.). <br><br>  Now we will simply assume, by default, that the best division is division in half, exactly in the middle, because we believe that all objects are distributed around the world approximately evenly.  This is a good assumption, but in some space partitioning algorithms perform a partition in such a way that in each of the halves there is an equal number of objects (weighted division), so that the resulting tree would be more balanced.  However, what happens if all these objects start moving?  To maintain a roughly equal split, you have to either move the section plane, or completely rebuild the tree in each frame.  It is quite confusing and difficult. <br><br>  Therefore, for my own implementation of the partitioning tree, I decided to divide it in half each time.  As a result, some trees will be more sparse, but this is normal and will not lead to high costs. <br><br><h2>  Share or not to divide?  That is the question. </h2><br>  Suppose we have a fairly sparse area with only a few objects.  We can continue to perform the partition until we find the minimum possible bounding space for the last object.  But is it necessary?  Recall that the <i>reason for</i> creating a tree was the reduction in the number of collision checks performed in each frame, and not the creation of the region of space ideally restricting each object.  Here are the rules I chose to decide whether to split or not: <br><br><ul><li>  If we create a partition in which there will be only one object, then we stop splitting, despite the fact that <i>we can</i> break up space further.  This rule will be an important part of the criteria defining the ‚Äúleaf node‚Äù in the octree. </li><li>  Another important criterion is setting the minimum size of an area.  If you have a very small object a few nanometers in size (or there is a bug in the code and you forgot to initialize the size of the object!), The separation will continue and you can potentially overflow the call stack.  For my implementation, I chose the minimum area - a 1x1x1 cube.  For all objects in this cube, it will be necessary to perform a collision check by simple search (O (N <sup>2</sup> )) (I do not count on more objects!). </li><li>  If the area contains no objects, I will not add it to the tree. </li></ul><br>  You can take another step in halving and divide the two-dimensional space of the world into <i>quadrants</i> .  The logic is essentially the same, but now we are checking for collisions between four squares, not two rectangles.  We can continue the partitioning until the completion conditions are satisfied.  The space of the world and the corresponding data structure for the quad tree will look something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b9/48a/088/2b948a088e81982d6eb572cc24d866c2.png"><br><br>  If the division into quad tree and data structure looks logical to you, then the octree will also be understandable.  We simply add the third dimension and use bounding cubes, not squares, that is, we will have eight, not four possible children nodes.  One may wonder what will happen if the game world has non-cubic dimensions, for example, 200x300x400.  Anyway, you can use an octree with cubic dimensions ‚Äî some child nodes will simply be empty if there is nothing in them in the space of the world.  Obviously, it is necessary that the sizes of the octree are at least equal to the larger of the dimensions of the game world. <br><br><h2>  Creating oktotreev </h2><br>  So, as you have already read, octree is a special type of partitioning tree, usually used for objects in three-dimensional space (or anything with three dimensions).  The bounding area will be a three-dimensional rectangle (parallelepiped) (usually a cube).  Then we apply the logic described above and cut the bounding area into eight smaller parallelepipeds.  If the game object is entirely placed in one of these subdivided areas, we drop it down the tree to the node of the area containing it.  Then we continue to recursively divide each resulting area until one of the termination conditions is fulfilled.  As a result, we should have a beautiful tree data structure. <br><br><blockquote>  In my implementation of an octree, there will be objects that have a bounding sphere and / or a bounding box.  You will see that I use a large amount of code to determine which bounding shape is being used. </blockquote><br>  For the <em>Octree</em> class data structure, I chose the following rules for each tree: <br><br><ul><li>  Each node has a bounding area defining its including area. </li><li>  Each node has a link to the parent node. </li><li>  Contains an array of eight child nodes (arrays are used for code simplicity and cache speed) </li><li>  Contains a list of objects in the current area </li><li>  I used a bit mask in byte size to determine which child nodes are being actively used (the <i>advantages of optimization at the cost of additional complexity are a rather controversial issue</i> ) </li><li>  To indicate the state of the tree, I used several static variables. </li></ul><br>  Here is the outline code for my <em>Octree</em> class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OctTree</span></span> { BoundingBox m_region; List m_objects; <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  ,       . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">        ,      .      . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> static Queue m_pendingInsertion = new Queue(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">        . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> OctTree[] m_childNode = new OctTree[8]; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   , ,     . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    ,   ,        . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> byte m_activeNodes = 0; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">     -  1x1x1. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> const int MIN_SIZE = 1; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  ,       . ,    .     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">     ,   ""     (64) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> int m_maxLifespan = 8; // int m_curLife = -1; //    ,     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    .      . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> OctTree _parent; static bool m_treeReady = false; //     ,   ,      static bool m_treeBuilt = false; //      }</span></span></code> </pre> <br><h2>  Initializing the bounding area </h2><br>  The first step in creating an octree is setting the bounding area of ‚Äã‚Äãthe entire tree.  This will be the bounding box for the root node of the tree, which initially contains all the objects in the game world.  Before initializing the bounding volume, we need to make decisions regarding the design: <br><br>  <strong>1.</strong> What <i>should</i> happen when an object moves beyond the bounding volume of the root node?  Will we resize the entire tree so that all objects are limited?  If so, then we will have to completely rebuild the octree from scratch.  If not, then you need to find some way to process objects outside the boundaries, or to make sure that the objects never go beyond the boundaries. <br><br>  <strong>2.</strong> How will we create the bounding area for the octree?  Will we use predefined dimensions, for example, parallelepiped 200x400x200 (X, Y, Z)?  Or we will use cubic sizes.  being a power of two?  What happens if the <i>minimum</i> acceptable bounding area cannot be divided?  I decided that I would use a cubic bounding area with dimensions equal to a power of two, large enough to completely restrict the whole world.  The minimum allowable area is a 1x1x1 cube.  Thanks to this, I will clearly share the world and receive whole numbers (even though <em>Vector3</em> has a floating-point format).  I also decided that my bounding area would limit the whole world, so if an object leaves this area, it will be destroyed.  For the minimum octant, I will perform a collision check by simple brute force.  But I expect that no more than three objects at the same time will occupy such a small area, so O (N <sup>2</sup> ) performance costs are absolutely acceptable.  I standardly initialize an octree with the help of a constructor that gets the size of the region and the list of objects inserted into the tree.  It seemed to me that you should not show this part of the code, because it is elementary, but added it for completeness. <br><br>  Here are my designers: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/*:        ,        .*/</span></span> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  ,         . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  ,     private OctTree(BoundingBox region, List objList) { m_region = region; m_objects = objList; m_curLife = -1; } public OctTree() { m_objects = new List(); m_region = new BoundingBox(Vector3.Zero, Vector3.Zero); m_curLife = -1; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    ,     . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> :       ,     . public OctTree(BoundingBox region) { m_region = region; m_objects = new List(); m_curLife = -1; }</span></span></code> </pre> <br><h2>  Create the initial octree </h2><br>  I'm a big fan of <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D1%2582%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F" rel="external nofollow">deferred initialization</a> .  I try to avoid allocating memory and doing work until it is absolutely necessary.  In the case of an octree, I avoid creating a data structure for as long as possible.  We receive a user request to insert an object into the data structure, but in fact we are not obliged to create a tree until someone starts a queue for it. <br><br>  What does this give us?  Well, suppose that the process of creating and traversing a tree will be quite resource intensive.  If the user wants to give us 1000 objects for insertion into the tree, does it make sense to recalculate each subsequent bounding area a thousand times?          ? <br><br>   ¬´¬ª     ,     .                     .      ,          .      ,   ,    .        <em>UpdateTree()</em> .  ,   ,   ,        . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">        . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">     ? private void UpdateTree() //    { if (!m_treeBuilt) { while (m_pendingInsertion.Count != 0) m_objects.Add(m_pendingInsertion.Dequeue()); BuildTree(); } else { while (m_pendingInsertion.Count != 0) Insert(m_pendingInsertion.Dequeue()); } m_treeReady = true; }</span></span></code> </pre> <br>        . <br><br>           ,    .  ,    ,   ,       ,       .           ,        .  ,         .          ,   ,             ,   . <br><br>        ,           .  ,       ,     . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">     . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> private void BuildTree() //   { // ,       if (m_objects.Count </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;= 1) return; Vector3 dimensions = m_region.Max - m_region.Min; if (dimensions == Vector3.Zero) { FindEnclosingCube(); dimensions = m_region.Max - m_region.Min; } //,       if (dimensions.X &lt;= MIN_SIZE &amp;&amp; dimensions.Y &lt;= MIN_SIZE &amp;&amp; dimensions.Z &lt;= MIN_SIZE) { return; } Vector3 half = dimensions / 2.0f; Vector3 center = m_region.Min + half; //      BoundingBox[] octant = new BoundingBox[8]; octant[0] = new BoundingBox(m_region.Min, center); octant[1] = new BoundingBox(new Vector3(center.X, m_region.Min.Y, m_region.Min.Z), new Vector3(m_region.Max.X, center.Y, center.Z)); octant[2] = new BoundingBox(new Vector3(center.X, m_region.Min.Y, center.Z), new Vector3(m_region.Max.X, center.Y, m_region.Max.Z)); octant[3] = new BoundingBox(new Vector3(m_region.Min.X, m_region.Min.Y, center.Z), new Vector3(center.X, center.Y, m_region.Max.Z)); octant[4] = new BoundingBox(new Vector3(m_region.Min.X, center.Y, m_region.Min.Z), new Vector3(center.X, m_region.Max.Y, center.Z)); octant[5] = new BoundingBox(new Vector3(center.X, center.Y, m_region.Min.Z), new Vector3(m_region.Max.X, m_region.Max.Y, center.Z)); octant[6] = new BoundingBox(center, m_region.Max); octant[7] = new BoundingBox(new Vector3(m_region.Min.X, center.Y, center.Z), new Vector3(center.X, m_region.Max.Y, m_region.Max.Z)); //     ,       . List[] octList = new List[8]; for (int i = 0; i &lt; 8; i++) octList = new List(); //     ,    .       . List delist = new List(); foreach (Physical obj in m_objects) { if (obj.BoundingBox.Min != obj.BoundingBox.Max) { for (int a = 0; a &lt; 8; a++) { if (octant[a].Contains(obj.BoundingBox) == ContainmentType.Contains) { octList[a].Add(obj); delist.Add(obj); break; } } } else if (obj.BoundingSphere.Radius != 0) { for (int a = 0; a &lt; 8; a++) { if (octant[a].Contains(obj.BoundingSphere) == ContainmentType.Contains) { octList[a].Add(obj); delist.Add(obj); break; } } } } //        . foreach (Physical obj in delist) m_objects.Remove(obj); //  ,    ,     for (int a = 0; a &lt; 8; a++) { if (octList[a].Count != 0) { m_childNode[a] = CreateNode(octant[a], octList[a]); m_activeNodes |= (byte)(1 &lt;&lt; a); m_childNode[a].BuildTree(); } } m_treeBuilt = true; m_treeReady = true; } private OctTree CreateNode(BoundingBox region, List objList) //   { if (objList.Count == 0) return null; OctTree ret = new OctTree(region, objList); ret._parent = this; return ret; } private OctTree CreateNode(BoundingBox region, Physical Item) { List objList = new List(1); //         objList.Add(Item); OctTree ret = new OctTree(region, objList); ret._parent = this; return ret; }</span></span></span></span></code> </pre> <br><h2>   </h2><br> ,       <i></i> .  -  ,    ,        .     ,    ? <br><br> <b> 1:   ,     .</b> <br><br>             .   ,        ,    .  ,             ,      ,     ,      .    ,     ,  ¬´  ¬ª   : <br><br><ol><li>           .       .          ,     . </li><li> ÃÅ    ,         ‚Äî     . </li></ol><br> <b> 2:   ,   .</b> <br><br>  ,       .     . <br><br>    ,              ,  ?          ,     .    ,   ,     ! <br><br>       ,              .  This is not true.        ,         ,        ,  ,   .       ,       .  ,        ,      .       <i></i>     . <br><br>  ,        ,       ,   ! <br><br>       ,         .       .       ,        , ,     . <br><br>     ,          <i></i> ,    ,       (     -    ).        ,        .          . <br><br>  ,       <i></i>  ,         .  ,      ,       .     ,        ,         .         ,       ,           . <br><br> <b> </b> <br><br>                ,     .       <i> </i> .            . <br><br>    : <i></i>      ?      ,      <i> </i>       ,     ?     ,       ? <br><br>         , ,    .       ,    ,       .  ,          ,        ,      . <br><br>         ,   .        ,         ,      ,             .  ,       - .        ,        . <br><br>     ,    . <br><br>  ,     <em>Update()</em> .       .    ,     ,          (  ). <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTime gameTime</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_treeBuilt == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//        ,      . //   ,   .       ,    . //               if (m_objects.Count == 0) { if (HasChildren == false) { if (m_curLife == -1) m_curLife = m_maxLifespan; else if (m_curLife &gt; 0) { m_curLife--; } } } else { if (m_curLife != -1) { if(m_maxLifespan &lt;= 64) m_maxLifespan *= 2; m_curLife = -1; } } List movedObjects = new List(m_objects.Count); //         foreach (Physical gameObj in m_objects) { //  ,   ,        . if (gameObj.Update(gameTime)) { movedObjects.Add(gameObj); } } //     . int listSize = m_objects.Count; for (int a = 0; a &lt; listSize; a++) { if (!m_objects[a].Alive) { if (movedObjects.Contains(m_objects[a])) movedObjects.Remove(m_objects[a]); m_objects.RemoveAt(a--); listSize--; } } //    . for( int flags = m_activeNodes, index = 0; flags &gt; 0; flags &gt;&gt;=1, index++) if ((flags &amp; 1) == 1) m_childNode[index].Update(gameTime); //  ,       ,        . //,       ,          . foreach (Physical movedObj in movedObjects) { OctTree current = this; //,       ,     //      //      ,      if (movedObj.BoundingBox.Max != movedObj.BoundingBox.Min) { while (current.m_region.Contains(movedObj.BoundingBox) != ContainmentType.Contains) if (current._parent != null) current = current._parent; else break; //  ,        } else { while (current.m_region.Contains(movedObj.BoundingSphere) != ContainmentType.Contains)//,     ,     . if (current._parent != null) current = current._parent; else break; } //           . m_objects.Remove(movedObj); current.Insert(movedObj); //        ,  . } //     for (int flags = m_activeNodes, index = 0; flags &gt; 0; flags &gt;&gt;= 1, index++) if ((flags &amp; 1) == 1 &amp;&amp; m_childNode[index].m_curLife == 0) { m_childNode[index] = null; m_activeNodes ^= (byte)(1 &lt;&lt; index); //       } //,          ,   . if (IsRoot == true) { //       . //               . //:  ,        . // 2:     ,    .         . List irList = GetIntersection(new List()); foreach (IntersectionRecord ir in irList) { if (ir.PhysicalObject != null) ir.PhysicalObject.HandleIntersection(ir); if (ir.OtherPhysicalObject != null) ir.OtherPhysicalObject.HandleIntersection(ir); } } } else { } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that for displaced objects we call the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insert ()</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Inserting objects into a tree is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> similar to the method used to create the original tree. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insert ()</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tries to pull objects down through the tree as low as possible. </font><font style="vertical-align: inherit;">I also strive to avoid creating new bounding spaces if one can use the existing ones in the child node.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   ,       ,     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">       private void Insert(T Item) where T : Physical { /*,     ,   -       ,   .*/ if (m_objects.Count </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;= 1 &amp;&amp; m_activeNodes == 0) { m_objects.Add(Item); return; } Vector3 dimensions = m_region.Max - m_region.Min; //,       if (dimensions.X &lt;= MIN_SIZE &amp;&amp; dimensions.Y &lt;= MIN_SIZE &amp;&amp; dimensions.Z &lt;= MIN_SIZE) { m_objects.Add(Item); return; } Vector3 half = dimensions / 2.0f; Vector3 center = m_region.Min + half; //           BoundingBox[] childOctant = new BoundingBox[8]; childOctant[0] = (m_childNode[0] != null) ? m_childNode[0].m_region : new BoundingBox(m_region.Min, center); childOctant[1] = (m_childNode[1] != null) ? m_childNode[1].m_region : new BoundingBox(new Vector3(center.X, m_region.Min.Y, m_region.Min.Z), new Vector3(m_region.Max.X, center.Y, center.Z)); childOctant[2] = (m_childNode[2] != null) ? m_childNode[2].m_region : new BoundingBox(new Vector3(center.X, m_region.Min.Y, center.Z), new Vector3(m_region.Max.X, center.Y, m_region.Max.Z)); childOctant[3] = (m_childNode[3] != null) ? m_childNode[3].m_region : new BoundingBox(new Vector3(m_region.Min.X, m_region.Min.Y, center.Z), new Vector3(center.X, center.Y, m_region.Max.Z)); childOctant[4] = (m_childNode[4] != null) ? m_childNode[4].m_region : new BoundingBox(new Vector3(m_region.Min.X, center.Y, m_region.Min.Z), new Vector3(center.X, m_region.Max.Y, center.Z)); childOctant[5] = (m_childNode[5] != null) ? m_childNode[5].m_region : new BoundingBox(new Vector3(center.X, center.Y, m_region.Min.Z), new Vector3(m_region.Max.X, m_region.Max.Y, center.Z)); childOctant[6] = (m_childNode[6] != null) ? m_childNode[6].m_region : new BoundingBox(center, m_region.Max); childOctant[7] = (m_childNode[7] != null) ? m_childNode[7].m_region : new BoundingBox(new Vector3(m_region.Min.X, center.Y, center.Z), new Vector3(center.X, m_region.Max.Y, m_region.Max.Z)); //-,        ? // 2:       .       ,     /. // .           .     . // :       256x256x256.    . if (Item.BoundingBox.Max != Item.BoundingBox.Min &amp;&amp; m_region.Contains(Item.BoundingBox) == ContainmentType.Contains) { bool found = false; //     .       ,        . for(int a=0;a&lt;8;a++) { //     ? if (childOctant[a].Contains(Item.BoundingBox) == ContainmentType.Contains) { if (m_childNode[a] != null) m_childNode[a].Insert(Item); //          ,     else { m_childNode[a] = CreateNode(childOctant[a], Item); //      m_activeNodes |= (byte)(1 &lt;&lt; a); } found = true; } } if(!found) m_objects.Add(Item); } else if (Item.BoundingSphere.Radius != 0 &amp;&amp; m_region.Contains(Item.BoundingSphere) == ContainmentType.Contains) { bool found = false; //     .       ,        . for (int a = 0; a &lt; 8; a++) { //     ? if (childOctant[a].Contains(Item.BoundingSphere) == ContainmentType.Contains) { if (m_childNode[a] != null) m_childNode[a].Insert(Item); //A          ,     else { m_childNode[a] = CreateNode(childOctant[a], Item); //      m_activeNodes |= (byte)(1 &lt;&lt; a); } found = true; } } if (!found) m_objects.Add(Item); } else { //      ,   .     ,    // ,      //BoundingBox enclosingArea = FindBox(); BuildTree(); } }</span></span></span></span></code> </pre> <br><h2>  Collision detection </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we built an octree tree and all the objects are where needed. </font><font style="vertical-align: inherit;">How to perform collision detection? </font><font style="vertical-align: inherit;">First, let's list the different ways in which we want to recognize collisions:</font></font><br><br><ol><li> <b>   .</b>      ,    .    ,     .               ,       . </li><li> <b>  .</b>           ,      ,     ,     (,  ).     <a href="http://away3d.com/tutorials/Introduction_to_Mouse_Picking" rel="external nofollow"> </a> .     ,      ,    . </li><li> <b>   .</b>   ,       .         ¬´¬ª (,   ..). </li><li> <b>   .</b>   ,       .             ,          . </li></ol><br>           ,     /            . <br><br>               .        ,         .       ,         .        <i></i>  .        .               . <br><br>     ,        ,     .     ,  ,    .    -         ,     . ,         (quad damage!),     ,    . <br><br>    ,        .       ,  ,      ..      ,      ,    . <br><br>           : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IntersectionRecord</span></span> { Vector3 m_position; <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    3D-,    . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> public Vector3 Position { get { return m_position; } } Vector3 m_normal; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">       </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> public Vector3 Normal { get { return m_normal; } } Ray m_ray; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  ,    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> public Ray Ray { get { return m_ray; } } Physical m_intersectedObject1; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  ,    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> public Physical PhysicalObject { get { return m_intersectedObject1; } set { m_intersectedObject1 = value; } } Physical m_intersectedObject2; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">     (   null, ,    -) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> public Physical OtherPhysicalObject { get { return m_intersectedObject2; } set { m_intersectedObject2 = value; } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">       ,    .      </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">           .   -       , </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">        ,      . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> OctTree m_treeNode; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">       .      ,     . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> ,     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> ,   -      ,    . public override bool Equals(object otherRecord) { IntersectionRecord o = (IntersectionRecord)otherRecord; // // (m_intersectedObject1 != null &amp;&amp; m_intersectedObject2 != null &amp;&amp; m_intersectedObject1.ID == m_intersectedObject2.ID); if (otherRecord == null) return false; if (o.m_intersectedObject1.ID == m_intersectedObject1.ID &amp;&amp; o.m_intersectedObject2.ID == m_intersectedObject2.ID) return true; if (o.m_intersectedObject1.ID == m_intersectedObject2.ID &amp;&amp; o.m_intersectedObject2.ID == m_intersectedObject1.ID) return true; return false; } double m_distance; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">       . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">     ,      . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> public double Distance { get { return m_distance; } } private bool m_hasHit = false; public bool HasHit { get { return m_hasHit; } } public IntersectionRecord() { m_position = Vector3.Zero; m_normal = Vector3.Zero; m_ray = new Ray(); m_distance = float.MaxValue; m_intersectedObject1 = null; } public IntersectionRecord(Vector3 hitPos, Vector3 hitNormal, Ray ray, double distance) { m_position = hitPos; m_normal = hitNormal; m_ray = ray; m_distance = distance; // m_hitObject = hitGeom; m_hasHit = true; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    ,   ,   ,      . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> : ,    .   null. public IntersectionRecord(Physical hitObject = null) { m_hasHit = hitObject != null; m_intersectedObject1 = hitObject; m_position = Vector3.Zero; m_normal = Vector3.Zero; m_ray = new Ray(); m_distance = 0.0f; } }</span></span></code> </pre> <br><h2>      </h2><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">     ,          </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">      /  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">      private List GetIntersection(BoundingFrustum frustum, Physical.PhysicalType type = Physical.PhysicalType.ALL) { if (m_objects.Count == 0 &amp;&amp; HasChildren == false) //   return null; List ret = new List(); //       foreach (Physical obj in m_objects) { //  ,     if ((int)((int)type &amp; (int)obj.Type) == 0) continue; //   IntersectionRecord ir = obj.Intersects(frustum); if (ir != null) ret.Add(ir); } //       for (int a = 0; a </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; 8; a++) { if (m_childNode[a] != null &amp;&amp; (frustum.Contains(m_childNode[a].m_region) == ContainmentType.Intersects || frustum.Contains(m_childNode[a].m_region) == ContainmentType.Contains)) { List hitList = m_childNode[a].GetIntersection(frustum); if (hitList != null) { foreach (IntersectionRecord ir in hitList) ret.Add(ir); } } } return ret; }</span></span></span></span></code> </pre> <br>           ,        .     ,  ,       .       ,      : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">         </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> public int Render() { int triangles = 0; //    ,       //       foreach (IntersectionRecord ir in m_octTree.AllIntersections(m_cameras[m_activeCamera].Frustum)) { ir.PhysicalObject.SetDirectionalLight(m_globalLight[0].Direction, m_globalLight[0].Color); ir.PhysicalObject.View = m_cameras[m_activeCamera].View; ir.PhysicalObject.Projection = m_cameras[m_activeCamera].Projection; ir.PhysicalObject.UpdateLOD(m_cameras[m_activeCamera]); triangles += ir.PhysicalObject.Render(m_cameras[m_activeCamera]); } return triangles; }</span></span></code> </pre> <br><h2>    </h2><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">       ,     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> ,     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    private List GetIntersection(Ray intersectRay, Physical.PhysicalType type = Physical.PhysicalType.ALL) { if (m_objects.Count == 0 &amp;&amp; HasChildren == false) //   return null; List ret = new List(); //    ,              . //        foreach (Physical obj in m_objects) { //   ,     if ((int)((int)type &amp; (int)obj.Type) == 0) continue; if (obj.BoundingBox.Intersects(intersectRay) != null) { IntersectionRecord ir = obj.Intersects(intersectRay); if (ir.HasHit) ret.Add(ir); } } //       for (int a = 0; a </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; 8; a++) { if (m_childNode[a] != null &amp;&amp; m_childNode[a].m_region.Intersects(intersectRay) != null) { List hits = m_childNode[a].GetIntersection(intersectRay, type); if (hits != null) { foreach (IntersectionRecord ir in hits) ret.Add(ir); } } } return ret; }</span></span></span></span></code> </pre> <br><h2>     </h2><br>                   ( .   <em>Update()</em> ).      ,        . <br><br>     .               .           .      ,   .         ,    ,    .            .     ,    ,      ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7bf/a8e/7fc/7bfa8e7fcca54aa3ea0a07d51cf549e1.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ca/00c/ba6/9ca00cba6d492de44aa77b3016b277be.png"><br><br>       ,   ,   29     4.   ,  [11*11 = 121]  . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetIntersection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List parentObjs, Physical.PhysicalType type = Physical.PhysicalType.ALL</span></span></span><span class="hljs-function">)</span></span> { List intersections = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List(); <span class="hljs-comment"><span class="hljs-comment">// ,          . //            foreach (Physical pObj in parentObjs) { foreach (Physical lObj in m_objects) { //    .   ,      . //   ,   . IntersectionRecord ir = pObj.Intersects(lObj); if (ir != null) { intersections.Add(ir); } } } //         if (m_objects.Count &gt; 1) { #region self-congratulation /* *     .      foreach,  : * foreach(Physical lObj1 in m_objects) * { * foreach(Physical lObj2 in m_objects) * { * //    * } * } * *   ,    O(N*N)    ,      . * ,        : {1,2,3,4} *    {1}  {1,2,3,4} *   {2}  {1,2,3,4}, *     {1}  {2},    {2}  {1}    .     ,  {1}? *     4+3+2+1  ,    O(N(N+1)/2).  N = 10,       . *           for,       foreach,    *  for(int i=0;i tmp = new List(m_objects.Count); tmp.AddRange(m_objects); while (tmp.Count &gt; 0) { foreach (Physical lObj2 in tmp) { if (tmp[tmp.Count - 1] == lObj2 || (tmp[tmp.Count - 1].IsStatic &amp;&amp; lObj2.IsStatic)) continue; IntersectionRecord ir = tmp[tmp.Count - 1].Intersects(lObj2); if (ir != null) intersections.Add(ir); } //      ,    O(N(N+1)/2)   O(N*N) tmp.RemoveAt(tmp.Count-1); } } //         ,        . foreach (Physical lObj in m_objects) if (lObj.IsStatic == false) parentObjs.Add(lObj); //parentObjs.AddRange(m_objects); //       ,        . for (int flags = m_activeNodes, index = 0; flags &gt; 0; flags &gt;&gt;= 1, index++) if ((flags &amp; 1) == 1) intersections.AddRange(m_childNode[index].GetIntersection(parentObjs, type)); return intersections; } ;i++)&gt;</span></span></code> </pre> <br><h2>   </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/976/e75/c85/976e75c85099b51d5814fe36710d9e66.png"><br> <i>     ,      .</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/296/ced/ffb/296cedffbd5de8f4cfdd2a3395e81812.png"><br> <i>    ,    .    ,   .</i> </div><p>Source: <a href="https://habr.com/ru/post/334990/">https://habr.com/ru/post/334990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334980/index.html">Hidden messages in JavaScript property names</a></li>
<li><a href="../334982/index.html">Application availability for visually impaired users</a></li>
<li><a href="../334984/index.html">Resource planning. Part 1. What is it all about?</a></li>
<li><a href="../334986/index.html">Comedy. Actors in Node.JS for flexible scaling</a></li>
<li><a href="../334988/index.html">Struct, union, and enum types in Modern C ++</a></li>
<li><a href="../334992/index.html">How to view 20 million domain names and be satisfied</a></li>
<li><a href="../334994/index.html">I want to like YouTube</a></li>
<li><a href="../334996/index.html">Usability card product. Scenario profitable for business</a></li>
<li><a href="../334998/index.html">Protection of the site against attacks using Nemesida WAF: from signatures to artificial intelligence</a></li>
<li><a href="../335002/index.html">Lecture by Vladimir Iglovikov at machine training for Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>