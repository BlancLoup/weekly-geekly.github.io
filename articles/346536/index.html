<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mobile devices from the inside. The image structure of partitions containing the file system. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The image structure of partitions containing the file system. Part 2. 
 Start publishing, read in Part 1. 

 Table of contents  Part 2  3.2._sparsechu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mobile devices from the inside. The image structure of partitions containing the file system. Part 2</h1><div class="post__text post__text-html js-mediator-article"><h2>  The image structure of partitions containing the file system.  Part 2. </h2><br>  Start publishing, read in <a href="https://habrahabr.ru/post/345726/"><b>Part 1.</b></a> <br><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Part 2</b> <div class="spoiler_text">  <a href="https://habr.com/ru/post/346536/">3.2._sparsechunk files.</a> <br>  <a href="https://habr.com/ru/post/346536/">3.2.1.Structure of _sparsechunk-files.</a> <br>  <a href="https://habr.com/ru/post/346536/">3.2.2. Examples of working with _sparsechunk-files.</a> <br>  <a href="https://habr.com/ru/post/346536/"><b>4. Creating <b>dat</b> files.</b></a> <br>  <a href="https://habr.com/ru/post/346536/">4.1.Struktura <b>dat-</b> files.</a> <br>  <a href="https://habr.com/ru/post/346536/">4.1.1. The structure of the transfer_list file.</a> <br>  <a href="https://habr.com/ru/post/346536/">4.1.2. Structure of a new_data-file.</a> <br>  <a href="https://habr.com/ru/post/346536/">4.1.3.The structure of the patch_data file.</a> <br>  <a href="https://habr.com/ru/post/346536/">4.2. Description of data structures.</a> <br>  <a href="https://habr.com/ru/post/346536/">4.2.1. The structure of the description of the range of info-blocks (set of ranges [rangeset])</a> <br>  <a href="https://habr.com/ru/post/346536/">4.2.2.Stash-band structure (stash_rangeset)</a> <br>  <a href="https://habr.com/ru/post/346536/">4.2.3. The structure of the input data set &lt;...&gt;</a> <br>  <a href="https://habr.com/ru/post/346536/">4.3. Structure and description of transfer_list-file commands.</a> <br>  <a href="https://habr.com/ru/post/346536/">4.3.1.Commands ‚Äúerase‚Äù, ‚Äúnew‚Äù, ‚Äúzero‚Äù</a> <br>  <a href="https://habr.com/ru/post/346536/">4.3.2. The "move" command</a> <br>  <a href="https://habr.com/ru/post/346536/">4.3.3. The bsdiff and imgdiff commands</a> <br>  <a href="https://habr.com/ru/post/346536/">4.3.4. The "stash" command</a> <br>  <a href="https://habr.com/ru/post/346536/">4.3.5. Team "free"</a> <br></div></div><br>  To be continued‚Ä¶ <br><div class="spoiler">  <b class="spoiler_title">Part 3</b> <div class="spoiler_text">  4.4.Examples of working with dat-files. <br></div></div><br>  <a href="https://habr.com/ru/post/346536/"><b>5. Conclusion.</b></a> <br>  <a href="https://habr.com/ru/post/346536/"><b>6. Sources of information.</b></a> <br></div></div><br><a name="32"></a><h3>  3.2._sparsechunk files </h3><br>  Since  Although the <b>sparse</b> file, although it is a compressed source data file, can also be quite large, its modification appeared, called <b>_sparsechunk</b> files, which is the same <b>sparse</b> file, but cut into smaller pieces based on a previously selected borders (according to the file cutting algorithm). <br><br>  This add-on allows you to use compressed <b>sparse</b> files to transfer updates via OTA or download in <b>fastboot</b> mode. <br><a name="habracut"></a><br><a name="321"></a><h4>  3.2.1.Structure of _sparsechunk-files </h4><br>  By structure, each <b>_sparsechunk</b> file is a regular <b>sparse</b> file, but containing not all, but only a part of the input file, for example, a partition image.  The size of this part is compressed, i.e.  in a <b>sparse</b> view, must not exceed a predetermined value or boundary.  Currently, the "border" size <b>_sparsechunk</b> file, is usually 256MB ( <b>268,435,456</b> bytes). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The next part of the <b>sparse</b> file is contained in the next <b>_sparsechunk</b> file, etc. <br><br>  Externally, these files are distinguished by an index in the name, which determines the sequence of their processing during decoding.  The index may simply be an ordinal number or may be represented as an offset in the input file up to a chunk. <br><br>  So  First, the image of the section is encoded into a <b>sparse</b> file, and then converted (cut) into a set of <b>_sparsechunk</b> files. <br><br>  The process of creating a <b>_sparsechunk</b> file can be described by the following algorithm: <br><br><ol><li>  The finished <b>sparse</b> file is viewed and all consecutive pieces (chunks) of the Raw and Fill types are grouped into a group called ‚Äúdata‚Äù, the length of which is constantly monitored.  The procedure is performed until the group size reaches the limit, the value of which is indicated in advance and is determined by the requirements listed above when describing the file splitting process; </li><li>  If the joining of the next piece leads to exceeding the border, then it is not included in the group, and a separate file is formed from the already grouped pieces, to which a piece of the <b>DontCare</b> type, called ‚Äúfinal‚Äù, is added, in which the data offset to the end of the output file is specified in the <b>Chunk_Size</b> field.  This file is named _sparsechunk.1; </li><li>  The sparse file continues to be searched according to the method of paragraphs 1‚Äì2 and the next <b>_sparsechunk</b> file is formed; just before its formation, a <b>sparse</b> DontCare <b>piece</b> , called ‚Äúinitial‚Äù, is added to the <b>sparse</b> group of pieces in front of which the data offset is specified in the <b>Chunk_Size</b> field, contained in this file, from the beginning of the original image.  At the end of the ‚Äúfinal‚Äù piece is added, formed by the above algorithm; </li><li>  This continues until the end of the <b>sparse</b> file is reached. </li></ol><br>  Thus, each <b>_sparsechunk</b> file can consist of three parts, which I have named: <br><br><ol><li>  <b>OFFSET_TO_START</b> - contains the "initial" piece; </li><li>  <b>INFO</b> - the part containing the "data"; </li><li>  <b>OFFSET_TO_END</b> - contains the "final" piece. </li></ol><br>  The <b>OFFSET_TO_START</b> part is an offset in the input file before the beginning of the ‚Äúdata‚Äù part that contains information in the sparse form. <br><br>  The <b>INFO</b> part contains only information in a sparse form, consisting of <b>sparse</b> pieces of the type <b>Fill</b> and <b>Raw</b> . <br><br>  The <b>OFFSET_TO_END</b> part is the offset to the end of the output file.  If the offset is zero, i.e.  <b>if the _sparsechunk</b> file containing the info group is the last in the set of <b>_sparsechunk</b> files, then the <b>OFFSET_TO_END</b> part <b>is</b> completely absent. <br><br><a name="322"></a><h4>  3.2.2. Working with _sparsechunk files </h4><br>  As an example of working with _sparsechunk files, let's look at the conversion of <b>_sparsechunk</b> files into a <b>sparse</b> file and back by the example of the system.img_sparsechunk.0 fileset - system.img_sparsechunk.4 firmware from Moto X <a href="https://habr.com/ru/post/346536/">[5]</a> . <br><br><h5>  3.2.2.1. Converting a list of _sparsechunk files into one file </h5><br>  Above, I showed that when converting to <b>_sparsechunk</b> files, the contents of the source <b>sparse</b> file are simply divided into info parts, which, if necessary, are wrapped in additional pieces.  Accordingly, to restore the original sparse file, it is necessary to discard the wrapper chunks, if any, from each <b>_sparsechunk</b> file, and simply add all the info parts together, counting the total number of <b>sparse</b> chunks. <br><br><ol><li>  Open <b>system.img_sparsechunk.0</b> in a hex editor: <br><img src="https://habrastorage.org/webt/bx/hl/4v/bxhl4vuoyk2vv2gnrfdpfm3eoxe.png"><br>  <b>Fig.8</b> .  sparsechunk_0 <br><br>  It is seen that from the address <b>0x0000</b> to the address <b>0x001B</b> is the header of the <b>sparse</b> file.  Further, from the address <b>0x001C</b> follows the info-group, starting with a piece of type <b>0xCAC1</b> , having the length of the data area along with the header <b>0x100C</b> (address <b>0x0024</b> ).  Consequently, the next piece will be located starting at the address: <br><br><pre><code class="xml hljs">0001 + 0100 = 01028</code> </pre> <br>  Let's see what is located at this address: <br><br><img src="https://habrastorage.org/webt/v5/iy/cs/v5iycsbwn0dm2wrtu77f2pb687k.png"><br>  <b>Fig.9</b> .  Piece 2 <br><br>  Address <b>0x1028</b> is a piece of type <b>0xCAC2</b> , having a length of <b>0x0010</b> (address <b>0x1030</b> ).  Then (address <b>0x1038</b> ) again a piece of type <b>0xCAC1</b> , etc. <br><br>  The last piece of this file is located at <b>0x0FFFF524</b> and is of type <b>0xCAC3</b> , i.e.  This is a piece of type <b>OFFSET_TO_END</b> , having a size of <b>0x067AD4</b> .  Delete it as useless: <br><br><img src="https://habrastorage.org/webt/5h/ym/fy/5hymfye5mw7qy7elsl9lupekm_0.png"><br>  <b>Fig.10</b> .  First _sparsechunk_end <br><br>  So, from the first <b>_sparsechunk</b> file we left only the <b>sparse</b> file header and ‚Äúdata‚Äù.  Let us also remember the number of pieces that are in the ‚Äúdata‚Äù - <b>0x005D</b> (see the field at <b>0x0014</b> ), but this, together with a piece of the <b>OFFSET_TO_END</b> type, therefore, in fact, we ‚Äúgot‚Äù only <br><br><pre> <code class="xml hljs">0x005D - 00001 = 0005</code> </pre> <br></li><li>  Open the following <b>_sparsechunk</b> file - <b>system.img_sparsechunk.1</b> in the hex editor: <br><br><img src="https://habrastorage.org/webt/ts/vc/ye/tsvcyeuhypkkpvu7y-btpcpbygs.png"><br>  <b>Fig.11a. The</b> beginning of the second piece <br><br><img src="https://habrastorage.org/webt/rt/po/cg/rtpocgrcbqikkjxyypjbf0uerua.png"><br>  <b>Fig.11b. The</b> end of the second piece <br><br>  Copy the content, discarding the header, the initial and last pieces of type <b>0xCAC3</b> , ie, starting from address <b>0x0028</b> to address <b>0xFBFC46C</b> , and add it to the end of the previous part to the place of the remote last piece of type <b>0xCAC3</b> (address <b>0xFFFF524</b> ).  This picture should turn out like this: <br><br><img src="https://habrastorage.org/webt/tl/3p/yv/tl3pyv45rorvm-ewq9pxnlob-sm.png"><br>  <b>Fig.12</b> .  Addition of two parts <br><br>  Those.  we got this "pie": <br><br><ul><li>  <b>sparse</b> file header; </li><li>  "Data" of the first <b>_sparsechunk</b> file; </li><li>  "Data" of the second <b>_sparsechunk</b> file. </li></ul><br><img src="https://habrastorage.org/webt/cf/9b/a5/cf9ba5hbpnwoygowdnhvdee4tgg.png"><br>  <b>Fig.13</b> .  End of the folded file <br><br>  Do not forget to sum up the total number of pieces, i.e.  add the number of pieces in the added ‚Äúdata‚Äù <br><br><pre> <code class="xml hljs">0x005 + (0x0050 - 00002) = 0x00A</code> </pre> <br></li><li>  We continue to perform steps 2 for all the remaining <b>_sparsechunk</b> files except the last.  After processing each new file, our ‚Äúpie‚Äù will grow due to the addition of the ‚Äúdata‚Äù itself: <br><br><img src="https://habrastorage.org/webt/3s/ah/no/3sahnornviwn-w6gdqqpjdccz_u.png"><br>  <b>Fig.14</b> .  Adding a second file <br><br>  And we continue to summarize the number of pieces ... </li><li>  Add to the "cake" the last <b>_sparsechunk</b> file, following the steps in <b>step</b> 2, discarding only the title and the initial piece of type <b>0xCAC3 from it</b> .  Here's what we got: <br><br><img src="https://habrastorage.org/webt/rx/mn/ae/rxmnael8sgwnozs-ccbel6m-4oa.png"><br>  <b>Fig.15</b> .  Result <br><br>  The size of this file is <b>0x4173FBD4</b> ( <b>1098120148</b> or approximately 1047MB), and the total number of pieces is <b>0x01FB</b> ( <b>507</b> ), we write it at <b>0x0014</b> (the number of pieces header <b>Total_Chunks field</b> ).  8 pieces that we took away from the total number are pieces of type 0xCAC3: 1 is the final piece from part 0 of the <b>_sparsechunk</b> file, 2 pieces from parts 1-3 and 1 piece from the last (fourth) part. <br><br><img src="https://habrastorage.org/webt/gn/ev/ab/gnevabcvytdnzr-rn0aw4m-6ify.png"><br>  <b>Fig.16</b> .  Record the total number of pieces in all <b>_sparsechunk</b> files <br><br>  If necessary, in the <b>Image_Checksum</b> field (address 0x0018) of the header, enter the checksum calculated using the <b>Crc32</b> algorithm for the entire file, i.e.  header + all pieces.  Usually this field is not filled and remains zero. </li><li>  Save the resulting <b>sparse</b> file under the name, for example, <b>system.sparse</b> . </li></ol><br>  All assembly <b>sparse</b> files from the pieces is completed. <br><br><h5>  3.2.2.2. Converting a sparse file into a set of _sparsechunk files or cutting (splitting) into chunks </h5><br>  Now let's try to cut the created <b>sparse</b> file into <b>_sparsechunk</b> files.  We take 256MB (0x10000000) as the border value. <br><br><ol><li>  Open the file <b>system.sparse</b> , in which we will perform all the actions described below, in the hex editor: <br><br><img src="https://habrastorage.org/webt/sk/ep/0h/skep0hvb38nfax7uvdihsseng60.png"><br>  <b>Fig.17</b> .  <b>system.sparse</b> file <br><br>  and divide it into separate <b>_sparsechunk parts</b> , containing only ‚Äúdata‚Äù. </li><li>  Create the first <b>_sparsechunk</b> file.  To do this, go to the offset 0x10000000 from the current position of the marker (for the first file it is 0x0000), i.e.  let's get to the maximum size of the future <b>_sparsechunk</b> file.  For the first file it will be the address 0x10000000: <br><img src="https://habrastorage.org/webt/ga/--/i7/ga--i7u8nwnaqfhaybumfowstge.png"><br>  <b>Fig.18</b> .  _Sparsechunk file boundary <br><br>  and start looking down the beginning of a piece of any type, i.e.  codes 0xCAC1 or 0xCAC2.  The nearest piece of type 0xCAC1 is located at 0xFFFF524: <br><img src="https://habrastorage.org/webt/ig/m4/c0/igm4c0py4m1zbr2okkqhi2hwhn8.png"><br>  <b>Fig.19</b> .  The boundary of the section _sparsechunk files <br><br>  To make sure that we have found the most recent piece that ‚Äúfit‚Äù to the dimensions of the ‚Äúborder‚Äù, add to the offset found the size of this piece + the size of the header to find the beginning of the next piece: <br><br><pre> <code class="xml hljs">0xFFFF524 + 0x41D2000 + 0x000C = 0x141D1530</code> </pre> <br>  Since  displacement of the next piece goes "border", then we found the point of the section <b>_sparsechunk</b> files.  Save the code of the <b>system.sparse</b> file from <b>0x00000000</b> to <b>0xFFFF524</b> to a file, for example, <b>system_new_sparsechunk_0.img</b> . </li><li>  Repeat step 2, taking the beginning of the last piece found in the previous step, i.e.  <b>0xFFFF524</b> .  Let's move the offset <b>0x10000000</b> from the current position: <br><br><img src="https://habrastorage.org/webt/zk/tq/sh/zktqshqckjfrvlihkppdzea-ttw.png"><br>  <b>Fig.20</b> .  The border of the second file <br><br>  We get the maximum value, i.e.  the address of the beginning of the next <b>_sparsechunk</b> <b>part 0x1FFFF524</b> .  Find the nearest piece to the lower side, i.e.  <b>Estimated</b> boundary between parts of <b>_sparsechunk</b> files: <br><br><img src="https://habrastorage.org/webt/lu/gk/mo/lugkmopeqd2rclxj6l-k-4srzvm.png"><br>  <b>Fig.21</b> .  The second boundary of the _sparsechunk files section <br><br>  Check if we found the last piece correctly, i.e.  determine the offset to the next piece: <br><br><pre> <code class="xml hljs">0x1FBFB968 + 0x01897000 + 0x000C = 0x21492968</code> </pre> <br>  Since  the offset moves the expected offset of the beginning of the next part, then we correctly found the point of the section <b>_sparsechunk</b> -parts.  Save the following code for the <b>system.sparse</b> file from <b>0xFFFF524</b> to <b>0x1FBFB968</b> to a file, for example, <b>system_new_sparsechunk_1.img</b> . </li><li>  Repeat step 3 to the end of the <b>system.sparse</b> file.  As a result, we got a set of the following files: <br><br><pre> <code class="xml hljs"> =========================================================================== | ‚Ññ |  |  |  |  | | / |  |  |  |  |  | |=====|===================|========|============|============|==============| | 1 | new_sparsechunk_0 | 256 | 0x00000000 | 0x0FFFF523 | 0x005C ( 92) | | 2 | new_sparsechunk_1 | 252 | 0x0FFFF524 | 0x1FBFB967 | 0x004E ( 78) | | 3 | new_sparsechunk_2 | 242 | 0x1FBFB968 | 0x2EE61403 | 0x00C2 (194) | | 4 | new_sparsechunk_3 | 235 | 0x2EE61404 | 0x3D92DA5B | 0x0074 (116) | | 5 | new_sparsechunk_4 | 62 | 0x3D92DA5C | 0x4173FBD3 | 0x001B ( 27) | |============================================================|==============| | : | 0x01FB (507) | ===========================================================================</code> </pre> </li><li>  Create in each <b>_sparsechunk parts</b> , except the first, because  He was there immediately, the title of the <b>sparse</b> file.  To do this, copy the header from <b>system.sparse</b> and paste it into each part at the beginning of the file.  Using the data from the previous table, we enter the value from the " <b>Number of pieces</b> " column in the <b>Total_Chunks</b> field at <b>0x0014 of</b> each file. </li></ol><br>  That's it, the process of cutting into <b>_sparsechunk is</b> complete. <br><br><blockquote>  PS All these "horrors" with transitions on shift, search of the necessary pieces, calculation of the sizes of files, etc.  I described only in order to show the developer of the MU the procedure necessary to perform work on the processing of <b>sparse</b> - and <b>_sparsechunk</b> files.  I never do it myself, because  there are computers ... and applications written by me. <br><br>  Those who wish, having studied the above materials, can themselves create applications to their own taste and color. </blockquote><br><a name="4"></a><h2>  4. Creating Dat Files </h2><br>  <b>Dat</b> file is the next step of image compression of partitions.  Unlike a <b>sparse</b> file, it contains only informational parts.  And to ensure the assembly of the source file, a file called <b>transfer_list is created</b> . <br><br>  In this case, the source file is divided into parts containing useful information, i.e.  info-blocks, and ‚Äúempty‚Äù blocks, i.e.  containing zeros.  Then all the parts with information are copied in succession to the output file, called <b>new_data</b> , and information about their placement in the source file and the size of these parts is recorded in the <b>transfer_list</b> file. <br><br>  Thus, the final file with information ( <b>new_data</b> ) does not contain blocks with zeros, i.e.  "Shrinks", becoming much smaller in size than the original. <br><br>  The possibilities of such data conversion and, accordingly, the format of the file <b>transfer_list</b> over time have undergone some changes.  There are several versions of this file. <br><br>  Initially, the <b>new_data</b> file contained all the info blocks, and the <b>transfer_list</b> entered information necessary only for ‚Äúunclamping‚Äù, i.e.  to restore full source file.  It was version 1, which is used to compress files in the Android OS, starting with version 5.0.0. <br><br>  Then, besides simple compression, the ability to create patch files to replace only certain parts of the source file, such as a patch for recovery, was added to the <b>dat</b> and <b>transfer_list</b> files, so version 2, used in Android OS starting from version 5.1.0, appeared.  This led to even greater compression of the original images, because  In general, only changes are transmitted in the patch. <br><br>  In Android OS 6.0, the approach to the security system has changed a lot, encryption is widely used, respectively, version 3 of the <b>transfer_list</b> file has appeared, allowing you to perform decryption on the fly using <b>stash</b> commands. <br><br><a name="41"></a><h3>  4.1.Structure of dat-files </h3><br>  The image of a RAW-format file (.img) after conversion to dat-files (.dat) is a set of the following files: <br><br><ul><li>  <b>transfer_list</b> file  This file contains the description of the location of the information parts and the command for their restoration and verification; </li><li>  <b>new_data</b> file  It contains only the information parts of the source file that are continuously located in it, i.e.  no gaps or alignments; </li><li>  <b>patch_data</b> file  This file contains only parts that replace the information parts of the source file that are continuously located in it, i.e.  without gaps or alignments. </li></ul><br>  Depending on the type of conversion performed on the source file of the RAW format, the composition of the file set may change, but the <b>transfer_list</b> file must always be present, whereas the <b>new_data</b> file and the <b>patch_data</b> file can be either together or separately. <br><br>  If the conversion consisted in the simple removal of ‚Äúempty‚Äù blocks, then in addition to the <b>transfer_list</b> file, only a <b>new_data</b> file is included in the set, for example, <a href="https://habr.com/ru/post/346536/">[7]</a> . <br><br>  If the conversion involved applying the patch, i.e.  replacing parts of blocks with others, then only a <b>patch_data</b> file will be present in the set, for example, <a href="https://habr.com/ru/post/346536/">[8]</a> . <br><br>  If the conversion consisted of both removing the ‚Äúempty‚Äù blocks, and applying the patch, i.e.  replacing parts of the blocks with others, then the <b>new_data</b> file and the <b>patch_data</b> file will be present in the set, for example, <a href="https://habr.com/ru/post/346536/">[6]</a> . <br><br>  Consider the structure of each of the <b>dat-</b> files in more detail and begin with the <b>transfer_list</b> file, always used, because  namely, it describes the transformations performed on the source file and, accordingly, the actions that must be performed to "get" the source file.  I did not say ‚Äúrecovery‚Äù because  strictly speaking, the source file subjected to conversion may not coincide with the final one obtained after processing.  This can occur, for example, after applying a patch, i.e.  making changes to the source file. <br><br><a name="411"></a><h4>  4.1.1. Structure of the transfer_list file </h4><br>  The file <b>transfer_list</b> is a set of lines of more than 4, each line describes one data field, and has the following structure: <br><br><pre> <code class="xml hljs"> ==================================================== | ‚Ññ | | | | / |   |   | | | | | |=====|=================|============================| | 1 | Version |   | | 2 | Size New Data |    new_dat | | 3 | Stash Entries |   stash- | | 4 | Stash Max Block | . stash- | | 5 | Commands |    | ====================================================</code> </pre><br>  The <b>Version</b> string field describes the version of the <b>transfer_list</b> file and can take values ‚Äã‚Äãfrom 1 to 3. File versions differ in their capabilities, which affects the number of lines in the file itself.  Version 1 is used for files created for Android version not higher than 5.0.  Version 2 is used starting with Android 5.1.0.  Version 3 is used starting with Android 6.0.1. <br><br>  Version 1 does not contain the values ‚Äã‚Äãdescribed in lines 3 and 4, but must contain at least 2 commands.  Therefore, the length of the <b>transfer_list</b> file is at least 4 lines: <br><br><ul><li>  <b>Version</b> ; </li><li>  <b>Size New Data</b> ; </li><li>  <b>Command 1</b> ; </li><li>  <b>Command 2</b> . </li></ul><br>  Versions 2 and 3 can already execute <b>stash</b> commands, so the <b>transfer_list</b> file will contain at least 6 lines: <br><br><ul><li>  <b>Version</b> ; </li><li>  <b>Size New Data</b> ; </li><li>  <b>Stash Entries</b> ; </li><li>  <b>Stash Max Block</b> ; </li><li>  <b>Command 1</b> ; </li><li>  <b>Command 2</b> . </li></ul><br>  The string field <b>Size New Data</b> describes the size in blocks of the output file <b>new_dat</b> , which contains only info-blocks, i.e.  the number of blocks of data being moved.  The default block size is 4096 bytes. <br><br>  The <b>Stash Entries</b> string field describes the number of <b>stash</b> table entries containing a set of offsets to parts of the source file simultaneously used by the <b>stash</b> command. <br><br>  The <b>Stash Max Block</b> string field describes the maximum size of such a <b>stash part of the</b> source file. <br><br>  The <b>Command</b> line field contains the command that must be executed to get the target file. <br><br>  Here is an example <b>transfer_list</b> file version 1: <br><br><pre> <code class="xml hljs">1 140333 erase 2,0,190108 new 236,0,56,57,164,517,523,3717,21738,21739,32767,32768,32770,32825,32826,33285...</code> </pre><br>  where the first line indicates the version of the file (1), the second size of the data being moved, i.e.  the size of the <b>new.dat</b> file in blocks (140333).  The third and fourth lines contain commands ( <b>erase</b> and <b>new</b> ).  These lines are truncated, because  too long. <br><br>  And this is what a <a href="https://habr.com/ru/post/346536/"><b>transfer_list</b></a> version 2 <a href="https://habr.com/ru/post/346536/">file</a> looks like: <br><br><pre> <code class="xml hljs">2 317984 129 24931 move 2,117767,117787 20 2,128537,128557 move 2,113788,117574 3786 2,124558,128344 imgdiff 0 2187 2,117631,117633 2 2,128401,128403 imgdiff 2187 2210 2,117788,117902 114 2,128558,128672 move 2,117903,121984 4081 2,164515,168596 move 2,117609,117630 21 2,128379,128400 imgdiff 4397 2229 2,117575,117602 27 2,128345,128372 imgdiff 6626 16212 2,117636,117759 123 2,128406,128529 imgdiff 22838 2170 2,117760,117766 6 2,128530,128536 imgdiff 25008 2198 2,117603,117608 5 2,128373,128378 move 2,125336,125341 5 2,129329,129334 ... move 2,383166,383179 13 2,392851,392864 move 2,383475,383496 21 2,393160,393181 erase 70,32770,32929,32931,33443,65535,65536,65538,66050,98303,98304,98306,98465,98467,98979,131071,131072,131074,131586,163839,163840,163842...,589826,622592,622594,655360</code> </pre><br>  where in the first line again the version number, in the second the size of the data being moved.  3 and 4 lines are 0, i.e.  <b>stash - the</b> table is not used.  In lines 5 through the last are the commands <b>erase</b> , <b>move</b> and <b>imgdiff</b> .  Some lines are truncated because  too long. <br><br>  Let us consider the structure of the <b>new_data</b> file. <br><br><a name="412"></a><h4>  4.1.2. Structure of a new_data-file </h4><br>  This file contains only info-blocks of the source img-file code taken from it during processing.  They are arranged strictly in order, without spaces, and are used as a data source for the <b>new</b> command. <br><br>  Let's take a look at the structure of a <b>new_data</b> file with a specific example.  The OTA firmware MU A7010-40 [6] incorporates the files <b>system.new.dat</b> and <b>system.transfer.list</b> . <br><br>  In the last file, the <b>new</b> command occurs three times, in lines 1901, 1945, and 1946. Because  the commands are executed strictly sequentially, then the execution of the nerve command <b>new</b> in line 1901 <br><br><pre> <code class="xml hljs">new 2,226365,226468</code> </pre> <br>  will lead to reading from the <b>new_dat</b> file of the first 103 blocks, starting from the current position of the read pointer, i.e.  from 0, and writing to the output file 103 blocks in the range [226365,226468].  In this case, the read pointer of the source will be moved to the address 103. The next command in line 1945 <br><br><pre> <code class="xml hljs">new 2,294901,294902</code> </pre> <br>  will lead to reading from the <b>new_dat</b> file of the next 1 block, starting from the current position of the read pointer, i.e.  with 103, and records in the output file of 1 block in the range [294901,294902].  In this case, the read pointer of the source will be moved to the address 104. Execution of the following command in line 1946 <br><br><pre> <code class="xml hljs">new 2,294902,294903</code> </pre> <br>  will lead to reading from the <b>new_dat</b> file of the next 1 block, starting from the current position of the read pointer, i.e.  with 104, and records in the output file of 1 block in the range [294902,294903].  In this case, the read pointer of the source will be moved to the address 105. <br><br>  Thus, a <b>new_dat</b> file should contain 105 blocks of jann, respectively, its length should be 105 * 4096 = 430080, which is in reality. <br><br>  We now turn to the consideration of the structure of the <b>patch_data</b> file. <br><br><a name="413"></a><h4>  4.1.3. The structure of the patch_data file </h4><br>  All patch data is combined into one <b>patch_data</b> file in the update package.  The data in this file is the source for the bsdiff and imgdiff commands. <br><br><a name="42"></a><h3>  4.2. Description of data structures </h3><br>  All structures describe data ranges, with a block value taken as a data unit, i.e.  4096 bytes.  The following data description structures exist: <br><br><ul><li>  range set <b>[rangeset]</b> </li><li>  slash range set [stash_rangese] </li><li>  input data set &lt;...&gt; </li></ul><br>  Consider their structure in turn. <br><br><a name="421"></a><h4>  4.2.1. The structure of the description of the range of info-blocks (set of ranges [rangeset]) </h4><br>  The range set <b>[rangeset] is</b> used in the <b>transfer_list</b> file commands to describe the ranges of the info blocks of both the source and destination of the data.  Also used in the <b>stash</b> command to describe <b>stash</b> ranges. <br><br>  A simple data range is described by two values: a pointer to the first and last element of the range, for example, [23,56).  In this case, the left border is included in the range, but the right is not.  If there are several ranges, then a description of them requires a set of ranges containing one more element - the number of ranges in the set. <br><br>  Description of the range set, regardless of the version of the <b>transfer_list</b> file, has the following structure: <br><br><pre> <code class="html hljs xml">[count,posStart1,posEnd1,posStart2,posEnd2,...] ,</code> </pre> <br>  Where <br><br><ul><li>  <b>count</b> is the number of offsets in the range set, i.e.  numbers in a row of a set of ranges without the first.  The number of info-block ranges is equal to half of this value, since  each range is described by a pair of values: the beginning and end of the range; </li><li>  <b>posStart1</b> - offset of the beginning of the first range of info-blocks in the final file, in blocks; </li><li>  <b>posEnd1</b> - offset of the last block of the first range of info-blocks in the final file in blocks; </li><li>  <b>posStart2</b> - offset of the beginning of the second range of info-blocks in the final file in blocks; </li><li>  <b>posEnd2</b> - offset of the last block of the second range of info-blocks in the final file in blocks. </li></ul><br>  As you can see, the set contains an enumeration of data ranges, each consisting of an enumeration start boundary and an end boundary.  And the right border is not included in the listing.  The length of the range is calculated as follows: length = end - start. <br><br>  For example, from the above example of <b>transfer_list</b> file, let's see how the range sets in the <b>move</b> command are described: <br><br><pre> <code class="xml hljs">move 2,117767,117787 20 2,128537,128557</code> </pre> <br>  Here are two sets of ranges: <br><br><ul><li>  source range: 2,117767,117787.  It means that the range contains two offsets, i.e.  the line contains two numbers of offsets - 117767 and 117787, describing one data range.  Accordingly, count = 2. Next, the offset of the beginning of the range (posStart = 117767) is located, followed by the offset of the end of the range (posEnd = 117787).  Accordingly, the range contains 117787 - 117767 = 20 elements, i.e.  its length is 20; </li><li>  receiver range: 2,128537,128557.  Similarly, for the target range: count = 2, posStart = 128537, posEnd = 128557, length - 20 elements. </li></ul><br>  The fact that both ranges contain the same number of elements is an attribute of the move operation, i.e.  20 source elements will be moved to 20 receiver elements. <br><br><a name="422"></a><h4>  4.2.2.Stash-band structure (stash_rangeset) </h4><br>  <b>A stash</b> range is a set of info blocks designed to store data elements in a specific place, i.e.  This range has not only a set of elements (from what offset and to what), but also the name or pointer of the repository. <br><br>  A set of info- <b>stash-</b> range blocks has the following structure: <br><br><pre> <code class="html hljs xml"> number:[range_set],</code> </pre> <br>  Where <br><ul><li>  <b>number</b> is the identification number of the <b>stash</b> store, decimal number; </li><li>  <b>[range_set]</b> - a set of data ranges. </li></ul><br>  For example, the command line looks like this: <br><br><pre> <code class="xml hljs">stash 10 2,298306,298307</code> </pre> <br>  means that one (2/2) data range has been created, starting with offset 298306 to offset 298307 (not including it), i.e.  the size of one element (298307-298306 = 1), and marked as stash-storage with an identification number of 10. <br><br>  Another example: <br><br><pre> <code class="xml hljs">stash 11 2,295927,295960</code> </pre> <br>  means that one (2/2) data range has been created, starting with offset 295927 to offset 295960 (not including it), i.e.  33 elements in size (295960-295927 = 33), and marked as stash storage with identification number 11. <br><br>  One more example: <br><br><pre> <code class="xml hljs">stash 8 6,247114,247116,247150,247155,247156,247156</code> </pre> <br>  means that 3 (6/2) data ranges: <br><br>  1) from the offset 247114 to the offset 247116 (not including it), i.e.  the size of 2 elements (247116-247114 = 2); <br><br>  2) starting from offset 247150 to offset 247155 (not including it), i.e.  the size of 5 elements (247155-247150 = 5); <br><br>  3) starting from offset 247156 to offset 247156 (not including it), i.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 elements in size (247156-247156 = 0), merged and marked together as a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stash</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> storage with identification number 8.</font></font><br><br><a name="423"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.2.3. The structure of the input data set &lt;...&gt; </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For version 1, this set looks like this: </font></font><br><br><pre> <code class="xml hljs">[src_rangeset] [tgt_rangeset],</code> </pre> <br>  Where <br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[src rangeset]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - set of ranges of info-blocks of the source file ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new_dat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patch_dat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), i.e. </font><font style="vertical-align: inherit;">data source;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[tgt rangeset]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - set of ranges of info-blocks of the output file (* .img), i.e. </font><font style="vertical-align: inherit;">data receiver.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For version 2 and 3 this set can be of the following types: </font></font><br><br><ol><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[tgt_rangeset] &lt;src_block_count&gt; [src_rangeset]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[tgt_rangeset] &lt;src_block_count&gt; [stash_rangeset]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[tgt_rangeset] &lt;src_range&gt; &lt;src_loc&gt; [stash_rangeset]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li></ol><br>  Where <br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[tgt rangeset]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - set of ranges of info-blocks of the output file (* .img), i.e. </font><font style="vertical-align: inherit;">receiver;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[src rangeset]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - set of ranges of info-blocks of the source file, i.e. </font><font style="vertical-align: inherit;">source;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[stash_rangeset]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - set of ranges of info-blocks of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stash</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -commands;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;src_block_count&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the number of info-blocks in the range of the source and receiver;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;src_range&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the number of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stash</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bands;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;src_loc&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -.</font></font></li></ul><br><a name="43"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.3. Structure and description of transfer_list-file commands </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The transfer_list file uses the following commands: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bsdiff, imgdiff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - apply patch;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erase</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - mark specified areas as empty;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">free</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - clear the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stash area</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Available in version 2;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - fill in the </font><font style="vertical-align: inherit;">specified areas of the output file </font><font style="vertical-align: inherit;">with the information from the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new_data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">move</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - move info-blocks in specified areas;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stash</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - perform moving of specified areas with preliminary processing. </font><font style="vertical-align: inherit;">Available in version 2;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zero</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - fill in the specified areas of the file with zeros.</font></font></li></ul><br><a name="431"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.3.1.Commands ‚Äúerase‚Äù, ‚Äúnew‚Äù, ‚Äúzero‚Äù </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> These commands have the following structure: </font></font><br><br><pre> <code class="xml hljs">name [rangeset],</code> </pre> <br>  Where <br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">name</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the name of the team;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[rangeset]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a structure that describes a set of ranges of info blocks.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erase</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><b><font style="vertical-align: inherit;">marks</font></b><font style="vertical-align: inherit;"> the empty blocks described by the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[rangeset]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For example, the execution of the command</font></font><br><br><pre> <code class="xml hljs">erase 70,32770,32929,32931,33443,...</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from [7, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transfer_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file, line 2337] will result in clearing 35 sets of blocks of the output file with the numbers [32770,32929], [32931,33443], etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">records the source info-blocks, i.e. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The new_dat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file, in the range set, described by the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[rangeset]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure of the </font><font style="vertical-align: inherit;">receiver, i.e. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">system.img</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">Info blocks from the source are selected strictly sequentially. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, in [7, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transfer_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file] command execution in line 1901</font></font><br><br><pre> <code class="xml hljs">new 2,226365,226468</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will lead to reading from the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new_dat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file, starting from the current position of the pointer 103 blocks and writing to the output file in the range [226365,226468]. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zero</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">clears the specified set of output file ranges, i.e. </font><font style="vertical-align: inherit;">fills it with zeros. </font><font style="vertical-align: inherit;">For example, the execution of the command</font></font><br><br><pre> <code class="xml hljs">zero 2,226365,226366</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will cause the receiver unit 226365 to be cleared. </font></font><br><br><a name="432"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.3.2. The "move" command </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This command simply copies the info blocks from the source file described by the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[src_rangeset]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><font style="vertical-align: inherit;">into the existing set of output file ranges described by the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[tgt_rangeset]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">move</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">has the following structure:</font></font><br><br><pre> <code class="xml hljs">move <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">...</span></span></span><span class="hljs-tag">&gt;</span></span>,</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;...&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a set of input data that differs depending on the version of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transfet_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, if a command has the following form:</font></font><br><br><pre> <code class="xml hljs">move 2,117767,117787 20 2,128537,128557</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and this is the command for moving info-blocks ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">move</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), then two sets of ranges are described here:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source range</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 2,117767,117787. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indicates that the range contains two offsets (count = 2), describing one range of data. </font><font style="vertical-align: inherit;">Next is the offset of the beginning of the range (posStart = 117767) and next is the offset of the end of the range (posEnd = 117787);</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">receiver range</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 2,128537,128557. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Similarly for the receiver: count = 2, posStart = 128537, posEnd = 128557.</font></font></li></ul><br><a name="433"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.3.3. The "bsdiff" and "imgdiff" commands </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These commands read the info blocks of the source file, perform updates, and change the info blocks written to the output file. </font><font style="vertical-align: inherit;">Commands differ only in the type of transformations applied to the info blocks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both teams have the following structure:</font></font><br><br><pre> <code class="xml hljs">name <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">patchstart</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">patchlen</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">...</span></span></span><span class="hljs-tag">&gt;</span></span>,</code> </pre> <br>  Where <br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">name</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the name of the team;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patchstart</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - offset of the beginning of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patch area</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in blocks;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patchlen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the length of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patch area</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in blocks;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;...&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a set of input data.</font></font></li></ul><br><a name="434"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.3.4. The "stash" command </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This command saves info-blocks in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stash-area</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It has the following structure:</font></font><br><br><pre> <code class="xml hljs">stash <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">stash_id</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">src_range</span></span></span><span class="hljs-tag">&gt;</span></span>,</code> </pre> <br>  Where <br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;stash_id&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the identifier of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stash</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> range;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;src_range&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a set of ranges of info-blocks of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stash area</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ul><br><a name="435"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.3.5. Team "free" </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This command clears the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stash area</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It has the following structure:</font></font><br><br><pre> <code class="xml hljs">free <span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span>,</code> </pre> <br>  Where <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;...&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - is a set of input data.</font></font><br><br>  To be continued‚Ä¶ <br><br><a name="5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Conclusion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All the above material and examples of its use is only a ‚Äúmultiplication table‚Äù, and not a guide to action. Nobody, of course, manually applies patches and does not convert </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">system</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> files ... I just described the principles for performing transformations on "sparse" files, the categories of which mainly include files containing filesystem files. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For processing ‚Äúsparse‚Äù files, of course, computer programs are used, which are already a large number. If hands reach, I will write a review of existing conversion tools. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting to write a publication, I wanted to bring to the users only the basics, so to speak, exclusively ‚Äútheory‚Äù.</font></font> Since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">most of the work on the ‚Äúdigging‚Äù in the source texts and firmware was done by me in 2013-2014, then in the process of work I had to work a lot: to remember something, to rethink something, and to thoroughly supplement it with the advent of new versions of android. </font><font style="vertical-align: inherit;">In the next part, I will describe examples of processing ‚Äúsparse‚Äù files. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There was a lot of material, of course, the article needed to be immediately divided into two or three parts for ease of assimilation and preparation. </font><font style="vertical-align: inherit;">But as it happened, it happened. </font><font style="vertical-align: inherit;">This is me about the fact that you do not judge strictly, I also may not know something at all, but do not take into account something ... If you have questions or suggestions, you are welcome.</font></font><br><br><a name="6"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Sources of information </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. </font></font><a href="https://ru.wikipedia.org/wiki/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sparse_file. </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. </font></font><a href="https://firmwarefile.com/lenovo-s90-a"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lenovo s90A device firmware</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3. </font></font><a href="https://github.com/aosp-mirror/platform_system_core/tree/master/libsparse"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sparse_format.h</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. </font></font><a href="https://www.android-hilfe.de/forum/motorola-moto-z.2836/firmware-moto-z-xt1650-%250A03.806214.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lenovo Moto Z</font></font></a> <br>  five. <a name="65"></a> <a href="https://forum.gsmhosting.com/vbb/f783/moto-xt1085-stock-firmware-new-direct-download-2077026/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Victara_Retail_China_XT1085_5.1_LPE23.32-53_CFC.xml.zip - Lenovo Moto X.</font></font></a> <br>  6 <a name="66"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A7010a40_S111_150825_ROW_TO_A7010a40_S112_150901_ROW_WC15.zip. </font></font><br>  7 <a name="67"></a><br>  eight. <a name="68"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OTA update recovery. </font></font></div><p>Source: <a href="https://habr.com/ru/post/346536/">https://habr.com/ru/post/346536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346524/index.html">Meltdown and Specter for the cloud: our risk assessment and how we patched</a></li>
<li><a href="../346526/index.html">One is not a warrior in the field: advantages from working in a company on a remote</a></li>
<li><a href="../346530/index.html">Linux and newspaper layout (not for professionals)</a></li>
<li><a href="../346532/index.html">Basics of lossy audio coding. Testing Opus 1.3 Beta</a></li>
<li><a href="../346534/index.html">10 years have passed, and no one has figured out how to use the blockchain</a></li>
<li><a href="../346538/index.html">Animation in mobile applications. We test Kite compositor</a></li>
<li><a href="../346540/index.html">On the problems of determining the location of the subscriber when he calls 112</a></li>
<li><a href="../346542/index.html">The decentralized data warehouse Ethereum Swarm</a></li>
<li><a href="../346544/index.html">Detection of known malicious code in TLS-encrypted traffic (without decryption)</a></li>
<li><a href="../346546/index.html">‚ÄúNon-existent‚Äù cryptomachine of ‚Äúnon-existent‚Äù agency: NSA (No Such Agency) and KL-7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>