<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rounded Images on Qt Quick Scene Graph</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have been using Qt in development for over 6 years, of which the last 3 years have been building applications for Android and iOS on Qt Quick. My co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rounded Images on Qt Quick Scene Graph</h1><div class="post__text post__text-html js-mediator-article"><p>  I have been using Qt in development for over 6 years, of which the last 3 years have been building applications for Android and iOS on Qt Quick.  My commitment to this framework is due to two reasons: </p><br><ul><li>  Qt provides a large package of components, functions, classes, etc., which is enough to develop most applications; </li><li>  If you need to create the missing component, Qt provides several levels of abstraction for this - from simple to coding, to the most productive and functional. </li></ul><br><p>  For example, in Qt Quick, there is an <a href="http://doc.qt.io/qt-5/qml-qtquick-image.html">Image</a> component that places an image in an interface.  The component has many parameters: location, scaling method, anti-aliasing, etc., but there is no radius parameter for rounding the image at the corners.  At the same time, round images can now be found in almost any modern interface and because of this there was a need to write your Image.  With support for all parameters Image and radius.  In this article I will describe several ways to make rounded images. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/files/3b3/866/f3f/3b3866f3f4e341f791b712566b5a71df.jpeg"></div><a name="habracut"></a><p></p><br><h2 id="pervaya-realizaciya-ona-zhe-naivnaya">  The first implementation is naive. </h2><br><p>  Qt Quick has a library for working with graphic effects <a href="http://doc.qt.io/qt-5/qtgraphicaleffects-index.html">QtGraphicalEffects</a> .  In essence, each component is a wrapper over shaders and OpenGL.  So I suggested that this should work quickly and did something like this: </p><br><pre><code class="hljs mel">import QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> import QtGraphicalEffects <span class="hljs-number"><span class="hljs-number">1.0</span></span> Item { property <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">source</span></span>: imageOriginal.<span class="hljs-keyword"><span class="hljs-keyword">source</span></span> property <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> radius: mask.radius Image { id: imageOriginal anchors.fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> visible: false } Rectangle { id: rectangleMask anchors.fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> radius: <span class="hljs-number"><span class="hljs-number">0.5</span></span>*height visible: false } OpacityMask { id: opacityMask anchors.fill: imageOriginal <span class="hljs-keyword"><span class="hljs-keyword">source</span></span>: imageOriginal maskSource: rectangleMask } }</code> </pre> <br><p>  Let's look at how this works: <code>opacityMask</code> superimposes the <code>rectangleMask</code> mask on the <code>imageOriginal</code> image and displays what happened.  Please note that the original image and the rectangle are invisible <code>visible: false</code> .  This is necessary to avoid overlap, because  <code>opacityMask</code> is a separate component and does not directly affect the display of other elements of the scene. </p><br><p>  This is the simplest and slowest implementation possible.  Display lags will be immediately visible if you create a long list of images and scroll through it (for example, the list of contacts as in Telegram).  Even greater discomfort will deliver the image resizing brakes.  The problem is that all components of the <code>QtGraphicalEffects</code> library heavily load the graphics subsystem, even if the original image and the size of the element do not change.  The problem can be slightly reduced by using the <a href="http://doc.qt.io/qt-5/qml-qtquick-item.html">grubToImage (...)</a> function to create a static round image, but it‚Äôs better to use another implementation of the image rounding. </p><br><h2 id="vtoraya-realizaciya-canvas">  Second implementation, Canvas </h2><br><p>  The next method that came to mind was to draw the corners over the image with the background color using <a href="http://doc.qt.io/qt-5/qml-qtquick-canvas.html">Canvas</a> .  In this case, with the same size and radius of the image, the Canvas can not be redrawn, but copied for each new element.  Due to this optimization, the advantage in rendering speed is achieved in comparison with the first implementation. </p><br><p>  This approach has two minuses.  Firstly, any change in size and radius requires a redrawing of the Canvas, which in some cases will reduce performance even lower than in the solution with OpacityMask.  And second, the background under the image must be uniform, otherwise our illusion will be revealed. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtGraphicalEffects <span class="hljs-number"><span class="hljs-number">1.0</span></span> Item { property alias source: imageOriginal.source property real radius: <span class="hljs-number"><span class="hljs-number">20</span></span> property color backgroundColor: <span class="hljs-string"><span class="hljs-string">"white"</span></span> Image { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: imageOriginal anchors.fill: parent visible: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } Canvas { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: roundedCorners anchors.fill: parent onPaint: { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ctx = getContext(<span class="hljs-string"><span class="hljs-string">"2d"</span></span>); ctx.reset(); ctx.fillStyle = backgroundColor; ctx.beginPath(); ctx.moveTo(<span class="hljs-number"><span class="hljs-number">0</span></span>, radius) ctx.lineTo(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); ctx.lineTo(radius, <span class="hljs-number"><span class="hljs-number">0</span></span>); ctx.arc(radius, radius, radius, <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(width, radius) ctx.lineTo(width, <span class="hljs-number"><span class="hljs-number">0</span></span>); ctx.lineTo(width-radius, <span class="hljs-number"><span class="hljs-number">0</span></span>); ctx.arc(width-radius, radius, radius, <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(<span class="hljs-number"><span class="hljs-number">0</span></span>, height-radius) ctx.lineTo(<span class="hljs-number"><span class="hljs-number">0</span></span>, height); ctx.lineTo(radius, height); ctx.arc(radius, height-radius, radius, <span class="hljs-number"><span class="hljs-number">0.5</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(width-radius, height) ctx.lineTo(width, height); ctx.lineTo(width, height-radius); ctx.arc(width-radius, height-radius, radius, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); ctx.closePath(); ctx.fill(); } } }</code> </pre> <br><h2 id="tretya-realizaciya-qpainter">  Third implementation, QPainter </h2><br><p>  To increase performance and get rid of the dependence on a uniform background, I created a QML component based on the C ++ class <a href="http://doc.qt.io/qt-5/qquickpainteditem.html">QQuickPaintedItem</a> .  This class provides a component drawing mechanism through <a href="http://doc.qt.io/qt-5/qpainter.html">QPainter</a> .  To do this, override the <code>void paint(QPainter *painter)</code> method of the parent class.  From the name it is clear that the method is called to draw the component. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ImageRounded::paint(QPainter *painter) { QPen pen; pen.setStyle(Qt::NoPen); painter-&gt;setPen(pen); QImage *image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QImage(<span class="hljs-string"><span class="hljs-string">"image.png"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      QBrush brush(image); //   qreal wi = static_cast&lt;qreal&gt;(image.width()); qreal hi = static_cast&lt;qreal&gt;(image.height()); qreal sw = wi / width(); qreal sh = hi / height(); brush.setTransform(QTransform().scale(1/sw, 1/sh)); painter-&gt;setBrush(brush); //      qreal radius = 10 painter-&gt;drawRoundedRect(QRectF(0, 0, width(), height()), radius, radius); }</span></span></code> </pre> <br><p>  In the example above, the original image is stretched to the size of the element and is used as a pattern when drawing a rectangle with rounded edges.  To simplify the code, hereinafter, image scaling options are not considered: <code>PreserveAspectFit</code> and <code>PreserveAspectFit</code> , but only <code>Stretch</code> . <br>  By default, <code>QPainter</code> draws on the image, and then copies it into the OpenGL buffer.  If you draw directly in <a href="https://ru.wikipedia.org/wiki/Framebuffer_Object">FBO</a> , then component rendering will be accelerated several times.  To do this, call the following two functions in the class constructor: </p><br><pre> <code class="cpp hljs">setRenderTarget(QQuickPaintedItem::FramebufferObject); setPerformanceHint(QQuickPaintedItem::FastFBOResizing, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><h2 id="finalnaya-realizaciya-qt-quick-scene-graph">  Final implementation, Qt Quick Scene Graph </h2><br><p>  The implementation on <code>QQuickPaintedItem</code> works much faster than the first and second.  But even in this case, on smartphones, there is a noticeable delay in rendering when the image is resized.  The fact is that any function of the scaling image is made at the processor's capacity and takes at least 150 ms (measured on i7 and on HTC One M8).  You can take out the scaling in a separate stream and draw the picture by readiness - this will improve responsiveness (the application will always respond to user actions), but it will not solve the problem in essence - you will see the image twitching when scaling. </p><br><p>  Once the bottleneck is the processor, it comes to mind to use the power of the video accelerator.  Qt Quick provides the <a href="http://doc.qt.io/qt-5/qquickitem.html">QQuickItem</a> class for this.  When inheriting from it, you must override the <code>updatePaintNode</code> method.  The method is called every time the component needs to be drawn. </p><br><div class="spoiler">  <b class="spoiler_title">updatePaintNode (...)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">QSGNode* ImageRounded::updatePaintNode(QSGNode *oldNode, QQuickItem::UpdatePaintNodeData *) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_status != Ready) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } QSGGeometryNode *node; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!oldNode) { node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QSGGeometryNode(); <span class="hljs-comment"><span class="hljs-comment">//     QSGGeometry *geometry = new QSGGeometry(QSGGeometry::defaultAttributes_TexturedPoint2D(), _segmentCount); geometry-&gt;setDrawingMode(QSGGeometry::DrawTriangleFan); setGeometry(geometry); node-&gt;setFlag(QSGNode::OwnsGeometry); node-&gt;setFlag(QSGNode::OwnsOpaqueMaterial); //     auto image = new QImage("image.png"); auto texture = qApp-&gt;view()-&gt;createTextureFromImage(image); auto material = new QSGOpaqueTextureMaterial; material-&gt;setTexture(texture); material-&gt;setFiltering(QSGTexture::Linear); material-&gt;setMipmapFiltering(QSGTexture::Linear); setMaterial(material); node-&gt;markDirty(QSGNode::DirtyGeometry | QSGNode::DirtyMaterial); } else { node = oldNode; node-&gt;markDirty(QSGNode::DirtyGeometry); } //       QSGGeometry::TexturedPoint2D *vertices = node-&gt;geometry()-&gt;vertexDataAsTexturedPoint2D(); const int count = 20; //      const int segmentCount = 4*count + 3; //    Coefficients cf = {0, 0, width(), height() ,0, 0, 1/width(), 1/height()}; const float ox = 0.5f*cf.w + cf.x; const float oy = 0.5f*cf.h + cf.y; const float lx = 0.5f*cf.w + cf.x; const float ly = cf.y; const float ax = 0 + cf.x; const float ay = 0 + cf.y; const float bx = 0 + cf.x; const float by = cf.h + cf.y; const float cx = cf.w + cf.x; const float cy = cf.h + cf.y; const float dx = cf.w + cf.x; const float dy = 0 + cf.y; const float r = 2*_radius &lt;= cf.w &amp;&amp; 2*_radius &lt;= cf.h ? _radius : 2*_radius &lt;= cf.w ? 0.5f*cf.w : 0.5f*cf.h; vertices[0].set(ox, oy, ox*cf.tw+cf.tx, oy*cf.th+cf.ty); vertices[1].set(lx, ly, lx*cf.tw+cf.tx, ly*cf.th+cf.ty); //    int start = 2; for (int i=0; i &lt; count; ++i) { double angle = M_PI_2 * static_cast&lt;double&gt;(i) / static_cast&lt;double&gt;(count-1); float x = ax + r*(1 - qFastSin(angle)); float y = ay + r*(1 - qFastCos(angle)); vertices[start+i].set (x, y, x*cf.tw+cf.tx, y*cf.th+cf.ty); } //    start += count; for (int i=0; i &lt; count; ++i) { double angle = M_PI_2 * static_cast&lt;double&gt;(i) / static_cast&lt;double&gt;(count-1); float x = bx + r*(1 - qFastCos(angle)); float y = by + r*(-1 + qFastSin(angle)); vertices[start+i].set (x, y, x*cf.tw+cf.tx, y*cf.th+cf.ty); } //    start += count; for (int i=0; i &lt; count; ++i) { double angle = M_PI_2 * static_cast&lt;double&gt;(i) / static_cast&lt;double&gt;(count-1); float x = cx + r*(-1 + qFastSin(angle)); float y = cy + r*(-1 + qFastCos(angle)); vertices[start+i].set (x, y, x*cf.tw+cf.tx, y*cf.th+cf.ty); } //    start += count; for (int i=0; i &lt; count; ++i) { double angle = M_PI_2 * static_cast&lt;double&gt;(i) / static_cast&lt;double&gt;(count-1); float x = dx + r*(-1 + qFastCos(angle)); float y = dy + r*(1 - qFastSin(angle)); vertices[start+i].set (x, y, x*cf.tw+cf.tx, y*cf.th+cf.ty); } vertices[segmentCount-1].set(lx, ly, lx*cf.tw+cf.tx, ly*cf.th+cf.ty); return node; }</span></span></code> </pre> </div></div><br><p>  In the example under the spoiler, we first create an object of the <a href="http://doc.qt.io/qt-5/qsggeometrynode.html">QSGGeometryNode</a> class - we return this object to the Qt Quick Scene Graph engine for rendering.  Then we specify the geometry of the object - a rectangle with rounded corners, create a texture from the original image and transfer the texture coordinates (they indicate how the texture is stretched onto the geometry).  Note: the geometry in the example is given by the <a href="https://en.wikipedia.org/wiki/Triangle_fan">triangle fan</a> method.  Here is an example of the component: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-bg5Z8QSW08" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In this article, I tried to collect various methods of drawing a rounded image in Qt Quick: from the simplest to the most productive.  I deliberately missed the methods of loading images and specifics in creating QML components, because the topic of a separate article with its pitfalls.  However, you can always see the source code of our library, which my friend and I use to create mobile applications: <a href="https://github.com/SiberianProgrammers/sp_qt_libs">here</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/320212/">https://habr.com/ru/post/320212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320200/index.html">Pygest # 1. Releases, articles, interesting projects from the world of Python [January 01, 2017 - January 15, 2017]</a></li>
<li><a href="../320202/index.html">Wikimart and the ‚Äútheory of the big fool‚Äù in e-commerce</a></li>
<li><a href="../320204/index.html">GearVR tracking system or electronics production in Russia</a></li>
<li><a href="../320206/index.html">On the fabulous Bali snow fell or how easy it is to deceive the GPS</a></li>
<li><a href="../320210/index.html">Exam for future "Russian hackers" at the Moscow Polytech</a></li>
<li><a href="../320214/index.html">Big data protection - how to start and minimize possible risks?</a></li>
<li><a href="../320218/index.html">How a former command post becomes a data center</a></li>
<li><a href="../320220/index.html">Sparrow plug-ins and Ansible modules - comparative analysis</a></li>
<li><a href="../320222/index.html">How IT professionals work. Ilya Titov, Managing Director for IT at Modbank</a></li>
<li><a href="../320224/index.html">IAP in Unity3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>