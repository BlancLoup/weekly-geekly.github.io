<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to Renesas microcontrollers using the RL78 line as an example</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If the average Russian-speaking developer of microcontroller electronics is asked to name 3-5 best known or major manufacturers of microcontrollers, i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to Renesas microcontrollers using the RL78 line as an example</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/81f/975/dcb/81f975dcb522c2a34b2a65c631deae71.jpg"><br><p></p><br><p>  If the average Russian-speaking developer of microcontroller electronics is asked to name 3-5 best known or major manufacturers of microcontrollers, it is most likely to hear in response such names as Microchip, Atmel, TI, or STM.  Someone will also call NXP, Freescale, Samsung or Fujitsu.  But few people will remember another producer who is almost unknown in the post-Soviet space. </p><br><p></p><br><p>  We are talking about the Japanese company Renesas Electronics, which, meanwhile, in its annual reports boasts such an interesting infographic ... </p><br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/c63/d32/f49/c63d32f49bff35e53ad2f6e9c9765807.png"><br><p>  <i>General application microcontrollers: microcontrollers for various applications, excluding automotive electronics</i> </p><br><p></p><br><p>  Thus, the "dark horse", the products of which will be discussed below, is the leader of the global market for both general-purpose microcontrollers and the automotive electronics market, and has every right to call itself "the world's No. 1 microcontroller supplier."  The secret of this company's success is simple: Renesas Technology appeared in 2003 as a joint venture between Hitachi and Mitsubishi, and in 2010 they were also joined by Nec Electronics, forming a joint venture of Renesas Electronics. </p><br><p></p><br><p>  The result of this cooperation is the possibility of using the well-established cores of the three companies together with effective specialized peripherals: </p><br><ul><li>  From Hitachi, H8, H8S, H8SX and SuperH cores were used. </li><li>  From Mitsubishi, M16 / M32, R32, 720 and 740 cores fell into the hands of developers. </li><li>  From NEC - the V850 and 78K line of cores. </li></ul><br><p>  Having received such a number of developments, Renesas began to develop new lines using technologies available to participating companies.  To replace the Hitachi H8SX and Mitsubishi R32C came a line of 32-bit RX microcontrollers.  As a successor to the popular NEC V850, the RH850 was developed - a line of microprocessors for use in automotive electronics.  The R8C core was also developed as a solution of the lower price range, compatible with the Mitsubishi M16C. </p><br><p></p><br><p>  The first independent development of Renesas after unification with NEC was the new 16-bit RL78 core with CISC architecture.  In it, the developers tried to combine the positive sides of the R8C and 78K0 in the same family.  At the moment, the family can be divided into 5 "branches" for various applications: </p><br><ol><li>  RL78 / G1x - general purpose microcontrollers: up to 28 channels ADC, DAC, USB, I2C, SPI, PWM, RTCC. </li><li>  RL78 / L1x - LCD control microcontrollers: support USB 2.0, control LCD indicators up to 4x53 / 8x48 segments. </li><li>  RL78 / F1x - microcontrollers for the automotive industry: CAN interface support, engine management, extended temperature range up to +150 ¬∫C. </li><li>  RL78 / D1x - microcontrollers for instrument making: 4-channel stepper motor controller out-of-the-box, LCD control of up to 4x53 segments, CAN. </li><li>  RL78 / I1x - microcontrollers for lighting control: DALI / DMX512, PWM. </li></ol><br><p>  The range of RL78 microcontrollers is simply huge, it is easy to find a model that is suitable for a specific use.  Controllers of all families boast the presence of DMA lines, ADC / DAC converters, support for I2C and SPI interfaces, as well as support for operation in an industrial LIN network. </p><br><p></p><br><p>  The CIS pipeline of the RL78 core consists of 3 stages, about 86% of instructions can be executed in 1‚Äì2 processor cycles.  It also supports hardware execution of MAC commands 16x16 bits. </p><br><p></p><br><p>  As the main advantage of the microcontroller RL78, the manufacturer claims minimal power consumption, calling the line no less than true low power (really low power consumption).  Despite this, we can note the preservation of high performance and a wide range of operating voltages. </p><br><p></p><br><p>  For clarity, we will summarize in the general table the key characteristics of this controller and the main competitors from the ‚Äúpopular‚Äù brands: </p><br><p></p><br><p>  <i>Comparison of characteristics of popular microcontrollers</i> </p><br><table border="1" cellspacing="5"><tbody><tr><td><p></p><br></td><td><p>  <b>STM8L</b> </p><br></td><td><p>  <b>STM32L</b> </p><br></td><td><p>  <b>PIC24 Lite</b> </p><br></td><td><p>  <b>MSP430</b> </p><br></td><td><p>  <b>RL78</b> </p><br></td></tr><tr><td><p>  Digit </p><br></td><td><p>  8 bit </p><br></td><td><p>  32 bits </p><br></td><td><p>  16 bits </p><br></td><td><p>  16 bits </p><br></td><td><p>  16 bits </p><br></td></tr><tr><td><p>  Performance </p><br></td><td><p>  ~ 1 <abbr title="MIPS (English Million Instructions Per Second) - one million instructions per second">DMIPS</abbr> / MHz, 16 MHz max </p><br></td><td><p>  ~ 1.04 DMIPS / MHz, 32 MHz max </p><br></td><td><p>  ~ 0.5 MIPS / MHz, 32 MHz max </p><br></td><td><p>  ~ 1 DMIPS / MHz, 25 MHz max </p><br></td><td><p>  ~ 1.3 DMIPS / MHz, 32 MHz max </p><br></td></tr><tr><td><p>  Flash </p><br></td><td><p>  2-64 KB </p><br></td><td><p>  32-384 KB </p><br></td><td><p>  16-32 KB </p><br></td><td><p>  0.5-512 KB </p><br></td><td><p>  0.125-512 KB </p><br></td></tr><tr><td><p>  Ram </p><br></td><td><p>  1-4 KB </p><br></td><td><p>  4-48 KB </p><br></td><td><p>  1-2 KB </p><br></td><td><p>  0.125-66 KB </p><br></td><td><p>  1-32 KB </p><br></td></tr><tr><td><p>  Slave consumption </p><br></td><td><p>  150-180 ŒºA / MHz </p><br></td><td><p>  214-230 ŒºA / MHz </p><br></td><td><p>  195-350 ŒºA / MHz </p><br></td><td><p>  80-280 ŒºA / MHz </p><br></td><td><p>  46-156.25 ŒºA / MHz </p><br></td></tr><tr><td><p>  Sleep consumption + rtc </p><br></td><td><p>  1,3 ŒºA </p><br></td><td><p>  0.9 ŒºA </p><br></td><td><p>  0.5-0.7 ŒºA </p><br></td><td><p>  0.7 ŒºA </p><br></td><td><p>  0.56-0.68 ŒºA </p><br></td></tr><tr><td><p>  Power range </p><br></td><td><p>  1.65-3.6 V </p><br></td><td><p>  1.65-3.6 V </p><br></td><td><p>  1.8-3.6 / 2.0-5.5 V </p><br></td><td><p>  1.65-3.6 B </p><br></td><td><p>  1.6-5.5 V </p><br></td></tr><tr><td><p>  Approximate price range </p><br></td><td><p>  0.5-4.5 $ </p><br></td><td><p>  1,5-7,7 $ </p><br></td><td><p>  0,8-4,2 $ </p><br></td><td><p>  0,34-9,5 $ </p><br></td><td><p>  $ 0.68-8 </p><br></td></tr></tbody></table><br><p>  The periphery is deliberately not mentioned in this table, but even here the advantage is definitely not in favor of the competitors - traditionally everything is very good with the periphery of Renesas. </p><br><p></p><br><p>  As for the useful features of some representatives of the line, the following can be noted: </p><br><ul><li>  Data transfer control - the ability to transfer data between peripheral modules without a processor. </li><li>  Event link controller - exchange interrupts between peripheral modules without the participation of the processor. </li><li>  Flash memory with ECC. </li><li>  LVD - low voltage detection. </li><li>  Ability to issue up to 20 mA per GPIO pin, 5V-tolerant pins. </li></ul><br><p>  It all sounds good and beautiful, but are Renesas microcontrollers comfortable when developing?  To check this, let's take the Renesas YRPBRL78G13 debug board and try to evaluate the entry threshold for using Renesas RL78 series microcontrollers. </p><br><p></p><br><p>  The ‚Äúon board‚Äù board is equipped with the R5F100LEAFB microcontroller, which belongs to the RL78 / G13 family: 64 KB of flash-memory, 4 KB of RAM, and 4 KB of flash-memory with an increased number of overwrites for storing data are also allocated.  The built-in ADC on 12 channels provides resolution up to 10 bits, and DMA on 2 channels will help to store the received data in memory.  Fourteen timers channels, seven PWM channels, three UARTs and seven I2Cs are quite good for a ‚Äúkid‚Äù in the LFQFP64 package for $ 1.64 (albeit in batches of 1000 pieces). </p><br><p></p><br><p>  This board is attributed by Renesas to the demo section (promotion boards), so its retail price is $ 25.  In fairness, this is not the most interesting offer of the company, the debug board YRPBRL78L12 on RL78 / L12 is currently offered for only $ 10.  For those who wish, there is also a large number of large, ‚Äúadult‚Äù debugs. </p><br><p></p><br><img src="https://habrastorage.org/getpro/habr/post_images/ae7/33d/cac/ae733dcac258fe5aeeac34e2da3ab84a.jpg"><br><p>  <i>Debug board Renesas YRPBRL78G13</i> </p><br><p></p><br><p>  The board is made in a compact form factor of 100x30 mm and, in addition to the controller itself, the RL78 / G13 contains a hardware debugger that allows not only to flash the board via USB, but also to perform in-circuit debugging in real time.  The board provides power from both the USB bus and from an external power source. </p><br><p></p><br><img src="https://habrastorage.org/getpro/habr/post_images/bcc/34a/a45/bcc34aa45c7278d220294ded4bf2ea24.png"><br><p>  <i>Renesas YRPBRL78G13 Debug Card</i> </p><br><p></p><br><p>  The external power supply (+ 5V) can be directly connected to the board using the J4 connector, while the adjacent pads must be re-connected.  Using jumpers J6 ‚Äì J9, you can choose to decide the USB port, OCD (On Chip Debug) or Virtual UART (a COM port emulator via USB using the optional 8-bit ŒºPD78F0730 controller of the previously mentioned 78K0 family).  Virtual UART, however, is not always convenient to use because of the need to constantly rearrange jumpers when debugging.  If necessary, you can use the external debugger Renesas E1, connected via the connector J5. </p><br><p></p><br><p>  On the long lines J1 and J2 almost all pins of the microcontroller are derived.  Connector J10 is used to flash an auxiliary controller 78K0 in production.  To control the power consumption of the microcontroller, power is supplied to it via jumper J3. </p><br><p></p><br><p>  There are also two LEDs on the board (power indicator and user LED) and a potentiometer connected to a 10-bit ADC microcontroller.  Interestingly, a small screwdriver comes with the board for adjusting the potentiometer. </p><br><p></p><br><p>  So, with the hardware, everything is clear, now let's see what Renesas offers to software developers. </p><br><p></p><br><p>  Development begins with documentation, and here Renesas can be called an example to follow: the specification can be found in free access without any problems, and most often there are no problems with their relevance and completeness - the volume of documentation can even frighten the uninitiated person.  The manufacturer traditionally pays special attention to the description of the periphery and application notes (application notes).  Due to the prevalence, Renesas also has its online community with the modest name Renesas Rulz. </p><br><p></p><br><p>  RL78 c language.  As a development environment, the beloved IAR Embedded Workbench with support for RL78 (version EWRL78) is offered by many, traditionally there is its free version KickStart edition with a code size limit of 16 KB.  The C-SPY debugger built into IAR is fully supported: you can set breakpoints and freely walk through the code with a view of registers / variables.  It is also possible to use e¬≤ studio (eclipse embedded studio) with the GDB debugger, as well as many other utilities as the development environment. </p><br><p></p><br><p>  The firmware code can be written both for bare metal and using RTOS: the manufacturer suggests using FreeRTOS, CMX-RTX, Micrium ŒºC / OS, OSEK Run Time Interface (ORTI), Express Logic or Segger embOS implementations.  For home automation lovers, there is a KNX stack implementation. </p><br><p></p><br><p>  To fill the firmware in the controller, there are many applications, such as the free utility WriteEZ5.  This utility is universal: to support a certain model of the microcontroller, simply download the appropriate configuration file in pr5 format and point the program at it before flashing. </p><br><p></p><br><p>  The most interesting approach from the point of view of developing software code Renesas demonstrates with its graphical utility Applilet.  This utility allows you to configure all the peripherals, gpio, interrupt subsystem and ADC / DAC modes used by the microcontroller in a convenient human-readable form, and then, based on this configuration, generate initialization code and stubs for all event handlers.  The generated code can then be used as the basis of the project and, subject to the rules for organizing the code (see below), at any time have the opportunity to change the configuration of the finished project. </p><br><p></p><br><p>  Such an approach will allow concentrating on the application logic, initialization of the periphery and the API for its management, the code generated by the utility will take over.  There is no need to deal with monstrous libraries of work with peripherals, as is often the case with other vendors, and the generated code is guaranteed to contain a minimum of redundancy. </p><br><p></p><br><p>  Thus, the entry threshold for the RL78 is significantly reduced, even a developer without microcontroller programming experience will be able to write simple firmware in minimal time. </p><br><p></p><br><p> As an example, we will show how to write a traditional Hello world from the world of microcontrollers - we blink a LED.  And so that it is not so boring, we will blink for a reason, and using pulse-width modulation and timers to smoothly turn on and off the LED.  In total, we will need 3 timers - 2 of them will be used for PIM, and for the third we will smoothly change the pulse duty cycle, which in our case will lead to a change in brightness. </p><br><p></p><br><p>  Let's open the Applilet utility from Renesas and create a new project for the R5F100LEAFB controller: </p><br><p></p><br><img src="https://habrastorage.org/getpro/habr/post_images/161/f50/440/161f5044058d61d3fd77aad145e043a9.png"><br><p>  <i>New project in the Applilet3 for RL78 / G13 utility window</i> </p><br><p></p><br><p>  This is how the Applilet utility window of the currently currently running version 3 looks like, opened on the tab of the zero channel timer settings.  When using the appropriate mode of operation, channel 0 is reserved for the timer, which defines the PIMA period, so it does not abound in settings.  When the INTTM00 interrupt is enabled, exactly like any other interrupt from the periphery, the ‚Äústub‚Äù code of the interrupt will be automatically added (and initialized) to the code generated by the utility. </p><br><p></p><br><p>  Channel 1 directly specifies the active part of the period, so on the tab of its configuration, you can set the width of the active level (as a percentage of the period of channel 0) and the level settings: </p><br><p></p><br><img src="https://habrastorage.org/getpro/habr/post_images/be3/cdf/e14/be3cdfe14db333f3095195882c367805.png"><br><p>  <i>Channel 1 settings in Applilet3 for RL78 / G13 utility window</i> </p><br><p></p><br><p>  We also need the so-called interval timer, which will generate an interrupt every 0.2 seconds.  Its configuration is also reduced to a pair of ticks in the Applilet utility interface. </p><br><p></p><br><img src="https://habrastorage.org/getpro/habr/post_images/72d/5f0/b38/72d5f0b3878c3c39d0ebbc5378fa7cf6.png"><br><p>  <i>Setting the interval timer in the Applilet3 for RL78 / G13 utility window</i> </p><br><p></p><br><p>  And of course, we will need to transfer the P77 pin, to which our LED is connected, to the output mode. </p><br><p></p><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/515/2b2/ad75152b262e69dfffc8576b3a0c2c7e.png"><br><p>  <i>Set pin P77in the Applilet3 for RL78 / G13 utility window</i> </p><br><p></p><br><p>  You can stop at this, save the project and press the cherished button Generate code (generate code).  We will use IAR as the development environment. </p><br><p></p><br><p>  Let's look at the files of the generated project: </p><br><p>  r_cg_cgc.c </p><br><p>  r_cg_cgc_user.c </p><br><p>  r_cg_it.c </p><br><p>  r_cg_it_user.c </p><br><p>  r_cg_port.c </p><br><p>  r_cg_port_user.c </p><br><p>  r_cg_timer.c </p><br><p>  r_cg_timer_user.c </p><br><p>  r_main.c </p><br><p>  r_systeminit.c </p><br><p></p><br><p>  As can be understood from their names, the entire code is divided into modules according to the functions performed: clock generator, interval timer, gpio, timers, as well as the main program loop (empty in our case) and the low-level controller initialization code.  Files of the form * _user.c contain stubs of event handlers of the corresponding periphery. </p><br><p></p><br><p>  Open the r_cg_it_user.c file and modify the interval timer handler.  Each call to the handler will be made to reduce or increase the duty cycle of the PWM by an amount specified by the number of STEPS_NUM steps.  When the maximum or minimum is reached, the direction of the change in brightness is reversed. </p><br><p></p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vector = INTIT_vect __interrupt static void r_it_interrupt(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Start user code. Do not edit comment generated here */</span></span></span><span class="hljs-meta"> int16_t TDR0_value, TDR1_value, step; R_TAU0_Channel0_Stop(); TDR0_value = TDR00; TDR1_value = TDR01; step = TDR0_value / STEPS_NUM; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (moving_up == 1) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (TDR1_value &gt; TDR0_value - step) moving_up = 0; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> TDR1_value += step; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (TDR1_value &lt; step) moving_up = 1; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> TDR1_value -= step; } TDR01 = TDR1_value; R_TAU0_Channel0_Start(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* End user code. Do not edit comment generated here */</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><p></p><br><p>  As it is easy to see, the generated project is replete with comments intended to separate the automatically generated and user-written code.  If you comply with these limits and save comments, you can change the peripheral settings using the Applilet utility at any time without losing the existing user code of the project. </p><br><p></p><br><p>  The only thing left for us to add to the project is the connection between the state of PWM and the pin P77 to which the LED is connected.  To do this, when the interruption of channel 0 of the timer is triggered, we set the controller's foot to one: </p><br><p></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vector = INTTM00_vect __interrupt static void r_tau0_channel0_interrupt(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Start user code. Do not edit comment generated here */</span></span></span><span class="hljs-meta"> P7_bit.no7 |= 1; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* End user code. Do not edit comment generated here */</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br><p>  And for channel 1, reset this value to zero: </p><br><p></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vector = INTTM01_vect __interrupt static void r_tau0_channel1_interrupt(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Start user code. Do not edit comment generated here */</span></span></span><span class="hljs-meta"> P7_bit.no7 &amp;= 0; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* End user code. Do not edit comment generated here */</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br><p>  Everything is ready: we compile the project, fill it into the controller using the WriteEZ utility and, moving the jumpers on our debug board from debug mode to the operating mode, observe how the LED on the board slowly and smoothly turns on and off, as required. </p><br><p></p><br><p>  Using the shown approach, the internal features of the Renesas RL78 series microcontrollers remained behind the scenes for us, which may not satisfy the needs of demanding developers when implementing complex projects, but for simple work algorithms, using automatic generation of an initialization code for an extensive list of peripherals of Renesas RL78 controllers can significantly reduce time, and therefore the cost of developing devices with ultra-low power consumption. </p><br><br>  Questions and comments are welcome. <br><br>  <b>PS</b> This article was published in a new issue of the printed magazine "Herald of Electronics".  More information about other electronic components and technologies that we use to develop electronics can be found on the Promwad team website in the <a href="http://promwad.ru/tehnologii/karta-tehnologiy">‚ÄúTechnologies‚Äù</a> section. </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/227409/">https://habr.com/ru/post/227409/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227387/index.html">Martian Jubilee Curiosity: A Whole Year on the Red Planet</a></li>
<li><a href="../227389/index.html">Cardberry discount cards aggregator: from idea to prototype</a></li>
<li><a href="../227391/index.html">Amazon's lure, Boom Beach results on Google Play, mobile gaming market volume in 2016 - the main mobile news for the week</a></li>
<li><a href="../227395/index.html">MongoDB Sharded Cluster on Centos 6.5</a></li>
<li><a href="../227399/index.html">We invite you to take part in the Russian Developers Cup</a></li>
<li><a href="../227411/index.html">Synology Announces Free Five-Year Warranty for XS / XS + Series NAS Servers</a></li>
<li><a href="../227415/index.html">Own WebGL engine. Article number 3. Primitives</a></li>
<li><a href="../227419/index.html">Formed a preliminary program WebCamp: Project Management Day</a></li>
<li><a href="../227421/index.html">Sell ‚Äã‚Äãa lot: the principles of the device sales department</a></li>
<li><a href="../227423/index.html">Database monitoring HostTracker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>