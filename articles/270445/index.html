<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Design and evolution of the C ++ language: excerpts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the comments to the translation of ‚Äú30 years of C ++‚Äù, it was noticeable that not all stages of the evolution of a language are equally well known,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Design and evolution of the C ++ language: excerpts</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/2d5/fd4/724/2d5fd472443c473181b72873d96129f9.png" align="left">  In the comments to the translation of <a href="http://habrahabr.ru/post/270083/">‚Äú30 years of C ++‚Äù,</a> it was noticeable that not all stages of the evolution of a language are equally well known, sometimes there is no idea at all about the origin and development of a particular element of syntax or corresponding semantics.  Perhaps this note will be able to interest readers turn to the not a new <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25B7%25D0%25B0%25D0%25B9%25D0%25BD_%25D0%25B8_%25D1%258D%25D0%25B2%25D0%25BE%25D0%25BB%25D1%258E%25D1%2586%25D0%25B8%25D1%258F_C%252B%252B">book by the author of the language</a> for a long time in order to form a more complete picture of C ++.  The book tells how its development took place, what influenced this process and why one approach was preferred over the other. <a name="habracut"></a><br><br>  Below is a set of short excerpts from the book, presented in a free form and sometimes supplemented with examples.  The order of presentation basically repeats the relative order of their appearance in the book.  Numbering is used for possible references to individual items.  There will be no intentional repetition of well-known facts here, since there is not much point in this.  Attention was paid to just the lesser known of them and the most interesting from the point of view of the author of the post.  Some items are quotations that say it all, some others just mention potentially interesting or funny facts.  Also, many details are omitted, they should be sought in the book. <br><br>  Some of the material intersects somewhat with recent posts, but has not been cut out for completeness.  The order may seem chaotic, but then this is a sample, an additional reason for the "disorder" is indicated in the conclusion.  When reading it is useful to bear in mind that the first edition of the book was published in early 1994. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#0d6cb6">Excerpts</font> </h2><br><ol><li><a name="e1"></a>  It all started in 1971, when <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D0%25B0%25D1%2583%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BF,_%25D0%2591%25D1%258C%25D1%2591%25D1%2580%25D0%25BD">Bjorn Stroustrup</a> needed a fast language to perform the simulation. <br><br></li><li><a name="e2"></a>  Classes came primarily from <a href="https://ru.wikipedia.org/wiki/Simula">Simula</a> . <br><br></li><li><a name="e3"></a>  <code>const</code> qualifiers owe their existence to <a href="https://ru.wikipedia.org/wiki/ROM">ROM</a> . <br><br></li><li><a name="e4"></a>  <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25BD%25D0%25B8%25D1%2581_%25D0%25A0%25D0%25B8%25D1%2587%25D0%25B8">Dennis Ritchie</a> was actively involved in discussing C ++ design.  (You will see below how strongly C and C ++ influenced each other.) <br><br></li><li><a name="e5"></a>  ‚ÄúInitially, the language suggested general mechanisms for organizing programs, rather than supporting specific subject areas,‚Äù i.e.  multi-paradigm in C ++ is inborn and corresponds to the idea of ‚Äã‚Äãits author. <br><br></li><li><a name="e6"></a>  ‚ÄúI am sincerely convinced that there is no one correct way to write a program, and a language designer should not force a programmer to follow a certain style.‚Äù <br><br></li><li><a name="e7"></a>  The initial implementation did not support virtual functions. <br><br></li><li><a name="e8"></a>  Multiple inheritance was added years after the start of language development. <br><br></li><li><a name="e9"></a>  Initially, class constructors were called <code>new</code> and returned <code>void</code> (although it could be omitted).  At the same time, the designers allocated memory for the object, and the destructors released it: <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// new(); };</span></span></code> </pre><br></li><li><a name="e10"></a>  The original name of the destructors was <code>delete</code> and they also returned <code>void</code> (although it could be omitted): <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// delete(); };</span></span></code> </pre><br></li><li><a name="e11"></a>  Instead of a double colon ( <code>::</code> :), a dot was used to declare the class methods: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.pop() { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br></li><li><a name="e12"></a>  Class names were in a separate namespace and had to be preceded by the <code>class</code> keyword (as well as <code>struct</code> / <code>union</code> in C): <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thatStack</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class">;</span></span></code> </pre><br></li><li><a name="e13"></a>  The very keyword <code>class</code> came from Simula, and since Bj√∂rn is not a fan of inventing terminology, he left what he was used to. <br><br></li><li><a name="e14"></a>  Simula language allowed to create instances of classes only on the heap, which was extremely inconvenient and gave the idea to allow them to be created in C ++ on the stack or globally. <br><br></li><li><a name="e15"></a>  ‚ÄúC ++ is just another language in the system, not the whole system.‚Äù <br><br></li><li><a name="e16"></a>  In the first implementation, it was not possible to access <code>this</code> , but this was largely due to an error. <br><br></li><li><a name="e17"></a>  Autoprototyping (output and memorization of a prototype of an unknown function in the place of its first access) was originally invented for C ++, but was later used in C (although it is now deprecated): <pre> <code class="cpp hljs">function(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,  function  int  double. function("string"); //    -    int  double.</span></span></code> </pre><br></li><li><a name="e18"></a>  The declaration of a function that does not accept arguments using <code>(void)</code> was added first in C ++, and only then in C (then in C ++ this idea was already abandoned and decided to use empty parentheses): <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noArgsInCpp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noArgsInCAndCpp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre><br></li><li><a name="e19"></a>  Declaring an implicit <code>int</code> as stale was originally proposed for C ++: <pre> <code class="cpp hljs">function() {} <span class="hljs-comment"><span class="hljs-comment">//  ,  function  int.</span></span></code> </pre><br></li><li><a name="e20"></a>  In the early periods, attempts were made to prohibit narrowing transformations ( <code>long -&gt; int</code> , <code>double -&gt; int</code> ), but because of too high prevalence, it was decided to abandon this idea: <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lng, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ i = lng; <span class="hljs-comment"><span class="hljs-comment">//   . char c = i; //   . }</span></span></code> </pre><br></li><li><a name="e21"></a>  Operator overloading, references and the ability to declare variables anywhere in the block came from <a href="https://ru.wikipedia.org/wiki/ALGOL_68">ALGOl 68</a> . <br><br></li><li><a name="e22"></a>  Single line comments ( <code>//</code> ) are from <a href="https://ru.wikipedia.org/wiki/BCPL">BCPL</a> . <br><br></li><li><a name="e23"></a>  Sources used in the development of exceptions: <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B4%25D0%25B0_(%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Ada</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D1%2583">Clu</a> , <a href="https://ru.wikipedia.org/wiki/ML">ML</a> . <br><br></li><li><a name="e24"></a>  Patterns and namespaces are borrowed from the Ada language. <br><br></li><li><a name="e25"></a>  Specifying the types of parameters in the function declaration is first implemented in C ++, later adapted to C. <br><br></li><li><a name="e26"></a>  The possibility of introducing an alternative syntax of declarations was considered (recently there was a <a href="http://habrahabr.ru/post/270081/">post</a> on a related topic): <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  : v: [10]-&gt;int; // int *v[10]; p: -&gt;[10]int; // int (*p)[10]; //   : int v[10]-&gt;; // int *v[10]; int p-&gt;[10]; // int (*p)[10]; int f(char)-&gt;[10]-&gt;(double)-&gt;; // int *(*(*f(char))[10])(double);</span></span></code> </pre>  The new syntax was not worked out in all its details and it never got into the language due to the small significance of the change against the background of potentially large backward-compatibility problems. <br><br></li><li><a name="e27"></a>  The refusal of mandatory type prefixes ( <code>struct</code> / <code>union</code> / <code>class</code> ) led to the possibility of declaring variables that coincide by name with classes (for the most part, for compatibility with C): <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Class Class; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br></li><li><a name="e28"></a>  At one time, it was allowed to declare new composite types in the argument list, or directly in the return value of the function: <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... } get() { return A(); }</span></span></code> </pre><br></li><li><a name="e29"></a>  Previously, ‚Äúpulling out‚Äù the members of the base classes did not require the use of the using keyword, it was enough just to specify the name of the member: <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingElse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: doSomething; <span class="hljs-comment"><span class="hljs-comment">// using doSomething; Base.doSomethingElse; // using doSomethingElse; };</span></span></code> </pre><br></li><li><a name="e30"></a>  Initially, only classes could be friendly.  The general idea of ‚Äã‚Äãthe concept is to place a number of entities in a single security domain, the members of which are equal in rights (and not encapsulation violation, as it may seem that, however, does not cancel the possibility of such use). <br><br></li><li><a name="e31"></a>  Perhaps it was Stroustrup who invented the concept of the designer. <br><br></li><li><a name="e32"></a>  Initially, each object could contain the <code>call()</code> and <code>return()</code> methods, which were called, respectively, before and after the execution of any method of the class.  Similar methods <code>:before</code> and <code>:after</code> are in <a href="https://ru.wikipedia.org/wiki/CLOS">CLOS</a> . <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProtectedAccess</span></span></span><span class="hljs-class"> :</span></span> object { call(); <span class="hljs-comment"><span class="hljs-comment">//   . return(); //  . };</span></span></code> </pre>  Later decided that this feature adds more difficulty in the language than brings benefits. <br><br></li><li><a name="e33"></a>  The possibility of including the garbage collector in the language was considered several times, but was considered unacceptable. <br><br></li><li><a name="e34"></a>  Direct support for multithreading was also considered, but it was decided to leave it for implementation as a library. <br><br></li><li><a name="e35"></a>  For a while, the language was called C84 to avoid confusion, since users replaced C with classes with something like ‚Äúnew C‚Äù, ‚Äúimproved C‚Äù, etc.  Optimistically considering that C will be standardized in 1985, Bj√∂rn was asked to change the name again, in order to avoid possible ambiguity with the ‚Äústandard C‚Äù. <br><br></li><li><a name="e36"></a>  The first C ++ compiler (not the preprocessors that were used initially) was written in C ++ (Cfront, C with classes and C84, it seems, were written in C). <br><br></li><li><a name="e37"></a>  <a href="https://en.wikipedia.org/wiki/Cfront">Cfront</a> was probably the first incomplete loop compiler generating code in C. It was followed by Ada, <a href="https://en.wikipedia.org/wiki/Eiffel_(programming_language)">Eiffel</a> , <a href="https://en.wikipedia.org/wiki/Lisp">Lisp</a> , <a href="https://en.wikipedia.org/wiki/Modula-3">Modula-3</a> , <a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a> . <br><br></li><li><a name="e38"></a>  The first implementation of exceptions was added by Hewlett-Packart in 1992. <br><br></li><li><a name="e39"></a>  Virtual functions were borrowed from Simula, but with modifications. <br><br></li><li><a name="e40"></a>  Type definition at runtime was not originally added intentionally to force users to use static type control and virtual functions, rather than a run-time type, which is essentially a <code>switch</code> . <br><br></li><li><a name="e41"></a>  <code>struct</code> almost equivalent to <code>class</code> for the purpose of uniformity and unification. <br><br></li><li><a name="e42"></a>  Before Cfront 2.0, <code>operator=</code> could be a global function; later, this idea was abandoned due to conflicting predefined semantics. <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span>}; C &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(C &amp;rhs) {} <span class="hljs-comment"><span class="hljs-comment">//   : // src.cpp:3:21: error: 'C&amp; operator=(C&amp;)' must be a nonstatic member function</span></span></code> </pre><br></li><li><a name="e43"></a>  The definition of a variable at its place of use is taken from ALGOL 68. <br><br></li><li><a name="e44"></a>  Links are also borrowed from ALGOL 68, but there they could be reassigned after initialization. <br><br></li><li><a name="e45"></a>  Overload on lvalue / rvalue was considered at the time of Cfront 1.0. <br><br></li><li><a name="e46"></a>  readonly / writeonly pointers / data were invented by Straustrup and Dennis Ritchie in 1981, and were later added to the standard C by the ANSI C (X3J11) committee, but in a somewhat truncated form: only readonly and after renaming it to <code>const</code> . <br><br></li><li><a name="e47"></a>  The <code>new</code> keyword is also taken from Simula. <br><br></li><li><a name="e48"></a>  The initial implementation of object allocation assumed the assignment of <code>this</code> in the constructor. <br><br></li><li><a name="e49"></a>  <code>constructor</code> / <code>destructor</code> as the names of the corresponding special methods were rejected to reduce the number of keywords, as well as for more obvious syntax. <br><br></li><li><a name="e50"></a>  The <code>new()</code> and <code>delete()</code> functions (the old constructor and destructor names) in C with classes, by default, automatically received the <code>public</code> access <code>public</code> . <br><br></li><li><a name="e51"></a>  Operator <code>::</code> was introduced to resolve ambiguity with a dot. <br><br></li><li><a name="e52"></a>  Initially, the variables entered in the <code>for</code> initialization list were visible after its body (due to inaccurate wording ‚Äúnames are visible from the declaration point to the end of the area‚Äù).  Many have probably come across this in Borland C ++. <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i) { <span class="hljs-comment"><span class="hljs-comment">// ... } if (i &gt;= n) { //   i,    for.</span></span></code> </pre><br></li><li><a name="e53"></a>  Nested class scopes were added, later removed for compatibility with C and re-added again. <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      C   C++: struct Outer { struct Inner { }; }; //   C   : struct Outer { }; struct Inner { };</span></span></code> </pre><br></li><li><a name="e54"></a>  <code>static</code> default for global characters was against the rules of C and for this reason was not added to C ++. <br><br></li><li><a name="e55"></a>  Strict type checking when calling functions in C came from C ++. <br><br></li><li><a name="e56"></a>  ‚ÄúThe key to good design is a deep understanding of the tasks facing the language, not the inclusion of the most advanced ideas.‚Äù <br><br></li><li><a name="e57"></a>  Abstract classes, type-safe layout, and multiple inheritance appeared in Cfront 2.0. <br><br></li><li><a name="e58"></a>  The arbitrary order of declarations of class elements caused problems and led to some inequality between types and data.  So allowed to do: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-comment"><span class="hljs-comment">// x  X::x int x; };</span></span></code> </pre>  And it is already forbidden: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *T; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Y</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-comment"><span class="hljs-comment">// , .. T      . typedef f int T; };</span></span></code> </pre>  The same is true for types of functions, because: <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Q1)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// static int Q1(); static P Q2; // static int Q2(); };</span></span></code> </pre><br></li><li><a name="e59"></a>  In Cfront, temporary objects were destroyed at the end of the block (now - after evaluating the expression, if the temporary object is not bound): <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s1 = ..., s2 = ...; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((p = (s1 + s2).c_str()) &amp;&amp; p[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { <span class="hljs-comment"><span class="hljs-comment">//      p. // ... //    ,   "s1 + s2". }</span></span></code> </pre><br></li><li><a name="e60"></a>  Maybe someone else will be news, but Pascal also has <a href="https://en.wikipedia.org/wiki/Pascal_%2528programming_language%2529">ISO / IEC standards</a> (there are just <a href="https://en.wikipedia.org/wiki/Category:Programming_languages_with_an_ISO_standard">not</a> enough of these languages). <br><br></li><li><a name="e61"></a>  The proposal to add named arguments was considered, but rejected.  (While reading the book, the impression was that a rather large number of different proposals were rejected; however, a lot of this still fell into the standard after decades.) <br><br></li><li><a name="e62"></a>  <code>restrict</code> (noalias) pointers were never adapted from C even though they were known in the early 90s. <br><br></li><li><a name="e63"></a>  Special characters caused C distribution problems in Europe due to the wide use of 7-bit encodings.  From here came the trigraphs, digraphs and special words ( <code>and</code> , <code>or</code> , etc .; <a href="http://en.cppreference.com/w/cpp/language/operator_alternative">see.</a> ).  All this migrated to C ++. <br><br></li><li><a name="e64"></a>  The budget that AT &amp; T has allocated in C ++ for all time is approximately $ 3000.  Of these, $ 1000 went to the C ++ advertising newsletter to UNIX buyers and $ 2000 to the first conference, at which everything was more than modest (even the paper was not enough, the volunteers made copies of technical documentation on the visitors registration forms ...).  Nevertheless, the absence of any marketing for decades did not prevent the widespread use of the language. </li></ol><br><h2>  <font color="#0d6cb6">Conclusion</font> </h2><br>  In conclusion, I would like to mention the somewhat nonstandard structure of the book (so the order of the points might seem strange) with an increase in the level of detail in each of the parts, as well as the fact that it describes well the principles that Straustrup tries to adhere to and justify them.  Therefore, it should be interesting not only to C ++ programmers, but also to many who are interested in programming languages ‚Äã‚Äãin general. </div><p>Source: <a href="https://habr.com/ru/post/270445/">https://habr.com/ru/post/270445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270435/index.html">Forcing open_basedir + realpath_cache to work together</a></li>
<li><a href="../270437/index.html">(Archive) Matreshka.js - Three possibilities</a></li>
<li><a href="../270439/index.html">Linux containers: when containers gets bigger</a></li>
<li><a href="../270441/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ184 (November 2 - 8, 2015)</a></li>
<li><a href="../270443/index.html">Processing of private data on public computer networks</a></li>
<li><a href="../270447/index.html">Design development for MyOffice applications</a></li>
<li><a href="../270449/index.html">Some repositories to help learners and teachers of Python and machine learning.</a></li>
<li><a href="../270451/index.html">7 enhanced features of Visual Studio 2015 Enterprise</a></li>
<li><a href="../270453/index.html">Big data from A to Z. Part 3: Techniques and strategies for developing MapReduce-applications</a></li>
<li><a href="../270457/index.html">Apple TV</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>