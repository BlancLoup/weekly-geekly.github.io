<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bucardo: Multimaster replication</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the process of tormenting, I shoveled a ton of articles and decided to write a detailed manual. Moreover, the information on configuring multimaste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bucardo: Multimaster replication</h1><div class="post__text post__text-html js-mediator-article">  In the process of tormenting, I shoveled a ton of articles and decided to write a detailed manual.  Moreover, the information on configuring multimaster and in Russian is very small and it is kind of piecewise. <br><br>  A bit of introductory.  To Bucardo earned, we must: <br><br>  1) Tell him which databases on which servers exist at all. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2) Tell him which tables are involved in replication. <br><br>  <i>Attention: if the developers add a new table to the application, we must report this to bucardo.</i>  <i>The same goes for changing the schema of existing tables.</i> <br><br>  3) Tell him which groups of tables exist and which tables fall into which groups.  Groups are needed in case different tables need to be replicated between different servers.  It is more convenient to work with a group than to indicate each one separately (very similar to groups in Nagios). <br><br>  4) Tell him which database groups exist.  The goal is the same as for the tables. <br><a name="habracut"></a><br>  Let's proceed to the installation.  Option for Debian 7. It is understood that the postgresql-9.1 and postgresql-client-9.1 packages are already installed. <br><br><h5>  Preliminary preparation </h5><br>  Servers will be called <b>node1</b> and <b>node2</b> .  Be sure to also ensure that all participating PostreSQL servers listen to external interfaces: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># netstat -plnt4 | grep 5432 tcp 0 0 0.0.0.0:5432 0.0.0.0:* LISTEN 12345/postgres</span></span></code> </pre> <br>  Install the Bucardo package and PL / Perl support for PostgreSQL on each of the servers: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># apt install bucardo postgresql-plperl-9.1</span></span></code> </pre> <br>  Activate on each of the servers: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># sed -i 's/ENABLED=0/ENABLED=1/' /etc/default/bucardo</span></span></code> </pre> <br>  For some reason, the main managers of the package did not guess to create a directory under the PID, so we will create it ourselves on each of the servers: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># mkdir /var/run/bucardo</span></span></code> </pre> <br>  Make sure that we can connect via a TCP socket to the DBMS on each of the servers: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># psql -U postgres -h 127.0.0.1</span></span></code> </pre> <br>  If you do not remember the password, the simplest instruction is <a href="http://null-step.blogspot.ru/2008/11/postgresql.html">here</a> . <br><br>  If the PG does not want to accept requests from a particular user‚Äôs address, then configure /etc/postgresql/9.1/main/pg_hba.conf <br><br>  Next will be the initialization of the database.  It will be created by the postgres user, but filled with the user bucardo, so you can rest against the connectivity issue. <br>  In order to avoid it, we will pre-add a line for it to /etc/postgresql/9.1/main/pg_hba.conf.  In addition, in the process of work, Bucardo will turn not only to its cluster node, but also to the steam room.  Therefore, we also do not forget it.  If you have more servers in a cluster, do not forget about them.  On each of the servers: <br><br><pre> <code class="bash hljs">host all bucardo 127.0.0.1/32 trust host all bucardo SECOND.NODE.IP.ADDRESS/32 password</code> </pre> <br>  After this, restarting the DBMS: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># pg_ctlcluster 9.1 main restart</span></span></code> </pre> <br><h5>  Install Bucardo </h5><br>  The bucardo_ctl utility in recent versions of Debian has been replaced by bucardo, so we will use it. <br><br>  Initialize the database: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo install</span></span></code> </pre> <br>  The dialogue looks like this: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo install This will install the bucardo database into an existing Postgres cluster. Postgres must have been compiled with Perl support, and you must connect as a superuser Current connection settings: 1. Host: localhost 2. Port: 5432 3. User: postgres 4. Database: postgres 5. PID directory: /var/run/bucardo Enter a number to change it, P to proceed, or Q to quit: P Password for user postgres: Postgres version is: 9.1 Password for user postgres: Creating superuser 'bucardo' Password for user postgres: Attempting to create and populate the bucardo database and schema Password for user postgres: Database creation is complete Updated configuration setting "piddir" Installation is now complete. If you see errors or need help, please email bucardo-general@bucardo.org You may want to check over the configuration variables next, by running: bucardo show all Change any setting by using: bucardo set foo=bar</span></span></code> </pre> <br>  During the initialization process, the database was created from the /usr/share/bucardo/bucardo.schema file, so there is no need to fill it in with hands, as described in the manuals of previous versions. <br><br>  Bucardo is installed, you can run it: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo start</span></span></code> </pre> <br><h5>  Replication setup </h5><br>  Before configuring replication, let's create test databases that will be replicated. <br>  On each of the servers: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># psql -U postgres -c "CREATE DATABASE mydb;" # psql -U postgres mydb -c "CREATE TABLE mytable ( num123 integer PRIMARY KEY, abc varchar(10) );"</span></span></code> </pre> <br>  <u>Another important point about security</u> .  After adding the replicable database to the configuration, Bucardo will enter the user's password into the database.  And since he did not request it during installation, he made it exactly the same as that of the postgres user.  In other words, in our bucardo database, the password from the superuser will be stored in clear text, which is somewhat dangerous. <br><br>  Therefore, we will make him a different password.  On each of the servers: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># psql -U postgres -c "ALTER USER bucardo WITH PASSWORD 'eiP4uSash5';"</span></span></code> </pre> <br>  Next, we give Bucardo information on how to connect to the database, which we will replicate.  I am not a fan of Unix sockets under high load conditions (a separate topic for conversation), so even where locally, we specify a TCP socket. <br><br>  ATTENTION: We do this on the node1 server.  In general, we continue to work only with node1 until it is specified what should be done on both. <br><br>  Add a local (mydb_node1) and its remote copy (mydb_node2) from the node2 server: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo add database mydb_node1 dbname=mydb dbhost=127.0.0.1 dbuser=bucardo dbpass=eiP4uSash5 Added database "mydb_node1"</span></span></code> </pre> <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo add database mydb_node2 dbname=mydb dbhost=node2.example.com dbuser=bucardo dbpass=eiP4uSash5 Added database "mydb_node2"</span></span></code> </pre> <br>  Here: <br><br>  mydb_nodeX is an internal base notation.  This is the name Bucardo uses in interior work with the base. <br>  dbname = mydb is the real database name in PostgreSQL, referenced by mydb_nodeX. <br>  dbuser = bucardo - under whom Bucardo will connect to the database to work with this database. <br><br>  We can see the result like this: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo list database Database: mydb_node1 Status: active Conn: psql -p -U bucardo -d mydb -h 127.0.0.1 Database: mydb_node2 Status: active Conn: psql -p -U bucardo -d mydb -h node2.example.com</span></span></code> </pre> <br>  These settings are taken from the db table of the base bucardo, where the password mentioned above sits: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># psql -U postgres bucardo -c "SELECT name,dbname,dbhost,dbuser,dbpass,status FROM db;" name | dbname | dbhost | dbuser | dbpass | status ------------+--------+-------------------+---------+------------+-------- mydb_node1 | mydb | 127.0.0.1 | bucardo | eiP4uSash5 | active mydb_node2 | mydb | node2b.forbet.net | bucardo | eiP4uSash5 | active (2 rows)</span></span></code> </pre><br>  Now we need to add a table that we will replicate between them.  In most cases, people replicate the entire database, so we will add everything at once (a group of tables (herd) will be created automatically).  If the developers come up with a new table, we will simply add it to the group later and everything will work by itself - as further settings will concern the entire group. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo add table all --db=mydb_node1 --herd=mydb_herd Creating herd: mydb_herd Added table public.mytable to herd mydb_herd New tables added: 1</span></span></code> </pre> <br>  Here: <br><br>  --herd = mydb_herd - the name of the table group, in order to set up synchronization not for each one separately, but for the whole crowd. <br><br>  And we can immediately see it: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo list tables 1. Table: public.mytable DB: mydb_node1 PK: num123 (int4)      PK. Bucardo, ,       .      .</span></span></code> </pre><br>  And the group is also visible: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo list herd Herd: mydb_herd DB: mydb_node1 Members: public.mytable</span></span></code> </pre> <br>  The same goes for sequences.  In our example, they are not, but suddenly someone uses.  We will not create our own group for them in order not to complicate things.  The likelihood that the tables are replicated in one direction and the sequences in the other is extremely small.  Therefore, let there be one group for tables and sequences: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo add sequence all --db=mydb_node1 --herd=mydb_herd Sorry, no sequences were found New sequences added: 0</span></span></code> </pre><br>  Our next task is to create a replication group.  In this group we will say which database will be the source and which will be the recipient of the data.  First create the group itself, while the empty one: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo add dbgoup other_mydb_servers Created database group "mydb_servers_group"</span></span></code> </pre> <br>  We add both our servers to the group, indicating who will play what role.  <b>This is the only point where the master-slave setting differs from the master-master</b> . <br><br>  Initially, you might think that source is the source, and target is the recipient.  In fact this is not true.  A source is one who works both as a source and as a recipient, and the target is only a recipient. <br><br>  That is, if we have a master-slave, then we specify one source, and the second target.  And if we have a master-master, then both will be source, and there will be no target'es at all. <br><br><h6>  Option for MASTER -&gt; SLAVE: </h6><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo add dbgroup mydb_servers_group mydb_node1:source Added database "mydb_node1" to group "mydb_servers_group" as source # bucardo add dbgroup mydb_servers_group mydb_node2:target Added database "mydb_node2" to group "mydb_servers_group" as target</span></span></code> </pre> <br><h6>  Option for MASTER &lt;-&gt; MASTER: </h6><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo add dbgroup mydb_servers_group mydb_node1:source Added database "mydb_node1" to group "mydb_servers_group" as source # bucardo add dbgroup mydb_servers_group mydb_node2:source Added database "mydb_node2" to group "mydb_servers_group" as source</span></span></code> </pre> <br>  Everything!  We have written what is the base.  It is written what tables are in them.  It is written who in what group.  It remains to say the final touch - to say which group of tables will ‚Äúply‚Äù between the bases of which group.  In other words - create a "sync": <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo add sync mydb_sync herd=mydb_herd dbs=mydb_servers_group Added sync "mydb_sync"</span></span></code> </pre> <br>  We can see what we did: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo list sync Sync: mydb_sync Herd: mydb_herd [Active] DB group mydb_servers_group: mydb_node1 (source) mydb_node2 (source  target -  )</span></span></code> </pre> <br>  After changing the settings, be sure to restart Bucardo: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># bucardo restart</span></span></code> </pre> <br>  ======== <br><br>  Check: on the first node1 node we run: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># psql -U postgres mydb -c "INSERT INTO mytable VALUES (1, 'a');"</span></span></code> </pre> <br>  and on the second node2 we check: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># psql -U postgres mydb -c "SELECT * FROM mytable;"</span></span></code> </pre> <br>  who made multimaster, that should be checked in the opposite direction.  Create on node2, and check on node1. <br><br>  ======== <br><br>  Questions that most people will have: <br><br>  1) What will happen to the table on the target-base if the table on the source-base was changed while Bucardo was turned off or the network was unavailable? <br><br>  The answer is: Ok.  When starting or when the network appears, Bucardo will transfer data to the target server.  So the target server can break as you like.  The only requirement is that it should have the same data scheme (table structure) as the first one. <br><br>  __ <br><br>  2) If the base is large (tens to hundreds of gigabytes), Bucardo "breaks off" and does not synchronize to the end.  How to be? <br><br>  Answer: put sync in the inactive state.  But Bucardo must be enabled for the source-base for logging queries. <br><br>  bucardo update sync mydb_sync status = inactive (for multimaster on all nodes) <br>  Next, do pg_dump / pg_restore with your hands and return sync to active mode (for multimaster, first on the one where the new requests went after starting the dump). </div><p>Source: <a href="https://habr.com/ru/post/327674/">https://habr.com/ru/post/327674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327658/index.html">What's new in Rails 5.1</a></li>
<li><a href="../327662/index.html">Swift Generics: Styles for UIView and more. # 1</a></li>
<li><a href="../327666/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ260 (April 24 - 30, 2017)</a></li>
<li><a href="../327668/index.html">Quick start on React Native</a></li>
<li><a href="../327670/index.html">Monitoring Docker Swarm with cAdvisor, InfluxDB and Grafana</a></li>
<li><a href="../327676/index.html">We raise our VPN server on Amazon EC2 under Windows Server 2008 r2</a></li>
<li><a href="../327678/index.html">Linus Torvalds introduced the Linux kernel 4.11</a></li>
<li><a href="../327680/index.html">Crowd Marketing: Top 10 Popular Questions</a></li>
<li><a href="../327682/index.html">Encryption in EXT4. How it works?</a></li>
<li><a href="../327684/index.html">How to raise your i2p-site (eepsite) on VDS (VPS) under Ubuntu (LAMP). Briefing for beginners</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>