<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementation of multi-threaded game engine architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the advent of multi-core processors, it became necessary to create a game engine based on a parallel architecture. The use of all processors of t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementation of multi-threaded game engine architecture</h1><div class="post__text post__text-html js-mediator-article">  With the advent of multi-core processors, it became necessary to create a game engine based on a parallel architecture.  The use of all processors of the system - both graphic (GP) and central (CPU) - opens up much more possibilities compared to a single-threaded engine based on GP only.  For example, using more CPU cores, you can improve the visual effects by increasing the number of physical objects used in the game, as well as achieve more realistic behavior of the characters through the implementation of advanced artificial intelligence (AI). <br>  Consider the features of the implementation of a multi-threaded game engine architecture. <br><a name="habracut"></a><br><h2>  <font color="#0071c5">1. Introduction</font> </h2><br><h4>  1.1.  Overview </h4><br>  The multi-threaded architecture of the game engine allows you to use the capabilities of all processors of the platform to the maximum.  It involves the parallel execution of various functional blocks on all available processors.  However, to implement such a scheme, it turns out, is not so simple.  Individual elements of the game engine often interact with each other, which can lead to errors when they are executed simultaneously.  To handle such scenarios, the engine has special data synchronization mechanisms that exclude possible locks.  It also implements methods for simultaneous synchronization of data, thereby minimizing the execution time. <br><br>  To understand the presented materials, one needs to be well-versed in modern methods of creating computer games, multi-threading support for game engines, or to improve the performance of applications in general. <br><br><h2>  <font color="#0071c5">2. State of parallel execution</font> </h2><br>  The parallel execution state is a key notion of multithreading.  Only by dividing the game engine into separate systems, each working in its own mode and practically not interacting with the rest of the engine, one can achieve the highest efficiency of parallel computing and reduce the time required for synchronization.  It is not possible to completely isolate separate parts of the engine, excluding all shared resources.  However, for operations such as retrieving data on the position or orientation of objects, individual systems may use local copies of data, rather than shared resources.  This allows you to minimize the dependence of data in different parts of the engine.  Notifications of changes in general data made by a separate system are transmitted to the state manager, which places them in a queue.  This is called messaging mode.  This mode assumes that, after completing the execution of tasks, the engine systems receive notification of changes and update their internal data accordingly.  Such a mechanism can significantly reduce synchronization time and the dependence of systems on each other. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  2.1 Fulfillment States </h4><br>  In order for the execution state manager to work efficiently, it is recommended to synchronize operations on a certain clock pulse.  This allows all systems to operate simultaneously.  In this case, the clock frequency does not necessarily have to correspond to the frame rate.  Yes, and the duration of the cycles may not depend on the frequency.  It can be chosen in such a way that one clock corresponds to the time required to transmit one frame (regardless of its size).  In other words, the frequency or duration of clocks is determined by the specific implementation of the state manager.  Figure 1 shows the ‚Äúfree‚Äù step-by-step mode of operation, in which it is not required that all systems complete the operation in the same clock cycle.  The mode in which all systems complete operations in one cycle is called ‚Äúhard‚Äù step-by-step mode.  It is schematically depicted in Figure 2. <br><br><img src="https://habrastorage.org/files/c4b/f4d/d79/c4bf4dd7989044418f2de2077a7fa7e6.jpg"><br>  <i>Figure 1. Run state in step free mode</i> <br><br><h5>  2.1.1.  Free step mode </h5><br>  In free step-by-step mode, all systems operate continuously for a predetermined period of time required to complete the next batch of calculations.  However, the name ‚Äúfree‚Äù should not be taken literally: the systems are not synchronized at an arbitrary point in time, they are only ‚Äúfree‚Äù in the choice of the number of cycles required for the execution of the next stage. <br>  As a rule, in this mode it is not enough to send a simple state change notification to the state manager.  You must also transfer the updated data.  This is because the system that changed the shared data may be in a running state, while another system that is waiting for this data is ready to perform the update.  In this case, more memory is required, since you need to create more copies of the data.  Therefore, the ‚Äúfree‚Äù regime cannot be considered a universal solution for all occasions. <br><br><h5>  2.1.2.  Hard Step Mode </h5><br>  In this mode, the execution of tasks of all systems is completed in one cycle.  Such a mechanism is easier to implement and does not require the transfer of updated data along with the notification.  Indeed, if necessary, one system can simply request new values ‚Äã‚Äãfrom another system (of course, at the end of the execution cycle). <br>  In hard mode, you can implement a pseudo-free step-by-step mode of operation, distributing the calculations between the various steps.  In particular, this may be required for AI calculations, where the initial ‚Äúcommon goal‚Äù is calculated for the first beat, which is gradually refined in the next stages. <br><br><img src="https://habrastorage.org/files/270/51f/a7c/27051fa7c2824eea8ad60cbaa1368d40.jpg"><br>  <i>Figure 2. Execute status in hard walk mode</i> <br><br><h4>  2.2.  Data synchronization </h4><br>  Changing shared data across multiple systems may result in a conflict of changes.  In this case, in the messaging system it is necessary to provide an algorithm for selecting the correct total value.  There are two main approaches based on the following criteria. <br><ul><li>  Time: The final value is the last change made. </li><li>  Priority: the final value is the change made by the system with the highest priority.  If the priority of the systems coincides, you can also consider the time for making changes. </li></ul><br>  All obsolete data (according to any of the criteria) can be simply overwritten or excluded from the notification queue. <br>  Since the final value may depend on the order of the changes, it can be very difficult to use the relative values ‚Äã‚Äãof the total data.  In such cases, absolute values ‚Äã‚Äãshould be used.  Then, when updating local data, systems can simply replace old values ‚Äã‚Äãwith new ones.  The optimal solution is to choose absolute or relative values ‚Äã‚Äãdepending on the specific situation.  For example, general data, such as position and orientation, should have absolute values, since the order of change is important to them.  Relative values ‚Äã‚Äãcan be used, for example, for a particle generation system, since all information about particles is stored only in itself. <br><br><h2>  <font color="#0071c5">3. Engine</font> </h2><br>  When developing the engine, the focus is on the flexibility needed to further expand its functionality.  This will optimize it for use under certain restrictions (for example, by memory). <br>  The engine can be divided into two parts: the framework and managers.  The framework (see section 3.1) includes parts of the game that are replicated in the process of execution, that is, they exist in several copies.  It also includes elements involved in the execution of the main game cycle.  Managers (see Section 3.2) are singleton objects responsible for the execution of the logical component of the game. <br>  Below is a diagram of the game engine. <br><br><img src="https://habrastorage.org/files/816/216/a0c/816216a0c704407c91dbf6893be939fe.jpg"><br>  <i>Figure 3. The overall architecture of the engine</i> <br><br>  Please note that functional game modules, or systems, are not part of the engine.  The engine only unites them, acting as a connecting element.  Such a modular organization makes it possible to load and unload systems as needed. <br><br>  The interaction of the engine and systems is carried out using interfaces.  They are implemented in such a way as to give the engine access to the functions of the systems, and systems - to the managers of the engine. <br>  A detailed diagram of the engine is presented in Appendix A, ‚ÄúEngine Diagram‚Äù. <br><br>  In fact, all systems are independent of each other (see Section 2, ‚ÄúSimultaneous Execution Status‚Äù), that is, they can perform actions in parallel without affecting the work of other systems.  However, any change in data will entail certain difficulties, since the systems will have to interact with each other.  The exchange of information between systems is necessary in the following cases: <br><ul><li>  to inform another system about changes in general data (for example, the position or orientation of objects); </li><li>  to perform functions that are not available for this system (for example, the AI ‚Äã‚Äãsystem refers to the system for calculating the geometric or physical properties of an object in order to perform a ray intersection test). </li></ul><br>  In the first case, the state manager described in the previous section can be used to control the exchange of information.  (For details on the state manager, see section 3.2.2, ‚ÄúState Manager‚Äù.) <br>  In the second case, you need to implement a special mechanism that allows you to provide the services of one system to use another.  A full description of this mechanism is given in Section 3.2.3, ‚ÄúService Manager‚Äù. <br><br><h4>  3.1.  Framework </h4><br>  The framework is used to combine all the elements of the engine.  It is the initialization of the engine, with the exception of managers, instances of which are created globally.  It also stores information about the scene.  To achieve greater flexibility, the scene is implemented in the form of a so-called universal scene, which contains universal objects.  They are containers that combine the various functional parts of the scene.  Detailed information is provided in section 3.1.2. <br>  The main game cycle is also implemented in the framework.  Schematically it can be represented as follows. <br><br><img src="https://habrastorage.org/files/7e0/841/120/7e0841120e844a4d92d1115543c8866f.jpg"><br>  <i>Figure 4. Main game loop</i> <br><br>  The engine works in a windowed environment, therefore, in the first step of the game cycle, it is necessary to process all incomplete messages of the OS windows.  If this is not done, the engine will not respond to OS messages.  In the second step, the scheduler assigns tasks using the task manager.  This process is described in detail in section 3.1.1 below.  After that, the state manager (see Section 3.2.2) sends information about the changes made to the engine systems, the operation of which it can affect.  At the last step, depending on the execution status, the framework determines whether to complete or continue the engine, for example, to go to the next scene.  Information about the state of the engine is stored in the environment manager.  For details, see section 3.2.4. <br><br><h5>  3.1.1.  Scheduler </h5><br>  The scheduler generates a reference clock signal with a specified frequency.  If in benchmarking mode it is required that the next operation starts immediately after the previous one is completed, without waiting for the end of the cycle, the frequency can be unlimited. <br>  Using a clock signal, the scheduler with the help of the task manager puts the system into the execution mode.  In a free step-by-step mode (section 2.1.1), the scheduler polls the system to determine how many ticks they need to complete the task.  According to the survey results, the scheduler determines which systems are ready for execution, and which ones will complete the work at a specific time.  The scheduler can change the number of ticks if any system needs more time to execute.  In a hard step-by-step mode (section 2.1.2), all systems begin and end execution on the same clock cycle, so the scheduler waits for all systems to finish. <br><br><h5>  3.1.2.  Universal Scene and Objects </h5><br>  The universal scene and objects are containers for functionality implemented in other systems.  They are intended solely to interact with the engine and do not perform any other functions.  However, they can be extended to use functions available to other systems.  This allows for weak connectivity.  Indeed, the universal scene and objects can use the properties of other systems without being attached to them.  This property eliminates the dependence of systems from each other and gives them the opportunity to work simultaneously. <br>  The diagram below shows the expansion of the universal scene and object. <br><br><img src="https://habrastorage.org/files/06b/97d/c09/06b97dc09bc443fb93106bc5eb0215b4.jpg"><br>  <i>Figure 5. Expansion of the universal scene and object</i> <br><br>  Consider the principle of the extensions on the following example.  Let's say an extension of the universal universal scene has been completed; the scene has been extended to use graphical, physical, and other properties.  In this case, the ‚Äúgraphic‚Äù part of the expansion will be responsible for the initialization of the display, and its ‚Äúphysical‚Äù part will be responsible for implementing the physical laws for solids, such as gravity.  Scenes contain objects, so a universal scene will also include several universal objects.  Generic objects can also be expanded to be extended to use graphical, physical, and other properties.  For example, the drawing of an object on the screen will be realized by graphic functions of expansion, and the calculation of the interaction of solids - by physical ones. <br><br>  A detailed diagram of the interaction of the engine and systems is given in Appendix B, "The scheme of interaction between the engine and systems." <br>  It should be noted that the universal scene and universal object are responsible for registering all of their "extensions" in the state manager, so that all extensions can be notified of changes made by other extensions (that is, other systems).  As an example, a graphic extension registered to receive notifications about changes in position and orientation made by the physical extension. <br>  For detailed information on system components, see Section 5.2, ‚ÄúSystem Components‚Äù. <br><br><h4>  3.2.  Managers </h4><br>  Managers manage the engine.  They are singleton objects, that is, each type of manager is available in only one instance.  This is necessary because the duplication of resource managers will inevitably lead to redundancy and will adversely affect performance.  In addition, managers are responsible for implementing common functions for all systems. <br><br><h5>  3.2.1.  Task manager </h5><br>  The task manager is responsible for managing system tasks in the thread pool.  To ensure optimal n-fold scaling and prevent the assignment of unnecessary threads, eliminating unnecessary costs for switching tasks in the operating system, a thread pool creates one thread per processor. <br><br>  The scheduler sends to the task manager a list of tasks to be performed, as well as information on which tasks need to be completed.  He receives this data from various systems.  Each system receives only one task to perform.  This method is called functional decomposition.  However, for data processing each such task can be divided into an arbitrary number of subtasks (data decomposition). <br>  Below is an example of the distribution of tasks between threads for a quad-core system. <br><br><img src="https://habrastorage.org/files/226/f62/1a1/226f621a10fb4c7e810b40ac8b50d6a2.jpg"><br>  <i>Figure 6. Example thread pool used by task manager</i> <br><br>  In addition to processing the scheduler's requests for access to the main tasks, the task manager can work in the initialization mode.  He sequentially polls the systems from each stream so that they can initialize the local data stores needed for operation. <br>  Tips for implementing a task manager are given in Appendix D, ‚ÄúTips for Implementing Tasks.‚Äù <br><br><h5>  3.2.2.  State manager </h5><br>  The state manager is part of the messaging engine.  It tracks changes and sends notifications about them to all systems that these changes may affect.  In order not to send unnecessary notifications, the state manager stores information about which systems to notify in this or that case.  This mechanism is based on the ‚ÄúObserver‚Äù template (see Appendix C, ‚ÄúObserver (design pattern)‚Äù).  In short, this pattern assumes the use of an ‚Äúobserver‚Äù who monitors any changes of the subject, and the change controller performs the role of an intermediary between them. <br><br>  The mechanism works as follows.  1. The observer tells the change controller (or state manager) which changes he wants to monitor.  2. The entity notifies the controller of all its changes.  3. At the signal of the framework, the controller notifies the observer about changes in the subject.  4. The observer sends a request for updated data to the subject. <br><br>  In the free step-by-step mode (see Section 2.1.1), the implementation of this mechanism is somewhat complicated.  First, the updated data will have to be sent along with the change notification.  In this mode, sending by request is not applicable.  Indeed, if at the time of receiving the request, the system responsible for the changes has not yet completed execution, it will not be able to provide updated data.  Secondly, if some system is not yet ready to receive changes at the end of a clock, the state manager will have to hold the changed data until all the systems registered to receive them are in a ready state. <br><br>  The framework provides for this two state managers: for processing changes at the scene level and at the object level.  Typically, messages relating to scenes and objects are independent of each other, so the use of two separate managers eliminates the need to process unnecessary data.  But if a scene needs to take into account the state of an object, it can be registered on to receive notifications about its changes. <br><br>  In order not to perform unnecessary synchronization, the state manager creates a queue of change notifications separately for each thread created by the task manager.  Therefore, when accessing the queue, no synchronization is required.  Section 2.2 describes a method that can be used to join queues after execution. <br><br><img src="https://habrastorage.org/files/886/a94/bfd/886a94bfdfc44d8db5d7f1cc73d202b1.jpg"><br>  <i>Figure 7. Notification of internal changes to the universal object</i> <br><br>  Notification of changes is not necessary to send consistently.  There is a way to send them in parallel.  Performing the task, the system works with all its objects.  For example, as physical objects interact with each other, the physical system controls their movement, the calculation of collisions, new forces, etc. When receiving notifications, the system object does not interact with other objects of its system.  It interacts with the associated extensions of the universal object.  This means that universal objects are now independent of each other and can be updated simultaneously.  This approach does not exclude extreme cases that should be considered in the synchronization process.  However, it allows the use of parallel execution mode, when it seemed that it was possible to act only consistently. <br><br><h5>  3.2.3.  Service Manager </h5><br>  The service manager provides systems with access to functions of other systems that otherwise would not be available to them.  It is important to understand that access to functions is done through interfaces, and not directly.  Information about system interfaces is also stored in the service manager. <br>  To eliminate system dependencies from each other, each of them has only a small set of services.  In addition, the ability to use a particular service is not determined by the system itself, but by the service manager. <br><br><img src="https://habrastorage.org/files/b2d/b9b/5ed/b2db9b5ed5124247a5e15aef042759ee.jpg"><br>  <i>Figure 8. Sample service manager</i> <br><br>  The service manager has another function.  It provides systems with access to the properties of other systems.  Properties are specific values ‚Äã‚Äãof specific systems that are not transmitted in the messaging system.  This may be an extension of the screen resolution in the graphics system or the magnitude of gravity in the physical.  The service manager provides systems with access to such data, but does not allow direct control over them.  It puts the property changes in a special queue and publishes them only after successive execution.  Please note that access to the properties of another system is rarely required and should not be abused.  For example, it may be necessary to enable or disable the frame grid mode in the graphics system from the console window or to change the screen resolution for a player's request from the user interface.  This feature is mainly used to set parameters that do not change from frame to frame. <br><br><h5>  3.2.4.  Environment manager </h5><br><ul><li>  The environment manager provides an engine runtime environment.  Its functions can be divided into the following groups. </li><li>  Variables: the names and values ‚Äã‚Äãof common variables used by all parts of the engine.  Usually, the values ‚Äã‚Äãof variables are determined when loading a scene or certain user settings.  The engine and various systems can access them by sending an appropriate request. </li><li>  Execution: information about the execution, such as the completion of a scene or program.  These parameters can set and request both the systems themselves and the engine. </li></ul><br><h5>  3.2.5.  Platform manager </h5><br>  The platform manager implements an abstraction for calls to the operating system, and also provides additional functionality besides simple abstraction.  The advantage of this approach is the encapsulation of several typical functions within a single call.  That is, they do not have to be implemented separately for each caller, overloading it with details about the OS calls. <br>  Consider as an example a call to the platform manager to load the system dynamic library.  It not only loads the system, but also receives the function entry points and calls the library initialization function.  The manager also stores the library descriptor and unloads it after the engine is completed. <br><br>  The platform manager is also responsible for providing information about the processor, for example, supported SIMD instructions, and for initializing a specific mode of operation of processes.  The system cannot use other query functions. <br><br><h2>  <font color="#0071c5">4. Interfaces</font> </h2><br>  Interfaces are the means of interaction between the framework, managers and systems.  The framework and managers are part of the engine, so they can interact with each other directly.  Systems to the engine do not apply.  Moreover, they all perform different functions, which leads to the need to create a single method of interaction with them.  Since systems cannot interact with managers directly, they need to provide another way of access.  However, not all functions of managers should be open to systems.  Some of them are available only to the framework. <br><br>  Interfaces define a set of functions required to use the standard access method.  This eliminates the need for the framework to know the implementation details of specific systems, since it can interact with them only through a specific set of calls. <br><br><h4>  4.1.  Subject and Observer Interfaces </h4><br>  The main purpose of the subject and observer interfaces is to register how to send observers notifications about which subjects, as well as sending such notifications.  Registration and disconnection with the observer are standard functions for all subjects included in the implementation of their interface. <br><br><h4>  4.2.  Manager Interfaces </h4><br>  Managers, despite being singleton objects, are directly accessible only to the framework.  Other systems can access managers only through interfaces that represent only a fraction of their overall functionality.  After initialization, the interface is transferred to the system, which uses it to work with certain functions of the manager. <br>  There is no single interface for all managers.  Each of them has its own separate interface. <br><br><h4>  4.3.  System interfaces </h4><br>  In order for the framework to access the components of the system, it needs interfaces.  Without them, the support of each new engine system would have to be implemented separately. <br>  Each system includes four components, so there should be four interfaces.  Namely: the system, the scene, the object and the task.  For a detailed description, see section 5, ‚ÄúSystems‚Äù.  Interfaces are the means of gaining access to components.  System interfaces allow you to create and delete scenes.  The scene interfaces, in turn, allow you to create and destroy objects, as well as request information about the main task of the system.  The task interface is mainly used by the task manager when setting tasks to the thread pool. <br>  Since the scene and the object, as parts of the system, must interact with each other and with the universal scene and the object to which they are attached, their interfaces are also created on the basis of the subject and the observer interfaces. <br><br><h4>  4.4.  Change Interfaces </h4><br>  These interfaces are used to transfer data between systems.  All systems that perform changes of a particular type must implement such an interface.  An example is the geometry.  The geometry interface includes methods for determining the position, orientation and scale of an element.  Any system that makes changes to the geometry must implement such an interface that information about other systems is not required to access the modified data. <br><br><h2>  <font color="#0071c5">5. Systems</font> </h2><br>  Systems are part of the engine, which is responsible for the implementation of gaming functionality.  They perform all the basic tasks, without which the engine would have no meaning.  The interaction between the engine and systems is carried out using interfaces (see Section 4.3, ‚ÄúSystem Interfaces‚Äù).  This is necessary in order not to overload the engine with information about various types of systems.  Thanks to the interfaces, the process of adding a new system becomes much easier, because the engine does not need to take into account all the implementation details. <br><br><h4>  5.1.  Types </h4><br>  The engine system can be divided into several predefined categories that correspond to the standard components of the game.  For example: geometry, graphics, physics (collision of solids), sound, input data processing, AI and animation. <br>  Systems with non-standard features fall into a separate category.  It is important to understand that any system that changes data of a specific category must be aware of the interface of this category, since the engine does not provide such information. <br><br><h4>  5.2.  System components </h4><br>  For each system it is necessary to implement several components.  Here are some of them: system, scene, object and task.  All these components are used to interact with different parts of the engine. <br>  The diagram below shows the interactions between the various components. <br><br><img src="https://habrastorage.org/files/93f/61e/a2e/93f61ea2eb16474d90ef34eec29e4ffb.jpg"><br>  <i>Figure 9. System components</i> <br><br>  A detailed diagram of the connections between the engine systems is given in Appendix B, "The scheme of interaction between the engine and systems." <br><br><h5>  5.2.1.  System </h5><br>  The ‚Äúsystem‚Äù component, or simply the system, is responsible for the initialization of system resources, which will practically not change during the engine operation.  For example, the graphics system analyzes the addresses of resources to determine their location and speed up loading when using a resource.  It also sets the screen resolution. <br>  The system is the main entry point for the framework.  It provides information about itself (for example, the type of system), as well as methods for creating and deleting scenes. <br><br><h5>  5.2.2.  Scene </h5><br>  The scene component, or system scene, is responsible for managing the resources that belong to the current scene.  The universal scene uses system scenes to extend functionality through the use of their functions.  As an example, we can take the physical scene, which is used when creating a new game world and when initializing a scene, determines the gravity forces in it. <br>  The scenes provide methods for creating and destroying objects, as well as the ‚Äútask‚Äù component for processing the scene and the method for accessing it. <br><br><h5>  5.2.3.  An object </h5><br>  The ‚Äúobject‚Äù component, or system object, belongs to the scene and is usually associated with what the user sees on the screen.  A universal object uses a system object to extend its functionality, providing its properties as its own. <br>  An example would be the geometric, graphical, and physical expansion of a universal object to display a wooden beam on the screen.  Geometric properties will include the position, orientation and scale of the object.  To display it, the graphics system will use a special grid.  A physical system will endow it with the properties of a solid to calculate interactions with other bodies and the acting forces of gravity. <br><br>  In certain cases in the system object it is necessary to take into account changes in the universal object or one of its extensions.  For this purpose, you can create a special link that allows you to track changes made. <br><br><h5>  5.2.4.  Task </h5><br>  The task component, or system task, is used to process the scene.         .         . <br>      ,            .        .     . <br>            .      .   3.2.2. <br><br><h2> <font color="#0071c5">6.   </font> </h2><br>            .        ,    . <br><br><h4>  6.1.   </h4><br>        . <br><ul><li>    . </li><li> ,     ,        . </li><li>          ,       . </li><li>       ,    . </li><li>     ,    . </li></ul><br><br><img src="https://habrastorage.org/files/248/36d/1e2/24836d1e2ef44f7ca389e9900d8c3f73.jpg"><br> <i> 10.     </i> <br><br><h4>  6.2.    </h4><br>   ,   . <br><ul><li>    .     ,    ,    . </li><li>   ,               . </li><li>  ,         ,        . </li><li>        ,  ,      .         ,    .     . </li><li>                 . </li><li>          ,         . </li></ul><br><br><img src="https://habrastorage.org/files/d0a/c7e/abe/d0ac7eabeb044fb187905dd9f2cefc77.jpg"><br> <i> 11.     </i> <br><br><h4> 6.3.    </h4><br><ul><li>          ,     . </li><li>    ,    ,   . </li><li>         ,    .    (    )   . </li><li>  ,       ,    . </li><li>          .         . </li></ul><br><br><h5> 6.3.1.   </h5><br>    . <br><ul><li>       , ,     ,   . (       .              ,     .) </li><li>              ,    . </li><li>          (,   ).             .         ,     . </li><li>          .   ,     . </li><li>    ,     .        ,        (,       ‚Äî   ). </li><li>                 ( ,      .). </li></ul><br><br><img src="https://habrastorage.org/files/df7/fcd/fc9/df7fcdfc9e104682bc5bc557fbe97cba.jpg"><br> <i> 12.    </i> <br><br><h5> 6.3.2.   </h5><br>             ,     . <br><ul><li>             .  ,          . </li><li>           (        ).            ,             . </li><li>  ,        ,    ,        .         ,    .    ,          . </li></ul><br><br><h5> 6.3.3.     </h5><br>          .    : , ,    . .    ¬´¬ª,     .  ¬´¬ª    ,      .     ,  ¬´¬ª, ¬´ ¬ª  . <br><br><h2> <font color="#0071c5">7. </font> </h2><br>        2, ¬´  ¬ª.            ,           .     ,      ,         . <br><br>  ¬´¬ª ‚Äî     .      ,        .       ,     . <br><br>        .   D          . <br><br>  ,             .           . <br><br><h2> <font color="#0071c5"> A.  </font> </h2><br>        (. . 4, ¬´  ¬ª). <br><br><img src="https://habrastorage.org/files/21c/3ef/9b6/21c3ef9b6b284c6f94b71fe648ae76f1.jpg"><br><br><h2> <font color="#0071c5"> B.     </font> </h2><br><br><img src="https://habrastorage.org/files/e60/10f/e01/e6010fe012024a63902c58117890ddb0.jpg"><br><br><h2> <font color="#0071c5"> C.  ( )</font> </h2><br>  ¬´¬ª     ¬´ - .  ¬ª, . , . , . , .  (¬´Design Patterns: Elements of Reusable Object-Oriented Software¬ª, Gamma E., Helm R., Johnson R., Vlissides J.).         1995   Addison-Wesley. <br><br>       :  -        ,        ,      .      ,       .     .           .     . <br><br><img src="https://habrastorage.org/files/3b0/cba/a5b/3b0cbaa5bea240559d3c0637b49698c8.jpg"><br> <i> 13.  ¬´¬ª</i> <br><br>      . <br><ol><li>      ,      . </li><li>     .         .            . </li><li>    (   )    ,       .     ,  ,      .        . </li><li>    ,             . </li><li>                 . </li><li>         . </li><li>           (     ). </li><li>             ,         . </li></ol><br><br><h2> <font color="#0071c5"> D.    </font> </h2><br>       .             .       .        .              .    ,    ,  <a href="https://www.threadingbuildingblocks.org/">Threading Building Blocks</a>  Intel. <br><br>       ,      .    . <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reverse feed. </font><font style="vertical-align: inherit;">If the order of the main tasks practically does not change, for each next frame they can be assigned in the reverse order. </font><font style="vertical-align: inherit;">It is highly likely that the data from the last task performed in the previous frame is still in the cache. </font><font style="vertical-align: inherit;">That is, performing tasks in reverse order eliminates the need to overwrite the data in the CPU cache.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shared cache: in some multi-core processors, the cache is divided into sections. </font><font style="vertical-align: inherit;">Thus, one pair of processors can use one part of the common cache, and the other - the other. </font><font style="vertical-align: inherit;">Such a model increases the likelihood that when assigning subtasks to the same system, the necessary data will already be in the shared cache.</font></font></li></ul></div><p>Source: <a href="https://habr.com/ru/post/266427/">https://habr.com/ru/post/266427/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266415/index.html">Protection of corporate applications: how to become a developer of PT Application Firewall</a></li>
<li><a href="../266417/index.html">Release it! Software design and design for those who care</a></li>
<li><a href="../266419/index.html">Organization of monitoring the work of employees in a small office</a></li>
<li><a href="../266421/index.html">How a month to get a lot of pumping in Data Science</a></li>
<li><a href="../266425/index.html">Magnetic core memory module in an IBM 1401 vintage mainframe</a></li>
<li><a href="../266429/index.html">Joint editing. Part 2</a></li>
<li><a href="../266431/index.html">Extortionist Android / Lockerpin.A attacks US users</a></li>
<li><a href="../266433/index.html">Developing a metamodel using the Eclipse Modeling Framework (and a little about data modeling)</a></li>
<li><a href="../266435/index.html">How to learn to make games: useful resources</a></li>
<li><a href="../266437/index.html">Says Gartner: Overheated IoT and Practical Clouds</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>