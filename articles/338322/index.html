<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Autopilot with your hands. We add electronic control steer-by-wire to a regular car</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. Any autopilot obviously needs to not only make management decisions, but also make the car obey these decisions. Today we will see how to modif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Autopilot with your hands. We add electronic control steer-by-wire to a regular car</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello.  Any autopilot obviously needs to not only make management decisions, but also make the car obey these decisions.  Today we will see how to modify the usual car with a fully electronic steering system (steer-by-wire) using very affordable means.  It turns out that the car itself is not very necessary for development, and most of the functionality can be easily debugged at home or in the office.  Starring the well-known components from hobby electronics stores. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7dd/74a/1ab/7dd74a1ab89e63bc46e65872700f1416.jpg" alt="Electronics Assembly"></p><a name="habracut"></a><br><p>  Think for a second, what is needed for an electronic control system?  A servo that can turn the wheels and a controller to control the servo.  Suddenly, all this is already in most modern cars, and is called "power steering".  Traditional purely mechanical (usually hydraulic) amplifiers are rapidly disappearing from the market, giving way to nodes with an electronic control unit (ECU).  So, the task is immediately simplified: we can only ‚Äúpersuade‚Äù the existing amplifier ECU to issue the necessary commands to the servo. </p><br><p>  KIA Cee'd from the 2015 model year turned out to be very convenient for refinement (most likely, its co-platform from KIA / Hyundai is most likely the same).  Several factors agreed at the same time: </p><br><ul><li>  The power steering is fully electric, there is no fuss with hydraulics, it costs a penny (relatively) on disassembly.  All necessary wiring is brought out and easily accessible. </li><li>  The amplifier is integrated with the steering column, so there is easy access to it by car and any additional electronics will remain in the cabin in greenhouse conditions (as opposed to amplifiers integrated into the steering rack). </li><li>  It is very important - there is an example of successful completion of a similar KIA Soul.  American <a href="https://polysync.io/">PolySync is</a> developing an upgrade from Soul to a fully drive-by-wire <a href="http://oscc.io/">platform for UAVs</a> , and you can see a <a href="https://github.com/PolySync/OSCC/wiki">lot of useful things</a> on <a href="https://github.com/PolySync/OSCC">their githaba</a> . </li></ul><br><p>  So, obtained at the disposal of the steering column assembly: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7de/ac6/661/7deac6661d3de1428804afb1a0c57743.jpg" alt="KIA Cee'd JD steering column"></p><br><p>  We will make it spin.  To do this, create an impression on the control unit that </p><br><ol><li>  He is in a car with a running engine. </li><li>  The driver applies the rotational force to the steering wheel. </li></ol><br><p>  Let's go in order. </p><br><h1 id="simulyaciya-avtomobilya">  Car simulation </h1><br><p>  It is necessary to understand the interface between the electronic control unit (ECU) of the amplifier and the rest of the car.  Googling <a href="http://kiaceed2.ru/html/elektrousilitel.html">electrical circuit</a> see the picture: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/44d/25d/488/44d25d48830bf05c06d8c44e85405fc1.png" alt="Interface KEU KIA Cee'd"></p><br><p>  From the diagram it is clear that the physical interface is very simple: </p><br><ul><li>  Power supply (12V constant) via E29 connector. </li><li>  Ignition on signal (12V) via connector M46. </li><li>  CAN data bus also via connector M46. </li></ul><br><p>  Appearance and pinout connectors find on the same site. </p><br><p>  With power and ignition, everything is simple, we take 12V from a conventional computer power supply.  But if you simply apply power and ignition, the amplifier will not fully turn on and will not be amplified.  Additionally, information is needed from other car units: whether the engine is working (so as not to waste battery energy when it is turned off), the current speed (to make the steering wheel "harder" at speed), surely something else. </p><br><p>  Data exchange between electronic units in modern cars is organized on <a href="https://ru.wikipedia.org/wiki/Controller_Area_Network">CAN</a> buses <a href="https://ru.wikipedia.org/wiki/Controller_Area_Network">(Controller Area Network)</a> .  This is a broadcast (packets have no destination addresses) local network on a twisted pair, where each unit can publish its data.  Each data type has its own identifier.  For example, in our case, the power steering sends the values ‚Äã‚Äãof the steering angle with ID 0x2B0.  Often there are several physically separated tires so that minor blocks such as window regulators do not interfere with the exchange between critical components.  Cee'd uses two buses: C-CAN and B-CAN (the <a href="http://kiaceed2.ru/html/hod-ogni.html">diagram is here</a> , in the section "Information about the data transmission channel").  Almost all the blocks with it hang on the C-CAN and we will work. </p><br><h2 id="vybor-adaptera-can-shiny">  CAN bus adapter selection </h2><br><p>  First of all, you need a CAN interface for a computer.  There is a detailed overview of possible solutions <a href="https://makezine.com/2016/04/08/car-hacking-tools-trade/">here</a> , <a href="https://makezine.com/2016/04/08/car-hacking-tools-trade/">for example</a> , prices range from tens to hundreds of dollars.  On devices we have relatively available: </p><br><ol><li>  Adapters <a href="https://ru.aliexpress.com/item/usb-to-serial-adapter-can-USB-to-CAN-CAN-CAN-turn-turn-CAN-232-to-232/32425298401.html">assembled with aliexpress</a> .  They did not try, according to rumors quite a lot of marriage and software apparently only under Windows. </li><li>  Arduino shields on the MCP2515 / MCP2551, mostly <a href="http://wiki.seeed.cc/CAN-BUS_Shield_V1.2/">design</a> clones <a href="http://wiki.seeed.cc/CAN-BUS_Shield_V1.2/">from seeed</a> in any shop on the subject.  But it is necessary to combine such a shield <strong>not with the Arduino</strong> (I could not get the bundle to work at playback at the desired speed), but with the Raspberry Pi.  See the appendix below for <a href="https://habr.com/ru/post/338322/">detailed instructions</a> . </li><li>  USB adapter <a href="http://canhacker.ru/%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D1%258B/can-hacker-baby/">CANHacker Baby</a> , development <a href="https://habrahabr.ru/users/artemka86/" class="user_link">Artemka86</a> .  Favorably differs from the options with aliexpress with excellent support "first-hand" from the developer (tested personally, Artem approaches the matter with the soul).  Also a plus is the support of the standard LAWICEL protocol compatible with a wide range of software. </li></ol><br><p> There is also a lot of software ( <a href="https://makezine.com/2016/04/08/car-hacking-tools-trade/">for review here again</a> ).  The easiest option is Linux c <code>can-utils</code> from <a href="https://en.wikipedia.org/wiki/SocketCAN">SocketCAN</a> , for which thanks to the Volkswagen engineers.  SocketCAN is a big plus in standardization - any USB device with support <a href="http://www.can232.com/docs/can232_v3.pdf">for the LAWICEL protocol (pdf)</a> is seen by the system as a normal network interface.  Thus, we avoid binding to the vendor-specific software of a specific device.  The current version of CANHacker has a slight incompatibility with the can-utils runtime for working with USB, so we take the <a href="https://github.com/waiwnf/can-utils">patched version from here</a> .  Raspberry Pi with CAN Shield works with the can-utils stock package from Raspbian OS without problems. </p><br><h2 id="podklyuchenie-k-shine-zapis-paketov">  Bus connection, packet writing </h2><br><p>  With the connection to the individual node on the stand, everything is simple: we connect the CAN-High contact of the adapter with the CAN-High of the vehicle node, CAN-Low - with CAN-Low.  According to the standard, between CAN-High and CAN-Low there should be 2 closing resistors of 120 Ohm each, in practice everything usually works on a rather wide resistance range, for example, I have one 110 Ohm. </p><br><p>  On the car, the closing resistor is not needed (they are already there, so that the bus itself works).  Depending on the model of car, you may have to tinker with the physical access to the bus wiring.  The most convenient option is the <a href="https://en.wikipedia.org/wiki/On-board_diagnostics">OBD-II</a> connector <a href="https://en.wikipedia.org/wiki/On-board_diagnostics">(on-board diagnostic)</a> , it is mandatory on all cars produced in Europe from 2001-2004 and located no more than 60 cm from the steering wheel.  On the Cee'd connector to the left under the steering wheel, behind the plastic cover of the fuse box. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bd8/40e/fce/bd840efce5cfbe3188c8d5995417badc.jpg" alt="Diagnostic connector OBD-II KIA Cee'd"></p><br><p>  The OBD-II pinout is standardized and includes a CAN bus (CANH on pin 6, CANL on 14).  We were lucky, the Koreans took the path of least resistance and brought out the C-CAN, on which all the important nodes hang, directly to the diagnostic connector: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9f/b26/e96/e9fb26e96be4cf30c3c6d09f02e88c2a.png" alt="Gateways? No, not heard."></p><br><p>  As a result, you can listen to all the internal traffic on Cee'd, without disassembling anything in the car.  When the car is not yours, and friends let you tinker - a big plus.  But such a freebie is not everywhere.  In Volkswagen, for example, the service CAN is isolated from the OBD by the gateway, so you would have to connect like this: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9b/0f7/b2f/a9b0f7b2f45e283bf3b3599b57589a6f.jpg" alt="Connecting to the service CAN bus on Skoda Ostavia through the connector of the control unit transmission."></p><br><p>  Having connected all the contacts, we raise the network interface: </p><br><pre> <code class="bash hljs">$ sudo slcand -o -c -s6 -S 115200 ttyACM0 slcan0 &amp;&amp; sleep 1 &amp;&amp; sudo ifconfig slcan0 up</code> </pre> <br><p>  Check that the network is working and data is being received (by turning on the ignition): </p><br><pre> <code class="bash hljs">$ cansniffer slcan0</code> </pre> <br><p>  And finally, if everything is fine, you can write a log: </p><br><pre> <code class="bash hljs">$ candump -L slcan0 &gt; real-car-can-log.txt</code> </pre> <br><p>  Here you need to start the engine, because  the power steering is turned on for the actual gain only when the engine is running, and we need to stand on the stand to increase it. </p><br><h2 id="vosproizvedenie-zapisi-shiny-na-stende">  Playback tire recording on stand </h2><br><p>  With the recorded log from the car, you can go back to the stand and start the deception of our lonely amplifier.  First of all, let us remember that the car has its own amplifier, it also sends data to the CAN bus, and these packets are also in our log.  We filter them to avoid conflicts.  Connect to the amplifier on the stand, see what it gives out: </p><br><pre> <code class="bash hljs">$ $ candump slcan0 slcan0 2B0 [5] 00 00 00 00 00 slcan0 2B0 [5] FF 7F FF 06 F1 slcan0 2B0 [5] FF 7F FF 06 C2 slcan0 2B0 [5] FF 7F FF 06 D3 slcan0 2B0 [5] FF 7F FF 06 A4 slcan0 2B0 [5] FF 7F FF 06 B5 slcan0 2B0 [5] FF 7F FF 06 86 slcan0 2B0 [5] FF 7F FF 06 97 slcan0 2B0 [5] FF 7F FF 06 68 slcan0 5E4 [3] 00 00 00 slcan0 2B0 [5] FF 7F FF 06 79 slcan0 2B0 [5] FF 7F FF 06 4A ....</code> </pre> <br><p>  We see that <code>2B0</code> packets (the current steering angle) and, less commonly, <code>5E4</code> (some kind of general amplifier status) are sent.  Filter them from the common log: </p><br><pre> <code class="bash hljs">$ cat real-car-can-log.txt | grep -v <span class="hljs-string"><span class="hljs-string">' 2B0'</span></span> | grep -v <span class="hljs-string"><span class="hljs-string">' 5E4 '</span></span> &gt; can-log-no-steering.txt</code> </pre> <br><p>  Filtered log can be submitted for playback: </p><br><pre> <code class="bash hljs">% sudo ifconfig slcan0 txqueuelen 1000 $ canplayer -I can-log-no-steering.txt</code> </pre> <br><p>  If everything worked out successfully, the amplifier will work, turning the steering shaft with your hand will become much easier.  So, we made the knot work in normal mode, we can proceed to the simulation of efforts on the steering wheel. </p><br><h1 id="emulyaciya-usiliya-na-rule">  Emulation effort on the steering wheel </h1><br><p>  Torque on the steering shaft and the angle of rotation is measured by the built-in sensor unit, from which the wiring harness goes to the amplifier control unit: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bbf/c47/4fd/bbfc474fd6022a221a34a30fdd770369.jpg" alt="Wires to the sensors of the steering angle and torque on the steering shaft."></p><br><p>  The control unit processes the sensor signals and commands the servo to create additional effort to turn the steering shaft. </p><br><h2 id="proverka-formata-signala-datchikov">  Check sensor signal format </h2><br><p>  According <a href="https://github.com/PolySync/oscc/wiki/Steering">to PolySync</a> , the Soul, which has a common platform with Cee'd, has two analog torque sensors.  The signal of each is the deviation of the DC voltage level from the base 2.5V, the wires in the harness are green and blue.  Check that we have the same thing: </p><br><ul><li>  We disconnect the connector on the computer, we forward the necessary contacts through the layout and we get to the analog inputs of the arduino. </li></ul><br><p><img src="https://habrastorage.org/getpro/habr/post_images/10c/69e/e1e/10c69ee1e8809ae04925ce5304e7d824.jpg" alt="Who said the collective farm ?!"></p><br><ul><li>  We load the <a href="https://github.com/waiwnf/pilotguru/tree/master/sketches/voltmeter">sketch</a> , in a cycle measuring tension and printing them in the terminal. </li><li>  We start Serial Plotter in Arduino IDE, we turn a steering shaft.  We see the result on the graph, the scheme coincides with Soul: <br><img src="https://habrastorage.org/getpro/habr/post_images/c2f/b7f/701/c2fb7f701b27a043223ab83cf070a7ed.png" alt="Voltage plot from torque force sensors on the steering shaft."></li><li>  We rejoice at the time saved. </li></ul><br><h2 id="emulyaciya-signala-datchikov">  Sensor signal emulation </h2><br><p>  Go to the emulation of the sensor signal.  To do this, we put our module in the open circuit between the sensor and the computer, we will transmit the real signal from the sensor and, on command, shift it to a fixed level (depicting the force applied to the steering column).  With the help of one arduino, this will not work: there is no full-fledged digital-to-analog converter, which could produce a constant voltage.  The analog inputs of the arduino are not very suitable for us either - although there are only 6 pins for them, the ADC channel in the controller is only one, and switching between pins takes considerable time. </p><br><p>  It is necessary to add an external DAC / ADC to the arduino.  I came across the YL-40 modules ( <a href="http://imrad.com.ua/userdata/modules/wproducts/wprod_products/135743/Arduino%2520YL-40.pdf">described in pdf</a> ) based on the <a href="https://www.nxp.com/docs/en/data-sheet/PCF8591.pdf">PCF8591</a> chip - each with 4 channels of 8-bit ADC and 1 8-bit DAC.  The module can communicate with arduino <a href="https://ru.wikipedia.org/wiki/I%25C2%25B2C">via I2C protocol</a> .  It will take a little dopilivanie (literally): the Chinese comrades put on the board the LED indicating the voltage at the DAC output - it <strong>must</strong> be disconnected.  Otherwise, the current flowing through the diode will not allow the DAC to raise the voltage at the output to more than 4.2V (instead of the standard 5V).  Diode disconnect, otkovyrivaya resistor R4 on the back of the board. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fc9/6ee/2f5/fc96ee2f5cd720f9e00508b9ba89cf76.jpg" alt="YL-40 disconnect the diode from the output of the DAC"></p><br><p>  Also, the inputs are soldered toy loads (thermistor, photoresistor, something else), disconnect them, removing the jumpers, so as not to interfere. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b7d/28e/cb7/b7d28ecb76e7ffa79a53d5821c04d046.jpg" alt="YL-40 remove jumpers"></p><br><p>  With the interface to the arduino there is a nuance - we need 2 DAC channels, respectively 2 modules, but they have the same I2C addresses (they are embedded in the chip).  Although the chip allows you to change your I2C address, closing certain legs to + 5V instead of ground, these jumpers on the board are not divorced.  Instead of soldering, take a crutch - two different I2C libraries on arduino (standard Wire and <a href="https://github.com/felias-fogg/SoftI2CMaster">SoftI2CMaster</a> ), each for its own pair of pins.  We get modules on different tires, the conflict disappears. </p><br><p>  The rest is straightforward - we put the modules in the open circuit from the sensors, connect them to the arduino, load the <a href="https://github.com/waiwnf/pilotguru/tree/master/sketches/steering-fixed-torque">sketch</a> .  Details on the pinout of the connection are in the comments in the sketch.  It remains to include everything in the collection, the <strong>sequence is important</strong> here: </p><br><ol><li>  Turn on arduino, open Serial Monitor.  It is important to start arduino first, do not stop or interrupt.  Otherwise, the voltage at the outputs of the DACs will reset, the amplifier's ECU will detect the signal error from the sensors, go to a safe environment and have to restart all over again. </li><li>  We power the amplifier, we connect the ignition. </li><li>  We start playback of the CAN-bus log. </li><li>  Now, at the <code>l</code> and <code>r</code> commands, the amplifier will turn the steering shaft through the Serial Monitor.  Victory is declared. </li></ol><br><iframe width="560" height="315" src="https://www.youtube.com/embed/s84M3_18pmI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Today, everything is in line with software development (integration with the CAN bus, reading the current angle of rotation and dynamic torque control from there, so that the external controller can set a fixed angle of rotation of the steering wheel and the system can withstand it), testing the vehicle (you cannot simulate resistance from wheels).  It is possible to replace 8-bit DAC / ADC with 10 or 12 bits (I took the first one that came to hand).  The steering network is also in the process, I hope to make a post soon. </p><br><p>  Thanks <a href="https://habrahabr.ru/users/artemka86/" class="user_link">Artemka86</a> for valuable advice on working with CAN and help with the equipment. </p><br><h2 id="resursy-dlya-dalneyshego-pogruzheniya">  Resources for further immersion </h2><br><ol><li>  <a href="http://illmatics.com/carhacking.html">Car Hacking: The definitive source</a> .  You can start with <a href="http://illmatics.com/car_hacking_poories.pdf">Car Hacking for Poories</a> , there are well covered bases.  The rest is also interesting, but with an emphasis on unauthorized access. </li><li>  <a href="http://opengarages.org/handbook/ebook/">The Car Hacker's Handbook: A Guide for the Penetration Tester</a> .  More details than in Car Hacking: The definitive source, also an emphasis on unauthorized access.  If you read as the first introduction to the topic, you need to adapt to skip large chunks. </li><li>  <a href="https://makezine.com/2016/04/08/car-hacking-tools-trade/">Car Hacking 101: Tools of the Trade</a> , <a href="http://opengarages.org/index.php/MCD_software">MCD Software</a> - Tool Reviews.  Mostly uninteresting exotic in my opinion. </li><li>  <a href="https://github.com/PolySync/OSCC/">Open Source Car Control</a> is an open source platform for KIA Soul, under development.  They make a complete solution (steering wheel, accelerator, brakes), turning on the hardware on the car (mainly for brakes - additional brake drives are put, something changes in brake hydraulics, etc.).  There was no release yet, but many things are already visible. </li></ol><br><br><h1 id="bonus-sovmeschaem-raspberry-pi-i-arduino-can-shield">  Bonus  Combine Raspberry Pi and Arduino CAN shield </h1><br><p>  First of all, attention, <strong>CAN Shield and raspberry pi cannot be connected directly</strong> , they are not voltage compatible.  On Arduino UNO-compatible boards, the logic voltage is 5V, and on a raspberry pi only 3.3V, so a direct connection will only burn the pins involved. </p><br><p>  We will need: </p><br><ul><li>  Raspberry Pi (tested on version 3B). </li><li>  Arduino CAN Shield on MCP2515 / MCP2551. </li><li>  A logic level converter for 5 channels or more (2 to 4 channels are possible, but more connections will be needed).  I <a href="https://tpai.ru/preobrazovateli-elektricheskogo-toka/344-preobrazovateli-elektricheskogo-toka-universalnyy-dvunapravlennyy-8-mi-kanalnyy-preobrazovatel-urovney-33v-5v-spi-i2c-uart-i-dr-.html">got this</a> </li></ul><br><p>  It is necessary to power the CAN shield (5V), <a href="https://ru.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI data interface connections</a> (4 pins: MOSI, MISO, SCLK, CS) and 1 pin of the interrupt signal.  Everything, except power supply, goes through a level converter, which in turn also needs to be powered. </p><br><p>  On the schemes we are looking for the necessary pins. </p><br><p>  Raspberry Pi: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/931/a2d/779/931a2d779681862c5ebecb126316b998.png" alt="Raspberry Pi pinout"></p><br><p>  CAN Shield: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bdb/295/1ba/bdb2951baae935eb524c511439e5af31.png" alt="Can shield pinout"></p><br><p>  We get the result: </p><br><ul><li>  SPI on raspberry pi 19, 21, 23, 24 (MOSI, MISO, SCLK, CS) correspond to D11, D12, D13, D9 (or on some versions of D10) on the CAN label. </li><li>  Interruption from D2 on the shield can be made on any GPIO pin raspberry, I have it pin 22 (GPIO 25).  Pin number will indicate in the software when setting up. </li></ul><br><p>  We connect through the converter, we get the necessary supply voltage on each side of the converter, it turns out such noodles: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cf0/a6c/fa8/cf0a6cfa8ff18690aa90cc1db4c9c691.jpg" alt="Raspberry Pi + Arduino CAN shield"></p><br><p>  Everything except 5V power and ground to the shield goes through the converter: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/328/ee4/4bc/328ee44bccdaeb9b8ee04c50b034314b.jpg" alt="RPi - CAN shield converter connections labeled"></p><br><p>  Go to setting up the software (standard Raspbian). </p><br><ol><li><p>  We include support for SPI and CAN module.  Add to <code>/boot/config.txt</code> </p><br><pre> <code class="bash hljs">dtparam=spi=on dtoverlay=mcp2515-can0,oscillator=16000000,interrupt=25,spimaxfrequency=1000000 dtoverlay=spi0-hw-cs</code> </pre> <br><p>  Here <code>interrupt=25</code> indicates the pin, which interrupted with Shield.  Indexing goes on GPIO pins, so <code>interrupt=25</code> is GPIO 25, it‚Äôs also pin 22 for end-to-end indexing of all pins.  It is also important to indicate the frequency of the SPI interface <code>spimaxfrequency</code> , since  the default is 10 MHz - too high for the shield, it just won't connect. </p><br></li><li><p>  Reboot the raspberry pi, check the connection with the shield: </p><br><pre> <code class="bash hljs">$ dmesg ... [ 12.985754] CAN device driver interface [ 13.014774] mcp251x spi0.0 can0: MCP2515 successfully initialized. ...</code> </pre> <br></li><li><p>  Install <code>can-utils</code> : </p><br><pre> <code class="bash hljs">$ sudo apt install can-utils</code> </pre> <br></li><li><p>  We start the virtual network interface: </p><br><pre> <code class="bash hljs">$ sudo /sbin/ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> can0 up <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> can bitrate 500000 $ sudo ifconfig can0 txqueuelen 1000</code> </pre> <br><p>  The second command is important when playing a large amount of data from a raspberry pi, that is, when a full CAN bus log is recorded on the car, it is reproduced for an isolated node on the stand.  Without an increase in the buffer, it is likely to overflow when there are several CAN packets in the log at small intervals, and then the connection hangs. </p><br></li><li>  Done, you can use <code>candump</code> , <code>cansniffer</code> and everything else from <code>can-utils</code> . </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/338322/">https://habr.com/ru/post/338322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338308/index.html">How to divide one instructor into all, so that everyone gets two. Best practice in IT training</a></li>
<li><a href="../338312/index.html">Safari 11 and WebRTC: the pitfalls of video calls</a></li>
<li><a href="../338314/index.html">Mobile Steam Survival Guide for Mobile Developers</a></li>
<li><a href="../338318/index.html">Futures, indices and IPOs: how exchanges really work and why they are needed</a></li>
<li><a href="../338320/index.html">What exactly is included in the concept of "blockchain"</a></li>
<li><a href="../338324/index.html">How to write an excellent scientific article on CS</a></li>
<li><a href="../338326/index.html">You bought a CRM. How to live with it?</a></li>
<li><a href="../338328/index.html">From marketer to software tester - change of profession after 40? Why not</a></li>
<li><a href="../338330/index.html">Solar JSOC analytics: how Russian companies are attacking</a></li>
<li><a href="../338332/index.html">Overview of GUI Interfaces for Managing Docker Containers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>