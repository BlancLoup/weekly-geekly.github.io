<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The history of one bug: the alignment of data on x86</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once I had to calculate the sum of the vectors of integers. 

 It sounds unusual. Who needs to do this in real life? Usually such calculations are fou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The history of one bug: the alignment of data on x86</h1><div class="post__text post__text-html js-mediator-article">  Once I had to calculate the sum of the vectors of integers. <br><br>  It sounds unusual.  Who needs to do this in real life?  Usually such calculations are found only in tasks from elementary school or compiler benchmarks.  But now it really happened. <br><br>  In reality, the task was to check the <a href="https://en.wikipedia.org/wiki/IPv4_header_checksum">checksum of IPv4 headers</a> , which is the sum of the reverse codes (additions to one) of double-byte machine words.  Simply put, it means adding all the words and all the carry bits that are produced in the process.  This procedure has several nice features: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> it can be efficiently executed using the <code>ADC</code> processor instruction (unfortunately, this feature is not available in C); </li><li>  it can be done on words of any size (you can add eight-byte values ‚Äã‚Äãif desired, only the result should be reduced to two bytes and all overflow bits should be added); </li><li>  it is insensitive to the byte order (surprisingly, but it is). </li></ul><a name="habracut"></a><br>  There was one important requirement: the source data was not aligned (IP frames are the same as they came from the equipment or read from the file). <br><br>  I didn‚Äôt have to worry about software portability, because the code had to work only on a single platform: Intel x64 (Linux and GCC 4.8.3).  Intel has no restrictions on the alignment of integer operands (access to unaligned data used to be slow, but not anymore), and since the byte order is not important, then the order of bytes from the youngest to the oldest will go down.  So I quickly wrote: <br><br><pre> <code class="cpp hljs">_<span class="hljs-function"><span class="hljs-function">Bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_ip_header_sum</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> * q = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *) p; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; sum += q[<span class="hljs-number"><span class="hljs-number">0</span></span>]; sum += q[<span class="hljs-number"><span class="hljs-number">1</span></span>]; sum += q[<span class="hljs-number"><span class="hljs-number">2</span></span>]; sum += q[<span class="hljs-number"><span class="hljs-number">3</span></span>]; sum += q[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">5</span></span>; i &lt; size / <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { sum += q[i]; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { sum = (sum &amp; <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>) + (sum &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sum &amp; ~<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>L); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum == <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>; }</code> </pre> <br>  The source code and the output of the assembler can be found in the <a href="https://github.com/pzemtsov/article-align-x86">repository</a> . <br><br>  The most common IP header size is 20 bytes (5 double words, which I will call just <i>words</i> ) ‚Äîthat is why the code looks that way.  In addition, the size can never be less - it is checked before calling this function.  Since an IP header cannot be more than 15 words, the number of loop iterations is from 0 to 10. <br><br>  This code is really not programmatically portable - it is known that accessing arbitrary memory using pointers to 32-bit values ‚Äã‚Äãdoes not work on some processors.  For example, on most RISC processors, if not at all.  But, as I said earlier, it was never supposed that this would create problems on x86. <br><br>  And of course (otherwise there wouldn‚Äôt be something to talk about here) the reality proved the opposite, and this code fell out with a SIGSEGV error. <br><br><h3>  Simplify </h3><br>  The failure occurred only when the loop was running, that is, the headers were longer than 20 bytes.  In real life, this happens very rarely, but I was lucky, because in my test dataset there were such headers.  Let's simplify our code just before this loop.  We write it on pure C and divide it into two files in order to avoid the built-in functions.  Here is our <code>sum.c</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;stdint.h&gt; uint64_t sum (const uint32_t * p, size_t nwords) { uint64_t res = 0; size_t i; for (i = 0; i &lt; nwords; i++) res += p [i]; return res; }</span></span></span></span></code> </pre> <br>  But <code>main.c</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; #include &lt;stdio.h&gt; extern uint64_t sum (const uint32_t * p, size_t nwords); char x [100]; int main (void) { size_t i; for (i = 0; i &lt; sizeof (x); i++) x [i] = (char) i; for (i = 0; i &lt; 16; i++) { printf ("Trying %d sum\n", (int) i); printf ("Done: %d\n", (int) sum ((const uint32_t*) (x + i), 16)); } return 0; }</span></span></span></span></code> </pre> <br>  Now SIGSEGV appeared on the function <code>sum</code> when <code>i</code> 1. <br><br><h3>  Investigation </h3><br>  The function code <code>sum</code> is surprisingly large, so I will show only the main loop. <br><br><pre> <code class="hljs perl">.L13: movdqa (%r8), %xmm2 addq $1, %rdx addq $16, %r8 cmpq %rdx, %r9 pmovzxdq %xmm2, %xmm1 psrldq $8, %xmm2 paddq %xmm0, %xmm1 pmovzxdq %xmm2, %xmm0 paddq %xmm1, %xmm0 ja .L13</code> </pre> <br>  The compiler is smart.  Too clever, as for me.  He applied the SSE instruction set (he was allowed to do this because I used it everywhere and specified <code>-msse4.2</code> on the command line. This code simultaneously reads four values ‚Äã‚Äã( <code>movdqa</code> ), then converts them into a 64-bit format in two registers ( two instructions <code>pmovzxdq</code> and <code>psrldq</code> ) and adds the current amount ( <code>%xmm0</code> ). After iterating the cycle, it adds the accumulated values ‚Äã‚Äãtogether. <br><br>  This looks like an acceptable optimization for the case when we are dealing with a lot of words, but this is not the case here.  The compiler did not have the opportunity to establish the typical number of iterations of the loop, so he optimized the code to the maximum, correctly reasoning that for a case with a small number of words, the losses from over-optimization would also be small.  We will check later what the losses are and how big they are. <br><br>  What in general in this code could cause an error?  We quickly realized that this is the <code>movdqa</code> instruction.  Like most SSE memory-access instructions, it requires a 16-byte alignment of the address of the source argument.  But we cannot expect such an alignment from the <code>uint32_t</code> pointer, and how, then, generally use this instruction? <br><br>  The compiler really cares about alignment.  Before starting the cycle, it calculates how many words can be processed before the cycle begins. <br><br><pre> <code class="hljs perl"> testq %rsi, %rsi ; %rsi is n je .L14 movq %rdi, %rax ; %rdi is p movq %rsi, %rdx andl $15, %eax shrq $2, %rax negq %rax andl $3, %eax</code> </pre> <br>  Or, in a more familiar form: <br><br><pre> <code class="hljs objectivec"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nwords == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> start_nwords = (- (((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)p &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>)) &amp; <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br>  It returns 0 if <code>p</code> ends with 0, 1, 2, or 3 in Hex, returns 3 if it ends with 4-7, returns 2 for the range 8 ‚àí B, and 1 for C ‚àí F.  After processing these first words, we can start a cycle (provided that the number of remaining words is at least 4, and taking care of the leftovers). <br><br>  In short, this code aligns the pointer to 16 bytes, <b>but on the condition that it is already aligned to 4</b> . <br><br>  Suddenly, our x86 behaves like RISC: it crashes with an error if the pointer to <code>uint32_t</code> not aligned to 4 bytes. <br><br><h3>  Simple solutions do not fit </h3><br>  No simple manipulation of this function solves the problem.  We could, for example, declare the parameter <code>p</code> as <code>char*</code> in a naive attempt to ‚Äúexplain to the compiler the arbitrary nature of the pointer‚Äù: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> sum0 (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * p, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nwords) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> * q = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *) p; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nwords; i++) res += q [i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br>  Or we can replace indexing with pointer arithmetic. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> sum01 (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> * p, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) res += *p++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br>  Or apply both methods. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> sum02 (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * p, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++, p += <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)) res += *(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *) p; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br>  None of these modifications helps.  The compiler is smart enough to ignore all syntactic sugar and reduce the code to the base.  All these versions crash with a SIGSEGV error. <br><br><h3>  What the standards say </h3><br>  This is like a rather dirty compiler trick.  The program transformation that it performs contradicts the programmer‚Äôs usual expectations for x86.  Is the compiler allowed to do this?  To answer this question, you have to look at the standard. <br><br>  I'm not going to dig deep into various <b>C</b> and <b>C ++ standards</b> .  We will see only one of them, namely <b>C99</b> , and more specifically, the <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">latest publicly available version of the standard C99 (2007)</a> . <br><br>  It presents the concept of leveling: <br><br><blockquote>  <b>3.2</b> <br>  <b>alignment</b> <br>  the requirement for objects of a certain type to be located on the borders of memory elements with addresses multiple of the byte address </blockquote><br>  This concept is used in defining a pointer mapping. <br><br><blockquote>  <b>6.3.2.3</b> <br>  A pointer to an object or an incomplete type can be converted to a pointer to another object or an incomplete type.  If the resulting pointer is incorrectly aligned for the specified type, then the behavior is undefined.  Otherwise, when converting back, the result should be equal to the original pointer.  When a pointer to an object is converted to a pointer to a character data type, the result points to the lower addressed byte of the object.  Successful increment of the result, up to the size of the object, gives pointers to the remaining bytes of the object. </blockquote><br>  And also it is used in pointer dereferencing. <br><br><blockquote>  <b>6.5.3.2 Address and dereference operation</b> <br>  If the pointer has been assigned an invalid value, the behavior of the unary operator * is undefined.  <sup>87</sup> ) <br><br>  <sup>87</sup> ) Among the invalid values ‚Äã‚Äãfor dereferencing an operator by a unary operator *: null pointer;  improperly aligned address for the type of the specified object;  address of the object at the end of its use. </blockquote><br>  If I understand these points correctly, the conversion of pointers (other than the conversion of something to <code>char *</code> ) is generally a dangerous business.  The program can fall out right here during the conversion.  Alternatively, the conversion can be successful, but produce an invalid value that will cause the program to crash (or crap on the output) during dereference.  In our case, both of these can happen if the alignment requirement for <code>uint32_t</code> performed by this compiler differs from unity (the alignment for <code>char*</code> ).  Since the most natural alignment for <code>uint32_t</code> is 4, the compiler was absolutely right. <br><br>  Version <code>sum0</code> , although it does not solve the problem, is still better than the original <code>sum</code> , because it required that the pointer be already of type <code>uint32_t*</code> , which required the pointer to be converted in the call code.  This conversion may fail immediately or produce an invalid pointer value.  Let's give alignment to the responsibility of the sum function and therefore replace the <code>sum</code> with <code>sum0</code> . <br><br>  These clauses of the standard explain why our attempts to solve the problem failed, playing with the types of pointers and how to calculate them.  It doesn't matter what we do with the pointer, as a result, it is converted to <code>uint32_t*</code> , which immediately signals the compiler that the pointer is aligned on the border of four bytes. <br><br>  There are only two suitable solutions. <br><br><h3>  Disable SSE </h3><br>  The first is not so much a decision - rather, a trick.  Problems with alignment on x86 appear only when using SSE, so let's turn it off.  We can do this for the entire file in which the <code>sum</code> declared, and if this is inconvenient, only for this particular function. <br><br><pre> <code class="cpp hljs">__attribute__ ((target(<span class="hljs-string"><span class="hljs-string">"no-sse"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> sum1 (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * p, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nwords) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> * q = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *) p; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nwords; i++) res += q [i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br>  This code is even worse tolerable than the original one, since it uses GCC-specific attributes and Intel-specific attributes.  It can be cleared by an appropriate conditional compilation. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined (__GNUC__) &amp;&amp; (defined (__x86_64__) || defined (__i386__)) __attribute__ ((target (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"no-sse"</span></span></span><span class="hljs-meta">))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  However, this method is actually of little use, since it only allows the program to compile on other computers and other architectures, but it will not necessarily work there.  The program may still fail if there is a RISC processor or if the compiler uses a different syntax to disable SSE. <br><br>  Even if we remain within the framework of GCC and Intel, who can guarantee that in ten years there will not be another architecture other than SSE?  In the end, my original code could have been written 20 years ago, when SSE did not exist (the first MMX appeared in 1997). <br><br>  However, such a program is compiled into a very neat code: <br><br><pre> <code class="hljs perl">sum<span class="hljs-number"><span class="hljs-number">0</span></span>: testq %rsi, %rsi je .L34 lea<span class="hljs-string"><span class="hljs-string">q (%rdi,%rsi,4)</span></span>, %rcx xorl %eax, %eax .L33: movl (%rdi), %edx addq $4, %rdi addq %rdx, %rax cmpq %rcx, %rdi jne .L33 ret .L34: xorl %eax, %eax ret</code> </pre> <br>  This is exactly the code I was thinking about when I wrote the function.  I think this code will work faster than SSE-based code for small vector sizes, which is our case with IP headers.  Later we will take measurements. <br><br><h3>  Using <code>memcpy</code> </h3><br>  Another option is to use the <code>memcpy</code> function.  This function can copy bytes representing a number into a variable of the appropriate type, regardless of alignment.  And she does it in full compliance with the standard.  It may seem that it is inefficient, and 20 years ago it was so.  Nowadays, however, it is not necessary to implement a function as a procedure call;  the compiler can regard it as its own language function and replace it with memory-to-register memory transfer.  GCC definitely does.  It compiles the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> sum2 (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * p, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nwords) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nwords; i++) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span> (&amp;temp, p + i * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (temp)); res += temp; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br>  in code similar to the original SSE, but only uses <code>movdqu</code> instead of <code>movdqa</code> .  This instruction allows unaligned data;  but acts with different performance.  On some processors, it is much slower than <code>movdqa</code> , even if the data is actually aligned.  On others, it works at almost the same speed. <br><br>  Another difference in the generated code is that it does not even try to align the pointer.  It uses <code>movdqu</code> on the original pointer even if it could align it and then use <code>movdqa</code> .  This means that such a code, being more universal, may end up being slower than the original code on some input data. <br><br>  This solution is completely portable, it can be used anywhere, even on RISC architectures. <br><br><h3>  Combined solution </h3><br>  The first solution seems to be faster on our data (although we have not measured it yet), while the second is more portable.  We can combine them together: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined (__GNUC__) &amp;&amp; (defined (__x86_64__) || defined (__i386__)) __attribute__ ((target (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"no-sse"</span></span></span><span class="hljs-meta">))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> uint64_t sum3 (const char * p, size_t nwords) { uint64_t res = 0; size_t i; uint32_t temp; for (i = 0; i &lt; nwords; i++) { memcpy (&amp;temp, p + i * sizeof (uint32_t), sizeof (temp)); res += temp; } return res; }</span></span></code> </pre> <br>  This code will compile into a good non-SSE loop on GCC / Intel, but will still produce working (and fairly good) code on other architectures.  This is the version I'm going to use in my project. <br><br>  The x86 code produced is identical to that obtained from <code>sum1</code> . <br><br><h3>  Speed ‚Äã‚Äãmeasurement </h3><br>  We have seen that the compiler has the full right to generate code with <code>movdqa</code> .  How good is this solution in terms of performance?  Let's measure the performance of all our solutions.  First, we do this on fully aligned data (the pointer is aligned on the border 16).  The values ‚Äã‚Äãin the table are in nanoseconds per word to be added. <br><br><table cellpadding="3" width="700"><tbody><tr><th>  Size, words </th><th>  sum0 (movdga) </th><th>  sum1 (loop) </th><th>  sum2 (movdqu) </th><th>  sum3 (loop, memcpy) </th></tr><tr><td>  one </td><td>  2.91 </td><td>  1.95 </td><td>  2.90 </td><td>  1.94 </td></tr><tr><td>  five </td><td>  0.84 </td><td>  0.79 </td><td>  0.77 </td><td>  0.79 </td></tr><tr><td>  sixteen </td><td>  0.46 </td><td>  0.45 </td><td>  0.41 </td><td>  0.46 </td></tr><tr><td>  1024 </td><td>  0.24 </td><td>  0.46 </td><td>  0.26 </td><td>  0.48 </td></tr><tr><td>  65536 </td><td>  0.24 </td><td>  0.45 </td><td>  0.24 </td><td>  0.45 </td></tr></tbody></table><br>  This table confirms that on a very small number of words (1), ordinary cycles work faster than SSE-based versions, although the difference is not so big (1 nanosecond per word, and here there is only one word). <br><br>  SSE is much faster on a large number of words (1024 and more), and here the overall result in winning can be quite significant. <br><br>  On the input data of medium size (like 16), the speed is almost the same, with a slight advantage of SSE ( <code>movdqu</code> ). <br><br>  Run the test on all values ‚Äã‚Äãbetween 1 and 16 and check where the equilibrium point is.  Versions <code>sum1</code> (non-SSE cycle) and <code>sum3</code> show a very similar result (which is expected because the code is the same; the difference in the results shows the measurement error in the region of 0.02 ns).  That is why only the final version is presented on the graph ( <code>sum3</code> ). <br><br><img src="http://pzemtsov.github.io/images/align-1-16.png"><br><br>  We see that simple cycles win SSE versions with the number of words up to 3, after which SSE versions begin to take over (the <code>movdqu</code> version is usually faster than the original <code>movdqf</code> ). <br><br>  I think that in the absence of any additional information, the rights compiler assumes that an arbitrary cycle will be executed more than three times, so the decision to use SSE was completely correct.  But why did he not immediately switch to the <code>movdqu</code> option?  Is there any reason to use <code>movdqa</code> ? <br><br>  We have seen that when the data is aligned, the <code>movdqu</code> version works at the same speed as <code>movdqa</code> , on a large number of words, and works faster on a small number of words.  The latter can be explained by a smaller number of instructions that precede the cycle (there is no need to check for alignment).  What happens if we run a test on unaligned data?  Here are the results for some options: <br><br><table><tbody><tr><th rowspan="2">  Size, words </th><th colspan="3">  Offset 0 </th><th colspan="2">  Offset 1 </th><th colspan="3">  Offset 4 </th></tr><tr><th>  movdqa </th><th>  movdqu </th><th>  loop </th><th>  movdqu </th><th>  loop </th><th>  movdqa </th><th>  movdqu </th><th>  loop </th></tr><tr><td>  one </td><td>  2.91 </td><td>  2.90 </td><td>  1.94 </td><td>  2.93 </td><td>  1.94 </td><td>  2.90 </td><td>  2.90 </td><td>  1.94 </td></tr><tr><td>  five </td><td>  0.84 </td><td>  0.77 </td><td>  0.79 </td><td>  0.77 </td><td>  0.79 </td><td>  0.84 </td><td>  0.79 </td><td>  0.78 </td></tr><tr><td>  sixteen </td><td>  0.46 </td><td>  0.41 </td><td>  0.46 </td><td>  0.42 </td><td>  0.46 </td><td>  0.52 </td><td>  0.40 </td><td>  0.46 </td></tr><tr><td>  1024 </td><td>  0.24 </td><td>  0.26 </td><td>  0.48 </td><td>  0.26 </td><td>  0.51 </td><td>  0.25 </td><td>  0.25 </td><td>  0.47 </td></tr><tr><td>  65536 </td><td>  0.24 </td><td>  0.24 </td><td>  0.45 </td><td>  0.25 </td><td>  0.50 </td><td>  0.24 </td><td>  0.24 </td><td>  0.46 </td></tr></tbody></table><br>  As you can see, the alignment gives only minor changes in speed, with the exception of one: the <code>movdqa</code> version starts to slow down a bit (0.52 ns instead of 0.46 ns) when shifted by 4 with 16 words.  The direct loop is still the best solution on a small number of words;  <code>movdqu</code> - the best solution for large quantities.  The compiler was wrong using <code>movdqa</code> .  A possible explanation is that it is optimized for the old Intel processor model.  The <code>movdqu</code> instruction worked a bit slower on <code>movdqa</code> on Xeon processors, even on fully aligned data.  It seems that now it is no longer observed, so the compiler can be simplified (and soften the alignment requirements). <br><br><h3>  Original feature </h3><br>  The original function for checking IP headers should now be rewritten as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined (__GNUC__) &amp;&amp; (defined (__x86_64__) || defined (__i386__)) __attribute__ ((target (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"no-sse"</span></span></span><span class="hljs-meta">))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> _Bool check_ip_header_sum (const char * p, size_t size) { const uint32_t * q = (const uint32_t *) p; uint32_t temp; uint64_t sum = 0; memcpy (&amp;temp, &amp;q [0], 4); sum += temp; memcpy (&amp;temp, &amp;q [1], 4); sum += temp; memcpy (&amp;temp, &amp;q [2], 4); sum += temp; memcpy (&amp;temp, &amp;q [3], 4); sum += temp; memcpy (&amp;temp, &amp;q [4], 4); sum += temp; for (size_t i = 5; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; size / 4; i++) { memcpy (&amp;temp, &amp;q [i], 4); sum += temp; } do { sum = (sum &amp; 0xFFFF) + (sum &gt;&gt; 16); } while (sum &amp; ~0xFFFFL); return sum == 0xFFFF; }</span></span></span></span></code> </pre> <br>  If we are afraid of converting an unaligned pointer to <code>uint32_t*</code> (the standard speaks of undefined behavior), then the code will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined (__GNUC__) &amp;&amp; (defined (__x86_64__) || defined (__i386__)) __attribute__ ((target (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"no-sse"</span></span></span><span class="hljs-meta">))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> _Bool check_ip_header_sum (const char * p, size_t size) { uint32_t temp; uint64_t sum = 0; memcpy (&amp;temp, p, 4); sum += temp; memcpy (&amp;temp, p + 4, 4); sum += temp; memcpy (&amp;temp, p + 8, 4); sum += temp; memcpy (&amp;temp, p + 12, 4); sum += temp; memcpy (&amp;temp, p + 16, 4); sum += temp; for (size_t i = 20; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; size; i+= 4) { memcpy (&amp;temp, p + i, 4); sum += temp; } do { sum = (sum &amp; 0xFFFF) + (sum &gt;&gt; 16); } while (sum &amp; ~0xFFFFL); return sum == 0xFFFF; }</span></span></span></span></code> </pre> <br>  Both versions look pretty ugly, especially the second.  Both remind me of programming in pure assembler.  However, this is exactly the right way to write portable code in C. <br><br>  Interestingly, although in our tests the cycle worked at the same speed as <code>movdqu</code> , on the number of words 5, but after writing this function in one cycle from 0 to <code>size</code> it began to work slower (the usual result is 0.48 ns and 0.83 ns per word). <br><br><h3>  C ++ Version </h3><br>  C ++ allows you to write the same function in a much more readable form, using some templates.  We introduce the parameterized type <code>const_unaligned_pointer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const_unaligned_pointer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * p; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: const_unaligned_pointer () : p (<span class="hljs-number"><span class="hljs-number">0</span></span>) {} const_unaligned_pointer (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * p) : p ((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)p) {} T <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>* () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { T tmp; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span> (&amp;tmp, p, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } const_unaligned_pointer <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+ (<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> const_unaligned_pointer (p + d * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (T)); } T <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[] (<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> * (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + d); } };</code> </pre> <br>  Here is the whole frame.  This definition should contain a test for equality, a minus operator for two pointers, a plus operator in another direction, some transformations, and probably other things. <br><br>  With the help of a parameterized type, our function looks very close to where we started: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_ip_header_sum</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ const_unaligned_pointer&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt; q (p); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; sum += q[<span class="hljs-number"><span class="hljs-number">0</span></span>]; sum += q[<span class="hljs-number"><span class="hljs-number">1</span></span>]; sum += q[<span class="hljs-number"><span class="hljs-number">2</span></span>]; sum += q[<span class="hljs-number"><span class="hljs-number">3</span></span>]; sum += q[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">5</span></span>; i &lt; size / <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { sum += q[i]; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { sum = (sum &amp; <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>) + (sum &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sum &amp; ~<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>L); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum == <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From this it turns out exactly the same assembler code as in the code with </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and, obviously, it works with the same speed.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A few more templates </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our code reads only unaligned data, so class is </font></font><code>const_unaligned_pointer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sufficient. </font><font style="vertical-align: inherit;">What if we wanted to write it too? </font><font style="vertical-align: inherit;">We can write a class for this, but in this case we need two classes: one for the pointer and the other for the l-value, which is obtained during the dereference of this pointer:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unaligned_ref</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * p; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: unaligned_ref (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * p) : p (p) {} T <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>= (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; rvalue) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span> (p, &amp;rvalue, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rvalue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ T tmp; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span> (&amp;tmp, p, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unaligned_pointer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * p; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: unaligned_pointer () : p (<span class="hljs-number"><span class="hljs-number">0</span></span>) {} unaligned_pointer (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * p) : p ((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)p) {} unaligned_ref&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>* () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unaligned_ref&lt;T&gt; (p); } unaligned_pointer <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+ (<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unaligned_pointer (p + d * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (T)); } unaligned_ref&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[] (<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + d); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again, this code simply demonstrates the idea; </font><font style="vertical-align: inherit;">Much more is needed to make it suitable for use in production. </font><font style="vertical-align: inherit;">Let's try running a simple test:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> mem [<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) mem [<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) mem [<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) mem [<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) mem [<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) mem [<span class="hljs-number"><span class="hljs-number">4</span></span>] &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ dump (); unaligned_pointer&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p (mem + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = *p; r++; *p = r; dump (); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is his issue: </font></font><br><br><pre> <code class="hljs">0 0 0 0 0 0 1 0 0 0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We could write </font></font><br><br><pre> <code class="hljs"> ++ *p;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">but this requires a definition of </font></font><code>operator++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>unaligned_ref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3>  findings </h3><br><ul><li>         RISC. - SSE      x86 (  32-,    64- ). </li><li>      ,  SSE   .       ‚Äî       ,    (   ,        -   ). </li><li>       :           . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a lot of code written twenty years and working only under Intel. </font><font style="vertical-align: inherit;">This code may suddenly start to crash in the same way. </font><font style="vertical-align: inherit;">There is one practical tip: to disable all possible extended instruction sets during the compilation of such code - however, even this may not help.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This story shows that there is something useful in code coverage tools. </font><font style="vertical-align: inherit;">Here I was lucky that the input data made the whole code run. </font><font style="vertical-align: inherit;">Next time may be different.</font></font></li></ul><br><h3>  Update </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the </font></font><a href="https://www.reddit.com/r/cpp/comments/5bn8jx/a_bug_story_data_alignment_on_x86/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ r / cpp / </font></font></a><font style="vertical-align: inherit;"></font><a href="https://www.reddit.com/user/OldWolf2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">branch, the OldWolf2</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> user </font></font><a href="https://www.reddit.com/r/cpp/comments/5bn8jx/a_bug_story_data_alignment_on_x86/d9q4xcd/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noticed</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that the checksum verification code contains an error in the last line:</font></font><br><br><pre> <code class="cpp hljs"> } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sum &amp; ~<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>L);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He is right: u </font></font><code>0xFFFFL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type </font></font><code>unsigned long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is not always the same as </font></font><code>uint64_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The length </font></font><code>long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be 32 bits, and then the inversion of bits (reverse code) will occur before the extension to 64 bits, and the real constant in the test will be </font></font><code>0x00000000FFFF0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It is easy to pick up input data, where such a test will fail, for example, for an array of two words: </font></font><code>0xFFFFFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>0x00000001</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can either do the reverse code after translating to 64 bits:</font></font><br><br><pre> <code class="cpp hljs"> } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sum &amp; ~(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>) <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Or, alternatively, make a comparison: </font></font><br><br><pre> <code class="cpp hljs"> } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sum &gt; <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interestingly, GCC produces a more concise code in the second case. </font><font style="vertical-align: inherit;">Here is the test version:</font></font><br><br><pre> <code class="hljs perl">.L15: movzwl %ax, %edx shrq $16, %rax addq %rdx, %rax movq %rax, %rdx xorw %dx, %dx testq %rdx, %rdx jne .L15</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But the comparison version: </font></font><br><br><pre> <code class="hljs perl">.L44: movzwl %ax, %edx shrq $16, %rax addq %rdx, %rax cmpq $65535, %rax ja .L44</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comments are welcome below or on </font></font><a href="https://www.reddit.com/r/programming/comments/5bl553/a_bug_story_data_alignment_on_x86/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reddit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/318456/">https://habr.com/ru/post/318456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318446/index.html">Seattle's voice: talking to Sergey Teplyakov</a></li>
<li><a href="../318448/index.html">Hakintosh: we deploy macOS Sierra on Intel-PC in detail and clearly</a></li>
<li><a href="../318450/index.html">The most popular programming languages ‚Äã‚Äã2016</a></li>
<li><a href="../318452/index.html">We deliver a cup of hot coffee to our office with one team of console using TestCafe</a></li>
<li><a href="../318454/index.html">Analysis of the statistical language model from Google - part 1: vector representation of characters</a></li>
<li><a href="../318458/index.html">On a combinatorial problem</a></li>
<li><a href="../318460/index.html">How long does it take to learn a new technology?</a></li>
<li><a href="../318464/index.html">Data Storage Architecture in Facetz.DCA</a></li>
<li><a href="../318466/index.html">Comparison of monitoring systems: Shinken vs Sensu vs Icinga 2 vs Zabbix</a></li>
<li><a href="../318468/index.html">Computers of Soviet Russia with the ternary balanced number system</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>