<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Terra Language - Low Level Partner Lua</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terra is a low-level system programming language that is embedded and can be metaprogrammed using Lua. 




-- Lua function printhello() -- Lua print(...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Terra Language - Low Level Partner Lua</h1><div class="post__text post__text-html js-mediator-article">  Terra is a low-level system programming language that is embedded and can be metaprogrammed using Lua. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/3c5/425/78c/3c542578c1b04aec8778786e90983716.jpg"></div><a name="habracut"></a><br><pre><code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--     Lua function printhello() --    Lua print("Hello, Lua!") end printhello() -- Terra    C,     C    C = terralib.includec("stdio.h") --   'terra'    terra hello(argc : int, argv : &amp;rawstring) --     C  Terra C.printf("Hello, Terra!\n") return 0 end --     Terra   Lua,   JIT --  LLVM     hello(0,nil) --  Terra      Lua,      --     hello:disas() --[[ output: assembly for function at address 0x60e6010 0x60e6010(+0): push rax 0x60e6011(+1): movabs rdi, 102129664 0x60e601b(+11): movabs rax, 140735712154681 0x60e6025(+21): call rax 0x60e6027(+23): xor eax, eax 0x60e6029(+25): pop rdx 0x60e602a(+26): ret ]] --      Terra  ,   ,    --       terralib.saveobj("helloterra",{ main = hello })</span></span></code> </pre> <br>  Like C / C ++, Terra is a statically typed, compiled language with ‚Äúmanual‚Äù memory management.  Unlike C / C ++, it was originally designed for metaprogramming using Lua. <br><br>  Terra is designed based on the fact that C / C ++ actually consists of many ‚Äúlanguages.‚Äù There is a core language, consisting of operators, controlling the flow of execution and calling functions, but the surrounding language is a metalanguage made up of a mixture of different things, such as preprocessor, templates, structure declarations.  The templates themselves form a Turing-complete language and are used to generate optimized libraries, such as <a href="http://eigen.tuxfamily.org/index.php%3Ftitle%3DMain_Page">Eigen</a> , but are terrible in terms of practical use. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the Terra language, we abandoned the idea of ‚Äã‚Äãmaking the metal language C / C ++ more powerful and replaced it with a real programming language, Lua. <br><br>  The combination of a low-level language that can be meta-programmed by a high-level scripting language makes many behaviors impossible in other systems possible.  Unlike C / C ++, the code on Terra can be JIT-compiled and run in conjunction with the Lua interpreter, which makes it easy to write libraries that depend on runtime code generation. <br><br>  The capabilities of other languages, such as conditional compilation and patterns, simply lose compared to using Lua for Terra metaprogramming: <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- C++ | -- Lua/Terra int add(int a, int b) { | terra add(a : int,b : int) : int return a + b; | return a + b } | end | | --    | --   | -- ,    #ifdef _WIN32 | if iswindows() then void waitatend() { | terra waitatend() getchar(); | C.getchar() } | end #else | else void waitatend() {} | terra waitatend() end #endif | end | | --    Lua | --     terra | --        | --   template&lt;class T&gt; | function Array(T) struct Array { | struct Array { int N; | N : int T* data; | data : &amp;T | } T get(int i) { | terra Array:get(i : int) return data[i]; | return self.data[i] } | end | return Array }; | end typedef | Array&lt;float&gt; FloatArray; | FloatArray = Array(float)</span></span></code> </pre> <br>  You can use Terra and Lua as ... <br><br>  <b>Embedded JIT compiler for constructing languages.</b>  We use multi-stage programming techniques [2] to enable Terra metaprogramming using Lua.  Expressions, types and functions of the Terra language are first-class values ‚Äã‚Äãin the Lua language, which makes it possible to generate arbitrary programs in runtime.  This allows you to compile domain-specific languages ‚Äã‚Äã(DSL) written in Lua into high-performance Terra code.  Moreover, since Terra is built on the Lua ecosystem, it is easy to embed a program on Terra-Lua into another program as a library.  This design allows you to add a JIT compiler to your existing software.  You can use it to add JIT-compiled DSL languages ‚Äã‚Äãto your application, or automatically and dynamically configure high-performance code. <br><br>  <b>A scripting language with high-performance extensions.</b>  Although the performance of Lua and other dynamic languages ‚Äã‚Äãis continuously improving, a low level of abstraction gives you predictable performance control when you need it.  The Terra programs use the same LLVM backend that Apple uses in its C compilers. This means that the performance of the Terra code is similar to the C code. For example, our translations of the nbody and fannhakunen programs from the benchmark [1] programming languages ‚Äã‚Äãhave a performance that is no more than 5% of their equivalents on C compiled to Clang, frontend LLVM.  Terra also includes built-in support for SIMD operations and other low-level features, such as <a href="https://stackoverflow.com/questions/37070/what-is-the-meaning-of-non-temporal-memory-accesses-in-x86">recording and prefetching non-temporary memory</a> .  You can use Lua to organize and configure your application, and then, when you need managed performance, make a call to the Terra code. <br><br>  <b>Independent low-level language.</b>  Terra is designed to work independently of Lua.  In fact, your final program does not require Lua, you can save the Terra code to a .o file or to an executable file.  In addition to a clear separation between high-level and low-level code, this design allows you to use Terra as an independent low-level language.  In such a use case, Lua acts as a powerful metaprogramming language.  Lua serves as a substitute for C ++ templates [3] and C preprocessor macros (X-Macro) [4], with the best syntax and best hygiene properties [5].  Since Terra exists only as code embedded in a Lua metaprogram, those features that are usually built into a low-level language can be implemented as Lua libraries.  Such a design keeps the Terra core simple, making it possible to perform complex behaviors such as conditional compilation, namespaces, patterns, and even a class system implemented as libraries. <br><br>  For more information on using Terra, see <a href="http://terralang.org/getting-started.html">the beginner</a> ‚Äôs <a href="http://terralang.org/api.html">guide and API reference</a> .  Our <a href="http://terralang.org/publications.html">publications</a> provide a deeper insight into language design. <br><br>  [1] <a href="http://benchmarksgame.alioth.debian.org/">http://benchmarksgame.alioth.debian.org</a> <br>  [2] <a href="http://www.cs.rice.edu/~taha/MSP/">http://www.cs.rice.edu/~taha/MSP/</a> <br>  [3] <a href="http://en.wikipedia.org/wiki/Template_metaprogramming">http://en.wikipedia.org/wiki/Template_metaprogramming</a> <br>  [4] <a href="http://en.wikipedia.org/wiki/X_Macro">http://en.wikipedia.org/wiki/X_Macro</a> <br>  [5] <a href="http://en.wikipedia.org/wiki/Hygienic_macro">http://en.wikipedia.org/wiki/Hygienic_macro</a> <br><br><h3>  Generating programming </h3><br>  Terra entities such as functions, types, variables, and expressions are first-class values ‚Äã‚Äãin Lua, they can be stored as variables, and also passed to Lua functions and returned from Lua functions.  Using constructs from multi-stage programming, you can write Lua code that generates arbitrary Terra code. <br><br><h4>  Multistep Operators </h4><br>  In the Terra code, you can use the escape ([]) operator, which places the result of the Lua expression in the Terra code: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> terra sin5() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(a) ] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  The escape value is calculated when the Terra function is compiled, and the result is placed in the Terra code.  In this example, this means that the expression math.sin (5) will be evaluated once, and the code implementing the Terra function will return a constant.  This can be verified by displaying the compiled version of the function sin5. <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--  ,    sin5:printpretty() &gt; output: &gt; sin50 = terra() : {double} &gt; return -0.95892427466314 &gt; end</span></span></code> </pre><br>  Escape statements can also return other Terra entities, such as functions: <br><br><pre> <code class="lua hljs">add4 = terra(a : int) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> terra example() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [add4](<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">-- 7 end</span></span></code> </pre><br>  In this case, the Terra code will be inserted into the Terra function stored in the variable add4: <br><br><pre> <code class="lua hljs">example:printpretty() &gt; <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>: &gt; example4 = terra() : {int32} &gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;extract0&gt; #add43(<span class="hljs-number"><span class="hljs-number">3</span></span>)# &gt; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  In fact, any name used in Terra code, such as add4 or foo.bar, is treated by default as if it were an escape statement. <br><br>  Inside the escape statement, you can refer to variables defined in Terra: <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--    escape function choosesecond(a,b) --  false, 'a' -  : print(a == 1) --  true, 'a' -  Terra: print(terralib.issymbol(a)) return b end terra example(input : int) var a = input var b = input+1 -- escape    'a'  'b' return [ choosesecond(a,b) ] --  b end example(1) -- 2</span></span></code> </pre><br>  Since the escape operators are evaluated before the Terra functions are compiled, the variables a and b will not have specific integer values ‚Äã‚Äãinside the escape operator.  Instead, inside the Lua code, the variables a and b are Terra symbols representing references to Terra values.  Since choosesecond returns the character b, the function in the example will return the value b of the Terra code variable when it is called. <br><br>  The quotation operator, the reverse apostrophe, allows you to generate Terra operators and expressions in Lua.  They can be inserted into the Terra code using the escape statement. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addtwo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> `a + b <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> terra example(<span class="hljs-built_in"><span class="hljs-built_in">input</span></span> : int) var a = <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> var b = <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ addtwo(a,b) ] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> example(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">--  3</span></span></code> </pre> <br>  To generate statements instead of expressions, use the quote clause: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> printtwice = quote C.printf(<span class="hljs-string"><span class="hljs-string">"hello\n"</span></span>) C.printf(<span class="hljs-string"><span class="hljs-string">"hello\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> terra print4() [printtwice] [printtwice] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h4>  Compiling language </h4><br>  With these two statements, you can generate arbitrary code on Terra at compile time.  This makes the Lua / Terra combination well suited for writing a high-performance, object-oriented language compiler.  For example, we can implement a <a href="https://en.wikipedia.org/wiki/Brainfuck">BF</a> compiler, a minimal language that emulates a Turing machine.  The compile function in Lua takes a string of BF code and a maximum tape size N. It then generates a Terra function that implements the BF code.  This is the ‚Äúskeleton‚Äù that prepares the BF program: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code,N)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data,ptr)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">--&lt;&lt; body&gt;&gt; end return terra() --    var data : int[N] --   for i = 0, N do data[i] = 0 end var ptr = 0 --   body [ body(data,ptr) ] end end</span></span></code> </pre><br>  The body function is responsible for generating the body of the BF program with a line of code: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data,ptr)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">--  Terra,   BF local stmts = terralib.newlist() --    BF for i = 1,#code do local c = code:sub(i,i) local stmt --   Terra --   BF if c == "&gt;" then stmt = quote ptr = ptr + 1 end elseif c == "&lt;" then stmt = quote ptr = ptr - 1 end elseif c == "+" then stmt = quote data[ptr] = data[ptr] + 1 end elseif c == "-" then stmt = quote data[ptr] = data[ptr] - 1 end elseif c == "." then stmt = quote C.putchar(data[ptr]) end elseif c == "," then stmt = quote data[ptr] = C.getchar() end elseif c == "[" then error("Implemented below") elseif c == "]" then error("Implemented below") else error("unknown character "..c) end stmts:insert(stmt) end return stmts end</span></span></code> </pre><br>  The loop goes through the line of code, generates the corresponding code on Terra for each BF character (for example, "&gt;" shifts the tape by one character and is implemented on Terra with the code ptr = ptr + 1).  Now we can compile the BF function: <br><br><pre> <code class="lua hljs">add3 = compile(<span class="hljs-string"><span class="hljs-string">",+++."</span></span>)</code> </pre> <br>  The result, add3, is the Terra function, which adds 3 to the input symbol and displays the result: <br><br><pre> <code class="lua hljs">add3:printpretty() &gt; bf_t_46_1 = terra() : {} &gt; var data : int32[<span class="hljs-number"><span class="hljs-number">256</span></span>] &gt; ... &gt; var ptr : int32 = <span class="hljs-number"><span class="hljs-number">0</span></span> &gt; data[ptr] = &lt;extract0&gt; #getchar()# &gt; data[ptr] = data[ptr] + <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; data[ptr] = data[ptr] + <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; data[ptr] = data[ptr] + <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; &lt;extract0&gt; #putchar(data[ptr])# &gt; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  We can also use the <b>goto</b> operator ( <b>goto labelname</b> ) and labels ( <b>:: labelname ::)</b> to implement the loop construction in BF: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data,ptr)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> stmts = terralib.newlist() <span class="hljs-comment"><span class="hljs-comment">-- ,      local jumpstack = {} for i = 1,#code do local c = code:sub(i,i) local stmt if ... elseif c == "[" then -- ,   --   -- 'symbol'    --  local target = { before = symbol(), after = symbol() } table.insert(jumpstack,target) stmt = quote --   ::[target.before]:: if data[ptr] == 0 then goto [target.after] --exit the loop end end elseif c == "]" then -- ,   local target = table.remove(jumpstack) assert(target) stmt = quote goto [target.before] --loop back edge :: [target.after] :: --label for end of the loop end else error("unknown character "..c) end stmts:insert(stmt) end return stmts end</span></span></code> </pre><br>  We use generative programming constructs to implement domain-specific languages ‚Äã‚Äãand auto-tuning.  Our PLDI <a href="http://terralang.org/publications.html">article</a> describes our implementation of Orion, the language for image processing cores, and we are in the process of porting the <a href="http://graphics.stanford.edu/hackliszt/">Liszt</a> language ( <a href="http://graphics.stanford.edu/hackliszt/">mesh-</a> based solution of partial differential equations) to the Terra language. <br><br><h3>  Embedding and interaction </h3><br>  Programming languages ‚Äã‚Äãdo not exist in a vacuum, and the possibilities of generating programming in Terra can be useful even in projects that were originally implemented in other programming languages.  We make possible the integration of Terra with other projects, so that you can use the generation of low-level code, and at the same time most of your project will be implemented in any traditional language. <br><br>  First we make it possible to transfer values ‚Äã‚Äãbetween Lua and Terra.  Our implementation is based on the <a href="http://luajit.org/ext_ffi_tutorial.html">interface of foreign functions</a> (LuaJIT foreign function).  You can call Terra functions directly from Lua (and vice versa) and access objects directly from Lua (described in more detail in the API reference). <br><br>  Moreover, Lua-Terra is backward compatible with pure Lua and C, which facilitates the use of existing code.  In Lua-Terra, you can use require or loadfile and treat the file as a Lua program (use terralib.loadfile to load the combined Lua-Terra file).  You can use terralib.includec to import C functions from existing header files. <br><br>  Finally, Lua-Terra can also be embedded in an existing application by linking the application with libterra.a and using Terra's C API.  The interface is very similar to the <a href="http://queue.acm.org/detail.cfm%3Fid%3D1983083">Lua interpreter</a> interface.  A simple example initializes Terra and runs the code from the file defined in each argument: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include "terra.h" int main(int argc, char ** argv) { lua_State * L = luaL_newstate(); //   Lua luaL_openlibs(L); //   //  Terra  Lua terra_init(L); for(int i = 1; i &lt; argc; i++) //  Terra    if(terra_dofile(L,argv[i])) exit(1); return 0; }</span></span></span></span></code> </pre> <br><h3>  Simplicity </h3><br>  The combination of a simple low-level language with a simple dynamic programming language means that many of the built-in capabilities of statically typed low-level languages ‚Äã‚Äãcan be implemented as libraries in a dynamic language.  Here are a few examples: <br><br><h4>  Conditional compilation </h4><br>  As a rule, conditional compilation is done using preprocessor directives (for example, #ifdef), or some kind of build system.  When using Lua-Terra, we can write Lua code that defines how to construct the Terra function.  Since Lua is a complete programming language, it can do things that most preprocessors cannot do, for example, call external programs.  In this example, we use conditional compilation to compile the Terra function differently for OSX and Linux by calling uname to determine the operating system, and using the if statement to instantiate different versions of the Terra function depending on the result: <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- uname  ,    local uname = io.popen("uname","r"):read("*a") local C = terralib.includec("stdio.h") if uname == "Darwin\n" then terra reportos() C.printf("this is osx\n") end elseif uname == "Linux\n" then terra reportos() C.printf("this is linux\n") end else error("OS Unknown") end --   --     reportos()</span></span></code> </pre> <br><h4>  Namespaces </h4><br>  Statically typed languages ‚Äã‚Äãusually need constructs that solve the namespace problem (for example, the namespace keyword in C ++, or the <b>import</b> construct in Java).  For Terra, we simply use Lua's first-class tables as a way to organize functions.  When you use any name, for example, myfunctions.add, inside the Terra function, Terra will resolve it <i>at compile time</i> to its associated value Terra.  Here is an example of placing the Terra function inside a Lua table, followed by a call from another Terra function: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> myfunctions = {} <span class="hljs-comment"><span class="hljs-comment">--  terra -      Lua --       Lua terra myfunctions.add(a : int, b : int) : int return a + b end --     terra myfunctions.add3(a : int) return myfunctions.add(a,3) end -- myfunctions.add     : myfunctions["add"] = terra(a : int, b : int) : int return a + b end print(myfunctions.add3(4))</span></span></code> </pre><br>  In fact, you have already seen this behavior when we imported C functions: <br><br><pre> <code class="lua hljs">C = terralib.includec(<span class="hljs-string"><span class="hljs-string">"stdio.h"</span></span>)</code> </pre> <br>  The includec function simply returns a Lua (C) table containing C functions. Since C is a Lua table, you can iterate over it: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k,v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(C) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(k,v) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; seek &lt;terra <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&gt; &gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asprintf</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">terra</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">&gt; &gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gets</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">terra</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">&gt; &gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size_t</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint64</span></span></span><span class="hljs-function"> &gt; ...</span></span></code> </pre><br><h4>  Templates </h4><br>  Since the types and functions of Terra are first-class values, you can get functionality close to C ++ templates by simply creating the Terra type and defining the Terra function inside the Lua function.  Below is an example in which we define the Lua function MakeArray (T), which takes the type T of the Terra language and generates an Array object that can store many objects of type T (that is, a simple version of std :: vector from C ++). <br><br><pre> <code class="lua hljs">C = terralib.includec(<span class="hljs-string"><span class="hljs-string">"stdlib.h"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">--   Struct,   --   T   N local struct ArrayT { --&amp;T i-   T data : &amp;T; N : int; } --    terra ArrayT:init(N : int) --  [&amp;T](...) -  , --  (T*)(...)   self.data = [&amp;T](C.malloc(sizeof(T)*N)) self.N = N end terra ArrayT:get(i : int) return self.data[i] end terra ArrayT:set(i : int, v : T) self.data[i] = v end --   return ArrayT end IntArray = MakeArray(int) DoubleArray = MakeArray(double) terra UseArrays() var ia : IntArray var da : DoubleArray ia:init(1) da:init(1) ia:set(0,3) da:set(0,4.5) return ia:get(0) + da:get(0) end</span></span></code> </pre> <br>  As shown in the example, Terra allows you to define methods in <b>struct</b> types.  Unlike other statically typed languages ‚Äã‚Äãwith classes, there are no built-in inheritance mechanisms or run-time polymorphisms.  The method declarations are simply syntactic sugar, which associates Lua method tables with each type.  Here, the get method is equivalent to the following: <br><br><pre> <code class="cpp hljs">ArrayT.methods.get = terra(self : &amp;T, i : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.data[i] end</code> </pre> <br>  The ArrayT.methods object in the Lua table stores methods for the ArrayT type. <br><br>  Similarly, a call, for example, ia: get (0) is equivalent to T.methods.get (&amp; ia, 0). <br><br><h4>  Specialization </h4><br>  By placing the Terra function inside the Lua function, you can compile different versions of the function.  Here we generate different versions of the degree function (i.e. pow2, pow3): <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--     N (, N = 3) function makePowN(N) local function emit(a,N) if N == 0 then return 1 else return `a*[emit(a,N-1)] end end return terra(a : double) return [emit(a,N)] end end --      local mymath = {} for n = 1,10 do mymath["pow"..n] = makePowN(n) end print(mymath.pow3(2)) -- 8</span></span></code> </pre> <br><h4>  Class system </h4><br>  As shown in the example for templates, Terra allows you to define methods for <b>struct</b> types, but does not provide a built-in mechanism for inheritance or polymorphism.  Instead, the usual class system can be written as a library.  For example, a user might write: <br><br><pre> <code class="lua hljs">J = terralib.<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"lib/javalike"</span></span>) Drawable = J.interface { draw = {} -&gt; {} } struct Square { length : int; } J.extends(Square,Shape) J.implements(Square,Drawable) terra Square:draw() : {} <span class="hljs-comment"><span class="hljs-comment">-- draw end</span></span></code> </pre><br>  The J.extends and J.implements functions are Lua functions that generate the corresponding Terra code for the implementation of the class system.  More information is available in our <a href="http://terralang.org/publications.html">PLDI article</a> .  The file <a href="">lib / javalike.t</a> contains one possible implementation of a class system similar to Java, and the file <a href="">lib / golike.t</a> is more similar to the language Go. </div><p>Source: <a href="https://habr.com/ru/post/336406/">https://habr.com/ru/post/336406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336396/index.html">Work with CST parameters from Matlab</a></li>
<li><a href="../336398/index.html">Shipbuilding of the 17th century and your unsuccessful development projects: find five differences</a></li>
<li><a href="../336400/index.html">Android: the evolution of the photo editor VK</a></li>
<li><a href="../336402/index.html">Amsterdam invites to work in the field of AI</a></li>
<li><a href="../336404/index.html">In-line cooling in the data center: myths and realities</a></li>
<li><a href="../336408/index.html">How to easily break up with $ 1000</a></li>
<li><a href="../336410/index.html">Nontrivial techniques for finding business ideas</a></li>
<li><a href="../336412/index.html">Review of the best technical reports of the Still Hacking Anyway 2017 conference</a></li>
<li><a href="../336414/index.html">Dagger 2 Multibindings</a></li>
<li><a href="../336416/index.html">Pygest # 16. Releases, articles, interesting projects from the world of Python [August 15, 2017 - August 28, 2017]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>