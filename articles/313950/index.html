<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to unload dll from java-machine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java interacts with the operating system through methods marked with the native keyword using the system libraries loaded by the System.loadLibrary ()...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to unload dll from java-machine</h1><div class="post__text post__text-html js-mediator-article">  Java interacts with the operating system through methods marked with the native keyword using the system libraries loaded by the System.loadLibrary () procedure. <br><br>  Download the system library is very simple, but to unload it, as it turned out, you need to put a lot of effort.  How exactly the system libraries are unloaded, and why this is necessary, I will try to tell. <br><a name="habracut"></a><br>  Suppose we want to make a small utility that users will run on their computers in the local network.  We would like to save users from problems with installing and configuring the program, but there are no resources to deploy and support a centralized infrastructure.  In such cases, the program is usually assembled along with all dependencies into a single jar file.  This is easy to do with a maven-assembly-plugin or simply export from an IDE Runnable jar.  The program will be launched by the command: <br><br><pre><code class="dos hljs">java -jar my-program.jar</code> </pre> <br>  Unfortunately, this does not work if one of the libraries requires a system dynamic library for its work, in other words, dll.  Usually in one of the classes of such a library in a static initializer a call to System.loadLibrary () is made.  To load the dll, you need to put it in a directory accessible through the jVM jli.library.path system property.  How can this limitation be circumvented? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Pack the dll inside the jar file.  Before using classes that require loading dlls, create a temporary directory, extract the library there and add the directory to java.library.path.  It will look something like this: <br><br><div class="spoiler">  <b class="spoiler_title">prepareLibrary</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addLibraryPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String pathToAdd)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException </span></span>{ Field usrPathsField = ClassLoader.class.getDeclaredField(<span class="hljs-string"><span class="hljs-string">"usr_paths"</span></span>); usrPathsField.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); String[] paths = (String[]) usrPathsField.get(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); String[] newPaths = Arrays.copyOf(paths, paths.length + <span class="hljs-number"><span class="hljs-number">1</span></span>); newPaths[newPaths.length - <span class="hljs-number"><span class="hljs-number">1</span></span>] = pathToAdd; usrPathsField.set(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, newPaths); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Path </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareLibrary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ReflectiveOperationException </span></span>{ Path dir = Files.createTempDirectory(<span class="hljs-string"><span class="hljs-string">"lib"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream input = ExampleClass.class.getResourceAsStream(<span class="hljs-string"><span class="hljs-string">"custom.dll"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException(<span class="hljs-string"><span class="hljs-string">"Can't load resource custom.dll"</span></span>); } Files.copy(input, dir.resolve(<span class="hljs-string"><span class="hljs-string">"custom.dll"</span></span>)); } addLibraryPath(dir.toAbsolutePath().toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dir; }</code> </pre><br><br></div></div><br>  Unfortunately, you have to mix it with reflection, because Java <a href="http://stackoverflow.com/questions/15961483/">does not provide</a> standard methods to extend java.library.path. <br><br>  Now the library is loaded for the user transparently, and he does not have to worry about copying files or setting environment variables.  To work, it is still enough just to run a regular script.  However, after each launch of the program there is a temporary directory with files.  This is not very good, so cleaning should be done at the exit. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { delete(dir); }</code> </pre><br>  But on Windows it does not work.  The library loaded in the JVM blocks the dll-file and the directory in which it lies.  Thus, to solve the problem of a neat program termination, you need to unload the system dynamic library from the JVM. <br><br><h3>  Attempt to solve </h3><br>  First of all, it is reasonable to add diagnostics to the code.  If the files could be deleted, for example.  when the library is not used, then nothing needs to be done, and if the files are locked, then take additional measures. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!delete(dir)) { forceDelete(dir); }</code> </pre><br>  As a quick, but not the most beautiful solution, I used the scheduler.  At the output, I create an xml file with the task to execute the cmd / c rd / s / q temp-dir command after 1 minute and load the task into the scheduler with the command ‚Äúschtasks -create taskName -xml taskFile.xml‚Äù.  By the time the task is completed, the program is already completed, and no one is holding the files <br><br>  The most correct decision is to provide unloading of the library by means of a Java-machine.  The documentation says that the system library will be unloaded when a class is deleted, and the class is deleted by the garbage collector along with the classcadder when there is not a single instance left of its classes.  In my opinion, it is better to always write such code that completely clears all memory and other resources after it.  Because if the code does something useful, sooner or later you will want to reuse it and install it on some server where other components are installed.  So I decided to take the time to figure out how to programmatically unload the dll. <br><br><h3>  Using a classeloader </h3><br>  In my program, problems originated from the JDBC driver, so I will continue to look at the JDBC example.  But with other libraries you can work in a similar way. <br><br>  If the dll is loaded from the system class loader, then it will no longer be able to unload it, so you need to create your own classifier in such a way that the class that pulls the library is loaded from it.  The new classifier must be connected to the system classifier via the parent property, otherwise the String, Object and other classes necessary for the household will not be available in the item. <br><br>  Let's try: <br><br><div class="spoiler">  <b class="spoiler_title">Loading class from new loader (1)</b> <div class="spoiler_text"><pre> <code class="java hljs">ClassLoader parentCl = ExampleClass.class.getClassLoader(); classLoader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URLClassLoader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL[<span class="hljs-number"><span class="hljs-number">0</span></span>], parentCl); Class.forName(<span class="hljs-string"><span class="hljs-string">"org.jdbc.CustomDriver"</span></span>, classLoader, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Connection connection = DriverManager.getConnection(dbUrl, dbProperties)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection.getClass().getClassLoader() != classLoader) { System.out.printf(<span class="hljs-string"><span class="hljs-string">"-   %n"</span></span>); } ... }</code> </pre><br></div></div><br>  Does not work.  When a class is loaded, an attempt is first made to pick it up from the parent loader, so our driver did not load as we needed.  To use the new classifier, you need to delete the JDBC driver from the jar file of the program so that it is not accessible to the system loader.  So, we pack the library as an attached jar-file, and before using it we deploy it in the temporary directory (in the same place where we have the dll). <br><br><div class="spoiler">  <b class="spoiler_title">Loading class from new loader (2)</b> <div class="spoiler_text"><pre> <code class="java hljs">ClassLoader cl = ExampleClass.class.getClassLoader(); URL url = UnloadableDriver.class.getResource(<span class="hljs-string"><span class="hljs-string">"CustomJDBCDriver.jar"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (url == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException(<span class="hljs-string"><span class="hljs-string">"Can't load resource CustomJDBCDriver.jar"</span></span>); } Path dir = prepareLibrary(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream stream = url.openStream()) { Path target = dir.resolve(<span class="hljs-string"><span class="hljs-string">"CustromJDBCDriver.jar"</span></span>); Files.copy(stream, target); url = target.toUri().toURL(); } ClassLoader classLoader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URLClassLoader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL[] {url}, cl); Class.forName(<span class="hljs-string"><span class="hljs-string">"org.jdbc.CustomDriver"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, classLoader); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Connection connection = DriverManager.getConnection(dbUrl, dbProperties)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection.getClass().getClassLoader() != classLoader) { System.out.printf(<span class="hljs-string"><span class="hljs-string">"-   %n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.out.printf(<span class="hljs-string"><span class="hljs-string">",   %n"</span></span>); } ... }</code> </pre><br></div></div><br>  We received an object loaded from our new loader, after finishing work we need to close everything we opened, clean all our variables, and, apparently, call System.gc (), then try to clean the files.  In this place, it makes sense to encapsulate all the logic of working with class loaders in a separate class with explicit initialization methods. <br><br><div class="spoiler">  <b class="spoiler_title">Core class skeleton</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path dir; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> URLClassLoader classLoader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classLoader.close(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classloader = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; System.gc(); <span class="hljs-comment"><span class="hljs-comment">// -    dll if (!delete(this.dir)) { scheduleRemovalToTaskschd(this.dir); } } } public class Main { public static void main(String args[]) { try (ExampleClass example = new ExampleClass()) { example.doWork(); } catch (Throwable e) { e.printStackTrace(); } } }</span></span></code> </pre><br></div></div><br><h3>  Experiments with the garbage collector </h3><br>  Despite the fact that everything seems to be formally necessary for unloading the library is done, in fact, unloading does not occur.  Reading the sources from the java.lang package allowed us to determine that the removal of the native libraries is done in the finalize () method in one of the internal classes.  This is distressing and alarming, because the documentation does not give any precise definition of when this method will be executed and whether it will be executed at all.  That is, success depends on some factors that may vary in different environments, in different versions of the JVM, or in different garbage collectors.  However, there is a System.runFinalization () method that gives some hope. <br><br>  We try: <br><br><div class="spoiler">  <b class="spoiler_title">Run finalization ...</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classLoader.close(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classloader = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; System.gc(); System.runFinalization(); <span class="hljs-comment"><span class="hljs-comment">// -    dll if (!delete(this.dir)) { scheduleRemovalToTaskschd(this.dir); } }</span></span></code> </pre><br></div></div><br>  Does not work.  The directory is locked by the java process.  From this point on, I used this technique: <br><br><ol><li>  I put on the output System.in.read () </li><li>  When the program stops in this place, I make a memory dump from jvisualvm </li><li>  Watching a dump with the Eclipse Memory Analysis Tool or jhat </li><li>  Looking for instances of objects whose classes were loaded by my loader </li></ol><br>  Found 5 sources of leakage: <br><br><ol><li>  Local variables </li><li>  Drivermanager </li><li>  ResourceBundle </li><li>  ThreadLocals </li><li>  Exceptions </li></ol><br><div class="spoiler">  <b class="spoiler_title">Local variables</b> <div class="spoiler_text"><h4>  Local variables </h4><br><br>  It turned out that the garbage collector does not consider a local variable to be unreachable until the function containing this variable is completed, even if the variable goes out of scope. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needConnection) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Connection connection = DriverManager.connect()) { ... } } <span class="hljs-comment"><span class="hljs-comment">//    connection   .</span></span></code> </pre><br>  Therefore, to solve the unloading problem of the classifier, it is necessary to quit all functions that use the unloaded classes before calling gc. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Drivermanager</b> <div class="spoiler_text"><h4>  Drivermanager </h4><br>  JDBC drivers when loading their class are registered in the DriverManager class using the registerDriver () method.  Apparently, before unloading, you must call the deregisterDriver () method.  We try. <br><br><pre> <code class="java hljs">Enumeration&lt;Driver&gt; drivers = driverManager.getDrivers(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (drivers.hasMoreElements()) { Driver driver = drivers.nextElement(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (driver.getClass().getClassLoader() == classLoader) { DriverManager.deregisterDriver(driver); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Does not work.  Heapdump has not changed.  We look into the source code of the DriverManager class and find that in the deregisterDriver () method there is a check that the call must be from a class that belongs to the same class as the class that previously called registerDriver ().  And registerDriver () is called by the driver itself from a static initializer.  Unexpected turn. <br><br>  It turns out, we can not directly unregister the driver.  Instead, we have to ask some class from the new classifier to do it on its own behalf.  The solution is to create a special class DriverManagerProxy, more precisely, even two, a class and an interface. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DriverManagerProxy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deregisterDriver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Driver driver)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DriverManagerProxyImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DriverManagerProxy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deregisterDriver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Driver driver)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ DriverManager.deregisterDriver(driver); } }</code> </pre><br>  The interface will be in the main classpath, and the release will be loaded by the new loader from the auxiliary jar file along with the JDBC driver.  Theoretically, one could do without an interface, but then to call the function, one would have to use reflection.  Proxy is used as follows: <br><br><div class="spoiler">  <b class="spoiler_title">Using DriverManagerProxy</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path dir; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> URLClassLoader classLoader; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DriverManagerProxy driverManager; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classLoader = ...; Class.forName(<span class="hljs-string"><span class="hljs-string">"org.jdbc.CustomDriver"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, classLoader); Class&lt;?&gt; dmClass = Class.forName(<span class="hljs-string"><span class="hljs-string">"ru.example.DriverManagerProxyImpl"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, classLoader); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.driverManager = (DriverManagerProxy) dmClass.newInstance(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... Enumeration&lt;Driver&gt; drivers = driverManager.getDrivers(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (drivers.hasMoreElements()) { Driver driver = drivers.nextElement(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (driver.getClass().getClassLoader() == classLoader) { driverManager.deregisterDriver(driver); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.driverManager = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classLoader.close(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classloader = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; System.gc(); System.runFinalization(); <span class="hljs-comment"><span class="hljs-comment">// -    dll if (!delete(this.dir)) { scheduleRemovalToTaskschd(this.dir); } } }</span></span></code> </pre><br></div></div><br></div></div><br><div class="spoiler">  <b class="spoiler_title">ResourceBundle</b> <div class="spoiler_text"><h4>  ResourceBundle </h4><br>  The next hook on the classifier that I was trying to unload was found in the depths of the ResourceBundle class.  Fortunately, unlike DriverManager, ResourceBundle provides a special function, clearCache (), to which the classloader is passed as a parameter. <br><br><pre> <code class="java hljs">ResourceBundle.clearCache(classLoader);</code> </pre><br>  It should be noted that, judging from the source, the ResourceBundle uses weak links that should not interfere with garbage collection.  Perhaps, if you clear all other references to our objects, then you do not need to clear this cache. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">ThreadLocals</b> <div class="spoiler_text"><h4>  ThreadLocals </h4><br>  The last place where the unused driver tails were found was ThreadLocals.  After the DriverManager story, clearing the local flow variables seems like a trifle.  Although it could not do without reflection. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanupThreadLocals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassLoader cl)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; Thread threads[] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread[length]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt = Thread.enumerate(threads); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cnt &gt;= length) { length *= <span class="hljs-number"><span class="hljs-number">2</span></span>; threads = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread[length]; cnt = Thread.enumerate(threads); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cnt; i++) { Thread thread = threads[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (thread == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } cleanupThreadLocals(thread, cl); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanupThreadLocals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Thread thread, ClassLoader cl)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException </span></span>{ Field threadLocalsField = Thread.class.getDeclaredField(<span class="hljs-string"><span class="hljs-string">"threadLocals"</span></span>); threadLocalsField.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Object threadLocals = threadLocalsField.get(thread); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (threadLocals == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Class&lt;?&gt; threadLocalsClass = threadLocals.getClass(); Field tableField = threadLocalsClass.getDeclaredField(<span class="hljs-string"><span class="hljs-string">"table"</span></span>); tableField.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Object table = tableField.get(threadLocals); Object entries[] = (Object[]) table; Class&lt;?&gt; entryClass = table.getClass().getComponentType(); Field valueField = entryClass.getDeclaredField(<span class="hljs-string"><span class="hljs-string">"value"</span></span>); valueField.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Method expungeStaleEntry = threadLocalsClass.getDeclaredMethod(<span class="hljs-string"><span class="hljs-string">"expungeStaleEntry"</span></span>, Integer.TYPE); expungeStaleEntry.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; entries.length; i++) { Object entry = entries[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entry == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } Object value = valueField.get(entry); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { ClassLoader valueClassLoader = value.getClass().getClassLoader(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueClassLoader == cl) { ((java.lang.ref.Reference&lt;?&gt;) entry).clear(); expungeStaleEntry.invoke(threadLocals, i); } } } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Exceptions</b> <div class="spoiler_text"><h4>  Exceptions </h4><br>  We expect the cleanup code to be placed in a finally block.  At the entrance to this block, we should already have everything closed automatically using the try-with-resources mechanism.  However, our classifier will still not be deleted from memory in this place if an exception is thrown from the try block, the class of which is loaded by this classifier. <br><br>  To remove an unwanted exception from memory, it is necessary to catch and process it, and if you need an error all the same, throw it up, then copy the exception to another class.  Here's how I did it in my program: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.getClass().getClassLoader() == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getClass().getClassLoader()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e; } RuntimeException exception = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(String.format(<span class="hljs-string"><span class="hljs-string">"%s: %s"</span></span>, e.getClass(), e.getMessage())); exception.setStackTrace(e.getStackTrace()); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> exception; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (SQLException e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.getClass().getClassLoader() == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getClass().getClassLoader()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e; } SQLException exception = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SQLException(String.format(<span class="hljs-string"><span class="hljs-string">"%s: %s"</span></span>, e.getClass(), e.getMessage())); exception.setStackTrace(e.getStackTrace()); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> exception; }</code> </pre><br></div></div><br><h3>  Java Strikes Back </h3><br>  After clearing all detected references to the unloaded classes, a slightly paradoxical situation has turned out.  There are no objects in memory, judging by the memory dump, the number of instances in all classes is 0. But the classes themselves and their loader have not gone away, and the native library has not been deleted accordingly. <br><br>  To solve the problem it turned out like this: <br><br><pre> <code class="java hljs">System.gc(); System.runFinalization(); System.gc(); System.runFinalization();</code> </pre><br>  Probably, in Java 1.7, which I used, there was some peculiarity of cleaning objects that are in PermGen.  I did not experiment with the garbage collection settings, because I tried to write code that would work equally in different environments, including application servers. <br><br>  After this reception, the code worked as it should, the library was unloaded, the directories were deleted.  However, after the transition to Java 8, the problem returned.  There was no time to figure out what was happening, but apparently, something has changed in the behavior of the garbage collector. <br><br>  Therefore it was necessary to use heavy artillery, namely JMX: <br><br><div class="spoiler">  <b class="spoiler_title">How to make java collect garbage</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dumpHeap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string"><span class="hljs-string">"com.sun.management.HotSpotDiagnosticMXBean"</span></span>); MBeanServer server = ManagementFactory.getPlatformMBeanServer(); Object hotspotMBean = ManagementFactory.newPlatformMXBeanProxy( server, <span class="hljs-string"><span class="hljs-string">"com.sun.management:type=HotSpotDiagnostic"</span></span>, clazz); Method m = clazz.getMethod(<span class="hljs-string"><span class="hljs-string">"dumpHeap"</span></span>, String.class, <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>.class); m.invoke(hotspotMBean, <span class="hljs-string"><span class="hljs-string">"nul"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unused"</span></span>) RuntimeException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unused"</span></span>) ReflectiveOperationException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unused"</span></span>) IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre><br></div></div><br>  Via HotSpotDiagnosticMXBean, we save the memory dump.  We specify nul as the file name, which in Windows means the same as / dev / null in Unix.  The second parameter indicates that only live objects should be uploaded to the dump.  It is this parameter that causes the JVM to do a full garbage collection. <br><br>  After this lifehack, the problem of deleting the library from the temporary directory no longer arose.  The final file cleanup code looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.classLoader = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; System.gc(); System.runFinalization(); System.gc(); System.runFinalization(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!delete(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir)) { dumpHeap(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!delete(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir)) { scheduleRemovalToTaskschd(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir); } }</code> </pre><br><h3>  OSGI Validation </h3><br>  To check the quality of the code, I wrote my JDBC driver, which completely cleans up after itself.  It works like a wrapper around any other driver loaded from a separate classpath. <br><br><div class="spoiler">  <b class="spoiler_title">UnloadableDriver</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnloadableDriver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Driver</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path dir; <span class="hljs-comment"><span class="hljs-comment">//  ,   private URLClassLoader classLoader; private DriverManagerProxy driverManager; private Driver driver; public UnloadableDriver() throws SQLException { ... } @Override public void close() { ... } ... }</span></span></code> </pre><br></div></div><br>  I inserted this driver into the OSGI service on Apache Felix. <br><br><div class="spoiler">  <b class="spoiler_title">JDBCService</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JDBCService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Connection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String url, Properties properties)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Service</span></span>(JDBCService.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JDBCServiceImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JDBCService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> UnloadableDriver driver; <span class="hljs-meta"><span class="hljs-meta">@Activate</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ComponentContext ctx)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.driver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnloadableDriver(); } <span class="hljs-meta"><span class="hljs-meta">@Deactivate</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deactivate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.driver.close(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.driver = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Connection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String url, Properties info)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.driver.connect(url, properties); } }</code> </pre><br></div></div><br>  When the module is started via the Apache Felix system console running on Java 1.8.0_102, a temporary directory with a dll file appears.  The file is locked by the java process.  As soon as the module stops, the directory is deleted automatically.  If instead of UnloadableDriver you use DriverManager and the usual library from Embedded-Artifacts, then after updating the module, the error java.lang.UnsatisfiedLinkError occurs: Native Library already loaded in another classloader. <br><br><h3>  findings </h3><br>  There is no universal way to unload the system dynamic library from a Java machine, but this task is solvable. <br><br>  In Java, there are quite a few places where you can accidentally leave links to your classes, and this is a prerequisite for memory leaks. <br><br>  Even if your code does everything correctly, a leak can be introduced by some library that you are using. <br><br>  Special attention should be paid to cases when the program loads something using the new class loader created during the execution.  If at least one link to one of the loaded classes remains, then the classifier and all its classes will remain in memory. <br><br>  To detect a memory leak, you need to make a dump and analyze with the help of special tools, such as Eclipse MAT. <br><br>  If a memory leak is detected in a third-party library, you can try to fix it with one of the recipes described in the article. </div><p>Source: <a href="https://habr.com/ru/post/313950/">https://habr.com/ru/post/313950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313940/index.html">The digest of interesting materials for the mobile # 177 developer (October 24-30)</a></li>
<li><a href="../313942/index.html">LED Management Tutorial with the Robotics Development Kit</a></li>
<li><a href="../313944/index.html">A few things to know about MaaS</a></li>
<li><a href="../313946/index.html">How to make a sound processor in Zhiguli</a></li>
<li><a href="../313948/index.html">Tips on proportions and scale in games</a></li>
<li><a href="../313958/index.html">Select / Multiselect without JS</a></li>
<li><a href="../313960/index.html">A large number of people in openspace interferes with concentration and leads to frequent diseases.</a></li>
<li><a href="../313962/index.html">The opening of a mobile development studio from scratch in St. Petersburg - 3.5 years later. Reincarnation. Part 3</a></li>
<li><a href="../313964/index.html">What is it, in fact, writing JavaScript in 2016</a></li>
<li><a href="../313966/index.html">Redux-form. When to work with forms is simple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>