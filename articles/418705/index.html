<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Futex basics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Futex (futex - short for ‚ÄúFast userspace mutex‚Äù) is a mechanism proposed by Linux developers from IBM in 2002 and entered the kernel at the end of 200...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Futex basics</h1><div class="post__text post__text-html js-mediator-article">  <b>Futex</b> (futex - short for ‚ÄúFast userspace mutex‚Äù) is a mechanism proposed by Linux developers from IBM in 2002 and entered the kernel at the end of 2003.  The main idea was to provide a more efficient way to synchronize user threads with a minimum number of calls to the OS kernel. <br><br>  In this article we will review the futexes, try to understand the principles of their work, and also use them as building blocks for building higher-level (and familiar to us) synchronization objects. <br><br>  An important point: futexes are quite a low-level tool, it‚Äôs worth using directly only when developing fundamental libraries, like the standard C / C ++ library.  It is very unlikely that you will need to use futexes in a regular application. <br><a name="habracut"></a><br><h3>  Motivation </h3><br>  Before the emergence of futexes to control access to shared resources from multiple threads, it was necessary to make system calls each time (using, for example, <a href="http://man7.org/linux/man-pages/man2/semop.2.html">semop</a> ), which, as is well known, is resource intensive, since each call requires switching the context from user mode to kernel mode.  With the growing number of cores in modern processors and the increasing number of threads in the application software, this has become a significant problem.  It is even more ‚Äúoffensive‚Äù, considering that all these calls do not carry any application function, do not implement any business logic, but only guarantee the correct operation of the rest of the code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The proposal to add a new concept of ‚Äúfutex‚Äù to the OS was based on a simple observation: in most cases, an attempt to capture the synchronization object succeeds the first time.  Programmers write software in such a way that it takes as little time as possible from capturing a lock to its release, which means there are very high chances that an attempt to capture by another stream will not encounter obstacles.  When a thread reaches such a ‚Äúfree‚Äù synchronization object, we can capture it without performing a system call, using relatively cheap atomic operations.  And there is a very big chance that the atomic operation will work successfully. <br><br>  In the rare case when we are still trying to gain access to a resource blocked by another thread, an atomic operation will return an error.  In this case, we have two options.  We can either spin in some user mode spin-lock, waiting for the resource to be released (which will eat up the CPU resources), or ask the kernel to put us into sleep mode, waiting for the resource to be released.  This is where futexes come on the scene. <br><br><h3>  Simple use of futexes - wait and wake up </h3><br>  <a href="http://man7.org/linux/man-pages/man2/futex.2.html">The futex system call</a> combines quite diverse functionality.  We will not consider complex options here (some of them are so elaborate that they are not even described in the official documentation), but focus on the operations FUTEX_WAIT and FUTEX_WAKE.  The description in the official documentation will serve as a good base: <br><blockquote>  The futex () system call provides programs with a method to wait until a particular condition is true.  Typically, this system call uses a blocking construct in the context of shared memory synchronization.  When using futexes, basic synchronization operations are performed in user space.  User-space programs execute the futex () system call only when it is necessary for the program to enter standby mode for a long time until the condition becomes true.  Also futex () can be used to wake up processes or threads waiting for a specific condition. </blockquote>  Simply put, a futex is a kernel-based construct that helps user code synchronize threads in the event of an event.  Some processes (or threads) can wait for events in the FUTEX_WAIT call, while others can trigger these events with FUTEX_WAKE.  Waiting works efficiently - waiting threads are suspended by the kernel and do not use processor resources until they are awakened when an expected event occurs. <br><br>  Do not be lazy to read the documentation in full.  Or at least read the sections on FUTEX_WAIT and FUTEX_WAKE. <br><br>  Let's look at a <a href="">simple example</a> that demonstrates the basic use of futexes to coordinate the work of two processes. <br><br>  Child process: <br><br><ol><li>  Waiting for the value 0xA to appear in the general memory slot </li><li>  Writes 0xB value to this slot. </li></ol><br>  Parent process at this time: <br><br><ol><li>  Writes 0xA value to shared memory slot. </li><li>  Waiting for the value 0xB to appear in it. </li></ol><br>  Such a "handshake" between the two processes.  Here is the code: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shm_id = shmget(IPC_PRIVATE, <span class="hljs-number"><span class="hljs-number">4096</span></span>, IPC_CREAT | <span class="hljs-number"><span class="hljs-number">0666</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shm_id &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"shmget"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* shared_data = shmat(shm_id, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); *shared_data = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> forkstatus = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   printf("child waiting for A\n"); wait_on_futex_value(shared_data, 0xA); printf("child writing B\n"); //  0xB         *shared_data = 0xB; wake_futex_blocking(shared_data); } else { //   printf("parent writing A\n"); //  0xA         *shared_data = 0xA; wake_futex_blocking(shared_data); printf("parent waiting for B\n"); wait_on_futex_value(shared_data, 0xB); // Wait for the child to terminate. wait(NULL); shmdt(shared_data); } return 0; }</span></span></code> </pre> <br>  Note the POSIX calls for allocating shared memory between processes.  We could not use normal memory allocation here, since even the same pointer addresses in different processes would in fact indicate different blocks of memory (unique for each process). <br><br>  It should be noted that this example somewhat deviates from the canons, because the futex was originally created to wait for a change in some value "from something concrete to anything," and not "from anything to something concrete."  I gave this example in order to demonstrate this possibility, and below we will consider the basic variant (on it we implement the mutex). <br><br>  And here is the wait_on_futex_value function code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_on_futex_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAIT, val, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno != EAGAIN) { perror(<span class="hljs-string"><span class="hljs-string">"futex"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*futex_addr == val) { <span class="hljs-comment"><span class="hljs-comment">//    return; } } else { abort(); } } }</span></span></code> </pre> <br>  The main task of this function (besides, actually, the futex system call) is a cycle in which we run in a false (not interesting) awakening.  This can happen when installing a new, but not expected value in a shared memory slot.  Well, or in the case when another process was awakened before ours (this cannot happen in our particular case, but more generally it is possible). <br><br>  Futex semantics - tricky enough!  The call FUTEX_WAIT will return immediately if the value at the futex address is not equal to the argument val.  In our case, this can happen if the child process waited before the parent wrote the value 0xA in the slot.  Futex in this case will return the value of EAGAIN. <br><br>  And here is the wake_futex_blocking function code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake_futex_blocking</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAKE, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"futex wake"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }</code> </pre> <br>  This is a blocking wrapper over FUTEX_WAKE that will quickly work out and return value, no matter how many listeners expect it.  In our example, this is used as part of a handshake, but other uses are possible. <br><br><h3>  Futexes are kernel queues for custom code. </h3><br>  Simply put, futex is a queue managed by the kernel to solve user code problems.  It allows the user code to request the kernel to suspend the execution of its thread until a certain event occurs, and another thread at the same time to signal this event and wake up all the threads waiting for it.  Earlier we mentioned the possibility to organize spin-lok in user mode, waiting for the fulfillment of some condition.  However, the queue in the core is a much better alternative, because it saves us from wasting billions of burned processor instructions that are executed in the wait cycle. <br><br>  Here is the diagram from the <a href="https://lwn.net/Articles/360699/">‚ÄúA futex overview and update‚Äù</a> article on LWN: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/476/433/d4e/476433d4e5a9ba7dcd840a7fe5eb3d87.png" alt="image"><br><br>  In the Linux kernel code, futexes are implemented in kernel / futex.c.  The kernel stores a hash table, where the keys are addresses - to quickly search for the desired queue and add the calling process to it.  Everything, of course, is not so simple - after all, the kernel itself needs to synchronize access to the data inside, plus support any additional options of futexes. <br><br><h3>  Timeout with FUTEX_WAIT </h3><br>  The futex system call has a timeout parameter that allows the user to specify how long he is willing to wait.  Here is a complete <a href="">example of</a> where this is implemented, but its key part: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child waiting for A\n"</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class"> = {</span></span>.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>, .tv_nsec = <span class="hljs-number"><span class="hljs-number">500000000</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> t1 = time_ns(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(shared_data, FUTEX_WAIT, <span class="hljs-number"><span class="hljs-number">0xA</span></span>, &amp;timeout, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child woken up rc=%d errno=%s, elapsed=%llu\n"</span></span>, futex_rc, futex_rc ? strerror(errno) : <span class="hljs-string"><span class="hljs-string">""</span></span>, time_ns() - t1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; *shared_data == <span class="hljs-number"><span class="hljs-number">0xA</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  If the wait is delayed for 500 ms, then the futex function will end, and at the next iteration of the cycle we can somehow react to this (display something on the screen, write to the log, continue the wait or stop). <br><br><h3>  Use futex for implementing mutex </h3><br>  We began this article by saying that futexes have practical benefits when implementing higher-level synchronization objects.  Let's try using them (and also atomics) to implement a classic mutex.  The implementation below is based on the code from the article ‚ÄúFutexes are Tricky‚Äù written by Ulrich Drepper. <br><br>  For this example, I use C ++, mainly to be able to use atomics from the C ++ 11 standard.  You can find the full code <a href="">here</a> , but the most important part of it is: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() : atom_(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = cmpxchg(&amp;atom_, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If the lock was previously unlocked, there's nothing else for us to do. // Otherwise, we'll probably have to wait. if (c != 0) { do { // If the mutex is locked, we signal that we're waiting by setting the // atom to 2. A shortcut checks is it's 2 already and avoids the atomic // operation in this case. if (c == 2 || cmpxchg(&amp;atom_, 1, 2) != 0) { // Here we have to actually sleep, because the mutex is actually // locked. Note that it's not necessary to loop around this syscall; // a spurious wakeup will do no harm since we only exit the do...while // loop when atom_ is indeed 0. syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAIT, 2, 0, 0, 0); } // We're here when either: // (a) the mutex was in fact unlocked (by an intervening thread). // (b) we slept waiting for the atom and were awoken. // // So we try to lock the atom again. We set teh state to 2 because we // can't be certain there's no other thread at this exact point. So we // prefer to err on the safe side. } while ((c = cmpxchg(&amp;atom_, 0, 2)) != 0); } } void unlock() { if (atom_.fetch_sub(1) != 1) { atom_.store(0); syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAKE, 1, 0, 0, 0); } } private: // 0 means unlocked // 1 means locked, no waiters // 2 means locked, there are waiters in lock() std::atomic&lt;int&gt; atom_; };</span></span></code> </pre><br>  In this code, the cmpxhg function is a simple wrapper for more convenient use of atomics: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An atomic_compare_exchange wrapper with semantics expected by the paper's // mutex - return the old value stored in the atom. int cmpxchg(std::atomic&lt;int&gt;* atom, int expected, int desired) { int* ep = &amp;expected; std::atomic_compare_exchange_strong(atom, ep, desired); return *ep; }</span></span></code> </pre> <br>  This code example contains many comments explaining the logic of its operation.  This does not hurt, because there is a significant risk that you will want to write a slightly simpler, but completely wrong version of it.  As for this code, it is not perfect either.  For example, he tries to make an assumption about the internal structure of the std :: atomic type, casting its contents to int * for transfer to the futex call.  This is generally not the case.  The code compiles and runs on Linux x64, but we have no guarantee of compatibility with other platforms.  To get it - we need to add a layer of platform dependency for atomics.  Since this is not the topic of this article (and also because it is very unlikely that you will mix in one C ++ module and futexes) we will omit this implementation.  This is just a demonstration! <br><br><h3>  Glibc mutexes and low-level locks </h3><br>  And here we come to how glibc implements POSIX threads, of which the pthread_mutex_t type is a part.  As I said at the beginning of this article, futexes are not exactly the thing that an ordinary developer will need.  They are used by runtime libraries or by something very specialized for implementing higher level synchronization primitives.  In this context, it is interesting to look at the <a href="https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library">NPTL</a> mutex implementation.  In the glibc code, this is the nptl / pthread_mutex_lock.c file. <br><br>  The code is rather complicated due to the need to support various types of mutexes, but we can find quite familiar blocks if we wish.  You can also take a look at the files sysdeps / unix / sysv / linux / x86_64 / lowlevellock.h and nptl / lowlevellock.c.  The code is somewhat confusing, but the combination of comparison-and-exchange and futex calls is easy. <br><br>  The initial comment of the systeds / nptl / lowlevellock.h file should already be well understood: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Low-level locks use a combination of atomic operations (to acquire and release lock ownership) and futex operations (to block until the state of a lock changes). A lock can be in one of three states: 0: not acquired, 1: acquired with no waiters; no other threads are blocked or about to block for changes to the lock state, &gt;1: acquired, possibly with waiters; there may be other threads blocked or about to block for changes to the lock state. We expect that the common case is an uncontended lock, so we just need to transition the lock between states 0 and 1; releasing the lock does not need to wake any other blocked threads. If the lock is contended and a thread decides to block using a futex operation, then this thread needs to first change the state to &gt;1; if this state is observed during lock release, the releasing thread will wake one of the potentially blocked threads. .. */</span></span></code> </pre> <br><h3>  Runes in Runtime Go </h3><br>  Runtime Go does not use libc (in most cases).  Thus, it cannot rely on the implementation of POSIX threads.  Instead, it directly calls the underlying system calls.  This makes it a good example of the use of futexes.  Since there is no way to call pthread_mutex_t, you have to write your replacement.  Let's see how this is done, let's start with the sync.Mutex type visible to the user (in src / sync / mutex.go). <br><br>  The Lock method of this type tries to use an atomic exchange operation (swap) to quickly capture a lock.  If it turns out that you need to wait, it calls runtime_SemacquireMutex, which calls runtime.lock.  This function is defined in src / runtime / lock_futex.go and it declares several constants that you might already find familiar: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( mutex_unlocked = <span class="hljs-number"><span class="hljs-number">0</span></span> mutex_locked = <span class="hljs-number"><span class="hljs-number">1</span></span> mutex_sleeping = <span class="hljs-number"><span class="hljs-number">2</span></span> ... ) <span class="hljs-comment"><span class="hljs-comment">// Possible lock states are mutex_unlocked, mutex_locked and mutex_sleeping. // mutex_sleeping means that there is presumably at least one sleeping thread.</span></span></code> </pre><br>  runtime.lock also tries to lock a lock with an atomic function.  This makes sense, since runtime.lock is called in many places of Go runtime, but it seems to me that we could somehow optimize the code by removing two consecutive atom-function calls when calling runtime.lock from Mutex.lock. <br><br>  If it turns out that you have to wait, the platform-specific function futexsleep is called, which is defined for Linux in the src / runtime / os_linux.go file.  This function makes a futex system call with the code FUTEX_WAIT_PRIVATE (in this case, this is appropriate since the Go runtime lives in the same process). </div><p>Source: <a href="https://habr.com/ru/post/418705/">https://habr.com/ru/post/418705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418687/index.html">The 3.5 "revolution: details of a small diskette boom with wavepave music</a></li>
<li><a href="../418689/index.html">How to create a library of components in Figma, saving the budget, for example, an online auction</a></li>
<li><a href="../418691/index.html">Rancher: Kubernetes in 5 minutes on bare iron</a></li>
<li><a href="../418695/index.html">Anti-Piracy Wars - The Empire Strikes Back</a></li>
<li><a href="../418699/index.html">Creating an emulator arcade machine. Part 3</a></li>
<li><a href="../418709/index.html">You need to force yourself: drivers and barriers in interfaces</a></li>
<li><a href="../418711/index.html">Token-Managed Registries 1.0</a></li>
<li><a href="../418713/index.html">Game to improve the quality of Wikipedia</a></li>
<li><a href="../418715/index.html">How effective is the procfs virtual file system and can it be optimized?</a></li>
<li><a href="../418717/index.html">Ghosts in Unicode</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>