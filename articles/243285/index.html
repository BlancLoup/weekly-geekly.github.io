<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Likbez: image resize methods</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Why an image scaled with bicubic interpolation does not look like in Photoshop. Why one program resizes quickly and the other does not, although the r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Likbez: image resize methods</h1><div class="post__text post__text-html js-mediator-article">  Why an image scaled with bicubic interpolation does not look like in Photoshop.  Why one program resizes quickly and the other does not, although the result is the same.  Which resize method is better for increasing and which for reducing.  What filters do and how do they differ. <br><br>  In general, this was an introduction to another article, but it dragged on and turned into a separate material. <br><br><img src="https://habrastorage.org/files/d7b/6a5/fee/d7b6a5fee46b48cea427442b87ec65be.jpg" width="640" height="427"><br>  <font color="#888">This person sits among the daisies to get your attention to the article.</font> <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For visual comparison, I will use images of the same resolution of 1920 √ó 1280 ( <a href="">one</a> , the <a href="">second</a> ), which will result in sizes of 330 √ó 220, 1067 √ó 667 and 4800 √ó 3200.  Under the illustrations it will be written how many milliseconds it took to resize this or that resolution.  The numbers are given only to understand the complexity of the algorithm, so the specific hardware or software on which they are obtained is not so important. <br><br><a name="nearest-neighbor"></a><br><h3>  Nearest neighbor <font color="#888">(Nearest neighbor)</font> </h3><br>  This is the most primitive and fast method.  For each pixel of the final image, one pixel of the source image is selected that is closest to its position, taking into account scaling.  This method gives a pixelated image when zoomed in and a highly grainy image when zoomed out. <br><br><img src="https://habrastorage.org/files/5ec/df1/7a0/5ecdf17a09f842a0a89904ebf1808929.png" width="480" height="188"><br><br>  In general, the quality and performance of any reduction method can be estimated by the ratio of the number of pixels involved in the formation of the final image to the number of pixels in the original image.  The greater this ratio, the more likely the algorithm is better and slower.  A ratio equal to one means that at least each pixel of the original image has contributed to the final.  But for advanced methods, it may be more than one.  So here, if for example we reduce the image by the method of the nearest neighbor by 3 times on each side, then this ratio is 1/9.  Those.  most of the original pixels are not taken into account. <br><br><img src="https://habrastorage.org/files/5de/5ab/390/5de5ab390d9341c68bce924c1cf86bb8.jpg" width="330" height="220"><img src="https://habrastorage.org/files/d33/cb6/e8b/d33cb6e8b4c2417b806e3f002f3de558.jpg" width="330" height="220"><br><img src="https://habrastorage.org/files/78c/8aa/86d/78c8aa86dd2f4c35ba5a08a91683c124.jpg" width="330" height="220"><img src="https://habrastorage.org/files/9ef/e08/be1/9efe08be1c7947ab9d62bed21fd21c30.jpg" width="330" height="220"><br><img src="https://habrastorage.org/files/c37/746/af6/c37746af6e9940439f79943d3ce79b6b.jpg" width="330" height="220"><img src="https://habrastorage.org/files/eda/249/ddf/eda249ddff424157a6716ac8dce12d0d.jpg" width="330" height="220"><br> <code>1920√ó1280 ‚Üí 330√ó220 = 0,12 ms</code> <br> <code>1920√ó1280 ‚Üí 1067√ó667 = 1,86 ms</code> <br> <code>1920√ó1280 ‚Üí 4800√ó3200 = 22,5 ms</code> <br> <br>  The theoretical speed depends only on the size of the final image.  In practice, with a decrease, processor cache misses make a contribution: the smaller the scale, the less data is used from each line loaded into the cache. <br><br>  The method is consciously used to reduce extremely rarely, because  gives a very poor quality, although it can be useful with the increase.  Because of the speed and ease of implementation, it is in all libraries and applications that work with graphics. <br><br><a name="affine-transformations"></a><br><h3>  Affine transformations </h3><br>  Affine transformations are a common method for image distortion.  They allow you to rotate, stretch and reflect the image in one operation.  Therefore, in many applications and libraries implementing the method of affine transformations, the function of changing images is simply a wrapper that calculates the coefficients for the transformation. <br><br>  The principle of operation is that for each point of the final image a fixed set of points of the source is taken and interpolated in accordance with their mutual position and the selected filter.  The number of points also depends on the filter.  For bilinear interpolation, 2x2 source pixels are taken, for bicubic 4x4.  This method gives a smooth image when zoomed in, but with a decrease the result is very similar to the nearest neighbor.  See for yourself: theoretically, with a bicubic filter and a 3-fold decrease, the ratio of processed pixels to the original is 4¬≤ / 3¬≤ = 1.78.  In practice, the result is much worse.  in existing implementations, the filter window and the interpolation function are not scaled according to the image scale, and the pixels closer to the edge of the window are taken with negative coefficients (according to the function), i.e.  do not make a useful contribution to the final image.  As a result, the image reduced with the bicubic filter differs from the image reduced with the bilinear one, only in that it is even clearer.  Well, for a bilinear filter and a reduction of three times the ratio of processed pixels to the original is 2¬≤ / 3¬≤ = 0.44, which is not fundamentally different from the nearest neighbor.  In fact, affine transformations cannot be used to reduce more than 2 times.  And even with a decrease to two times, they give noticeable ladder effects for lines. <br><br>  Theoretically, there should be implementations of exactly affine transformations, scaling the filter window and the filter itself in accordance with the given distortions, but I have not seen such in popular open source libraries. <br><br><img src="https://habrastorage.org/files/4bb/ab7/9cb/4bbab79cbb1445e4ab1e1d39e9066438.jpg" width="330" height="220"><img src="https://habrastorage.org/files/6a3/a61/65c/6a3a6165cd89408ba121476d1f612c28.jpg" width="330" height="220"><br><img src="https://habrastorage.org/files/68c/580/ce2/68c580ce20a34de8a7f590b40ae0313e.jpg" width="330" height="220"><img src="https://habrastorage.org/files/6da/8c9/84c/6da8c984c1d44d76bcdecd84db250491.jpg" width="330" height="220"><br><img src="https://habrastorage.org/files/710/758/e97/710758e9783d4bc5ba025a25bb95526f.jpg" width="330" height="220"><img src="https://habrastorage.org/files/cd0/e33/30c/cd0e3330c013491db84e1825597bbca0.jpg" width="330" height="220"><br> <code>1920√ó1280 ‚Üí 330√ó220 = 6.13 ms</code> <br> <code>1920√ó1280 ‚Üí 1067√ó667 = 17.7 ms</code> <br> <code>1920√ó1280 ‚Üí 4800√ó3200 = 869 ms</code> <br> <br>  The running time is noticeably longer than that of the nearest neighbor, and depends on the size of the final image and the window size of the selected filter.  From cache misses already almost does not depend, because  source pixels are used at least two. <br><br>  My humble opinion that using this method to arbitrarily reduce images is simply <b>a bug</b> , because the result is very bad and looks like the nearest neighbor, and you need much more resources for this method.  However, this method has found wide application in programs and libraries.  The most surprising is that this method is used in all browsers for the <code>drawImage()</code> canvas method (a <a href="http://jsbin.com/koyifazese/1/edit%3Fjs,output">visual example</a> ), although for a simple display of pictures in an element, more accurate methods are used (except IE, it uses affine transformations for both cases).  In addition, this method is used in OpenCV, the current version of the Python library Pillow (I hope to write about this separately) in Paint.NET. <br><br>  In addition, this method is used by graphics cards for rendering three-dimensional scenes.  But the difference is that the video cards for each texture prepare in advance a set of reduced versions (mip levels), and for the final rendering a level is selected with such a resolution that the texture reduction is no more than two times.  In addition, to eliminate a sharp jump when changing a mip-level (when a textured object approaches or moves away), linear interpolation between adjacent mip-levels is used (this is already trilinear filtering).  Thus, to draw each pixel of a three-dimensional object, it is necessary to interpolate between 2¬≥ ‚Äã‚Äãpixels.  This gives a result that is acceptable for fast moving images in a time that is linear with respect to the final resolution. <br><br><a name="supersampling"></a><br><h3>  <font color="#888">Supersampling</font> </h3><br>  With this method, the very mip-levels are created, with the help of it (if greatly simplified) full-screen anti-aliasing works in games.  Its essence is in splitting the original image into a grid of final pixels and folding all the original pixels falling on each pixel of the final one in accordance with the area that falls under the final pixel.  When using this method to increase, for each pixel of the final image there is exactly one pixel of the original.  Therefore, the result to increase is equal to the nearest neighbor. <br><br><img src="https://habrastorage.org/files/8ba/fcb/d57/8bafcbd57dd843ba824f36e0bbaca7c5.png" width="240" height="200"><img src="https://habrastorage.org/files/a4f/826/bde/a4f826bde73a403aac0e2c95fec8a022.png" width="240" height="200"><br><br>  Two subspecies of this method can be distinguished: with the rounding of the borders of pixels to the nearest whole number of pixels and without.  In the first case, the algorithm becomes unsuitable for scaling less than 3 times, because for any one final pixel there may be one source, and for the next one - four (2x2), which leads to imbalances at the local level.  At the same time, the algorithm with rounding can obviously be used in cases when the size of the original image is a multiple of the size of the final image, or the reduction scale is rather small (the versions with a resolution of 330 √ó 220 are almost the same).  The ratio of processed pixels to the original when rounding borders is always one. <br><br><img src="https://habrastorage.org/files/739/600/6b3/7396006b3bb24ba9833d3b3c5bd212c0.jpg" width="330" height="220"><img src="https://habrastorage.org/files/115/b0d/990/115b0d990fd14cebb2294ea4cb61dade.jpg" width="330" height="220"><br><img src="https://habrastorage.org/files/8eb/3d7/0cd/8eb3d70cde9a4251bd0b6ba3b34d865d.jpg" width="330" height="220"><img src="https://habrastorage.org/files/da6/bca/0a3/da6bca0a343047ec9bb9ec7f035b59b8.jpg" width="330" height="220"><br><img src="https://habrastorage.org/files/749/e94/c42/749e94c4260745e49f4772d0f181d4b3.jpg" width="330" height="220"><img src="https://habrastorage.org/files/753/dfc/4eb/753dfc4eb9b7492191176e1a28341b8d.jpg" width="330" height="220"><br> <code>1920√ó1280 ‚Üí 330√ó220 = 7 ms</code> <br> <code>1920√ó1280 ‚Üí 1067√ó667 = 15 ms</code> <br> <code>1920√ó1280 ‚Üí 4800√ó3200 = 22,5 ms</code> <br> <br>  The subspecies without rounding gives excellent quality while decreasing at any scale, and with increasing gives a strange effect when most of the original pixel on the final image looks homogeneous, but at the edges a transition is visible.  The ratio of processed pixels to the original without the rounding of borders can be from one to four, because each source pixel contributes either to one final pixel, or to two adjacent ones, or to four neighboring pixels. <br><br><img src="https://habrastorage.org/files/a42/249/d8c/a42249d8c92e44399db23182c2a7f447.png" width="330" height="220"><img src="https://habrastorage.org/files/c69/ed6/42f/c69ed642f3594f828bb6f90bdfce1e4b.png" width="330" height="220"><br><img src="https://habrastorage.org/files/7b9/aab/406/7b9aab4069d540589ac25fa33c77ac02.png" width="330" height="220"><img src="https://habrastorage.org/files/158/8e0/11e/1588e011e2f64b2bbdb5ac1fb13660f6.png" width="330" height="220"><br><img src="https://habrastorage.org/files/68c/3f3/a13/68c3f3a13c1744d883f577d7f1ae8aab.png" width="330" height="220"><img src="https://habrastorage.org/files/a86/5b3/90f/a865b390f2d24779b033106cebbf9edf.png" width="330" height="220"><br> <code>1920√ó1280 ‚Üí 330√ó220 = 19 ms</code> <br> <code>1920√ó1280 ‚Üí 1067√ó667 = 45 ms</code> <br> <code>1920√ó1280 ‚Üí 4800√ó3200 = 112 ms</code> <br> <br>  The performance of this method to reduce is lower than that of affine transformations, because all the pixels of the original are involved in the calculation of the final image.  The version with rounding to the nearest borders is usually several times faster.  It is also possible to create separate versions for scaling a fixed number of times (for example, a decrease of 2 times), which will be even faster. <br><br>  This method is used in the <code>gdImageCopyResampled()</code> function of the GD library included in PHP in the OpenCV (INTER_AREA flag), Intel IPP, AMD Framewave.  About the same principle works libjpeg, when it opens images in a reduced form several times.  The latter allows many applications to open JPEG images in advance reduced several times without any special overhead (in practice, libjpeg opens thumbnails even a little faster than full-sized ones) and then apply other methods to resize to exact sizes.  For example, if you want to regenerate JPEG with a resolution of 1920 √ó 1280 to a resolution of 330 √ó 220, you can open the original image at a resolution of 480 √ó 320 and then reduce it to the desired 330 √ó 220. <br><br><a name="convolution"></a><br><h3>  Convolutions <font color="#888">(Convolution)</font> </h3><br>  This method is similar to affine transformations in that filters are used, but it has not a fixed window, but a window proportional to the scale.  For example, if the filter window size is 6, and the image size is reduced 2.5 times, then (2.5 * 6) ¬≤ = 225 pixels takes part in the formation of each pixel of the final image, which is much more than in the case of supersampling (from 9 to 16).  Fortunately, convolutions can be considered in 2 passes, first in one direction, then in another, therefore the algorithmic complexity of calculating each pixel is not 225, but only (2.5 * 6) * 2 = 30. The contribution of each source pixel to the final one is times determined by the filter.  The ratio of processed pixels to the original is entirely determined by the size of the filter window and is equal to its square.  Those.  for a bilinear filter, this ratio will be 4, for bicubic 16, for Lanczos 36. The algorithm works fine for both reduction and increase. <br><br><img src="https://habrastorage.org/files/377/b37/de6/377b37de67134e5ebf3753fcbe234b31.jpg" width="330" height="220"><img src="https://habrastorage.org/files/e06/a4a/2ae/e06a4a2ae0f047e29c3993b31f91d203.jpg" width="330" height="220"><br><img src="https://habrastorage.org/files/4c4/8f4/e48/4c48f4e48d7042fdb9162274d63f9bbf.jpg" width="330" height="220"><img src="https://habrastorage.org/files/e0d/829/e99/e0d829e9993442b0add881cf624dd411.jpg" width="330" height="220"><br><img src="https://habrastorage.org/files/724/49b/b7d/72449bb7d72d4f83bb088d51621a0375.jpg" width="330" height="220"><img src="https://habrastorage.org/files/d6e/61b/1ac/d6e61b1ac48f4f80a2e57a188de03eb9.jpg" width="330" height="220"><br> <code>1920√ó1280 ‚Üí 330√ó220 = 76 ms</code> <br> <code>1920√ó1280 ‚Üí 1067√ó667 = 160 ms</code> <br> <code>1920√ó1280 ‚Üí 4800√ó3200 = 1540 ms</code> <br> <br>  The speed of this method depends on all parameters: the size of the original image, the size of the final image, the size of the filter window. <br><br>  This method is implemented in ImageMagick, GIMP, in the current version of Pillow with the ANTIALIAS flag. <br><br>  One of the advantages of this method is that filters can be defined by a separate function that is not tied to the implementation of the method.  At the same time, the function of the filter itself can be quite complex without much loss of performance, because the coefficients for all pixels in one column and for all pixels in one line are counted only once.  Those.  the filter function itself is called only (m + n) * w times, where m and n are the dimensions of the final image, and w is the size of the filter window.  And to rivet these functions can be many, it would be a mathematical justification.  In ImageMagick, for example, there are 15. Here‚Äôs what the most popular look like: <br><br>  Bilinear filter ( <code>bilinear</code> or <code>triangle</code> in ImageMagick) <br><img src="https://habrastorage.org/files/2b7/8f5/538/2b78f5538ea440b496e9f77bebfa290c.png" width="572" height="239"><br>  Bicubic filter ( <code>bicubic</code> , <code>catrom</code> in ImageMagick) <br><img src="https://habrastorage.org/files/cc1/ce2/998/cc1ce29988fb471a848626101cdca7d0.png" width="572" height="239"><br>  Lanczos filter <br><img src="https://habrastorage.org/files/f25/c5f/112/f25c5f112eb94c8ba41f981db21b20d0.png" width="572" height="239"><br><br>  It is noteworthy that some filters have zones of negative coefficients (such as a bicubic filter or a Lanczos filter).  This is necessary to make the transitions in the final image sharpen, which was the original. </div><p>Source: <a href="https://habr.com/ru/post/243285/">https://habr.com/ru/post/243285/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243275/index.html">Virtual hackathon with a prize fund of $ 30,000 in early December</a></li>
<li><a href="../243277/index.html">Expressive javascript: Project: programming language</a></li>
<li><a href="../243279/index.html">Apple commented on the situation with the Masque vulnerability in iOS</a></li>
<li><a href="../243281/index.html">New dangerous vulnerability discovered in Windows</a></li>
<li><a href="../243283/index.html">Create products, shape habits. Interview with Nir Eyal</a></li>
<li><a href="../243291/index.html">Java: IP telephony from scratch</a></li>
<li><a href="../243295/index.html">ReactOS 0.3.17 - ‚Äúnumerological‚Äù release of the operating system</a></li>
<li><a href="../243297/index.html">My first Eclipse plugin</a></li>
<li><a href="../243301/index.html">Loading Eloquent links using left join instead of additional requests</a></li>
<li><a href="../243305/index.html">Creating plug-ins for AutoCAD using the .NET API (Part 2 - Working with Ribbon [Ribbon])</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>