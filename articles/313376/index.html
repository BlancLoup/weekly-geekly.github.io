<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Soviet "Elbrus" - an overview of the architecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About the subject of the article goes a lot of speculation - from the "Russian Barrows" to "unparalleled." This is due in no small measure to the lack...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Soviet "Elbrus" - an overview of the architecture</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/789/51e/e73/78951ee7320947dea403fce966608210.PNG" alt="image"></div><br>  About the subject of the article goes a lot of speculation - from the "Russian Barrows" to "unparalleled."  This is due in no small measure to the lack of (accessible) full-fledged documentation, the few people who have dealt with them, and even a considerable amount of time that has passed since then.  "Elbrus" has become one of the myths of a bygone era. <br><br>  On the other hand, the computing complex undoubtedly existed and showed excellent results for its time.  Perhaps due to the scarcity of the element base, which forced developers to invent various kinds of architectural tricks.  Many of these tricks now look archaic, and some are quite relevant. <br><br>  So the author, out of his inquisitive curiosity, tried to figure out the available documentation and create a more or less coherent picture.  If the reader is interested in it - welcome under cat. <br><a name="habracut"></a><br><h3>  Element base </h3><br>  A new generation of technology arises not when a new generation of engineers has grown up, but on the basis of qualitative changes in technology.  As for the Soviet ‚ÄúElbrus‚Äù, such a change was the emergence of integrated circuits.  For the "Elbrus-1", it was <a href="http://www.155la3.ru/k133.htm">133</a> chip <a href="http://www.155la3.ru/k133.htm">series</a> with <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B7%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D1%2580%25D0%25BD%25D0%25BE-%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B7%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D1%2580%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25BA%25D0%25B0">TTL</a> logic (speed 10 ... 15 ns per valve).  For the "Elbrus-2" - the <a href="http://www.155la3.ru/k100.htm">100th series</a> with ECL logic (speed 2 ns per valve). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      100 series is made (serial production since 1974) on the basis of MECL 10K from <a href="https://ru.wikipedia.org/wiki/Motorola">Motorola</a> (since 1971) [6].  133 series (since 1969) was based on 54 series from <a href="https://en.wikipedia.org/wiki/Texas_Instruments">TI</a> (since 1965) [6].  Those.  there was no particular lag in the element base at that time. <br><br><h3>  Memory organization </h3><br><h4>  Physical memory </h4><br>  The memory subsystem was built on the basis of the <a href="https://ru.wikipedia.org/wiki/%25D0%259A565%25D0%25A0%25D0%25A33">K565RU3B</a> ( <a href="https://ru.wikipedia.org/wiki/N-%25D0%259C%25D0%259E%25D0%259F">NMOP</a> ) <a href="https://ru.wikipedia.org/wiki/N-%25D0%259C%25D0%259E%25D0%259F">microcircuit</a> [3] with a capacity of 16Kbit and an organization of 16384x1. <br><br>  Equipment correction and control allows you to correct single and detect double errors when reading information.  To this end, eight bits of the Hamming code are formed and added to the 72-bit information word when recording.  Thus, the word stored in the memory contains 80 bits, including: 8 - control information (tag), 64 - data, 8 - check bits of the Hamming code. <br><br>  The address bus has a capacity of - 24, i.e.  The size of physical memory is limited to 16 mega-words (72 bits each), 144 MB of data along with tags. <br><br>  If we read along with the Hamming codes, we get 180 MB or 90 Kmcircume.  All this was possible for the maximum configuration to place in 8 cabinets (sections OP). <br><br>  In the maximum configuration includes 10 processors, with each processor connected to each section of the OP.  The length of the communication lines is chosen approximately equal to 10 m from the condition of placement of devices of the complex.  This length of light flies in vacuum for ~ 1/30000000 seconds (33 ns).  In E-2, the signals are transmitted from the output register of the transmitting station to the receiver register in 80 ns (with a 44 ns duty cycle), which is very good. <br><br>  Each memory cabinet (OP section) consists of four memory modules and a switch.  The modules are functionally independent and can simultaneously exchange information with different processors.  Only 32 modules, each with half a mega-word.  With group access, all four modules are started simultaneously.  This allows you to get the maximum rate of data exchange with the OP section. <br><br>  The module's operation cycle is 13 clocks, however, successive calls to different chips of one group can be serviced every seven clocks. <br><br>  At the lower level, the minimum block size - 16K words corresponds to the memory chip size of 16K bits.  The block consists of 80 memory microcircuits, one microcircuit per discharge.  Therefore, the memory module consists of 32 such minimum blocks. <br><br><h4>  The exchange device with RAM </h4><br>  It is part of the processor.  It has a separate communication channel from each of the eight sections of the OP and can apply to each section both with single and with group requests. <br><br>  In a group query, four words are exchanged in one call.  The memory write access time for ECP is about eight clocks, the read memory retrieval time is about 20 clocks (the access can be delayed by the OU switch in case the memory module is busy or a conflict occurs with another CPU). <br><br>  At the same time, up to three requests can be stored in the Unit.  The Unitary Public Organization has internal paralleling into two channels, which makes it possible to simultaneously set two exchange requests to different sections of the OP.  The maximum frequency of a channel change is one request per eight cycles.  Thus, with group calls to the memory, the Unit will ensure the <b>rate of exchange - one word per clock</b> [1]. <br><br>  To optimize the work with a sequential crawl of addresses, a splitting technique (interleaving) is used.  Some of the bits in the physical address are intermixed, as a result, successive words appear in different units of the above described memory hierarchy and can be read in parallel.  The mixing scheme is as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/566/6f7/8a4/5666f78a4863416b84a4d378be31c2ed.PNG" alt="image"></div><br>  When excluding individual modules from the configuration, the operating system does not assign their addresses.  The presence of a disabled module makes splitting impossible in this section. <br><br><h3>  Mathematical (virtual) memory </h3><br>  Mathematical memory is described by a 38-bit mathematical address, provided that the placement of the value with an accuracy of one digit is indicated (with a 32-bit address when specified with an accuracy of a machine word). <br><br><h4>  Values </h4><br>  The basic unit of information is value.  Value is the logical unit of information that can be addressed using a mathematical address.  Values ‚Äã‚Äãare performed on operations when executing program commands. <br><br>  Values ‚Äã‚Äãcan have the following sizes in bits (formats): 1, 4, 8, 16, 32, 64, 128. <br><br>  None of the values ‚Äã‚Äãother than 128-bit can be located in more than one word. <br><br>  A single word can contain values ‚Äã‚Äãof only the same type and format, with one exception: the whole and real format of 32 bits can be packed in one word in any order. <br><br>  The control bits of the word stores information about the type and format of the values ‚Äã‚Äãthat are in the word. <br><br><h4>  Pages </h4><br>  Mathematical memory is paginated.  Pages can be of various sizes (multiples of 16) - from 16 to 1024 words.  The address of the beginning of the page has the lowest 10 (out of 38) digits of zero [2 p.61]. <br><br>  A block of 16 words located in a mathematical memory so that in the 38-bit address of the first word the lower 10 digits are zero, is called a string. <br><br><h4>  Segments </h4><br>  Segments are continuous addressing areas allocated by the system.  The beginning of any segment in mathematical memory coincides with the beginning of a certain page. <br><br>  To place a segment, use the page of the smallest possible size.  Segments larger than 1024 words are placed in mathematical memory on adjacent pages, and all pages, except the last, should have a maximum size. <br><br>  The beginning of the page, and therefore the segment, in physical memory can be placed at the beginning of any physical line.  The page is located in adjacent cells of physical memory. <br><br>  Therefore, a segment larger than 1024 words may not be fully present in physical memory (swapping), and its pages in physical memory are not required to go in a row. <br><br><h4>  Virtual memory support. </h4><br>  Virtual memory is organized in a rather logical and natural way.  Segments are created by the OS kernel, which is inevitable, given the tag system and memory protection issues. <br><br>  All free memory areas in the kernel are combined into an ordered list of free areas.  Ordering is done by area size.  In the command system there is specifically for this purpose the intended command ‚ÄúSEARCH BY LIST‚Äù, which finds either an area that exactly matches the size with the required one, or minimally exceeds the required size in size.  In the first case, the found area is excluded from the list, loaded into the mathematical memory (if required), and a handle to this area is generated as the result of the procedure.  In the second case, if the size of the found area exceeds the required one by more than 15 words, the area of ‚Äã‚Äãthe required size is taken from the found area, and the remainder is returned to the free memory area, where it will be included in the appropriate place in the free memory list.  The user is given a handle to the memory area of ‚Äã‚Äãthe size that exactly matches the requested one. <br><br>  In the event that there is no memory of the required size, an attempt is made to consolidate parts of free memory by moving smaller occupied areas that divide adjacent free areas into available free areas. <br><br>  If this does not lead to the goal, pumping (swapping) of the occupied areas to external carriers occurs.  This does not apply to running segments, you can simply release them ... <br><br>  Each task has its own rollout file, and each segment knows its task.  The allocation of free memory in the file is on the bit mask [2, p.143], in which one digit corresponds to the page.  (For a mathematical memory of 2 ** 32, a mask of 2 ** (32-16) = 64K is required for a task, which is not so little. In addition, it is not clear how to deal with pages smaller than the maximum possible 8K.) Thus it is possible to avoid problems with maintaining the registry of free pages in comparison with the general download file.  After all, each task has its own mathematical memory.  In addition, the release of the entire memory of the process is reduced to the deletion of its pumping file, the work is transferred to the file system.  With a relatively small number of tasks, this is an excellent approach.  Its disadvantages can be attributed perhaps to the additional load on the file system. <br><br>  In the OS kernel there is a task that ‚Äúcuts‚Äù tasks in the background [2, p.143], discarding a certain percentage of pages.  The data of passive tasks at the same time gradually appear in the pumping files, the actively working tasks are balanced. <br><br>  Let us now analyze the transformation of addresses from mathematical to physical.  All task memory areas (segments) are combined by a list, the head and tail of which are located in the task descriptor.  Note that in this architecture there are no calls for a bare pointer in the spirit of ‚ÄúC‚Äù, the pair is always converted (pointer, offset). <br><br>  In the mentioned list of task segments using the ‚ÄúSEARCH BY LIST‚Äù instruction there is a segment descriptor, and in it is the physical address of the desired page.  If there is no page in physical memory, the swap mechanism is enabled. <br><br>  To speed up the conversion of a mathematical address into a physical one in the CPU, an associative array of 64 elements is provided for the most ‚Äúactive‚Äù pages.  The associative attribute is the number of the mathematical page, the answer is the physical address of the beginning of the page, its size, and also some service attributes.  The search time in this associative array is 3 cycles, the processing rate is one application per cycle. <br><br>  In addition, the word itself, which is accessed, along with its mathematical address is placed in the associative memory of words, which is also in each CPU.  Such memory is an analogue of modern cache memory. <br><br>  There is a mention [2, p.144] of the table of downloaded pages (TOC), designed to accommodate information about pages that have been rolled out or not yet initialized.  The head of this table is in RAM, the overflow area is in the external memory (drum).  Its value is proportional to the number of existing pages, and not the entire mathematical memory. <br><br>  TOC is one for the system, so for each page, you must also remember the task ID. <br><br>  To speed up work with TOC, a cache is provided in the kernel, and, as stated, is very efficient.  But it is strange, because for effective caching it is necessary to understand the logic of the application of the task with memory, and it is unknown to OS developers. <br><br>  So: <br><br><ul><li>  Pages are pumped out to external media by the background task of the kernel ‚Äúcutting‚Äù the task.  Therefore, they go in TOC packs and (probably) in an orderly manner. <br><br></li><li>  Free space in the pumping files is distributed using the above-mentioned bit mask. <br><br></li><li>  But the pages are downloaded in an arbitrary order, determined by the logic of the work of applied tasks. <br><br></li><li>  Under TOC, they gave the fastest (and the smallest - up to 136 MB) external memory - <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D0%25B3%25D0%25BD%25D0%25B8%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B1%25D0%25B0%25D1%2580%25D0%25B0%25D0%25B1%25D0%25B0%25D0%25BD">drums</a> , the average access time of 5-5.5 ms, the exchange rate of 3.6 MB / s [2, p.187].  As a comparison, for disks: the average access time is 60 ms, the exchange rate is 180 Kb / s. <br><br></li><li>  It is even more offensive if, in the course of operation, the TOC becomes fragmented and will require excess space.  In addition, over time, TOC will lose orderliness and you will have to read the whole page to find the right page. <br><br></li><li>  Apparently, even though TOC is called a table, it is designed as a B-tree (1970) or, for example, similar to the <a href="https://en.wikipedia.org/wiki/Dbm">DBM</a> hash table (1979), cheap and cheerful.  Rather, the first, given that the tree-like structure is used to allocate free memory by the file system [2, p.146].  On the other hand, in [2, p. 200] one can see regrets that segment management was too complicated and resulted in the use of a different RAM exchange interface with external memory used in the EU.  With all the consequences. </li></ul><br><h3>  Data types </h3><br>  As already mentioned, the word consists of 64 data bits and 8 control bits.  Control bits contain a tag - a description of what lies in the information part of a word. <br><br>  It may be: <br><br><ol><li>  Empty 32 and 64 bit formats are usually uninitialized data.  Dummies are quite possible to read, write, transfer to procedures and even check and change bits.  But if you try to work with numbers or with arrays, an interrupt will occur. </li><li>  Integer format 32 and 64 bits - in contrast to the now common format, here the sign is highlighted in the most significant bit. </li><li>  Real 32 - sign of the mantissa / sign of the order / order of 6 digits / mantissa 24 digits </li><li>  Real 64 - sign of the mantissa / sign of the order / order of 6 digits / mantissa 56 digits </li><li>  Real 128 - the sign of the mantissa / sign of the order / order of 6 digits / mantissa 56 digits / high digits of the order - 8 digits / high digits of the mantissa - 56 digits.  In general, the format of numbers differs from that of IEEE 754, which is now adopted. It is also taken from system 360. </li><li>  Bit </li><li>  Number - 4 digits, usually used to represent decimal numbers </li><li>  Byte - 8 bits, usually - a character string </li><li>  Set - 64 digits, a collection of similar elements that are not quantities and individual access to them is not allowed (SIMD?) </li><li>  The descriptor is 64 bits, the descriptor of the memory area, created only by the kernel, contains the mathematical address, the size in the elements, the size of the element in the bits, the type of memory protection.  The maximum size of the area described by the descriptor is 2 ** 20 words. </li><li>  The index (indirect) word - 64 bits - is the loop counter in e-1. <br>  It contains the current value of the counter, the cycle step, and the limit value (all by 20 digits + sign). <br>  In arithmetic operations or operations of addressing the elements of an array, it is automatically converted to an integer; during cycle operations, an automatic check for going beyond the limit value occurs and the transition <br>  at the address or automatically change the counter. </li><li>  An indirect word has a descriptor structure and is distinguished by the fact that reading such a value automatically reads the value to which the address points (can be repeated several times). </li><li>  The interval is 64 bits, used to obtain a sub-region descriptor from the area described by the indexed descriptor. </li><li>  Label operation transition.  Can only be used with the GOTO team.  - 64 bits, contains <br><ul><li>  The mathematical address of the context of the enclosing procedure within which this label is described.  - 32 digits </li><li>  byte number from the beginning of the area - 16 bits </li><li>  program segment descriptor - 12 bits </li><li>  The lexicographic level of the procedure is 5 digits (0 is system calls, 1 &amp; 2 are user procedures. 3 is the first executable ... [2, p.43]). </li></ul></li><li>  Label procedure.  It has the same structure, different tag, can only be used in the operations of entry into the procedure. </li><li>  Technical label.  It has the same structure, different tag.  When reading, there is an automatic entry into the procedure without parameters, which returns a single value. </li><li>  Semaphore - a means of synchronization in the system. </li><li>  Billet array.  In the Elbrus system, it is not customary to explicitly call a getmem or maloc procedure. <br>  Instead, a so-called array storage is put into memory ‚Äî a word with a special tag, which indicates the size of the array and the size of the array element.  If the array is never needed, the billet will remain billet.  Otherwise, when reading such a workpiece, an interruption will occur, the processing procedure of which will allocate memory and write a descriptor of the selected array to the place of this workpiece. </li></ol><br><h3>  Features of the command system </h3><br><ol><li>  The data is tagged, it allows the hardware to protect them as well as to simplify the system of commands, for example, replacing the whole family of typed addition commands with a single one - taking into account the tags. <br><br></li><li>  An addressless system of commands was adopted, as a result of which there is no unnecessary information about the distribution of registers.  Effective dynamic allocation of registers implements the equipment.  The unaddressed command format is based on the hardware implementation of the stack. <br><br></li><li>  The addressing of data in commands occurs on a pair ‚Äî segment / index, taking into account the execution context, and not on the mathematical address.  For example, the sequence number in the area of ‚Äã‚Äãthe stack allocated to a particular procedure. <br><br></li><li>  To call functions, in addition to the mathematical address, a fairly detailed descriptor is used, in which, among other things, the size of the local stack for data and parameters is specified.  A deferred selection of data is implemented; when entering a function, only a segment descriptor is created, the actual selection occurs on the first call.  It is reported [2 p.42] that this is an innovative technique.  In fact, the function descriptor number comes with the call argument as well as the mathematical address of the code.  In x86, for example, the compiler does all the auxiliary work, placing the prologue and the epilog of the function. </li></ol><br><h4>  Addressless code. </h4><br>  We say ‚Äúaddressless instruction set‚Äù, we mean ‚Äú <a href="https://en.wikipedia.org/wiki/Stack_machine">stack processor</a> ‚Äù.  Consider a simple example, the calculation of the expression x + y * z + u. <br><br>  When building <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">a parse tree with a</a> compiler, it looks like this: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/124/738/94b/12473894b5c54ae5bae1cf196f0c7bda.PNG" alt="image"></div><br>  The assembly code (x86) for this expression is: <br><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">dword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[y]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">imul</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">dword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[z]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ecx</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">dword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[x]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ecx</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">ecx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">dword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[u]</span></span></code> </pre> <br>  For a hypothetical stack engine, pseudocode is: <br><br><pre> <code class="hljs perl"> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-keyword"><span class="hljs-keyword">y</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> z multiply add <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> u add</code> </pre><br>  Operations with the stack require the following types of operations: <br><br><ul><li>  write element to the top of the stack (push) </li><li>  remove item from the top of the stack (pop) </li><li>  binary operations that remove two elements from the top of the stack and record the result of the operation (+ - * /) </li><li>  unary operations, replace the result at the top of the stack (change sign) </li></ul><br>  What does the architecture of Elbrus offer us? <br><br><ol><li>  <b>Load operations to the stack.</b>  Information can be loaded onto the stack either directly from the command thread or from the data area.  In the first case, the load value is in the command itself, in the second case, the value is loaded to the address located either in the command or at the top of the stack (load by address). <br><br>  Note that since the stack is implemented as a cyclic buffer from the registers, loading a new element can cause the automatic unloading of a part of the stack into memory. <br><br>  Of particular interest is the download at the address at which: <br><br><ul><li>  on the address pair is the mathematical address of the value </li><li>  this checks the ability to access the value </li><li>  the value is loaded to the top of the stack </li><li>  next cycle <ul><li>  the tag checks the class of values ‚Äã‚Äãof the loaded value </li><li>  if the value belongs to a class of values, the operation is completed </li><li>  if it is an indirect word, an indirect word is read </li><li>  procedure label is quite a value, the loop stops </li><li>  if this is a <i>technical</i> label of the procedure, the procedure is called which should leave its result at the top of the stack </li></ul></li></ul><br><br></li><li>  <b>Write to memory from stack.</b>  To do this, we need two values ‚Äã‚Äãfrom the top of the stack: the value and the address of the record.  The address of the entry can be either an address pair or an indirect word.  The entry is made ‚Äúone-step‚Äù, that is, directly at the address of the entry. <br><br></li><li>  <b>Arithmetic operations</b> , relational operations and logical operations.  Arithmetic operations are performed on one or two values ‚Äã‚Äãcontained in the top of the stack.  As a rule, the operands are whole or real, and, if the operands are of different types (whole and real), then before the operation, the whole is automatically transformed into real.  If the operands have different formats, before the operation, an automatic ‚Äúlength alignment‚Äù is performed along the longest length. <br><br>  Initial numbers are removed from the stack (with a corresponding pointer offset), and then the result is placed at the top of the stack. <br><br>  Single-place arithmetic operations take an operand from the top of the stack and replace it with the result. <br></li></ol><br><h3>  CPU </h3><br><img src="https://habrastorage.org/files/902/1dc/89a/9021dc89a05a43bbae30f156d2023acb.PNG" alt="image"><br>  The block diagram of the CPU [1]: <br><br><ul><li>  memory exchange device </li><li>  512-word command buffer memory (BC) for coordinating the rate of decryption of commands and calling a program from RAM </li><li>  control device (CU) </li><li>  10 specialized actuators (DUT) to execute commands </li><li>  base registers (BR) for converting relative addresses to absolute </li><li>  256-word operand stack (STOP) for storing intermediate results of operations </li><li>  buffer memory (PSU) of 1024 words, is intended for storing global data plus buffer memory of 256-word arrays with preliminary paging </li><li>  CB - sampling (decoding) scheme </li></ul><br><h4>  Decoding </h4><br>  The program code is read into the command buffer (BC).  BC works as an associative array, has a volume of 512 words, which are divided into 32 equal segments.  Swapping information in the BC from the RAM is performed in blocks of four words.  The paging rate is determined by the required supply of command words in the instruction buffer and is automatically adjusted when the decoding rate of the commands changes. <br><br>  The sampling scheme extracts the next command from the BC, decrypts it and transmits it to the CU for conversion to the internal register format. <br><br><h4>  Internal Addressing System </h4><br>  All transfers of address and numeric information are accompanied in the CPU by the internal address of the source or consumer of information.  Internal addresses are assigned to the instruction buffer, a stack of operands (Stop), a power supply unit, and some input registers of the DUT. <br><br>  The STOP consists of 32 registers and a 32-bit register - bit mask.  Each bit in this mask is responsible for a specific register, 1 means busy, 0 means free. <br><br>  When issuing a command in the DUT, the internal addresses of the operands and the result of the operation are formed.  For stack operations, the operands and the result are register numbers from the Stop. <br><br>  To decode the summation command, for example, it is considered that the numbers of the operands have already been obtained earlier, you can assign any free register from the Stop.  After the command is executed, the operands are released. <br><br><h4>  Execution </h4><br>  Not all commands can be executed directly after their decoding; therefore, a buffer of decoded but not executed commands is necessary.  The CPU has this buffer for 32 commands in the internal representation. <br><br>  Commands from the decoder are issued in the sequence specified by the program.  In this case, they are sequentially numbered and this number accompanies the team throughout its life.  This number is the index in the aforementioned decoded instruction buffer, when it reaches 32, it starts from zero again.  Knowing the current value, you can line up all the commands in the queue in order of their decoding. <br><br>  The execution time of commands in the DUT is determined by their type and ranges from 2 to 20 clocks for operations on single-precision operands (32) and up to 30 clocks over double-precision operands (64).  ???  Multiplication (F64) - 4 bars.  Division (F64) - 24 bars. <br><br>  Performing operations on real numbers of the F128 format requires a threefold addition ‚Äî the addition of the lower digits, the addition of the higher digits, taking into account the transfer from the lower digits, and the repeated addition of the lower digits, taking into account the transfer from the higher digits.  This requires station storage intermediate results. <br><br>  Execute commands begin on the availability of arguments and the availability of the desired actuator.  Since  the order of execution does not necessarily coincide with the original, we have an extraordinary execution ( <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BD%25D0%25B5%25D0%25BE%25D1%2587%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B8%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">OoO</a> ).  And since there are several execution units and they work in parallel, there is <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2583%25D0%25BF%25D0%25B5%25D1%2580%25D1%2581%25D0%25BA%25D0%25B0%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">superscalarity</a> .  True, the adder, divider and multiplier in a single copy, but can work in parallel. <br><br>  Given that there are 10 actuators in total, the question arises, how many instructions per clock can be executed.  In [2 p. 185] it is mentioned that in the technological mode with sequential execution of commands, the productivity drops by a factor of 2-3.  [4] talks about 2 teams per clock.  This is due, apparently, to the implementation of the Stop, which allows only two entries per clock. <br><br><h5>  Example </h5><br>  To demonstrate the possibility of a completely superscalar behavior, consider the expression ‚Äú(a * b) + (c / d)‚Äù.  At the same time, the variables ‚Äúa‚Äù &amp; ‚Äúc‚Äù are located in the region of local variables of the procedure and are present in the cache, and the ‚Äúb‚Äù &amp; ‚Äúd‚Äù are global and not in the cache.  For simplicity, they are all F64 type. <br><br>  The assembler code looks like this: <br><br><pre> <code class="hljs swift">    b ‚àó  <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>  d ‚ÅÑ +</code> </pre><br>  Where OT means ‚Äúevoke value‚Äù, DVZ means ‚Äúlong OT‚Äù, and the mnemonics of arithmetic operations are unknown. <br><br>  After decoding, the code in the internal representation is approximately as follows (mnemonics are invented): <br><br><pre> <code class="hljs erlang-repl"> a -&gt; R1 ;   R1    b -&gt; R2 ;   R2   ‚àó R1 R2 -&gt;R3 ;   R2  , R1 &amp; R2      -&gt; R4 ;   R4    d -&gt; R5 ;   R5   ‚ÅÑ R4 R5 -&gt;R6 ;   R6  , R4 &amp; R5    + R3 R6 -&gt;R1 ;     R1  , ; R3 &amp; R6    ;   R1</code> </pre><br>  Due to the dependencies between the commands, execution occurs in the following order (2 instructions per clock, loading from the cache - 1 clock, loading from the memory, 13 clock cycles, ‚Äú*‚Äù - 4 clock cycles, ‚Äú/‚Äù - 24 clock cycles, ‚Äú+‚Äù - 3 clock cycles ): <br><table><tbody><tr><td>  tact </td><td>  Start </td><td>  Turned </td></tr><tr><td>  one </td><td>  loading a -&gt; R1;  boot b -&gt; R2 </td><td></td></tr><tr><td>  2 </td><td>  boot with -&gt; R4;  boot d -&gt; R5 </td><td>  Loaded a -&gt; R1 </td></tr><tr><td>  3 </td><td></td><td>  boot with -&gt; R4 </td></tr><tr><td>  13 </td><td></td><td>  boot b -&gt; R2 </td></tr><tr><td>  14 </td><td>  ‚àó R1 R2 -&gt; R3 </td><td>  boot with -&gt; R4 </td></tr><tr><td>  15 </td><td>  ‚ÅÑ R4 R5 -&gt; R6 </td><td></td></tr><tr><td>  17 </td><td></td><td>  ‚àó R1 R2 -&gt; R3 </td></tr><tr><td>  38 </td><td></td><td>  ‚ÅÑ R4 R5 -&gt; R6 </td></tr><tr><td>  38 </td><td>  + R3 R6 -&gt; R1 </td><td></td></tr><tr><td>  40 </td><td></td><td>  + R3 R6 -&gt; R1 </td></tr></tbody></table><br>  Multiplication and division are quite parallel.  Alas, arithmetic actuators do not have pipelines that were planned only in a vector processor [2, p.150]. <br><br><h4>  Stop and continue execution </h4><br>  Sometimes it may be necessary to pause the program, with the option to continue, if necessary, for example, when a time slice expires.  This requires restoring the original order of instructions.  Wherein: <br><br><ol><li>  remember the number of the command that caused the interrupt </li><li>  the commands decrypted before it are completed, and the execution of commands decrypted later is canceled </li><li>  registers are restored to the moment corresponding to the decoding of the command that caused the interrupt </li><li>  enter interrupt </li></ol><br>  Restoring the status of registers will require a special mechanism, for example, a cyclic buffer for the log of changes in register values ‚Äã‚Äãof 2 * ‚Äúmaximum instruction length in cycles‚Äù.  At the end of the instruction, this log is written to the old register value from the Stop, the new value, the register number and the command number.  Then, if necessary, you can unscrew the changes for the commands being canceled. <br><br>  Cancel command execution is also used when processing conditional jump commands.  Thus, <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D1%2580%25D0%25B0%25D0%25BB%25D0%25BB%25D0%25B5%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25BC_%25D0%25BD%25D0%25B0_%25D1%2583%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BD%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B4">speculative execution of the code is</a> carried <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D1%2580%25D0%25B0%25D0%25BB%25D0%25BB%25D0%25B5%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25BC_%25D0%25BD%25D0%25B0_%25D1%2583%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BD%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B4">out</a> . <br>  About the predictor of the direction of branching there is a mention [1], but the mechanism is unclear. <br><br>  So what do we have? <br><br><ul><li>  superscalar level 2 instructions per clock </li><li>  for the implementation of superscalar use of the technique of <a href="https://en.wikipedia.org/wiki/Scoreboarding">scoreboarding</a> , no <a href="https://en.wikipedia.org/wiki/Register_renaming">renaming of registers</a> , as indicated in [5], and there is no close, this technique is simply not applicable here </li><li>  use of the operand stack close to the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B3%25D0%25B8%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B5_%25D0%25BE%25D0%25BA%25D0%25BD%25D0%25BE">register window</a> technique, which appeared independently, but several years later (E-1: raz. 1973-1979, Berkeley RISC: 1980-1984) </li><li>  extraordinary command execution </li><li>  speculative conversion prediction </li><li>  the combination of unaddressed architecture and superscalarity in Elbrus-1 seems to take precedence </li></ul><br><h4>  Multiprocessing </h4><br>  The problem of interprocessor interaction is associated with the presence of each processor‚Äôs own POPs (cache) and, consequently, matching the data in the RAM and POPs.  POPs can significantly reduce the frequency of calls to relatively slow memory, but it is possible that the data in the memory is fresh to POPs. <br><br>  In the Elbrus MVK, a task can generate several processes (threads) that share a common mathematical memory.  A program section that uses (reading or modifying) data common to several processes is called a critical section. <br><br>  There are two problems - synchronization and <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B3%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_%25D0%25BA%25D1%258D%25D1%2588%25D0%25B0">cache coherence</a> support. <br><br><h5>  <b>Semaphores</b> : </h5><br><ul><li>  A semaphore is a data type in the command system that has its own tag [2 p.121].  An unprivileged user cannot change the contents of the semaphore.  It can only submit a semaphore by name as a parameter to synchronization procedures (semaphores cannot be copied and each semaphore exists only in one instance, however several links can be established for each semaphore) </li><li>  A semaphore may be ‚Äúopen‚Äù or ‚Äúclosed‚Äù. </li><li>  The ‚ÄúWAIT‚Äù function (with the argument referring to the semaphore) blocks (puts it in the semaphore queue) the current thread if it is closed or does nothing if it is open.  After unblocking, thread will continue execution with the next instruction after calling this function. </li><li>  The function ‚ÄúOPEN‚Äù (...) puts the semaphore in the open state, all processes waiting for its opening (threads) are transferred to the queue ready for execution </li><li>  The ‚ÄúSKIP‚Äù (...) function transfers all processes (threads) locked on this semaphore to the category of ready for execution, the semaphore remains closed </li><li>  The ‚ÄúCLOSE‚Äù function (...) places the semaphore in the closed state if it has been opened.  If the semaphore has been closed, then the current thread is blocked and put in the semaphore queue.  The difference from the ‚ÄúWAIT‚Äù function is that when this thread is unlocked, an attempt will be made to close the semaphore again. </li><li>  The ‚ÄúOPEN‚Äù function is privileged [2,124], the first operand should be a spinlock, and the second should be an ordinary semaphore, atomically opening the first semaphore and closing the second one.  producer-consumer.  For example, processes exchange portions of data, when the consumer must receive a signal that a new portion of data is ready, and the producer that the consumer has processed the previous one.  The solution to this problem on two semaphores is that one semaphore is used to alert the manufacturer and the other the consumer. </li><li>  For privileged users, operations with <a href="https://ru.wikipedia.org/wiki/Spinlock">spinlocks</a> are available - ‚ÄúZHUZH‚Äù (yes, from the word buzz [2 p. 124]) and ‚ÄúOPEN‚Äù, similar to ‚ÄúCLOSE‚Äù and ‚ÄúOPEN‚Äù.  These operations are noticeably faster, but are only suitable for short-term work, while interruptions are not allowed (work with virtual memory and devices).  It is impossible to work simultaneously with a semaphore as with a semaphore and as with a spinlock. </li><li>  Users are responsible for the correct use of this technology.  For example, if a process opens a semaphore that was not closed to them, then the process that closed the semaphore loses its monopoly on working with the data protected by this semaphore.  In addition, this technique does not guarantee the absence of <a href="https://ru.wikipedia.org/wiki/Deadlock">dead ends</a> . </li><li>  When the semaphore is closed, the time of this event is remembered, it will still be useful to us. </li></ul><br><h5>  <b>Memory coherence</b> </h5><br>  It is believed that working with common data can only be done in the critical section, that is, between the operations "CLOSE" and "OPEN" or the operations "LUTURE" and "OTKSEM." <br><br>  All data recorded in the processor's POPS between these operations are marked as ‚Äúcommon‚Äù and, in addition, the time they are recorded in the POPS is remembered.  Under the POPs mean the global data memory of 1024 words [2 p. 186]. <br><br>  Each procedure has its own local address space, global data belongs to other procedures, as far as the scope of the procedure allows.  Those.  for the compiler and for the processor, references to local and global data are unequal. <br><br>  When a semaphore is opened, an opening time is recorded in it.  Each time the semaphore is closed, the time recorded in it and the time of recording general data in the POPS are analyzed.  Those common data that hit the POPs before the discovery of this semaphore is no longer reliable, since they could be changed by another CPU.  Those data that fell into the POPs after the opening of the semaphore, reliable, since they are not related to this semaphore. <br><br>  We will understand by example.  Suppose we are talking about a flow-safe counter. <br><br><ol><li>  flow-1 captures (closes in terms of Elbrus) semaphore-1 on CPU-1 at time T-1 </li><li>  thread-1 reads variable counter-1, which was not in the global cache </li><li>  thread 2 tries to capture semaphore 1 and is blocked </li><li>  Now counter-1 has appeared in the global cache CPU-1 with time T-2 </li><li>  thread-1 increments and writes counter-1 to the global cache CPU-1 over time T-3 </li><li>  flow-1 frees up (opens in terms of Elbrus) semaphore-1 with time T-4.  At this moment, a change in counter-1 is detected within the semaphore-1 capture time and this value is recorded in memory, now it is available to all </li><li>  Stream-2 woke up at the time of T-5 on CPU-2 with a captured (closed) semaphore-1 </li><li>  thread-2 is trying to read the value of counter-1, which is already in the global cache of CPU-2 with time stamp T-0.  Since  T-0 is less than T-5, the value is considered invalid and read from memory. </li><li>  flow-2 frees up (opens in terms of Elbrus) semaphore-1 with time T-6.  Since nothing has changed, nothing happens </li></ol><br>  Thus, based on a comparison of the opening time of the semaphore and the time of entry of common data into the POPS, the CPU unambiguously solves the problem of data reliability.  You do not need to reset the entire global cache, which would hurt performance. <br><br>  To ensure all this, instructions are introduced for inter-processor communication: <br><br><ul><li>  ‚ÄúPREVATCH‚Äù with an argument - mask of interested processors.  As a result, all specified processors receive an interrupt. </li><li>  ‚ÄúWAITING‚Äù - the command execution is waiting for the execution of the ‚ÄúRESPONSE‚Äù command from all processors specified in the command (command parameter) </li><li>  ‚ÄúRESPONSE‚Äù - confirmation of receipt and execution of the interrupt </li></ul><br>  Apparently, this is how the information on the state change of semaphores is distributed. <br><br>  Also, presumably, in this way, the data that are recorded into the POPs by the hardware without closing any semaphores should be distributed.  This includes program segment descriptors and math and physical address mapping tables. <br><br>  In the same way, it would be possible (would) solve the problem of delivering changes to a POPs while closing a semaphore to POPs of other processors. <br><br><h3>  Function call </h3><br>  Function call parameters and local variables are on the stack.  The call context is also on the stack.  In essence, the context consists of two pointers ‚Äî to the old context (that is, the contexts are linked by a list for exiting functions) and to the instruction with which the call occurred.  Plus additional information, all this was able to pack in two words. <br><br>  But the call of functions in Elbrus is peculiar.  It is multi-phase. <br><br><ol><li>  First we need to create the context of the future call and place it on top of the stack (marking the stack) </li><li>  We calculate the call parameters that appear on top of the stack in the right order.  Thus, the parameters are located after the context and can be accessed via the local data area descriptor using the general hardware protection mechanism. </li><li>  Memory is allocated (the size of which is defined by the compiler) for local data.  And that's it, you can start the execution of the function. </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When exiting, if necessary, the function leaves the return value at the place of its former context. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why so difficult? </font><font style="vertical-align: inherit;">Why not call a function more traditionally, with one instruction? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the parameters of the function will be in front of the context and the descriptor of the local data area, which starts from this context will not be able to cover them. </font><font style="vertical-align: inherit;">If you move the descriptor back to the beginning of the parameter area, the list of the call stack breaks, or you have to add a pseudo-parameter to the stack ‚Äî the length of the parameter area. </font><font style="vertical-align: inherit;">What is actually the same stack marking. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As for the mentioned descriptor for access to local data, it is not one, there are 32 of them. And which of them is used is determined by the lexicographic level of the function.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lexicographic level of procedures. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This mechanism is somewhat similar to </font></font><a href="https://en.wikipedia.org/wiki/Privilege_level"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the x86 privilege level</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">There are 32 base registers of descriptors that describe the local data of the procedures (+ parameters) on the stack. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each (as a regular domain descriptor) contains:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 32 ... 38 bits - the mathematical address of the beginning of the region being described (‚ÄúMANACH‚Äù) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13 ... 18 digits - maximum index or size (‚ÄúINDMAX‚Äù) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 digits - descriptor step 2 ** n bits (n = 0,1,2, ..., 7) (‚ÄúSTEPDESS‚Äù) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4 digits - access mode information (‚ÄúPROTECTION‚Äù) </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Different base registers describe different stack contexts. </font><font style="vertical-align: inherit;">Thus, register No. 0 contains a descriptor describing the stack of descriptors of procedures and data of operating systems, registers No. 1 and No. 2 describe stacks of procedure descriptors and external names of the task being performed, register No. 3 contains a descriptor describing the stack of the top level block and so on. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, if some instruction instructions contain an encoded "name" of a value (physically located on the stack), then it is defined only in this context. </font><font style="vertical-align: inherit;">Access to the stack element is carried out through the lexicographic level of the function, and the sequence number of the word in the stack area allocated for the data of this function (address pair).</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FORTRAN, COBOL, LISP, APL - languages ‚Äã‚Äãthat do not have a block structure </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the procedures of such languages, only local variables and call parameters are available. Memory allocation for each called procedure is performed dynamically. Upon entering the procedure, it is allocated in the stack the necessary free memory area for the formal parameters and local variables, the stack pointer (US) moves to the new boundary. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The memory area allocated to the procedure is described by a descriptor placed in one of the basic registers (even N). Appeal to the value in this area is carried out using the address pair (N, I). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The area of ‚Äã‚Äãfree memory in the stack below the new border is used to store intermediate results.</font></font><br><br>    ,              .  ,      ,     ,   ,   . <br><br>           Q,    Q        ,     .   ,    ,            ,      Q. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When exiting the Q procedure, it is necessary to restore the contents of the base register with the number N and transfer control to the operator following the operator of the procedure Q call. : </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MKS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the stack marker is similar to the descriptor, contains the size of the procedure data area, and its own address is the start address of this area.</font></font> Top down: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 32 bits - mathematical address of the previous ISS (‚ÄúADDRESS‚Äù) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 bit - a sign of blocking the recording of address information (‚ÄúBL‚Äù) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 digit - a sign of privileged procedure (‚ÄúREG‚Äù) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 19 bits - the size of the memory area in the stack allocated for the procedure (‚ÄúSIZE‚Äù) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 digits - return type: no value; </font><font style="vertical-align: inherit;">1 word; </font><font style="vertical-align: inherit;">2 words (‚Äú‚Äù)</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5 digits - reserve </font></font></li><li> 4  ‚Äî     (‚ÄúLL‚Äù) </li></ul><br><br></li><li> <b></b> ‚Äî    ‚Äî ,             . <br><br><ul><li> 18  ‚Äî ‚ÄúŒî ‚Äù           </li><li> 3  ‚Äî ‚Äú‚Äù,      </li><li> ‚Ä¶   ,  ‚Ä¶ </li><li> 16  ‚Äî ‚ÄúNk‚Äù,       </li><li> 11  ‚Äî ‚Äú‚Äù,     , ,  ,  (Nk &amp; )    </li><li> 4  ‚Äî     </li><li>  ... </li></ul></li></ul><br>    Q    : <br><br><ol><li>      Q,     ,          Q. </li><li>   ‚Äú‚Äù ‚Äî  .  Wherein: <br><br><ol><li>      ,          Q </li><li>   ‚ÄúŒî ‚Äù            ( ,    ),     .     .       ,   . </li><li>   ,         . </li></ol></li><li>   ‚Äú‚Äù. </li></ol><br>      ‚Äú‚Äù,  : <br><br><ol><li>     ()      , ,     0    </li><li>      (‚Äú‚Äù) ,      </li><li>  ,    ‚ÄúŒî ‚Äù  ( )  ‚Äú‚Äù  ,   ,   ()        . </li><li>       ,    .      ‚Äú‚Äù         ,        Nk ‚Äî   ,        . </li></ol><br><h4> 60, /1, , 68 ‚Äî     </h4><br>    ,         ,             . <br><br> ,            ‚Äî  &amp;     .   ,   .                  2   . <br><br> ,      ,           .    ? <br><br>       .   ,     32 ,  3   .    .  Those.          (    ),    ,  . ,      ‚Äî  30     32   . <br><br>    ‚Äî        N  Q   P    .    ,    (  )      P    . <br><br>  ,       ‚Äî    .        ,        : <br><br><ol><li>     .          ,     ()  </li><li>         ‚ÄúLL‚Äù   </li><li>  ‚Äú‚Äù            ,          </li><li>               LL </li></ol><br>      .  ,       ‚Äî   ,     ,    .     ‚Äî   .   ? <br><br>     .     ,     . <br><br>         ?    ,               . <br><br>  For example: <br><br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> integer i; ... <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> integer <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> s [<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1000</span></span>]; ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>       ,           P       1001 ,   1  .  ,      ,   . <br><br>             ?           ( 50% :).  , ,    ( ,   )   ,      . <br><br>  ,   ‚Äú‚Äù  (  , -)        [9].           . ,  ‚Äú‚Äù       . <br><br><h3>  Total </h3><br>      .       ‚Äú‚Äù.      , ,   ,    ‚Ä¶ ..       ,  (   )        ‚Äî ‚Äú,          ?‚Äù. <br><br>  ,    ,   ,       . ,      ‚Äú‚Äù . ,   <a href="https://habrahabr.ru/post/278575/">  </a>  ,    (  ,   )   ,          . <br><br>   ,     ‚Äú‚Äù      ,         , , ,   ,     . <br><br>       [2,  201]          (         80 Mflops [2,  166]),       . <br><br><h3>  Sources </h3><br><blockquote> [1] <a href="http://www2.icmm.ru/~masich/win/lexion/elbrus2/elbrus2.htm"> ..</a>  <a href="http://www2.icmm.ru/~masich/win/lexion/elbrus2/elbrus2.htm">lectures</a> <br> [2] <a href="http://www.computer-museum.ru/books/Burcev_elbrus.pdf">  .  ( ,    )</a> <br> [3] <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D1%258C%25D0%25B1%25D1%2580%25D1%2583%25D1%2581_(%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D1%258C%25D1%258E%25D1%2582%25D0%25B5%25D1%2580)">WIKI   </a> <br> [4] <a href="http://www.osp.ru/os/2009/02/7314081/">www.osp.ru/os/2009/02/7314081</a> <br> [5] <a href="http://www.ixbt.com/cpu/e2k-spec.html">www.ixbt.com/cpu/e2k-spec.html</a> <br> [6] <a href="http://dm-kalashnikov.livejournal.com/79346.html">    </a> <br> [7] <a href="http://www.pvsm.ru/programmirovanie/106969">www.pvsm.ru/programmirovanie/106969</a> <br> [8] <a href="http://www.caesarion.ru/warrax/w/warrax.net/88/elbrus.html">www.caesarion.ru/warrax/w/warrax.net/88/elbrus.html</a> <br> [9] <a href="http://www.mcst.ru/files/511cea/886487/1a8f40/000000/book_elbrus.pdf">www.mcst.ru/files/511cea/886487/1a8f40/000000/book_elbrus.pdf</a> </blockquote><br><br> UPD:    <a href="https://habrahabr.ru/users/wasya/" class="user_link">wasya</a>   ,   , ,  ,   </div><p>Source: <a href="https://habr.com/ru/post/313376/">https://habr.com/ru/post/313376/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313364/index.html">Experience in building and operating large file storage</a></li>
<li><a href="../313366/index.html">Sharding - patterns and antipatterns</a></li>
<li><a href="../313370/index.html">Elements of functional programming in C ++: partial application</a></li>
<li><a href="../313372/index.html">Elections 2016. Part 2 is amazing nearby and it is allowed</a></li>
<li><a href="../313374/index.html">JavaScript: includes vs indexOf</a></li>
<li><a href="../313380/index.html">learnopengl. Lesson 1.5 - Shaders</a></li>
<li><a href="../313382/index.html">Virtual server with video card</a></li>
<li><a href="../313384/index.html">Dribbble review number 2 - the most interesting interface designs for the last 2 weeks</a></li>
<li><a href="../313386/index.html">The digest of interesting materials for the mobile developer # 176 (October 17-23)</a></li>
<li><a href="../313390/index.html">Interview with MapR's VP of Technology Strategy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>