<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>qt-items - a new framework, or an attempt to find a theory of everything</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, physicists have long tried to find the Theory of Everything, within which one could explain all known interactions in nature. The tendenc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>qt-items - a new framework, or an attempt to find a theory of everything</h1><div class="post__text post__text-html js-mediator-article">  As you know, physicists have long tried to find the Theory of Everything, within which one could explain all known interactions in nature.  The tendency to generalization is inherent not only to physicists, but also to mathematicians, and programmers.  The ability of a smaller number of entities to explain and predict a wide range of phenomena is very valuable.  For programmers, various APIs and frameworks act as theories.  Some of them solve narrowly specialized problems, and some claim to be universal theories.  An example of the latter is Qt, a universal framework designed primarily for GUI development. <br><br>  Next, I‚Äôll tell you what I don‚Äôt like in Qt and how it can be made even more versatile, powerful and convenient for work. <br><br>  Demo video (better to watch in HD): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/o2rMyPM3qlM%3Ffeature%3Doembed&amp;xid=17259,15700002,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgTcMAiqcTFAN7uPDGR1SM1TPf7Ww" frameborder="0" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  Qt, like many other GUI frameworks, has evolved from simple to complex.  First, simple widgets were created, then more complex and complex ones.  Appeared Model / View framework, to display data in a tabular or tree view.  Appeared Graphics Items framework to display a set of graphic elements.  All of these frameworks have different APIs and are incompatible with each other.  In fact, we have three independent and almost overlapping theories within the framework of one big one.  When I need to develop a new visual element, then I have to choose in which of the three frameworks I am going to use it and use the corresponding API.  Thus, I cannot create an element that could be used as a separate widget, and embedded in the table cells, and used in the nodes of the graphic scene. <br><br>  Qt develops under the slogan - Write once, run anythere.  This may be true for writing final applications, but for expansion and customization of the library itself this is not the case. <br><br>  Let's think about how widgets should be arranged in order for the Qt library to become truly unified and powerful. <br><br>  Consider different widgets (checkbox, table, tree and graphic scene) and try to find something in them in common.  Information in them is grouped into cells (Items).  A checkbox consists of a single cell, a table is made up of rows and columns of cells; in the scene, the cells are nodes.  Thus, it can be said that all widgets display cells, only their number and location in space are specific for different types of widgets.  Let's say that the widget displays some space of cells ( <a href="">Space</a> ).  For simple widgets, the cell space is trivial to a <a href="">SpaceItem</a> , and consists of a single cell.  For a table, you can <a href="">create a SpaceGrid</a> that describes how cells are organized into rows and columns.  For the graphic scene, we have <a href="">SpaceScene</a> , where cells can be placed as you like. <br><br>  What do all the spaces have in common, what can be distinguished into the base class? <br>  So far, two things can be distinguished: <br><ol><li>  Return the total size of the space (usually the bounding box of all cells) </li><li>  Return the location of the cell according to its ItemID </li></ol><br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Space</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QSize </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QRect </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">itemRect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ItemID item</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  Let's now take a close look at the cells themselves.  For clarity, we will study the following table: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df3/a5f/f2e/df3a5ff2e721e90f82ed5c22d2243809.png"><br><br>  The cells also have some structure.  For example, the checkbox consists of a small square with a check mark and text.  In a table, cells can be very complex (contain text, pictures, links, as in my video example).  Note that for a table, as a rule, the cells in one column have the same structure.  Therefore, it is easier for us to describe not every cell, but a whole set.  A <a href="">range of</a> cells can be different, for example, all RangeAll cells, cells from the RangeColumn column, cells from the RangeRow row, cells from even-numbered RangeOddRow rows, etc.  What kind of interface can be distinguished for the base class <a href="">Range</a> ?  The interface is simple and concise - to answer the question whether some cell is in the <a href="">Range</a> or not: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Range</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ItemID item</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  After we have decided on a subset of cells, we need to specify what type of information in these cells we want to display.  The view class will be responsible for displaying the smallest and indivisible piece of information.  For example, <a href="">ViewCheck</a> can display a checkbox icon, <a href="">ViewText</a> displays a string of text, etc. <br><br>  So far, the base <a href="">View</a> class should only be able to draw information in a cell: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">View</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QPainter* painter, ItemID item, QRect rect</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  The question arises, where <a href="">does ViewCheck</a> know that he needs to draw the icon on the left in the cell, and <a href="">ViewText</a> knows that he needs to draw text after the checkbox icon?  To do this, we will create another "dwarf" class <a href="">Layout</a> .  This class can place a <a href="">View</a> inside a cell.  For example, LayoutLeft will place <a href="">View</a> at the left edge of the cell, LayoutRight at the right, and LayoutClient will occupy the entire space of the cell.  Here is the basic interface: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Layout</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doLayout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ItemID item, View view, QRect&amp; itemRect, QRect&amp; viewRect</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  The doLayout function changes the itemRect and viewRect parameters so that the view is positioned inside the item cell.  For example, LayoutLeft requests the size required by the view to display information in the cell, and bites the necessary space from itemRect.  As you can see, one more function is required from the <a href="">View</a> interface - size: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">View</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QPainter* painter, ItemID item, QRect rect</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QSize </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ItemID item</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  As a result, in order to describe <b>what</b> and <b>how</b> we want to display in the cells of a certain space, we need to enumerate triples of objects tuple &lt;Range, View, Layout&gt;.  I called this triple <a href="">ItemSchema</a> .  Completely our <a href="">Space</a> class looks like this: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Space</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QSize </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QRect </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">itemRect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ItemID item</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; QVector&lt;ItemSchema&gt; schemas; };</code> </pre><br>  Here is a vivid example (the signatures are a bit outdated, but I think the main idea is clear): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac9/069/fa1/ac9069fa168190cf2ea53ba31364e11e.png"><br><br>  Creating different heirs of the <a href="">Range</a> , <a href="">View</a> and <a href="">Layout</a> classes, and combining them in various ways, we have rich possibilities for customizing any cell space and, thus, any widget.  For example, having created the <a href="">ViewRating</a> class, which displays an estimate in the form of asterisks, I can use it both as a separate widget, in table cells, and in elements of a graphic scene. <br><br>  This architecture has the cooperation of programmers.  Someone can write their own type of cell space, which lays out the cells in some special way.  Someone will write a View that displays specific data.  And these programmers can take advantage of each other‚Äôs work.  This is not a complete list of my implementations of the View class, they are easy to create and use (the implementation is literally a few lines of code): <br><ol><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/button">ViewButton</a> - draws a button; </li><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/checkbox">ViewCheck</a> - draws the checkbox icon; </li><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/color">ViewColor</a> - fills the area with a specific color; </li><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/enum">ViewEnumText</a> - draws text from a limited list; </li><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/image">ViewImage</a> , <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/image">ViewPixmap</a> , <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/image">ViewStyleStandardPixmap</a> - draw images; </li><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/link">ViewLink</a> - draws text links; </li><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/misc">ViewAlternateBackground</a> - draws across the stripes; </li><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/progressbar">ViewProgressLabel</a> , <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/progressbar">ViewProgressBox</a> - draw a progress <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/progressbar">bar</a> or percents; </li><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/radiobutton">ViewRadio</a> - draws the radio <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/radiobutton">button</a> icon; </li><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/rating">ViewRating</a> - draws assessment icons; </li><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/selection">ViewSelection</a> - draws selected cells; </li><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/text">ViewText</a> - draws text; </li><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/text">ViewTextFont</a> - changes the font of the following text; </li><li>  <a href="https://github.com/lexxmark/qt-items/tree/master/src/items/visible">ViewVisible</a> - shows or hides another View; </li></ol><br><br>  Go ahead.  As a rule, the widget does not display the whole space of cells, but only the visible part.  The <a href="">Space</a> class is convenient for describing cell space, but bad for drawing cells in some limited visible area.  Let's define a special class to display the sub-region of the <a href="">CacheSpace</a> space: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CacheSpace { // reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> items space Space space; // visible area QRect <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>; // draw cached items <span class="hljs-type"><span class="hljs-type">void</span></span> draw(QPainter* painter) const; // visit <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> cached items virtual <span class="hljs-type"><span class="hljs-type">void</span></span> visit(Visitor visitor) = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/9bb/530/7e8/9bb5307e8cd497affbd554dd84165400.png"><br>  Each specific heir from <a href="">CacheSpace</a> ( <a href="">CacheGrid</a> , <a href="">CacheScene</a> , etc.) stores a set of cached <a href="">CacheItem</a> cells differently (but optimally for a given type of space).  Therefore, we will allocate the visit function in the base class, which visits all cached cells.  Using it, it is easy to implement the draw function ‚Äî you just need to visit all the cached cells and call their own draw function. <br><br>  As the name implies, <a href="">CacheItem</a> stores all the information needed to display a specific cell: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CacheItem</span></span> { ItemID item; QRect itemRect; QVector&lt;CacheView&gt; views; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QPainter* painter</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre><br>  Here, the draw function is also very simple - in a loop, call draw on the <a href="">CacheView</a> class, which is responsible for drawing the smallest and indivisible piece of information inside the cell. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CacheView</span></span> { View view; QRect viewRect; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QPainter* painter, ItemID item</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre><br><br>  Thus, the widget needs to have <a href="">CacheSpace</a> and use it to draw the contents of its cell space: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Widget</span></span></span><span class="hljs-class"> { // space of items </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Space</span></span></span><span class="hljs-class"> space; // cache of visible area of space </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CacheSpace</span></span></span><span class="hljs-class"> cacheSpace; void paintEvent(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QPaintEvent</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">) override; void resizeEvent(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QResizeEvent</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">) override; };</span></span></code> </pre><br>  In the resizeEvent handler, we change the visible region of the cacheSpace.window object, and in the paintEvent handler, we draw its contents cacheSpace.draw (). <br><br>  As you can see, the hierarchy of CacheSpace-&gt; CacheItem-&gt; CacheView objects allows us to ‚Äúsee‚Äù the entire visual structure of the widget with maximum details.  We can access any smallest and indivisible piece of information, going down from the <a href="">CacheSpace</a> level to the level of a separate <a href="">CacheItem</a> cell and, further, going through individual <a href="">CacheView</a> inside the cell. <br><br>  This ability, to present any widget as a hierarchy of CacheSpace-&gt; CacheItem-&gt; CacheView, gives us great control and introspection of the widget. <br><br>  For example, we can implement a single access interface to any of our widgets from the automated testing system.  The automatic GUI testing system usually queries the necessary area in the widget and then acts on this area with the mouse, simulating the user's actions.  We can provide such a system with the most detailed "map" of areas that can be affected. <br><br>  Another example is the animations presented in the video example.  We can not only see what our widget consists of, but also affect its component parts.  For example, you can change the location of any objects in the hierarchy (CacheSpace-&gt; CacheItem-&gt; CacheView) in time or draw them with translucency.  Thus, you can collect a whole library of animations that can be applied to any widget and to any space of cells. <br><br>  As a result, I want to once again list in which areas you can customize this library: <br><ol><li>  <a href="">Space</a> - you can create your own cell space types </li><li>  <a href="">CacheSpace</a> - you can create new types of display spaces, for example, implement CacheSpaceCourusel - display a list of cells in the form of carousel </li><li>  <a href="">View</a> - create new types of visualizations for cells </li><li>  <a href="">Animation</a> - create new animations </li></ol><br><br>  This note is a continuation of the previous two: <a href="http://habrahabr.ru/post/203968/">here</a> and <a href="http://habrahabr.ru/post/204374/">here</a> .  The <a href="https://github.com/lexxmark/qt-items">qt-items</a> project is an implementation of the ideas from these notes. <br><br>  There are still a lot of ideas and tasks for further development, so stay in touch. </div><p>Source: <a href="https://habr.com/ru/post/255573/">https://habr.com/ru/post/255573/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255559/index.html">The digest of interesting materials for the mobile # 98 developer (April 6-12)</a></li>
<li><a href="../255561/index.html">Techniques for designing game architecture</a></li>
<li><a href="../255565/index.html">ASN1js and PKIjs - a year after creation</a></li>
<li><a href="../255569/index.html">SSO on FreeIPA + Apache + Flask-Login + JWT</a></li>
<li><a href="../255571/index.html">Preview version of WinJS 4.0 announced: universal UX, integration with AngularJS, updated ListView</a></li>
<li><a href="../255579/index.html">Stephen Wolfram: Frontiers of Computational Thinking (SXSW Festival Report)</a></li>
<li><a href="../255583/index.html">Principles of Web Animation</a></li>
<li><a href="../255585/index.html">Daniil Dubrovkin: ‚ÄúBecause they don‚Äôt write open source, they didn‚Äôt become bad engineers‚Äù</a></li>
<li><a href="../255587/index.html">Attention! Phishing of registration data NIC.ru</a></li>
<li><a href="../255591/index.html">Android security report, a contest from Microsoft, a little more about mobile advertising - and other news of the week for a mobile developer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>