<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Algorithms and JDK data structures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[   ] 
 Periodically checking if there is any implementation of one or another standard algorithm in jdk, I got the idea to create a similar review. A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Algorithms and JDK data structures</h1><div class="post__text post__text-html js-mediator-article">  [ <a href="http://www.yetanothercoder.ru/2013/06/algorithms-and-data-structures-of-jdk-7.html"> </a> ] <br>  Periodically checking if there is any implementation of one or another standard algorithm in jdk, I got the idea to create a similar review.  Also interesting were the reasons for the presence / absence of many well-known data structures. <br>  The format of the review - only the key properties and features of the structures and algorithms in jdk, details and details - are painted in javadoc or easily found in the source. <br>  I hope for constructive criticism and collective intelligence if I missed it. <br>  Enough intro, so let's see what the current jdk 7 includes and why. <a name="habracut"></a><br><br><h4>  Structures </h4><br><h5>  Stack </h5><br>  In jdk, there is an old stack ( <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Stack.html">Stack</a> ), which exists since the release of java and is no longer recommended to use, it is complex and strange: inherited from <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html">Vector</a> , which means it is built on a dynamically expandable array and synchronized. <br>  Why this is all the usual stack and why this is not the interface is not entirely clear (discussed more than once: <a href="http://stackoverflow.com/questions/2922257/what-are-the-negative-aspects-of-java-class-stack-inheriting-from-vector">1</a> , <a href="http://stackoverflow.com/questions/8281752/replace-the-legacy-stack-with-what-from-java-collections">2</a> ), but it looks like a design error, the same as <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html">Vector</a> itself. <br>  Also in the javadoc itself, it is advised to use <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Deque.html">Deque instead</a> . <br><br>  <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Deque.html">Deque</a> is an interface (api) of a <a href="http://en.wikipedia.org/wiki/Double-ended_queue">two-way queue</a> (LIFO + FIFO for O (1)), which includes stack operations (push, pop, isEmpty, size).  Available in jdk not too long ago (1.6+). <br>  Of course, it would be easier if these stack operations were in the Stack interface, and Deque, for example, would inherit it, but since Stack was already present, and backward compatibility is for java ‚Äúour everything‚Äù, we had to sacrifice normal design. <br>  Deque implementations are <a href="http://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html">ArrayDeque</a> and <a href="http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html">LinkedList</a> , which in combination also implement the usual queue, so we will look at it later. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Queues </h5><br>  Next in order we look at the queue.  Everything is good here, the design is decent. <br>  <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Queue.html">Queue</a> - interface (api) FIFO of the queue, adding to the beginning, deleting from the end for O (1). <br><br>  The main implementations are <a href="http://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html">ArrayDeque</a> , a <a href="http://en.wikipedia.org/wiki/Circular_buffer">cyclic buffer</a> based on a dynamically expanding array (doubled when filled) and <a href="http://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html">LinkedList</a> , a classic <a href="http://en.wikipedia.org/wiki/Linked_list">doubly linked list</a> , the size is unlimited.  In a strange way, the first one does not support <a href="http://en.wikipedia.org/wiki/Random_access">random access</a> (add / remove / get with an index), the second one does, but during the O (n) iteration through the linked list. <br>  The same implementations implement the mentioned bilateral queue, which means removal from the end and addition to the beginning - also O (1). <br><br>  Then c jdk 1.5+ was added to the <a href="http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html">PriorityQueue,</a> which in fact violates the queue contract because  the elements are not taken from the end (they are also not put in the beginning), but according to their priorities. <br>  It is built on the basis of an expandable <a href="http://en.wikipedia.org/wiki/Binary_heap">binary heap</a> , at the top is the minimum element (according to its comparator), when filled, it increases in size by one and a half times.  The corresponding add / delete is O (log N), the reference to the minimum (head) is O (1). <br><br>  The remaining queue types are for multi-threaded use, such as BlockingQueue, TransferQueue, ConcurrentLinkedQueue, and ConcurrentLinkedDeque. <br><br>  Implementations BlockingQueue (ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue) are a kind of synchronized versions of their originals, i.e.  almost every operation is performed synchronously (blocked).  This also includes the DelayQueue - also synchronized, using PriorityQueue inside. <br><br>  While SynchronousQueue, TransferQueue (LinkedTransferQueue), ConcurrentLinkedQueue, ConcurrentLinkedDeque - are based on a different approach: they use <a href="http://www.cs.rochester.edu/u/michael/PODC96.html">non-blocking queue algorithms on linked lists</a> using <a href="http://en.wikipedia.org/wiki/Compare-and-swap">CAS</a> instructions that are well parallelized in a multiprocessor environment.  A detailed description is in the source. <br>  The algorithms of this class are quite extensive and new material, not yet completely standardized and structured, therefore it is beyond the scope of this review and rather a topic for a separate article. <br><br><h5>  Priority queues (heaps) </h5><br>  As already mentioned, since 1.5, there is a universal PriorityQueue, in addition there is another heap implementation in jdk.  This is the good old Timer, internal TaskQueue classic (on top of it is a task with minimal latency).  Naturally, this is a closed implementation and it cannot be used except inside the timer. <br><br><h5>  Lists </h5><br>  As you know there are sequential and / or random access. <br>  In java, the list is a List and 2 main implementations, the first is an ArrayList, supports random access, based on a <a href="http://en.wikipedia.org/wiki/Dynamic_array">dynamically expandable array</a> (increases by one and a half times when filled), but does not shrink itself when deleting elements, you need to call the provided method (trimToSize ). <br><br>  And the second is the already mentioned LinkedList, a doubly linked list of sequential access, the size is limited only by free jvm memory.  Although random access methods (by index) are also present - as already mentioned, they are executed here for O (n) <br><br>  For some reason, there is no simplest simply-connected list in java collections, although it probably wouldn‚Äôt hurt (2 times less overhead for links), as well as a simple stack. <br><br>  To use lists in a multithreaded environment, there is a CopyOnWriteArrayList (change operations - O (n)), a wrapper (synchonizedList), and also an outdated Vector. <br><br><h5>  Character tables </h5><br>  Represented by a binary tree and a hash table. <br><br>  The tree is the TreeMap (TreeSet), the SortedMap implementation (SortedSet, respectively), is based on the classic <a href="http://en.wikipedia.org/wiki/Red%25E2%2580%2593black_tree">red-black tree</a> , i.e.  Balanced and basic operations guaranteed for O (log N), unlimited in size. <br>  There are no other types of trees in jdk. <br><br>  Hash table - HashMap (HashSet) is probably the most used structure in java, built on a dynamically expanding <a href="http://en.wikipedia.org/wiki/Hash_table">hash table with chains</a> , with all the consequences: performance depends on the hash function, in the worst case O (N).  When the size reaches the specified loadFactor - doubles.  It is also worth noting that double hashing is used to protect against bad hash functions, in which sly bit arithmetic is applied to the result of the hashCode () call. <br><br>  There are jdk implementations of hash tables and with <a href="http://en.wikipedia.org/wiki/Hash_table">open addressing (linear probing)</a> .  One of them is IdentityHashMap, which also uses classic linear probing optimization when both keys and values ‚Äã‚Äãare stored in the same array next to each other, for better data caching (javadoc: "better locality for large tables than arrays") <br>  The second implementation is very specific: it serves only to store ThreadLocal elements (internal hidden classic ThreadLocalMap) and is certainly not available for use. <br><br>  Multi-threaded versions: ConcurrentHashMap, synchronizedMap, Hashtable, and ConcurrentSkipListMap.  A wrapper is naturally just a blocking version of a regular HashMap, Hashtable is the same, ConcurrentHashMap is a lock-striping version that allows for the reduction of critical sections (read about this better in <a href="http://jcip.net/">JCiP</a> , <a href="http://books.google.ru/books%3Fid%3DEK43StEVfJIC%26pg%3DPT256%26lpg%3DPT256%26dq%3Djava%2Block%2Bstriping%2Btechnique%26source%3Dbl%26ots%3Dun_xE7uNnv%26sig%3DDPo_S09nbiU1VFc1DhMsCB-fHRQ%26hl%3Dru%26sa%3DX%26ei%3D9rq1UYbhKYKH4ASv5oDwDQ%26ved%3D0CIEBEOgBMAk">here‚Äôs an excerpt</a> ). <br>  ConcurrentSkipListMap is a non-blocking version of <a href="http://en.wikipedia.org/wiki/Skip_list">the algorithm of the same name</a> adapted for the hash table (for more details, see the source code). <br><br>  Set sets (not allowing duplicates) are implemented through hash tables, so all that is said to hash tables is true for Set. <br><br><h5>  Counts </h5><br>  Graph structures and algorithms are not represented in jdk.  Therefore, in this case, it remains to use only third-party libraries. <br><br><h5>  Strings </h5><br>  The standard implementation is based on an array of unicode characters.  It is worth recalling that since version 1.7_17, performance substring is now O (n), since the substring is copied. <br><br>  It is interesting that to search for a substring, a simple search algorithm gives O (N * M) in the worst case, and not some <a href="http://en.wikipedia.org/wiki/String_searching_algorithm">effective algorithm</a> built on a state machine (Knuth-Morris-Pratt, etc.). <br>  There are several reasons: firstly, again, the large size of the alphabet of UTF characters (~ 65K), which means large overhead costs for storing the finite state machine, while the brute force algorithm is in-place (no additional memory is used). <br>  And secondly, the performance on average lines - in this, apparently, the search does not lose much to other algorithms. <br><br>  The same with sorting.  There are effective <a href="https://en.wikipedia.org/wiki/Radix_sort">row sorts by counting</a> (LSD, MSD, etc.), but jdk uses the standard for objects, giving O (M * N * log N) if most of the lines are not very different (M is the average length of the lines). <br>  The reason is the same: sorting by counting uses auxiliary arrays of the size of the alphabet UTF, which makes them ineffective on average input data. <br><br><h4>  Algorithms </h4><br><h5>  Sorting </h5><br>  In jdk7, there have been many changes regarding sorting options, the topic has been discussed repeatedly, the information and articles on this topic are full, I can advise <a href="http://www.javaspecialist.ru/2012/02/java.html">this review in</a> more detail. <br>  In short, the current list of sorting implementations currently available in jdk: <a href="http://en.wikipedia.org/wiki/Timsort">TimSort</a> - sorting objects by default, <a href="http://en.wikipedia.org/wiki/Merge_sort">merging</a> - also for objects, the old version (enabled through the system property), for primitives used <a href="http://iaroslavski.narod.ru/quicksort/DualPivotQuicksort.pdf">Dual-Pivot Quick sort</a> , for byte / character arrays counting sorting is used; for small arrays, in all cases <a href="http://en.wikipedia.org/wiki/Insertion_sort">sorting is</a> used. <br><br>  Sorting collections Collections.sort (List ...) is still done through copying to an array, sorting and then overwriting the collection.  Therefore, it is impossible to do this without standard costs, although it would probably do well to have in-place <a href="http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html">sorting of linked lists</a> . <br><br>  The object version is also used to sort the rows, the reasons are mentioned above. <br><br><h5>  Search </h5><br>  Traditional <a href="http://en.wikipedia.org/wiki/Binary_search_algorithm">binary search is</a> present for all arrays of primitives and objects as well as lists supporting random access. <br><br>  Moreover in Collections there is a version for linked lists.  It turns out that sorting for linked lists didn‚Äôt make sense, but the binary search was needed, although it makes even less sense since O (log N) performance isn‚Äôt close there. <br><br><h5>  Regular expressions </h5><br>  A traditional implementation based on non-deterministic finite state machine ( <a href="http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">NFA</a> ) and <a href="http://www.regular-expressions.info/catastrophic.html">backtracking is used</a> .  Those.  <a href="http://en.wikipedia.org/wiki/Regular_expression">exponential complexity</a> O (m ^ N) in the worst case on degenerate values, example: <br><br><pre><code class="java hljs"><span class="hljs-string"><span class="hljs-string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span></span>.matches(<span class="hljs-string"><span class="hljs-string">"(a|aa)*b"</span></span>)</code> </pre> <br><br>  Also has a so-called.  ‚ÄúOrdered alternation‚Äù is when the search stops immediately after finding the first match from several and not the most specific (long) match, for <a href="http://stackoverflow.com/questions/4515309/java-regex-alternation-operator-behavior-seems-broken">example</a> . <br><br><h5>  Hash functions, checksums </h5><br>  The hashCode calculation algorithms in jdk are as many as six, <a href="http://en.wikipedia.org/wiki/Park-Miller_random_number_generator">Park-Miller_random_number_generator is</a> used by default, a more <a href="http://habrahabr.ru/post/165683/">recent article on</a> <a href="http://en.wikipedia.org/wiki/Park-Miller_random_number_generator">Habr√© is used</a> in more detail. <br><br>  There are also standard industrial hashing algorithms (SHA- *, MD5 and variations) - <a href="http://docs.oracle.com/javase/7/docs/api/java/security/MessageDigest.html">MessageDigest</a> <br><br>  To calculate the checksums, there are also implementations of the <a href="http://en.wikipedia.org/wiki/Adler-32">Adler-32</a> ( <a href="http://docs.oracle.com/javase/7/docs/api/java/util/zip/Adler32.html">javadoc</a> ) and <a href="http://en.wikipedia.org/wiki/CRC32">CRC32</a> ( <a href="http://docs.oracle.com/javase/7/docs/api/java/util/zip/CRC32.html">javadoc</a> ) algorithms <br><br><h5>  Compression </h5><br>  In jdk there is an implementation of the standard compression algorithm deflate ( <a href="http://docs.oracle.com/javase/7/docs/api/java/util/zip/Deflater.html">Deflater</a> ) and also based on it zip / gzip.  All this in <a href="http://docs.oracle.com/javase/7/docs/api/java/util/zip/package-summary.html">java.util.zip</a> <br><br><h4>  Conclusion </h4><br>  As you can see, the classic data structures in java are far from complete, but at the same time there are several options for thread-safe versions for almost everyone. <br>  What is missing is an open question.  For example, it is possible to argue whether some <a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">Union-Find is</a> needed in jdk, but the absence of graph structures and algorithms in the age of social networks in a language that claims to be the most universal is surprising, <s>bugs and bicycles are</s> surprising. </div><p>Source: <a href="https://habr.com/ru/post/182776/">https://habr.com/ru/post/182776/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182764/index.html">CONFidence. Again about how cool it is</a></li>
<li><a href="../182766/index.html">KidsReview.ru - entry with children is allowed</a></li>
<li><a href="../182770/index.html">Grodnohost closes?</a></li>
<li><a href="../182772/index.html">Second chance or how I fixed the monitor outside the box</a></li>
<li><a href="../182774/index.html">How to make iPhone external buttons work for you</a></li>
<li><a href="../182778/index.html">Technology of ‚Äúdrawn sound‚Äù: sound synthesis in the USSR of the 30s of the XX century</a></li>
<li><a href="../182780/index.html">Simple Android app framework</a></li>
<li><a href="../182782/index.html">HTML5 ASCII Art Generator</a></li>
<li><a href="../182784/index.html">Voxel graphics do-it-yourself - first steps</a></li>
<li><a href="../182786/index.html">Installing any clone of Red Hat Enterprise Linux without using a standard installer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>