<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Closures in Javascript [Part 1]</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of an article by Richard Cornford Javascript Closures . 



- Introduction 
- Resolving object property names Assignment of values Reading...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Closures in Javascript [Part 1]</h1><div class="post__text post__text-html js-mediator-article">  Translation of an article by Richard Cornford <a href="http://jibbering.com/faq/notes/closures/">Javascript Closures</a> . <br><br><ul><li>  Introduction </li><li>  Resolving object property names <br><ul><li>  Assignment of values </li><li>  Reading values </li></ul><br></li><li>  Identifier Name Resolution, Execution Contexts, and Scoping Chain <br><ul><li>  Execution context </li><li>  The scope chain and the [[scope]] property </li><li>  Identity Name Resolution </li></ul><br></li><li>  ... </li></ul><br><h2>  Introduction </h2><br>  Short circuit <br><blockquote>  A closure is an expression (usually a function) that can have free variables, along with an environment that binds these variables (that is, ‚Äúcloses‚Äù this expression). </blockquote><br>  Closures are among the most powerful features of ECMAScript (javascript), but they cannot be properly applied without understanding.  Despite the fact that they are easy to create, even by accident, their creation can have detrimental effects, in particular, in some relatively common browser environments.  To avoid accidental collisions with flaws and to take advantage of closures, it is necessary to understand their mechanism.  This is highly dependent on the role of the scope chain in identifier resolution resolution and on the resolution of property names in objects. <br><br>  The simplest explanation of the closure is that ECMAScript allows nested functions, function definitions and function expressions (function expressions) within the bodies of other functions.  And these nested functions have access to all local variables, parameters and functions that are inside their external function (external functions).  A closure occurs when one of these nested functions becomes available outside the function in which it was included, so it can be executed after the external function completes.  At this point, she still has access to local variables, parameters, and internal function declarations (function declarations) of her external function.  These local variables, parameters and function declarations (initially) have the same values ‚Äã‚Äãthat were at the time of the completion of the external function and can interact with the internal function. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Unfortunately, a proper understanding of closures requires an understanding of the mechanisms behind them, and quite a few technical details.  Although some of the algorithms defined in ECMA 262 are affected at the beginning of the following explanation, most cannot be omitted or simply reduced to a simplified form.  If you are familiar with resolving object property names, you can skip this section, but only people who are already familiar with closures can afford to skip subsequent sections and stop reading right now and return to using them. <br><a name="habracut"></a><br><h2>  Resolving object property names </h2><br>  ECMAScript recognizes two categories of objects: native objects ‚ÄúNative Object‚Äù and objects of the environment ‚ÄúHost Object‚Äù and a subcategory of native objects called built-in objects ‚ÄúBuilt-in Objects‚Äù (ECMA 262 3rd Ed Section 4.3).  Native objects belong to the language, and host objects are provided by the environment and can be, for example, a document object, DOM nodes, etc. <br><br>  Native objects are free and dynamic containers of named properties (some implementations are not so dynamic when it comes to the subcategory of embedded objects, although this usually does not matter).  Certain named properties of a native object store values ‚Äã‚Äãthat can be referenced by another object (functions are also objects in this sense) or elementary values: String, Number, Boolean, Null, or Undefined.  The primitive type Undefined is a bit unusual in the sense that you can set the property of an object to <b>undefined</b> , but the property will not be removed from the object;  it will remain a named property of the object, which simply stores the value <b>undefined</b> . <br><br>  The following is a simplified explanation of how the properties of objects are read and set, with as much internal details as possible, including internal details. <br><br><h4>  Assignment of values </h4><br>  Named properties of objects can be created, or the values ‚Äã‚Äãof existing named properties can be set, by assigning a value to a named property. <br>  In this way, <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objectRef = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>(); <span class="hljs-comment"><span class="hljs-comment">//   (generic)  javascript.</span></span></code> </pre> <br>  A property named "testNumber" can be created like this: <br><pre> <code class="javascript hljs">objectRef.testNumber = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> objectRef[<span class="hljs-string"><span class="hljs-string">"testNumber"</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  The object did not have the <b>testNumber</b> property before assigning a value, but it was created after.  Any subsequent assignments do not need to create this property, they will simply change its value. <br><pre> <code class="javascript hljs">objectRef.testNumber = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> objectRef[<span class="hljs-string"><span class="hljs-string">"testNumber"</span></span>] = <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre><br>  Javascript objects have prototypes that can themselves be objects, as will be briefly described later, and these prototypes can have named properties.  But this does not apply to assignment.  If a value is assigned and the object does not have a property with the corresponding name, then this property will be created and the value assigned to it.  If the object has such a property, its value will be reset. <br><br><h4>  Reading values </h4><br>  It is when reading values ‚Äã‚Äãthat prototype objects are used.  If the object has a property with the name used in the property accessor expression (property accessor), then the value of this property will be returned. <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*    .           ,     */</span></span> objectRef.testNumber = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = objectRef.testNumber; <span class="hljs-comment"><span class="hljs-comment">/*  val    8,        . */</span></span></code> </pre><br>  But all objects can have prototypes, and prototypes are objects and, in turn, can have prototypes that can have prototypes, etc., forming what is called a chain of prototypes.  A prototype chain ends when one of the objects in the chain has a <b>null</b> prototype.  The default prototype with the <b>Object</b> constructor has a <b>null</b> prototype, so <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objectRef = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>(); <span class="hljs-comment"><span class="hljs-comment">//   (generic)  javascript</span></span></code> </pre><br>  creates an object with the prototype <b>Object.prototype</b> , which itself has a <b>null</b> prototype.  Then the prototype chain of the <b>objectRef</b> object contains only one object: <b>Object.prototype</b> .  But, <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*  ‚Äú‚Äù     MyObject1.*/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyObject1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">formalParameter</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*    testNumber    ,  ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testNumber = formalParameter; } <span class="hljs-comment"><span class="hljs-comment">/*  ‚Äú‚Äù     MyObject2 */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyObject2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">formalParameter</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*  testString      ,  ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testString = formalParameter; } <span class="hljs-comment"><span class="hljs-comment">/*   ,   ,      MyObject2,   MyObject1,   8   MyObject1,     testNumber     */</span></span> MyObject2.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyObject1( <span class="hljs-number"><span class="hljs-number">8</span></span> ); <span class="hljs-comment"><span class="hljs-comment">/*,    MyObject2    objectRef    ,        */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objectRef = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyObject2( <span class="hljs-string"><span class="hljs-string">"String_Value"</span></span> );</code> </pre><br>  The instance of the <b>MyObject2</b> object referenced by the <b>objectRef</b> variable has a prototype chain.  The first object in this chain is an instance of the object <b>MyObject1</b> , which was created and assigned to the <b>prototype</b> property of the constructor <b>MyObject2</b> .  An instance of <b>MyObject1</b> has as its prototype an object that has been assigned to the <b>prototype</b> property of the <b>MyObject1</b> function by default.  This prototype is the default prototype of an <b>Object</b> , i.e.  the object referenced by the <b>Object.prototype</b> .  <b>Object.prototype</b> has a <b>null</b> prototype, so the chain ends at this point. <br><br>  When a property access expression tries to read a named property from an object referenced by an <b>objectRef</b> , the whole prototype chain can participate in the process.  In the simple case <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = objectRef.testString;</code> </pre><br>  - an instance of <b>MyObject2</b> , accessible via <b>objectRef</b> , has a property named <b>testString</b> , therefore the value of this property is set to <b>String_Value</b> , and it is assigned to the variable <b>val</b> . <br>  However, <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = objectRef.testNumber;</code> </pre><br>  cannot read a property from the very instance of the <b>MyObject2</b> function, since  it does not have this property, but the variable <b>val is</b> set to <b>8</b> , not <b>undefined</b> , because the interpreter checks the object, which is its prototype, due to an unsuccessful search for the corresponding named property in the object itself.  Its prototype is an instance of the function <b>MyObject1</b> , which was created with the <b>testNumber</b> property with a value of <b>8</b> assigned to this property, so the property access expression is calculated as the value <b>8</b> .  Neither <b>MyObject1</b> nor <b>MyObject2</b> defines the <b>toString</b> method, but if the property access expression tries to read the value of the <b>toString</b> property from the <b>objectRef</b> , <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = objectRef.toString;</code> </pre><br>  then the variable <b>val is</b> assigned a function reference.  This function is the <b>toString</b> property of the <b>Object.prototype</b> object and is returned as a result of the prototype verification process: the <b>objectRef</b> object is <b>checked</b> , after the absence of the <b>toString</b> property is <b>detected</b> , the <b>objectRef</b> prototype is <b>checked</b> and when it turns out that it does not have this property, in turn its prototype is checked.  Its prototype is the <b>Object.prototype</b> , which has a <b>toString</b> method and the link is returned to this function. <br><br>  Finally: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = objectRef.madeUpProperty;</code> </pre><br>  - returns <b>undefined</b> , because the process that processes the prototype chain does not find properties with the name <b>madeUpProperty</b> in any of the objects, it ultimately reaches the prototype of the <b>Object.prototype</b> object, i.e.  <b>null</b> , and then the process ends, returning <b>undefined</b> . <br><br>  Reading named properties returns the first value found from an object or from its prototype chain.  Assigning a value to a named property of an object will create a property in the object itself if the corresponding property does not already exist. <br><br>  This means that if the value was assigned to <b>objectRef.testNumber = 3</b> , then the <b>testNumber</b> property will be created in the instance of the <b>MyObject2</b> function and subsequent attempts to read the value will result in the return of the value that is set in the object.  Now, the execution of the prototype chain processing is no longer required to execute the property access expression, but the instance of the <b>MyObject1</b> object with the value <b>8</b> assigned to the <b>testNumber</b> property is not changed.  Assigning a value to an <b>objectRef</b> simply hides the corresponding property in its prototype chain. <br><br>  Note that ECMAScript defines an internal <b>[[prototype]]</b> internal property of type <b>Object</b> .  This property is not directly accessible to scripts, but there is a chain of objects referenced by the <b>[[prototype]]</b> internal property, which is used in resolving access property expressions;  this chain is a chain of object prototypes.  The public property <b>prototype</b> exists for assigning values, defining, and manipulating prototypes along with the internal <b>[[prototype]]</b> property.  Details of the relationship between these two properties are described in ECMA 262 (3rd edition) and are not included in this discussion. <br><br><h2>  Identifier Name Resolution, Execution Contexts, and Scoping Chain </h2><br><h4>  Execution context </h4><br>  <i>The execution context</i> is an abstract concept that is used in the ECMAScript specification (ECMA 262 3rd edition) to define the behavior required from ECMAScript implementations.  The specification says nothing about how the <i>execution context</i> should be implemented, but <i>execution contexts</i> have associative attributes that refer to structures defined in the specification, so they can be conceived (or even implemented) as objects with properties, albeit closed ones. <br><br>  All javascript code is executed in <i>execution context</i> .  The global code (embedded code in the html page or in the JS file or executed after the page loads (loads)) is executed in the <i>global execution context</i> and each function call (possibly as a constructor) has a corresponding execution context.  The code executed using the <b>eval</b> function also receives a specific execution context, but since <b>eval is</b> usually not used by javascript programmers, it will not be discussed here.  Specified details of <i>execution contexts</i> can be found in section 10.2 of ECMA 262 (3rd edition). <br><br>  When the javascript function is called, it adds <i>the execution context</i> , if another function is called (or the same function recursively), a new <i>execution context</i> is created, and the execution process adds this context during the function call.  When the called function is completed, the initial <i>execution context is</i> returned.  Thus, the javascript executable code forms a stack of <i>execution contexts</i> . <br><br>  When the <i>execution context</i> is created, several things happen in a certain order.  First, in <i>the execution context</i> , an Activation object is created.  The activation object is another mechanism from the specification.  It can be considered as an object, because as a result it has available named properties, but it is not an ordinary object, since  it does not have a prototype (at least, the prototype is not defined) and there can be no links to it in javascript code. <br><br>  The next step in creating <i>the execution context</i> for a function call is to create a <b>arguments</b> object, this is a massive object with elements indexed by integers that correspond to the arguments sent to the function in the given order.  It also has the <b>length</b> and <b>callee</b> properties (which are not relevant to our discussion, details in the specification).  A property of the activation object is created with the name <b>arguments</b> , which is assigned a reference to the <b>arguments</b> object. <br><br>  Then <i>the execution context</i> assigns a <i>scope</i> .  <i>The scope</i> consists of a list (or chain) of objects.  Each function object has an internal <b>[[scope]]</b> property (which we will soon discuss in more detail), which also consists of a list (or chain) of objects.  <i>The scope</i> assigned to <i>the execution context of a</i> function call consists of the list referenced by the <b>[[scope]]</b> property of the corresponding function object, and of the activation object added to the beginning of the chain (or at the top of this list). <br><br>  Then comes the process of creating variables (variable instantiation) using an object, which is defined in ECMA 262 as an object of variables (Variable object).  At the same time, the activation object is used as an object of variables (note that this is one and the same object, this is important).  Named properties of the variable object are created for each formal parameter of the function, and if the arguments in the function call correspond to these parameters, then the arguments are assigned to these properties (otherwise, they are assigned <b>undefined</b> ).  The definition of internal functions is used to create function objects that are assigned to the properties of the variable object with the names corresponding to the function names used in the function declarations.  The final stage in creating variables is to create named object properties for variables that correspond to all local variables defined inside the function. <br><br>  Properties created in the object of variables that correspond to declared local variables initially get the value <b>undefined</b> during the creation of variables; local variables are not initialized until the corresponding assignment operation is performed during execution of the function body code. <br><br>  In fact, an activation object with the <b>arguments</b> property and an object of variables with named properties corresponding to the local variables of the function are the same object that allows you to treat the <b>arguments</b> identifier as a local variable of the function. <br><br>  Finally, the value used with the this keyword is assigned.  If this value refers to an object, then property access expressions with the prefix of <b>this</b> refer to the properties of this object.  If this value (assigned inside the function) is <b>null</b> , then <b>this</b> will refer to the global object. <br><br>  The processing of the global execution context is slightly different, it has no arguments, so it does not need to define an activation object to refer to them.  The global execution context needs a scope and its chain contains only one object - a global object.  The global execution context goes through the creation of variables, its internal functions are the usual top-level declaration functions that make up most of the javascript code.  A global object is used as an object of variables, which is why functions declared globally become properties of a global object.  The same with globally declared variables. <br><br>  The global execution context also uses the reference to the global object as the value of <b>this</b> . <br><br><h4>  The scope chain and the [[scope]] property </h4><br>  <i>The scope chain of the</i> execution context of a function call is assembled by adding an activation object (variable object) to the beginning of <i>the scope chain</i> contained in the <b>[[scope]]</b> property of the function object, so it is important to understand how the <b>[[scope]]</b> internal property is defined. <br><br>  In ECMAScript, functions are objects, they are created during the creation of variables from function declarations, during the execution of a function-expression (Function Expression) or by calling the <b>Function</b> constructor. <br><br>  Function objects created by the <b>Function</b> constructor always have the <b>[[scope]]</b> property referencing the <b>scope</b> <i>chain</i> that contains only the global object. <br><br>  Function objects created by a function declaration or function-expression have <i>the scope of</i> the execution context in which they are created, which is assigned to their internal <b>[[scope]]</b> property. <br><br>  In the simplest case, the declaration of a global function, such as <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">formalParameter</span></span></span><span class="hljs-function">)</span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre><br>  the corresponding function object is created during the creation of variables for the global execution context.  The global execution context has a <i>scope</i> consisting of only a global object. <br><br>  ,    ,       <b>exampleFunction</b> ,    <b>[[scope]]</b> ,    <i> </i> ,    . <br><br>          -    <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exampleFuncRef = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre><br>   ,                ,     ,           ,     .          ,   <b>[[scope]]</b>            . <br><br>     -     ,      ,      <i>  </i> .   ,       ,      <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleOuterFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">formalParameter</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleInnerFuncitonDec</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">//    } ... //      } exampleOuterFunction( 5 );</span></span></code> </pre><br>  ,    ,         ,    <b>[[scope]]</b>  <i>  </i> ,     . <br><br>      <b>exampleOuterFunction</b> ,             ( ). <i> </i>     ,     ,    ,     <b>[[scope]]</b>   (  ).           ,    ,  <b>[[scope]]</b>       <i> </i>  ,     . <i>  </i>   ,     . <br><br>             . <i>  </i>     <b>[[scope]]</b>          <b>[[scope]]</b>        (    ).  ECMAScript   <b>with</b>     . <br><br>  <b>with</b>      ,     <i>  </i>    (   /).  <b>with</b>    (   )    <i>  </i>     . <br><br>  <b>with</b>      ,          ,  -      <b>with</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*    y,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = {<span class="hljs-attr"><span class="hljs-attr">x</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//     x function exampleFuncWith(){ var z; /*  ,     y,      */ with(y){ /*  -,    ,          z */ z = function(){ ... //   -; } } ... } /*   exampleFuncWith */ exampleFuncWith();</span></span></code> </pre><br>   <b>exampleFuncWith</b> ,      <i>  </i> ,            .   <b>with</b>  ,      <b>y</b> ,    <i>  </i>  ,    -.    <b>[[scope]]</b> ,   -,  ,   <i> </i>  ,      . <i> </i>    <b>y</b> ,          ,     . <br><br>     <b>with</b> , <i> </i>    ( <b>y</b> ),            <b>[[scope]]</b>    <i>  </i>   <b>y</b>   . <br><br><h4>    </h4><br>     <i>  </i> . ECMA 262  <b>this</b>    ,   ,    , ..        <b>this</b> ,     ,    ,    <i>  </i> . <br><br>         <i>  </i> .   ,     ,  . - ,  <i>  </i>   ,         (  ).            <i>  </i> ,      .     ,       (     )     ,  ,       . <br><br>       ,       ,   . ,   <i>  </i>    ,        ,        .        . <br><br>          ( )   , ,    ,  ,     ,       .         ( ). <br><br>      . <br><br> <a href="http://habrahabr.ru/post/229887/">  Javascript [ 2]</a> </div><p>Source: <a href="https://habr.com/ru/post/223459/">https://habr.com/ru/post/223459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../223449/index.html">SQLite file structure</a></li>
<li><a href="../223451/index.html">SQLite internal tables</a></li>
<li><a href="../223453/index.html">Samsung secretly released a dream phone</a></li>
<li><a href="../223455/index.html">Fight for traffic. How to get a site out of Google spam filter (Part Two)</a></li>
<li><a href="../223457/index.html">A place where you can test the strength of enterprise-software in the center of Symantec solutions</a></li>
<li><a href="../223461/index.html">Why, why, our Protons do not fly</a></li>
<li><a href="../223463/index.html">Dangerous security</a></li>
<li><a href="../223465/index.html">Contest ‚ÄúBig ky $ h‚Äù on PHDays: the image of the RBS system is available for download</a></li>
<li><a href="../223477/index.html">Braille keyboard phone went on sale</a></li>
<li><a href="../223481/index.html">AT & T flooded New York charging stations for smartphones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>