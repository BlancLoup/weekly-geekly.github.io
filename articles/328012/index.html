<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Redux as the heart of the front-end architecture of the Unified Frontal System</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article, we told how the front-end of the program was arranged in general, and discussed the technological stack. This article is devoted ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Redux as the heart of the front-end architecture of the Unified Frontal System</h1><div class="post__text post__text-html js-mediator-article">  In the last <a href="https://habrahabr.ru/company/efs/blog/325916/">article,</a> we told how the front-end of the program was arranged in general, and discussed the technological stack.  This article is devoted to the discussion of Redux - why we call it the heart of the architecture of the EFS. <br><br> <a href="https://habrahabr.ru/company/efs/blog/328012/"><img src="https://habrastorage.org/getpro/habr/post_images/119/05b/58c/11905b58cbc22e4d37dd460ea8467f3d.png"></a> <br><a name="habracut"></a><br>  At first, when we chose React as the key technology for our frontend, we experimented a lot with various flux implementations: we didn‚Äôt want to write our implementation.  We looked at two implementations: alt and redux.  Since redux promotes a functional approach to development, and in the state we had a lot of java-developers accustomed to object-oriented programming, in their opinion, alt turned out to be simpler.  From a subjective point of view, he had a major advantage: alt contained the magic component AltContainer, which passed the <b>Instance</b> <b>Store</b> to the child component through Props.  Initially, it worked perfectly: we have a small application, within which there are several stores that are not interconnected.  However, as the functionality increased, we began to realize that this technology was erroneous for us and the application became huge and uncontrollable. <br><br><h2>  One truth to rule'em all </h2><br>  When we thought about how to implement the router in the application, we relied on react-router.  On the backend, we then used Spring WebFlow and had the desire to make react-router friends with WebFlow.  As a result, due to the peculiarities of the react-router implementation, we were unable to implement anything, but we saw how it was implemented.  Active work began on our component, which eventually received the name SWFRouter: the backend told us the id of the form that we output to the page, and we conducted the data from the backend through a special field in the react-context.  It so happened that not only we are experimenting with technology.  Backend developers abandoned SWF in favor of their own development, called Workflow.  What to do next - SWFRouter is no longer needed, a different solution is needed.  We didn‚Äôt want to rewrite the current implementation much by going to a slightly modified version called WFRouter.  However, he could not satisfy our ambitions.  We needed a single source of truth that could guide us where to go next.  No longer thinking of routers, we switched to a slightly different concept: no routers - only flux.  We came to the conclusion that alt did not suit us to implement the general logic of the application, and we finally returned to redux. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      About what redux is and how it works, there are already a lot of articles, but we‚Äôll stop at a little introductory.  Each time an action triggers, the corresponding reducer fires, returning a new state.  Redux adheres to the immutable pattern, which allows you to return to any state of the application at any time.  In addition, there is support for middleware, i.e.  we can embed our functions in the state update process. <br><br>  With redux, switching applications became simple: a special action sent data to the backend, which returned either the id of the following form, or the URL to the bundle for subsequent download.  We develop applications for the workplace independently of each other, and when released, we transfer the assembled bundle for subsequent deployment.  This is convenient because we can assemble a business process from individual applications created by different groups of developers. <br><br>  Let's say we have a task scheduler.  Clicking on the task, we get into the application that allows you to perform it.  Having performed the necessary operations, we return to the scheduler and see that its state is similar to what it was before the transition.  When we went to the task, we completely unloaded the scheduler from the memory, however, we saved its state in the persistent storage, which allowed it to be loaded again upon return.  To do this, we used a special middleware, which gave us the state to save it later. <br><br>  So how does the workplace work?  We basically abandoned the idea of ‚Äã‚Äãusing an iframe, since  this creates overhead and the need for workaround in the case of pop-ups. <br><br>  The workplace consists of several components: AppContainer is a component for asynchronous loading of AMD modules, UFSProvider is a component wrapper over the Provider component from the react-redux module, which creates a store and passes some set of reducer's to it to connect the entire architecture into a single whole.  But first things first. <br><br><h2>  Appcontainer </h2><br><h3>  Props </h3><br><ul><li>  loadUrl - { <i>() =&gt; Promise &lt;React.Component&gt;</i> } - function that returns Promise, returns React.Component <br></li><li>  defaultUrl - { <i>string</i> } - default application URL <br></li><li>  defaultData - { <i>Object</i> } - data passed to the loaded application <br></li></ul><br>  In the draft, the number of forms exceeded several thousand, and it would be a mistake to make it a monolithic application, since  each form has its own development, testing and deployment cycle.  AMD was chosen as a modular system: each project packs its own set of forms into an AMD-module, which is a React-component.  With the help of SystemJS, the next application is loaded; when it is loaded, it returns a promise, which is passed to the AppContainer component.  After loading, the application is drawn inside AppContainer, and the reducer special field of the loaded application passes the root reducer, which is responsible for the application logic and is passed as a property to the UFSProvider component. <br><br><h2>  UFSProvider </h2><br><h3>  Props </h3><br><ul><li>  reducer - {function} - reducer for workplace logic <br></li></ul><br>  As mentioned earlier, UFSProvider creates a store with pre-configured reducer.  We do not create a separate store for each application, instead we provide a piece of the existing one.  We divided the store logic into five components: <br><br><img src="https://habrastorage.org/web/a0a/cf7/4b4/a0acf74b417a4ac180fa49bbde4632ae.png"><br><br><ul><li>  appContainer - the logic used by the AppContainer component to download applications <br></li><li>  workspace is the logic of the workplace, i.e.  the entire wrapper around the application <br></li><li>  app - directly loaded application logic <br></li><li>  workflow - the logic of the transition between the forms given by the <b>backend</b> <b><br></b> <br>  hints - special reducer for the introduction of hints on forms <br></li></ul><br>  Each time an application in the AppContainer is replaced, the set of reducer's in the app is replaced.  If necessary, the previously saved state is transferred to the initialState. <br><br><h2>  Tips </h2><br>  The cornerstone in many applications is incomprehensible to a simple user prompts, which the programmer wrote in haste.  We strive to ensure that all the hints in the interface are clear to the user.  To do this, we created a special admin panel for prompts.  From our library of components we deliver a specific set of tips: block, pop-up and others.  All of them at the library level are connected to the state, i.e.  already wrapped in the connect function.  It is enough for the developer to specify only the hint code, and the text itself will be picked up from the state.  So how does it work?  Each time we access the server, we check the presence of the <i>hints</i> field in the response, if it exists, we transfer the contents of this field to state and thus the ‚Äúterminated‚Äù components will receive text instead of code. <br><br><h2>  Download multiple applications </h2><br>  Everything described above works fine when there is only one application on the page.  But what to do when such applications must be simultaneously loaded two or more?  At the same time, applications should be able to exchange data between themselves.  For this case, we set up the UFSProvider in such a way that at each action the event goes to a common data bus.  In addition, we pass the state application.  This was made possible thanks to special middleware, which transmits action and state to a special object.  Now we insert into the page several AppContainer pairs - UFSProvider and set some logic.  Suppose application A must respond to application B event, for this, A subscribes to action B of application B and implements its own logic. <br><br>  Perhaps this is the main thing that we wanted to talk about Redux technology in the Program.  The main thing is not to be afraid of experiments and create such an architecture that is right for you. <br><br>  We will be happy to talk about this and other current topics of front-end development in the comments to the article. </div><p>Source: <a href="https://habr.com/ru/post/328012/">https://habr.com/ru/post/328012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328002/index.html">SimplePage: a simple, declarative framework for rapid prototyping</a></li>
<li><a href="../328004/index.html">Part 3. Where to store data for decentralized applications on the blockchain?</a></li>
<li><a href="../328006/index.html">‚ÄúThe incident with Gitlab is a very good and revealing story‚Äù, - Alexey Lesovsky about PostgreSQL administration</a></li>
<li><a href="../328008/index.html">UAC Bypass or the story of three escalations</a></li>
<li><a href="../328010/index.html">Bildim under stm32duino using CMake (and scavenging from the linker)</a></li>
<li><a href="../328014/index.html">Build 2017: text translation. Day 1</a></li>
<li><a href="../328018/index.html">Work with real-time logging with Heka. Experience Yandex. Money</a></li>
<li><a href="../328022/index.html">Interactive 3D-installation based on "Star Wars"</a></li>
<li><a href="../328024/index.html">Video: Uptime Day, conference about monitoring and 24/7 support</a></li>
<li><a href="../328026/index.html">Mobilization without "headache"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>