<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Test :: Spec: pros, cons and features</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Test :: Spec ( https://metacpan.org/pod/Test::Spec ) is a module for declarative writing of Perl unit tests. We in REG.RU actively use it, so I want t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Test :: Spec: pros, cons and features</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/9c2/e1a/38a/9c2e1a38a2984b849b7f6e3fa6297198.jpg" alt="image"></div><br>  Test :: Spec ( <a href="https://metacpan.org/pod/Test::Spec">https://metacpan.org/pod/Test::Spec</a> ) is a module for declarative writing of Perl unit tests.  We in REG.RU actively use it, so I want to tell why it is needed, how it differs from other modules for testing, to point out its advantages, disadvantages and peculiarities of implementation. <br><br>  This article is not an introduction to unit testing in general, nor to the use of Test :: Spec in particular.  Information on using Test :: Spec can be obtained from the documentation ( <a href="https://metacpan.org/pod/Test::Spec">https://metacpan.org/pod/Test::Spec</a> and <a href="https://metacpan.org/pod/Test::Spec::Mocks">https://metacpan.org/pod/Test::Spec::Mocks</a> ).  The article deals with the specifics and nuances of this module. <br><br><a name="habracut"></a>  <b>Table of contents:</b> <br>  <b><a href="https://habr.com/ru/company/regru/blog/239417/">Specifications for the code being tested</a></b> <br>  <b><a href="https://habr.com/ru/company/regru/blog/239417/">Unit testing using mock objects</a></b> <br>  <b><a href="https://habr.com/ru/company/regru/blog/239417/">More small utility</a></b> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">Clear exception output</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">Automatically imports strict / warnings;</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">Simple and convenient selective test run</a> <br>  <b><a href="https://habr.com/ru/company/regru/blog/239417/">There is no alternative</a></b> <br>  <b><a href="https://habr.com/ru/company/regru/blog/239417/">Features work and rake</a></b> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">Displaying test names in ok / is / other does not work</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">Do not place tests inside before / after</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">Before / after blocks change code structure</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">Local operator no longer works</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">DSL</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">Global caches</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">Global variables</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">How different?</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">More about it and local</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">Common code</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">It is difficult to write helpers that work simultaneously with both Test :: Spec and Test :: More</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">The with function only works for classes.</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">The with function does not see the difference between a hash and an array.</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">Problems testing things like memory leaks</a> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">The use_ok function is out of place</a> <br>  <b><a href="https://habr.com/ru/company/regru/blog/239417/">Interesting</a></b> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">How objects are technically forged</a> <br>  <b><a href="https://habr.com/ru/company/regru/blog/239417/">findings</a></b> <br>  <a href="https://habr.com/ru/company/regru/blog/239417/">Test :: Spec is good for unit testing high level code.</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <br><a name="spec"></a><h2>  <font color="#000"><b>Specifications for the code being tested</b></font> </h2><br>  Take a simple test on Test :: More. <br><br>  Test code: <br><pre><code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> MyModule; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mid</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($first, $last) = @_; $first + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>( ($last - $first) / <span class="hljs-number"><span class="hljs-number">2</span></span> ); } <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  The test itself: <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::More; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> MyModule; is MyModule::mid(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"mid should work"</span></span>; is MyModule::mid(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"mid should round the way we want"</span></span>; done_testing;</code> </pre><br>  work result: <br> <code>ok 1 - mid should work</code> <br> <code>ok 2 - mid should round the way we want</code> <br> <code>1..2</code> <br> <br>  The equivalent test for Test :: Spec: <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> MyModule; describe <span class="hljs-string"><span class="hljs-string">"MyModule"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ describe <span class="hljs-string"><span class="hljs-string">"mid"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is MyModule::mid(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>; }; it <span class="hljs-string"><span class="hljs-string">"should round the way we want"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is MyModule::mid(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>; }; }; }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br>  and the result of his work: <br> <code>ok 1 - MyModule mid should work</code> <br> <code>ok 2 - MyModule mid should round the way we want</code> <br> <code>1..2</code> <br> <br>  Everything is very similar.  Differences in the structure of the test. <br><br>  Test :: Spec is a way to declare the specifications for the code under test declaratively.  This module is created in the likeness of the well-known RSpec package from the Ruby world, which, in turn, works in accordance with the principles of TDD and BDD.  The specification for the code being tested describes the functional behavior of the code being tested ( <a href="http://en.wikipedia.org/wiki/Behavior-driven_development">http://en.wikipedia.org/wiki/Behavior-driven_development#Story_versus_specification</a> ).  It makes it easier to read the source code of the test and to understand what we are testing and how.  At the same time, the lines describing the behavior and the entities with which this behavior corresponds are used when displaying information about successful or failed tests. <br><br>  Compare these entries: <br><br>  <b>Ruby:</b> <br><pre> <code class="ruby hljs">describe SomeClass <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> describe <span class="hljs-symbol"><span class="hljs-symbol">:process</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @instance = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> before <span class="hljs-symbol"><span class="hljs-symbol">:all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @instance = SomeClass.new(<span class="hljs-number"><span class="hljs-number">45</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> it <span class="hljs-string"><span class="hljs-string">"should return to_i"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @instance.to_i.should == <span class="hljs-number"><span class="hljs-number">45</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  <b>Perl:</b> <br><pre> <code class="perl hljs">describe <span class="hljs-string"><span class="hljs-string">SomeClass =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ describe <span class="hljs-string"><span class="hljs-string">process =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $instance; before <span class="hljs-string"><span class="hljs-string">all =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ $instance = SomeClass-&gt;new(<span class="hljs-number"><span class="hljs-number">45</span></span>); }; it <span class="hljs-string"><span class="hljs-string">"should return to_i"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is $instance-&gt;to_i, <span class="hljs-number"><span class="hljs-number">45</span></span>; }; }; };</code> </pre><br>  <b><a href="https://metacpan.org/pod/Test::Spec">describe</a></b> - the block where the tests are located (should describe what we are testing).  The nesting of the describe blocks is not limited, which allows you to structurally declare the desired behavior in the test and set up test scripts. <br><br>  <b><a href="https://metacpan.org/pod/Test::Spec">it</a></b> is one separate test (should describe what what we are testing should do).  Testing itself takes place inside the ‚Äúit‚Äù blocks, implemented by the usual ok / is / like functions (by default, all functions from Test :: More, Test :: Deep and Test :: Trap are imported). <br><br>  <b><a href="https://metacpan.org/pod/Test::Spec">before</a> / <a href="https://metacpan.org/pod/Test::Spec">after</a></b> - allow you to perform various actions before each test, or before each block of tests. <br><br><br><a name="unit_mock"></a><h2>  <font color="#000"><b>Unit testing using mock objects</b></font> </h2><br>  Test :: Spec is ideal for unit testing using mock-objects ( <a href="https://metacpan.org/pod/Test::Spec::Mocks">https://metacpan.org/pod/Test::Spec::Mocks#Using-mock-objects</a> ). This is its main advantage over other libraries for tests. <br><img src="https://habrastorage.org/files/206/24a/f32/20624af3219741a596de9047d6022fca.jpg" alt="image" align="right"><br>  To implement unit testing according to the principle ‚Äúonly one module / function is tested at one time‚Äù, it is practically necessary to actively use mock objects. <br><br>  For example, the following method of the User module is an implementation of business logic to provide discounts on purchases: <pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_discount</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($self, $shopping_cart) = @_; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($shopping_cart-&gt;total_amount &gt;= Discounts::MIN_AMOUNT &amp;&amp; Discounts::is_discount_date) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($shopping_cart-&gt;items_count &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) { $self-&gt;set_discount(DISCOUNT_BIG); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $self-&gt;set_discount(DISCOUNT_MINI); } } }</code> </pre><br>  One of the options for testing it could be this: creating a User object ($ self) with all dependencies, creating a basket with the required number of products and with the required amount and testing the result. <br><br>  In the case of a unit test, only this section of the code is tested, while creating a User and Shopping cart can be avoided. <br><br>  The test (for one ‚Äúif‚Äù branch) looks like this: <pre> <code class="perl hljs">describe <span class="hljs-string"><span class="hljs-string">discount =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $user = <span class="hljs-keyword"><span class="hljs-keyword">bless</span></span> {}, <span class="hljs-string"><span class="hljs-string">'User'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $shopping_cart = mock(); $shopping_cart-&gt;expects(<span class="hljs-string"><span class="hljs-string">'total_amount'</span></span>)-&gt;returns(<span class="hljs-number"><span class="hljs-number">4_000</span></span>)-&gt;once; Discounts-&gt;expects(<span class="hljs-string"><span class="hljs-string">'is_discount_date'</span></span>)-&gt;returns(<span class="hljs-number"><span class="hljs-number">1</span></span>)-&gt;once; $shopping_cart-&gt;expects(<span class="hljs-string"><span class="hljs-string">'items_count'</span></span>)-&gt;returns(<span class="hljs-number"><span class="hljs-number">11</span></span>); $user-&gt;expects(<span class="hljs-string"><span class="hljs-string">'set_discount'</span></span>)-&gt;with(Discounts::DISCOUNT_BIG); ok $user-&gt;apply_discount($shopping_cart); }; };</code> </pre><br>  It uses the functions Test :: Spec :: Mocks: <a href="https://metacpan.org/pod/Test::Spec::Mocks">expects</a> , <a href="https://metacpan.org/pod/Test::Spec::Mocks">returns</a> , <a href="https://metacpan.org/pod/Test::Spec::Mocks">with</a> , <a href="https://metacpan.org/pod/Test::Spec::Mocks">once</a> . <br><br>  The following happens: the User :: apply_discount method is called, the $ shopping_cart mock-object is passed to it.  This checks that the total_amount method of the $ shopping_cart object is called exactly once (in fact, no real code will be called ‚Äî instead, this method will return the number 4000).  Similarly, the class method Discounts :: is_discount_date should be called once, and returns one.  The items_count method of the $ shopping_cart object will be called at least once and will return 11. And as a result, $ user-&gt; set_discount should be called with the argument Discounts :: DISCOUNT_BIG <br><br>  That is, in fact, we most naturally check every branch of logic. <br><br>  This approach gives us the following advantages: <br><br><ol><li>  The test is easier to write. </li><li>  It is less fragile: if we completely tried to recreate the User object in the test, we would have to deal with breakdowns associated with the fact that the implementation details of something that were not used at all in the tested function changed. </li><li>  The test works faster. </li><li>  Business logic is more clearly stated (documented) in the test. </li><li>  If the bug is in the code, then 100,500 different tests are not falling, but some one, and it is clear from it that what is broken. </li></ol><br>  If the equivalent unit test had to be written in pure Perl and Test :: More, it would look something like this: <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::More; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $user = <span class="hljs-keyword"><span class="hljs-keyword">bless</span></span> {}, <span class="hljs-string"><span class="hljs-string">'User'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $shopping_cart = <span class="hljs-keyword"><span class="hljs-keyword">bless</span></span> {}, <span class="hljs-string"><span class="hljs-string">'ShoppingCart'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> warnings <span class="hljs-string"><span class="hljs-string">'redefine'</span></span>, <span class="hljs-string"><span class="hljs-string">'once'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $sc_called = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> *ShoppingCart::total_amount = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ $sc_called++; <span class="hljs-number"><span class="hljs-number">4_000</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $idd_called = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> *Discounts::is_discount_date = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ $idd_called++; <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $sc2_called = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> *ShoppingCart::items_count = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ $sc2_called++; <span class="hljs-number"><span class="hljs-number">11</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $sd_called = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> *User::set_discount = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($self, $amount) = @_; is $amount, Discounts::DISCOUNT_BIG; $sd_called = <span class="hljs-number"><span class="hljs-number">1</span></span>; }; ok $user-&gt;apply_discount($shopping_cart); is $sc_called, <span class="hljs-number"><span class="hljs-number">1</span></span>; is $idd_called, <span class="hljs-number"><span class="hljs-number">1</span></span>; ok $sc2_called; is $sd_called, <span class="hljs-number"><span class="hljs-number">1</span></span>; done_testing;</code> </pre><br>  Here it is obvious that a lot of routine work on the falsification of functions is taking place, which could be automated. <br><br><br><a name="misc_features"></a><h2>  <font color="#000"><b>More small utility</b></font> </h2><br><a name="exceptions"></a><h2>  <font color="#000">Clear exception output</font> </h2><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; describe <span class="hljs-string"><span class="hljs-string">"mycode"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is <span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>; }; it <span class="hljs-string"><span class="hljs-string">"should work great"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"WAT? Unexpected error"</span></span>; is <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>; }; }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br>  gives out: <br> <code>ok 1 - mycode should work</code> <br> <code>not ok 2 - mycode should work great</code> <br> <code># Failed test 'mycode should work great' by dying:</code> <br> <code># WAT? Unexpected error</code> <br> <code># at test.t line 8.</code> <br> <code>1..2</code> <br> <code># Looks like you failed 1 test of 2.</code> <br>  which contains, in addition to the line number, the name of the test - ‚Äúmycode should work great‚Äù.  Naked Test :: More cannot boast with this and cannot, because the name of the test is not yet known while preparations are coming to it. <br><br><a name="strict_warnings"></a><h2>  <font color="#000">Automatically imports strict / warnings;</font> </h2><br>  That is, in fact, it is not necessary to write them.  But be careful if you have adopted another code requirements module, for example Modern :: Perl.  In this case, turn it on after Test :: Spec. <br><br><a name="evn_spec"></a><h2>  <font color="#000">Simple and convenient selective test run</font> </h2><br>  By simply setting the SPEC = pattern environment variable on the command line, only some tests can be performed.  Which is extremely convenient when you debug one test and you do not need the output from the rest. <br><br>  Example: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; describe <span class="hljs-string"><span class="hljs-string">"mycode"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"should add"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is <span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>; }; it <span class="hljs-string"><span class="hljs-string">"should substract"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is <span class="hljs-number"><span class="hljs-number">4</span></span>-<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>; }; }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br>  If you run it as SPEC = add perl test.t, then only the ‚Äúmycode should add‚Äù test will be executed. <br><br>  For more information: <a href="https://metacpan.org/pod/Test::Spec">https://metacpan.org/pod/Test::Spec#runtests-patterns</a> . <br><br><br><a name="no_alt"></a><h2>  <font color="#000"><b>There is no alternative</b></font> </h2><br>  Modules that allow you to organize test code in a structured way, like RSpec, of course, exist.  But there are no alternatives in terms of working with mock-objects. <br><br><img src="https://habrastorage.org/files/905/167/f2b/905167f2ba3c4ebc9fb878743e1058ff.jpg" alt="image" align="right">  The creator of the Test :: MockObject module is Chromatic <a href="https://metacpan.org/author/CHROMATIC">https://metacpan.org/author/CHROMATIC</a> (the author of Modern Perl, participated in the development of Perl 5, Perl 6 and many popular modules on CPAN), does not recognize unit testing, in the documentation for module mock objects are described as "Test :: MockObject - Perl extension for emulating troublesome interfaces" (keyword troublesome interfaces), about which he even wrote a post: <a href="http://modernperlbooks.com/mt/2012/04/mock-objects-despoil-your-tests.html">http://modernperlbooks.com/mt/2012/04/mock-objects -despoil-your-tests.html</a> <br><br>  His approach is clearly not for us. <br><br>  He also noted: ‚ÄúNote: See Test :: MockModule for an alternate (and better) approach‚Äù. <br><br>  Test :: MockModule is extremely inconvenient, not supported (the author is not visible since 2005) and is broken in perl 5.21 ( <a href="https://rt.cpan.org/Ticket/Display.html%3Fid%3D87004">https://rt.cpan.org/Ticket/Display.html?id=87004</a> ) <br><br><br><a name="gotchas"></a><h2>  <font color="#000"><b>Features work and rake</b></font> </h2><br><a name="no_test_names"></a><h2>  <font color="#000">Displaying test names in ok / is / other does not work</font> </h2><br>  More precisely, it works, but it spoils the logic of forming test names in Test :: Spec. <br><pre> <code class="perl hljs">describe <span class="hljs-string"><span class="hljs-string">"Our great code"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>; }; };</code> </pre><br>  displays: <br> <code>ok 1 - Our great code should work</code> <br> <code>1..1</code> <br> <br>  and code: <br><pre> <code class="perl hljs">describe <span class="hljs-string"><span class="hljs-string">"Our great code"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"should add right"</span></span>; }; };</code> </pre><br>  displays: <br> <code>ok 1 - should add right</code> <br> <code>1..1</code> <br> <br>  As we see, ‚ÄúOur great code‚Äù is lost, which negates the use of text in describe / it. <br><br>  It turns out, messages in ok and is better not to use. <br><br>  But what to do if we want two tests in the it block? <br><br><pre> <code class="perl hljs">describe <span class="hljs-string"><span class="hljs-string">"Our great code"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>; is <span class="hljs-number"><span class="hljs-number">10</span></span>-<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>; }; };</code> </pre><br>  will output: <br> <code>ok 1 - Our great code should work</code> <br> <code>ok 2 - Our great code should work</code> <br> <code>1..2</code> <br> <br>  As you can see, there are no individual messages for each test.  If you look carefully at the examples in the Test :: Spec documentation, you can see that each individual test should be in a separate it: <pre> <code class="perl hljs">describe <span class="hljs-string"><span class="hljs-string">"Our great code"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"should add right"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>; }; it <span class="hljs-string"><span class="hljs-string">"should substract right"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is <span class="hljs-number"><span class="hljs-number">10</span></span>-<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>; }; };</code> </pre><br>  will output: <br> <code>ok 1 - Our great code should add right</code> <br> <code>ok 2 - Our great code should substract right</code> <br> <code>1..2</code> <br> <br>  Which, however, is not very convenient and cumbersome for some cases. <br><br>  There are problems with other modules made for Test :: More, for example, <a href="https://metacpan.org/pod/Test::Exception">https://metacpan.org/pod/Test::Exception</a> defaults to an automatically generated message for ok, respectively, you need to explicitly specify an empty string instead. <br><br><a name="no_tests_inside_before_after"></a><h2>  <font color="#000">Do not place tests inside before / after</font> </h2><br>  The before block you will have to use very often, it will initialize the variables before the tests.  The block after is basically needed to undo changes made in the outside world, including global variables, etc. <br><br>  They do not need to try to place the tests themselves, which should be in it.  For example: <br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; describe <span class="hljs-string"><span class="hljs-string">"mycode"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $s; before <span class="hljs-string"><span class="hljs-string">each =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ $s = stub(<span class="hljs-string"><span class="hljs-string">mycode=&gt;</span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span></span>{<span class="hljs-number"><span class="hljs-number">42</span></span>}); }; after <span class="hljs-string"><span class="hljs-string">each =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is $s-&gt;mycode, <span class="hljs-number"><span class="hljs-number">42</span></span>; }; it <span class="hljs-string"><span class="hljs-string">"should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is $s-&gt;mycode, <span class="hljs-number"><span class="hljs-number">42</span></span>; }; }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br>  Gives an error message: <br> <code>ok 1 - mycode should work</code> <br> <code>not ok 2 - mycode should work</code> <br> <code># Failed test 'mycode should work' by dying:</code> <br> <code># Can't locate object method "mycode" via package "Test::Spec::Mocks::MockObject"</code> <br> <code># at test.t line 9.</code> <br> <code>1..2</code> <br> <code># Looks like you failed 1 test of 2.</code> <br> <br>  As you can see, in the after block, the mock object created in the before block no longer works.  So, if you have a lot of it blocks, and at the end of each block you want to do the same tests, then you won't be able to put them in the after block.  You can take them to a separate function, and call it from each of it, but this is similar to the duplication of functionality. <br><br><img src="https://habrastorage.org/files/e83/99e/7c9/e8399e7c99534fc781418e7bf67aed22.jpg" alt="image" align="right"><a name="before_after_are_different"></a><h2>  <font color="#000">Before / after blocks change code structure</font> </h2><br>  In the example below, we need to initialize a new Counter object for each test (let's imagine that this is difficult and takes many lines of code, so copy / paste is not an option).  It will look like this: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Counter; describe <span class="hljs-string"><span class="hljs-string">"counter"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $c; before <span class="hljs-string"><span class="hljs-string">each =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ $c = Counter-&gt;new(); }; it <span class="hljs-string"><span class="hljs-string">"should calc average"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ $c-&gt;add(<span class="hljs-number"><span class="hljs-number">2</span></span>); $c-&gt;add(<span class="hljs-number"><span class="hljs-number">4</span></span>); is $c-&gt;avg, <span class="hljs-number"><span class="hljs-number">3</span></span>; }; it <span class="hljs-string"><span class="hljs-string">"should calc sum"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ $c-&gt;add(<span class="hljs-number"><span class="hljs-number">2</span></span>); $c-&gt;add(<span class="hljs-number"><span class="hljs-number">4</span></span>); is $c-&gt;avg, <span class="hljs-number"><span class="hljs-number">3</span></span>; }; }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br>  That is, the lexical variable $ c is used, which will be available in the scope of the ‚Äúit‚Äù blocks.  Before each of them, the ‚Äúbefore‚Äù block is called, and the variable is reinitialized. <br><br>  If you write a similar test without Test :: Spec, you get this: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::More; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Counter; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_case</span></span></span></span>(&amp;) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($callback) = @_; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $c = Counter-&gt;new(); $callback-&gt;($c); } test_case { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($c) = @_; $c-&gt;add(<span class="hljs-number"><span class="hljs-number">2</span></span>); $c-&gt;add(<span class="hljs-number"><span class="hljs-number">4</span></span>); is $c-&gt;avg, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"should calc average"</span></span>; }; test_case { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($c) = @_; $c-&gt;add(<span class="hljs-number"><span class="hljs-number">2</span></span>); $c-&gt;add(<span class="hljs-number"><span class="hljs-number">4</span></span>); is $c-&gt;sum, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"should calc sum"</span></span>; }; done_testing;</code> </pre><br>  That is, a callback is passed to the test_case function, then test_case creates a Counter object and calls a callback, passing the created object as a parameter. <br><br>  In principle, in Test :: More you can organize a test as your heart desires, but the example above is a universal, scalable solution. <br><br>  If you try to make a tracing with Test :: Spec, a lexical variable that is initialized before each test, you get something ‚Äúnot very correct‚Äù: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::More; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Counter; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function"> </span></span>{ $c = Counter-&gt;new(); } init(); $c-&gt;add(<span class="hljs-number"><span class="hljs-number">2</span></span>); $c-&gt;add(<span class="hljs-number"><span class="hljs-number">4</span></span>); is $c-&gt;avg, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"should calc average"</span></span>; init(); $c-&gt;add(<span class="hljs-number"><span class="hljs-number">2</span></span>); $c-&gt;add(<span class="hljs-number"><span class="hljs-number">4</span></span>); is $c-&gt;sum, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"should calc sum"</span></span>; done_testing;</code> </pre><br>  In this code, the function modifies a variable that is not passed to it as an argument, which is already considered a bad style.  However, technically it is the same as in the version with Test :: Spec (there, too, the code in the before block modifies a variable that is not explicitly passed to it), but in it it is considered ‚Äúnormal‚Äù. <br><br>  We see that in Test :: More and Test :: Spec the code is organized differently.  Different language features are used to organize the test. <br><br><a name="no_more_local"></a><h2>  <font color="#000">Local operator no longer works</font> </h2><br>  More precisely, it works, but not always. <br><br>  This does not work: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; <span class="hljs-keyword"><span class="hljs-keyword">our</span></span> $_somevar = <span class="hljs-number"><span class="hljs-number">11</span></span>; describe <span class="hljs-string"><span class="hljs-string">"foo"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> $_somevar = <span class="hljs-number"><span class="hljs-number">42</span></span>; it <span class="hljs-string"><span class="hljs-string">"should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is $_somevar, <span class="hljs-number"><span class="hljs-number">42</span></span>; }; }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br> <code>not ok 1 - foo should work</code> <br> <code># Failed test 'foo should work'</code> <br> <code># at test-local-doesnt-work.t line 8.</code> <br> <code># got: '11'</code> <br> <code># expected: '42'</code> <br> <code>1..1</code> <br> <code># Looks like you failed 1 test of 1.</code> <br> <br>  So it works: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; <span class="hljs-keyword"><span class="hljs-keyword">our</span></span> $_somevar = <span class="hljs-number"><span class="hljs-number">11</span></span>; describe <span class="hljs-string"><span class="hljs-string">"foo"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> $_somevar = <span class="hljs-number"><span class="hljs-number">42</span></span>; is $_somevar, <span class="hljs-number"><span class="hljs-number">42</span></span>; }; }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br> <code>ok 1 - foo should work</code> <br> <code>1..1</code> <br> <br>  The thing is that it does not fulfill the callback given to it (or rather, this can already be considered a closure), and remembers the link to it.  It is executed during the runtests call.  And as we know, local, unlike my, acts "in time" and not "in space". <br><br>  What problems can this cause?  local tests may be needed for two things - to fake a function and fake a variable.  Now this is not so easy to do. <br><br>  In principle, the fact that it is impossible to forge a function with the help of local (and without it it is not practical - you have to return the old function with your hands), only for the benefit.  Test :: Spec has its own function falsification mechanism (about it was higher), and there is no other support. <br><br>  But the impossibility of resetting a variable is worse. <br><br>  If you are not using local in Perl now, this does not mean that you will not need it in tests.  In the next three paragraphs I will tell you why he may be needed. <br><br><a name="dsl"></a><h3>  <font color="#000">DSL</font> </h3><br>  The fact is that DSL ( <a href="http://www.slideshare.net/mayperl/dsl-perl">http://www.slideshare.net/mayperl/dsl-perl</a> ) in Perl is very often done using local variables. <br><br>  For example, we need to retrieve data from the database in the Web application, in the controllers.  At the same time, we have configured master / slave replication.  By default, the data must be received from the slave servers, but if we are going to modify the received data and write it to the database, the initial data must be received from the master server before the modification. <br><br>  Thus, we need all of our functions to retrieve data from the database, transfer information: from the slave server to take data or from the master.  You can simply transfer them a connection to the database, but this is too cumbersome - there may be many such functions, they can call each other. <br><br>  Suppose the code for retrieving data from a database looks like this: <pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_data</span></span></span><span class="hljs-function"> </span></span>{ mydatabase-&gt;query(<span class="hljs-string"><span class="hljs-string">"select * from ... "</span></span>); }</code> </pre><br>  Then we can make the following API: mydatabase will return the connection to the slave database, mydatabase inside the with_mysql_master block will return the connection to the master database. <br><br>  This is how reading data from a slave looks like: <pre> <code class="perl hljs">$some_data = get_data(); $even_more_data = mydatabase-&gt;query(<span class="hljs-string"><span class="hljs-string">"select * from anothertable ‚Ä¶ "</span></span>);</code> </pre><br>  So read data from master and write to master: <pre> <code class="perl hljs">with_mysql_master { $some_data = get_data(); mydatabase-&gt;query(<span class="hljs-string"><span class="hljs-string">"insert into ‚Ä¶ "</span></span>, $some_data); };</code> </pre><br>  The with_mysql_master function is easiest to implement with local: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">our</span></span> $_current_db = get_slave_db_handle(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mydatabase</span></span></span><span class="hljs-function"> </span></span>{ $_current_db } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">with_mysql_master</span></span></span></span>(&amp;) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($cb) = @_; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> $_current_db = get_master_db_handle(); $cb-&gt;(); }</code> </pre><br>  Thus, mydatabase inside the with_mysql_master block will return a connection to the master database, because it is in the ‚Äúaction area‚Äù of the $ _current_db local override, and outside this block is a connection to the database slave. <br><br>  So, in Test :: Spec with all such constructions there can be difficulties. <br><br>  Test :: Spec is made in the image and likeness of Ruby libraries, there DSL is organized without local (and there is no analog of local at all), so this nuance was not foreseen. <br><br><a name="global_cache"></a><h3>  <font color="#000">Global caches</font> </h3><br>  Look in your state for code.  Any use of it can usually be classified as a global cache of something.  When they say that global variables are bad, this often applies to such a ‚Äúnon-global‚Äù state. <br><br>  The problem with the state is that it cannot be tested at all (see <a href="http://perlmonks.org/%3Fnode_id%3D1072981">http://perlmonks.org/?node_id=1072981</a> ).  You cannot call a function from one process many times where something is cached using state and flush caches.  We'll have to replace the state with the good old ours.  And just when testing to dump it: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> %SomeModule::SomeData;</code> </pre><br>  If you need to test such a function with Test :: Spec, and the cache will interfere, you can replace it with two separate functions - the first one returns data without caching (say, get_data), the second one - deals only with caching (cached_get_data).  And test only the first one.  This will be a unit test (testing one function separately).  The second of these functions cannot be tested at all, but this is not really necessary: ‚Äã‚Äãit is simple - you have to believe that it works. <br><br>  If you have an integration test that tests a whole call stack, then you will have to forge a cached_get_data call in it and replace it with get_data without caching. <br><br><a name="global_vars"></a><h3>  <font color="#000">Global variables</font> </h3><br>  Some% SomeModule :: CONFIG is quite normal use-case for using global variables.  With local it is convenient to replace the config before calling functions. <br><br>  If there are difficulties with this in Test :: Spec, it is better to make a function that returns CONFIG and forge it. <br><br><a name="other_way"></a><h3>  <font color="#000">How different?</font> </h3><br>  It should be noted that there are modules in which the same structural description of tests is available (even with the same "describe" and "it"), but without this problem with local, for example <a href="https://metacpan.org/pod/Test::Kantan">https://metacpan.org/pod/Test :: Kantan</a> .  However, this module, besides the structural description of tests, does not provide any possibilities. <br><br><a name="more_on_it_local"></a><h2>  <font color="#000">More about it and local</font> </h2><br>  At the beginning of the article, we found out that in each ‚Äúit‚Äù there should be one test.  It was originally intended, and the only way it works.  What to do if we have a whole cycle, where in each iteration of the test? <br><br>  It is assumed that the correct way to do this is: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; describe <span class="hljs-string"><span class="hljs-string">"foo"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $i (<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">7</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $n = $i + <span class="hljs-number"><span class="hljs-number">10</span></span>; it <span class="hljs-string"><span class="hljs-string">"should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is $n, $i + <span class="hljs-number"><span class="hljs-number">10</span></span>; }; } }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br>  But since each ‚Äúit‚Äù only remembers the closure, but does not execute it immediately, local cannot be used in this code anymore, such a test fails completely: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; <span class="hljs-keyword"><span class="hljs-keyword">our</span></span> $_somevar = <span class="hljs-number"><span class="hljs-number">11</span></span>; describe <span class="hljs-string"><span class="hljs-string">"foo"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> $_somevar = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $i (<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">7</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $n = $i + $_somevar; it <span class="hljs-string"><span class="hljs-string">"should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is $n, $i + $_somevar; }; } }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br> <code>not ok 1 - foo should work</code> <br> <code># Failed test 'foo should work'</code> <br> <code># at t6-local.pl line 9.</code> <br> <code># got: '43'</code> <br> <code># expected: '12'</code> <br> <code>not ok 2 - foo should work</code> <br> <code># Failed test 'foo should work'</code> <br> <code># at t6-local.pl line 9.</code> <br> <code># got: '44'</code> <br> <code># expected: '13'</code> <br> <code>not ok 3 - foo should work</code> <br> <code># Failed test 'foo should work'</code> <br> <code># at t6-local.pl line 9.</code> <br> <code># got: '45'</code> <br> <code># expected: '14'</code> <br> <code>not ok 4 - foo should work</code> <br> <code># Failed test 'foo should work'</code> <br> <code># at t6-local.pl line 9.</code> <br> <code># got: '46'</code> <br> <code># expected: '15'</code> <br> <code>not ok 5 - foo should work</code> <br> <code># Failed test 'foo should work'</code> <br> <code># at t6-local.pl line 9.</code> <br> <code># got: '47'</code> <br> <code># expected: '16'</code> <br> <code>not ok 6 - foo should work</code> <br> <code># Failed test 'foo should work'</code> <br> <code># at t6-local.pl line 9.</code> <br> <code># got: '48'</code> <br> <code># expected: '17'</code> <br> <code>not ok 7 - foo should work</code> <br> <code># Failed test 'foo should work'</code> <br> <code># at t6-local.pl line 9.</code> <br> <code># got: '49'</code> <br> <code># expected: '18'</code> <br> <code>1..7</code> <br> <code># Looks like you failed 7 tests of 7.</code> <br> <br>  Yes, and everyone ‚Äúdescribe‚Äù also remembers the closure, but does not fulfill it, so that it is the same as ‚Äúit‚Äù. <br><br><a name="shared_code"></a><h2>  <font color="#000">Common code</font> </h2><br>  There is a mechanism for connecting common code that can be performed in different tests.  Here is the documentation: <a href="https://metacpan.org/pod/Test::Spec">https://metacpan.org/pod/Test::Spec#spec_helper-FILESPEC</a> , and here is the implementation: <a href="">https://metacpan.org/source/PHILIP/Test-Spec-0.47/lib/Test/Spec. pm # L354</a> . <br><br>  How does he work? <br><br><ol><li>  It searches for an include file on disk using File :: Spec (bypassing the perl <i>@</i> INC mechanism and the require file upload mechanism). </li><li>  It loads the file into memory, makes a string with perl code, where the package first changes, then the contents of the read file are ‚Äúas is‚Äù simply included. </li><li>  Executes this line as eval EXPR. </li><li>  The download file itself has the extension .pl, everything works, but it may not be a valid perl file, it may not have enough use, it may not include the wrong paths and so on, respectively, from the point of view of perl there are syntax errors.  In general, this is a non-working piece of code that needs to be stored in a separate file. </li></ol><br>  That is - an absolute hack. <br><br>  However, it is quite possible to write a common code in the usual way - arrange it as a function, put it into modules: <br><br>  Test code: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> User; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">home_page</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($self) = @_; <span class="hljs-string"><span class="hljs-string">"http://www.example.com/"</span></span>.$self-&gt;login; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($self) = @_; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $id = $self-&gt;login; $id =~ <span class="hljs-regexp"><span class="hljs-regexp">s/\-/_/g</span></span>; $id; } <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Our module with common code for tests: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> MyTestHelper; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fake_user</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($login) = @_; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $user = <span class="hljs-keyword"><span class="hljs-keyword">bless</span></span> {}, <span class="hljs-string"><span class="hljs-string">'User'</span></span>; $user-&gt;expects(<span class="hljs-string"><span class="hljs-string">"login"</span></span>)-&gt;returns($login); $user; } <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  The test itself: <pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> User; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> MyTestHelper; describe <span class="hljs-string"><span class="hljs-string">user =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"login should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $user = MyTestHelper::fake_user(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>); is $user-&gt;home_page, <span class="hljs-string"><span class="hljs-string">'http://www.example.com/abc'</span></span>; }; it <span class="hljs-string"><span class="hljs-string">"should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $user = MyTestHelper::fake_user(<span class="hljs-string"><span class="hljs-string">'hello-world'</span></span>); is $user-&gt;id, <span class="hljs-string"><span class="hljs-string">'hello_world'</span></span>; }; }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br>  The fake_user function creates a User object, at the same time forging the login method of this object, so that it returns the login that we want now (also passed to fake_user).  In tests, we check the logic of the User :: home_page and User :: id methods (knowing the login, we know that we need to return these methods). Thus, the fake_user function is an example of reusing code to create a User object and set up fake methods. <br><br><a name="uni_helpers"></a><h2>  <font color="#000">It is difficult to write helpers that work simultaneously with both Test :: Spec and Test :: More</font> </h2><br>  As you can see, the test build order for Test :: Spec and Test :: More is very different.  Usually, we are unable to write a library that works in both test environments (we do not take into account all sorts of tricks). <br><br>  For example, we have a helper for Test :: More, which helps in the test to contact Redis.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is necessary for integration testing of code that works with this Redis, as well as conveniently for some other tests (for example, fork tests, where Redis is used to exchange test data between different processes). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This helper gives the following DSL:</font></font><pre> <code class="perl hljs">redis_next_test $redis_connection =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function executes the code passed as the last argument. </font><font style="vertical-align: inherit;">A function namespace is available inside the code. </font><font style="vertical-align: inherit;">Within each redis_next_test block, the namespace is unique. </font><font style="vertical-align: inherit;">It can and should be used to name Redis keys. </font><font style="vertical-align: inherit;">At the end of the block, all keys with this prefix are deleted. </font><font style="vertical-align: inherit;">All this is necessary so that the tests can be executed in parallel with themselves on the CI server, and at the same time they do not spoil each other‚Äôs keys, as well as not to litter the developers' cars with unnecessary keys. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A simplified version of this helper:</font></font><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> RedisUniqueKeysForTestMore; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Exporter <span class="hljs-string"><span class="hljs-string">'import'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">our</span></span> @EXPORT = <span class="hljs-keyword"><span class="hljs-keyword">qw</span></span>/ namespace redis_next_test /; <span class="hljs-keyword"><span class="hljs-keyword">our</span></span> $_namespace; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">namespace</span></span></span></span>() { $_namespace }; sub redis_next_test { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($conn, $cb) = @_; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> $_namespace = $$.rand(); $cb-&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @all_keys = $conn-&gt;<span class="hljs-keyword"><span class="hljs-keyword">keys</span></span>($_namespace.<span class="hljs-string"><span class="hljs-string">"*"</span></span>); $conn-&gt;del(@all_keys) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> @all_keys; } <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sample test with him: </font></font><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::More; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> RedisUniqueKeysForTestMore; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $conn = connect_to_redis(); <span class="hljs-comment"><span class="hljs-comment"># external sub redis_next_test $conn =&gt; sub { my $key = namespace(); $conn-&gt;set($key, 42); is $conn-&gt;get($key), 42; }; done_testing;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For Test :: Spec, this is no longer suitable, since: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The notion of ‚Äúinside redis_next_test‚Äù is completely naturally realized with the help of local, and with local in Test :: Spec problems, as we saw above. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even if redis_next_test didn‚Äôt have local, instead of local $ _namespace = $$. Rand () it would be just $ _namespace = $$. Rand () (which would make nested redis_next_test impossible), it wouldn‚Äôt work anyway, because $ conn-&gt; del (@all_keys) if @all_keys; </font><font style="vertical-align: inherit;">would be executed not after the test, but after the callback of the test is added to the internal structures of Test :: Spec (in fact, the same story as with local).</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A function that accepts a callback and executes it inside the describe block is suitable, with blocks before (generates a namespace) and after (deletes keys). </font><font style="vertical-align: inherit;">Here she is:</font></font><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> RedisUniqueKeysForTestSpec; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Exporter <span class="hljs-string"><span class="hljs-string">'import'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">our</span></span> @EXPORT = <span class="hljs-keyword"><span class="hljs-keyword">qw</span></span>/ describe_redis namespace /; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $_namespace; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">namespace</span></span></span></span>() { $_namespace }; sub describe_redis { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($conn, $example_group) = @_; describe "in unique namespace" =&gt; sub { before <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> =&gt; sub { $_namespace = $$.rand(); }; after <span class="hljs-string"><span class="hljs-string">each =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @all_keys = $conn-&gt;<span class="hljs-keyword"><span class="hljs-keyword">keys</span></span>($_namespace.<span class="hljs-string"><span class="hljs-string">"*"</span></span>); $conn-&gt;del(@all_keys) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> @all_keys; }; $example_group-&gt;(); }; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And so the test looks like with her: </font></font><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> RedisUniqueKeysForTestSpec; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $conn = connect_to_redis(); describe <span class="hljs-string"><span class="hljs-string">"Redis"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ describe_redis $conn =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"should work"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $key = namespace(); $conn-&gt;set($key, <span class="hljs-number"><span class="hljs-number">42</span></span>); is $conn-&gt;get($key), <span class="hljs-number"><span class="hljs-number">42</span></span>; }; }; }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br><a name="with_is_for_classes"></a><h2> <font color="#000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The with function only works for classes.</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MyModule.pm </font></font><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> MyModule; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-function"> </span></span>{ f2(<span class="hljs-number"><span class="hljs-number">42</span></span>); }; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test: </font></font><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> MyModule; describe <span class="hljs-string"><span class="hljs-string">"foo"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"should work with returns"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ MyModule-&gt;expects(<span class="hljs-string"><span class="hljs-string">"f2"</span></span>)-&gt;returns(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ is <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>}); MyModule::f1(); }; it <span class="hljs-string"><span class="hljs-string">"should work with with"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ MyModule-&gt;expects(<span class="hljs-string"><span class="hljs-string">"f2"</span></span>)-&gt;with(<span class="hljs-number"><span class="hljs-number">42</span></span>); MyModule::f1(); }; }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br>  Result: <br> <code>ok 1 - foo should work with returns</code> <br> <code>not ok 2 - foo should work with with</code> <br> <code># Failed test 'foo should work with with' by dying:</code> <br> <code># Number of arguments don't match expectation</code> <br> <code># at /usr/local/share/perl/5.14.2/Test/Spec/Mocks.pm line 434.</code> <br> <code>1..2</code> <br> <code># Looks like you failed 1 test of 2.</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, it can only be used to work with class methods, if the perl package is not used as a class, but as a module (procedural programming), it does not work. </font><font style="vertical-align: inherit;">Test :: Spec simply waits for the first argument $ self, always.</font></font><br><br><a name="with_not_for_hashes"></a><h2> <font color="#000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The with function does not see the difference between a hash and an array.</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MyClass.pm: </font></font><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> MyClass; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anotherfunc</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myfunc</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($self, %h) = @_; $self-&gt;anotherfunc(%h); } <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test: </font></font><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> MyClass; describe <span class="hljs-string"><span class="hljs-string">"foo"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $o = <span class="hljs-keyword"><span class="hljs-keyword">bless</span></span> {}, <span class="hljs-string"><span class="hljs-string">'MyClass'</span></span>; it <span class="hljs-string"><span class="hljs-string">"should work with with"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ MyClass-&gt;expects(<span class="hljs-string"><span class="hljs-string">"anotherfunc"</span></span>)-&gt;with(<span class="hljs-string"><span class="hljs-string">a =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">b =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">c =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>); $o-&gt;myfunc(<span class="hljs-string"><span class="hljs-string">a =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">b =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">c =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>); }; }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br>  Result: <br> <code>not ok 1 - foo should work with with</code> <br> <code># Failed test 'foo should work with with' by dying:</code> <br> <code># Expected argument in position 0 to be 'a', but it was 'c'</code> <br> <code>Expected argument in position 1 to be '1', but it was '3'</code> <br> <code>Expected argument in position 2 to be 'b', but it was 'a'</code> <br> <code>Expected argument in position 3 to be '2', but it was '1'</code> <br> <code>Expected argument in position 4 to be 'c', but it was 'b'</code> <br> <code>Expected argument in position 5 to be '3', but it was '2'</code> <br> <code># at /usr/local/share/perl/5.14.2/Test/Spec/Mocks.pm line 434.</code> <br> <code>1..1</code> <br> <code># Looks like you failed 1 test of 1.</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually, Perl doesn't see the difference either. </font><font style="vertical-align: inherit;">And the order of the elements in the hash is undefined. </font><font style="vertical-align: inherit;">This could be taken into account when developing the API function with and to make a method that facilitates checking hashes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can work around this flaw by using returns and checking the data in its callback. </font><font style="vertical-align: inherit;">For the example above, this would be:</font></font><br><pre> <code class="perl hljs">MyClass-&gt;expects(<span class="hljs-string"><span class="hljs-string">"anotherfunc"</span></span>)-&gt;returns(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; cmp_deeply +{@_}, +{<span class="hljs-string"><span class="hljs-string">a =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">b =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">c =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>} });</code> </pre><br><br><a name="mem_leaks"></a><h2> <font color="#000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problems testing things like memory leaks</font></font></font> </h2><br><img src="https://habrastorage.org/files/4c7/837/7cc/4c78377cc00d456da85902f5aa1a14f7.jpg" alt="image" align="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, the stub () function itself is a leak (apparently, stubs are stored somewhere). </font><font style="vertical-align: inherit;">So this test does not work: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MyModule.pm:</font></font><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> MyModule; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myfunc</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> ($data) = @_; <span class="hljs-comment"><span class="hljs-comment">### Memory leak BUG #$data-&gt;{x} = $data; ### /Memory leak BUG $data; } 1;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test: </font></font><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Scalar::Util <span class="hljs-string"><span class="hljs-string">qw( weaken )</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> MyModule; describe <span class="hljs-string"><span class="hljs-string">"foo"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"should not leak memory"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $leakdetector; { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $r = stub( <span class="hljs-string"><span class="hljs-string">service_id =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ); MyModule::myfunc($r); $leakdetector = $r; weaken($leakdetector); } ok ! <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span> $leakdetector; } }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This test shows a memory leak, even when it is not. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A test written without a stub works fine (it fills only if the line with the bug in MyModule.pm is uncommented):</font></font><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Test::Spec; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Scalar::Util <span class="hljs-string"><span class="hljs-string">qw( weaken )</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> MyModule; describe <span class="hljs-string"><span class="hljs-string">"foo"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ it <span class="hljs-string"><span class="hljs-string">"should not leak memory"</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $leakdetector; { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $r = <span class="hljs-keyword"><span class="hljs-keyword">bless</span></span> { <span class="hljs-string"><span class="hljs-string">service_id =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> }, <span class="hljs-string"><span class="hljs-string">"SomeClass"</span></span>; MyModule::myfunc($r); $leakdetector = $r; weaken($leakdetector); } ok ! <span class="hljs-keyword"><span class="hljs-keyword">defined</span></span> $leakdetector; } }; runtests <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">caller</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In any case, since ‚Äúdescribe‚Äù and ‚Äúit‚Äù remember closures, this in itself can interfere with the search for leaks, since the closure can contain references to all variables that it uses. </font></font><br><br><a name="no_use_ok"></a><h2> <font color="#000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The use_ok function is out of place</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you previously used use_ok in tests, now you can say goodbye to it. </font><font style="vertical-align: inherit;">Judging by the documentation, it can only be used in the BEGIN block (see </font></font><a href="https://metacpan.org/pod/Test::More"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://metacpan.org/pod/Test::More#use_ok</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), and this is correct, because outside of BEGIN it may not work exactly as in reality ( for example, not to import prototype functions), and it makes no sense to use such a ‚Äúright‚Äù construct for testing imports from modules, violating this import itself. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, in Test :: Spec it is not customary to write tests outside ‚Äúit‚Äù, and inside ‚Äúit‚Äù the BEGIN block will execute ... as if it were outside of ‚Äúit‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So it‚Äôs impossible to do everything ‚Äúbeautifully and correctly‚Äù, but if you‚Äôre not interested in ‚Äúbeautifully and correctly‚Äù, then the usual use will do.</font></font><br><br><br><a name="interesting"></a><h2> <font color="#000"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interesting</font></font></b></font> </h2><br><a name="how_expects_works"></a><h2> <font color="#000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How objects are technically forged</font></font></font> </h2><img src="https://habrastorage.org/files/a55/5bc/0b6/a555bc0b6a314f0bb923d9b0d10fa0a1.jpg" alt="image" align="right"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separately, it is worth noting how it is technically possible to achieve overlapping of the expects method for any object or class. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is done by creating a method (surprise!) Expects in the code of the UNIVERSAL package. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's try to do the same trick:</font></font><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> User; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">somecode</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; { <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> warnings <span class="hljs-string"><span class="hljs-string">'once'</span></span>; *UNIVERSAL::expects = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Hello there ["</span></span>.join(<span class="hljs-string"><span class="hljs-string">','</span></span>, @_).<span class="hljs-string"><span class="hljs-string">"]\n"</span></span>; }; } User-&gt;expects(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $u =<span class="hljs-keyword"><span class="hljs-keyword">bless</span></span> { <span class="hljs-string"><span class="hljs-string">x =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">123</span></span>}, <span class="hljs-string"><span class="hljs-string">'User'</span></span>; $u-&gt;expects(<span class="hljs-number"><span class="hljs-number">11</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will deduce: </font></font><br> <code>Hello there [User,42]</code> <br> <code>Hello there [User=HASH(0x8a6688),11]</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is, everything works - it was possible to override the method.</font></font><br><br><br><a name="theend"></a><h2> <font color="#000"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findings</font></font></b></font> </h2><br><a name="ts_is_for_highlevel_code"></a><h2> <font color="#000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test :: Spec is good for unit testing high level code.</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test :: Spec is good for unit tests, that is, when only one ‚Äúlayer‚Äù is tested, and the rest of the functions are faked. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For integration tests, when we are not more interested in fast, convenient and correct testing of a unit of code and all borderline cases in it, but if everything works and everything is correctly ‚Äúconnected‚Äù, then Test :: More and analogs are more suitable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another criterion is high-level vs low-level code. In high-level code, you often have to test business logic; mock objects are ideal for this. Everything, except the logic itself, is faked, the test becomes simple and clear.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For low-level code, sometimes it makes no sense to write a separate ‚Äúreal‚Äù unit test, a separate ‚Äúintegration‚Äù one, since in a low-level code there is usually one ‚Äúlayer‚Äù and there is nothing to forge. Unit test will be an integration. Test :: More in these cases is preferable because in Test :: Spec there are things that are not very well transferred from the world of Ruby, without taking into account the realities of Perl, and the methods for building code change without good reason. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The unit tests of the high-level code are pretty similar, so the limitations and the listed drawbacks of Test :: Spec are not a big problem for them, and for low-level code and integration tests it is better to leave room for maneuver and use Test :: More. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article was prepared with the active participation of the development department of REG.RU. Special thanks to </font></font><a href="https://habrahabr.ru/users/s-f-x/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFX</font></font></a>   , <a href="https://habrahabr.ru/users/akzhan/" class="user_link">akzhan</a>       Ruby  <a href="https://habrahabr.ru/users/dmvaskin/" class="user_link">dmvaskin</a>       Test::Spec,   <a href="https://habrahabr.ru/users/imagostorm/" class="user_link">imagostorm</a> , <a href="https://habrahabr.ru/users/chips/" class="user_link">Chips</a> , <a href="https://habrahabr.ru/users/evostrov/" class="user_link">evostrov</a> , <a href="https://habrahabr.ru/users/timurn/" class="user_link">TimurN</a> , <a href="https://habrahabr.ru/users/nugged/" class="user_link">nugged</a> , <a href="https://habrahabr.ru/users/vadiml/" class="user_link">vadiml</a> .</i> </div><p>Source: <a href="https://habr.com/ru/post/239417/">https://habr.com/ru/post/239417/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239407/index.html">Based on the ‚Äúthree interviews about static analyzers,‚Äù or the fourth interview</a></li>
<li><a href="../239409/index.html">Why snowkit</a></li>
<li><a href="../239411/index.html">Protecting HTTP traffic with Citrix Netscaler</a></li>
<li><a href="../239413/index.html">"Smart money" from Microsoft and FRIA for startups</a></li>
<li><a href="../239415/index.html">Jump start on October 7th. Modernizing the company's IT infrastructure using Windows Server 2012 R2</a></li>
<li><a href="../239419/index.html">Installing and running Asterisk on an Android smartphone</a></li>
<li><a href="../23942/index.html">Loud lawsuit against Samsung</a></li>
<li><a href="../239421/index.html">NemerleWeb - Unique Web Framework</a></li>
<li><a href="../239423/index.html">Chrome who stole christmas</a></li>
<li><a href="../239425/index.html">My library for IT-manager</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>