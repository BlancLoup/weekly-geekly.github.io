<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sensor of absolute pressure BMP180</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Today, the hero of our evening show is a sensor of absolute pressure and temperature (the latter is no surprise to anyone today, they w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sensor of absolute pressure BMP180</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Today, the hero of our evening show is a sensor of absolute pressure and temperature (the latter is no surprise to anyone today, they were shoved into absolutely all sensors related to embedded systems anyway) Bosch BMP180.  The sensor is not new and by its name at any time you can google just an incredible amount of information, including examples of work in all possible languages.  But no matter how strange it may seem, our goal is not at all to figure out exactly how it works, no.  We will work on a programming style. <br><a name="habracut"></a><br><h4>  A few words about the programming style </h4><br>  Every novice programmer is constantly improving their style of writing code.  This process is inevitable and if you do not feel it, it means that you have already learned everything long ago, or you need to change your occupation. <br><br>  So what do we want?  What is ‚Äúbeautiful code‚Äù?  Let's understand the concepts. <br><br>  Beautiful code: <br>  - Optimal (in terms of memory usage and the number of cycles required for its execution) <br>  - We read (what is the use of the code that is written in such a way that nobody understands it except the compiler?) <br>  - Cross-platform (today ARM, tomorrow STM8, and yesterday one man called, wanted to make something like that on the PIC) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      How to choose a middle ground?  Can you kill all the hares with one shot?  I think that we will not rush into the embrasure, but we will work in this direction for sure. <br><br>  So let's move on to the actual code.  This sensor has two possible interfaces - I2C and SPI.  I would like the code to be the same for both.  Let's try to do it.  And we want to be able to connect not one sensor, but as many as you like.  Well, for the heap, they must be connected by their interfaces.  Those.  we really really want to, for example, have the opportunity to work with three sensors - two are connected to different I2C interfaces, and one is generally on SPI.  And so that the code was one.  Well, let's try. <br><br>  We will need a structure.  In it, we will store all the information for each specific sensor - where it is connected, what its address, what settings it will have, its calibration constants list and, in fact, the result of converting: <br><br><pre><code class="cs hljs">typedef <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Data */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Temperature; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Pressure; <span class="hljs-comment"><span class="hljs-comment">/* Functions */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> (*WriteReg)(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> I2C_Adrs, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Reg, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Value); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> (*ReadReg) (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> I2C_Adrs, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Reg, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * buf, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> size); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*delay_func)(unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ms); <span class="hljs-comment"><span class="hljs-comment">/* Settings */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> I2C_Adrs; <span class="hljs-comment"><span class="hljs-comment">//I2c address. Default value 0xEE BMP180_OversamplingEnumTypeDef P_Oversampling; /* Internal data */ ` short AC1; short AC2; short AC3; unsigned short AC4; unsigned short AC5; unsigned short AC6; short B1; short B2; short MB; short MC;` short MD; long UT; long UP; }BMP180_StructTypeDef;</span></span></code> </pre> <br><br>  What do we see?  The <b>temperature</b> and <b>pressure</b> variables are actually the results of our work with the sensor.  Everything speaks for itself.  The field <b>Functions</b> is a list of pointers to functions that we will use to work with the interface and the implementation of the delay function.  The <b>Settings</b> field allows us to specify which address on the I2C bus our sensor will use.  For the SPI interface (by the way, these sensors with the SPI interface are sold only by special order, but this is not important for us now) we will indicate what sensor number we will read (we will create a constant array of pointers to the port and pin CS. So the number the element of this array will lead directly to the port we need to select the device we need on the bus). <br><br>  The <b>P_Oversampling</b> parameter will be an element of the <b>enum</b> type, described in advance: <br><pre> <code class="cs hljs">typedef <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { BMP180_OV_Single = <span class="hljs-number"><span class="hljs-number">0</span></span>, BMP180_OversamplingX2, BMP180_OversamplingX4, BMP180_OversamplingX8, }BMP180_OversamplingEnumTypeDef;</code> </pre> <br><br><h4>  Initialization. </h4><br>  Here we will read the calibration constants.  Here is the code: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BMP180_Init</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BMP180_StructTypeDef * BMP180_Struct</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">22</span></span>], Result; BMP180_SW_Reset(BMP180_Struct); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Result = BMP180_Struct-&gt;ReadReg(BMP180_Struct-&gt;I2C_Adrs, AC1_Reg, buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf))) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result; BMP180_Struct-&gt;AC1 = (buf[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | buf[<span class="hljs-number"><span class="hljs-number">1</span></span>]; BMP180_Struct-&gt;AC2 = (buf[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | buf[<span class="hljs-number"><span class="hljs-number">3</span></span>]; BMP180_Struct-&gt;AC3 = (buf[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | buf[<span class="hljs-number"><span class="hljs-number">5</span></span>]; BMP180_Struct-&gt;AC4 = (buf[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | buf[<span class="hljs-number"><span class="hljs-number">7</span></span>]; BMP180_Struct-&gt;AC5 = (buf[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | buf[<span class="hljs-number"><span class="hljs-number">9</span></span>]; BMP180_Struct-&gt;AC6 = (buf[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | buf[<span class="hljs-number"><span class="hljs-number">11</span></span>]; BMP180_Struct-&gt;B1 = (buf[<span class="hljs-number"><span class="hljs-number">12</span></span>]&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | buf[<span class="hljs-number"><span class="hljs-number">13</span></span>]; BMP180_Struct-&gt;B2 = (buf[<span class="hljs-number"><span class="hljs-number">14</span></span>]&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | buf[<span class="hljs-number"><span class="hljs-number">15</span></span>]; BMP180_Struct-&gt;MB = (buf[<span class="hljs-number"><span class="hljs-number">16</span></span>]&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | buf[<span class="hljs-number"><span class="hljs-number">17</span></span>]; BMP180_Struct-&gt;MC = (buf[<span class="hljs-number"><span class="hljs-number">18</span></span>]&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | buf[<span class="hljs-number"><span class="hljs-number">19</span></span>]; BMP180_Struct-&gt;MD = (buf[<span class="hljs-number"><span class="hljs-number">20</span></span>]&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | buf[<span class="hljs-number"><span class="hljs-number">21</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result; }</code> </pre> <br>  What is there to note?  Well, the first thing that catches your eye is why it is impossible to send the address of the first parameter in the structure and fill the entire structure with data on the fly, without using an intermediate buffer of 22 bytes?  Yes, because the order of the high and low bytes of this sensor is reversed.  (who remembers big indian / little indian).  You can get out the commands byte swap at the kernel level, but the code should not be tied to the platform.  Therefore, so.  According to the good old tradition, any mistake has a nonzero value.  If the function returns zero, then there is no error.  Therefore, I check the operation of the interface only with the equality condition with zero.  If the interface does not work or there is no sensor on the bus, it makes no sense to write values ‚Äã‚Äãin constants. <br><br><h4>  We read the raw data. </h4><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BMP180_Read_UT_Value</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BMP180_StructTypeDef * BMP180_Struct</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">2</span></span>]; BMP180_Struct-&gt;WriteReg(BMP180_Struct-&gt;I2C_Adrs, ctrl_meas, <span class="hljs-number"><span class="hljs-number">0x2E</span></span>); BMP180_Struct-&gt;delay_func(<span class="hljs-number"><span class="hljs-number">50</span></span>); BMP180_Struct-&gt;ReadReg(BMP180_Struct-&gt;I2C_Adrs, out_msb, buf, <span class="hljs-number"><span class="hljs-number">2</span></span>); BMP180_Struct-&gt;UT = (buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + buf[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BMP180_Read_UP_Value</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BMP180_StructTypeDef * BMP180_Struct</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">3</span></span>]; BMP180_Struct-&gt;WriteReg(BMP180_Struct-&gt;I2C_Adrs, ctrl_meas, <span class="hljs-number"><span class="hljs-number">0x34</span></span> + (BMP180_Struct-&gt;P_Oversampling &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>)); BMP180_Struct-&gt;delay_func(<span class="hljs-number"><span class="hljs-number">100</span></span>); BMP180_Struct-&gt;ReadReg(BMP180_Struct-&gt;I2C_Adrs, out_msb, buf, <span class="hljs-number"><span class="hljs-number">3</span></span>); BMP180_Struct-&gt;UP = ((buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) + (buf[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + buf[<span class="hljs-number"><span class="hljs-number">2</span></span>]) &gt;&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - BMP180_Struct-&gt;P_Oversampling); }</code> </pre> <br>  These functions read the raw values ‚Äã‚Äãof pressure and temperature, so that later we can achieve results in human-readable form with the help of mind-blowing mathematics.  This is where the delay function came in handy.  The values ‚Äã‚Äãare chosen with a margin and the reason for this is a slight reassurance in case of inaccurate operation of the delay functions.  In my case, it all works in a separate thread and while functions are waiting, other sensors work with the interface.  So I do not lose anything. <br><br><h4>  We get the result </h4><br>  To preserve the result in the structure, it is enough just to call the function <b>BMP180_Get_Result</b> with a pointer to our structure as a parameter.  She herself polls the sensor and calculates the result: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BMP180_Get_Result</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BMP180_StructTypeDef * BMP180_Struct</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> X1, X2, B5, T; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> B6, X3, B3; unsigned <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> B4, B7; BMP180_Read_UT_Value(BMP180_Struct); BMP180_Read_UP_Value(BMP180_Struct); <span class="hljs-comment"><span class="hljs-comment">/*Calculate temperature*/</span></span> X1 = ((BMP180_Struct-&gt;UT - BMP180_Struct-&gt;AC6) * BMP180_Struct-&gt;AC5) &gt;&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>; X2 = (BMP180_Struct-&gt;MC &lt;&lt; <span class="hljs-number"><span class="hljs-number">11</span></span>) / (X1 + BMP180_Struct-&gt;MD); B5 = X1 + X2; T = (B5 + <span class="hljs-number"><span class="hljs-number">8</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>; BMP180_Struct-&gt;Temperature = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)T / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*Calculate pressure*/</span></span> B6 = B5 - <span class="hljs-number"><span class="hljs-number">4000</span></span>; X1 = (BMP180_Struct-&gt;B2 * ((B6 * B6) &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>)) &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>; X2 = (BMP180_Struct-&gt;AC2 * B6) &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>; X3 = X1 + X2; B3 = (((BMP180_Struct-&gt;AC1 * <span class="hljs-number"><span class="hljs-number">4</span></span> + X3) &lt;&lt; BMP180_Struct-&gt;P_Oversampling) + <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; X1 = (BMP180_Struct-&gt;AC3 * B6) &gt;&gt; <span class="hljs-number"><span class="hljs-number">13</span></span>; X2 = (BMP180_Struct-&gt;B1 * ((B6 * B6) &gt;&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>)) &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>; X3 = ((X1 + X2) + <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; B4 = (BMP180_Struct-&gt;AC4 * (unsigned <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(X3 + <span class="hljs-number"><span class="hljs-number">32768</span></span>)) &gt;&gt; <span class="hljs-number"><span class="hljs-number">15</span></span>; B7 = ((unsigned <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)BMP180_Struct-&gt;UP - B3) * (<span class="hljs-number"><span class="hljs-number">50000</span></span> &gt;&gt; BMP180_Struct-&gt;P_Oversampling); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (B7 &lt; <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) BMP180_Struct-&gt;Pressure = (B7 * <span class="hljs-number"><span class="hljs-number">2</span></span>) / B4; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> BMP180_Struct-&gt;Pressure = (B7 / B4) * <span class="hljs-number"><span class="hljs-number">2</span></span>; X1 = (BMP180_Struct-&gt;Pressure &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) * (BMP180_Struct-&gt;Pressure &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>); X1 = (X1 * <span class="hljs-number"><span class="hljs-number">3038</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>; X2 = (<span class="hljs-number"><span class="hljs-number">-7357</span></span> * (BMP180_Struct-&gt;Pressure)) &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>; BMP180_Struct-&gt;Pressure = BMP180_Struct-&gt;Pressure + ((X1 + X2 + <span class="hljs-number"><span class="hljs-number">3791</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br>  Mathematics, of course, is hard.  ARM clicks it quickly, but STM8 might think.  In this case, the algorithm was lapped from the manual, but slightly optimized.  However, he didn‚Äôt become much easier.  On the other hand, you have not yet seen what a BMP280 is.  It uses 64-bit mathematics.  Although there are also optimization options with a loss of accuracy for the sake of speed and volume of code. <br><br><h4>  Additional features </h4>  . <br>  We now turn to the buns.  Knowing the pressure, we can theoretically calculate the height above sea level.  To be honest, I haven‚Äôt yet come up with any practical application, but there is a possibility.  Values ‚Äã‚Äãare obtained linearly dependent on the actual height, but still require adjustment for atmospheric pressure.  The same function requires the use of the library <b>&lt;math.h&gt;</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Altitude</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Pressure</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> p0 = <span class="hljs-number"><span class="hljs-number">101325</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Pressure at sea level (Pa) return (float)44330 * (1 - pow(((float) Pressure/p0), 0.190295)); }</span></span></code> </pre> <br>  This function returns millimeters of mercury.  Pretty accurate work.  To an ordinary person, this speaks much more than kPa. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">unsigned </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">short</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pa_To_Hg</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Pressure_In_Pascals</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (unsigned <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(Pressure_In_Pascals * <span class="hljs-number"><span class="hljs-number">760</span></span>) / <span class="hljs-number"><span class="hljs-number">101325</span></span>; }</code> </pre> <br>  Well, it remains the function of checking the ID of the chip.  I don't use it because  if everything is set up correctly, the connection is checked at the initialization stage: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BMP180_Check_ID</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BMP180_StructTypeDef * BMP180_Struct</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> inbuff; BMP180_Struct-&gt;ReadReg(BMP180_Struct-&gt;I2C_Adrs, <span class="hljs-number"><span class="hljs-number">0xD0</span></span>, &amp;inbuff, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inbuff == <span class="hljs-number"><span class="hljs-number">0x55</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Just add the chip reset function.  From sin away it is better to first dump it, and then intitialize. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BMP180_SW_Reset</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BMP180_StructTypeDef * BMP180_Struct</span></span></span><span class="hljs-function">)</span></span> { BMP180_Struct-&gt;delay_func(<span class="hljs-number"><span class="hljs-number">100</span></span>); BMP180_Struct-&gt;WriteReg(BMP180_Struct-&gt;I2C_Adrs, soft_reset, <span class="hljs-number"><span class="hljs-number">0xB6</span></span>); BMP180_Struct-&gt;delay_func(<span class="hljs-number"><span class="hljs-number">100</span></span>); }</code> </pre> <br><br><h4>  Initiations </h4><br>  We declare the structure for one sensor (there can be as many as possible): <br><br><pre> <code class="cs hljs">BMP180_StructTypeDef BMP180_Struct;</code> </pre> <br>  Next, we initialize it: <br><br><pre> <code class="cs hljs"> BMP180_Struct.delay_func = vTaskDelay; BMP180_Struct.ReadReg = I2C_ReadReg; BMP180_Struct.WriteReg = I2C_WriteReg; BMP180_Struct.P_Oversampling = BMP180_OversamplingX8; BMP180_Struct.I2C_Adrs = <span class="hljs-number"><span class="hljs-number">0xEE</span></span>; Error.BMP180 = BMP180_Check_ID(&amp;BMP180_Struct);</code> </pre> <br>  The first thing I want to note is that the delay function is performed by means of the operating system.  In my case, this is FreeRTOS.  You can use the standard library function <b>delay_ms</b> .  The parameters will be the same. <br>  Further functions of writing to the register and reading from the register.  We will come to them later.  For now, you just need to connect pointers to them. <br><br>  Oversempling allows us to filter the values ‚Äã‚Äãby means of the chip itself.  This increases the conversion time, but in this case it does not matter.  No one will check the pressure 10 times per second. <br><br>  The address of the sensor on the I2C bus will be standard from the manual.  (I use 8 bits of the address. Somehow it happened so historically) <br>  In a certain structure <b>Error</b> , containing the element <b>char BMP180,</b> we write the error code obtained after initialization.  If all is well, there will be zero. <br><br>  Getting the result is also very primitive: <br><br><pre> <code class="cs hljs">BMP180_Get_Result(&amp;BMP180_Struct);</code> </pre> <br>  After that, we have the temperature and pressure values ‚Äã‚Äãstored in the <b>BMP180_Struct</b> structure.  Nothing complicated. <br><br><h4>  We connect the interface. </h4><br>  It's time to connect the functions of working with the interface. <br>  Here, just take and copy is no longer possible.  Here it is necessary to include the head. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">I2C_WriteReg</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I2C_Adrs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value</span></span></span><span class="hljs-function">)</span></span> { unsigned <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xSemaphoreTake (xI2C_Semaphore, xSEMwTime) != pdTRUE) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] = Value; I2C_Struct.I2C_Address = I2C_Adrs; I2C_Struct.Reg_AddressOrLen = Reg; I2C_Struct.pBuffer = buf; I2C_Struct.pBufferSize = <span class="hljs-number"><span class="hljs-number">1</span></span>; Result = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)SW_I2C_Write_Reg(&amp;I2C_Struct); xSemaphoreGive (xI2C_Semaphore); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result; }</code> </pre> <br>  We immediately see that there is a buffer, one byte long, which we will use as a value for the register.  In essence, your task here is to ensure that the <b>Value</b> value is registered in the <b>Reg</b> register of the device with the address <b>I2C_Adrs</b> .  This is done because I never write a function to write only one byte.  I have a buffer of arbitrary length written there.  Therefore, so.  What interface to use is your business.  But we will definitely consider the example of using the I2C software implementation in the next article.  And now it's clear that I use mutexes to protect the function from access from different threads and use some of my own implementation of the <b>SW_I2C_Write_Reg</b> software function.  So it is, we'll talk more about this, this is a platform-specific part, which I deliberately do not want to consider here.  The general idea is clear and true. <br><br>  <a href="https://drive.google.com/open%3Fid%3D0Bza2qqxq3H1cVnRKZENJSFBQeHc">Download the BMP180 library from here.</a> <br>  <a href="https://drive.google.com/open%3Fid%3D0Bza2qqxq3H1cYVdCRDN3bHdLT00">You can download the I2C software implementation from here.</a> </div><p>Source: <a href="https://habr.com/ru/post/307228/">https://habr.com/ru/post/307228/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307218/index.html">How many neurons do you need to find out if the Alexander Nevsky Bridge is divorced?</a></li>
<li><a href="../307220/index.html">This little miracle is the Knut-Morris-Pratt (KMP) algorithm.</a></li>
<li><a href="../307222/index.html">About pricing for indie games</a></li>
<li><a href="../307224/index.html">Fairy, evil corporation and duck. How games are really made. Part 2. Programmer</a></li>
<li><a href="../307226/index.html">New x features: Bind in UWP</a></li>
<li><a href="../307232/index.html">We force FFMPEG to change HLS flows depending on the current throughput</a></li>
<li><a href="../307234/index.html">Migrating Xenserver 7 to linux raid</a></li>
<li><a href="../307236/index.html">Approximation of Pi by Mandelbrot Set</a></li>
<li><a href="../307242/index.html">Pattern recognition in R using convolutional neural networks from the MXNet package</a></li>
<li><a href="../307248/index.html">Work with PGPool + ORM Yii2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>