<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Maple: composing Lagrange equations of the 2 kind and the method of redundant coordinates</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 

 By the nature of professional and scientific activities, I am a mechanic. I teach theoretical mechanics at the university, I write a docto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Maple: composing Lagrange equations of the 2 kind and the method of redundant coordinates</h1><div class="post__text post__text-html js-mediator-article"><h1>  Foreword </h1><br><br>  By the nature of professional and scientific activities, I am a mechanic.  I teach theoretical mechanics at the university, I write a doctoral thesis in the field of railway rolling stock dynamics.  In general, this science absorbs most of my work and even free time. <br><br>  With Maple (the 6th version was at the department, and the 8th was bought from the hawkers) he got acquainted with a student when he started working on a future Ph.D. under the wing of my first (now late) supervisor.  There were good people who helped to figure out the package at the very first stage and start working. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And so gradually, most of the computational work on thesis preparation was shifted onto his shoulders.  The thesis was defended, and Maple forever remained a reliable assistant in scientific work.  It is often necessary to quickly evaluate a problem, set up equations, investigate them analytically, quickly obtain a numerical solution, and build graphs.  In this regard, Maple is simply irreplaceable for me (in no case I want to offend the adherents of other packages). <br><br>  To do everything that will be offered to the reader under the cut, I was prompted by the task brought by the student (I still have to do tutoring) from the school Olympiad.  The condition of the problem is as follows: <br><blockquote>  A load hanging on a thread of length L = 1.1 m tied to a nail was pushed so that it rose, and then hit the nail.  What is its speed at the moment of hitting the nail?  Gravitational acceleration g = 10 m / s <sup>2</sup> . </blockquote><br>  If you do not find fault with the necorny nebula of the condition, then the task is quite simple, and its solution, obtained by cumbersome calculations for the student, gives the result in general <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dv%26space%3B%3D%26space%3B%5Csqrt%7BgL%5Csqrt%7B3%7D%7D"><img src="https://habrastorage.org/getpro/habr/post_images/528/490/18f/52849018f722c050f2d3458a9820c088.gif" title="v = \ sqrt {gL \ sqrt {3}}"></a> <br><br>  And here I wanted to check the solution obtained with an eye to the school curriculum in physics in an independent way, for example by making the differential equations of motion of this pendulum, and not simply, but taking into account the release from communication (in the process of motion, the thread considered weightless, sags and the pendulum moves as free point). <br><br>  This served as a catalyst to take and dig up my old ideas accumulated from the time of work at the organizing committee of the All-Russian Olympiad of students on theoretical mechanics - for three years in a row he was engaged in the preparation of computer competition tasks.  The ideas concerned the automation of the construction of equations of motion for mechanical systems with non-retaining constraints and friction, using the well-known Lagrange equations of the 2nd kind <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cfrac%7Bd%7D%7Bdt%7D%5Cleft(%5Cfrac%7B%5Cpartial%26space%3BT%7D%7B%5Cpartial%26space%3B%5Cdot%7Bq%7D_i%7D%26space%3B%5Cright%26space%3B)%26space%3B-%26space%3B%5Cfrac%7B%5Cpartial%26space%3BT%7D%7B%5Cpartial%26space%3Bq_i%7D%26space%3B%3D%26space%3BQ_i,%26space%3B%5Cquad%26space%3Bi%3D%5Coverline%7B1,s%7D"><img src="https://habrastorage.org/getpro/habr/post_images/49e/930/2f7/49e9302f7d3c41f9a99d7a4a5d2689b8.gif" title="\ frac {d} {dt} \ left (\ frac {\ partial T} {\ partial \ dot {q} _i} \ right) - \ frac {\ partial T} {\ partial q_i} = Q_i, \ quad i = \ overline {1, s}"></a> <br><br>  Many teachers claim that the equations are not applicable to systems with non-holding bonds and friction. <br><br>  As for Maple, its library for solving problems of the calculus of variations makes it possible to quickly obtain the Euler-Lagrange equations, the solution of which minimizes the Hamiltonian action, which is applicable to conservative systems <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cfrac%7Bd%7D%7Bdt%7D%5Cleft(%5Cfrac%7B%5Cpartial%26space%3BL%7D%7B%5Cpartial%26space%3B%5Cdot%7Bq%7D_i%7D%26space%3B%5Cright%26space%3B)%26space%3B-%26space%3B%5Cfrac%7B%5Cpartial%26space%3BL%7D%7B%5Cpartial%26space%3Bq_i%7D%26space%3B%3D%26space%3B0,%26space%3B%5Cquad%26space%3Bi%3D%5Coverline%7B1,s%7D"><img src="https://habrastorage.org/getpro/habr/post_images/fb5/1c3/696/fb51c369678e831f7d8e55b742c941c8.gif" title="\ frac {d} {dt} \ left (\ frac {\ partial L} {\ partial \ dot {q} _i} \ right) - \ frac {\ partial L} {\ partial q_i} = 0, \ quad i = \ overline {1, s}"></a> <br><br>  Where <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DL%26space%3B%3D%26space%3BT%26space%3B-%26space%3B%5CPi"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/ae7/5d0/fd7ae75d01f259d1dc8a9f025df7d048.gif" title="L = T - \ Pi"></a>  - Lagrange function, equal to the difference between the kinetic and potential energies of the system. <br><br>  Since the tasks under consideration do not belong to the conservative class, the author made an attempt to independently realize the automation of the construction and analysis of the equations of motion.  What came of it is stated under the cut <br><br><a name="habracut"></a><br><br><h1>  1. The method of redundant coordinates </h1><br><br>  We consider a mechanical system having <i>s</i> degrees of freedom, whose position is described by a vector of generalized coordinates <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cvec%7Bq%7D%26space%3B%3D%26space%3B%5Cleft%5Bq_1%5Cleft(t%26space%3B%5Cright%26space%3B),%26space%3Bq_2%5Cleft(t%26space%3B%5Cright%26space%3B),...,q_s%5Cleft(t%26space%3B%5Cright%26space%3B)%26space%3B%5Cright%26space%3B%5D%5ET"><img src="https://habrastorage.org/getpro/habr/post_images/65e/5a8/ca3/65e5a8ca3b73816cd2186a5dc4ffd618.gif" title="\ vec {q} = \ left [q_1 \ left (t \ right), q_2 \ left (t \ right), ..., q_s \ left (t \ right) \ right] ^ T"></a>  .  Suppose there are also <i>r</i> <b>non-holding</b> bonds, among which reactions one can also count rest friction, when the limit value is exceeded, it transforms into an active force of sliding friction, the direction of which is opposite to the direction of the relative sliding velocity. <br><br>  Accounting for non-retaining bonds requires us to determine and analyze the magnitude of their reactions, so it is also necessary to determine their magnitude.  Remove these links and introduce additional <i>r</i> generalized coordinates, expressing through them the kinetic energy of the system <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DT%26space%3B%3D%26space%3BT%5Cleft(q_1,...,q_s,%26space%3Bq_%7Bs%26plus%3B1%7D,...,q_%7Bs%26plus%3Br%7D,%26space%3B%5Cdot%7Bq%7D_1,...,%5Cdot%7Bq%7D_s,%26space%3B%5Cdot%7Bq%7D_%7Bs%26plus%3B1%7D,...,%26space%3B%5Cdot%7Bq%7D_%7Bs%26plus%3Br%7D%26space%3B%5Cright%26space%3B)"><img src="https://habrastorage.org/getpro/habr/post_images/032/d72/e09/032d72e09daf20e235544d2e8455c1ef.gif" title="T = T \ left (q_1, ..., q_s, q_ {s + 1}, ..., q_ {s + r}, \ dot {q} _1, ..., \ dot {q} _s, \ dot {q} _ {s + 1}, ..., \ dot {q} _ {s + r} \ right)"></a> <br><br>  We compose <i>s + r</i> equations of motion in the form of the Lagrange equations of the 2nd kind <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cfrac%7Bd%7D%7Bdt%7D%5Cleft(%5Cfrac%7B%5Cpartial%26space%3BT%7D%7B%5Cpartial%26space%3B%5Cdot%7Bq%7D_i%7D%26space%3B%5Cright%26space%3B)%26space%3B-%26space%3B%5Cfrac%7B%5Cpartial%26space%3BT%7D%7B%5Cpartial%26space%3Bq_i%7D%26space%3B%3D%26space%3BQ_i,%26space%3B%5Cquad%26space%3Bi%3D%5Coverline%7B1,s%26plus%3Br%7D%5Cquad%5Cquad(1)"><img src="https://habrastorage.org/getpro/habr/post_images/3e0/c56/ab4/3e0c56ab4447cf3cd64f71600ab5be1c.gif" title="\ frac {d} {dt} \ left (\ frac {\ partial T} {\ partial \ dot {q} _i} \ right) - \ frac {\ partial T} {\ partial q_i} = Q_i, \ quad i = \ overline {1, s + r} \ quad \ quad (1)"></a> <br><br>  containing <i>s + r</i> unknown coordinates and <i>r</i> unknown bond reactions.  Considering relations as retaining, we supplement this system with equations of relations (for simplicity, considering geometric relations) in the form <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Df_j%5Cleft(q_1,...,q_%7Bs%26plus%3Br%7D%26space%3B%5Cright%26space%3B)%26space%3B%3D%26space%3B0,%26space%3B%5Cquad%26space%3Bj%3D%5Coverline%7B1,r%7D"><img src="https://habrastorage.org/getpro/habr/post_images/5cf/7d6/7ba/5cf7d67bae6f3809b6880fe75d9aa3a0.gif" title="f_j \ left (q_1, ..., q_ {s + r} \ right) = 0, \ quad j = \ overline {1, r}"></a> <br><br>  we obtain a closed system of equations from which the reaction values ‚Äã‚Äãare found <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DR_j%26space%3B%3D%26space%3BR_j%5Cleft(q_1,...,q_%7Bs%7D,%5Cdot%7Bq%7D_1,...%5Cdot%7Bq%7D_s%26space%3B%5Cright%26space%3B),%5Cquad%26space%3Bj%3D%5Coverline%7B1,r%7D%5Cquad%5Cquad(2)"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c22/2ff/9c4c222ff256f764166975ab40d8e878.gif" title="R_j = R_j \ left (q_1, ..., q_ {s}, \ dot {q} _1, ... \ dot {q} _s \ right), \ quad j = \ overline {1, r} \ quad \ quad (2)"></a> <br><br>  which are functions of the first <i>s</i> (independent) generalized coordinates and velocities, and they can be calculated at any step of integrating the equations of motion (1).  For retention bonds of the ‚Äúthread / surface‚Äù type, equations (1) and (2) must be supplemented with the condition of release from the bond <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DR_j%26space%3B%3D%26space%3B%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%26space%3B0,%5Cquad%26space%3BR_j%26space%3B%5Cle%26space%3B0%26space%3B%5C%5C%26space%3BR_j,%5Cquad%26space%3BR_j%26space%3B%253E%26space%3B0%26space%3B%5Cend%7Bmatrix%7D%5Cright.%5Cquad%26space%3B%5Cquad%26space%3B(3)"><img src="https://habrastorage.org/getpro/habr/post_images/a92/995/239/a9299523939bfe79bf5bf9a45f31d50c.gif" title="R_j = \ left \ {\ begin {matrix} 0, \ quad R_j \ le 0 \\ R_j, \ quad R_j> 0 \ end {matrix} \ right. \ Quad \ quad (3)"></a> <br><br>  and for bonds with dry friction <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DF_j%5Cvec%7B%5Ctau%7D%26plus%3BN_j%5Cvec%7Bn%7D"><img src="https://habrastorage.org/getpro/habr/post_images/4d9/4f5/071/4d94f50710ea5e35283329dab1914952.gif" title="F_j \ vec {\ tau} + N_j \ vec {n}"></a> <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DF_j%26space%3B%3D%26space%3B%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%26space%3B%26F_j,%26space%3B%5Cquad%26space%3B%5Cleft%7CF_j%5Cright%7C%26space%3B%5Cle%26space%3BfN_j%5C%5C%26space%3B%26-fN_j%26space%3B%5Ccfrac%7Bv_j%7D%7B%5Cleft%7Cv_j%5Cright%7C%7D,%26space%3B%5Cquad%26space%3B%5Cleft%7CF_j%5Cright%7C%26space%3B%253E%26space%3BfN_j%26space%3B%5Cend%7Bmatrix%7D%5Cright.%26space%3B%5Cquad%26space%3B(4)"><img src="https://habrastorage.org/getpro/habr/post_images/f85/007/107/f85007107b61d6623e0aa09454f051c4.gif" title="F_j = \ left \ {\ begin {matrix} &amp; F_j, \ quad \ left | F_j \ right | \ le fN_j \\ &amp; -fN_j \ cfrac {v_j} {\ left | v_j \ right |}, \ quad \ left | F_j \ right | > fN_j \ end {matrix} \ right. \ quad (4)"></a> <br><br>  where <i>F <sub>j</sub></i> and <i>N <sub>j</sub></i> respectively, the tangent and the normal component of the reaction;  <i>v <sub>j</sub></i> is the projection of the relative slip rate of the reaction point. <br><br>  Thus, equations (1) - (4) are a complete mathematical model of the motion of the mechanical system under consideration. <br><br>  We can do away with theory and go to practice. <br><br><h1>  2. Maple-functions of construction and analysis of the Lagrange equations </h1><br><br>  To solve this problem, the <b>lagrange</b> Maple library was written, containing four functions <br><br>  <b>LagrangeEQs - the construction of the equations of motion in the form of Lagrange 2 kind</b> <br><pre><code class="hljs markdown">LagrangeEQs := proc(T, q, r, F) local s := numelems(q); local n := numelems(rk); local i, k; local T1, dT1dv; local dTdv, dTdvdt; local T2, dT2dq; local dTdq; local left<span class="hljs-emphasis"><span class="hljs-emphasis">_part; local Q; local summa; local r1, dr1dq, drdq; #      for i from 1 to s do #         T1[i] := subs(diff(q[i], t) = v[i], T); dT1dv[i] := diff(T1[i], v[i]); dTdv[i] := subs(v[i] = diff(q[i], t), dT1dv[i]); dTdvdt[i] := diff(dTdv[i], t); #       T2[i] := subs(q[i] = q1[i], T); dT2dq[i] := diff(T2[i], q1[i]); dTdq[i] := subs(q1[i] = q[i], dT2dq[i]); #      left_</span></span>part[<span class="hljs-string"><span class="hljs-string">i</span></span>] := expand(simplify(dTdvdt[<span class="hljs-string"><span class="hljs-string">i</span></span>] - dTdq[<span class="hljs-string"><span class="hljs-string">i</span></span>])); end do; VectorCalculus[<span class="hljs-string"><span class="hljs-string">BasisFormat</span></span>](<span class="hljs-link"><span class="hljs-link">false</span></span>); #    (   ) for i from 1 to s do summa := 0; for k from 1 to n do #  -   k-   i-   r1[<span class="hljs-string"><span class="hljs-string">k</span></span>] := subs(q[<span class="hljs-string"><span class="hljs-string">i</span></span>] = q1[<span class="hljs-string"><span class="hljs-string">i</span></span>], r[<span class="hljs-string"><span class="hljs-string">k</span></span>]); dr1dq[<span class="hljs-string"><span class="hljs-string">k</span></span>] := VectorCalculus[<span class="hljs-string"><span class="hljs-string">diff</span></span>](<span class="hljs-link"><span class="hljs-link">r1[k], q1[i]</span></span>); drdq[k] := subs(q1[i] = q[i], dr1dq[k]); #        -    #    summa := summa + LinearAlgebra:-DotProduct(F[k], drdq[k], conjugate = false); end do; Q[i] := expand(simplify(summa)); end do; #      q return {seq(left_part[i] = Q[i], i=1..s)}; end proc:</code> </pre> <br><br>  As input parameters, the function accepts the expression of the kinetic energy <b>T</b> as a function of generalized coordinates and generalized velocities;  array of generalized coordinates <b>q</b> ;  an array of radius vectors of application points of forces <b>r</b> and an array of force vectors <b>F.</b> <br><br>  <b>LinksEQs - deriving differential constraint equations from geometric constraint equations</b> <br><pre> <code class="hljs lua">LinksEQs := proc(eqs) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Eq1, Eq2; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> r := numelems(eqs); #       <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> to r <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Eq1[i] := diff(lhs(eqs[i]), t) = diff(rhs(eqs[i]), t); Eq2[i] := diff(diff(lhs(eqs[i]), t), t) = diff(diff(rhs(eqs[i]), t), t); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>; #    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {seq(eqs[i], i=<span class="hljs-number"><span class="hljs-number">1.</span></span>.r), seq(Eq1[i], i=<span class="hljs-number"><span class="hljs-number">1.</span></span>.r),seq(Eq2[i], i=<span class="hljs-number"><span class="hljs-number">1.</span></span>.r)}; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> proc:</code> </pre><br><br>  Here it should be noted that the system of equations of geometric relations <b>eqs</b> must contain redundant coordinates explicitly, that is, have the form <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dq_%7Bs%26plus%3Bj%7D%26space%3B%3D%26space%3Bg%5Cleft(q_1,..q_s%26space%3B%5Cright%26space%3B)%26space%3B%5Cquad%26space%3Bj%3D%5Coverline%7B1,r%7D"><img src="https://habrastorage.org/getpro/habr/post_images/574/c98/8c6/574c988c6e7746faecab55aaf7f967ae.gif" title="q_ {s + j} = g \ left (q_1, .. q_s \ right) \ quad j = \ overline {1, r}"></a> <br><br>  otherwise the library functions will not be able to process the equations correctly.  To test the library's capabilities, it will come down this way, but later on this point will be reworked: it is just unclear whether the system of communication equations is guaranteed to be resolved with respect to the angular redundant coordinates. <br><br>  <b>ReduceSystem - transformation of the equations of motion with regard to the equations of relations</b> <br><pre> <code class="hljs perl">ReduceSystem := proc(eqs, links, <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> i, j, k; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> links_eqs := LinksEQs(links); <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> r := numelems(links_eqs); <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">s</span></span> := numelems(<span class="hljs-keyword"><span class="hljs-keyword">q</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> eq := [se<span class="hljs-string"><span class="hljs-string">q(eqs[i], i=1..s)</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> to <span class="hljs-keyword"><span class="hljs-keyword">s</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j from <span class="hljs-number"><span class="hljs-number">1</span></span> to r <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> e<span class="hljs-string"><span class="hljs-string">q[i]</span></span> := simplify(algsubs(links_eqs[j], e<span class="hljs-string"><span class="hljs-string">q[i]</span></span>)); end <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: end <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {se<span class="hljs-string"><span class="hljs-string">q(eq[i], i=1..s)</span></span>}; end proc:</code> </pre><br><br>  This code does not need detailed explanations - this is where the substitution of redundant generalized coordinates, velocities and accelerations, expressed by the equations of geometric and differential constraints into the equations of motion, is performed in order to bring them to a form suitable for calculating reactions of non-holding bonds <br><br>  <b>SolveAccelsReacts - solving equations of motion for reactions and generalized accelerations</b> <br><pre> <code class="hljs lua">SolveAccelsReacts := proc(eqs, q, R) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> s := numelems(q); <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> r := numelems(R); #   ,       <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> vars := [seq(diff(diff(q[i], t), t), i=<span class="hljs-number"><span class="hljs-number">1.</span></span>.s), seq(R[i], i=<span class="hljs-number"><span class="hljs-number">1.</span></span>.r)]; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> eq := [seq(eqs[i], i=<span class="hljs-number"><span class="hljs-number">1.</span></span>.numelems(eqs))]; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> i, j; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> solv; #   -  <span class="hljs-string"><span class="hljs-string">""</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> to numelems(eqs) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j from <span class="hljs-number"><span class="hljs-number">1</span></span> to s + r <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> eq[i] := subs(vars[j] = x[j], eq[i]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>; #  <span class="hljs-string"><span class="hljs-string">""</span></span> (    ) solv := solve({seq(eq[i], i=<span class="hljs-number"><span class="hljs-number">1.</span></span>.numelems(eq))}, {seq(x[i], i=<span class="hljs-number"><span class="hljs-number">1.</span></span>.s+r)}); #      assign(solv); #  ,       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {seq(vars[i] = x[i], i=<span class="hljs-number"><span class="hljs-number">1.</span></span>.s+r)}; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> proc:</code> </pre><br><br>  This function takes as input a system of equations of motion eqs, transformed according to the equations of constraints.  It is linear with respect to the second derivatives of independent coordinates and bond reactions.  Other input parameters: <b>q</b> - vector of independent coordinates;  R is an array of reactions for which it is necessary to solve the equations of motion. <br><br>  Now we illustrate how to apply the described ‚Äúfarm‚Äù in <br><br><h1>  3. The problem of a pendulum on a thin inextensible thread </h1><br><br>  The design scheme will be like this.  As a generalized coordinate, choose the angle <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cvarphi"><img src="https://habrastorage.org/getpro/habr/post_images/171/69a/674/17169a6741a1bb27b86a1280ebc0586a.gif" title="\ varphi"></a>  tilt the filament to the vertical. <br><br><img src="https://habrastorage.org/files/116/312/00c/11631200c37c4b47823cc2b27f975f4d.png"><br><br>  Since the thread is a non-holding bond, we will be interested in its reaction, which means we introduce an additional, redundant coordinate <i>r</i> ( <i>t</i> ). <br><br>  Getting started.  We clean the memory and connect the library of linear algebra <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">restart</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>(LinearAlgebra):</code> </pre><br>  We connect <b>lagrange</b> library <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">read</span></span> `/home/maisvendoo/<span class="hljs-keyword"><span class="hljs-keyword">work</span></span>/maplelibs/mechanics/lagrange.m`;</code> </pre><br>  We determine the vector of generalized coordinates, calculate the coordinates and velocity of the load, as well as the kinetic energy of the system <br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">q</span></span> := [r(t), phi(t)]; xM := <span class="hljs-string"><span class="hljs-string">q[1]</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(<span class="hljs-string"><span class="hljs-string">q[2]</span></span>); yM := -<span class="hljs-string"><span class="hljs-string">q[1]</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(<span class="hljs-string"><span class="hljs-string">q[2]</span></span>); vMx := diff(xM, t); vMy := diff(yM, t); T := simplify(<span class="hljs-keyword"><span class="hljs-keyword">m</span></span>*(vMx^<span class="hljs-number"><span class="hljs-number">2</span></span> + vMy^<span class="hljs-number"><span class="hljs-number">2</span></span>)/<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  At the output, we obtain an expression for the kinetic energy (for insertion, the latex () function is used here, which generates the result in LaTeX notation) <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DT%26space%3B%3D%26space%3B1/2%5C,m%26space%3B%5Cleft(%26space%3B%5Cleft(%26space%3Br%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7B%26space%3Bd%7D%7Bdt%7D%7D%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D%26plus%3B%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7Dr%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D%26space%3B%5Cright)"><img src="https://habrastorage.org/getpro/habr/post_images/606/7f1/e23/6067f1e23de923b9c8e49f86491867ec.gif" title="T = 1/2 \, m \ left (\ left (r \ left (t \ right) \ right) ^ {2} \ left ({\ frac {d} {dt}} \ phi \ left (t \ right ) \ right) ^ {2} + \ left ({\ frac {d} {dt}} r \ left (t \ right) \ right) ^ {2} \ right)"></a> <br><br>  We form an array of forces and an array of coordinates of their application points <br><pre> <code class="hljs perl">Mg := Vector([<span class="hljs-number"><span class="hljs-number">0</span></span>, -<span class="hljs-keyword"><span class="hljs-keyword">m</span></span>*g]); React := Vector([-S*<span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(<span class="hljs-string"><span class="hljs-string">q[2]</span></span>), S*<span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(<span class="hljs-string"><span class="hljs-string">q[2]</span></span>)]); rM := Vector([xM, yM]); Fk := [Mg, React]; rk := [rM, rM];</code> </pre><br>  We feed all functions <b>LagrangeEQs</b> () <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">EQs</span></span> := LagrangeEQs(T, q, rk, Fk):</code> </pre><br>  getting output equations of motion <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dm%7B%5Cfrac%26space%3B%7Bd%5E%7B2%7D%7D%7Bd%7Bt%7D%5E%7B2%7D%7D%7Dr%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B-mr%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7D%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D%3Dmg%5Ccos%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B-S%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(5)"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/6ad/58a/7b76ad58a593f7252c64786f74ba2a08.gif" title="m {\ frac {d ^ {2}} {d {t} ^ {2}}} r \ left (t \ right) -mr \ left (t \ right) \ left ({\ frac {d} {dt }} \ phi \ left (t \ right) \ right) ^ {2} = mg \ cos \ left (\ phi \ left (t \ right) \ right) -S \ quad \ quad (5)"></a> <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D2%5C,mr%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7D%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7Dr%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%26plus%3Bm%26space%3B%5Cleft(%26space%3Br%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D%7B%5Cfrac%26space%3B%7Bd%5E%7B2%7D%7D%7Bd%7Bt%7D%5E%7B2%7D%7D%7D%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%3D%26space%3B-mgr%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Csin%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(6)"><img src="https://habrastorage.org/getpro/habr/post_images/ad4/809/3f7/ad48093f7530af6c07986b2f7d155cf9.gif" title="2 \, mr \ left (t \ right) \ left ({\ frac {d} {dt}} \ phi \ left (t \ right) \ right) {\ frac {d} {dt}} r \ left ( t \ right) + m \ left (r \ left (t \ right) \ right) ^ {2} {\ frac {d ^ {2}} {d {t} ^ {2}}} \ phi \ left ( t \ right) = -mgr \ left (t \ right) \ sin \ left (\ phi \ left (t \ right) \ right) \ quad \ quad (6)"></a> <br><br>  It is not difficult to make sure that the function worked normally - for the illustration, a not too cumbersome task was specially chosen. <br><br>  Next, we set the coupling equation - while the thread is stretched, the condition <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dr(t)%26space%3B%3D%26space%3BL"><img src="https://habrastorage.org/getpro/habr/post_images/bb5/40b/0d1/bb540b0d1c271dd2594db8b4301b6f40.gif" title="r (t) = L"></a> <br><br>  transform the system taking into account this condition and find the reaction of communication <br><pre> <code class="hljs go">link_eqs := {r(t) = L}; simple_eqs := ReduceSystem(EQs, link_eqs, q); solv1 := SolveAccelsReacts(simple_eqs, [phi(t)], [S]);</code> </pre><br>  The tension force of the thread is equal to <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DS%3Dm%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7D%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7DL%26plus%3Bmg%5Ccos%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(7)"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/111/430/4a61114307b36e9b026543fe14b55a12.gif" title="S = m \ left ({\ frac {d} {dt}} \ phi \ left (t \ right) \ right) ^ {2} L + mg \ cos \ left (\ phi \ left (t \ right) \ right) \ quad \ quad (7)"></a> <br><br>  System (5) - (7) is a complete system of equations for the movement of the load, taking into account the possibility of thread sagging.  Now we will prepare it for numerical integration.  To begin with, let's solve it with respect to accelerations, passing to SolveAccelsReacts () equations (5) and (6), a vector of generalized coordinates and an empty array of reactions <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">EQs2</span></span> := SolveAccelsReacts(EQs, q,[]);</code> </pre><br>  getting out <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%7B%5Cfrac%26space%3B%7Bd%5E%7B2%7D%7D%7Bd%7Bt%7D%5E%7B2%7D%7D%7D%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%3D-%7B%5Cfrac%26space%3B%7B2%5C,%26space%3B%5Cleft(%26space%3B%7B%26space%3B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7Dr%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7D%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%26plus%3B%5Csin%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3Bg%7D%7Br%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%7D%7D%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(8)"><img src="https://habrastorage.org/getpro/habr/post_images/897/e54/52e/897e5452eb0f71d1e662ad71f257d5db.gif" title="{\ frac {d ^ {2}} {d {t} ^ {2}}} \ phi \ left (t \ right) = - {\ frac {2 \, \ left ({\ frac {d} {dt }} r \ left (t \ right) \ right) {\ frac {d} {dt}} \ phi \ left (t \ right) + \ sin \ left (\ phi \ left (t \ right) \ right) g} {r \ left (t \ right)}} \ quad \ quad (8)"></a> <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%7B%5Cfrac%26space%3B%7Bd%5E%7B2%7D%7D%7Bd%7Bt%7D%5E%7B2%7D%7D%7Dr%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%3D%7B%5Cfrac%26space%3B%7Bmr%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cleft(%26space%3B%7B%5Cfrac%26space%3B%7Bd%7D%7Bdt%7D%7D%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B%5E%7B2%7D%26plus%3Bmg%26space%3B%5Ccos%26space%3B%5Cleft(%26space%3B%5Cphi%26space%3B%5Cleft(%26space%3Bt%26space%3B%5Cright)%26space%3B%5Cright)%26space%3B-S%7D%7Bm%7D%7D%26space%3B%5Cquad%26space%3B%5Cquad%26space%3B(9)"><img src="https://habrastorage.org/getpro/habr/post_images/d89/bca/5ca/d89bca5ca6191cc1a80118083edc08a5.gif" title="{\ frac {d ^ {2}} {d {t} ^ {2}}} r \ left (t \ right) = {\ frac {mr \ left (t \ right) \ left ({\ frac {d } {dt}} \ phi \ left (t \ right) \ right) ^ {2} + mg \ cos \ left (\ phi \ left (t \ right) \ right) -S} {m}} \ quad \ quad (9)"></a> <br><br>  For numerical simulation, although it is not sporty, we will write a separate code in order not to clog the reader‚Äôs head with a long processing of the resulting system with a file.  Especially since the simulation will have its own characteristics. <br><br>  We prepare the source data and the system of equations of motion <br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">L</span></span> := <span class="hljs-number"><span class="hljs-number">1.1</span></span>: g := <span class="hljs-number"><span class="hljs-number">10.0</span></span>: #      <span class="hljs-type"><span class="hljs-type">EQs_func</span></span> := <span class="hljs-keyword"><span class="hljs-keyword">proc</span></span>(<span class="hljs-type"><span class="hljs-type">N</span></span>, t, <span class="hljs-type"><span class="hljs-type">Y</span></span>, dYdt) #     (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> = <span class="hljs-type"><span class="hljs-type">S</span></span>/m) local <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> := <span class="hljs-number"><span class="hljs-number">0</span></span>; #    ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; <span class="hljs-type"><span class="hljs-type">L</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #   ,     <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> := <span class="hljs-type"><span class="hljs-type">L</span></span>*<span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]^<span class="hljs-number"><span class="hljs-number">2</span></span> + g*cos(<span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>]); #    -  ,   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> := <span class="hljs-number"><span class="hljs-number">0</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; #       # <span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>] -&gt; r(t) -      # <span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>] -&gt; phi(t) -  -    # <span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>] -&gt; vr(t) -    # <span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>] -&gt; omega(t) -    - dYdt[<span class="hljs-number"><span class="hljs-number">1</span></span>] := <span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>]; dYdt[<span class="hljs-number"><span class="hljs-number">2</span></span>] := <span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; dYdt[<span class="hljs-number"><span class="hljs-number">3</span></span>] := <span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]*<span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]^<span class="hljs-number"><span class="hljs-number">2</span></span> + g*cos(<span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>]) - <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>; dYdt[<span class="hljs-number"><span class="hljs-number">4</span></span>] := -(<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>]*<span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>] + g*sin(<span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>]))/<span class="hljs-type"><span class="hljs-type">Y</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; end <span class="hljs-keyword"><span class="hljs-keyword">proc</span></span>:</code> </pre><br><br>  We build the function of calculating the state of the system, for a given horizontal initial velocity of the load <br><pre> <code class="hljs delphi">sys_pos := proc(v0) #    <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> initc := <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>([L, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, v0/L]); #  ,   <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> q := [r(t), phi(t), vr(t), omega(t)]; #      <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> dsolv := dsolve(numeric, number = <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EQs_func</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> = 0, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initial</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initc</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">procvars</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">q</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output</span></span></span><span class="hljs-function">=</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listprocedure</span></span></span><span class="hljs-function">);</span></span> #      <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> R := eval(r(t), dsolv); <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Phi := eval(phi(t), dsolv); <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Vr := eval(vr(t), dsolv); <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> Omega := eval(omega(t), dsolv); return [R, Phi, Vr, Omega]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> proc:</code> </pre><br><br>  Now we check the ‚Äúschool‚Äù solution of the problem. <br><pre> <code class="hljs go">#     ,     v0 := evalf(sqrt(g*L*(<span class="hljs-number"><span class="hljs-number">2</span></span> + sqrt(<span class="hljs-number"><span class="hljs-number">3</span></span>)))): #      eps := <span class="hljs-number"><span class="hljs-number">1e-5</span></span>: #      r := sys_pos(v0)[<span class="hljs-number"><span class="hljs-number">1</span></span>]: phi := sys_pos(v0)[<span class="hljs-number"><span class="hljs-number">2</span></span>]: vr := sys_pos(v0)[<span class="hljs-number"><span class="hljs-number">3</span></span>]: #     x := t-&gt;r(t)*sin(phi(t)): y := t-&gt;-r(t)*cos(phi(t)): #      t1 := fsolve(r(t) = eps, t=<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>): #      v := vr(t1); #    plot([x(t), y(t), t=<span class="hljs-number"><span class="hljs-number">0.</span></span>.t1], view=[-L..L, -L..L]);</code> </pre><br>  As a result, we get the result shown in the screenshot.  The speed of the load at the moment of impact corresponds to the value given in the preface, and it can be seen that before the thread sags, the load moves in a circle, and after the thread sags, it moves as a free point under the action of gravity, along a parabola. <br><img src="https://habrastorage.org/files/026/5d8/e6c/0265d8e6c32740a691339366ccf95eab.png"><br><br>  I note that the error of hitting the nail is a necessary measure: in the polar coordinates that were used, the task has a feature that is clear from equation (8).  Therefore, <i>r</i> ( <i>t</i> ) was not compared with zero, but with the value of eps small enough to get a solution, and large enough so that the numerical solver fsolve () does not go crazy.  However, this does not detract from the practical value of the results presented. <br><br><h1>  Instead of conclusion </h1><br><br>  Perhaps the reader will reproach me for shooting sparrows with a cannon.  However, I would like to note that everything complex begins with a simple one, and big science starts with small tasks. <br><br>  Test version of the library can be <a href="">downloaded here.</a> <br><br>  Thank you for your attention to my work) </div><p>Source: <a href="https://habr.com/ru/post/244957/">https://habr.com/ru/post/244957/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244947/index.html">How we experimented with the Theory of Constraints in Ukraine</a></li>
<li><a href="../244949/index.html">Javascript birthday</a></li>
<li><a href="../244951/index.html">Administration of our days: ‚ÄúI have a lift hung!‚Äù</a></li>
<li><a href="../244953/index.html">Increase conversion Landing Page</a></li>
<li><a href="../244955/index.html">New GNS3 - step forward or jump on the spot?</a></li>
<li><a href="../244959/index.html">Authorization and registration components in CMS 1C-Bitrix</a></li>
<li><a href="../244963/index.html">Serialization and C ++ 11</a></li>
<li><a href="../244965/index.html">15 tips on how to build communication with web service users based on their behavior</a></li>
<li><a href="../244967/index.html">The explosive growth of downloads after the release of the iPhone 6, what will be the mobile Internet, the new App Store from Xiaomi - and other news of the week for a mobile developer</a></li>
<li><a href="../244969/index.html">The author of Lean Startup, Eric Rees and Ilya Korolev (IIDF), on the advantages of a ‚Äúlean‚Äù approach to creating companies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>