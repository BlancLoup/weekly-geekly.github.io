<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Methods in primitive types of PHP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago, Anthony Ferrara expressed his thoughts about the future of PHP . I agree with most of his views, but not with all. In the article, I wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Methods in primitive types of PHP</h1><div class="post__text post__text-html js-mediator-article">  Some time ago, Anthony Ferrara expressed his thoughts about the <a href="http://blog.ircmaxell.com/2014/03/an-opinion-on-future-of-php.html">future of PHP</a> .  I agree with most of his views, but not with all.  In the article, I will focus on one specific aspect: converting primitive data types, such as strings or arrays, into ‚Äúpseudo-objects‚Äù, allowing you to execute method calls to them. <br><br>  Let's start with a few examples: <br><br><pre><code class="php hljs">$str = <span class="hljs-string"><span class="hljs-string">"test foo bar"</span></span>; $str-&gt;length(); <span class="hljs-comment"><span class="hljs-comment">// == strlen($str) == 12 $str-&gt;indexOf("foo") // == strpos($str, "foo") == 5 $str-&gt;split(" ") // == explode(" ", $str) == ["test", "foo", "bar"] $str-&gt;slice(4, 3) // == substr($str, 4, 3) == "foo" $array = ["test", "foo", "bar"]; $array-&gt;length() // == count($array) == 3 $array-&gt;join(" ") // == implode(" ", $array) == "test foo bar" $array-&gt;slice(1, 2) // == array_slice($array, 1, 2) == ["foo", "bar"] $array-&gt;flip() // == array_flip($array) == ["test" =&gt; 0, "foo" =&gt; 1, "bar" =&gt; 2]</span></span></code> </pre> <br>  Here <code>$str</code> is a regular string and <code>$array</code> is a simple array ‚Äî they are not objects.  We simply give them some object behavior, allowing them to call methods. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Please note that this behavior is not far off.  This is no longer a dream, something already exists right now.  The <a href="https://github.com/nikic/scalar_objects">scalar objects</a> php extension allows you to define methods for primitive types. <br><br><a name="habracut"></a><br><br>  The introduction of method call support in primitive types has a number of advantages, which I will consider further: <br><br><h2>  Ability to clear API </h2><br>  Probably the most common complaint of those who have ever heard of PHP is the inconsistent and incomprehensible naming of functions in the standard library, as well as the equally inconsistent and incomprehensible order of parameters.  Typical examples: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    strpos str_replace //    strcspn // STRing Complement SPaN strpbrk // STRing Pointer BReaK //    strpos($haystack, $needle) array_search($needle, $haystack)</span></span></code> </pre><br>  Although this problem is often overvalued <i>(we also have an IDE)</i> , it is difficult to deny that the current situation is not sufficiently optimal.  It should also be noted that many functions have problems that go beyond the bizarre name.  Often, all cases of behavior are taken into account properly taken into account and, accordingly, are not processed, thus there is a need to specifically process them in the calling code.  For string functions, as a rule, these are checks for empty lines or offsets at the very end of the line. <br><br>  The logical solution is to simply add to PHP6 a huge number of aliases for functions that will unify the names and parameters of the call.  We will have <code>string\\pos()</code> , <code>string\\replace()</code> , <code>string\\complement_span()</code> or something like that.  For me personally <i>(and, it seems, many php-src developers have a similar opinion)</i> this does not make much sense.  The current names of the functions are deeply rooted in the muscle memory of any PHP programmer, and there seems to be no need to make some trivial cosmetic changes. <br><br>  On the other hand, the introduction of the OO API for primitive types makes it possible to redesign the API as a side effect of the transition to a new paradigm.  It also allows you to start from a truly clean slate, without having to satisfy any expectations of the old procedural API.  Two examples: <br><br><ul><li>  I would very much like the <code>$string-&gt;split($delimiter)</code> and <code>$array-&gt;join($delimiter)</code> methods, which are generally accepted, to have normal names for these functions <i>(unlike <code>explode</code> and <code>implode</code> )</i> .  On the other hand, it is very inconvenient to have a <code>string\\split($delimiter)</code> function, even <code>str_split</code> function already exists, which does something completely different (converts a string into an array). </li><li>  I would like the new API to use error reporting exceptions, like in the OO API, in which it is already perceived as given and in the renamed procedural API.  However, this approach goes against the current agreement, which states that all procedural functions should use warning to handle errors.  Of course, this is not carved in stone, but I would not want to consciously start a holivar;) </li></ul><br><br>  My <i>main</i> goal in the OO API for primitive types is to start from scratch, which will allow us to implement a set of properly designed solutions.  But, of course, this is not the only advantage of such a step.  The TOE syntax offers a number of additional benefits, which will be discussed below. <br><br><h2>  Improved readability </h2><br>  Procedural calls usually do not stack into a chain.  Consider the following example: <br><br><pre> <code class="php hljs">$output = array_map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $value * <span class="hljs-number"><span class="hljs-number">42</span></span>; }, array_filter($input, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $value &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>; });</code> </pre><br>  At first glance, it is not clear what caused <code>array_map</code> and what <code>array_filter</code> turned <code>array_filter</code> ?  In what order did they volunteer?  The <code>$input</code> variable is hidden somewhere in the middle between two closures, function calls are written in reverse order, depending on how they are actually used.  Now the same example using OO syntax: <br><br><pre> <code class="php hljs">$output = $input-&gt;filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $value &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>; })-&gt;map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $value * <span class="hljs-number"><span class="hljs-number">42</span></span>; });</code> </pre><br>  I suppose that in this case the order of actions (first the filter, then the mapping) and the original <code>$input</code> array are shown more clearly. <br><br>  An example, of course, is a bit contrived, since you can always take out closures to variables or use auto-substitution and syntax highlighting in the IDE.  Another example (this time from the real code) shows approximately the same situation: <br><br><pre> <code class="php hljs">substr(strtr(rtrim($className, <span class="hljs-string"><span class="hljs-string">'_'</span></span>), <span class="hljs-string"><span class="hljs-string">'\\'</span></span>, <span class="hljs-string"><span class="hljs-string">'_'</span></span>), <span class="hljs-number"><span class="hljs-number">15</span></span>);</code> </pre><br>  In this case, the number of additional parameters <code>'_'), '\\\\', '_'), 15</code> completely confusing, it is difficult to associate the substituted values ‚Äã‚Äãwith the corresponding function calls.  Compare with this version: <br><br><pre> <code class="php hljs">$className-&gt;trimRight(<span class="hljs-string"><span class="hljs-string">'_'</span></span>)-&gt;replace(<span class="hljs-string"><span class="hljs-string">'\\'</span></span>, <span class="hljs-string"><span class="hljs-string">'_'</span></span>)-&gt;slice(<span class="hljs-number"><span class="hljs-number">15</span></span>);</code> </pre><br>  Here, operations and their arguments are tightly grouped and the order of calling the methods corresponds to the order in which they are executed. <br><br>  Another bonus that results from this syntax is the absence of the ‚Äúneedle / haystack‚Äù problem.  While aliases allow us to eliminate this by introducing a naming convention, there is simply no such problem in the OO API: <br><br><pre> <code class="php hljs">$string-&gt;contains($otherString) $array-&gt;contains($someValue) $string-&gt;indexOf($otherString) $array-&gt;indexOf($someValue)</code> </pre><br>  There can be no confusion as to which part performs which role. <br><br><h2>  Polymorphism </h2><br>  PHP currently provides <a href="http://php.net/manual/ru/class.countable.php">the <code>Countable</code> interface</a> , which can be implemented in classes, in order to customize the <code>count($obj)</code> output <code>count($obj)</code> .  Why is all this necessary?  Because we do not have polymorphism of functions.  However, we have a polymorphism of methods. <br><br>  If arrays implement <code>$array-&gt;count()</code> as a (pseudo-) method, at the code level you will not have to worry that <code>$array</code> is an array.  This can be implemented in any other object using the <code>count()</code> method.  In principle, we get the same behavior as when using the <code>Countable</code> , only without the need for any manipulations. <br><br>  In fact, a much more general solution is hidden here.  For example, you could implement a <code>UnicodeString</code> class that implements all methods of type string, and then use regular strings and <code>UnicodeString</code> interchangeably.  Well, at least in theory.  Obviously, this will work only as long as the use is limited only to string methods, and will fail, after using the concatenation operator, since  complete operator overloading is currently supported only for inner classes. <br><br>  However, I hope it is clear that this is a rather powerful concept.  The same applies to arrays, for example.  You could use <a href="http://php.net/manual/ru/class.splfixedarray.php">the <code>SplFixedArray</code> class</a> , which behaves in the same way as an array, implementing the same interface. <br><br>  Now that we have considered some of the advantages of this approach, let's also consider some of the problems that will have to be faced: <br><br><h2>  Unstable typing </h2><br>  Quote from Anthony's blog: <br><blockquote>  [C] Kalyars are not objects, but, more importantly, they cannot be any types.  PHP depends on a typing system that sincerely believes that strings are integers.  Much of the flexibility of the system is based on the fact that any scalar type can be converted to any other with ease.  [...] </blockquote><br><blockquote>  More importantly, however, because of this weak typing system, you cannot know 100% what type a variable will be.  You can tell how you want to relate to it, but you cannot explicitly state what will be under the hood.  Even with the help of casting, you will not achieve the ideal situation, as there are times when the type can still change. <br></blockquote><br><br>  To illustrate this problem, consider the following example: <br><br><pre> <code class="php hljs">$num = <span class="hljs-number"><span class="hljs-number">123456789</span></span>; $sumOfDigits = array_sum(str_split($num));</code> </pre><br>  Here, <code>$num</code> processed as a string of digits separated by <code>str_split</code> , and then summed with <code>array_sum</code> .  Now try doing the same thing using methods: <br><br><pre> <code class="php hljs">$num = <span class="hljs-number"><span class="hljs-number">123456789</span></span>; $sumOfDigits = $num-&gt;chunk()-&gt;sum();</code> </pre><br>  The <code>chunk()</code> method, which is in <code>string</code> , is called from <code>number</code> .  What's happening?  Anthony offers one solution: <br><br><blockquote>  This means that for all scalar operations, all scalar types must be respected.  Which leads to an object model where scalars have all the mathematical methods, as well as all string methods.  What a nightmare. <br></blockquote><br>  The quote already says that such a decision is unacceptable.  However, I think that we can completely get rid of such cases simply by throwing an error (exception!).  To explain why an idea has a right to life, let's take a look at what types in PHP may matter. <br><br><h2>  Primitive types in php </h2><br>  In addition to objects, PHP has the following types of variables: <br><br><pre> <code class="hljs cs"><span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> array resource</code> </pre><br>  Now let's think that the list can actually have meaningful methods: You can immediately remove the <code>resource</code> (legacy type) and look at the rest.  <code>Null</code> and <code>bool</code> , obviously, do not need methods if you do not want to invent abominations like <code>$bool-&gt;invert()</code> . <br><br>  The vast majority of mathematical functions do not look too good as methods.  Consider: <br><br><pre> <code class="php hljs">log($n) $n-&gt;log() sqrt($n) $n-&gt;sqrt() acosh($n) $n-&gt;acosh()</code> </pre><br>  I hope you agree that the mathematical functions for reading are much nicer in the current notation.  There are, of course, several methods that it would be reasonable to assign to the <code>number</code> type.  For example, <code>$num-&gt;format(10)</code> reads quite nicely.  More on this.  There is no real need for the OO number API, as there are few features that can be enabled.  In addition, the current mathematical API is not so problematic in terms of naming according to mathematical operations, the names are pretty standardized. <br><br>  Only strings and arrays remain.  We have already seen that there are many good APIs for these two types.  But what does all this have to do with the problem with weak typing?  The important point is the following: <br><br>  Although the presentation of strings as integers is very often used, for example, those arriving via HTTP or from a database, the reverse is not true: it is very rare that you need to use an integer as a string.  The following code will confuse me: <br><br><pre> <code class="php hljs">strpos(<span class="hljs-number"><span class="hljs-number">54321</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Handling numbers as strings is a pretty weird job.  I think it is perfectly normal to demand a reduction in this case.  Using the original example with the sum of numbers: <br><br><pre> <code class="php hljs">$num = <span class="hljs-number"><span class="hljs-number">123456789</span></span>; $sumOfDigits = ((string) $num)-&gt;chunk()-&gt;sum();</code> </pre><br>  Here we found out that, yes, in fact, it is not necessary to cast a number to a string.  It is acceptable for me in such cases to use such a hack. <br><br>  With arrays, the situation is even simpler: it does not make sense to use operations to work with arrays with a non-array array. <br><br>  Another factor that improves this issue is the control of scalar types (which is present in any version of PHP).  If you use the <code>string</code> type control, you will always have to submit a string at the input (even if the value passed to the function is missing - depending on the details of the type control implementation). <br><br>  But this does not mean that there is no problem at all.  Due to improperly designed functions, it can sometimes happen that an unexpected type sneaks into the code.  For example, <code>substr($str, strlen($str))</code> , someone very ‚Äúwise‚Äù decided to return <code>bool(false)</code> instead of <code>string(0) ""</code> .  However, such a question concerns only <code>substr</code> .  It is not related to API methods, so you will not encounter this. <br><br><h2>  Object transfer semantics </h2><br>  In addition to the problem with implicit typing, there is another semantic question about pseudo-methods in primitive types: objects and types in PHP have different semantic ways of interacting with themselves.  If we start allowing methods to be called in strings and arrays, they will start to look like objects and some people might start to expect that they have object semantics.  This issue affects both strings and arrays: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $arg-&gt;length(); <span class="hljs-comment"><span class="hljs-comment">// $arg    $arg[0] = 'x'; //    :3 } $str = 'foo'; change($str); // $str   $array = ['f', 'o', 'o']; change($array); // $array  </span></span></code> </pre><br>  One could change the effect of semantics.  In my eyes, the transmission of large structures, such as arrays, by value, is a rather bad idea; first of all, it would be preferable that they are transferred by object.  However, there would be a rather large hole in backward compatibility with the change of approach, at least I think so, I did not perform tests to determine the actual impact of such a change.  For strings, on the other hand, passing as an object will be disastrous if we force the strings to be completely unchanged.  Personally, I think the current approach, which allows changing a particular character in a string at any time, is very convenient (try doing the same in Python). <br><br>  I do not know if there is a good way to solve this problem, except for the explicit mention in our documentation that strings and arrays are only <i>pseudo-objects</i> with methods, and not real objects. <br><br>  The problem can also be extended to other object-related functions.  For example, you could write something like <code>$string instanceof string</code> to explicitly define a string this or a real object.  I do not know how far all this should go.  It is better to strictly adhere to all methods and explicitly mention that these are not real objects.  In this case, you get good support for the features of the OO system.  We will have to think about it. <br><br><h2>  Current state </h2><br>  In conclusion, this approach has a number of problems, but they should not be considered as particularly important.  At the same time, it provides great opportunities to implement environmentally friendly APIs for our basic types and to improve readability (and writing) of the code for performing operations with them. <br><br>  What is the state of the idea?  The people are not particularly against such an approach, and they want such alias to exist everywhere.  The main thing that is not enough to move forward on this issue is the lack of a developed specification for the API. <br><br>  I created a project <a href="https://github.com/nikic/scalar_objects">scalar objects</a> , which is implemented as a PHP extension.  It allows you to register a class that will handle method calls for the corresponding primitive type.  Example: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strlen(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> !== strpos(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>, $str); } } register_primitive_type_handler(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'StringHandler'</span></span>); $str = <span class="hljs-string"><span class="hljs-string">"foo bar baz"</span></span>; var_dump($str-&gt;length()); <span class="hljs-comment"><span class="hljs-comment">// int(11) var_dump($str-&gt;contains("bar")); // bool(true) var_dump($str-&gt;contains("hello")); // bool(false)</span></span></code> </pre><br>  Work has now begun on the <a href="https://github.com/nikic/scalar_objects/blob/master/handlers/string.php">string handler</a> , which includes the <a href="">API specification</a> , but I have not finished the project.  I hope I find the motivation to someday continue to develop this idea.  There are already a number of projects working on similar APIs. <br><br>  Here is one of those things that I would like to see in the new PHP. </div><p>Source: <a href="https://habr.com/ru/post/240561/">https://habr.com/ru/post/240561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240545/index.html">rawdog - RSS aggregator without excessive requests</a></li>
<li><a href="../240549/index.html">Barcelona tried to seize the domain in the .email zone</a></li>
<li><a href="../240555/index.html">DigitalOcean launches metadata server</a></li>
<li><a href="../240557/index.html">Using the proxy pattern to organize caching in PHP</a></li>
<li><a href="../240559/index.html">Pricing model for SaaS: more money - more problems</a></li>
<li><a href="../240565/index.html">Semi-automatic registration of unit tests on pure C</a></li>
<li><a href="../240571/index.html">Device for laying additional air lines</a></li>
<li><a href="../240573/index.html">Billing in SaaS applications on Ruby on Rails. Continued about 3-D Secure</a></li>
<li><a href="../240575/index.html">Partnership Docker and Microsoft: a lot of announcements</a></li>
<li><a href="../240577/index.html">Russian OVP - Telebreeze</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>