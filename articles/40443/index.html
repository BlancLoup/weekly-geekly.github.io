<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AdMe.ru: Tags, full-text search and all that ...</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will reveal the secrets of how adme.ru works, namely, I will tell you how storage of articles and tags is arranged, how full-text se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>AdMe.ru: Tags, full-text search and all that ...</h1><div class="post__text post__text-html js-mediator-article">  In this article I will reveal the secrets of how adme.ru works, namely, I will tell you how storage of articles and tags is arranged, how full-text search works, search by tags, and so on ... <br><br>  The article provides an example of the structure of the tables, the working Sphinx config and some php code with sample samples. <a name="habracut"></a><br><br><h4>  A bit of history </h4>  Once upon a time, tags on adme.ru were stored in the manner described <a href="http://habrahabr.ru/blogs/webdev/40320/">in this post</a> (method number two), and the search was carried out in the manner described <a href="http://habrahabr.ru/blogs/webdev/40218/">in this post</a> (match against). <br>  It was implemented in the following way: In the table where the articles were stored there was a text field tags - in this field the ID tags were stored in this form: "3a10 s3 1zog s7 4eus s8 vx rt 4lcd 4gv4 3c4i 3c3q 3a09 39za" is nothing else id tags in the 36-digit number system (was chosen because of the compactness of the representation of large numbers) listed through a space.  Just this method of storage allowed to receive articles from a table by a specific tag or tags.  Of course, for the operation of such a scheme, it was necessary to keep the table in MyISAM, across the tags field to make a fulltext index, and in my.cnf specify ft_min_word_len = 0 so that full-text search works and for tags whose ID in the 36th system will be less than 3 characters ( or 2, I do not remember).  Now, about the search: Full-text search did not work on the source table but on its own, which was replenished and changed during those moments when the editor added, deleted or changed articles.  In this table, for each article there was a text field that contained word forms.  The word forms themselves were built not only from the content, title and announcement of the article, but also from the tags belonging to this article.  And again, our not beloved MyISAM, fulltext index and match against. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Unfortunately, such tag storage and such a search mechanism have several important disadvantages:</b> <br><ol><li>  When adding or changing a record in a table (MyISAM) with articles, the entire table lochitsya, the process of adding / changing a record itself takes a long time and as a result all other customers who want to get something from the table get in the queue.  Articles are edited and added constantly, which leads to permanent site brakes. </li><li>  Full-text search using match against is very, very deceptive, and gives a significant load on the database. </li><li>  It works slowly. </li><li>  It works very slowly. </li><li>  It works like Kick as slow. </li></ol>  All these shortcomings made us think and make the right decision. <br><br><h4>  What is the solution </h4>  Links tags and materials stored in a separate table.  Selection of materials by tags, by time range and full-text search to give Sphinx'u. <br>  As a result, Sphinx saved us from all the flaws of the previous scheme and did not add any new ones.  In this article I will not dwell on the moments associated with the installation of Sphinx and I will not talk about sphinx-api - we will assume that all this is already familiar to the reader. <br><br><h4>  Keeping tags and articles </h4>  The requirements for tags are: <ol><li>  It should be possible to set the tags synonyms, for example: commercials, TV commercials and so on.  You also need the ability to designate the main of these synonyms. </li><li>  It should be possible to set tags for their values ‚Äã‚Äãin different languages, for example, in Russian, the tag will be presented as "Movies", and in English as "TV-Spots" or "Reels", for other languages, the rule from p.1 should also be observed </li><li>  Tags must be organized into multi-level trees, so that objects can be classified using several attributes.  For example, the tag "Russia" is a subsidiary to the tag "Geography". </li></ol>  Of these requirements, approximately the following table structure emerges: <br>  <b>tags</b> <br>  id <br>  path - URL of the tag, a string of Latin letters, for example for the tag "Creative Review" it will be "kreativnyj_obzor" <br>  left_key - tree <br>  right_key - tree <br>  gr_id - tag group (tree) ID.  It is necessary to store several trees in one table and to determine if a particular tag belongs to a specific tree. <br>  <b>tags_names</b> <br>  tree_id - tag identifier from tags table <br>  name - natural language tag representation, for example Russia, Russia <br>  primary - the main name value flag for the current tree_id <br>  lang - language code <br>  The structure of article tables (simplified version): <br>  <b>articles</b> <br>  id <br>  header - header <br>  anounce - announcement <br>  published_at - publication date <br>  modified_at - last modified date <br>  published - flag of publication <br>  <b>articles_content</b> <br>  id - id of articles from articles <br>  content - a large piece of text - article content <br>  <b>articles_sphinx</b> - this table always contains only one entry. <br>  ts - last full indexing time <br>  Link tags and articles: <br>  <b>articles_tags</b> <br>  id - article identifier <br>  tag_id - tag identifier <br>  order - tag order (this field is important for us, since we build the full URL of the article for its first tag, <a href="http://www.adme.ru/creativity/2008/09/18/23862/">here is an example</a> ) <br><br><h4>  How to index real-time </h4>  For real-time indexing, we use two indexes - the main index contains all articles and is updated at night, and the delta index contains articles added or modified today. <br><br>  Accordingly, every time we change or add an article, we run a reindexing of the delta index. <br>  Since the delta index itself does not contain a lot of materials, the indexing time is very short.  We reindex the main index at night. <br><br>  In this case, the search is always carried out simultaneously on two indices - on the main and delta. <br><br><h4>  Sphinx working config for real-time indexing and tag search </h4><br><pre>  source articles
 {	
	 type = mysql
	 sql_host = *********
	 sql_user = *********
	 sql_pass = *********
	 sql_db = *********
	 sql_port = 3306  

	 sql_query_pre = SET NAMES utf8
	 sql_query = SELECT article.id, article.id AS idt, article.header, article.anounce, article_content.content, article.published_at, 0 AS deleted, \
					 (SELECT concat (concat ('_ tag', replace (group_concat (tags_names.tree_id), ',', '_tag'), ''), replace (group_concat (tags_names.name), ',', '')) \
					 FROM tags_names AS tags_names \
					 JOIN articles_tags AS articles_tags ON (tags_names.tree_id = articles_tags.tag_id) \
					 WHERE articles_tags.id = article.id \
					 ) AS `tags_names` \
				   FROM articles AS article \
				   LEFT JOIN articles_content AS article_content on (article.id = article_content.id) \
				   WHERE article.published = 1;
	 sql_query_post_index = UPDATE articles_sphinx set ts = (select max (modyfied_at) from articles)
	 sql_attr_timestamp = published_at
	 sql_attr_uint = idt
	 sql_attr_uint = deleted
	 sql_attr_multi = uint tags from query;  SELECT id, tag_id FROM articles_tags order by `order` asc
	 sql_ranged_throttle = 0
 }

 source articles_delta: articles
 {
	 sql_query = SELECT article.id, article.id AS idt, article.header, article.anounce, article_content.content, article.published_at, 0 AS deleted, \
					 (SELECT concat (concat ('_ tag', replace (group_concat (tags_names.tree_id), ',', '_tag'), ''), replace (group_concat (tags_names.name), ',', '')) \
					 FROM tags_names AS tags_names \
					 JOIN articles_tags AS articles_tags ON (tags_names.tree_id = articles_tags.tag_id) \
					 WHERE articles_tags.id = article.id \
					 ) AS `tags_names` \
				   FROM articles AS article \
				   LEFT JOIN articles_content AS article_content on (article.id = article_content.id) \
				   WHERE article.published = 1 AND modyfied_at&gt; (SELECT ts FROM articles_sphinx limit 1)

	 sql_query_post_index = select 1; 

	 sql_attr_multi = uint tags from query;  SELECT id, tag_id FROM articles_tags \
							 WHERE id&gt; = (SELECT min (id) FROM articles WHERE modyfied_at&gt; (SELECT ts FROM articles_sphinx limit 1)) \
							 AND id &lt;= (SELECT max (id) FROM articles WHERE modyfied_at&gt; (SELECT ts FROM articles_sphinx limit 1))
 }

 index articles_index
 {
	 source = articles
	 path = / usr / local / sphinx / var / data / articles
	 docinfo = extern
	 mlock = 0
	 morphology = stem_enru
	 min_word_len = 1
	 charset_type = utf-8
	 html_strip = 1
 }

 index articles_index_delta: articles_index
 {
	 source = articles_delta
	 path = / usr / local / sphinx / var / data / articles_delta
 } </pre><br><br><h4>  Some lines of the Sphinx config with comments </h4><br><pre>  source articles
 {	
	 sql_query_post_index = UPDATE articles_sphinx set ts = (select max (modyfied_at) from articles)
 } </pre><br>  Every time after full indexation of articles, we set the time in the articles_sphix table as the maximum time for modifying articles - this is our time. <br>  used in source articles_delta in order to index only the materials that have changed since the last full indexation. <br><br><pre>  source articles
 {	
	 sql_attr_multi = uint tags from query;  SELECT id, tag_id FROM articles_tags order by `order` asc
 } </pre><br>  This is just a multi-value attribute - in fact, for each article we get a field with a list of ID tags by ID values, we can filter the search results. <br><br>  Part of the main query from both sources: <br><pre>  (SELECT concat (concat ('_ tag', replace (group_concat (tags_names.tree_id), ',', '_tag'), ''), replace (group_concat (tags_names.name), ',', '')) \
  FROM tags_names AS tags_names \
  JOIN articles_tags AS articles_tags ON (tags_names.tree_id = articles_tags.tag_id) \
  WHERE articles_tags.id = article.id \
 ) AS `tags_names` </pre><br>  This query for each article collects a string of the form: "_tag1020 _tag1342 _tag1243 Russia France" - this line contains the submission of tags in natural language and in the form of _tagN lines, where N is the tag tag.  As you already understood, tags in the index are presented in three forms: in the form of a multi-value attribute, in the form of strings "_tag1020" and in natural language, just below the text it is told why this is done. <br><br><pre>  source articles_delta: articles
 {
	 sql_query_post_index = select 1; 
 } </pre><br>  Everything is simple here - we need to block the request from the source from which we inherit. <br><br><h4>  Why we send to Sphinx tags in three forms: </h4>  <b>In the attributes:</b> <ol><li> Multi-value tag list field for implementing samples by one or multiple tags with AND and OR conditions if there is an additional search string.  An example can be found <a href="http://www.coloribus.com/paedia/reels/usa,tv-spot/%3Fq%3Dapple">here</a> .  This example using the condition I. <i>Multi-value attribute cannot be used to search for similar materials, since it returns weight = 1 for all materials - that is, we cannot determine relevance, but we need to sort by it.</i> </li></ol>  <b>In full-text index:</b> <ol><li>  The presentation of the tag in natural languages, that is, all the submission of the tag: "Russia Russia Russia" for full-text search is added to the indexed text. </li><li>  The string value in the form of "_tagN", where N is the tag id, for searching similar materials - this method partially covers the Multi-value fields, but is not suitable for tag samples by the condition OR if there is an additional search substring, since lines are already used by those _tagN. </li></ol><br><br><h4>  Indexing </h4><br>  '/ usr / local / sphinx / bin / indexer articles_index_delta - rotate' - this is run every time you save an article <br>  '/ usr / local / sphinx / bin / indexer articles_index --rotate' - and this is run on cron at night, or several times a day - as convenient. <br><br><h4>  Sample by one or more tags </h4>  <b>When selecting materials by tags, there are two tasks:</b> <br><ol><li>  Condition I: Select all materials for a specific tag / tag so that all requested tags are in the material </li><li>  Condition OR: Select all materials for a specific tag / tag so that at least one of the requested tags is in the material </li></ol>  With the use of the Sphinx, this is solved quite simply. <br>  <b>AND and OR conditions using filters</b> <br>  <b>AND:</b> <br><pre>  $ tags_ids = array (1,2,3,4,5,6);
 foreach ($ tags_ids as $ tag_id) {
	 // Adds new filters in each iteration, in each filter 
	 // one tag each - as a result we get the condition AND
	 $ sphinx_obj-&gt; SetFilter ('tags', array ($ tag_id)); 
 }
 $ search_res = $ sphinx_obj-&gt; Query ('', 'articles_index articles_index_delta'); </pre><br><br>  <b>OR:</b> <br><pre>  $ tags_ids = array (1,2,3,4,5,6);
 $ sphinx_obj-&gt; SetFilter ('tags', $ tags_ids); 
 $ search_res = $ sphinx_obj-&gt; Query ('', 'articles_index articles_index_delta'); </pre>  As you can see, the only difference is that in the first case we will get several filters, each of which must correspond to the desired material, and in the second case we will get one filter.  Quote from the Sphinx documentation: "SetFilter ($ attribute, $ values, $ exclude = false) If you are not logged exclude is true). ‚Äù- fully reveals the essence of the approach. <br><br>  <b>AND and OR conditions without using filters (works faster than filters)</b> <br>  <b>AND:</b> <br>  To do this, all the IDs of the required tags should be brought to their pseudo-strings. <br><pre>  $ tags_query_string = '_tag1 _tag2 _tag3';
 $ sphinx_obj-&gt; SetMatchMode (SPH_MATCH_ALL);
 $ search_res = $ sphinx_obj-&gt; Query ($ tags_query_string, 'articles_index articles_index_delta'); </pre><br><br>  <b>OR:</b> <br>  From the previous example, you need to replace SPH_MATCH_ALL with SPH_MATCH_ANY <br><br><h4>  A selection of similar materials </h4>  In our case, the similarity of materials is determined by the similarity of their tags. <br><pre>  // we throw out the current material from the sample
 $ sphinx_obj-&gt; SetFilter ('idt', array ($ current_article_id), true); 
 $ sphinx_obj-&gt; SetMatchMode (SPH_MATCH_ANY);
 // sort by weight and by publication date so that it is fresh on top
 $ sphinx_obj-&gt; SetSortMode (SPH_SORT_EXTENDED, '@weight DESC, published_at DESC'); 
 $ search_res = $ sphinx_obj-&gt; Query ('_ tag1 _tag2 _tag3 _tag4', 'articles_index articles_index_delta'); </pre><br><br><h4>  Full text search </h4>  It's simple <br><pre>  $ sphinx_obj-&gt; SetRankingMode (SPH_RANK_PROXIMITY_BM25);
 $ sphinx_obj-&gt; SetMatchMode (SPH_MATCH_ALL);
 $ sphinx_obj-&gt; Query ('I want an elephant', 'articles_index articles_index_delta'); </pre><br><br><h4>  Results </h4>  The scheme described in this article has been working stably on adme.ru for quite a long time under the following conditions: <br>  Tags: 87 402 pieces. <br>  Articles: 22,069, Tagging: 132,935. <br>  Images: 103 353, Tagging: 751 950. <br>  Video: 68 316, Tagging: 682 415. <br>  Of course, the given code and the structure of the tables are considerably simplified for clarity, but nevertheless can be used in real projects. <br><br><h5>  btw </h5>  In the sphinx config, there is a searchd section, in which, with a large number of returned results, it is recommended to tweak the max_matches parameter.  We have it worth 20,000, as the materials on the usa tag are more than 15,000, but this is not in the articles, but in the encyclopedia of advertising.  By default, this parameter is 1000. <br><br>  Questions, advice, criticism - all welcome. </div><p>Source: <a href="https://habr.com/ru/post/40443/">https://habr.com/ru/post/40443/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../40434/index.html">By or through</a></li>
<li><a href="../40435/index.html">Samsung NC10 - Samsung's netbook with anti-bacterial keyboard</a></li>
<li><a href="../40436/index.html">SVG animation in new build of WebKit</a></li>
<li><a href="../404381/index.html">3D video do it yourself</a></li>
<li><a href="../404423/index.html">Can we understand aliens?</a></li>
<li><a href="../40444/index.html">Install GWT</a></li>
<li><a href="../40446/index.html">Load function for own framework</a></li>
<li><a href="../404463/index.html">Star nebulae, galactic clusters and exoplanets: Friday selection of space video</a></li>
<li><a href="../40447/index.html">Camera blogger</a></li>
<li><a href="../404477/index.html">2017 IKEA LED Light Bulbs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>