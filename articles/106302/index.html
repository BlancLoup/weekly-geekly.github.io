<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Building SIFT descriptors and image matching task</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Small introduction 
 Let's begin with those cases when the problem of image matching is solved at all. I can list the following: creating panoramas, c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Building SIFT descriptors and image matching task</h1><div class="post__text post__text-html js-mediator-article"> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/23/f6/23f6415ffa944a746f04ecbf3d165cf4.png"></a> <br><a name="habracut"></a><br><h4>  Small introduction </h4><br>  Let's begin with those cases when the problem of image matching is solved at all.  I can list the following: creating panoramas, creating a stereo pair and reconstructing a three-dimensional model of an object from its two-dimensional projections in principle, recognizing objects and searching on a sample from some base, tracking the movement of an object through several images, reconstructing affine transformations of images.  Perhaps I missed some use in this list or this application has not yet been invented, but, probably, it is already possible to get an idea of ‚Äã‚Äãwhat range of tasks the use of descriptors is intended to solve.  It should be noted that the area of ‚Äã‚Äãknowledge that considers such tasks (computer vision) is quite young, with all the ensuing consequences.  There is no specific universal method that solves all the problems listed above in full, i.e.  for all input images.  However, not everything is so bad, you just need to know that there are methods for solving various kinds of narrower tasks, and understand that a lot in choosing the method of solving a problem depends directly on the type of the problem itself, the type of objects and the nature of the scene where they are depicted personal preference. <br><br>  Also, before reading, it will not be superfluous to look at the article on the <a href="http://habrahabr.ru/blogs/algorithm/103107/">SURF</a> method diagonally. <br><br><h4>  General thoughts </h4><br>  A person can compare images and allocate objects to them visually, on an intuitive level.  However, for a machine, an image is just a dummy data set.  In general terms, two approaches can be described in order to somehow ‚Äúendow‚Äù a machine with this human skill. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are certain methods for comparing images based on a comparison of knowledge about images in general.  In the general case, it looks like this: for each image point, the value of a certain function is calculated, on the basis of these values ‚Äã‚Äãa certain characteristic can be attributed to the image, then the task of comparing images is reduced to the problem of comparing such characteristics.  By and large, these methods are as bad as they are simple, and work reasonably, practically, only in ideal situations.  There are plenty of reasons for this: the appearance of new objects in an image, the overlapping of some objects by others, noise, changes in scale, position of an object in an image, camera position in three-dimensional space, lighting, affine transformations, etc.  Actually, the poor qualities of these methods are due to their main idea, i.e.  so that <b>each</b> point of the image contributes to the characteristic, no matter how bad this contribution is. <br><br>  The last phrase immediately suggests the idea of ‚Äã‚Äãavoiding such problems: it is necessary or somehow to choose points that contribute to the characteristic, or, even better, to single out some special (key) points and compare them.  This is where we come to the idea of ‚Äã‚Äãmatching images at key points.  We can say that we replace the image with some model - a set of its key points.  Immediately, we note that a particular point of the depicted object will be called, which with a high degree of probability will be found on another image of the same object.  The detector will be called the method of extracting key points from the image.  The detector should ensure the invariance of finding the same singular points with respect to image transformations. <br><br>  The only thing that remains unclear is how to determine which key point of one image corresponds to the key point of another image.  Indeed, after applying the detector, it is possible to determine only the coordinates of the singular points, and they are different on each image.  This is where the descriptors come in.  Descriptor - identifier of the key point, distinguishing it from the rest of the mass of singular points.  In turn, descriptors should ensure the invariance of finding a correspondence between specific points with respect to image transformations. <br><br>  The result is the following scheme for solving the image matching problem: <br>  1. On the images are highlighted key points and their descriptors. <br>  2. By coincidence of descriptors, key points corresponding to each other are highlighted. <br>  3. Based on a set of matched key points, an image transformation model is built, with which you can get another from one image. <br><br>  At each stage there are problems and different methods of solving them, which introduces a certain arbitrariness in the solution of the original problem.  Next, we will consider the first part of the solution, namely the selection of singular points and their descriptors using the SIFT (Scale Invariant Feature Transform) method.  The algorithm of the SIFT method will be mainly described, and not why this algorithm works, and it looks like that. <br><br>  Lastly, we list some transformations for which we would like to obtain invariance: <br>  1) offset <br>  2) turn <br>  3) scale (the same object can be of different sizes on different images) <br>  4) changes in brightness <br>  5) camera position changes <br><br>  Invariance with respect to the last three transformations cannot be fully achieved, but at least partially it would not be bad to do it. <br><br><h4>  Finding special points </h4><br>  The main point in the detection of singular points is the construction of a pyramid of Gaussians (Gaussian) and differences of Gaussians (Difference of Gaussian, DoG).  A Gaussian (or an image blurred by a Gaussian filter) is an image. <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/b0/ad/b0ade808a50d9b0857fb5b2cf3525aa8.png"></a> <br>  <i>Here L is the value of the Gaussian at the point (x, y), and sigma is the blur radius.</i>  <i>G is a Gaussian core, I is the value of the original image, * is a convolution operation.</i> <br><br>  The difference between gaussians is an image obtained by pixel-by-pixel subtraction of a single gaussin of the original image from a gaussian with a different radius. <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/b8/f9/b8f91eacbbd6f1280f43059bb7633184.png"></a> <br><br>  In a nutshell, let's talk about scalable spaces.  Scalable image space is a set of various versions of the original image, smoothed by some filter.  It is proved that the Gaussian scalable space is linear, invariant with respect to shifts, rotations, scale, not displacing local extremes, and has the property of semigroups.  For us it is important that a different degree of image blur by a Gaussian filter can be taken as the original image, taken at a certain scale. <br><br>  In general, scale invariance is achieved by finding the key points for the original image, taken at different scales.  For this, a Gaussian pyramid is built: the entire scalable space is divided into several sections ‚Äî octaves, with a part of the scalable space occupied by the next octave being twice as large as the part occupied by the previous one.  In addition, when moving from one octave to another, the image is resampled, its dimensions are halved.  Naturally, each octave covers an infinite number of Gaussian images, so only a certain number of them N are built, with a certain step along the blur radius.  With the same step, two additional Gaussians are completed (a total of N + 2 is obtained), extending beyond the limits of the octave.  Next, you will see why it is needed.  The scale of the first image of the next octave is equal to the scale of the image from the previous octave number N. <br><br>  In parallel with the construction of the pyramid of Gaussians, a pyramid of differences of Gaussians is constructed, consisting of the differences of neighboring images in the pyramid of Gaussians.  Accordingly, the number of images in this pyramid will be N + 1. <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/60/a0/60a0638879b89bfc5bcc6584ca3ff112.png"></a> <br>  <i>The figure on the left shows the pyramid of Gaussians, and on the right - their differences.</i>  <i>It is schematically shown that each difference is obtained from two neighboring Gaussians, the number of differences is one less than the number of Gaussians; when going to the next octave, the size of the images is halved</i> <br><br>  After building the pyramids, the matter remains small.  We consider a point to be special if it is a local extremum of the difference of Gaussians.  To search for extremums we will use the method shown schematically in the figure. <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/c6/f8/c6f8188b199623b4937bf6a1b66df25c.png"></a> <br>  <i>If the difference between the Gaussians at the point marked with a cross is more (less) than all the values ‚Äã‚Äãat the points marked with circles, then this point is considered an extremum point.</i> <br><br>  In each image from the DoG pyramid, local extremum points are searched.  Each point of the current DoG image is compared with its eight neighbors and with nine neighbors in the DoG that are one level higher and lower in the pyramid.  If this point is more (less) than all the neighbors, then it is taken as a point of local extremum. <br><br>  I think now it should be clear why we needed ‚Äúextra‚Äù images in an octave.  In order to check for the presence of points of the extremum N'e image in the DoG pyramid, you need to have N + 1'e.  And in order to get N + 1'e in the DoG pyramid, you must have N + 1'e and N + 2'e images in the pyramid of Gaussians.  Following the same logic, we can say that we need to build a 0'e image (to check the 1st'go) in the DoG pyramid and two more in the Gauss pyramid.  But remembering that the 1'e image in the current octave has the same scale as the N'e in the previous one (which should already be checked), we can relax a bit and read more :) <br><br><h4>  Specification of singular points </h4><br>  Oddly enough, in the previous paragraph, the search for key points is not over.  The next step will be a couple of tests of the suitability of the extremum point for the key role. <br><br>  The first step is to determine the coordinates of the singular point with sub-pixel accuracy.  This is achieved by approximating the DoG function by a second-order Taylor polynomial taken at the point of the calculated extremum. <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/1e/c7/1ec7e2f4aecaf75ee9a621fe742c6764.png"></a> <br>  <i>Here D is the DoG function, X = (x, y, sigma) is the displacement vector with respect to the decomposition point, the first derivative of DoG is the gradient, the second derivative of DoG is the Hessian matrix.</i> <br><br>  The extremum of the Taylor polynomial is found by calculating the derivative and equating it to zero.  As a result, we obtain the offset of the point of the calculated extremum, relative to the exact <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/c0/c2/c0c2340122423c15cd0cd3e80c2e7987.png"></a> <br><br>  All derivatives are calculated using finite difference formulas.  As a result, we obtain a SLAE of dimension 3x3, relative to the components of the vector X ^. <br><br>  If one of the components of the vector X ^ is greater than 0.5 * grid_path_in_this_direction, then this means that in fact the extremum point was not calculated correctly and you need to move to the neighboring point in the direction of the indicated components.  For the neighboring point, everything repeats.  If in this way we went beyond the octave, then this point should be excluded from consideration. <br><br>  When the position of the extremum point is calculated, the very DoG value at this point is checked by the formula <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/37/be/37bed275eca91b22d405919e01901cf6.png"></a> <br><br>  If this test fails, then the point is excluded, as a point with low contrast. <br><br>  Finally, the last check.  If a particular point lies on the border of an object or is poorly lit, then this point can be excluded from consideration.  These points have a large bend (one of the components of the second derivative) along the boundary and small in the perpendicular direction.  This large bend is determined by the Hessian matrix H. For verification, H size 2x2 is suitable. <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/89/3b/893bdcc5c26d32535b9b1b27f28063b7.png"></a> <br><br>  Let Tr (H) be the trace of a matrix, and Det (H) its determinant. <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/9c/29/9c29814ed394481c582cd69fc8289c52.png"></a> <br><br>  Let r be the ratio of a larger bend to a smaller one, <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/83/de/83de423ffcaf7b5d6b2a82f9e85672d0.png"></a> <br><br>  then <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/54/3d/543d8e41fed6b4fd72fb643a512c7c41.png"></a> <br><br>  and the point is considered further if <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/01/78/01785ec8ecf029bec431e39848d86a9f.png"></a> <br><br><h4>  Finding the orientation of the key point </h4><br>  After we have verified that a point is key, we need to calculate its orientation.  As will be seen later, a point may have several directions. <br><br>  The direction of the key point is calculated from the directions of the gradients of the points adjacent to the singular.  All gradient calculations are performed on the image in the pyramid of Gaussians, with a scale closest to the scale of the key point.  For reference: the magnitude and direction of the gradient at the point (x, y) are calculated by the formulas <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/6f/1d/6f1d94782e376000e3e474953c59c6d7.png"></a> <br>  <i>m is the magnitude of the gradient, theta is its direction</i> <br><br>  First, we define the window (neighborhood) of the key point, in which gradients will be considered.  In essence, this will be the window required for convolution with a Gaussian core, and it will be round and the blur radius for this kernel (sigma) is 1.5 * key-point scale.  For the Gaussian core, the so-called "three sigma" rule applies.  It consists in the fact that the value of the Gaussian core is very close to zero at a distance greater than 3 * sigma.  Thus, the radius of the window is defined as [3 * sigma]. <br><br>  The direction of the key point is found from the histogram of the O directions. The histogram consists of 36 components that evenly cover a gap of 360 degrees, and it is formed as follows: each point of the window (x, y) contributes equal to m * G (x, y, sigma ), into that component of the histogram that covers the gap containing the direction of the gradient theta (x, y). <br><br>  The direction of the key point lies in the gap covered by the maximum component of the histogram.  The values ‚Äã‚Äãof the maximum component (max) and its two adjacent ones are interpolated by a parabola, and the maximum point of this parabola is taken as the direction of the key point.  If there are more components in the histogram with values ‚Äã‚Äãnot less than 0.8 * max, then they are similarly interpolated and additional directions are assigned to a key point. <br><br><h4>  Building descriptors </h4><br>  We now turn directly to the descriptors.  This earlier definition says what the descriptor should do, but not what it is.  In principle, any object can act as a descriptor (as long as it copes with its functions), but usually the descriptor is some information about the neighborhood of the key point.  This choice was made for several reasons: small areas are less affected by distortion effects, some changes (changing the position of an object in the picture, changing the scene, overlapping one object with another, turning) may not affect the descriptor at all. <br><br>  In the SIFT method, the descriptor is a vector.  Like the direction of the key point, the descriptor is computed on a Gaussian closest in scale to the key point, and based on the gradients in a certain key point window.  Before calculating the descriptor, this window is rotated by the angle of the direction of the key point, which is how invariance with respect to rotation is achieved.  To start, look at the picture. <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/fe/6b/fe6b57079b5e7a2f195173ad982ecccc.png"></a> <br><br>  Here is a schematic representation of a part of the image (left) and (right) a handle derived from it.  For a start, look left.  Here you can see the pixels indicated by small squares.  These pixels are taken from the square window of the descriptor, which in turn is divided into four equal parts (we will further call them regions).  A small arrow in the center of each pixel indicates the gradient of that pixel.  Interestingly, the center of this window is between the pixels.  It should be chosen as close as possible to the exact coordinates of the key point.  The last detail that can be seen is a circle denoting a convolution window with a Gaussian core (similar to the window for calculating the direction of the key point).  For this kernel, a sigma is determined equal to half the width of the descriptor window.  In the future, the value of each point in the descriptor window will be multiplied by the value of the Gaussian core at this point, as by a weighting factor. <br><br>  Now we look to the right.  Here we can see a schematically depicted descriptor of a singular point, dimension 2x2x8.  The first two digits in the dimension value are the number of regions horizontally and vertically.  Those squares that covered a certain region of pixels on the left of the images, on the right cover histograms built on the pixels of these regions.  Accordingly, the third digit in the dimension of the descriptor means the number of components of the histogram of these regions.  Regional histograms are calculated in the same way as a direction histogram with three small but: <br>  1. Each histogram also covers a 360-degree section, but divides it into 8 parts. <br>  2. The weight of the Gaussian nucleus is taken as the weighting factor, which is common to the entire descriptor (this has already been said) <br>  3. For one more weight coefficients, the coefficients of trilinear interpolation are taken. <br><br>  Three real coordinates (x, y, n) can be assigned to each gradient in the descriptor window, where x is the horizontal distance to the gradient, y is the vertical distance, n is the distance to the gradient direction in the histogram (meaning the corresponding histogram of the descriptor in which this gradient contributes).  The bottom left corner of the descriptor window and the initial value of the histogram are taken as a point of reference.  For single segments, the sizes of the regions are taken horizontally and vertically for x and y, respectively, and the number of degrees in the histogram component for n.  The coefficient of trilinear interpolation is determined for each coordinate (x, y, n) of the gradient as 1-d, where d is equal to the distance from the coordinate of the gradient to the middle of the unit interval in which this coordinate falls.  Each occurrence of a gradient in the histogram is multiplied by all three weights of the trilinear interpolation. <br><br>  The key point descriptor consists of all the histograms obtained.  As already mentioned, the dimension of the descriptor in Figure 32 is components (2x2x8), but in practice descriptors of dimension 128 are used (4x4x8). <br><br>  The resulting descriptor is normalized, after which all its components, whose value is greater than 0.2, are truncated to a value of 0.2, and then the descriptor is normalized again.  In this form, the descriptors are ready to use. <br><br><h4>  The last word and literature </h4><br>  SIFT descriptors are not without flaws.  Not all points obtained and their descriptors will meet the requirements.  Naturally, this will affect the further solution of the image matching problem.  In some cases, a solution may not be found, even if it exists.  For example, when searching for affine transformations (or a fundamental matrix) using two images of a brick wall, a solution may not be found due to the fact that the wall consists of repetitive objects (bricks) that make descriptors of different key points similar to each other.  Despite this fact, these descriptors work well in many practically important cases. <br><br>  Plus, this method is patented. <br><br>  The article describes an approximate scheme of the SIFT algorithm.  If you are interested in why this algorithm is what it is and why it works, as well as justifying the choice of the values ‚Äã‚Äãof some parameters taken in the ‚Äúfrom the ceiling‚Äù article (for example, the number 0.2 in the descriptor normalization), then you should refer to the original source <br>  <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.157.3843%26rep%3Drep1%26type%3Dpdf">David G. Lowe "Distinctive image features from scale-invariant keypoints"</a> <br><br>  Another article, repeating the main content of the previous one.  It highlights some of the details. <br>  <a href="http://www.cs.st-andrews.ac.uk/~yumeng/yumeng-SIFTreport-5.18_bpt.pdf">Yu Meng "Implementing the Scale Invariant Feature Transform (SIFT) Method"</a> </div><p>Source: <a href="https://habr.com/ru/post/106302/">https://habr.com/ru/post/106302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../106293/index.html">The gel will be able to replace the dentist.</a></li>
<li><a href="../106294/index.html">Cast</a></li>
<li><a href="../106296/index.html">Homemade Remote Control for Canon 50d</a></li>
<li><a href="../106298/index.html">Hosting Reality Check Network hacked</a></li>
<li><a href="../106300/index.html">Adobe Flash CS5 + Adobe Flash Builder - Common Projects</a></li>
<li><a href="../106304/index.html">Ajenti 0.4</a></li>
<li><a href="../106305/index.html">Died CC search Yahoo!</a></li>
<li><a href="../106307/index.html">Homemade spacecraft</a></li>
<li><a href="../106308/index.html">Microsoft decided to reduce the price of the Xbox 360</a></li>
<li><a href="../106309/index.html">Eric Schmidt predicts the emergence of new billions of web users</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>