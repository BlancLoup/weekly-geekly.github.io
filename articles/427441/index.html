<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Convergence with Kubernetes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Total standardization 


 I prepared this material for a speech at the conference and asked our technical director what the main thing Kubernetes is f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Convergence with Kubernetes</h1><div class="post__text post__text-html js-mediator-article"><h3 id="totalnaya-standartizaciya">  Total standardization </h3><br><p>  I prepared this material for a speech at the conference and asked our technical director what the main thing Kubernetes is for our organization.  He replied: </p><br><blockquote>  The developers themselves do not understand how much extra work they have done. </blockquote><p>  Apparently, he was inspired by the recently read book <a href="https://www.goodreads.com/book/show/34890015-factfulness">‚ÄúFactfulness‚Äù</a> - it is difficult to notice minor and continuous changes for the better, and we constantly lose sight of our progress. </p><br><p>  But the transition to Kubernetes just can not be called insignificant. </p><br><p><img src="https://habrastorage.org/webt/72/vu/bn/72vubnen7dnspn7tp9wmy2if9cu.png"></p><a name="habracut"></a><br><p>  Nearly 30 of our teams run all or some of the workloads on the clusters.  Approximately 70% of our HTTP traffic is generated in applications on Kubernetes clusters.  This is probably the most extensive technology convergence since I joined the company after the <a href="https://en.wikipedia.org/wiki/USwitch">Forward group bought the uSwitch</a> in 2010 when we switched from .NET and physical servers to AWS and from a monolithic system to <a href="https://martinfowler.com/articles/microservices.html">microservices</a> . </p><br><p>  And everything happened very quickly.  At the end of 2017, all teams used their AWS infrastructure.  They set up load balancers, EC2 instances, ECS cluster updates, and so on.  It took a little over a year, and everything changed. </p><br><p>  We spent a minimum of time on convergence, and as a result, Kubernetes helped us solve pressing problems - our cloud grew, the organization became more complicated, and we hardly entered new people into the teams.  We did not change the organization to use Kubernetes.  On the contrary - we used Kubernetes to change the organization. </p><br><p>  Maybe the developers did not notice the big changes, but the data speak for themselves.  More on this later. </p><br><hr><br><p>  Many years ago I was at a Clojure conference and heard a lecture by Michael Nygard <a href="https://www.infoq.com/presentations/Architecture-Without-an-End-State">on architecture that cannot be brought to a final state</a> .  He opened my eyes.  A neat and orderly system looks caricature when it compares the TV shops with kitchen goods and large-scale software architecture - the existing system looks like a dull knife, and some kind of porridge comes out instead of even slices.  Without a new knife, there‚Äôs nothing to think about salad. </p><br><p>  This is about how organizations adore three-year projects: the first year is development and preparation, the second year is implementation, the third is return.  In the lecture, he says that such projects are usually done continuously and rarely get to the end of the second year (often due to another company's acquisition and changes in direction and strategy), so the usual architecture is </p><br><blockquote>  layering of change in some kind of stability. </blockquote><p>  And uSwitch is a great example. </p><br><p>  We switched to AWS for many reasons - our system could not cope with peak loads, and the development of the organization was hampered by a too rigid system and closely related teams that were formed for specific projects and were divided by specialization. </p><br><p>  We were not going to drop everything, move all systems and start over.  We created new services with proxying through the existing load balancer and <a href="https://www.martinfowler.com/bliki/StranglerApplication.html">gradually choked the old</a> application.  We wanted to immediately show a return and in the very first week we conducted A / B testing of the first version of the new service in production.  As a result, we took long-term products and began to form teams for them under developers, designers, analysts, etc. And we immediately saw the result.  In 2010, it seemed a real revolution. </p><br><p>  Year after year we added new commands, services and applications and gradually ‚Äúchoked‚Äù the monolithic system.  The teams progressed quickly - now they worked independently of each other and consisted of specialists in all the necessary fields.  We have minimized the interaction of teams for product release.  We have selected a few commands only for the configuration of the load balancer. </p><br><p>  The teams themselves chose development methods, tools and languages.  We set a task for them, and they themselves found a solution, because they understood the question best of all.  With AWS, these changes have become easier. </p><br><p>  We intuitively followed the principles of programming - teams that are loosely connected with each other will communicate less often and we will not have to spend precious resources to coordinate their work.  All this is great described in the recently published <a href="https://itrevolution.com/book/accelerate/">book "Accelerate"</a> . </p><br><p>  As a result, as Michael Nigard described, we got a system from many layers of changes - some systems were automated with Puppet, some with Terraform, somewhere we used ECS, somewhere - EC2. </p><br><p>  In 2012, <a href="https://skillsmatter.com/skillscasts/3623-keynote-3623">we were proud of our architecture, which could be easily changed to experiment</a> , find successful solutions and develop them. </p><br><p>  But in 2017, we realized that a lot has changed. </p><br><hr><br><p>  Now AWS infrastructure is much more complicated than in 2010. It offers a lot of options and opportunities - but not without consequences.  Today, any team that works with EC2 has to choose VPC, network configuration, and much more. </p><br><p>  We experienced it ourselves - the teams began to complain that they were spending more and more time on infrastructure maintenance, for example, updating instances <a href="https://aws.amazon.com/ru/ecs/">in AWS ECS clusters</a> , EC2 machines, switching from ELB balancers to ALB, etc. </p><br><p>  In mid-2017, at a corporate event, I called on everyone to standardize work in order to improve the overall quality of the systems.  I used the hackneyed iceberg metaphor to show how we create and maintain software: </p><br><p><img src="https://habrastorage.org/webt/sn/ci/pt/sncipt6axzuuqa2pcqxrpbcwzh0.png"></p><br><p>  I said that most of the teams in our company should be engaged in creating services or products and focus on solving problems, application code, platforms and libraries, etc. In that order.  There is a lot of work under water - log integration, increasing observability, secret management, etc. </p><br><p>  At that time, each application development team was engaged in almost the entire iceberg and made all the decisions on its own - choosing a language, development environment, library and metrics tool, operating system, instance type, storage. </p><br><p>  At the base of the pyramid, we had Amazon Web Services infrastructure.  But not all AWS services are the same.  They have <a href="https://martinfowler.com/articles/serverless.html">Backend-as-a-Service (BaaS)</a> , for example, for authentication and data storage.  And there are other, relatively low-level services, such as EC2.  I wanted to study the data and understand that the teams have reason to complain and they really spend more time working with low-level services and make many less important decisions. </p><br><p>  I divided the services into categories, collected all the available statistics using <a href="https://aws.amazon.com/ru/cloudtrail/">CloudTrail</a> , and then used <a href="https://cloud.google.com/bigquery/">BigQuery</a> , <a href="https://aws.amazon.com/ru/athena/">Athena</a> and <a href="https://ggplot2.tidyverse.org/">ggplot2</a> to see how the situation has changed for developers lately.  Growth for services such as RDS, Redshift, etc., we consider desirable (and expected), and growth for EC2, CloudFormation, etc., on the contrary. </p><br><p><img src="https://habrastorage.org/webt/dd/bd/-f/ddbd-fy5t4wzicbekukgyx_lji0.png"></p><br><p>  Each dot in the diagram shows the 90th (red), 80th (green) and 50th (blue) percentiles for the number of <strong>low-level services</strong> that our people used every week for a certain period.  I added smoothing lines to show the trend. </p><br><p>  And although we were striving for high-level abstractions when deploying software, for example, using containers and <a href="https://aws.amazon.com/ru/ecs/">Amazon ECS</a> , our developers regularly used more and more AWS services and didn‚Äôt abstract from the complexities of system management.  In two years, the number of services doubled for 50% of employees and almost tripled for 20%. </p><br><p>  This limited the growth of our company.  Teams sought autonomy, but how could they hire new people?  We needed strong application and product developers and knowledge of AWS‚Äôs increasingly complex system. </p><br><hr><br><p>  We wanted to expand the team and at the same time preserve the principles with which success was achieved: autonomy, minimal coordination and self-sustained infrastructure. </p><br><p>  With Kubernetes, we achieved this goal through abstractions with a focus on applications and the ability to maintain and tune clusters for minimal command coordination. </p><br><h3 id="abstrakcii-s-fokusom-na-prilozheniya">  Abstractions with a focus on applications </h3><br><p>  Kubernetes concepts can be easily compared with the language used by the application developer.  Suppose you manage application versions as a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">deployment</a> .  You can run multiple replicas for the <a href="https://kubernetes.io/docs/concepts/services-networking/service/">service</a> and map them to HTTP via <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Ingress</a> .  And through <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">user resources,</a> you can expand and specialize this language, depending on what you need. </p><br><p>  Teams work more productively with these abstractions.  In principle, this example has everything you need to deploy and run a web application.  The rest is handled by Kubernetes. </p><br><p> In the picture with the iceberg, these concepts are at the water level and connect the developer‚Äôs tasks from above to the platform below.  The cluster management team can make low-level and insignificant decisions (on managing metrics, logging, etc.) and at the same time speak the same language with the developers above water. </p><br><p>  In 2010, uSwitch had traditional teams to maintain a monolithic system, and most recently we had an IT department that partially managed our AWS account.  It seems to me that the lack of common concepts seriously interfered with the work of this team. </p><br><p>  Try saying something useful if you have only EC2 copies, load balancers and subnets in your vocabulary.  Describing the essence of the application was difficult or even impossible.  This could be a Debian package, deployment via Capistrano, and so on.  We could not describe the application in a common language for all. </p><br><p>  In the early 2000s, I worked in London ThoughtWorks.  At the interview, I was advised to read Eric Evans <a href="https://www.amazon.co.uk/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">' Problem-Oriented Design</a> .  I bought a book on the way home and started reading more on the train.  Since then, I remember about it in almost every project and system. </p><br><p>  One of the main concepts of the book is a <a href="https://martinfowler.com/bliki/UbiquitousLanguage.html">single language</a> in which different teams communicate.  Kubernetes provides such a common language for developers and infrastructure maintenance teams, and this is one of its main advantages.  Plus, it can be expanded and supplemented with other subject areas and business areas. </p><br><p>  In a common language, communication is more productive, but we still need to limit the interaction between the teams as much as possible. </p><br><h3 id="neobhodimyy-minimum-vzaimodeystviya">  Necessary minimum of interaction </h3><br><p>  The authors of the book <a href="https://www.amazon.co.uk/Accelerate-Software-Performing-Technology-Organizations/dp/1942788339/ref%3Dsr_1_1%3Fie%3DUTF8%26qid%3D1528883733%26sr%3D8-1%26keywords%3Daccelerate">‚ÄúAccelerate‚Äù</a> highlight the characteristics of a loosely coupled architecture with which IT teams work more efficiently: </p><br><blockquote>  In 2017, the success of continuous delivery depended on whether the team: <br>  Seriously change the structure of its system without the permission of the leadership. <br>  Seriously change the structure of your system, not waiting for other teams to change their own, and not creating a lot of extra work for other teams. <br>  Perform their tasks without communicating and coordinating their work with other teams. <br>  Deploy and release a product or service on demand, regardless of other services associated with it. <br>  Make most of the tests on demand, without an integrated test environment. </blockquote><p>  We needed centralized software multi-tenant clusters for all teams, but at the same time we wanted to preserve these characteristics.  We have not yet reached the ideal, but we try our best: </p><br><ul><li>  We have several working clusters, and the teams themselves choose where to run the application.  We do not use <a href="https://kubernetes.io/docs/concepts/cluster-administration/federation/">federation</a> yet (we are waiting for AWS support), but we have <a href="https://www.envoyproxy.io/">Envoy</a> for load balancing on <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">Ingress</a> balancers in different clusters.  We automate most of these tasks using a continuous delivery pipeline (we have a <a href="https://drone.io/">Drone</a> ) and other AWS services. </li><li>  All clusters have the same <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/">namespace</a> .  About one for each team. </li><li>  Access to <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/">namespaces</a> is controlled through <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">RBAC</a> (role-based access control).  For authentication and authorization, we use a corporate identity in Active Directory. </li><li>  <a href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler">Clusters are scaled automatically</a> , and we are doing everything possible to optimize the node startup time.  It still takes a couple of minutes, but, in general, even with large workloads, we do without coordination. </li><li>  Applications are scaled automatically based on application-level metrics from Prometheus.  The development teams control the automatic scaling of their application by query metrics per second, operations per second, etc. Thanks to the cluster autoscaling, the system prepares nodes when demand exceeds the capabilities of the current cluster. </li><li>  We wrote a command line tool in Go called <strong>u</strong> , which standardizes command authentication in Kubernetes, use of <a href="https://www.vaultproject.io/">Vault</a> , requests for AWS temporary credentials, and so on. </li></ul><br><p><img src="https://habrastorage.org/webt/oy/qv/bm/oyqvbm7x1orfe2kpjxubpis6r60.png"></p><br><p>  I'm not sure that we have more autonomy with Kubernetes, but it definitely remained at a high level, and at the same time we got rid of some problems. </p><br><hr><br><p>  The transition to Kubernetes was quick.  The diagram shows the total number <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/">of namespaces</a> (roughly equal to the number of teams) in our work clusters.  The first appeared in February 2017. </p><br><p><img src="https://habrastorage.org/webt/ux/y_/q_/uxy_q_hravmwkjhead1bgzkspz4.png"></p><br><p>  We had reasons to rush - we wanted to save small teams focused on their product from worries about the infrastructure. </p><br><p>  The first team agreed to switch to Kubernetes when the place on their application server ran out due to incorrect logrotate settings.  The transition took only a few days, and they took up the business again. </p><br><p>  Recently, teams are switching to Kubetnetes for the sake of improved tools.  Kubernetes clusters make it easy to integrate with our secret management system ( <a href="https://www.vaultproject.io/">Hashicorp Vault</a> ), distributed tracing ( <a href="https://cloud.google.com/trace/">Google Cloud Trace</a> ) and similar tools.  <em>All</em> our teams get even more efficient features. </p><br><hr><br><p>  I have already shown a chart with percentiles of the number of services that our employees used every week from the end of 2014 to 2017.  But the continuation of this chart to date. </p><br><p><img src="https://habrastorage.org/webt/o7/fa/mu/o7famum8vaa0uuuw5e2ynah0-ay.png"></p><br><p>  We have made progress in managing the complex structure of AWS.  I am glad that now half of the employees are doing the same as in early 2015.  In a cloud computing team, we have 4‚Äì6 employees, about 10% of the total number ‚Äî it‚Äôs not surprising that the 90th percentile almost did not budge.  But I hope for progress here. </p><br><p>  Finally, I will talk about how our development cycle has changed, and again recall the recently read Accelerate book. </p><br><p>  The book mentions two indicators of lean development: lead time and package size.  The lead time is calculated from the request to the delivery of the finished solution.  Package size is the amount of work.  The smaller the package size, the more efficient the work: </p><br><blockquote>  The smaller the package, the shorter the production cycle, the less variability of processes, less risks, costs and costs, we get feedback faster, work more efficiently, we have more motivation, we try to finish faster and less often we postpone the change. </blockquote><p>  The book proposes to measure the size of packages by the frequency of deployment - the more often the deployment, the smaller the packages. </p><br><p>  We have data for <em>some</em> deployments.  The data is not entirely accurate - some teams send releases directly to the main branch of the repository, some use other mechanisms.  This does not include all applications, but data for 12 months can be considered indicative. </p><br><p><img src="https://habrastorage.org/webt/dt/vt/53/dtvt53s-2o7-w9rs-7qx6dhnydc.png"></p><br><p>  The failure of the thirtieth week is Christmas.  For the rest, we see that the deployment frequency increases, which means the packet size decreases.  From March to May 2018, the frequency of issues has almost doubled, and lately, we sometimes do more than a hundred issues a day. </p><br><p>  Going to Kubernetes is only part of our strategy for standardizing, automating, and improving tools.  Most likely, all these factors influenced the frequency of issues. </p><br><p>  Back in Accelerate, there is a link between the frequency of deployments and the number of employees and how fast a company can work if the staff is increased.  The authors emphasize the limitations of the associated architecture and commands: </p><br><blockquote>  Traditionally it is believed that expanding a team increases overall productivity, but decreases individual developer productivity. </blockquote><p>  If we take the same data on the frequency of deployments and make a diagram of the dependence on the number of users, it is clear that we can increase the frequency of releases, even if we have more people. </p><br><p><img src="https://habrastorage.org/webt/xc/ti/xf/xctixfjqbqgkbdooamerhtg3d_e.png"></p><br><p>  At the beginning of the article, I mentioned the book <a href="https://www.amazon.co.uk/dp/B0769XK7D6/ref%3Ddp-kindle-redirect%3F_encoding%3DUTF8%26btkr%3D1">"Factfulness"</a> (which inspired our technical director).  The transition to Kubernetes has become for our developers the most significant and rapid convergence of technology.  We are moving in small steps, and it's easy not to notice how things have changed for the better.  It is good that we have data, and they show that we have achieved the desired - our people are engaged in their product and make important decisions in their own field. </p><br><p>  Previously, we have been so good.  We had microservices, AWS, well-established product teams, developers responsible for their production services, loosely coupled teams and architecture.  I talked about this in the report <a href="https://skillsmatter.com/skillscasts/3623-keynote-3623">"Our Age of Enlightenment"</a> ("Our Age of Enlightenment") at a conference in 2012.  But there is no limit to perfection. </p><br><p>  At the end I want to quote another book - <a href="https://www.amazon.co.uk/dp/B010P7Z8J0/ref%3Ddp-kindle-redirect%3F_encoding%3DUTF8%26btkr%3D1">Scale</a> .  I started it recently, and there is an interesting fragment about energy consumption in complex systems: </p><br><blockquote>  To maintain order and structure in a developing system, a constant flow of energy is needed, and it creates confusion.  Therefore, to maintain life, we must eat all the time to defeat the inevitable entropy. <br>  We are fighting entropy, supplying more energy for growth, innovation, maintenance and repair, which is becoming more difficult as the system ages, and this battle lies at the heart of any serious discussion about aging, mortality, sustainability and self-sufficiency of any systems, whether it is a living organism. , company or society. </blockquote><p>  I think you can add IT systems here.  I hope our last efforts will keep entropy for a little while. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/427441/">https://habr.com/ru/post/427441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427431/index.html">How Android works, part 4</a></li>
<li><a href="../427433/index.html">Balancing traffic in the operator‚Äôs IP networks</a></li>
<li><a href="../427435/index.html">STM32H7 - setting clocking without HAL</a></li>
<li><a href="../427437/index.html">Configuring linked servers: ms sql server and teradata</a></li>
<li><a href="../427439/index.html">The whole truth about the RTOS. Article # 16. Signals</a></li>
<li><a href="../427443/index.html">Vivisection success</a></li>
<li><a href="../427447/index.html">GNU Arm Embedded Toolchain appeared in PVS-Studio</a></li>
<li><a href="../427449/index.html">How to understand Tensorflow and not die, but even teach a car something</a></li>
<li><a href="../427451/index.html">Connect phpStorm tasks to Bitrix24</a></li>
<li><a href="../427453/index.html">How I did the transfer of sound on the Raspberry Pi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>