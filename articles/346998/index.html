<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Javascript and horror mutations</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mutation is a change. Change the shape or change the essence. What is subject to mutations may vary. In order to better understand the nature of the m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Javascript and horror mutations</h1><div class="post__text post__text-html js-mediator-article">  Mutation is a change.  Change the shape or change the essence.  What is subject to mutations may vary.  In order to better understand the nature of the mutation - think about the heroes of the film "X-Men".  They could suddenly get tremendous opportunities.  However, the problem is that it is not known exactly when these opportunities will manifest.  Imagine that your comrade for no apparent reason turned blue and overgrown with wool.  Scary, right?  There are the same problems in JavaScript.  If your code is subject to mutations, it means that you can, quite unexpectedly, change something and break it. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/346998/"><img src="https://habrastorage.org/getpro/habr/post_images/fcd/043/606/fcd0436061c48aeaa2ca04a813a0784a.jpg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Objects in javascript and mutation</font> </h2><br>  You can add properties to JavaScript objects.  When this is done after creating an instance of an object, the object changes irreversibly.  He mutates as one of the characters of the X-Men. <br><br>  In the following example, the constant <code>egg</code> , an object, mutates after the <code>isBroken</code> property is added to it.  Such objects (like <code>egg</code> ) we call mutable (that is, having the ability to mutate, change). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs pgsql">const egg = { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Humpty Dumpty" }; egg.isBroken = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; console.log(egg); // { //   <span class="hljs-type"><span class="hljs-type">name</span></span>: "Humpty Dumpty", //   isBroken: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> // }</code> </pre> <br>  Mutations are quite common in JavaScript.  You can literally run into them anytime, anywhere. <br><br><h2>  <font color="#3AC1EF">About the danger of mutations</font> </h2><br>  Suppose you have created a constant named <code>newEgg</code> in which an <code>egg</code> object is written.  Then it was necessary to change the <code>name</code> property of <code>newEgg</code> : <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> egg = { name: <span class="hljs-string"><span class="hljs-string">"Humpty Dumpty"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newEgg = egg; newEgg.name = <span class="hljs-string"><span class="hljs-string">"Errr ... Not Humpty Dumpty"</span></span>;</code> </pre> <br>  When we change <code>newEgg</code> (subject the object to a mutation), the <code>egg</code> changes automatically.  Did you know about this? <br><br><pre> <code class="hljs pgsql">console.log(egg); // { //   <span class="hljs-type"><span class="hljs-type">name</span></span>: "Errr ... Not Humpty Dumpty" // }</code> </pre> <br>  The above example illustrates the danger of mutations.  It comes down to the fact that when you change something in the code, something that is somewhere else can also change, and you won't know about it.  As a result, errors that are difficult to find and correct. <br><br>  All these oddities are due to the fact that objects in JavaScript are passed by reference. <br><br><h2>  <font color="#3AC1EF">Objects in javascript and links to them</font> </h2><br>  In order to realize the meaning of the statement ‚Äúobjects are passed by reference‚Äù, you first need to understand that each object in JavaScript has a unique identifier.  When you assign an object to a variable, you associate a variable with the identifier of this object (that is, the variable now refers to the object) instead of writing the value of the object to the variable, copying it.  That is why, comparing two different objects, even containing the same values ‚Äã‚Äã(or not containing them at all), we get <code>false</code> . <br><br><pre> <code class="hljs pgsql">console.log({} === {}); // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br>  When, in the example above, the <code>egg</code> constant was assigned to the <code>newEgg</code> constant, a reference to the same object referenced by the <code>egg</code> constant was written to <code>newEgg</code> .  Since <code>egg</code> and <code>newEgg</code> refer to the same object, when <code>newEgg</code> changes, <code>egg</code> changes automatically. <br><br><pre> <code class="hljs pgsql">console.log(egg === newEgg); // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  Unfortunately, in situations similar to the one described, it is usually not necessary that what is written in one variable changes when it affects the other, as this leads to the wrong behavior of the code, which manifests itself when it is least expected.  So, how to prevent object mutations?  Before finding the answer to this question, it would be good to first find out what is immutable in JS, that is, unchanged. <br><br><h2>  <font color="#3AC1EF">Immunable Primitives</font> </h2><br>  In JavaScript, primitives (we are talking about data types <code>String</code> , <code>Number</code> , <code>Boolean</code> , <code>Null</code> , <code>Undefined</code> , and <code>Symbol</code> ) are immutable.  That is, you cannot change the structure of a primitive, you cannot add properties or methods to it.  For example, when you try to add a new property to a primitive, absolutely nothing happens. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> egg = <span class="hljs-string"><span class="hljs-string">"Humpty Dumpty"</span></span>; egg.isBroken = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(egg); <span class="hljs-comment"><span class="hljs-comment">// Humpty Dumpty console.log(egg.isBroken); // undefined</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Keyword const and immunity</font> </h2><br>  Many people think that variables (constants) declared using the <code>const</code> keyword are immutable.  However, it is not. <br><br>  Using the <code>const</code> keyword does not make what is written in a constant immutable.  It only does not allow the constant to assign a new value. <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myName = <span class="hljs-string"><span class="hljs-string">"Zell"</span></span>; myName = <span class="hljs-string"><span class="hljs-string">"Triceratops"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ERROR</span></span></code> </pre> <br>  When, using the keyword <code>const</code> , an object is defined, its internal structure may well be changed.  In the example with the <code>egg</code> object, even though <code>egg</code> is a constant created using the keyword <code>const</code> , this object does not protect against mutation. <br><br><pre> <code class="hljs pgsql">const egg = { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Humpty Dumpty" }; egg.isBroken = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; console.log(egg); // { //   <span class="hljs-type"><span class="hljs-type">name</span></span>: "Humpty Dumpty", //   isBroken: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> // }</code> </pre> <br><h2>  <font color="#3AC1EF">Preventing object mutations</font> </h2><br>  In order to prevent mutations of objects, you can, when working with them, use the <code>Object.assign</code> method, which implements the operation of creating new objects by combining existing objects with assigning their properties to the resulting object. <br><br><h3>  <font color="#3AC1EF">Object Method Object.assign</font> </h3><br>  The <code>Object.assign</code> structure allows <code>Object.assign</code> to combine two objects (or more objects), resulting in a single new object.  You can use it like this: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newObject = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(object1, object2, object3, object4);</code> </pre> <br>  The <code>newObject</code> will contain properties from all objects passed to <code>Object.assign</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> papayaBlender = { <span class="hljs-attr"><span class="hljs-attr">canBlendPapaya</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mangoBlender = { <span class="hljs-attr"><span class="hljs-attr">canBlendMango</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fruitBlender = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(papayaBlender, mangoBlender); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fruitBlender); <span class="hljs-comment"><span class="hljs-comment">// { //   canBlendPapaya: true, //   canBlendMango: true // }</span></span></code> </pre> <br>  If two conflicting properties are found, the property of an object that is located to the right in the argument list of <code>Object.assign</code> overwrites the property of an object that is in the list to the left. <br><br><pre> <code class="hljs ruby">const smallCupWithEar = { <span class="hljs-symbol"><span class="hljs-symbol">volume:</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">hasEar:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; const largeCup = { <span class="hljs-symbol"><span class="hljs-symbol">volume:</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     volume  ,  <span class="hljs-number"><span class="hljs-number">300</span></span>   <span class="hljs-number"><span class="hljs-number">500</span></span> const myIdealCup = Object.assign(smallCupWithEar, largeCup); console.log(myIdealCup); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-symbol"><span class="hljs-symbol">volume:</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-symbol"><span class="hljs-symbol">hasEar:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ }</span></span></code> </pre> <br>  However, be careful!  When you combine two objects with <code>Object.assign</code> , the first object in the argument list is subject to mutations.  Others are not. <br><br><pre> <code class="hljs ruby">console.log(smallCupWithEar); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-symbol"><span class="hljs-symbol">volume:</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-symbol"><span class="hljs-symbol">hasEar:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ } console.log(largeCup); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   volume: 500 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Solving the problem of mutation when using Object.assign</font> </h3><br>  As the first <code>Object.assign</code> object, <code>Object.assign</code> can pass a new object in order to prevent the mutation of existing objects.  However, the first object (empty) is still subject to change, but there is nothing to worry about, since the mutation does not affect anything important. <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smallCupWithEar = { volume: <span class="hljs-number"><span class="hljs-number">300</span></span>, hasEar: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> largeCup = { volume: <span class="hljs-number"><span class="hljs-number">500</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//        const myIdealCup = Object.assign({}, smallCupWithEar, largeCup);</span></span></code> </pre> <br>  New object after performing this operation can be changed as you like.  This will not affect previous objects. <br><br><pre> <code class="hljs ruby">myIdealCup.picture = <span class="hljs-string"><span class="hljs-string">"Mickey Mouse"</span></span>; console.log(myIdealCup); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-symbol"><span class="hljs-symbol">volume:</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-symbol"><span class="hljs-symbol">hasEar:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-symbol"><span class="hljs-symbol">picture:</span></span> <span class="hljs-string"><span class="hljs-string">"Mickey Mouse"</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ smallCupWithEar   console.log(smallCupWithEar); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ { volume: 300, hasEar: true } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ largeCup   console.log(largeCup); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ { volume: 500 }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçObject.assign and links to property objects</font> </h3><br>  Another problem with <code>Object.assign</code> is that it performs a shallow merge of objects - it copies properties directly from one object to another.  At the same time, it also copies references to objects that are properties of the objects being processed. <br><br>  Consider this by example. <br><br>  Suppose you bought a new sound system.  You can control its power, set the volume, bass level and other parameters.  This is what the standard system configuration looks like. <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> defaultSettings = { power: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, soundSettings: {   volume: <span class="hljs-number"><span class="hljs-number">50</span></span>,   bass: <span class="hljs-number"><span class="hljs-number">20</span></span>,   <span class="hljs-comment"><span class="hljs-comment">//   } };</span></span></code> </pre> <br>  Some of your friends love loud music, so you decided to make a preset that is guaranteed to put the whole house on your ears. <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loudPreset = { soundSettings: {   volume: <span class="hljs-number"><span class="hljs-number">100</span></span> } };</code> </pre> <br>  Then you invite your friends to a party.  In order to bring the system to a working state and at the same time use both the standard settings and those where the volume is turned up to the maximum, you try to combine <code>defaultSettings</code> and <code>loudPreset</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> partyPreset = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, defaultSettings, loudPreset);</code> </pre> <br>  However, turning on the music, you realize that the system with <code>partyPreset</code> sounds weird.  The volume is good, but no bass at all.  When you explore <code>partyPreset</code> , you are surprised to find that the bass settings are not here! <br><br><pre> <code class="hljs ruby">console.log(partyPreset); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-symbol"><span class="hljs-symbol">power:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-symbol"><span class="hljs-symbol">soundSettings:</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-symbol"><span class="hljs-symbol">volume:</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/   } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ }</span></span></code> </pre> <br>  This is due to the fact that JavaScript copies the object-property <code>soundSettings</code> by reference.  As with <code>defaultSettings</code> , and <code>loudPreset</code> have a <code>soundSettings</code> object, the object that stands to the right in the <code>Object.assign</code> arguments is copied to the new object. <br><br>  If you change <code>partyPreset</code> , <code>loudPreset</code> mutates accordingly - as evidence that the link to <code>soundSettings</code> from <code>loudPreset</code> was copied to <code>loudPreset</code> . <br><br><pre> <code class="hljs ruby">partyPreset.soundSettings.bass = <span class="hljs-number"><span class="hljs-number">50</span></span>; console.log(loudPreset); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-symbol"><span class="hljs-symbol">soundSettings:</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-symbol"><span class="hljs-symbol">volume:</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-symbol"><span class="hljs-symbol">bass:</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/   } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ }</span></span></code> </pre> <br>  Since <code>Object.assign</code> performs a surface merging of objects, in similar situations, when a new object is a combination of objects containing property objects, something else needs to be used.  What?  For example, the <code>assignment</code> library. <br><br><h3>  <font color="#3AC1EF">‚ñç Library assignment</font> </h3><br>  <a href="">Assignment</a> is a small library created by <a href="https://twitter.com/nzgb">Nicolas Bevacqua</a> from <a href="https://ponyfoo.com/">Pony Foo</a> (a valuable source of information on JS).  It helps to perform deep merge of objects (deep merge) and at the same time not worry about mutations.  Using <code>assignment</code> is the same as working with <code>Object.assign</code> , except that it uses a different method name. <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/       assignment const partyPreset = assignment({}, defaultSettings, loudPreset); console.log(partyPreset); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   power: true, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   soundSettings: { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     volume: 100, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     bass: 20 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ }</span></span></code> </pre> <br>  The library copies the values ‚Äã‚Äãof all objects nested in other objects into a new object, which prevents existing objects from mutation. <br><br>  If you now try to change any property in <code>partyPreset.soundSettings</code> , you will find that <code>loudPreset</code> does not change. <br><br><pre> <code class="hljs ruby">partyPreset.soundSettings.bass = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> loudPreset   console.log(loudPreset); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   soundSettings { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-symbol"><span class="hljs-symbol">volume:</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/   } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ }</span></span></code> </pre> <br>  The <code>assignment</code> library is just one of many tools that allow you to deeply merge objects.  Other libraries, including <a href="https://lodash.com/docs">lodash.assign</a> and <a href="https://www.npmjs.com/package/merge-options">merge-options</a> , can also help you with this.  You can safely choose the one that you like best. <br><br><h2>  <font color="#3AC1EF">Is it always necessary to use deep merge instead of Object.assign?</font> </h2><br>  Since you now know how to protect objects from mutations, you can intelligently use <code>Object.assign</code> .  There is nothing wrong with this standard method if you know how to use it correctly. <br><br>  However, if you need to work with objects that have nested properties, always try to use a deep merge of objects instead of <code>Object.assign</code> . <br><br><h2>  <font color="#3AC1EF">Ensuring the immunity of objects</font> </h2><br>  Although the methods we discussed above can help protect objects from mutations, they do not guarantee the immunity of objects created with their help.  If you make a mistake and use <code>Object.assign</code> when working with an object that has nested object properties, then you may have serious trouble. <br><br>  In order to protect against this, it is necessary to provide a guarantee that the object will not mutate at all.  To do this, you can use a library like <a href="https://facebook.github.io/immutable-js/">ImmutableJS</a> .  This library gives an error when trying to change an object processed with its help. <br><br>  In addition, you can use the <code>Object.freeze</code> method and the <code>deep-freeze</code> library.  These two tools do not produce errors, but do not allow objects to mutate. <br><br><h2>  <font color="#3AC1EF">Object.freeze method and deep-freeze library</font> </h2><br>  The <code>Object.freeze</code> method protects the object's own properties from changes. <br><br><pre> <code class="hljs pgsql">const egg = { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Humpty Dumpty", isBroken: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> }; // ""  egg <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(egg); //          egg.isBroken = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; console.log(egg); // { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Humpty Dumpty", isBroken: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> }</code> </pre> <br>  However, this method will not help if you try to change an object that is a property of a ‚Äúfrozen‚Äù object, like <code>defaultSettings.soundSettings.base</code> . <br><br><pre> <code class="hljs pgsql">const defaultSettings = { power: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, soundSettings: {   volume: <span class="hljs-number"><span class="hljs-number">50</span></span>,   bass: <span class="hljs-number"><span class="hljs-number">20</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(defaultSettings); defaultSettings.soundSettings.bass = <span class="hljs-number"><span class="hljs-number">100</span></span>; //    soundSettings  console.log(defaultSettings); // { //   power: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, //   soundSettings: { //     volume: <span class="hljs-number"><span class="hljs-number">50</span></span>, //     bass: <span class="hljs-number"><span class="hljs-number">100</span></span> //   } // }</code> </pre> <br>  To prevent the mutation of property objects, you can use the <a href="https://www.npmjs.com/package/deep-freeze">deep-freeze</a> library, which recursively calls <code>Object.freeze</code> for all properties of the frozen object, which are objects. <br><br><pre> <code class="hljs pgsql">const defaultSettings = { power: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, soundSettings: {   volume: <span class="hljs-number"><span class="hljs-number">50</span></span>,   bass: <span class="hljs-number"><span class="hljs-number">20</span></span> } }; //  " " (   deep-<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>) deepFreeze(defaultSettings); //      ,      defaultSettings.soundSettings.bass = <span class="hljs-number"><span class="hljs-number">100</span></span>; // soundSettings    console.log(defaultSettings); // { //   power: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, //   soundSettings: { //     volume: <span class="hljs-number"><span class="hljs-number">50</span></span>, //     bass: <span class="hljs-number"><span class="hljs-number">20</span></span> //   } // }</code> </pre> <br><h2>  <font color="#3AC1EF">About rewriting values ‚Äã‚Äãand mutations</font> </h2><br>  Do not confuse the entry in variables and in the properties of objects of new values ‚Äã‚Äãwith a mutation. <br>  When a new value is written to a variable, in fact, it changes what it indicates.  In the following example, the value of the variable <code>a</code> changes from <code>11</code> to <code>100</code> . <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> a = <span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">a</span></span> = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  With mutation, the object itself changes.  The reference to an object written to a variable or constant remains the same. <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> egg = { name: <span class="hljs-string"><span class="hljs-string">"Humpty Dumpty"</span></span> }; egg.isBroken = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Mutations are dangerous because they can disrupt the work of the code, and, to do so completely unnoticed and unpredictable.  Even if you suspect that the cause of the problem is in a mutation, the search for a problem place is also a problem.  Therefore, the best way to protect the code from unpleasant surprises is to ensure, from the moment objects are created, their protection against mutations. <br><br>  In order to protect objects from mutations, you can use libraries like <a href="https://facebook.github.io/immutable-js/">ImmutableJS</a> and <a href="https://github.com/swannodette/mori">Mori.js</a> , or use the standard JS <code>Object.assign</code> and <code>Object.freeze</code> . <br><br>  Note that the <code>Object.assign</code> and <code>Object.freeze</code> can protect only their own object properties from changes.  If you want to protect against mutations and properties that are themselves objects, you will need libraries like <a href="">assignment</a> or <a href="https://www.npmjs.com/package/deep-freeze">deep-freeze</a> . <br><br>  <b>Dear readers!</b>  Have you encountered unexpected errors in JS applications caused by object mutations? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/346998/">https://habr.com/ru/post/346998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346982/index.html">Report from the Moscow CocoaHeads Meetup meeting December 15</a></li>
<li><a href="../346984/index.html">Java conference with English roots. Continuing mega review</a></li>
<li><a href="../346990/index.html">Disable DHT blocking in popular torrent clients</a></li>
<li><a href="../346992/index.html">Super-complete guide to publishing in Microsoft Store</a></li>
<li><a href="../346994/index.html">Conference C ++ Russia 2018</a></li>
<li><a href="../347000/index.html">McSema and decompiling into LLVM source code: is it real?</a></li>
<li><a href="../347002/index.html">Studying MBR and GPT structures</a></li>
<li><a href="../347004/index.html">Ukrainian startups are back from Las Vegas. And so</a></li>
<li><a href="../347008/index.html">Platforms for learning experiments with reinforcement and not only</a></li>
<li><a href="../347014/index.html">Learning to manage Kubernetes securely</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>