<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>From prototype to prototype, from prototype to prototype, from prototype to ... trash</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I wanted to develop a small application - Qtty. The application must be able to take a picture and apply a set of filters to it, and then publish this...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>From prototype to prototype, from prototype to prototype, from prototype to ... trash</h1><div class="post__text post__text-html js-mediator-article">  I wanted to develop a small application - Qtty.  The application must be able to take a picture and apply a set of filters to it, and then publish this very picture as the main photo in the VKontakte profile. <br>  The author will try to do everything through prototypes, as they did in <a href="">223 WWDC 2014 sessions</a> . <br><br><a name="habracut"></a><br><br><h4>  Project Description </h4><br>  Initially, the description looked like this: <br><blockquote>  The application will only work with VC (for now) and allow the user to take photos and immediately upload them to the desired album in the VC, if possible applying some filters. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The main functionality: <br>  <s>1. Display photo album list</s> <s><br></s>  <s>2. Display photos of the selected album</s> <s><br></s>  <s>3. Ability to delete a photo</s> <s><br></s>  <s>4. Ability to delete album</s> <s><br></s>  <s>5. Ability to create an album and specify access rights to it.</s> <br>  6. Make a photo, apply filters, specify the album in which to upload the photo (or make the main profile picture), attach a location, add a description to the photo. <br></blockquote><br><br>  I decided that I want to do something quickly, so I removed most of the functionality and made such an application, which is described in the first paragraph: <br><blockquote>  The application will work only with the VC (for now) and allow the user to take photos and immediately upload them to the VC, possibly applying some filters. <br></blockquote><br><br><h4>  Prototypes  Time. </h4><br>  We make any sketches of screens, offer a variety of ideas and in any way put them on paper. <br>  I started with the login screen.  Without authorization, the application does not make sense to process the photo, so the option of showing the screen to take a picture as a start is excluded.  On the authorization screen there should have been some element like a button, after clicking on which the user would be able to log in to the VC and we could carry out requests on his behalf. <br><br>  What sketches I had: <br><img src="https://habrastorage.org/getpro/habr/post_images/fea/a38/2c5/feaa382c5898e337d10a444317030122.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/fb8/82e/86b/fb882e86b4053771ed67ca3c69abf5cc.jpg"><br><br>  I will explain each of them. <br>  1. The idea was that in front of the user there will be a certain set of photos on which there will be inscriptions (Share impressions with friends, Always be in touch, Share joyful moments, etc.).  Below is the authorization button. <br>  <b>Cons of this option:</b> <br>  We need something to flip through. <br>  Excess work on the selection of pictures of the desired colors, which will be combined with the background color + selection of the font and its color for application to images. <br>  Looks like some kind of user manual. <br>  I just did not like it. <br><br>  2. If in the first version it was not visible which image you are flipping through the account and how many of the total, then this defect has been corrected.  However, the disadvantages remain the same. <br>  3. Picture and button.  It would seem simple, but a lot of questions arise: the color of the background, the color of the picture, their combinations.  Option disappeared. <br>  4. Here, the background is a picture with a lot of user photos, there can be some additional layer in the picture so that many faces do not hurt the eyes and the user does not cause anxiety and nervousness.  The button remains. <br>  This option I liked the most. <br><br>  After all our ideas were transferred from the head to the paper, I began to make sketches of these very screens in real sizes with real elements.  Everything was done in Keynote. <br>  I will show not all the options, but only 2 that I could do.  In the course of implementing the first two options, with flipping, I came to the conclusion that it was too cumbersome for such a small application. <br><br>  The very first preview of the authorization screen: <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/8a3/5b2/fca/8a35b2fca92a62e1d89163aee94cb117.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/58f/c06/61c/58fc0661c888f3be862999398e302466.png"><br><br>  I asked my colleagues at work which of the two options they like best.  All answered first.  The second was not much liked because of some dude and look.  They could not understand the essence of the application, why this particular guy, who he is, etc. <br>  The second option was dropped. <br><br>  After some time, there were more such options: <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/3cc/873/5a9/3cc8735a9f0f5af25c3411b784671907.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/c14/3bd/ca7/c143bdca7faba60b77e97a412bc629f9.png"><br><br>  There was no paper at hand, so the VC display screen in UIWebView for authorization was thrown right into Keynote.  Options that turned out: <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/45e/801/7ab/45e8017ab0bb3cc70ae2d879455008be.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/9b6/cae/f52/9b6caef52cc57f518778bbd6328fa4c0.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/3bd/6ad/8ab/3bd6ad8ab1d33b15af729e6cbc4db081.png"><br><br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/084/270/8eb/0842708ebea017516630467f3365dac1.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/ede/a98/0e6/edea980e6882b59e777f9e45a5ba402c.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/4db/11f/845/4db11f8459a47deb791102408a1476e5.png"><br><br>  I stopped at the first option.  With the ‚ÄúClose‚Äù / ‚ÄúCancel‚Äù button, the top panel did not look the way we would like.  I tried to add a button with different shadows / transparency and the ‚ÄúX‚Äù symbol, but it was also knocked out (although it starts to like the idea with stickers or sticker elements). <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/96c/c8a/f03/96cc8af037c11a995b777bbdea9d819e.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/575/013/b61/575013b61da3b5bdb9d434c1e356e83d.png"><br><br>  I want to remind once again that the main task at the prototyping stage is to visually recreate the application without programming, try out many types and variants of screens, look at the user‚Äôs reaction and <i>hear their response</i> (in the early stages of prototyping, we‚Äôll get rid of some problems usually occurred somewhere in the middle of developing an application or at the end). <br><br>  The next screen will be the photo screen, where the user can take a picture (using the front or rear camera) and go to the screen for applying filters / effects. <br>  With the photo screen was much more interesting.  I looked through and worked with Instagram, I didn‚Äôt like some moments and I decided to eliminate them, but at the same time I learned something from myself. <br>  What happened (from the initial options to the last): <br><img src="https://habrastorage.org/getpro/habr/post_images/184/0e9/a6e/1840e9a6ef0c6f80d9749bddf41edcab.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/20b/93e/1e9/20b93e1e9af69ae4776e6ccb5d856789.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/231/80b/24e/23180b24ec03ea692f5e02e0a7fd7f3b.jpg"><br><br>  This screen did not want to clutter with something other than the most basic elements, so in general we can say that all the options are some variations of one.  Initially, at the bottom of the screen there is only one button (one element) by clicking on which the user snapshot will be fixed.  After fixing the snapshot of the button (in my view), two additional buttons ‚ÄúReset‚Äù and ‚ÄúEdit‚Äù should ‚Äúmove out‚Äù to opposite sides.  As you can see on one of the sketches, at the initial stage the buttons were only with the words ‚ÄúYES‚Äù and ‚ÄúNO‚Äù, but the second option (the first picture, the second screen) gave me the idea that YES / NO is not at all informative, but at the same time It is unnecessary to display the question ‚ÄúWhat do you want to do with a snapshot?‚Äù, because it is clear from the context what actions can be and what are needed. <br>  Why did I decide to lower the button with the letter ‚ÄúQ‚Äù to the bottom of the screen in such a way that it began to drop down a bit?  The answer is simple - the desire to increase free space.  For this very reason, in the 3 pictures (1 screen) the top panel has been removed. <br>  From Instagram I took over only the grid, it seemed to me necessary if I want to take a couple of shots so that the object is in the center of the photo. <br><br>  This is what I received after 40-50 minutes (see below).  Some moments have been changed, some will be changed, there are ideas.  Thanks to the prototype, it was possible to notice that simply putting the sign of the grid and the camera on the image will not work - you need to put something under them.  The panel is the first solution, but because of it the integrity and impression of the photo is lost, it interferes. <br>  Video of the prototyping process can be found at <a href="https://vk.com/video58487857_169296946">this</a> link. <br><br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/92e/bcc/f3e/92ebccf3e417bd9985b0cc647641e58c.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/c1b/e39/10c/c1be3910c35e2f73a7ffb826f377ca9c.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/451/767/075/4517670751bb43abc163c01003375fd4.png"><br><br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/f52/a3a/cfb/f52a3acfb900feedce78566bbdd4b027.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/f10/770/5e4/f107705e452c9af8ec22df17a4ef62df.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/05b/866/534/05b866534b21928ec9be03a3fcd18ce7.png"><br><br>  While transferring items from portrait mode to Landscap mode, I thought about removing the status bar. <br>  Compare: <br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/394/f0d/234/394f0d234f3c38587d2417877f6565b3.png"><br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/5a0/cb2/453/5a0cb2453b78681f66d0d3d2f105e9d3.png"><br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/2ad/813/a87/2ad813a87c4be7a91327965bd3dd3657.png"><br><br>  Compare: <br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/b1a/c8d/2d0/b1ac8d2d055b44249e4bb83cd3c05103.png"><br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/44e/d78/ade/44ed78adea7ab41d5a9a4062e8a95173.png"><br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/132/587/4e9/1325874e950972158eb0e3bf3efe943e.png"><br><br>  Compare: <br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/5c3/7f8/286/5c37f8286a41ee298a76a56dc164c1a8.png"><br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/54d/101/561/54d1015619fe568daab6ae06c72df37c.png"><br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/efe/730/94b/efe73094b2bf83186f6d156a1307e467.png"><br><br>  Maybe try to do so? <br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/24b/9b4/ca5/24b9b4ca5ce66e14ceba2130bde01d7a.png"><br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/37f/312/621/37f312621de5b64349bb0dadccb3e73f.png"><br><br>  And in the portrait mode, move the elements down: <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/5ee/b10/fe8/5eeb10fe8fa0fed70e3ae2f3409bd74d.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/ef9/36c/306/ef936c306b6181c6f3e3e477621cb3ea.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/4f5/2ff/0c4/4f52ff0c4984566c91938bddaa6d5244.png"><br><br>  After 20-30 minutes I decided to stop at this option (the more options there are now, the wider the choice will be then): <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/f4d/12f/88d/f4d12f88d6a4eba9f7d7fa2ccda248fb.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/a82/215/1f0/a822151f0f4140af0363ea25fa888abc.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/19e/3bd/e01/19e3bde01b8bb479370e081d038949e3.png"><br><br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/74a/fd4/df4/74afd4df481395ac0454663ed2ce7727.png"><img width="568" src="https://habrastorage.org/getpro/habr/post_images/97b/3b5/e08/97b3b5e08ab4c8e9dbae46c12725e760.png"><br><br>  Purple button interferes.  A snapshot will be captured by pressing, after clicking, no further action will appear in front of the user - immediately displaying filters, sprinkles, etc.  From this screen, the user can one click to go to shooting. <br><br>  Started sketching photo processing screen.  The first versions were as follows: <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/e2f/13e/65e/e2f13e65e9a7e5524bc00afa42ad17bf.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/4ec/8eb/3ae/4ec8eb3aeb4026fd1b1fed524e3cc5b5.png"><br><br>  I liked the option, but I‚Äôm stuck in the implementation, which I don‚Äôt want. <br><br>  Simplified to this: <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/1c8/cec/a4d/1c8ceca4d6bf2b0aee7d2e44276322df.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/207/13f/729/20713f7297859e8714a93f4610b508a8.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/6c4/625/cc9/6c4625cc975d336fe05d733e64af8929.png"><br><br>  In this embodiment, I decided to beat the theme with stickers / stickers.  As you can see, in the first version of this theme - flat elements. <br><br>  I got such photo editing screens in Landscap mode (we‚Äôll choose later, but there are already some favorites. Video from <a href="https://vk.com/video58487857_169313091">this</a> link.): <br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/618/d5d/86f/618d5d86fba9b802187e6c19f4d7dfff.png"><br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/377/18c/336/37718c336b3a343dbd61e04823933ace.png"><br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/468/7f8/fd8/4687f8fd8b7bebb45f0cee1a6013b3f3.png"><br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/f88/344/8f0/f883448f007fb9cd48f60352999cc9ed.png"><br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/126/5e8/0a2/1265e80a2d78e04397e7dec86bcae50f.png"><br><br>  Something completely different (each image must be a source image with a superimposed filter): <br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/104/122/7da/1041227da7a24401d85db107f41ce814.png"><br><br>  After clicking this screen opens: <br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/a83/e51/f0f/a83e51f0fd333695bc70868d9b292f63.png"><br><br>  True, this option has several questions: <br>  1. How to leave this screen? <br>  2. Two elements that confirm the action of some kind (button - applies the filter, and a tick - the transition to the settings) <br>  3. With a small number of filters, it looks good and a large enough part of the image is visible, but what will this harmonica look like with 10-15 filters? <br>  Still, it looks nice, so finally we will not discard this option. <br><br>  Next we have the loading options screen.  What the user can specify: <br>  1) Set photo as primary <br>  2) Attach current location <br>  3) Select an album in which the photo will be uploaded. <br>  4) Add friend tag on photo <br>  5) Post a photo on the wall <br><br>  Keynote Sketches: <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/37b/c79/8fd/37bc798fd22670ae8845255ae92087bc.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/fd0/785/102/fd0785102b3cbb2c0cbffe0e97db3936.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/476/fc2/ce5/476fc2ce5383fac16a706c92ad571473.png"><br><br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/564/69b/b57/56469bb57c58693a5e3fec4f2bce9652.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/710/84d/e9d/71084de9d39df8b47232e7866adacfef.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/233/d8a/345/233d8a3453c5d9395b15313c9002d859.png"><br><br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/37f/ed6/042/37fed6042dfb20fa53fba156dd9d5041.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/d25/6c2/67d/d256c267d164a246cd820ccc10698404.png"><br><br>  A video of the creation process can be found at <a href="https://vk.com/video58487857_169315809">this</a> link. <br><br>  Should I show the user how to upload a photo?  If the answer is yes, then you need to place a certain loading indicator on the current screen, or create a new screen with a list of photos to be loaded.  The list is needed in order to solve the problem of uploading photos when there is no Internet.  How much does the user need such a list explicitly?  The main task is to hide all unnecessary and make the work of the application as organic and natural as possible. <br>  After a few minutes of estimations, I came to this option of displaying the number of photos in the queue: <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/098/9a2/bea/0989a2bea485ae824df264ffed30f981.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/6af/ccd/5e7/6afccd5e72e5dc86bf099e5c5521f408.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/e07/9c0/76f/e079c076f667a2a4bcadac74d90f60a1.png"><br><br>  We will upload images in the background.  If for some reason it was not possible to upload a photo, then we will try again later, but we will not remove the photo from the list. <br><br>  The last screen with the options I do not really like, I decided to poshamanit more.  Compare: <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/1a5/ecb/801/1a5ecb801cfe6f7fdb11d0890c5195e8.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/039/de6/812/039de68122853ebcba63fe237bc8c746.png"><br><br>  Such interfaces are obtained in landscape mode: <br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/b4c/a73/5ef/b4ca735ef561cb1869e63f01a1b9e0c4.png"><br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/498/67a/6b5/49867a6b513d031dd03d90adb549cc68.png"><br><br>  The variant with the callout block did not even begin to be considered.  The position of the vertical in the landscape mode was not enough + I wanted to preserve some common positions of the elements between the landscape variant and the portrait one. <br><br><h4>  Prototypes: reviews.  Two. </h4><br>  Authorization screen: <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/406/352/501/4063525012ba93846a7d44a3f6e85ebe.png"><br>  Comments: <b>None</b> . <br><br>  Modal authorization window in VK (corrected version): <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/e65/96d/bfd/e6596dbfd24ab4160e4d3b8e06af6903.png"><br>  Comments: <br><blockquote>  The inscription "Authorization" on the past screen looked like a button and the subjects had questions about this. <br></blockquote><br><br>  Shooting window (portrait mode): <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/33d/c33/1a4/33dc331a44f337c80fd58ab81dd1bdd0.png"><br>  Comments: <b>None</b> . <br><br>  Shooting window (Landscap mode): <br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/d1c/c04/c42/d1cc04c424251e92ad80088acf5090ad.png"><br>  Comments: <b>None</b> . <br><br>  Filters (portrait mode): <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/bc8/6f6/561/bc86f65616cac5485fc5685eeb393b42.png"><br>  Comments: <b>None</b> . <br><br>  Filters (landcap mode): <br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/c87/21b/e70/c8721be7063f9977cda663f178381b01.png"><br>  Comments: <b>None</b> . <br><br>  Download settings (portrait mode): <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/8b5/f24/b8b/8b5f24b8b5180701ea0a6a6e95386d4b.png"><br>  Comments: <br><blockquote>  Font sucks.  Why do I need the heading "Friends" if I see now that these are my friends?  (author: this is how the second version of the screen appeared) <br></blockquote><br><br>  Boot Settings (Landscap mode): <br><img width="568" src="https://habrastorage.org/getpro/habr/post_images/bc4/16e/1ab/bc416e1abf0c9aa8e844cb3056e57084.png"><br>  Comments: the <b>same as the screen in portrait mode</b> . <br><br><h4>  Prototypes: animation.  Three. </h4><br>  The video can be viewed at <a href="https://vk.com/video58487857_169335788">this</a> link. <br><br><h4>  We program the main screen. </h4><br>  On this screen, I decided to conduct several experiments: <br>  1. Use the blur effect as a ‚Äúglass‚Äù layer between the background image and the name of the application. <br>  2. The authorization button is not inserted with a shadow image, but programmatically create it. <br><br>  To begin with, the use of pure blue will not give the desired effect. <br><br>  We must cheat - add another layer.  So do.  The additional layer will be gray and to achieve the desired effect (as on the layout) it is necessary to experiment with the transparency of the layer itself (alpha). <br><br>  The application logo was inserted with a simple picture. <br><br>  It was much more interesting to deal with the shadow, the fact is that it is impossible to use cornerRadius and custom shadowPath on one view.  After googling and reading the documentation, we decide to put the shadow on a separate layer.  To achieve the desired sticker effect, it is necessary to define the borders of the shadow under the button, for this we use <a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/CGPath/">GGPath</a> and recall the geometry. <br><br>  If you look closely at the shadow under the button, then you can estimate that it consists of a ‚Äúalmost‚Äù rectangle with one rounded side (bottom).  With the construction of direct no problems should arise - <a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/CGPath/">CGPathAddLineToPoint ()</a> and <a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/CGPath/">CGPathMoveToPoint ()</a> .  As for the rounded side, we have little choice - either we subtle and the rounded side is replaced by two straight lines, or we deal with the <a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/CGPath/">CGPathAddArc ()</a> method and the like. <br>  I have to say that using the first method will not achieve the desired effect. <br><br>  What questions need to be answered? <br>  1. <a href="http://www.bitclass.ru/math/theory/%25D0%2593%25D0%25B5%25D0%25BE%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%258F/%25D0%259A%25D0%25B0%25D1%2581%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F,_%25D1%2581%25D0%25B5%25D0%25BA%25D1%2583%25D1%2589%25D0%25B0%25D1%258F,_%25D1%2585%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B0">How to determine the angle "resting" on the chord knowing the chord length and radius</a> ? <br>  2. <a href="http://http:">What are radians and what does a circle from 0 to 2Pi look like</a> ? <br><br>  With the first special difficulties should arise.  There is a formula for calculating the chord length, it has variables of radius and angle, it is necessary to express the angle and substitute the necessary values. <br>  In the second question, during implementation, I was confronted with what I did not expect to see. <br>  Here is what a circle looks like with angles in radians: <br><img src="https://habrastorage.org/getpro/habr/post_images/ddb/b3e/2c0/ddbb3e2c0a57238db3c432162d95cb90.png"><br><br>  The countdown is counterclockwise, in the implementation of Apple, the countdown <b>is clockwise</b> !  Where 270 we have, 90 - with them. <br>  I did not expect this, maybe something is missing? <br><br>  The shadow rendering code looks like this (Shl: there is no backlight for Swift): <br><pre><code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   let shadow = UIView(frame: CGRectMake(0, 0, CGRectGetWidth(frame), CGRectGetHeight(frame))) shadow.layer.shadowOpacity = 0.65 shadow.layer.shadowRadius = 4 shadow.layer.shadowColor = UIColor.blackColor().CGColor shadow.layer.shadowOffset = CGSize(width: 0, height: 0) //     let diameter = (CGRectGetWidth(frame) / CGRectGetHeight(frame)) * CGRectGetWidth(frame) let radius = diameter / 2 let xCenter = CGRectGetWidth(frame) / 2 let yCenter = CGRectGetHeight(frame) + radius let angle = 2 * asin(CGRectGetWidth(frame) / (2 * radius)) let endAngle = M_PI + (M_PI - angle) / 2 let startAngle = endAngle + angle let shadowPath = CGPathCreateMutable() CGPathMoveToPoint(shadowPath, nil, 0, CGRectGetHeight(frame) / 2) CGPathAddLineToPoint(shadowPath, nil, frame.size.width, CGPathGetCurrentPoint(shadowPath).y) CGPathAddLineToPoint(shadowPath, nil, CGPathGetCurrentPoint(shadowPath).x, frame.size.height) CGPathAddArc(shadowPath, nil, xCenter, yCenter, radius, startAngle, endAngle, true) CGPathAddLineToPoint(shadowPath, nil, 0, frame.size.height) CGPathCloseSubpath(shadowPath) shadow.layer.shadowPath = shadowPath</span></span></code> </pre> <br><br>  You can compare (on the left the layout, on the right the implementation): <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/1a2/d75/239/1a2d75239ecda9fce559e50cea246570.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/98a/971/d37/98a971d377e9c7408f751c4513eb45aa.png"><br><br><h4>  We program the authorization screen in VK. </h4><br>  The first thing to do is to integrate the <a href="https://github.com/AndrewShmig/Vkontakte-iOS-SDK-LV">Vkontakte iOS SDK</a> into the project.  <a href="https://github.com/AndrewShmig/Vkontakte-iOS-SDK-LV">Vkontakte iOS SDK is</a> written in Objective-C, there <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html">is such a tutorial</a> on how to integrate Objective-C into the Swift project. <br><br>  Connect the SDK no problems. <br>  Starting the authorization process starts with calling this method: <br><pre> <code class="objectivec hljs">VKConnector.sharedInstance().startWithAppID(<span class="hljs-string"><span class="hljs-string">"87687678678"</span></span>, permissons: [<span class="hljs-string"><span class="hljs-string">"photo"</span></span>, <span class="hljs-string"><span class="hljs-string">"wall"</span></span>, <span class="hljs-string"><span class="hljs-string">"friends"</span></span>], webView: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.webView, delegate: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre><br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/ce5/412/6b5/ce54126b5c452456b92a1ca35a011426.png"><br><br>  After successful authorization, we get an access token that will be stored in the SDK data store.  The user will transfer the photos to the screen. <br><br><h4>  We program the photo implementation screen </h4><br>  To begin with, I will show the final results: <br><img width="640" src="https://habrastorage.org/getpro/habr/post_images/605/ef6/aed/605ef6aed943cda4b4f971288c32558b.png"><br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/73a/858/ba1/73a858ba1aef0b898991fdda29380192.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/728/83c/c74/72883cc743a7f176687c378fc8eb8eb8.png"><br><br>  The net is removed and made so invisible on purpose. <br><br>  This is the layout of the buttons too, but I dropped it, because when I clicked on the screen border (button - screen), I often took a photo next to the button and did not switch between cameras or activate the grid: <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/4fe/a8b/b5a/4fea8bb5aae2b138defda42a3d868767.png"><img width="320" src="https://habrastorage.org/getpro/habr/post_images/8ae/4ef/8be/8ae4ef8befdf6d4fe58da216f24c7948.png"><br><br>  The article is supplemented only after the screen has been programmed, so unfortunately I can miss some moments. <br><br>  I took the UIImagePickerController as a basis, which is suitable for solving the task quite well.  Hid all its elements, removed all unnecessary, installed its cameraOverlayView. <br><pre> <code class="objectivec hljs"> let cameraView = NAGImagePickerController() cameraView.delegate = cameraView cameraView.sourceType = <span class="hljs-built_in"><span class="hljs-built_in">UIImagePickerControllerSourceType</span></span>.Camera cameraView.showsCameraControls = <span class="hljs-literal"><span class="hljs-literal">false</span></span> cameraView.allowsEditing = <span class="hljs-literal"><span class="hljs-literal">false</span></span> cameraView.cameraOverlayView = NAGFirstPhotoOverlayView(frame: <span class="hljs-built_in"><span class="hljs-built_in">UIScreen</span></span>.mainScreen().bounds)</code> </pre><br>  A slight surprise for me was the appearance of this visual element of zoom: <br><img width="320" src="https://habrastorage.org/getpro/habr/post_images/7df/e90/347/7dfe9034726a98fa43803b67223cf312.png"><br><br>  I did not need him here, and he was very spoiling the view, besides overlapping the button - I had to remove it.  Implemented the first method that came to mind: <br><pre> <code class="objectivec hljs"> let pinchGR = <span class="hljs-built_in"><span class="hljs-built_in">UIPinchGestureRecognizer</span></span>(target: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, action: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) addGestureRecognizer(pinchGR)</code> </pre><br><br>  Then I decided to look for SO for some more interesting solutions and found - setting userInteraction to false. <br><br>  Consider now the most interesting line, in my opinion the most interesting begins with it: <br><pre> <code class="objectivec hljs">cameraView.delegate = cameraView</code> </pre><br><br>  Two questions: <br>  1. Since when UIImagePickerController appears, I have to start the animation of the appearance of buttons, then somehow I need to receive an event / notification about it, which means we have to overwrite the UIImagePickerController method viewDidAppear itself. <br>  2. It is necessary to notify UIImagePickerController in some way that you need to take a photo or switch to the front camera <br><br>  Found two solutions: <br>  1. Move the UIImagePickerController into the global scope <br>  2. Create a subclass of UIImagePickerController and implement it in such a way that it sends notifications about events that occurred ‚Äúin it‚Äù and could process the commands itself (take a photo, change the camera, etc.) - NSNotificationCenter <br><br>  The first option, I almost started to try and watch, but at some point I simply felt sick from this decision and I found it ugly.  In the end, everything was implemented using notifications.  It turned out quite simple and flexible at the same time. <br>  This is what NAGImagePickerController looks like at this stage: <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// // NAGImagePickerController.swift // Qtty // // Created by AndrewShmig on 21/07/14. // Copyright (c) 2014 Non Atomic Games Inc. All rights reserved. // import UIKit let kNAGImagePickerControllerViewDidLoadNotification = "NAGImagePickerControllerViewDidLoadNotification" let kNAGImagePickerControllerViewWillAppearNotification = "NAGImagePickerControllerViewWillAppearNotification" let kNAGImagePickerControllerViewDidAppearNotification = "NAGImagePickerControllerViewDidAppearNotification" let kNAGImagePickerControllerViewDidDisappearNotification = "NAGImagePickerControllerViewDidDisappearNotification" let kNAGImagePickerControllerViewWillDisappearNotification = "NAGImagePickerControllerViewWillDisappearNotification" let kNAGImagePickerControllerFlipCameraNotification = "NAGImagePickerControllerFlipCameraNotification" let kNAGImagePickerControllerCaptureImageNotification = "NAGImagePickerControllerCaptureImageNotification" class NAGImagePickerController: UIImagePickerController, UIImagePickerControllerDelegate, UINavigationControllerDelegate { override func viewDidLoad() { super.viewDidLoad() NSNotificationCenter.defaultCenter().postNotificationName(kNAGImagePickerControllerViewDidLoadNotification, object: self) } override func viewWillAppear(animated: Bool) { super.viewWillAppear(animated) NSNotificationCenter.defaultCenter().postNotificationName(kNAGImagePickerControllerViewWillAppearNotification, object: self) } override func viewDidAppear(animated: Bool) { super.viewDidAppear(animated) NSNotificationCenter.defaultCenter().postNotificationName(kNAGImagePickerControllerViewDidAppearNotification, object: self) NSNotificationCenter.defaultCenter().addObserver(self, selector: "flipCameras", name: kNAGImagePickerControllerFlipCameraNotification, object: nil) NSNotificationCenter.defaultCenter().addObserver(self, selector: "captureImage", name: kNAGImagePickerControllerCaptureImageNotification, object: nil) } override func viewWillDisappear(animated: Bool) { super.viewWillDisappear(animated) NSNotificationCenter.defaultCenter().postNotificationName(kNAGImagePickerControllerViewWillDisappearNotification, object: self) } override func viewDidDisappear(animated: Bool) { super.viewDidDisappear(animated) NSNotificationCenter.defaultCenter().postNotificationName(kNAGImagePickerControllerViewDidDisappearNotification, object: self) } //       func flipCameras() { cameraDevice = (cameraDevice == .Rear ? .Front : .Rear) } //   func captureImage() { takePicture() } //   ,          func imagePickerController(picker: UIImagePickerController!, didFinishPickingMediaWithInfo info: [NSObject : AnyObject]!) { println(info) } deinit { NSNotificationCenter.defaultCenter().removeObserver(self) } }</span></span></code> </pre><br>  Now we quietly subscribe to our cameraOverlayView to receive notifications that viewDidAppear: in UIImagePickerController: <br><pre> <code class="objectivec hljs"> <span class="hljs-built_in"><span class="hljs-built_in">NSNotificationCenter</span></span>.defaultCenter().addObserver(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector: <span class="hljs-string"><span class="hljs-string">"imagePickerControllerViewDidAppear:"</span></span>, name: kNAGImagePickerControllerViewDidAppearNotification, object: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre><br>  Aha  Now you can create controls and display them with animation: <br><pre> <code class="objectivec hljs"> createControlElements() <span class="hljs-comment"><span class="hljs-comment">//      -  UIView.animateWithDuration(1.0, animations: { self.layout(UIDevice.currentDevice().orientation) })</span></span></code> </pre><br>  In the same method, we will subscribe to receive notifications about the change in the orientation of the device: <br><pre> <code class="objectivec hljs"> <span class="hljs-built_in"><span class="hljs-built_in">UIDevice</span></span>.currentDevice().beginGeneratingDeviceOrientationNotifications() <span class="hljs-built_in"><span class="hljs-built_in">NSNotificationCenter</span></span>.defaultCenter().addObserver(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector: <span class="hljs-string"><span class="hljs-string">"deviceDidChangeOrientation:"</span></span>, name: <span class="hljs-built_in"><span class="hljs-built_in">UIDeviceOrientationDidChangeNotification</span></span>, object: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre><br>  Why do we do it here and now?  The fact is that if the device is in an arbitrary orientation when the application starts up - no initial orientation notification will initially arrive, which means you need to add a flag to the change processing method that determines whether this is the first element mapping or not.  Only at the first appearance of the animation is played.  I would have to add unnecessary ify and enter a variable flag, I did not like the result and I came to what I showed above. <br><br>  In the method that handles device orientation changes, we 1) position the buttons in the desired corners of the screen 2) animate the rotation of the button in the direction of rotation of the device. <br><pre> <code class="objectivec hljs"> func layout(orientation: <span class="hljs-built_in"><span class="hljs-built_in">UIDeviceOrientation</span></span>) { println(__FUNCTION__) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> orientation { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .Portrait: leftButton.frame = position(leftButton, atCorner: .UpperLeftCorner) rightButton.frame = position(rightButton, atCorner: .UpperRightCorner) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .PortraitUpsideDown: leftButton.frame = position(leftButton, atCorner: .LowerRightCorner) rightButton.frame = position(rightButton, atCorner: .LowerLeftCorner) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .LandscapeRight: leftButton.frame = position(leftButton, atCorner: .LowerLeftCorner) rightButton.frame = position(rightButton, atCorner: .UpperLeftCorner) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">//    leftButton.frame = position(leftButton, atCorner: .UpperRightCorner) rightButton.frame = position(rightButton, atCorner: .LowerRightCorner) } var angle: CGFloat switch (prevDeviceOrientation, orientation) { case (.Portrait, .LandscapeLeft), (.LandscapeRight, .Portrait), (.PortraitUpsideDown, .LandscapeRight), (.LandscapeLeft, .PortraitUpsideDown): angle = CGFloat(M_PI) / 2.0 case (.Portrait, .LandscapeRight), (.LandscapeLeft, .Portrait), (.LandscapeRight, .PortraitUpsideDown), (.PortraitUpsideDown, .LandscapeLeft): angle = -CGFloat(M_PI) / 2.0 case (.Portrait, .PortraitUpsideDown), (.PortraitUpsideDown, .Portrait), (.LandscapeLeft, .LandscapeRight), (.LandscapeRight, .LandscapeLeft): angle = CGFloat(M_PI) default: angle = 0.0 } let rotate = CGAffineTransformMakeRotation(angle) UIView.animateWithDuration(0.3, animations: { self.leftButton.transform = CGAffineTransformConcat(self.leftButton.transform, rotate) self.rightButton.transform = CGAffineTransformConcat(self.rightButton.transform, rotate) }) }</span></span></code> </pre><br><br>  For some time I was picking with line drawing, I couldn‚Äôt understand why lines are not displayed when layer.alpha = 0.0.  Pereklinilo, set the backgroundColor in clearColor () and everything fell into place. <br>  Line drawing is in the drawRect: method and looks like this: <br><pre> <code class="objectivec hljs"> let screenHeight = <span class="hljs-built_in"><span class="hljs-built_in">CGRectGetHeight</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">UIScreen</span></span>.mainScreen().bounds) let screenWidth = <span class="hljs-built_in"><span class="hljs-built_in">CGRectGetWidth</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">UIScreen</span></span>.mainScreen().bounds) let context = <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsGetCurrentContext</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetLineWidth</span></span>(context, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetShadow</span></span>(context, <span class="hljs-built_in"><span class="hljs-built_in">CGSizeZero</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetStrokeColorWithColor</span></span>(context, <span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span>(red: <span class="hljs-number"><span class="hljs-number">0.803</span></span>, green: <span class="hljs-number"><span class="hljs-number">0.788</span></span>, blue: <span class="hljs-number"><span class="hljs-number">0.788</span></span>, alpha: <span class="hljs-number"><span class="hljs-number">0.5</span></span>).CGColor) <span class="hljs-comment"><span class="hljs-comment">//    ( ) let horizontalLines = screenHeight / kVisualBlocks let countHLines = screenHeight / horizontalLines for i in 1..&lt;countHLines { CGContextMoveToPoint(context, 0, i * horizontalLines) CGContextAddLineToPoint(context, screenWidth, i * horizontalLines) } //    ( ) let verticalLines = screenWidth / kVisualBlocks let countVLines = screenWidth / verticalLines for i in 1..&lt;countVLines { CGContextMoveToPoint(context, i * verticalLines, 0) CGContextAddLineToPoint(context, i * verticalLines, screenHeight) } CGContextStrokePath(context)</span></span></code> </pre><br><br>  After the implementation of the screen, <a href="https://developer.apple.com/swift/blog/%3Fid%3D5">in the Swift blog</a> , information appeared about access modifiers. <br>  The actual source code of the application can be found on GitHub, at the end of the article, see the link to the repository. <br><br><h4>  We program the screen of imposing of filters </h4><br>  After the user has taken a snapshot, the following method will be called: <br><pre> <code class="objectivec hljs"> func imagePickerController(picker: <span class="hljs-built_in"><span class="hljs-built_in">UIImagePickerController</span></span>!, didFinishPickingMediaWithInfo info: [<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span> : AnyObject]!) { <span class="hljs-built_in"><span class="hljs-built_in">NSNotificationCenter</span></span>.defaultCenter().postNotificationName(kNAGImagePickerControllerUserDidCaptureImageNotification, object: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, userInfo: info) }</code> </pre><br><br>  We send a notice to the tracking objects (layers) that the photo has been taken and it is necessary to change the control elements to new ones (go to another screen). <br>  The method that "handles" the notification is as follows: <br><pre> <code class="objectivec hljs"> <span class="hljs-comment"><span class="hljs-comment">//      ,   //   func hideControlElements(notification: NSNotification) { //       ,    //        //       deviceDidChangeOrientation NSNotificationCenter.defaultCenter().removeObserver(self) //   UIImagePickerController   (notification.object as NAGImagePickerController).view.userInteractionEnabled = false //   if !superview.viewWithTag(kGridViewTag).hidden { invertGridVisibility() } //     UIView.animateWithDuration(1.0, animations: { self.layout(self.prevDeviceOrientation, animation: .BeforeAnimation) }, completion: { _ in let imagePickerController = notification.object as NAGImagePickerController imagePickerController.cameraOverlayView = NAGPhotoOverlayView(imageInfo: notification.userInfo, frame: self.frame) }) }</span></span></code> </pre><br><br>  Next, I plan to do the following: create a layer that will contain the final photo, on this layer there will be another UIView, which will be responsible for displaying and changing control elements. <br><br>  In NAGPhotoOverlayView there will be (so far) two properties: <br>  1. UIImageView <br>  2. UIImage <br>  and declared as follows: <br><pre> <code class="objectivec hljs"> var photoView: <span class="hljs-built_in"><span class="hljs-built_in">UIImageView</span></span>! var originalPhoto: <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span>!</code> </pre><br><br>  Initialization is as follows: <br><pre> <code class="objectivec hljs"> init(imageInfo: [<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span> : AnyObject]!, frame: <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.init(frame: frame) originalPhoto = imageInfo[<span class="hljs-built_in"><span class="hljs-built_in">UIImagePickerControllerOriginalImage</span></span>] as <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> photoView = createPhotoLayer(image: originalPhoto) addSubview(photoView) <span class="hljs-built_in"><span class="hljs-built_in">NSNotificationCenter</span></span>.defaultCenter().addObserver(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector: <span class="hljs-string"><span class="hljs-string">"deviceDidChangeOrientation:"</span></span>, name: <span class="hljs-built_in"><span class="hljs-built_in">UIDeviceOrientationDidChangeNotification</span></span>, object: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre><br><br>  We sign the current layer to receive notifications around the rotation of the device in order to correctly rotate the image.  I want to remind you that by default, a photo that is made via UIImagePickerController will always be displayed in portrait mode, and this is fraught with image compression when displayed.  The method of processing turns the device looks like this: <br><pre> <code class="objectivec hljs"> func deviceDidChangeOrientation(notification: <span class="hljs-built_in"><span class="hljs-built_in">NSNotification</span></span>) { rotateImage(toOrientation: <span class="hljs-built_in"><span class="hljs-built_in">UIDevice</span></span>.currentDevice().orientation) }</code> </pre><br>  main image rotation code: <br><pre> <code class="objectivec hljs"> private func rotateImage(toOrientation orientation: <span class="hljs-built_in"><span class="hljs-built_in">UIDeviceOrientation</span></span>) { let orientation = <span class="hljs-built_in"><span class="hljs-built_in">UIDevice</span></span>.currentDevice().orientation let photoOrientation = originalPhoto.imageOrientation let isLandscapedPhoto = photoOrientation == .Down || photoOrientation == .Up <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isLandscapedPhoto &amp;&amp; (orientation == .LandscapeLeft || orientation == .LandscapeRight) { photoView.image = <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CGImage</span></span>: originalPhoto.CGImage, scale: originalPhoto.scale, orientation: orientation == .LandscapeRight ? .Right : .Left) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isLandscapedPhoto &amp;&amp; (orientation == .Portrait || orientation == .PortraitUpsideDown){ photoView.image = <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CGImage</span></span>: originalPhoto.CGImage, scale: originalPhoto.scale, orientation: orientation == .Portrait ? .Right : .Left) } }</code> </pre><br><br>  What are we doing?  Let's check first in what orientation the photo was taken.  If the photo is in Landscape mode, then turns should be allowed only for the position of the .LandscapeLeft and LandscapeRight device, if the photo in portrait mode is only .Portrait and .PortraitUpsideDown. <br>  Since you cannot directly change the imageOrientation property of a UIImage instance, you have to create a new object. <br><br>  The next step is to create a layer containing the controls, animate the appearance of the elements, and select and apply filters to the image. <br><br><h4>  the end </h4><br>  Just tired ... decided not to delete the article, but still publish it. <br><br>  Sources can be found at <a href="https://github.com/AndrewShmig/Qtty">this link on GitHub</a> . <br><br><h4>  Conclusion </h4><br>  <b>Do not do what you do not see the point.</b> <br><br>  Thank you for your attention, dear habrazhiteli. </div><p>Source: <a href="https://habr.com/ru/post/227751/">https://habr.com/ru/post/227751/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227739/index.html">New Opera Mini 8 for iOS</a></li>
<li><a href="../227741/index.html">PolyITAN-1 - the first Ukrainian nanosatellite in orbit</a></li>
<li><a href="../227743/index.html">Using characters and scenarios in testing your Calendar</a></li>
<li><a href="../227747/index.html">Application Porno or how to find secrets in mobile applications and take out everything</a></li>
<li><a href="../227749/index.html">Split Screen mode or Split Screen do it yourself</a></li>
<li><a href="../227753/index.html">Metaprogramming (with JavaScript examples)</a></li>
<li><a href="../227755/index.html">4 myths about landing page</a></li>
<li><a href="../227761/index.html">Searchcode 2.0</a></li>
<li><a href="../227763/index.html">Payoneer and Ball To All - a ball for each child</a></li>
<li><a href="../227767/index.html">Configuring OpenVPN in the Mikrotik / Ubuntu bundle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>