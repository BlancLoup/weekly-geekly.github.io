<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>2D magic in detail. Part Three Global coverage</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Global illumination, dynamic light and decals (yes, there is such a word :)) in action. 


 I love to look at white objects without texture. Recently,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>2D magic in detail. Part Three Global coverage</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/a32/3eb/731/a323eb731d8746c4b2da5d61f2af0ffb.png"><br><p>  <em>Global illumination, dynamic light and decals (yes, there is such a word :)) in action.</em> </p><br><p>  I love to look at white objects without texture.  Recently, in an art store, I have long considered plaster figures, which artists use as model objects.  It is very nice to see all these smooth transitions of light and soft shadows.  Later, when I returned home and opened Unity3D, it came to be understood that the light in my project is still dull and unrealistic. <br>  From that moment on, the story of global coverage began, which I will tell today. </p><a name="habracut"></a><br><h2 id="predyduschie-stati">  Previous articles </h2><br><p>  <a href="https://habrahabr.ru/post/305252">Part one.</a>  <a href="https://habrahabr.ru/post/305252">Shine.</a> <br>  <a href="https://habrahabr.ru/post/312046">Part two.</a>  <a href="https://habrahabr.ru/post/312046">Structure.</a> <br>  <b>Part Three</b>  <b>Global coverage.</b> </p><br><h2 id="oglavlenie">  Table of contents </h2><br><ol><li>  How to do procedurally generated effects </li><li>  What is global coverage? </li><li>  Direct lighting </li><li>  Indirect lighting </li><li>  Wall lighting </li><li>  Decals </li><li>  Improvements to dynamic lighting </li><li>  Conclusion </li></ol><br><h2 id="kak-delat-procedurno-generiruemye-effekty">  How to do procedurally generated effects </h2><br><p>  The very first comment on the initial article of this cycle was: ‚ÄúMagic! And straight arms.‚Äù  I‚Äôm not sure about the complete integrity of my hands (at the end of the previous article there are visual bugs that confirm this), but there is no magic here.  I will share the secret of procedural effects: </p><br><ul><li><p>  At least a third of the work has already been done, as soon as you had the idea to make procedurally generated content.  It can be anything: spots on the wings of butterflies or the atmosphere of the planet, trees and bushes, etc.  Sometimes, especially with light, it is immediately clear how the "generation" occurs in the real world.  Most often, the algorithm boils down to: "send infinitely many rays in an infinite number of directions and get a realistic picture." </p><br></li><li><p>  And this is the second third - to write a similar algorithm (taking into account the fact that infinity is well approximated by a thousand).  It turns out simple, like "hello world", but slow.  Hands immediately stretch something to optimize, but, believe me, you should not.  It is better to start it in the editor and go to drink tea.  And after tea to understand that the invented method will not give a beautiful picture and redo everything.  If you plan to preassign once a picture in the editor, and then use it in the build, you can stop there. </p><br></li><li>  And finally, the last third is to come up with an algorithm that will give a visually close result, but it will work faster.  Usually, knowledge of all interesting containers, algorithms, trees, etc. comes in handy.  For one of these algorithms - thank you very much <a href="https://habrahabr.ru/users/dionis_mgn/" class="user_link">Dionis_mgn</a> , who once told you how to make cool two-dimensional shadows. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Sometimes it turns out to make interesting things.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/be4/765/b6f/be4765b6f6e449199168cd9e7948e764.jpg"><br><p>  <em>Planet from the previous project.</em> </p><br><p>  For example, the sky for the planets in one of the projects was predicted as follows: for each pixel of the sky 20-30 rays were emitted to different parts of the Sun, it was considered how many rays intersect with the planet itself, what part of the path the ray passed in the atmosphere (for similarity of Rayleigh dispersion).  With good quality, calculations for one planet lasted about 30‚Äì40 seconds and produced various atmospheres at the exit depending on the distance of the Sun, the ‚Äúcomposition‚Äù and density of the atmosphere.  And this algorithm managed quite good sunsets. </p><br><img src="https://habrastorage.org/files/3e4/69f/1db/3e469f1dbe68444d82effeb13a34cf94.png"><br><p>  <em>Sunset on Earth II.</em> </p><br><img src="https://habrastorage.org/files/0c3/1fa/d34/0c31fad345784629a30b3ecb7f215307.png"><br><p>  <em>The whole star system.</em> </p></div></div><br><h2 id="chto-takoe-globalnoe-osveschenie">  What is global coverage? </h2><br><blockquote>  I noticed the need to do something with lighting when I added day and night to the demo.  Rays of light from the sun and the moon beautifully illuminated the walls of the castles, but something strange was happening inside the rooms: as soon as the dawn rays touched the tops of the towers, it became light in the deepest casemates, forgive the pun like during the day.  Of course, the reason is not in the light source ‚ÄúdefaultSun‚Äù: when changing day and night, the color and brightness of the sky changed.  So they influenced every pixel, regardless of whether it was a blade of grass on the old roof or a stone in a gloomy cave. </blockquote><p>  Let's define what picture we want to get.  ‚ÄúIt‚Äôs light in the light and dark in the dark‚Äù sounds good for a starting point.  As in the real world: it is dark in the closet, lighter in the corridor, lighter in the room, and quite bright on the roof.  Let us reformulate: the elements of the background, characters and other objects should receive as much light as the photons could get to them from the celestial sphere (in our 2D case, the celestial circle).  It is clear that it is better to direct our "photons" not from the sky, as in the real world, but on the contrary, from an illuminated point to the sky: otherwise, we will need too many shots, and even that, many will go "to milk". </p><br><p>  One of the conditions: we expect global illumination only for static objects: walls, earth.  So we will be able to run it at boot and use the results of the entire level (without affecting fps). </p><br><img src="https://habrastorage.org/files/d38/33b/ff6/d3833bff6b7a4f57adb15cbce6caabf8.png"><br><p>  <em>A slice of the scene.</em>  <em>In fact, the calculations go for the whole scene.</em> </p><br><h2 id="pryamoe-osveschenie">  Direct lighting </h2><br><p>  No sooner said than done.  Create a texture the size of the entire playing field.  Run through each pixel and see how many direct rays can be stretched from this point to the "sky".  The rays will be thrown with equal angles along the entire circumference, and the ‚Äúsky‚Äù is the nearest point outside the map (the distance of the diagonal of the rectangle describing the map is enough). <br>  Total <em>direct lighting algorithm</em> : </p><br><pre><code class="tex hljs">  : * ,    .   -    ; *  N       œÄ * 2 / N ; *  C  ,      ; *      C / N.</code> </pre> <br><p>  <b>UPD:</b> </p><br><blockquote>  This suggests an optimization: throwing rays only into the upper half-plane.  And only for indirect lighting to work with the entire plane entirely.  Unfortunately, optimizations (about this below) do not allow using a different number of rays for direct and indirect illumination. </blockquote><br><img src="https://habrastorage.org/files/794/f10/7b4/794f107b4bda47d582b58cc7d159b759.png"><br><p>  <em>Demonstration of lighting one pixel.</em> </p><br><p>  To speed up the process, we will work not with a texture, but with a one-dimensional array of brightness.  And it is not necessary to process each pixel: we introduce a <em>scale</em> factor, with scale = 4 we will work with every fourth pixel.  The size of the texture and the speed of work will grow in scale ^ 2 times.  In addition, we do not need to process the "hard" pixels of the walls, but we will need them in the future.  Let's get for them a separate array with boolean values ‚Äã‚Äãof "hardness". </p><br><img src="https://habrastorage.org/files/87b/970/6c1/87b9706c13a74e33904e27de851bff4f.png"><br><p>  <em>At 25 rays we get such a texture.</em> </p><br><p>  Remember, in the last part there was a section about the Region tree?  Using it, throwing a raycast across the entire map turns out to be quite a quick affair. </p><br><div class="spoiler">  <b class="spoiler_title">Hints</b> <div class="spoiler_text"><ol><li>  The search for wall hardness is also carried out through the Region tree.  And the result (in the form of a black and white texture) can be used in other post-effects. </li><li><p>  I do not cycle through the entire texture, since more than half of the pixels belong to the walls.  Instead, the iteration is performed on an array of indices of "not solid pixels". </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//        . static Texture2D FindEmptyCells(VolumeTree tree, IntVector2 startPosition, int fullHeight, int fullWidth, int height, int width, int scale, out List&lt;IntVector2&gt; result, out List&lt;int&gt; indexes) { var texture = new Texture2D(fullWidth, fullHeight, Core.Render.Utils.GetSupportsFormat(TextureFormat.Alpha8), false, true); texture.filterMode = FilterMode.Point; texture.wrapMode = TextureWrapMode.Clamp; result = new List&lt;IntVector2&gt;(); indexes = new List&lt;int&gt;(); Color[] mask = new Color[fullWidth * fullHeight]; var point = startPosition; int index = 0; int fullIndex = 0; for (int y = 0; y &lt; fullHeight; ++y) { point.x = startPosition.x; for (int x = 0; x &lt; fullWidth; ++x) { if (tree.Test(point)) { mask[fullIndex].a = 0; ++point.x; ++fullIndex; if (y % scale == 0 &amp;&amp; x % scale == 0) ++index; continue; } mask[fullIndex].a = 1; if (y % scale == 0 &amp;&amp; x % scale == 0) { result.Add(point); indexes.Add(index); ++index; } ++point.x; ++fullIndex; } ++point.y; } texture.SetPixels(mask); texture.Apply(); return texture; }</span></span></code> </pre> <br></li></ol></div></div><br><h2 id="nepryamoe-osveschenie">  Indirect lighting </h2><br><p>  Direct rays are clearly not enough: it will be too dark in the rooms of the castle, and the sharp borders are clearly visible.  We remember buzzwords, like raytracing, and understand how much time it takes to use these buzzwords.  On the other hand, because any re-reflected beam comes from somewhere on the map, and we have just built all the direct lighting!  We expand the array and store the whole structure there: </p><br><ol><li>  "Direct" brightness; </li><li>  "Indirect" brightness; </li><li>  The vector of intersection indices (The usual vector of integers. It can be optimized and immediately create an array of size N, and store the actual number in a separate variable). </li></ol><br><p>  We will remake <em>the direct illumination algorithm by</em> adding collision data: </p><br><pre> <code class="tex hljs">  : * ,    .   -    ; *  N          œÄ / N ; *   : *      : *   ; *         (  ); *      *  C  ,      ; *      C / N.</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Finally, the source!</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> CellInfo { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> directIllumination; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> indirectIllumination; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2[] normals; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2[] collisions; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> collisionsCount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CellInfo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> directions</span></span></span><span class="hljs-function">)</span></span> { directIllumination = <span class="hljs-number"><span class="hljs-number">0</span></span>; indirectIllumination = <span class="hljs-number"><span class="hljs-number">0</span></span>; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2[directions]; collisions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2[directions]; collisionsCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CellInfo[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateDirectIllumination</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">VolumeTree tree, List&lt;IntVector2&gt; points, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; indexes, IntVector2 startPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> directionsCount</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DISTANCE_RATIO = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NORMAL_RATIO = <span class="hljs-number"><span class="hljs-number">2.0f</span></span> / scale; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> COLLISION_RATIO = <span class="hljs-number"><span class="hljs-number">1.0f</span></span> / scale; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CellInfo[width * height]; Vector2[] directions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2[directionsCount]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> distance = Mathf.Sqrt(height * height + width * width) * scale * DISTANCE_RATIO; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; directionsCount; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = i * Mathf.PI / directionsCount * <span class="hljs-number"><span class="hljs-number">2</span></span>; directions[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(Mathf.Cos(angle), Mathf.Sin(angle)) * distance; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, count = points.Count; i &lt; count; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> point = points[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellIndex = indexes[i]; result[cellIndex] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CellInfo(directionsCount); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> collisionIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; directionsCount; ++j) { <span class="hljs-comment"><span class="hljs-comment">// TODO        float collisionX = 0; float collisionY = 0; int normalX = 0; int normalY = 0; if (tree.Raycast(point.x, point.y, point.x + directions[j].x, point.y + directions[j].y, ref collisionX, ref collisionY, ref normalX, ref normalY)) { result[cellIndex].normals[collisionIndex].Set(normalX * NORMAL_RATIO, normalY * NORMAL_RATIO); result[cellIndex].collisions[collisionIndex].Set(collisionX * COLLISION_RATIO, collisionY * COLLISION_RATIO); ++collisionIndex; } } result[cellIndex].directIllumination = 1 - (float)collisionIndex / directionsCount; result[cellIndex].collisionsCount = collisionIndex; } return result; }</span></span></code> </pre> <br><blockquote>  * Normals are needed for a simple reason: the intersection point returned by a raycast is in the wall.  We need to step aside to get the coordinates of the pixel nearest the wall. <br><br>  * I could not find the raycast method for the region tree, so I share my work with them: <br><br>  1. Take the node (initially - the root) and find the intersection with it using the <a href="https://gist.github.com/ChickenProp/3194723">Liang-Barsky</a> algorithm; 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2. Of the four descendant nodes, we find the one to which the nearest intersection point belongs; <br><br>  2.1.  If the node is a solid sheet, we return the coordinates of the intersection point and the normal; <br>  2.2.  If the node is not a sheet, go down below, starting with step 1; <br><br>  3. Find the far point of intersection of the line with the node descendant (the same algorithm Liang-Barsky).  We find another descendant to which this point belongs (i.e., if we first hit the upper left node and the straight line is vertical, then now it will be the lower left corner).  We continue with step 2.1. <br><br>  If it is simpler, we check the intersections of the segment with squares, ranging from the largest to the smallest, and sort them in proximity to the beginning of the beam, until we hit a solid node. <br></blockquote></div></div><br><p>  We now have enough information to calculate any number of reflections: if <br>  the beam went into the sky, we get direct illumination, otherwise - indirect from the intersection point. </p><br><p>  This is how <em>the indirect lighting algorithm</em> turns out: </p><br><pre> <code class="tex hljs">*    A: *      M; *   ,    A: *      B   ; *     " "  A. *    A: *   " "   " "   1 / M; *   " ".</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">And now in the form of code.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateIndirectIllumination</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;IntVector2&gt; points, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; indexes, CellInfo[] info, IntVector2 startPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> directionsCount</span></span></span><span class="hljs-function">)</span></span> { Vector2 floatStartPosition = startPosition.ToPixelsVector() / scale; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, count = points.Count; i &lt; count; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> point = points[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellIndex = indexes[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pixelInfo = info[cellIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pixelInfo.collisionsCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> indirectIllumination = directionsCount - pixelInfo.collisionsCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, collisionsCount = pixelInfo.collisionsCount; j &lt; collisionsCount; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collisionPoint = pixelInfo.collisions[j] + pixelInfo.normals[j] - floatStartPosition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = Mathf.RoundToInt(collisionPoint.x); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = Mathf.RoundToInt(collisionPoint.y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || x &gt;= width || y &gt;= height) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = x + y * width; indirectIllumination += info[index].directIllumination; } info[cellIndex].indirectIllumination = indirectIllumination / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)directionsCount; } }</code> </pre> </div></div><br><img src="https://habrastorage.org/files/41f/813/cad/41f813cadb7e46da80e310908b7c6bf0.png"><br><p>  <em>Demonstration of indirect lighting.</em>  <em>We collect from the collisions already calculated direct lighting.</em> </p><br><p>  The most important thing is that now, instead of a raycast operation on a region tree, we just need to take the brightness value in the array: this way we will get one reflection.  Of course, this method is only suitable for pixelart: you don‚Äôt need to consider normals or take care of artifacts that occur. </p><br><p>  See what results this algorithm gives: </p><br><img src="https://habrastorage.org/files/c10/ab4/bb4/c10ab4bb4ec146b29340a658920cd98c.png"><br><p>  <em>The first reflection.</em> </p><br><img src="https://habrastorage.org/files/e4c/973/452/e4c973452e7947a8b11fef2253699776.png"><br><p>  <em>The third reflection.</em> </p><br><img src="https://habrastorage.org/files/1fe/d5f/11a/1fed5f11a58947ec812eb51ec8a069ac.png"><br><p>  <em>Seventh reflection.</em> </p><br><img src="https://habrastorage.org/files/51c/395/4fa/51c3954fa3b94f8fbadbe50299312887.png"><br><p>  <em>The finished result for the background walls.</em> </p><br><p>  Pretty noisy picture is obtained.  In fact, after applying such lighting to real textured objects, the noise is almost invisible.  In addition, high-frequency noise will disappear when using scale&gt; 1. </p><br><h2 id="osveschenie-sten">  Wall lighting </h2><br><p>  Here are just the walls in the current texture black.  <em>"Of course," the</em> bore, distant from gamedev, pixelart and the sense of beauty, will object, <em>"It's not the walls, but the cut of three-dimensional walls in two-dimensional space. And inside the walls, as you know, it's dark."</em>  .  Thank you bore and continue the experiments.  Let's try not to darken the walls at all: </p><br><img src="https://habrastorage.org/files/c3e/2a1/8f9/c3e2a18f95a64743b23587eac03a8994.png"><br><p>  <em>Walls without lighting.</em> </p><br><p>  In the first case, the result looked beautiful only under the ground, in the second - on the surface.  It is necessary to adaptively change the brightness of the walls, depending on the environment. </p><br><blockquote>  And now the story of a single file.  After many hours of thinking and walks, an exceptional beauty came to my mind, which included adding new methods to a region tree, finding the nearest point not belonging to the wall, and so on.  I implemented this code, having spent all the weekend on it, optimized it as I could.  This monster was calculated for about a minute and still did not look perfect.  At some point, I decided to hide the flaws of the algorithm, a little Gauss erosion result.  It was perfect!  I made some changes and minor changes for some time.  Until I came across an error in the condition from which it followed that the results of my wonderful algorithm were sent straight to the garbage collector, and the final pixels were affected only by blurring.  But the picture remained the same beautiful. <br><br>  But now it is the fastest stage of the global coverage.  :) </blockquote><p>  We translate our arrays into texture, where in one channel there will be pixel brightness, and the other is the belonging to the wall.  Blur the wall pixels on the GPU using a simple shader (simple arithmetic average with neighbors) in a loop. </p><br><img src="https://habrastorage.org/files/9fa/804/c2a/9fa804c2a5c146768de8a9a9a3511053.png"><br><p>  <em>Blurred walls (scale = 2).</em> </p><br><img src="https://habrastorage.org/files/686/718/de7/686718de7fef4df1ba1f399f26197853.png"><br><p>  <em>Here is a misunderstanding, if you apply the lighting.</em> </p><br><p>  In the first article of the cycle, I talked about the basics of pixelart.  I will add one more important axiom: no gradients in the spirit of photoshop!  This turns a neat picture into soap and plasticine.  Against the backdrop of the gradients are not as striking as on the walls.  Let's go through the texture with another shader: for each pixel of the wall using a simple rounding (with the coefficient of the shader parameters) we get several brightness gradations.  Of course, the resulting transitions are far from ideal - the artist's hand did not move the pixels, removing the curves of the ladder, but it suits us. </p><br><img src="https://habrastorage.org/files/598/f6e/985/598f6e9850a84a898b2937fd5e1baa6b.png"><br><p>  <em>Light mask with low sampling (scale = 2).</em> </p><br><img src="https://habrastorage.org/files/2f0/aac/162/2f0aac1626ed45d58044f24da6f476fe.png"><br><p>  <em>The result of applying the mask.</em> </p><br><img src="https://habrastorage.org/files/433/4ca/451/4334ca45115b484d990facf01edbaf5d.png"><br><p>  <em>The result of applying the mask when using real textures.</em> </p><br><p>  Notice how well the noise and flaws of the lighting are hidden when we apply it to real textures.  If global illumination were dynamic, the human brain, which perfectly recognizes movement, would immediately find jambs. </p><br><p>  So, we have global coverage! </p><br><p>  The advantages of this algorithm are: </p><br><ul><li>  <strong>Customizable</strong>  By changing the number of rays, the number of reflections or the size of the texture, we can find a balance between quality and speed; </li><li>  <strong>Multithreading</strong>  In theory (in practice, hands have not yet reached), the algorithm should be well parallelized; </li><li>  <strong>Realism.</strong>  In the caves it is dark, in the rooms it is twilight, as we wanted; </li><li>  <strong>Easy to use.</strong>  Create a new level, run the game and everything. </li></ul><br><p>  And cons: </p><br><ul><li>  <strong>Work speed</strong>  About two seconds to calculate the lighting when loading level; </li><li>  <strong>Dependence on the size of the map.</strong>  Increasing the map by two times will also slow down the calculation of the light by two times (a funny moment: the more we fill the level with walls, the faster the light will be calculated); </li><li>  <strong>Noises</strong>  Perhaps some of the maps will have visible lighting artifacts. </li></ul><br><h2 id="dekali">  Decals </h2><br><blockquote>  Although the main topic of the article is revealed, this is not a reason to finish tapping the keys.  Most likely, this is the last article about lighting.  So, it makes sense to tell you about some new chips that were added after the refactoring of the game. </blockquote><p>  Decals ("decal" - "decal") are a great way to make the game more lively without sacrificing performance.  The idea is simple: a rectangle with a texture, like a real decal, is superimposed on a certain surface (wall, floor, etc.).  This may be a trail from a bullet, some kind of garbage, an inscription, whatever. </p><br><p>  But we will use decals a little differently: as arbitrary light sources.  Since we generate the texture with lighting, we can add objects of arbitrary shape to it.  And these objects will immediately begin to glow!  So you can easily realize the effects of luminescence, thermal radiation. </p><br><p>  But there are two important points: </p><br><ol><li>  In addition to the object itself, you need to add bloom - as a soft diffuse effect; </li><li>  You can not draw an object and bloom equally on the background and walls: so you will lose the feeling of depth.  Instead, we will draw the sprite either on the walls or on the background only (remember the hardness mask from global illumination?).  And the power of the bloom will also change depending on the layer. </li></ol><br><p>  In essence, the algorithm is simple: </p><br><p>  Let's divide all decals (for example, using Unity3D tags) into foreground and background decals: </p><br><ol><li>  We draw the sprite with the desired brightness and color in the texture, taking into account p.3 or p.4; </li><li>  Add the effect of "bloom" (another blur), taking into account p.3 or p.4; </li><li>  Foreground decals: <br><ul><li>  Drawn only on wall pixels; </li><li>  Bloom effect is stronger on wall pixels and weaker on background pixels. </li></ul></li><li>  Background decals: <br><ul><li>  Drawn only on background pixels; </li><li>  Bloom effect is stronger on background pixels and weaker on wall pixels. </li></ul></li></ol><br><p>  The example will be clearer: </p><br><img src="https://habrastorage.org/files/427/626/9a4/4276269a45774e0193a05295b5008419.png"><br><p>  <em>Find the old sprite grass.</em> </p><br><img src="https://habrastorage.org/files/6e8/f4b/f8a/6e8f4bf8a6fe4207a6cab03ff393c3ef.png"><br><p>  <em>Position the "grass" so that it covers the ends of the walls.</em> </p><br><img src="https://habrastorage.org/files/545/326/6d7/5453266d78bc44f5ad721a4864c42c59.png"><br><p>  <em>Render the sprite only in the lighting texture.</em> </p><br><img src="https://habrastorage.org/files/ae4/bc8/d18/ae4bc8d18de9498b9ac34bf276c08dd6.png"><br><p>  <em>Add a glow on the wall.</em> </p><br><img src="https://habrastorage.org/files/f76/5df/772/f765df7721ec4536943c8d7b74bc30d1.png"><br><p>  <em>Add a glow on the background.</em> </p><br><p>  And we get an interesting radioactive mold. <br>  And you can also make hot walls, unique luminous objects and much more. </p><br><img src="https://habrastorage.org/files/556/d6b/9f2/556d6b9f291d4ddaa911da410121a237.png"><br><p>  <em>The wall glows with happiness.</em> </p><br><h2 id="dorabotki-dinamicheskogo-osvescheniya">  Improvements to dynamic lighting </h2><br><blockquote>  This is a very short section and the whole first person.  Finally, we got our hands to render only visible light sources.  All sources that do not fall into the camera are not rendered and do not eat precious fps. <br><br>  Moreover, it turned out that light sources make up an excellent hierarchy: <br><br>  1. SkyLight.  Background lighting where brightness and color are important; <br>  2. SunLight.  Point source of light without attenuation.  Important brightness, color and position; <br>  3. PointLight.  Point source of light c attenuation.  Important brightness, color, position and radius; <br>  4. FlashLight.  Flashlight with a conical beam.  The brightness, color, position, radius, angle of rotation and width of the beam are important. <br><br>  And there was an opportunity to create any other light sources, inheriting from the base ones. <br></blockquote><br><img src="https://habrastorage.org/files/bc8/4c3/849/bc84c3849f484a018664e8b6caa58650.png"><br><p>  <em>The above light sources.</em> </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Now our project has realistic light, luminosity effects and updated dynamic light sources.  Compare with the image from the first article, not so little difference, right? </p><br><img src="https://habrastorage.org/files/a32/3eb/731/a323eb731d8746c4b2da5d61f2af0ffb.png"><br><p>  <em>Image from the beginning of this article.</em> </p><br><img src="https://habrastorage.org/files/49f/788/cc1/49f788cc14814b2098a07fddf70aed72.png" alt="image"><br><p>  <em>Image from the first part of the cycle.</em> </p><br><p>  And the most interesting thing: now that the lighting is ready and the algorithms and structure of the project have been refactored, it's time to write about the water! </p><br><p>  Thanks for reading and comments on the previous parts and to the next article! </p></div><p>Source: <a href="https://habr.com/ru/post/313776/">https://habr.com/ru/post/313776/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313764/index.html">Django User Model Extension Strategies</a></li>
<li><a href="../313768/index.html">Adobe has released an emergency update for Flash Player.</a></li>
<li><a href="../313770/index.html">DocFactor: technical documentation conference</a></li>
<li><a href="../313772/index.html">Application development for KolibriOS. Overview of options</a></li>
<li><a href="../313774/index.html">Login or Log in?</a></li>
<li><a href="../313780/index.html">Instant site diagnostics. Service Overview HostTracker Part 4</a></li>
<li><a href="../313782/index.html">Network security technologies at OSI level 2. Part 1</a></li>
<li><a href="../313784/index.html">The rules of bad and good tone in programming - expert opinions</a></li>
<li><a href="../313786/index.html">The minimum Hello Word limit on AVR is 0 bits.</a></li>
<li><a href="../313788/index.html">Collect cats in Android 7 Nougat (not only)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>