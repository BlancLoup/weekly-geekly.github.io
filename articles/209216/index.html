<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Additional physical modeling techniques in Teradata</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing to publish materials about the techniques of physical modeling in the Teradata DBMS, we, as promised in the last article, want to talk abou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Additional physical modeling techniques in Teradata</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/company/teradata/blog/209208/">Continuing to publish</a> materials about the techniques of physical modeling in the Teradata DBMS, we, as promised in the last article, want to talk about additional techniques that are not directly related to ordinary indices (although in this article we will touch on specific types of indices that should be known). <br><br>  In addition to the usual indexes, Teradata has a number of specific and sometimes fine techniques that can be used in physical modeling.  We give a description of most of the techniques, and if you have any questions or desire to learn more, we will be happy to answer in the comments. <br><a name="habracut"></a><br><h5>  Join index </h5><br>  This is a special kind of index that is a saved and updated result of a SQL query.  This index has the name because the query may include joining tables.  But there may be no table joins - in this case the index is called the Single Table Join Index.  Such a technique should be considered if there are frequent queries for joining several tables and / or performing aggregations.  After receiving a SQL query from a user, for which you can use only Join Index data, the optimizer will most likely prefer this method.  There are also ways to let the optimizer understand how to join the Join Index and the base table if, for example, the index does not have enough fields that the user requested.  This is done by including the ‚ÄúROWID‚Äù field in the Join Index - then the DBMS can, if necessary, perform an effective connection of the index with the base table. <br><br>  Indexes can be limited not only by width (the number of columns of the base table), but also by depth.  When creating a Join Index, you can specify the condition ‚ÄúWHERE‚Äù, and then only necessary data will be included in the index.  This method is suitable for optimizing queries that have quite specific filtering conditions.  Then they can be included in the index and thus reduce its volume and minimize the resources expended.  But it must be remembered that this index will be considered by the optimizer only when processing those queries that have the same (or more stringent) filtering conditions as when creating the index. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition, since the Join Index is almost the same as the table, it is possible to build indexes on it and collect statistics. <br><br><h5>  Hash nusi </h5><br>  By default, the NUSI index is distributed across AMPs in the same way as the base table on which it is built is distributed.  This gives an even distribution of the index across the AMPs and ease of use.  Inside each AMP, NUSI is sorted by hash value from all its columns.  But it is possible to create an index in such a way that it is sorted by the hash value of a specific field included in the index.  Such an index will significantly optimize query performance with equality conditions.  The value compared with the index column is then hashed, and this hash is quickly searched for in the index (which is sorted by it). <br><br><h5>  Value Ordered NUSI </h5><br>  But besides sorting by hash, you can set the index to be sorted by the value of a specific field.  Such indices allow to optimize well queries that have ranges or inequality conditions as filter conditions.  When creating such an index, it is sorted by the specified field and saved to disk in this form.  I think the advantages of searching ranges by sorted list do not need comments. <br><br><h5>  Intentional "skewed" data </h5><br>  The MPP system with the Shared Nothing architecture shows the best performance with the most even distribution of data.  This issue has received much attention in this and other articles.  But there are times when it makes sense to create a ‚Äúskew‚Äù of data intentionally, and this will have a positive impact on performance. <br><br>  For example, you have a system with 144 amps.  And there is a small directory in which, say, 200 records distributed more or less evenly.  When you fetch data from the directory, all 144 AMPs turn to their disks to extract one or two records each.  Does it make sense to strain so many AMPs for such a trivial operation?  In such situations, you can create an artificial "bias" of data - to do this, you need to add a blank column to the directory, making it the Primary Index, and fill it with the same value.  In this case, when accessing the table, only one AMP will work, which will quickly extract all records and redistribute between all other AMRs.  This approach cannot be recommended for use in all such cases, just keep in mind that this can be done.  And it will give a benefit in your particular case or not - is a separate question. <br><br><h4>  Referential integrity </h4><br>  Teradata, like other relational DBMSs, allows support for referential integrity.  But Teradata has a number of features that we want to mention.  The first feature is that the columns of the parent table to which reference is made do not have to be declared as Primary Key.  Teradata only requires that these columns form a unique index, primary or secondary.  Although the definition of PK remains an affordable option, because any constraint to the uniqueness of Teradata physically embodies in the form of a unique index. <br><br>  The remaining features relate to individual types of referential integrity. <br><br><h5>  Standard RI </h5><br>  Standard referential integrity checking.  Executed for each row to be inserted, modified or deleted.  Added by the following command: <br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Employee <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> fk1 <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (Dept) <span class="hljs-keyword"><span class="hljs-keyword">REFERENCES</span></span> Department (Dept);</code> </pre> <br>  A feature of the implementation of this type of referential integrity in Teradata is that when it is added to existing tables, even in the event of a violation of conditions, a restriction will be created and activated (you will not be able to perform operations that violate referential integrity).  At the same time, Teradata will automatically create an error table with the name of the child table, supplemented by the suffix ‚Äú_0‚Äù, into which it will place the records of the child table, which at the time of the inclusion of referential integrity did not meet its conditions.  In the future, the user is responsible for solving problems with these links and removing the error table.  Such an implementation makes it possible, without waiting for the resolution of table binding problems to enable and activate referential integrity, to easily detect problems (there is an error table ‚Äî there are problems), their scale and take corrective measures (all problem lines in the error table). <br><br><h5>  Batch RI </h5><br>  The implementation of this type of referential integrity in Teradata does not have any special features.  It is done after the completion of the DML command, the detection of violations leads to rollback of the entire transaction, the presence of violations at the time of creation leads to an error.  Added by the following command: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Employee <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> fk1 <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (Dept_Number) <span class="hljs-keyword"><span class="hljs-keyword">REFERENCES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPTION</span></span> Department (Dept_Number);</code> </pre><br><br><h5>  Soft ri </h5><br>  This type of referential integrity is specific to Teradata.  Any of the types described above, helping the optimizer, at the same time increases the load on the system, honestly performing checks.  Soft RI can also be called ‚Äútrusted referential integrity‚Äù, because its addition to tables does not lead to the inclusion of a mechanism for controlling data relatedness.  Creating this restriction will only add to the data dictionary information about how the tables A and B are interconnected. For what purpose, you will say.  With good data quality, you will give more information to the optimizer and, at the same time, eliminate costly referential integrity checks.  Added by the following command: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Employee <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> fk1 <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (Dept_Number) <span class="hljs-keyword"><span class="hljs-keyword">REFERENCES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPTION</span></span> Department (Dept_Number);</code> </pre><br><br><h5>  What does RI give to the optimizer? </h5><br>  The presence of a referential integrity constraint defined for tables (of any of the above types) allows the optimizer to perform Join Elimination, that is, not to join the tables when executing a query that does not contain portions of the parent table column in the SELECT or WHERE, for example <br>  We have a View <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> EmpDept <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> Employee_Number, Last_Name, First_Name, E.Dept_Number, Dept_Name <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employee E <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Department D <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> E.Dept_Number = D.Dept_Number;</code> </pre><br>  where Department is the parent and Employee is the child table, between which referential integrity is defined. <br><br>  When executing the next request, the connection will not be executed, since  it does not refer to the columns of the parent table: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> Employee_Number, Last_Name, Dept_Number <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> EmpDept;</code> </pre><br>  <i>Note: when using Soft RI, be sure of the quality of your data, otherwise the exclusion of a connection may lead to an incorrect result.</i> <br><br><h4>  Data compression </h4><br>  As mentioned above, one of the main tasks of optimizing the physical data model is to reduce the number of I / O operations.  If compression is applied to the data, it takes up less disk space and is read in fewer block reads.  But after that the data will have to be decompressed, which will require additional resources. <br><br>  Data compression can be implemented both software and hardware.  We will not consider hardware compression in the framework of the topic about physical design; we‚Äôll dwell on software. <br><br>  It should be noted that the use of compression makes sense for those tables that occupy a truly significant amount.  If the table is so small, you are unlikely to notice the significant benefits of using compression. <br><br><h5>  Compressing null values </h5><br>  We agree immediately - in this section, the empty value means only NULL.  Philosophical debates that NULL is ‚Äúnothing‚Äù, and not null, are welcome, but in the comments. <br><br>  If you have a table with a large percentage of NULLs in fixed-size columns, then, given the large number of entries in the table, it makes sense to think about compressing NULLs.  This is done very simply - in the DDL-code for creating a table (or ALTER'e) after the attributes of the column the word "COMPRESS" is indicated.  Thus, the system will analyze the table and for all columns where the NULL value is present, put down a special bit, meaning: ‚Äúhere was NULL, but we squeezed it, and it was gone‚Äù. <br><br><h5>  Compression of specific values </h5><br>  So often it happens that in addition to NULLs there are frequently encountered values ‚Äã‚Äãin the tables.  For example, it could be a surname leading from a statistical point of view ‚Äî say, Ivanov.  Any field (especially string) for which statistically frequent values ‚Äã‚Äãcan be distinguished is a good candidate for compression.  There may be exceptions - for example, you decide to keep the client status as text (do not ask why).  The client table for HD is, as a rule, tens of millions of records.  Having just a limited set of statuses: ‚ÄúActive‚Äù, ‚ÄúInactive‚Äù, ‚ÄúBlocked‚Äù, you can apply compression and reduce costs for tens of millions of entries (in our example - from VARCHAR (16) to two bits). <br><br>  The list of values ‚Äã‚Äãfor compression can be specified for each column separately.  Such lists are stored in the table headings, and when accessing the table, the compressed values ‚Äã‚Äã(flags) are replaced with real values.  The additional load from this operation is so small that it can be neglected. <br><br>  When designing models, pay attention to the data demographics that have been mentioned many times in this article.  If the table contains millions of records and some values ‚Äã‚Äãcan be compressed, then having done this, you will speed up queries to the table. <br><br><h5>  Block Level Compression (BLC) </h5><br>  Block-level compression, or BLC, is a type of compression that is applied to entire data blocks before they are written directly to discs.  This type of compression can be applied either to the entire system or to individual tables.  With this type of compression, the disk space gain comes at the expense of increasing the load on the processor, so in this case it is important to understand how this suits you. <br><br>  After enabling this type of compression for the table, it can no longer be disabled, since it affects the physical appearance of the blocks, you will have to rewrite the table aside, but without compression, and then replace it completely. <br><br><h5>  Columnar compression </h5><br>  As we described in one of the previous articles ( <a href="http://habrahabr.ru/company/teradata/blog/170321/">Column and Hybrid Storage of Records in the Teradata DBMS</a> ), the Teradata DBMS supports both column storage of records and string storage.  When designing a physical data model, one must take the best from each of the options.  When using a column storage table, it is possible to use automatic compression.  Its algorithm is based on the fact that if a data block contains values ‚Äã‚Äãof a single column, then the probability of their compression is quite large (especially if these are non-unique values).  The values ‚Äã‚Äãof one column are compressed at the container level (see the article above).  If the system determines that compression does not give a gain for a given value, then it simply does not compress it, if it sees that it makes sense to compress, it checks which of the built-in compression algorithms will give the greatest gain and use it.  For example, if you decide to enable automatic column compression across the ‚Äúbalance‚Äù field, you are unlikely to get a big win - each client / subscriber, as a rule, has his own balance, close to the unique one. <br><br>  For the creator of the model, this means only one thing: if you decide to make a table with a column type of storage, then it makes sense to you.  And if so, then analyze the demographics - perhaps for a number of columns you want to enable automatic compression. <br><br><h5>  What to choose? </h5><br>  The table below will help you decide on the type of compression. <br><table border="1"><tbody><tr><td></td><td>  <b>Compression of specific values</b> </td><td>  <b>Block compression</b> </td><td>  <b>Column compression</b> </td></tr><tr><td>  <b>Ease of use</b> </td><td>  Just apply for well-studied data. </td><td>  Turned on and forgotten </td><td>  Turned on and forgotten </td></tr><tr><td>  <b>Need an analysis?</b> </td><td>  Need to analyze data demographics. </td><td>  It is necessary to analyze the space gain in exchange for CPU costs. </td><td>  It is necessary to understand for which columns of the table to enable compression, and for which it will not make sense </td></tr><tr><td>  <b>Flexibility</b> </td><td>  Works for a large number of situations and data types </td><td>  Can be combined with other types of compression. </td><td>  Can only be used for column storage tables. </td></tr><tr><td>  <b>Influence</b> </td><td>  Minimum impact on CPU consumption </td><td>  Influences CPU </td><td>  For each line it is determined whether it was compressed or not. </td></tr><tr><td>  <b>Application area</b> </td><td>  Replacing specific values </td><td>  Compression of all data </td><td>  Compression of a set of columns from the entire table </td></tr></tbody></table><br><h4>  The result of the work on the physical design </h4><br>  The result of the physical modeling work should be a set of DBMS objects, which, at the minimum cost of system resources, will provide the required performance for the main user load: <br><ul><li>  Primarily, these are tables (including storage attributes, such as, for example, compression parameters) and primary indexes (including partitioning parameters), for whose support no additional consumption of system resources is required.  Ideally, primary indexes should cover the basic need for access to the rows of the tables for which they are created, and promote the maximum use of local table join scripts on AMPs.  The creation of primary indexes is included in the compulsory physical design program for the Teradata platform. </li><li>  Secondary indexes, designed to provide alternative ways to access the required rows of tables.  Unlike the primary indexes, the system has to spend additional resources on their support, therefore, when deciding on their creation, it is necessary to weigh the benefits of their use and the expenditure of resources on their support.  Unused secondary indexes should be removed. </li><li>  Third, these are other objects that need to be created to achieve the desired performance.  Such objects include, for example, various types of join- and hash-indices. </li></ul><br>  Throughout life, the physical model should be subject to regular revision.  This is connected not only with a change in the demographics of the data, but also with changes in the nature of the load, extension of the model, etc. <br><br><h4>  Summing up </h4><br>  The attentive reader has already understood that the process of physical design of the data model is the process of preparation (before the model is implemented) and the process of fine-tuning (improvement after the implementation).  You can not 100% guess with the load and data, but 50% - you can.  The next time it will be possible to 60%, and with time, it will probably turn out to be 80%.  Thus, the grinding will take less time.  The skill of designing physical models increases with experience, therefore, the more experiments and projects you implement, the better you will understand how to work with models in the future. <br><br>  Comprehend the basics and do not be afraid to experiment.  We hope that the Teradata DBMS data processing mechanisms described in this article, the index selection criteria and the physical modeling techniques will be useful for specialists already working with our database and will cause interest to those who are yet to come. <br><br>  And, as always, we are ready to answer in the comments any questions you may have. </div><p>Source: <a href="https://habr.com/ru/post/209216/">https://habr.com/ru/post/209216/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209206/index.html">Build Android under Ubuntu Linux</a></li>
<li><a href="../209208/index.html">Physical design of storage structures in Teradata DBMS</a></li>
<li><a href="../209210/index.html"><Extended until February 27!> We are announcing a competition to develop a layout for a 3d kidney print.</a></li>
<li><a href="../209212/index.html">Migrating virtual machines on the fly without vMotion with Veeam Backup & Replication</a></li>
<li><a href="../209214/index.html">Today is the last day when you can use free coupons on COLT</a></li>
<li><a href="../209218/index.html">The best time to learn microcontrollers</a></li>
<li><a href="../209220/index.html">What unites NASA, Oculus Rift and Kinect 2?</a></li>
<li><a href="../209224/index.html">Happy Birthday, Wikipedia!</a></li>
<li><a href="../209226/index.html">How to move from java to scala in your project</a></li>
<li><a href="../209228/index.html">Creating a client MVC application using RequireJS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>