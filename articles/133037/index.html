<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Once again about finding prime numbers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This note discusses sieve algorithms for finding primes. We will consider in detail the classical sieve of Eratosthenes, the features of its implement...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Once again about finding prime numbers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/07142edf/ac614640/ae385f5c/83cf23cb.jpg" alt=" ` ` ( )" title="Sculpture `Sieve Eratosthenes` (Stanford University)" align="left">  This note discusses sieve algorithms for finding primes.  We will consider in detail the classical <b>sieve of Eratosthenes, the</b> features of its implementation in popular programming languages, parallelization and optimization, and then we will describe the more modern and fast <b>Atkin sieve.</b>  If the material on the sieve of Eratosthenes is intended primarily to protect beginners from regular walking on a rake, then the Atkin sieve algorithm was not previously described in Habrahabr. <br><br>  <i>The picture shows a sculpture of an abstract expressionist Mark Di Suvero "Sieve of Eratosthenes", <a href="http://g.co/maps/ksdse">installed</a> on the campus of Stanford University</i> <a name="habracut"></a><br><br><h4>  Introduction </h4><br>  Recall that a number is called <i>simple</i> if it has exactly two different divisors: the unit and itself.  Numbers with a greater number of divisors are called <i>composite.</i>  Thus, if we can factor numbers into factors, we can also check numbers for simplicity.  For example, something like this: <br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isprime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n==<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 1 -    return false; //     2  sqrt(n) for(d=2; d*d&lt;=n; d++){ //   ,   if(n%d==0) return false; } //    ,   return true; }</span></span></code> </pre>  (Hereinafter, unless otherwise specified, provides JavaScript-like pseudocode) <br>  The running time of such a test is obviously <i>O</i> ( <i>n</i> <sup>¬Ω</sup> ), that is, it grows exponentially with respect to the bit length <i>n</i> .  This test is called <i>brute force check.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Quite unexpectedly, there are a number of ways to test the simplicity of a number without finding its divisors.  If the polynomial factorization algorithm still remains an unattainable dream (which is what RSA encryption is based on), then the <acronym>AKS</acronym> [ <a href="http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf">1</a> ] test for simplicity works out in 2004 in a polynomial time.  With various effective tests for simplicity can be found on [2]. <br><br>  If now we need to find all simple ones on a fairly wide interval, then the first impulse will probably be to test each number from the interval individually.  Fortunately, if we have enough memory, we can use faster (and simple) <i>sieve algorithms.</i>  In this article we will discuss two of them: the classical <i>sieve of Eratosthenes,</i> known to the ancient Greeks, and the <i>Atkin sieve, the</i> most advanced modern algorithm of this family. <br><br><h4>  Sieve of Eratosthenes </h4><br>  The ancient Greek mathematician Eratosthenes proposed the following algorithm for finding all simple numbers that do not exceed a given number <i>n.</i>  Take an array S of length <i>n</i> and fill it with units ( <i>mark as unclosed</i> ).  Now we will successively look at the elements of S [ <i>k</i> ], starting with <i>k</i> = 2. If S [ <i>k</i> ] = 1, then fill in with zeroes ( <i>cross out</i> or <i>drop out</i> ) all subsequent cells whose numbers are multiples of <i>k.</i>  As a result, we obtain an array in which the cells contain 1 if and only if the cell number is a prime number. <br><br>  You can save a lot of time if you notice that, since a composite number has number less than <i>n,</i> at least one of the divisors does not exceed <img src="http://1450822640145370764766">  , the sowing process is enough to finish on <img src="http://habrastorage.org/storage1/92f1abf8/9f21e8ea/36ef5b5f/89689ac8.png">  .  Here is an animation of the sieve of Eratosthenes, taken from Wikipedia: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage1/6b8f3222/4acc55aa/91db537b/0696d73c.gif"></div><br><br>  Some more operations can be saved if, for the same reason, to begin eliminating multiples of <i>k,</i> starting not with <i>2k,</i> but from the number <i>k</i> <sup>2</sup> . <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage1/aaedfeb9/ca14dcb9/13d60baf/7e201ac1.gif"></div><br><br>  The implementation will take the following form: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sieve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ S = []; S[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 -    //    for(k=2; k&lt;=n; k++) S[k]=1; for(k=2; k*k&lt;=n; k++){ //  k -  ( ) if(S[k]==1){ //    k for(l=k*k; l&lt;=n; l+=k){ S[l]=0; } } } return S; }</span></span></code> </pre><br>  The effectiveness of the sieve of Eratosthenes is caused by the extreme simplicity of the internal cycle: it does not contain conditional transitions, as well as "heavy" operations like division and multiplication. <br><br>  We estimate the complexity of the algorithm.  The first crossing out requires <i>n</i> / 2 actions, the second - <i>n</i> / 3, the third - <i>n</i> / 5, etc. According to <a href="http://mathworld.wolfram.com/MertensSecondTheorem.html">the Mertens formula</a> <br><div style="text-align:center;"><img src="http://habrastorage.org/storage1/31e2cf98/4bd92ee2/2d776319/78ebea99.gif"></div><br>  so that <i>O</i> ( <i>n</i> log log <i>n</i> ) operations are required for the sieve of Eratosthenes.  The memory consumption is <i>O</i> ( <i>n</i> ). <br><br><h5>  Optimization and parallelization </h5><br>  The first sieve optimization was proposed by Eratosthenes himself: since only 2 of all even numbers is simple, then let's save half of the memory and time and write out and sow only odd numbers.  The implementation of such a modification of the algorithm will require only cosmetic changes ( <a href="http://pastebin.com/8rEqJgfC">code</a> ). <br><br>  More advanced optimization (so-called <i><a href="http://en.wikipedia.org/wiki/Wheel_factorization">wheel factorization</a></i> ) relies on the fact that all simple but 2, 3 and 5 lie in one of the following eight arithmetic progressions: 30 <i>k</i> +1, 30 <i>k</i> +7, 30 <i>k</i> +11, 30 <i>k</i> +13, 30 <i>k</i> +17, 30 <i>k</i> +19, 30 <i>k</i> +23 and 30 <i>k</i> +29.  To find all prime numbers up to <i>n</i> , we first calculate (again using a sieve) all prime numbers <img src="http://1450822640145370764766">  .  Now we will make eight sieves, each of which will include elements of the corresponding arithmetic progression, smaller than <i>n</i> , and we will sow each of them in a separate stream.  Everything, you can reap the benefits: we not only lowered memory consumption and CPU load (four times compared with the basic algorithm), but also parallelized the operation of the algorithm. <br><br>  By increasing the step of the progression and the number of sieves (for example, with a step of progression 210, we will need 48 sieves, which will save another 4% of resources) along with the growth of <i>n</i> , we can increase the speed of the algorithm by log log <i>n</i> times. <br><br><h5>  Segmentation </h5><br>  What to do if, in spite of all our tricks, there is not enough RAM and the algorithm shamelessly ‚Äúswaps‚Äù?  It is possible to replace one large sieve with a sequence of small strainers and sow each separately.  As above, we will have to first prepare a list of simple ones. <img src="http://1450822640145370764766">  That will take <i>O</i> ( <i>n</i> <sup>¬Ω-Œµ</sup> ) additional memory.  Simple, found in the process of sieving strainers, we do not need to store - we will immediately give them to the output stream. <br><br>  Do not make the strainers too small, less than the same <i>O</i> ( <i>n</i> <sup>¬Ω-Œµ</sup> ) elements.  So you will not gain anything in the asymptotics of memory consumption, but due to overhead costs you will start to lose more and more in performance. <br><br><h5>  Sieve of Eratosthenes and one-liners </h5><br>  Habrahabr previously <a href="http://habrahabr.ru/blogs/programming/120665/">published a</a> large collection of Eratosthenes algorithms in a single line in different programming languages ‚Äã‚Äã(single-line number 10).  Interestingly, all of them are in fact not the sieve of Eratosthenes and implement much slower algorithms. <br><br>  The fact is that filtering a set by the condition (for example, <pre> <code class="ruby hljs">primes = primes.select { <span class="hljs-params"><span class="hljs-params">|x|</span></span> x == prime <span class="hljs-params"><span class="hljs-params">||</span></span> x % prime != <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre>  in Ruby) or using aka list comprehensions generator lists (for example, <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> pgen (p:xs) = p : pgen [x|x &lt;- xs, x `mod` p &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre>  on Haskell) they cause exactly what the sieve algorithm is designed to avoid, namely, element-by-element checking of divisibility.  As a result, the complexity of the algorithm increases at least to <img src="http://habrastorage.org/storage1/0eb8e51e/db7f87e1/d0079457/7ef4f2c4.png">  (this is the number of filterings) multiplied by <img src="http://habrastorage.org/storage1/04a3a368/544a5d79/388eaf07/9ac719b9.png">  (the minimum number of elements of the filtered set), where <img src="http://habrastorage.org/storage1/e4f6db86/30e0f1e0/66b57b19/4f0190a7.png">  - the number of simple actions that do not exceed <i>n</i> , i.e., to <i>O</i> ( <i>n</i> <sup>3/2-Œµ</sup> ) actions. <br><br>  One-liner <pre> <code class="scala hljs">(n: <span class="hljs-type"><span class="hljs-type">Int</span></span>) =&gt; (<span class="hljs-number"><span class="hljs-number">2</span></span> to n) |&gt; (r =&gt; r.foldLeft(r.toSet)((ps, x) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ps(x)) ps -- (x * x to n by x) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ps))</code> </pre>  on Scala closer to the Eratosthenes algorithm in that it avoids divisibility checking.  However, the complexity of constructing the difference of sets is proportional to the size of the larger of them, so that the result is the same <i>O</i> ( <i>n</i> <sup>3/2-Œµ</sup> ) operations. <br><br>  In general, the sieve of Eratosthenes is difficult to effectively implement within the functional paradigm of immutable variables.  In case the functional language (for example, OCaml) allows, it is worth breaking the norms and having a variable array.  In [ <a href="http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf">3</a> ], it is discussed how to correctly implement the Eratosthenes sieve on Haskell with the help of a lazy strikeouts technique. <br><br><h5>  Sieve Eratosthenes and PHP </h5><br>  We write the algorithm of Eratosthenes in PHP.  It turns out about the following: <br><pre> <code class="php hljs">define(<span class="hljs-string"><span class="hljs-string">"LIMIT"</span></span>,<span class="hljs-number"><span class="hljs-number">1000000</span></span>); define(<span class="hljs-string"><span class="hljs-string">"SQRT_LIMIT"</span></span>,floor(sqrt(LIMIT))); $S = array_fill(<span class="hljs-number"><span class="hljs-number">2</span></span>,LIMIT<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>($i=<span class="hljs-number"><span class="hljs-number">2</span></span>;$i&lt;=SQRT_LIMIT;$i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($S[$i]===<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>($j=$i*$i; $j&lt;=LIMIT; $j+=$i){ $S[$j]=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } }</code> </pre><br>  There are two problems here.  The first one is related to the data type system and is characteristic of many modern languages.  The fact is that the most effective sieve of Eratosthenes is realized in those <acronym>PLs</acronym> where it is possible to declare a homogeneous array consistently located in memory.  Then the calculation of the address of the cell S [i] takes only a couple of processor commands.  An array in PHP is in fact a heterogeneous dictionary, that is, it is indexed by arbitrary strings or numbers and may contain data of various types.  In this case, finding S [i] becomes a much more laborious task. <br><br>  The second problem: arrays in PHP are terrible in memory overhead.  On my 64-bit system, each element of $ S from the code above eats up 128 bytes.  As discussed above, it is not necessary to keep the entire sieve in memory at once, it is possible to process it in portions, but still such expenses should be considered inadmissible. <br><br>  To solve these problems, it is enough to choose a more suitable data type - a string! <br><pre> <code class="php hljs">define(<span class="hljs-string"><span class="hljs-string">"LIMIT"</span></span>,<span class="hljs-number"><span class="hljs-number">1000000</span></span>); define(<span class="hljs-string"><span class="hljs-string">"SQRT_LIMIT"</span></span>,floor(sqrt(LIMIT))); $S = str_repeat(<span class="hljs-string"><span class="hljs-string">"\1"</span></span>, LIMIT+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>($i=<span class="hljs-number"><span class="hljs-number">2</span></span>;$i&lt;=SQRT_LIMIT;$i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($S[$i]===<span class="hljs-string"><span class="hljs-string">"\1"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>($j=$i*$i; $j&lt;=LIMIT; $j+=$i){ $S[$j]=<span class="hljs-string"><span class="hljs-string">"\0"</span></span>; } } }</code> </pre><br>  Now each element takes exactly 1 byte, and the operation time has decreased by approximately three times.  <a href="http://pastebin.com/REtUmXnd">Script for measuring speed</a> . <br><br><h4>  Sieve Atkina </h4><br>  In 1999, Atkin and Bernstein proposed a new method of sowing compound numbers, called the Atkin sieve.  It is based on the following theorem. <br><br>  <b>Theorem.</b>  Let <i>n</i> be a positive integer that is not divisible by any full square.  Then <ol><li>  if <i>n can be</i> represented as 4 <i>k</i> +1, then it is simple if and only if the number of natural solutions of the equation 4 <i>x</i> <sup>2</sup> + <i>y</i> <sup>2</sup> = <i>n</i> is odd. </li><li>  if <i>n</i> is representable as 6 <i>k</i> +1, then it is simple if and only if the number of natural solutions of the equation 3 <i>x</i> <sup>2</sup> + <i>y</i> <sup>2</sup> = <i>n</i> is odd. </li><li>  if <i>n can be</i> represented as 12 <i>k</i> -1, then it is simple if and only if the number of natural solutions of the equation 3 <i>x</i> <sup>2</sup> - <i>y</i> <sup>2</sup> = <i>n</i> , for which <i>x</i> &gt; <i>y</i> , is odd. </li></ol>  C proof can be found in [ <a href="http://www.ams.org/journals/mcom/2004-73-246/S0025-5718-03-01501-1/S0025-5718-03-01501-1.pdf">4</a> ]. <br><br>  From elementary number theory it follows that all simple, large 3, have the form 12 <i>k</i> +1 (case 1), 12 <i>k</i> +5 (again 1), 12 <i>k</i> +7 (case 2) or 12 <i>k</i> + 11 (case 3) . <br><br>  To initialize the algorithm, fill the sieve S with zeros.  Now for each pair ( <i>x</i> , <i>y</i> ), where <img src="http://habrastorage.org/storage1/ec47b37a/e9f70d29/3512ef11/02334fdf.png">  , increment the values ‚Äã‚Äãin the cells S [4 <i>x</i> <sup>2</sup> + <i>y</i> <sup>2</sup> ], S [3 <i>x</i> <sup>2</sup> + <i>y</i> <sup>2</sup> ], and also, if <i>x</i> &gt; <i>y</i> , then in S [3 <i>x</i> <sup>2</sup> - <i>y</i> <sup>2</sup> ].  At the end of the calculation, the cell numbers of the form 6 <i>k</i> ¬± 1, containing odd numbers, are either simple or are divided into simple squares. <br><br>  As a final step, go through the supposedly simple numbers in sequence and cross out multiples of their squares. <br><br>  From the description it can be seen that the complexity of the Atkin sieve is proportional to <i>n</i> , and not to <i>n</i> log log <i>n</i> as in the Eratosthenes algorithm. <br><br>  The author's optimized C implementation is presented as <a href="http://cr.yp.to/primegen.html">primegen</a> , the simplified version is in <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D1%2588%25D0%25B5%25D1%2582%25D0%25BE_%25D0%2590%25D1%2582%25D0%25BA%25D0%25B8%25D0%25BD%25D0%25B0">Wikipedia</a> .  On Habrahabr <a href="http://habrahabr.ru/blogs/algorithm/125620/">published</a> Atkin's sieve on C #. <br><br>  As in the sieve of Eratosthenes, using wheel factorization and segmentation, one can reduce the asymptotic complexity by log log <i>n</i> times, and the memory consumption - to <i>O</i> ( <i>n</i> <sup>¬Ω + o (1)</sup> ). <br><br><h4>  About logarithm of logarithm </h4><br>  In fact, the log log <i>n</i> factor is growing extremely.  slow.  For example, log log 10 <sup>10000</sup> ‚âà 10. Therefore, from a practical point of view, it can be considered a constant, and the complexity of the Eratosthenes algorithm is linear.  Unless the search for simple is a key function in your project, you can use the basic version of the sieve of Eratosthenes (except save on even numbers) and not complex in this regard.  However, when searching for simple ones at large intervals (from 2 <sup>32</sup> ), the game is worth the trouble, optimization and Atkin's sieve can significantly improve performance. <br><br>  <b>PS</b> The comments reminded about the <a href="http://en.wikipedia.org/wiki/Sieve_of_Sundaram">Sundaram sieve</a> .  Unfortunately, it is only a mathematical wonder and is always inferior either to the sieves of Eratosthenes and Atkin, or to the check by divisors. <br><br><h6>  Literature </h6><br>  [1] Agrawal M., Kayal N., Saxena N. <a href="http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf">PRIMES is in P.</a>  - Annals of Math.  160 (2), 2004. pp. 781‚Äì793. <br>  [2] Vasilenko O.N. Number-theoretic algorithms in cryptography.  - M., MTSNMO, 2003. - 328 p. <br>  [3] <a href="http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf">The Genuine Sieve of Eratosthenes</a> .  - 2008. <br>  [4] Atkin AOL, Bernstein DJ <a href="http://www.ams.org/journals/mcom/2004-73-246/S0025-5718-03-01501-1/S0025-5718-03-01501-1.pdf">Prime sieves using binary quadratic forms</a> .  - Math.  Comp.  73 (246), 2003. pp. 1023-1030. </div><p>Source: <a href="https://habr.com/ru/post/133037/">https://habr.com/ru/post/133037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133032/index.html">Proxy RSS feed with Python</a></li>
<li><a href="../133033/index.html">VMware View Client with PCoIP support and USB for Linux on Linux</a></li>
<li><a href="../133034/index.html">Trying to just explain complex, for beginners, things in javascript</a></li>
<li><a href="../133035/index.html">Bike music</a></li>
<li><a href="../133036/index.html">We make calendars in different number systems</a></li>
<li><a href="../133038/index.html">Nate or something, cards in hand!</a></li>
<li><a href="../133039/index.html">Made an iPad version of our service</a></li>
<li><a href="../133040/index.html">One Kindle Development History</a></li>
<li><a href="../133042/index.html">X student electronics contest in Tomsk</a></li>
<li><a href="../133045/index.html">Find tags and notebooks in Evernote for Mac</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>