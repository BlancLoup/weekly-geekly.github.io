<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Holy Grail Dynamic Dispatch</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Big trouble The bottleneck of static typing is heterogeneous collections and variadic functions. Therefore, in the RPC-libraries, there is often an ap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Holy Grail Dynamic Dispatch</h1><div class="post__text post__text-html js-mediator-article">  <s>Big trouble The</s> bottleneck of static typing is heterogeneous collections and variadic functions.  Therefore, in the RPC-libraries, there is often an approach when the incoming data is just one ADT-piece, and for methods one is the same flat type "[Foo] -&gt; IO Foo", the implementations of which copy-paste deserialization / serialization, which is inconvenient and causes errors including  runtime. <br><br>  The solution to this problem bothered me almost from the very beginning of the practical application of Haskel by me and, finally, last night, I was inspired by as much as 6.5 milliolegas and after the session of divination from mistakes and conversations with ghci, I succeeded. <br><br> <a href="http://memegenerator.net/instance/38540263"><img src="http://cdn.memegenerator.net/instances/400x/38540263.jpg"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  Suppose we want to make a list / dictionary Text -&gt; Method.  And immediately bummer: <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">methods</span></span> :: [(<span class="hljs-type"><span class="hljs-type">String</span></span>, ????)] methods = [ (<span class="hljs-string"><span class="hljs-string">"add"</span></span>, \xy -&gt; return (x + y)) , (<span class="hljs-string"><span class="hljs-string">"reverse"</span></span>, \s -&gt; return (reverse s)) ]</code> </pre> <br><br>  All methods have a different type.  This can be solved by putting them in an opaque box. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaconBox</span></span></span><span class="hljs-class"> = forall a. a methods :: [(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaconBox</span></span></span><span class="hljs-class">)]</span></span></code> </pre><br><br>  But such a box can not be unpacked.  it is not clear what you can do with them, unpacked.  This means that we need a class of types that can be in it and describing how to bring the function to a normal form, i.e.  functions ready for deserialization of input data and serialization of the result. <br><br>  In this example, the ‚Äúprotocol‚Äù Read / Show will be used.  Not the best, but for the rest all the same.  The data type, respectively, will be String. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tossable</span></span></span><span class="hljs-class"> t </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> toss :: [<span class="hljs-type"><span class="hljs-type">String</span></span>] -&gt; t -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaconBox</span></span></span><span class="hljs-class"> = forall a. (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tossable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaconBox</span></span></span><span class="hljs-class"> a</span></span></code> </pre><br><br>  With this definition, it is already clear even to the compiler that any type can be put inside the box, for which the toss function is defined, which is ... Bach!  Here we smoothly go to the second problem.  After all, it would be desirable, that the called methods could have any arguments in any quantity.  Those.  so that you can simply take and put into the box any RPC handler for which marshaling procedures are defined. <br><br>  Oleg and the Haskal wiki have an example of something similar - printf with any number of arguments of any type: <a href="http://www.haskell.org/haskellwiki/Varargs">www.haskell.org/haskellwiki/Varargs</a> .  But it is not quite that.  But not entirely wrong!  awesome.gif <br><br>  The trick is based on two instances - the basic form and the folding of arguments. <br><br>  The basic form determines what to do when the data is collected.  It also defines the class of the output type of the method. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tossable</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> toss [] f = fmap show f toss _ _ = fail <span class="hljs-string"><span class="hljs-string">"  "</span></span></code> </pre><br><br>  If all arguments are used and we have ready-made values ‚Äã‚Äãin our hands (in this case, this is an action that needs to be performed), i.e.  All arguments are applied to the function - we execute it and immediately serialize the result.  The remaining arguments can be thrown away, and you can curse - I prefer to throw an error than to guess about correctness. <br><br>  To convolve the arguments, a very interesting instance is used, demonstrating in all its glory the powerful functional approach in general and the correct type system in particular.  Here the class of input arguments is fixed, which guarantees the <s>success of the</s> presence of a de-sterilizer for the type used in the RPC method call. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Read</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tossable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tossable</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> toss [] _ = fail <span class="hljs-string"><span class="hljs-string">" "</span></span> toss (a:<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) f = toss <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (f (read a))</code> </pre><br><br>  Despite the magical definition, what is happening is rather trivial.  If our type is a function (a -&gt; t), and we still have arguments for it, then we will deserialize the next argument according to the type that the function expects and apply it to it. <br><br>  If the result is in the form of the base form - well, if after applying the argument to the function, the function is again obtained, we repeat the procedure. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">doAnd</span></span> :: <span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> doAnd ab = return (a &amp;&amp; b) doSum3 :: <span class="hljs-type"><span class="hljs-type">Double</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> doSum3 xyz = return (x + y + z) main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> toss [] (doAnd <span class="hljs-type"><span class="hljs-type">True</span></span> <span class="hljs-type"><span class="hljs-type">True</span></span>) &gt;&gt;= print toss [<span class="hljs-string"><span class="hljs-string">"True"</span></span>] (doAnd <span class="hljs-type"><span class="hljs-type">True</span></span>) &gt;&gt;= print toss [<span class="hljs-string"><span class="hljs-string">"True"</span></span>, <span class="hljs-string"><span class="hljs-string">"True"</span></span>] doAnd &gt;&gt;= print toss [<span class="hljs-string"><span class="hljs-string">"42"</span></span>, <span class="hljs-string"><span class="hljs-string">"2.71828"</span></span>, <span class="hljs-string"><span class="hljs-string">"3.14159"</span></span>] doSum3 &gt;&gt;= print</code> </pre><br><br>  Et voila!  The function quietly unpacks and feeds the arguments and packages the result. <br><br>  The final touch is the dynamic dispatching of methods from the boxes.  To do this, add some metadata to our box and a search function for them: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaconBox</span></span></span><span class="hljs-class"> = forall a. (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tossable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaconBox</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> a tossBacon :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaconBox</span></span></span><span class="hljs-class">] -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> a tossBacon [] _ _ = fail "  " tossBacon (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaconBox</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bf</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bs</span></span></span><span class="hljs-class">) name args | bn == name = toss args bf | otherwise = tossBacon bs name args</span></span></code> </pre><br><br>  A special function is needed so that the compiler does not explode the brain (sic!) When opening an existential container in any way other than pattern-matching.  FP-world problems ... <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- , ,    bacon :: [BaconBox] bacon = [ BaconBox "bool.and" doAnd , BaconBox "num.sum3" doSum3 ] main :: IO () main = do (method:args) &lt;- getArgs tossBacon bacon method args &gt;&gt;= print</span></span></code> </pre><br><br>  So, we have a container that allows us to poke in functions with an arbitrary (but strictly limited in input and output) type and call them by name, automatically doing the marshaling routine.  Less code - less bugs.  Hooray! </div><p>Source: <a href="https://habr.com/ru/post/182576/">https://habr.com/ru/post/182576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182558/index.html">IFXmanager - infrastructure management system</a></li>
<li><a href="../182560/index.html">IPv6 - one year later</a></li>
<li><a href="../182564/index.html">Use of automated verification tools for software testing in accordance with the standards DO-178B / C (–ö–¢-178–í), EN 50126, IEC 61508, ISO 26262, FDA, IEC 62304</a></li>
<li><a href="../182566/index.html">Curiosity on the way to the top</a></li>
<li><a href="../182574/index.html">Comment or not comment?</a></li>
<li><a href="../182578/index.html">Interview with Mark McClain, OpenStack Networking Project Leader</a></li>
<li><a href="../182580/index.html">Prism Developer Guide - Part 9, the interaction between loosely coupled components</a></li>
<li><a href="../182584/index.html">HiRISE or how to photograph Mars from orbit</a></li>
<li><a href="../182586/index.html">Transparent authentication for OTRS using mod_auth_ntlm_winbind using the example of Cent OS 6</a></li>
<li><a href="../182588/index.html">SIMD without SIMD, or looking at C almost twice as fast as C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>