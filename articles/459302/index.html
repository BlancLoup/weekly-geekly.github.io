<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Repeat failed HTTP requests in Angular</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Organizing access to server data is the foundation of almost any single-page application. All dynamic content in such applications is loaded from the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Repeat failed HTTP requests in Angular</h1><div class="post__text post__text-html js-mediator-article">  Organizing access to server data is the foundation of almost any single-page application.  All dynamic content in such applications is loaded from the backend. <br><br>  In most cases, HTTP requests to the server work reliably and return the desired result.  However, in some situations, requests may be unsuccessful. <br><br>  Imagine someone working with your website through an access point on a train that travels around the country at a speed of 200 kilometers per hour.  Network connection in this situation may be slow, but server requests, despite this, do their job. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And what if the train gets into the tunnel?  There is a high probability that the connection with the Internet will be interrupted and the web application will not be able to "reach" the server.  In this case, the user will have to reload the application page after the train leaves the tunnel and the Internet connection is restored. <br><br>  Reloading the page can have an impact on the current state of the application.  This means that the user may, for example, lose the data that he entered into the form. <br><br>  Instead of simply accepting the fact that a certain request was unsuccessful, it would be better to repeat it several times and show the corresponding notification to the user.  With this approach, when the user realizes that the application is trying to cope with the problem, he most likely will not reload the page. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/459302/"><img src="https://habrastorage.org/webt/tq/jn/st/tqjnsttqoifuf4p9-rnt_g1dfwg.jpeg"></a> <br><br>  The material, the translation of which we are publishing today, is devoted to the analysis of several ways to repeat unsuccessful requests in Angular-applications. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Repeat failed requests</font> </h2><br>  Let's reproduce the situation that a user running on the Internet from a train may encounter.  We will create a backend that processes the request incorrectly during the first three attempts to access it, returning data only on the fourth attempt. <br>  Usually, using Angular, we create a service, connect the <code>HttpClient</code> and use it to get data from the backend. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      catchError((</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      })    );  } }</span></span></code> </pre> <br>  There is nothing special.  We connect the Angular <code>HttpClient</code> module and perform a simple GET request.  If the request returns an error, we execute some code to process it and return an empty <code>Observable</code> (observable object) in order to inform about it what initiated the request.  This code as if says: "An error has occurred, but everything is in order, I will cope with it." <br><br>  Most applications perform HTTP requests in this way.  In the above code, the query is executed only once.  After that, it either returns the data received from the server, or turns out to be unsuccessful. <br><br>  How to repeat the request if the endpoint <code>/greet</code> not available or returns an error?  Maybe there is a suitable RxJS operator?  Of course he exists.  RxJS has operators for just about anything. <br><br>  The first thing that may come to mind in this situation is the <code>retry</code> operator.  Let's look at its definition: ‚ÄúReturns an Observable that plays the original Observable with the exception of <code>error</code> .  If the source Observable calls <code>error</code> , then this method, instead of propagating the error, will re-subscribe to the source Observable. <br><br>  The maximum number of recurring subscriptions is limited to <code>count</code> (this is a numeric parameter passed to the method). " <br><br>  The <code>retry</code> operator <code>retry</code> very similar to what we need.  So let's embed it in our chain. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError, retry, shareReplay} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      retry(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">),      </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">catchError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      }),      shareReplay()    );  } }</span></span></code> </pre> <br>  We successfully used the <code>retry</code> operator.  Let's look at how this affected the behavior of the HTTP request that is executed in the experimental application.  <a href="">Here is</a> a large GIF file that demonstrates the screen of this application and the Network tab of the browser‚Äôs developer tools.  You will meet here a few more such demonstrations. <br><br>  Our application is very simple.  It simply performs an HTTP request when you click on the <code>PING THE SERVER</code> button. <br><br>  As already mentioned, the backend returns an error when the first three attempts to execute a request are made to it, and when the fourth request is received, it returns a normal response. <br><br>  On the Network developer‚Äôs tools tab, you can see that the <code>retry</code> operator solves the task assigned to it and repeats the execution of the failed request three times.  The last attempt is successful, the application receives a response, a corresponding message appears on the page. <br><br>  Everything is very good.  Now the application can repeat failed requests. <br><br>  However, this example can still be improved.  Please note that now repeated requests are executed immediately after the execution of requests that fail.  This behavior of the system will not bring much benefit in our situation - when the train enters the tunnel and the Internet connection is lost for a while. <br><br><h2>  <font color="#3AC1EF">Delayed retry failed requests</font> </h2><br>  The train, which hit the tunnel, does not leave it instantly.  He spends some time there.  Therefore, it is necessary to ‚Äústretch‚Äù the period during which we make repeated requests to the server.  This can be done by postponing the execution of retries. <br><br>  To do this, we need to better control the process of executing repeated requests.  We need so that we can make decisions about when exactly we need to perform repeated requests.  This means that the capabilities of the <code>retry</code> operator are not enough for us.  Therefore, refer again to the RxJS documentation. <br><br>  The documentation has a description of the operator <code>retryWhen</code> , which seems to suit us.  The documentation describes it as follows: ‚ÄúReturns an Observable that reproduces the original Observable, with the exception of <code>error</code> .  If the original Observable causes an <code>error</code> , then this method will throw a Throwable that caused the error, Observable, returned from the <code>notifier</code> .  If this Observable calls <code>complete</code> or <code>error</code> , then this method will call <code>complete</code> or <code>error</code> on the child subscription.  Otherwise, this method will re-subscribe to the original Observable. ‚Äù <br><br>  Yes, the definition is not simple.  Let's describe the same thing in a more accessible language. <br><br>  The operator <code>retryWhen</code> accepts a callback, which is returned by the Observable.  The returned Observable decides how the <code>retryWhen</code> operator <code>retryWhen</code> based on some rules.  Namely, this is how the <code>retryWhen</code> operator <code>retryWhen</code> : <br><br><ul><li>  It stops working and gives an error if the returned Observable gives an error. </li><li>  It terminates if the returned Observable reports a shutdown. </li><li>  In other cases, when Observable returns successfully, it repeats the execution of the original Observable. </li></ul><br>  Callback is called only when the source Observable generates an error for the first time. <br><br>  Now we can use this knowledge to create a pending retry mechanism for a failed request using the RxJS operator <code>retryWhen</code> . <br><br><pre> <code class="plaintext hljs">retryWhen((errors: Observable&lt;any&gt;) =&gt; errors.pipe(    delay(delayMs),    mergeMap(error =&gt; retries-- &gt; 0 ? of(error) : throwError(getErrorMessage(maxEntry))    )) )</code> </pre> <br>  If the original Observable, which is our HTTP request, returns an error, then the <code>retryWhen</code> operator is <code>retryWhen</code> .  In a callback, we have access to the error that caused the failure.  We postpone <code>errors</code> , reduce the number of retries, and return a new Observable, which gives an error. <br><br>  Based on the rules of the <code>retryWhen</code> operator, this Observable, since it produces a value, performs a repeat request.  If the repetition is several times unsuccessful and the value of the variable <code>retries</code> reduced to 0, then we finish the work with an error that occurred during the execution of the request. <br><br>  Wonderful!  Apparently, we can take the code given above and replace with it the operator <code>retry</code> , which is in our chain.  But here we will slow down a bit. <br><br>  How to <code>retries</code> with variable <code>retries</code> ?  This variable contains the current state of the system for retry failed requests.  Where is she announced?  When is the state reset?  The state must be managed inside the stream, not outside it. <br><br><h3>  <font color="#3AC1EF">‚ñç Create your own delayedRetry operator</font> </h3><br>  We can solve the problem of managing the state and improve the readability of the code by issuing the above code as a separate RxJS operator. <br><br>  There are various ways to create your own RxJS operators.  What method to use exactly depends on how this or that operator is arranged. <br><br>  Our operator is based on existing RxJS operators.  As a result, we can use the easiest way to create our own operators.  In our case, the RxJs operator is just a function with the following signature: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt;</code> </pre> <br>  This statement takes the original Observable and returns another Observable. <br><br>  Since our operator allows the user to specify how often repeated requests should be performed, and how many times they need to be executed, we need to wrap the above function declaration into a factory function that takes the values ‚Äã‚Äãof <code>delayMs</code> (delay between repetitions) and <code>maxRetry</code> ( maximum number of repetitions). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt; }</code> </pre> <br>  If you want to create an operator based on no existing operators, you need to pay attention to error handling and subscriptions.  Moreover, you will need to extend the <code>Observable</code> class and implement the <code>lift</code> function. <br><br>  If you are interested in it - look <a href="">here</a> . <br><br>  So let's, based on the above code snippets, write your own RxJs operator. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delayedRetry</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        delay(delayMs),        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error) : throwError(getErrorMessage(maxRetry))        ))      )    ); }</code> </pre> <br>  Fine.  Now we can import this operator into client code.  We will use it when executing an HTTP request. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span><span class="hljs-string">/greet`</span></span>).pipe(        delayedRetry(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>),        catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error);            <span class="hljs-comment"><span class="hljs-comment">//               return EMPTY;        }),        shareReplay()    );</span></span></code> </pre> <br>  We put the <code>delayedRetry</code> operator in a chain and passed to it, as parameters, the numbers 1000 and 3. The first parameter specifies the delay in milliseconds between attempts to perform repeated requests.  The second parameter determines the maximum number of repeated requests. <br><br>  Restart the application and take a <a href="">look</a> at how the new operator works. <br><br>  After analyzing the behavior of the program using the browser's developer tools, we can see that the execution of repeated attempts to fulfill the request is postponed for a second.  After receiving the correct answer to the request, the corresponding message will appear in the application window. <br><br><h2>  <font color="#3AC1EF">Exponential delay request</font> </h2><br>  Let's develop the idea of ‚Äã‚Äãdeferred retry failed requests.  Previously, we always postponed the execution of each of the repeated requests for the same time. <br><br>  Here we will talk about how to increase the delay after each attempt.  The first attempt to repeat the request is made in a second, the second - in two seconds, the third - in three. <br><br>  Create a new operator, <code>retryWithBackoff</code> , that implements this behavior. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up.`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_BACKOFF = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retryWithBackoff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES, backoffMs = DEFAULT_BACKOFF</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {              <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backoffTime = delayMs + (maxRetry - retries) * backoffMs;              <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error).pipe(delay(backoffTime));            }            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> throwError(getErrorMessage(maxRetry));          }        )))); }</code> </pre> <br>  If you use this operator in the application and test it - you can <a href="">see</a> how the delay in the execution of the repeated request grows after each new attempt. <br><br>  After each attempt we wait for a certain time, repeat the request and increase the waiting time.  Here, as usual, after the server returns the correct response to the request, we display a message in the application window. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Repeating failed HTTP requests makes applications more stable.  This is especially important when performing very important requests, without the data obtained through which, the application can not work normally.  For example, it can be configuration data containing the addresses of the servers with which the application needs to interact. <br><br>  In most scenarios of the operator RxJs <code>retry</code> not enough to organize a reliable system to repeat failed requests.  The operator <code>retryWhen</code> gives the developer a higher level of control over repeated requests.  It allows you to customize the interval for the execution of repeated requests.  Thanks to the capabilities of this operator, you can implement a scheme of pending repetitions or repetitions with exponential shelves. <br><br>  When implementing behavior patterns in RxJS chains that are suitable for reuse, it is recommended to design them in the form of new operators.  <a href="http-retry">Here is the</a> repository, the code from which was used in this material. <br><br>  <b>Dear readers!</b>  How do you solve the task of repeating failed HTTP requests? <br><br> <a href="https://ruvds.com/turbo_vps/"><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div><p>Source: <a href="https://habr.com/ru/post/459302/">https://habr.com/ru/post/459302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459296/index.html">JavaScript price in 2019</a></li>
<li><a href="../459298/index.html">Angular: state of affairs in 2019</a></li>
<li><a href="../4593/index.html">"Soup" again answers the same questions.</a></li>
<li><a href="../45930/index.html">Russian coding4fun started</a></li>
<li><a href="../459300/index.html">Quasar 1.0: a new useful tool for Vue developers and not only for them.</a></li>
<li><a href="../459304/index.html">Angular Pitfalls and Time Saver</a></li>
<li><a href="../459306/index.html">Serverless serverless rendering</a></li>
<li><a href="../459308/index.html">SEO in 2019 not working?</a></li>
<li><a href="../45931/index.html">40 years old computer mouse</a></li>
<li><a href="../459310/index.html">Test automation tools or mobile tester on steroids</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>