<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Object pool and fast creation of heap objects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to share the next bike of my own assembly in C ++. Bicycle can quickly create and produce objects. As a result, we get the speed of creating (n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Object pool and fast creation of heap objects</h1><div class="post__text post__text-html js-mediator-article">  I want to share the next bike of my own assembly in C ++.  Bicycle can quickly create and produce objects.  As a result, we get the speed of creating (not returning) objects 30% faster than just with new.  The object pool is not a new thing, and in general - what can we say about it?  But as they say - the main thing in the details. <br><a name="habracut"></a><br>  It so happened that it took me a huge amount of small objects in a C ++ project.  At what they needed, as it turned out, in a heap.  Objects were nothing more than a description of a position in space.  And they contained a 4x4 matrix of double type and several auxiliary variables.  Having simplified the original form, we assume that the class (in this case, the structure) has the form: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Position</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> m[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s; }</code> </pre> <br>  That is - about 132 bytes. <br>  Having tried several ways, among which was the creation of objects simply through new, I came to the conclusion that it is better to do this using the object pool.  For new right in the forehead is a resource-intensive operation. <br><br>  At once I will make a reservation that with <a href="http://www.boost.org/">boost</a> , and others like them know very remotely.  And therefore, perhaps I describe a bicycle here.  However, I personally did not find anything like this (very likely, from what I didn‚Äôt know how to call it correctly), but what happened turned out to work very quickly. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The object pool is fairly well-known, and in general is a simple pattern to implement.  It would seem that there is a difficult thing - create a stack of objects and, as necessary, give it away.  When everything is distributed - create more.  If the object is no longer needed, we return it to the stack of free objects, instead of deleting it.  Let's give an example of the class implementing this pattern: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunk_size = <span class="hljs-number"><span class="hljs-number">100</span></span>&gt; class Factory { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> T* get(){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(free_ptrs.empty()){ makeMore(); } T* obj = free_ptrs.back(); free_ptrs.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T* obj)</span></span></span></span>{ free_ptrs.push_back(obj); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; buffer; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T*&gt; free_ptrs; <span class="hljs-comment"><span class="hljs-comment">//   ( ,  chunk_size = 1 ).  chunk_size = 1   loop. void makeMore(){ //   vector.reserve() ,     reserve     //  vector.size() ,     .   //    STL. for (int i = 0; i &lt; chunk_size ; ++i) { buffer.emplace_back(); //         ! free_ptrs.emplace_back(&amp;buffer.back()); //     } } }</span></span></code> </pre><br><br>  Application: <br><pre> <code class="cpp hljs">Factory&lt;Position&gt; pool; pool.get();</code> </pre><br>  Consider the disadvantages of the above method: <br>  - In practice, the creation of a huge number (10,000 - 1,000,000) of small objects in the heap caused a significant decline in productivity.  Of course, such hesitation in the work will be observed only at the initial initialization.  But still.  If you can do well, why not do it? <br>  - The object class being created must have a default constructor! <br>  - The object is returned in an uncertain state.  You can of course add a constructor / initializer call, but more on that below. <br><br>  It was noticed that objects are sooo smartly created in native arrays: <br><pre> <code class="cpp hljs">T* <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[];</code> </pre><br>  And according to this, we try to create and store objects in a similar way. <br>  It would seem to be enough to make an STL buffer. Reserve.  But with each increase in the array, a new native array is created, and then another one by the designer of the copy / transfer in it of all the already existing elements.  That is, if we don‚Äôt want to add a transfer constructor to the class of our objects, then it will work very slowly. <br>  So, let's rewrite our pool in order to store objects in such buffers: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunk_size = <span class="hljs-number"><span class="hljs-number">100</span></span>&gt; class Factory { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> T* get(){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(free_ptrs.empty()){ makeMore(); } T* obj = free_ptrs.back(); free_ptrs.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T* obj)</span></span></span></span>{ free_ptrs.push_back(obj); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">/** * @brief Use this against std::vector - because * vector have linear size complexity on reserve. * NOT grow size, but whole size! */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Buffer</span></span></span><span class="hljs-class">{</span></span> T* <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; Buffer(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = chunk_size){ <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[num]; size = num; } <span class="hljs-comment"><span class="hljs-comment">/** * @brief IMPORTANT! Due to ussage with vector must have it. * @param other */</span></span> Buffer(Buffer&amp;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>{ size = other.size; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = other.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; other.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } ~Buffer(){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> []<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; } } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Buffer&gt; buffers; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T*&gt; free_ptrs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeMore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ buffers.emplace_back(chunk_size); Buffer &amp;buf = buffers.back(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; buf.size; ++i) { free_ptrs.emplace_back(&amp;buf.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i]); } } };</code> </pre><br><br>  As you can see, the buffer class has a copy constructor.  We need it for those cases when std :: vector will decide to perform a reallocate array. <br>  As a result, the initial initialization of the pool accelerated almost in times. <br><br>  The final touch - using the variety of the <a href="http://www.cplusplus.com/reference/new/operator%2520new%5B%5D/">new</a> command, we divide the process of allocating memory for the buffer, and the actual constructor call.  As a result, it allows us, firstly, to get an ‚Äúnot dirty‚Äù object, and secondly, it will allow us to use objects without a default constructor. <br><br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunk_size = <span class="hljs-number"><span class="hljs-number">100</span></span>&gt; class PoolFactory { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> T* get(Args&amp;&amp;...args){ T* obj = getRaw(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (obj) T(args...); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRaw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(free_ptrs.empty()){ makeMore(); } T* obj = free_ptrs.back(); free_ptrs.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T* obj)</span></span></span></span>{ free_ptrs.push_back(obj); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearPool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ buffers.clear(); free_ptrs.clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">freeAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ free_ptrs.clear(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buf_count = buffers.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buf_id = <span class="hljs-number"><span class="hljs-number">0</span></span>; buf_id &lt; buf_count; ++buf_id) { Buffer &amp;buf = buffers[buf_id]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; buf.size; ++i) { free_ptrs.emplace_back(&amp;buf.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i]); } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">/** * @brief Use this against std::vector - because * vector have linear size complexity on reserve. * NOT grow size, but whole size! */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Buffer</span></span></span><span class="hljs-class">{</span></span> T* <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; Buffer(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = chunk_size){ <span class="hljs-comment"><span class="hljs-comment">// allocate, but not construct array = static_cast&lt;T*&gt; (::operator new (sizeof(T[num]))); size = num; } /** * @brief IMPORTANT! Due to ussage with vector must have it. * @param other */ Buffer(Buffer&amp;&amp; other) noexcept{ size = other.size; array = other.array; other.array = nullptr; } ~Buffer(){ if (array != nullptr){ // destructors for (int i = 0; i &lt; size; ++i) { array[i].~T(); } // deallocate ::operator delete(array); } } }; std::vector&lt;Buffer&gt; buffers; std::vector&lt;T*&gt; free_ptrs; void makeMore(){ buffers.emplace_back(chunk_size); Buffer &amp;buf = buffers.back(); for (int i = 0; i &lt; buf.size; ++i) { free_ptrs.emplace_back(&amp;buf.array[i]); } } };</span></span></code> </pre><br></div></div><br>  The main task, for me, was precisely the fast filling of std :: vector with these small objects.  From that the tests are somewhat specific.  In my case, the time to fill in with the pool and with emplace_back is the same.  When you reuse the pool - naturally the pool wins. <br><div class="spoiler">  <b class="spoiler_title">Tests</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: BaseClass(){} BaseClass(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value){ s = value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m[<span class="hljs-number"><span class="hljs-number">16</span></span>]; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; BaseClass &gt; ar; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; BaseClass* &gt; ptr_ar; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">1000000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ PoolFactory&lt;BaseClass&gt; bPool; ar.reserve(total); timer.start(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var = <span class="hljs-number"><span class="hljs-number">0</span></span>; var &lt; total; ++var) { ar.emplace_back(var); } qDebug()&lt;&lt;<span class="hljs-string"><span class="hljs-string">"1 : "</span></span>&lt;&lt;timer.elapsed(); ptr_ar.clear(); ptr_ar.reserve(total); timer.start(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var = <span class="hljs-number"><span class="hljs-number">0</span></span>; var &lt; total; ++var) { ptr_ar.push_back(bPool.get(var)); } qDebug()&lt;&lt;<span class="hljs-string"><span class="hljs-string">"2 : "</span></span>&lt;&lt;timer.elapsed(); bPool.freeAll(); ptr_ar.clear(); ptr_ar.reserve(total); timer.start(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var = <span class="hljs-number"><span class="hljs-number">0</span></span>; var &lt; total; ++var) { ptr_ar.push_back(bPool.get(var)); } qDebug()&lt;&lt;<span class="hljs-string"><span class="hljs-string">"3 : "</span></span>&lt;&lt;timer.elapsed(); ptr_ar.clear(); ptr_ar.reserve(total); timer.start(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> var = <span class="hljs-number"><span class="hljs-number">0</span></span>; var &lt; total; ++var) { ptr_ar.push_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(var)); } qDebug()&lt;&lt;<span class="hljs-string"><span class="hljs-string">"4 : "</span></span>&lt;&lt;timer.elapsed(); }</code> </pre><br>  Conclusion: <br>  1: 21 <br>  2:22 <br>  3: 5 <br>  4:30 <br><br>  Without reserve: <br>  1: 135 <i>(due to the absence of the transport constructor for the BaseClass being filled)</i> <br>  2:22 <br>  3: 4 <br>  4:38 <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/205316/">https://habr.com/ru/post/205316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../205300/index.html">The impact of the organization of the software development process on the quality of programs and on personal productivity in the Individual development process</a></li>
<li><a href="../205308/index.html">Continuous Integration for Android using Jenkins + Gradle</a></li>
<li><a href="../205310/index.html">Three in color. Littlesnake Alternative</a></li>
<li><a href="../205312/index.html">How long can you make a browser game without having a huge budget in your pocket?</a></li>
<li><a href="../205314/index.html">How to make autoloading screenshots on FTP in OS X or history, about how we are not looking for easy ways</a></li>
<li><a href="../205318/index.html">Simplicity Algorithm for O (log N)</a></li>
<li><a href="../205320/index.html">Basics of I2P Network Client Development</a></li>
<li><a href="../205322/index.html">Price Calculator for Cloud Hosting Instances</a></li>
<li><a href="../205324/index.html">Snake on the PLC. Our answer to Siemens</a></li>
<li><a href="../205326/index.html">Antivirus scan access to Samba</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>