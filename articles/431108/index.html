<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to turn satellite images into maps. Computer vision in Yandex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the main data sources for the Yandex.Maps service is satellite imagery. In order to work comfortably with the map, objects are shown on the ima...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to turn satellite images into maps. Computer vision in Yandex</h1><div class="post__text post__text-html js-mediator-article">  One of the main data sources for the Yandex.Maps service is satellite imagery.  In order to work comfortably with the map, objects are shown on the images by polygons: forests, water reservoirs, streets, houses, etc. Usually, cartographers deal with the layout.  We decided to help them and teach the computer to add polygons of houses without the participation of people. <br><br>  For operations with images, the IT area is responsible, which is called computer vision.  The last few years, most of the problems in this area have been successfully solved using neural networks.  Today we will tell about our experience of using neural networks in mapping to readers of Habr. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><a name="habracut"></a><br>  First of all, we will train the neural grid, which will be engaged in semantic segmentation, that is, it will determine whether each point on the satellite image is related to the house.  Why semantic segmentation, and not just the detection of objects?  When the detection problem is solved, we get a set of rectangles at the output, and specific ones: two sides are vertical, two are horizontal.  At home, houses are usually rotated relative to the image axes, and in some buildings there is also a complex shape. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The task of semantic segmentation is currently being solved by various networks ( <a href="">FCN</a> , <a href="http://mi.eng.cam.ac.uk/projects/segnet/">SegNet</a> , <a href="https://arxiv.org/abs/1505.04597">UNet</a> , etc.).  We only need to choose which one suits us best. <br><br>  Having obtained the mask from the satellite image, we will select rather large clusters of points belonging to houses, assemble them into connected regions and present the boundaries of the regions in the vector form in the form of polygons. <br><br>  It is clear that the mask will not be absolutely accurate, which means that nearby houses can stick together in one connected area.  To cope with this problem, we decided to further train the network.  She will find on the image of the rib (the borders of the houses) and divide the buildings that have stuck together. <br><br>  So, loomed such a scheme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7z/dw/lt/7zdwlt1z0orhy2i9fhkgifjwkcw.jpeg"></div><br>  We did not completely reject the detection networks and tried <a href="https://arxiv.org/abs/1703.06870">Mask R-CNN</a> .  Its plus in comparison with the usual segmentation is that Mask R-CNN detects objects and generates a mask, so you don‚Äôt have to mess around with the division of the common mask into coherent areas.  But a minus (as without it) in the fixed resolution of the mask of each object, i.e., for large houses with a complex border, this border will certainly be simplified. <br><br><h2>  Instruments </h2><br>  Then it was necessary to decide on the tools.  Everything was quite obvious here: <a href="https://opencv.org/">OpenCV</a> is best suited for computer vision tasks.  The choice of neural networks is somewhat broader.  We settled on <a href="https://www.tensorflow.org/">Tensorflow</a> .  Its advantages: <br><br><ul><li>  a sufficiently developed set of ready-made cubes from which you can assemble your networks; </li><li>  Python API, convenient for quickly creating a network structure and for training; </li><li>  A trained network can be used in its program through a C ++ interface (very poor compared to the Python part, but quite sufficient to run ready-made networks). </li></ul><br>  For training and other heavy calculations, they planned to use Nirvana - a wonderful Yandex platform, <a href="https://habr.com/company/yandex/blog/351016/">which we have already talked about</a> . <br><br><h2>  Dataset </h2><br>  Success in work with a neural network by 80 percent consists of a good dataset.  So, for starters, we should have collected such a dataset.  Yandex has a huge number of satellite images with already marked objects.  It seems, everything is simple: it is enough to upload this data and collect it in dataset.  However, there is one nuance. <br><br><h3>  Dataset update </h3><br>  When a person searches for a house in a satellite image, the first thing he sees is the roof.  But the height of houses is different, the satellite can take the same terrain from different angles - and if we put a polygon on the vector map corresponding to the roof, there is no guarantee that the roof will not leave when the picture is updated.  But the foundation is dug into the ground and, from whatever angle you take it off, it always remains in one place.  That is why the houses on the vector Yandex.Map are marked ‚Äúon the foundations‚Äù.  This is correct, but for the problem of segmentation of images it is better to teach the network to look for roofs: the hope that the grid is trained to recognize the foundations is very small.  Therefore, in dataset everything should be marked on the roofs.  So, to create a good datasset, we need to learn how to move the vector marking of houses from the foundations to the roofs. <br><br>  <i>We tried and did not move, but the quality was not very good, and this is understandable: the satellite shooting angles are different, the heights of the houses are different, as a result, the foundation shifted in different directions and at different distances from the roof in the photos.</i>  <i>The network is lost from such diversity and, at best, it trains at something average, at worst - at something incomprehensible.</i>  <i>And the network for semantic segmentation produces a result that looks like something acceptable, but when searching for edges, the quality drops dramatically.</i> <br><br><h4>  Raster approach </h4><br>  Since we have climbed into the field of computer vision, the first thing we tried was an approach that is relevant to this computer vision itself.  At first, the vector map is rasterized (the polygons of the houses are drawn with white lines on a black background), <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%25A1%25D0%25BE%25D0%25B1%25D0%25B5%25D0%25BB%25D1%258F">the Sobel filter</a> highlights the edges in the satellite image.  And then the two images are offset relative to each other, which maximizes the correlation between them.  The edges after the Sobel filter are quite noisy, therefore, if we apply this approach to a single building, an acceptable result is not always obtained.  However, the method works well in areas with buildings of the same height: if you look for an offset at once over a large portion of the image, the result will be more stable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7q/re/nq/7qrenqshfovrbc1y84j0y_5q7do.jpeg"></div><br><h4>  "Geometric" approach </h4><br>  If the territory is built up not by the same type, but by various houses, the previous method will not work.  Fortunately, sometimes we know the height of buildings on the Yandex vector map and the position of the satellite during the shooting.  Thus, we can use school knowledge of geometry and count where and how far the roof will move relative to the foundation.  This method has improved dataset in areas with high-rise buildings. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/in/v3/wp/inv3wppmsi5dhhk5jcbmiwymqas.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kj/_h/yqkj_h0okr891jlbdoaljqfhfsu.jpeg"></div><br><h4>  "Manual" approach </h4><br>  The most time consuming way: roll up your sleeves, uncover a mouse, stare at the monitor and manually move the vector marking of houses from the foundations to the roofs.  The technique brings a result that is simply amazing in quality, but it is not recommended to use it in large quantities: developers engaged in such tasks quickly fall into apathy and lose interest in life. <br><br><h4>  Neural network </h4><br>  As a result, we received enough satellite images, well-marked on the roofs.  So, there is a chance to train the neural network (so far, however, not for segmentation, but for improving the layout of other satellite images).  And we did it. <br><br>  The inputs to the convolutional neural network were satellite imagery and offset rasterized markup.  At the output, we obtained a two-dimensional vector: vertical and horizontal displacements. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ad/qy/i9/adqyi95ityf_cueqvd-f2krrknk.png"></div><br>  With the help of the neural network, we found the necessary displacement, which allowed us to achieve good results on buildings that do not have a height.  As a result, we have significantly reduced the correction of the markup manually. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s6/tj/v1/s6tjv13fffnmhkxrs7etzhiv1g0.jpeg"></div><br><h3>  Different territories - different houses </h3><br>  There are many interesting territories and states on Yandex.Maps.  But even in Russia, houses are extremely diverse, which affects the way they look in satellite imagery.  Means, it is necessary to reflect a variety in.  And initially we didn‚Äôt really understand how to deal with all this magnificence correctly.  Collect a huge dataset and then train one network on it?  Make your dataset for each (conditional) type of building and train a separate network?  To train a certain basic network and then to test it for a specific type of building? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/pa/fd/nypafdcjqd3vny1_uqpujrfn0ci.jpeg"></div><br>  Experienced we found that: <br><br><ol><li>  Undoubtedly, it is necessary to expand the datas for different types of buildings on which it is planned to use the tool.  A network trained on one type is able to allocate buildings of another type, although very poorly. </li><li>  It is better to train one large network on the entire data set.  It is fairly well generalized to different territories.  If you train individual networks for each type of development, the quality will either remain the same or barely increase.  So to introduce different networks for different territories is meaningless.  In addition, it requires more data and an additional classifier of the type of development. </li><li>  If you use old networks when new territories are added to the data, networks learn much faster.  Additional training of old networks on extended data leads to approximately the same result as network training from scratch, but it takes much less time. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vk/_v/zq/vk_vzq0fxfhcjlusrbqjjqhnfre.jpeg"></div><br><h2>  Solution options </h2><br><h3>  Semantic segmentation </h3><br>  Semantic segmentation is a fairly well-studied task.  After the appearance of the <a href="https://arxiv.org/abs/1605.06211">Fully Convolutional Networks</a> article, it is mainly solved with the help of neural networks.  It remains only to choose a network (we considered <a href="">FCN</a> , <a href="http://mi.eng.cam.ac.uk/projects/segnet/">SegNet</a> and <a href="https://arxiv.org/abs/1505.04597">UNet</a> ), consider whether we need additional tricks like CRF at the output, and decide how and what function of the error will be trained. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/un/ay/gn/unaygnyzsdhk_2dbk4qq2-2m340.png"></div><br>  As a result, we stopped at the U-Net-like architecture with the <a href="https://www.cs.umanitoba.ca/~ywang/papers/isvc16.pdf">generalized Intersection Over Union</a> function as a function of the error.  For training, satellite images and the corresponding markup (of course, rasterized) were cut into squares and collected in datasets.  It turned out quite nice, and sometimes just fine. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z1/rv/ub/z1rvubhjv5xcruynmvarimca3zy.jpeg"></div><br>  In areas with single buildings, semantic segmentation was enough to move on to the next stage - vectorization.  Where the building is dense, houses are sometimes glued together in a cohesive area.  It took to separate them. <br><br><h3>  Edge detection </h3><br>  To cope with this task, you can find the edges in the image.  To detect edges, we also decided to train the network (edge ‚Äã‚Äãsearch algorithms that do not use neural networks are clearly a thing of the past).  We trained the HED type network, which is described in <a href="https://arxiv.org/abs/1504.06375">Holistically-Nested Edge Detection</a> .  In the original article, the network was trained on the BSDS-500 dataset, in which all edges are marked on the images.  The trained network finds all clearly defined edges: the boundaries of houses, roads, lakes, etc. This is enough to divide nearby buildings.  But we decided to go further and use the same dataset for learning as for semantic segmentation, only during rasterization, not to paint over the polygons of buildings entirely, but to draw only their boundaries. <br><br>  The result turned out to be so stunningly beautiful that we decided to vectorize the buildings directly along the edges obtained from the network.  And it was completely successful. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/am/uz/h-/amuzh-xo7mzssz9jtzkppm3_nag.jpeg"></div><br><h3>  Vertex Detection </h3><br>  Since the HED network gave excellent results on the edges, we decided to train it to find the vertices.  In fact, we have a network with common weights on the convolutional layers.  She had two exits at the same time: for the edges and for the vertices.  As a result, we have made another version of the vectorization of buildings, and in some cases, it showed quite sane results. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fj/50/wl/fj50wlerknjc02f8cnhgguizu2o.jpeg"></div><br><h3>  Mask R-CNN </h3><br>  <a href="https://arxiv.org/abs/1703.06870">Mask R-CNN</a> is a relatively new extension of Faster R-CNN networks.  Mask R-CNN searches for objects and allocates a mask for each of them.  As a result, for houses we will get not only the bounding rectangles, but also a refined structure.  This approach compares favorably with simple detection (we do not know how the building is located inside the rectangle) and from the usual segmentation (several houses can stick together into one, and it‚Äôs not clear how to separate them).  With Mask R-CNN, you no longer need to think about additional tricks: it is enough to vectorize the mask boundary for each object and immediately get the result.  There is also a minus: the mask size for the object is always fixed, that is, for large buildings the pixel marking accuracy will be low.  The result of the Mask R-CNN is as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/it/8v/4w/it8v4wy0axix-hpi2gfxkomo3nk.jpeg"></div><br>  We tried Mask R-CNN last and made sure that for some types of development this approach benefits others. <br><br><h2>  Vectorization </h2><br><h3>  Vectoring Rectangles </h3><br>  With all the modern architectural diversity of the house on the satellite images are still most often look like rectangles.  Moreover, for the masses of the territories do not need to mark up complex polygons.  But I still want to mark the houses on the map.  (Well, for example, a gardener's partnership: there are usually a lot of houses, it‚Äôs not so important to manually mark, but to mark the rectangles on the map is very good.) Therefore, the first approach to vectorization was extremely simple. <br><br><ol><li>  Take the raster area corresponding to the "home". </li><li>  Find the minimum area rectangle that contains this area (for example, like this: <a href="https://docs.opencv.org/3.4.3/d3/dc0/group__imgproc__shape.html">OpenCV :: minAreaRect</a> ).  Problem solved. </li></ol><br>  It is clear that the quality of this approach is far from ideal.  However, the algorithm is quite simple and in many cases it is working. <br><br><h3>  Polygons vectorization </h3><br>  If the quality of the segmentation is good enough, you can more accurately recreate the contour of the house.  In most buildings of complex shape, the angles are mostly straight, so we decided to reduce the task to the problem of constructing a polygon with orthogonal sides.  Solving it, we want to achieve two goals at once: to find the most simple polygon and to repeat the shape of buildings as accurately as possible.  These goals conflict with each other, so you have to introduce additional conditions: limit the minimum length of the walls, the maximum deviation from the raster region, etc. <br><br>  The algorithm that first came to our mind was based on the construction of the projection of points on straight lines: <br><br><ol><li>  Find the contour of the raster area corresponding to one house. </li><li>  Reduce the number of points in the contour by simplifying it, for example, <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25A0%25D0%25B0%25D0%25BC%25D0%25B5%25D1%2580%25D0%25B0_%25E2%2580%2594_%25D0%2594%25D1%2583%25D0%25B3%25D0%25BB%25D0%25B0%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259F%25D0%25B5%25D0%25BA%25D0%25B5%25D1%2580%25D0%25B0">using the Douglas-Pecker algorithm</a> . </li><li>  Find the longest side in the contour.  Its angle of inclination will determine the angle of the entire future orthogonal polygon. </li><li>  Build a projection from the next point of the contour to the previous side. </li><li>  Extend the side to the projection point.  If the distance from the point to its projection is more than the shortest wall of the building, add the resulting segment to the contour of the building. </li><li>  Repeat steps 4 and 5 until the contour is closed. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/ok/y5/eyoky5b1d4ayzcflogdwsxfyi8g.png"></div><br>  This algorithm is extremely simple and quickly brings results, but still the outline of the building sometimes turns out to be quite noisy.  Trying to cope with this problem, we stumbled upon a rather interesting <a href="https://arxiv.org/abs/1504.06584">solution to the</a> problem, which uses a square grid in space to approximate a polygon.  Briefly, the algorithm consists of three actions: <br><br><ol><li>  Build a square grid in space centered at zero. </li><li>  On grid points that are located not farther than a certain distance from the original contour, construct various polygons. </li><li>  Select a polygon with a minimum number of vertices. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5f/em/ti/5femtieuuectay9wjhoncxi2rh4.png"></div><br>  Since the required angle of grid rotation is not known in advance, we have to sort out several values, which has a bad effect on performance.  However, the algorithm allows to achieve more visually beautiful results. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yz/rb/u1/yzrbu1in149ocfxxmdv_h6gctug.jpeg"></div><br><h2>  Improved vectorization </h2><br>  While we actually worked with each house separately.  When the first stage is completed, you can work with the whole picture and improve the result.  For this, the post processing algorithm for a set of polygons has been added.  We used the following heuristics: <br><br><ul><li>  Usually the walls of adjacent houses are parallel.  Moreover: most often, houses can be combined into sets, within which all elements are aligned. </li><li>  If the picture has already marked the streets, then it is very likely that the sides of the polygons will be parallel to the streets. </li><li>  If the polygons intersect, then most likely it makes sense to move the walls so that the intersection disappears. </li></ul><br>  As a result, the following algorithm appeared: <br><br><ol><li>  Cluster found houses by the distance between them and the angle of rotation.  We average the turns of buildings in each cluster.  We repeat until the position of the buildings stops changing or until the houses start to deviate too much from the initial position. </li><li>  We choose houses near the roads, we find the side that is the longest and closest to the road.  We turn the house to the parallelism of the selected side and the road. </li><li>  We remove the intersection between polygons, shifting the sides of two intersecting buildings in proportion to the size of the sides. </li></ol><br><h2>  Result </h2><br>  As a result, we got a tool that can recognize buildings of various types of buildings.  He helps cartographers in their hard work: significantly speeds up the search for missing homes and filling in new, not yet processed areas.  At the moment, with the help of this tool, more than 800 thousand new objects have been added to the People‚Äôs Map. <br><br>  Below you will see some examples of recognition. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bn/pk/o0/bnpko0puk1vcvnd1oxanqo7pvty.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nr/qi/q5/nrqiq5mdh2wl8fjaqmr28sn0oys.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xz/3a/iw/xz3aiwhlc_g1lo_huyb8yml_6ms.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/xz/e2/rnxze2-1b6bobojodppliybmehe.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/_j/cv/jm_jcvdv8pxm60tlwmoj2hmcgjc.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9x/k_/u3/9xk_u3nlc82ymdbtht8ebtbx6ue.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/zk/8g/mwzk8g2ga_798vg986flckxculo.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/37/gu/ue37gu16xwfvt3zqh0akmtmxnyi.jpeg"></div></div><p>Source: <a href="https://habr.com/ru/post/431108/">https://habr.com/ru/post/431108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../431096/index.html">How to build a chat bot product</a></li>
<li><a href="../431098/index.html">Even a fire is not an obstacle, or Zimbra speed recovery after a disaster</a></li>
<li><a href="../431102/index.html">How the physical address is displayed in rows and banks DRAM</a></li>
<li><a href="../431104/index.html">How we at Neoflex develop the expertise of DevOps</a></li>
<li><a href="../431106/index.html">How much money did Americans spend on this Black Friday, and what does smartphones mean?</a></li>
<li><a href="../431110/index.html">Stop feeding publishers. EU develops rules for compulsory free access to research</a></li>
<li><a href="../431112/index.html">How to use least squares methods for resource assessment and monitoring of Oracle databases</a></li>
<li><a href="../431114/index.html">Facebook for the first time closed access to some publications for Russian IP-addresses.</a></li>
<li><a href="../431116/index.html">Want strange: a review of the upcoming conference DartUP in St. Petersburg</a></li>
<li><a href="../431118/index.html">The whole truth about the RTOS. Article # 22. Mailboxes: ancillary services and data structures</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>