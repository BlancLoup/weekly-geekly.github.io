<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Again about STL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This selection of short notes on C ++ containers emerged as a result of a request to prepare a brief STL review for beginning fellow programmers. Why ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Again about STL</h1><div class="post__text post__text-html js-mediator-article">  This selection of short notes on C ++ containers emerged as a result of a request to prepare a brief STL review for beginning fellow programmers.  Why was this necessary when there is original documentation on this subject and many whole separate books, of which at least 5-6 excellent quality exist in translations into Russian? <br>  But the meaning, however, is, and here it is: <br><br><ul><li>  All books were published in the late 90s - early 2000s.  Later standards of the C ++ language (up to C ++ 11) introduce new syntactic constructions that, when used with STL, give a cross effect ... with a very interesting interference.  This allows frequent use of STL constructs with much greater ease. </li><li>  Books usually describe the subject matter too detailed (this is good for students, but redundant for programmers, even if it is a junior level, which, after other languages, for example, requires only basic familiarization).  The original documentation, on the contrary, is crammed with formal syntactic definitions (this is fine as a reference book at hand, but redundant for acquaintance).  These notes, completely avoiding formal definitions, are built around use cases that are mostly understood by the programmer even without any additional explanation. </li><li>  The contingent for which the texts were originally prepared, among other things, is largely focused on numerical mathematical methods, data processing in the stream, for which existing publications are not designed.  Such a bias is also closer to me, and such an accent will be noticeable in the examples on which the description is built. </li></ul><br>  Due to the requirements of the <b>mandatory</b> uniformity of objects in containers, they could be called regular containers with clarification, this clarifies a lot (such clarification is not made just because everything is already clear about what we are talking about).  Of course, we are talking about STL containers, but the traditional C / C ++ array is the same regular container, and they will appear in the text and examples.  (Structures, and even more generally, classes with data fields are also containers, but you can‚Äôt call them regular.) <br><br>  I would like to hope that these notes will be useful to someone from mastering STL, simplify this process of understanding.  And the suggestions and remarks, when they will be in essence, from those readers who are already pros in C ++, will help improve these texts for the future, when they can be useful to someone else. <br><a name="habracut"></a><br><h1>  Static and dynamic dimension arrays </h1><br>  But it is necessary to begin the review of STL containers from traditional arrays, since the former are a logical development of the latter.  Arrays are one of the most widely used forms of data organizations, and historically one of the very first forms of structuring that appeared in programming languages ‚Äã‚Äã(late 50s), before the appearance of structures in languages ‚Äã‚Äãand any other aggregation methods.  An array is a representation of a set of <b>consecutive</b> elements of the same type, and it is also organic for an internal representation for machine computations at the command level.  Fundamentally important in this definition are 2 points that for the array must be met: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Each element of the array can be specified by its location <b>number</b> in the sequence of elements similar to it. </li><li>  All array elements must necessarily be of the <b>same type</b> .  Everyone knows and understands the simplest definitions, for example, integer arrays: int array [100].  But this does not mean that only the simplest built-in types of the C ++ language can be organized into arrays - variable objects of any complex type (class) and of any degree of complexity can be organized into an array. </li></ol><br>  The only limitation is that <b>all</b> elements of the same array must be of the same type.  For example, a student group can be described like this in the dean‚Äôs accounting program: <br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">student</span></span> { ... } student <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>[ <span class="hljs-number"><span class="hljs-number">30</span></span> ];</code> </pre> <br>  To this extremely important circumstance - the types of the elements of the array - we will return later. <br><br>  Ever since the earliest programming languages ‚Äã‚Äã(FORTRAN, etc.), a very strong restriction was imposed on arrays: the <b>size of the</b> array should be determined only by an integer <b>constant</b> , the value of which should be determined at the time of <b>compiling the</b> code.  The same restriction persists in the C language, which became the progenitor of C ++.  For example: <br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> size 100 double array[ size ];</span></span></code> </pre><br>  In C ++ (in classical, except for the standards of recent years!), This restriction is slightly relaxed to the point that the size of the array can be an integer constant, the value of which can be <b>calculated</b> at the time of <b>compiling the</b> code.  For example: <br><pre> <code class="hljs vbscript">#include &lt;iostream&gt; using namespace std; float <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[ (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>)( <span class="hljs-number"><span class="hljs-number">10.</span></span> * <span class="hljs-number"><span class="hljs-number">10.</span></span> ) + <span class="hljs-number"><span class="hljs-number">2</span></span> ]; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> main( void ) { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"array size = "</span></span> &lt;&lt; sizeof( <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> ) / sizeof( <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[ <span class="hljs-number"><span class="hljs-number">0</span></span> ] ) &lt;&lt; endl; }</code> </pre><br><pre> <code class="dos hljs">$ ./siz1 array size = <span class="hljs-number"><span class="hljs-number">102</span></span></code> </pre><br>  In all such cases, after defining the array, its size is fixed and we will not be able to <b>increase</b> its size in any way (if, for example, during the calculations it turns out that we lack this size).  Thus, certain arrays are called arrays with a <b>statically</b> declared (at the time of writing) size. <br><br>  <b>Note:</b> Due to the fact that all the elements of the array are arranged sequentially (the first rule from those mentioned above), you can use the trick shown in the example to calculate the size of the array (in its visible area): the size of the array is equal to the length of the entire array divided by the length any of its elements (since they are all of the same type). <br><br>  It may seem that the arrays are defined differently without specifying the size, but with a list of initial values: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[] = { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">5.</span></span> };</code> </pre><br>  But it is not so!  Just here the constant value of the size of the declared array is extracted from the list of values, and is equal, in the shown example 5. <br><br>  The main way to create an array, in classic C and C ++, with the size of N elements, calculated at the time <b>of</b> array <b>creation</b> (at the execution stage), was the way of dynamic allocation of the array.  Which in C and C ++ is done, respectively: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = (<span class="hljs-type"><span class="hljs-type">double</span></span>*)calloc( N, sizeof( <span class="hljs-type"><span class="hljs-type">double</span></span> ) ); //  C <span class="hljs-type"><span class="hljs-type">double</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>[ N ]; //   C++</code> </pre><br>  For example: <br><pre> <code class="hljs mel">#include &lt;iostream&gt; #include &lt;cmath&gt; using <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> std; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main( void ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)( <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>( M_PI / <span class="hljs-number"><span class="hljs-number">2</span></span> ) * <span class="hljs-keyword"><span class="hljs-keyword">pow</span></span>( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *array = new <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[ <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> ]; cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"array size = "</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] array; }</code> </pre><br><pre> <code class="dos hljs">$ ./siz2 array size = <span class="hljs-number"><span class="hljs-number">1024</span></span></code> </pre><br>  <b>Note:</b> Dynamic array placement is the main way, although there are some other ways, such as alloca () from the C API, or including zero-length extensions in extensible structures (extension of the GCC compiler) or replacing them with variable bounds ( C99): <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vararr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// int n, data[ 0 ]; //    -  GCC int n, data[]; //     -  C99 } vararr_t;</span></span></code> </pre><br>  But all these methods, judging by the frequency of their use, are only exotic in comparison with dynamic placement.  And their diversity in different ways is only an indication that the static size of the array size is a strong limiting factor, and all this is the search for the removal of this limitation. <br><br>  The latest standards (C99, C ++ 11) have made extensions that allow the creation of <b>local</b> arrays in functions with sizes calculated at the execution stage when entering a function (under such conditions the array will be allocated in the function stack).  This is quite significant in cases where we cannot know in advance the size of the data being processed (the C99 standard calls this: VLA - variable-length array).  As an example, let's look at the task of finding all primes not exceeding N (the sieve of Eratosthenes), where N is specified by the command line parameter when the program is started: <br><pre> <code class="hljs lua">#include &lt;iostream&gt; #include &lt;cstdlib&gt; using namespace std; int main( int argc, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> **argv ) { unsigned k, j, n; //   bool a[ n = atoi( argv[ <span class="hljs-number"><span class="hljs-number">1</span></span> ] ) + <span class="hljs-number"><span class="hljs-number">1</span></span> ]; a[ <span class="hljs-number"><span class="hljs-number">0</span></span> ] = a[ <span class="hljs-number"><span class="hljs-number">1</span></span> ] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( k = <span class="hljs-number"><span class="hljs-number">2</span></span>; k &lt; n; k++ ) a[ k ] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( k = <span class="hljs-number"><span class="hljs-number">2</span></span>; k &lt; n; k++ ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( j = k + k; j &lt; n; j += k ) //     ka[ j ] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; const int line = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( k = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; n; k++ ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a[ k ] ) { cout &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\t"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> == ++j % line ) cout &lt;&lt; endl; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( j % line != <span class="hljs-number"><span class="hljs-number">0</span></span> ) cout &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  We are already obliged to compile this code with an indication of the C ++ standard of 2011 (using options of the compiler, or properties of the compiled project): <br><pre> <code class="dos hljs">$ g++ -Wall -std=c++<span class="hljs-number"><span class="hljs-number">11</span></span> -O3 erastof.cc -o erastof $ ./erastof <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">19</span></span> <span class="hljs-number"><span class="hljs-number">23</span></span> <span class="hljs-number"><span class="hljs-number">29</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span> <span class="hljs-number"><span class="hljs-number">41</span></span> <span class="hljs-number"><span class="hljs-number">43</span></span> <span class="hljs-number"><span class="hljs-number">47</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span> <span class="hljs-number"><span class="hljs-number">67</span></span> <span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">79</span></span> <span class="hljs-number"><span class="hljs-number">83</span></span> <span class="hljs-number"><span class="hljs-number">89</span></span> <span class="hljs-number"><span class="hljs-number">97</span></span> <span class="hljs-number"><span class="hljs-number">101</span></span> <span class="hljs-number"><span class="hljs-number">103</span></span> <span class="hljs-number"><span class="hljs-number">107</span></span> <span class="hljs-number"><span class="hljs-number">109</span></span> <span class="hljs-number"><span class="hljs-number">113</span></span> <span class="hljs-number"><span class="hljs-number">127</span></span> <span class="hljs-number"><span class="hljs-number">131</span></span> <span class="hljs-number"><span class="hljs-number">137</span></span> <span class="hljs-number"><span class="hljs-number">139</span></span> <span class="hljs-number"><span class="hljs-number">149</span></span> <span class="hljs-number"><span class="hljs-number">151</span></span> <span class="hljs-number"><span class="hljs-number">157</span></span> <span class="hljs-number"><span class="hljs-number">163</span></span> <span class="hljs-number"><span class="hljs-number">167</span></span> <span class="hljs-number"><span class="hljs-number">173</span></span> <span class="hljs-number"><span class="hljs-number">179</span></span> <span class="hljs-number"><span class="hljs-number">181</span></span> <span class="hljs-number"><span class="hljs-number">191</span></span> <span class="hljs-number"><span class="hljs-number">193</span></span> <span class="hljs-number"><span class="hljs-number">197</span></span> <span class="hljs-number"><span class="hljs-number">199</span></span> <span class="hljs-number"><span class="hljs-number">211</span></span> <span class="hljs-number"><span class="hljs-number">223</span></span> <span class="hljs-number"><span class="hljs-number">227</span></span> <span class="hljs-number"><span class="hljs-number">229</span></span> <span class="hljs-number"><span class="hljs-number">233</span></span> <span class="hljs-number"><span class="hljs-number">239</span></span> <span class="hljs-number"><span class="hljs-number">241</span></span> <span class="hljs-number"><span class="hljs-number">251</span></span> <span class="hljs-number"><span class="hljs-number">257</span></span> <span class="hljs-number"><span class="hljs-number">263</span></span> <span class="hljs-number"><span class="hljs-number">269</span></span> <span class="hljs-number"><span class="hljs-number">271</span></span> <span class="hljs-number"><span class="hljs-number">277</span></span> <span class="hljs-number"><span class="hljs-number">281</span></span> <span class="hljs-number"><span class="hljs-number">283</span></span> <span class="hljs-number"><span class="hljs-number">293</span></span></code> </pre><br>  But even after all extensions, the simplest array, as a form of organizing a collection of objects, is not flexible enough, the main limiting factors of which are: <br><br><ul><li>  No matter how the size of the array is determined (by a constant or by calculating the definition point), this size cannot be further increased (if you did not guess the required size in advance, or if you didn‚Äôt put a sufficient margin). </li><li>  According to the rules of C / C ++, when calling functions instead of an array, a pointer to its beginning (the address of the 1st element) is passed as a parameter to the function.  This allows you to greatly improve the efficiency of many computational algorithms, but this completely loses information about the size of the array (it is necessary, as an option) to pass a separate parameter.  For example, if we wanted to form the sieve of Eratosthenes not in the main () function, but in a separate function, then we should form its call as an erastof (a, n). </li><li>  Many intuitively simple operations on arrays cause difficulties, such as: in the 15-element array, insert element number 10 between elements 2 and 3. In addition, a).  all elements from 3 to 9 need to be copied one position to the right, b).  this can only be done in descending order from 9 to 3 and c).  all indices of these operations must be monitored manually. </li></ul><br>  In order to make it easier to perceive the access mechanisms in STL containers, it is useful to first recall how this is done to the elements of the arrays.  The choice (for reading or writing) of an arbitrary element of the array (let's call it arbitrarily arr []) can be chosen by <b>two</b> mechanisms: a).  indexing operation - arr [n], or b).  according to the pointer, counted from the beginning of the array - * (&amp; arr [0] + n).  The process of moving the pointer along an array, in the course of accessing its various elements, can be called an iteration, and the pointer used in this capacity is an iterator.  Thus, access to the elements of any arrays can be done either by index or by iterator. <br><br>  The C ++ 11 standard complements the operation of cyclic access to array elements with a new syntactic form, in the manner that the for_each () algorithm from STL does, which (using the deducibility of types from the same C ++ 11) may look quite unusual for the traditional syntax: <br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i : arr ) . . . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;i : arr ) . . . <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  The following example shows all these features at the same time: <br><pre> <code class="hljs vbscript">#include &lt;iostream&gt; using namespace std; double arr[] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unsigned n = sizeof( arr ) / sizeof( arr[ <span class="hljs-number"><span class="hljs-number">0</span></span> ] ); <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> main( void ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( unsigned i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++ ) cout &lt;&lt; arr[ i ] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; cout &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( double* i = arr; i - arr &lt; (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>)n; i++ ) cout &lt;&lt; *i &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; cout &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( auto i : arr ) cout &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; cout &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( auto &amp;i : arr ) i = i * i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( double i : arr ) cout &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; cout &lt;&lt; endl; }</code> </pre><br>  Pay attention to the expression for (auto &amp; i: arr), when using a reference to the elements of the array, representing the left-sided expression, which allows not only to read, but also to write values ‚Äã‚Äãto the elements of the array: <br><pre> <code class="dos hljs">$ g++ -Wall -std=c++<span class="hljs-number"><span class="hljs-number">11</span></span> -O3 siz3.cc -o siz3 $ ./siz3 <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">81</span></span></code> </pre><br>  <b>Postscript:</b> Naturally, that what is described here, and even more in the subsequent parts, not only works, but at least even elementarily compiles: <br><br><ul><li>  When compiling examples, one should explicitly indicate the following standard C ++ 11: either by the command line option (GCC and Clang - as shown in the text), or in the properties of the compiled project (Code :: Blocks).  Implicitly using C ++ 11 constructs is not yet supported. </li><li>  It is necessary for your compiler to know and support the C ++ 11 standard, that is, the compiler (or the IDE as part of which) was later ... well, let's say, 2013. </li></ul><br>  The last condition is completely satisfied by all the current versions of GCC or Clang in Linux.  At the request of readers, the following code examples (hereinafter) were tested in the Windows 7 virtual machine, and in the implementations of Visual Sudio 2013 and Code :: Blocks 2013. With stated support for C ++ 11 (with reservations on ‚Äúincompleteness‚Äù) in Visual Sudio 2013, the support there, if any, is very limited, and the compiler is not suitable for experimenting with the examples shown.  But Code :: Blocks (with MinGW) turned out to be quite suitable (although, in my firm conviction, it is necessary to <b>learn</b> C ++ languages, and especially C, only in the POSIX / Linux environment, and then <b>use it</b> in any environment ... but this is a purely personal conviction, which can not be taken into account). <br><br>  From such a cursory review of arrays as containers, it is clear that practice needs often require more, which created a need for STL (Standard Template Library) containers as a means of expanding the functionality of arrays. </div><p>Source: <a href="https://habr.com/ru/post/278039/">https://habr.com/ru/post/278039/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278023/index.html">Experiment: the creation of an algorithm for predicting the behavior of stock indices</a></li>
<li><a href="../278025/index.html">Security Week 08: Mice theft through a whistle, Blockbuster operation, Linux Mint with backdoor</a></li>
<li><a href="../278031/index.html">Problems of access control based on the access list in ECM systems (part 2)</a></li>
<li><a href="../278033/index.html">TOM.js is a special library for special cases.</a></li>
<li><a href="../278037/index.html">Handlersocket protocol in detail</a></li>
<li><a href="../278041/index.html">Personalize IMGUI and Unity Editor. Part one</a></li>
<li><a href="../278043/index.html">The story of the endless city. On Three.js</a></li>
<li><a href="../278045/index.html">Configuring fault tolerance in 3CX Version 14</a></li>
<li><a href="../278047/index.html">jsPDF + canvas: export to PDF of a multipage table in Russian</a></li>
<li><a href="../278049/index.html">How to create your own Dependency Injection Container</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>