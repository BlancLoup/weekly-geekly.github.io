<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Text output in iOS: CoreText, NSAttributedString</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I would like to tell you about the text output on the screen in iOS. Initially, it was intended as a tutorial, then as a collection of unobvious facts...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Text output in iOS: CoreText, NSAttributedString</h1><div class="post__text post__text-html js-mediator-article">  I would like to tell you about the text output on the screen in iOS.  Initially, it was intended as a tutorial, then as a collection of unobvious facts, but it turned out what happened. <br><br>  Methods of text output can be divided into several categories: <br><br><ul><li>  <b>UIKit</b> - familiar UI controls.  Only basic display capabilities, very little formatting capabilities. </li><li>  <b>UIKit + NSAttributedString</b> - familiar UI controls with the ability to set a string with display attributes.  A bunch of formatting options </li><li>  <b>CoreText</b> - a framework for working with text and text views.  In conjunction with NSAttributedString, there are plenty of possibilities for formatting text and, thanks to several levels of abstractions over text elements, advanced methods for displaying them. </li><li>  <b>CoreGraphics</b> - with it, you can also draw text </li></ul><br><a name="habracut"></a><br><h2>  NSAttributedString </h2><br>  First of all, you need to talk about the basic thing called <b>NSAttributedString</b> or <b>CFAttributedStringRef</b> if we work with toll-free-bridge objects.  This is a string with which to set display attributes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *textAttributes = @{(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)kCTFontAttributeName : [<span class="hljs-built_in"><span class="hljs-built_in">UIFont</span></span> systemFontOfSize:<span class="hljs-number"><span class="hljs-number">16</span></span>]}; <span class="hljs-built_in"><span class="hljs-built_in">NSAttributedString</span></span> *attributedString = [[<span class="hljs-built_in"><span class="hljs-built_in">NSAttributedString</span></span> alloc] initWithString:LoremIpsum attributes:textAttributes];</code> </pre> <br>  This code creates a string with a single display attribute: the font that you want to use when drawing the string.  It looks like this: <br><img src="https://habrastorage.org/storage2/03c/096/99d/03c09699dc87fd468b8f992cd991c67b.png"><br><br>  Here we need to highlight one important point that <a href="https://habrahabr.ru/users/demoniacdeath/" class="user_link">DemoniacDeath</a> kindly reminded me of in the comments: CoreText for drawing uses CTFont, which is actually a toll-free-bridge to UIFont starting only from iOS6.  Therefore, the type conversion, which is used in the examples for brevity, will work only on iOS6, and on everything below it you need to create a CTFont based on a UIFont: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CTFont</span></span> ctFont = (__bridge_transfer <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)<span class="hljs-built_in"><span class="hljs-built_in">CTFontCreateWithName</span></span>(uiFont.fontName, uiFont.pointSize, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  So, there are quite a few standard attributes available: <br><br><ul><li>  <b>kCTForegroundColorAttributeName</b> - font color </li><li>  <b>kCTUnderlineStyleAttributeName</b> - text underline style: <i>CTUnderlineStyle imposes</i> on underline type: single line, thick single, double;  <i>CTUnderlineStyleModifiers</i> affects the type of line: dashed, dots, etc </li><li>  <b>kCTUnderlineColorAttributeName</b> - underline color </li><li>  <b>kCTForegroundColorFromContextAttributeName</b> - whether to take the color from the graphic context.  If YES, then the <i>kCTUnderlineColorAttributeName</i> and <i>kCTUnderlineStyleAttributeName</i> parameters will not affect the color, but the context color <i>CGContextSetFillColorWithColor</i> will be used </li><li>  <b>kCTLigatureAttributeName</b> - mode of using <a href="http://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25B3%25D0%25B0%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_(%25D1%2581%25D0%25BE%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B1%25D1%2583%25D0%25BA%25D0%25B2)">ligatures</a> .  Modes: <br><ol><li>  0 specifies that only those ligatures that are necessary for the normal display of characters will be used. </li><li>  1 specifies that only standard ligatures will be used.  Which ligatures will be standard depends on the font and language.  For example, for English it is fl and fi.  Hebrew, Arabic, Thai - its own interesting characters. </li><li>  2 specifies that, if possible, the maximum characters should be grouped into ligatures. </li></ol></li><li>  <b>kCTParagraphStyleAttributeName</b> - there may be paragraphs in the text.  This parameter defines the paragraph style.  All parameters can be found in the definition of <b>CTParagraphStyleSpecifier</b> .  I would like to separately pay attention to <b>kCTParagraphStyleSpecifierBaseWritingDirection</b> - determines the text display direction (from left to right / from right to left) for the current paragraph.  The default is <i>kCTWritingDirectionNatural</i> - the display direction will be chosen according to <a href="http://www.unicode.org/reports/tr9/">this document</a> .  But you can set the input direction manually by setting <i>kCTWritingDirectionLeftToRight</i> / <i>kCTWritingDirectionRightToLeft</i> </li><li>  <b>kCTRunDelegateAttributeName</b> is a very important and interesting parameter.  At the input, it takes a set of functions that return the width and a few more parameters, based on which the row height is calculated.  Then I will talk about this parameter in more detail and its application. </li></ul><br>  For example, text with kerning 3.0, font size 14 and underline, indent all text to the right by 20.0 points, a red line by 40.0 points and a distance between paragraphs of 30.0 points: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CTParagraphStyleSetting</span></span> paragraphSettings[] = (<span class="hljs-built_in"><span class="hljs-built_in">CTParagraphStyleSetting</span></span>[]){ (<span class="hljs-built_in"><span class="hljs-built_in">CTParagraphStyleSetting</span></span>){ kCTParagraphStyleSpecifierFirstLineHeadIndent, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(float_t), (float_t[]){ <span class="hljs-number"><span class="hljs-number">40.0</span></span>f } }, (<span class="hljs-built_in"><span class="hljs-built_in">CTParagraphStyleSetting</span></span>){ kCTParagraphStyleSpecifierHeadIndent, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(float_t), (float_t[]){ <span class="hljs-number"><span class="hljs-number">20.0</span></span>f } }, (<span class="hljs-built_in"><span class="hljs-built_in">CTParagraphStyleSetting</span></span>){ kCTParagraphStyleSpecifierParagraphSpacing, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(float_t), (float_t[]){ <span class="hljs-number"><span class="hljs-number">30.0</span></span>f } } }; <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> paragraphStyle = (__bridge_transfer <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)<span class="hljs-built_in"><span class="hljs-built_in">CTParagraphStyleCreate</span></span>(paragraphSettings, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(paragraphSettings) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(paragraphSettings[<span class="hljs-number"><span class="hljs-number">0</span></span>])); <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *textAttributes = @{ (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)kCTFontAttributeName : [<span class="hljs-built_in"><span class="hljs-built_in">UIFont</span></span> systemFontOfSize:<span class="hljs-number"><span class="hljs-number">14</span></span>], (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)kCTKernAttributeName : @(<span class="hljs-number"><span class="hljs-number">3.0</span></span>), (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)kCTUnderlineStyleAttributeName : @(kCTUnderlineStyleSingle), (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)kCTParagraphStyleAttributeName : paragraphStyle };</code> </pre><br><img src="https://habrastorage.org/storage2/481/89e/7d5/48189e7d56c8556d7aa0dac04ca49664.png"><br><br><h2>  Drawing </h2><br><h4>  Uikit </h4><br>  Now how it all can be drawn.  Starting from iOS6 in <b>UIKit</b> , the <b>NSAttributedString</b> category now has the <b>NSStringDrawing</b> category and you can simply do this: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *textAttributes = @{(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)kCTFontAttributeName : [<span class="hljs-built_in"><span class="hljs-built_in">UIFont</span></span> systemFontOfSize:<span class="hljs-number"><span class="hljs-number">16</span></span>]}; <span class="hljs-built_in"><span class="hljs-built_in">NSAttributedString</span></span> *attributedString = [[<span class="hljs-built_in"><span class="hljs-built_in">NSAttributedString</span></span> alloc] initWithString:LoremIpsum attributes:textAttributes]; [attributedString drawInRect:rect];</code> </pre><br>  There is another method: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)drawWithRect:(<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>)rect options:(<span class="hljs-built_in"><span class="hljs-built_in">NSStringDrawingOptions</span></span>)options context:(<span class="hljs-built_in"><span class="hljs-built_in">NSStringDrawingContext</span></span> *)context;</code> </pre><br>  which pretends to be supposedly customizable with the help of passed parameters and special context.  Frankly, I have never used these methods, because the minimum version of iOS that we support in our product is 4.3. <br>  You can also pass the generated <b>NSAttributedString</b> to a <b>UILabel</b> , <b>UITextField,</b> or <b>UITextView</b> via the <b>setAttributedString</b> method <b>:.</b>  This method is also supported only with iOS6.0.  By the way, for these elements, starting with iOS6.0, attributes for display can be set directly in InterfaceBuilder in xib or storyboard. <br><br><h4>  Coretext </h4><br>  <b>CoreText</b> is such a cool thing that allows you to draw text on several levels of abstractions.  It also allows you to access elementary parts of the text display on several levels. <br>  Before I begin to talk further, I want to say that by this moment it is implied that you know what a graphic context is and are familiar with affine transformations. <br>  I‚Äôm also stealing a picture from an Apple site: <br><br><img src="https://habrastorage.org/storage2/d53/09a/fcf/d5309afcf0a444d1d97061e6f04463f1.jpg"><br><br><h5>  First level.  CTFramesetter </h5><br>  At this level, we still can not draw.  The only role of this abstraction: to create objects for drawing, which will be inscribed in geometric primitives, using text with specified styles.  Also, using the <b>CTFramesetter,</b> you can fix the width or height, find the height or width for the current text with the current display settings. <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *textAttributes = @{(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)kCTFontAttributeName : [<span class="hljs-built_in"><span class="hljs-built_in">UIFont</span></span> systemFontOfSize:<span class="hljs-number"><span class="hljs-number">16</span></span>]}; <span class="hljs-built_in"><span class="hljs-built_in">NSAttributedString</span></span> *attributedString = [[<span class="hljs-built_in"><span class="hljs-built_in">NSAttributedString</span></span> alloc] initWithString:LoremIpsum attributes:textAttributes]; <span class="hljs-built_in"><span class="hljs-built_in">CTFramesetterRef</span></span> framesetter = <span class="hljs-built_in"><span class="hljs-built_in">CTFramesetterCreateWithAttributedString</span></span>((__bridge <span class="hljs-built_in"><span class="hljs-built_in">CFAttributedStringRef</span></span>)(attributedString)); <span class="hljs-built_in"><span class="hljs-built_in">CGSize</span></span> suggestedSize = <span class="hljs-built_in"><span class="hljs-built_in">CTFramesetterSuggestFrameSizeWithConstraints</span></span>(framesetter, <span class="hljs-built_in"><span class="hljs-built_in">CFRangeMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">CGSizeMake</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CGRectGetWidth</span></span>(rect), <span class="hljs-built_in"><span class="hljs-built_in">CGFLOAT_MAX</span></span>), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Here is fixed the width in which you want to enter the text.  <b>suggestedSize</b> will contain the desired text height.  The same can be done with the width. <br><br><h5>  Second level.  CTFrame </h5><br>  This object creates the above described <b>CTFramesetter</b> and it is already fully ready for drawing. <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CGPathRef</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">CGPathCreateWithRect</span></span>((<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>){<span class="hljs-built_in"><span class="hljs-built_in">CGPointZero</span></span>, suggestedSize}, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">CTFrameRef</span></span> textFrame = <span class="hljs-built_in"><span class="hljs-built_in">CTFramesetterCreateFrame</span></span>(framesetter, <span class="hljs-built_in"><span class="hljs-built_in">CFRangeMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">CTFrameDraw</span></span>(textFrame, context);</code> </pre><br>  I want to elaborate on the parameters of the following method: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CTFrameRef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTFramesetterCreateFrame</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">CTFramesetterRef</span></span> framesetter, <span class="hljs-built_in"><span class="hljs-built_in">CFRange</span></span> stringRange, <span class="hljs-built_in"><span class="hljs-built_in">CGPathRef</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">CFDictionaryRef</span></span> frameAttributes )</code> </pre><br><ul><li>  <b>framesetter</b> - the object itself, containing a string with attributes, for which you need to build a graphic display </li><li>  <b>stringRange</b> - the section of the line for which the mapping will be built.  A length of 0 means that the line must be taken to the end, starting from the current position.  That is, CFRange (0,0) denotes a string from beginning to end </li><li>  <b>path</b> - sets a set of geometric primitives, into which the text should be entered </li><li>  <b>frameAttributes</b> - additional parameters for fitting.  For example, <b>kCTFramePathFillRuleAttributeName</b> sets the rule for how the text will be kept in the <a href="http://developer.apple.com/library/mac/">intersected areas</a> ;  <b>kCTFrameProgressionAttributeName</b> determines the order in which lines are created: from bottom to top (horizontal text) or from right to left (vertical text) </li></ul><br>  A couple of examples. <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CGMutablePathRef</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">CGPathCreateMutable</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">CGPathAddEllipseInRect</span></span>(path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, (<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>){<span class="hljs-built_in"><span class="hljs-built_in">CGPointZero</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">CGSizeMake</span></span>(suggestedSize.width, suggestedSize.height / <span class="hljs-number"><span class="hljs-number">2</span></span>)}); <span class="hljs-built_in"><span class="hljs-built_in">CGPathAddEllipseInRect</span></span>(path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, (<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>){<span class="hljs-number"><span class="hljs-number">0</span></span>, suggestedSize.height / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">CGSizeMake</span></span>(suggestedSize.width, suggestedSize.height / <span class="hljs-number"><span class="hljs-number">2</span></span>)});</code> </pre><br><img src="https://habrastorage.org/storage2/474/68e/b91/47468eb91cc8055b98a235c559950919.png"><br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CGAffineTransform</span></span> transformation = <span class="hljs-built_in"><span class="hljs-built_in">CGAffineTransformMakeRotation</span></span>(M_PI_4); <span class="hljs-built_in"><span class="hljs-built_in">CGPathAddEllipseInRect</span></span>(path, &amp;transformation, <span class="hljs-built_in"><span class="hljs-built_in">CGRectMake</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">-200</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">130</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">CGPathAddRect</span></span>(path, &amp;transformation, <span class="hljs-built_in"><span class="hljs-built_in">CGRectMake</span></span>(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">-150</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>));</code> </pre><br><img src="https://habrastorage.org/storage2/9a6/9ea/3ae/9a69ea3ae1d7a5d9454affc9f4e5cdda.png"><br><br>  The last example also uses the <b>kCTFramePathFillWindingNumber</b> parameter for the <b>CTFrame</b> , so the intersected areas are also filled with text. <br><br>  Two more important points: <br><ol><li>  If you try one of the above examples, the result will be very different from the one I gave, namely: the image will be inverted, since <b>CoreText</b> forms an image starting from the bottom left corner, as in any <b>CGContext</b> created, for example, <b>CGBitmapContext</b> .  Therefore, for correct output, you need to convert the current graphics context. </li><li>  It is possible and necessary to set the transformation only for the text, and not for the whole graphic context.  This is done via <b>CGContextSetTextMatrix</b> .  The peculiarity of this thing is that <b>CGSave / RestoreContext</b> does not save or restore the transformation matrix for text.  Therefore, it must always be set before drawing, otherwise it may contain values ‚Äã‚Äãthat were set in any other call to this method in the depths of the system libraries or simply in other parts of your program. </li></ol><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CGContextSetTextMatrix</span></span>(context, <span class="hljs-built_in"><span class="hljs-built_in">CGAffineTransformIdentity</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">CGContextScaleCTM</span></span>(context, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">-1.0</span></span>f); <span class="hljs-built_in"><span class="hljs-built_in">CGContextTranslateCTM</span></span>(context, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, -suggestedSize.height);</code> </pre><br>  This is what will happen to a non-unit transformation matrix: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CGContextSetTextMatrix</span></span>(context, <span class="hljs-built_in"><span class="hljs-built_in">CGAffineTransformMakeRotation</span></span>(M_PI_4)); <span class="hljs-built_in"><span class="hljs-built_in">CGContextScaleCTM</span></span>(context, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">-1.0</span></span>f); <span class="hljs-built_in"><span class="hljs-built_in">CGContextTranslateCTM</span></span>(context, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, -suggestedSize.height);</code> </pre><br><img src="https://habrastorage.org/storage2/df3/2c8/561/df32c856181a1d3d2368d2f69c05a155.png"><br><br>  Before further raskaz I would like to steal another image from the site of the Apple: <br><br><img src="https://habrastorage.org/storage2/98d/846/9c4/98d8469c4acf1ad9f182e4975b86c823.jpg"><br><br><h5>  Lyrical digression.  CTTypesetter </h5><br>  It is this entity that is involved in the creation of a <b>CTFrame</b> .  Her role is to create the very textual graphic primitives that are already ready for drawing at this stage.  He carries out the transfer of lines according to a given algorithm (according to words, symbols, etc), cuts off all that did not fit. <br><br><h5>  Level three.  CTLine </h5><br>  This is what <b>CTFrame</b> consists of.  <b>CTLine</b> can be drawn by specifying the positions for which they will be located: by taking the calculated from the <b>CTFrame</b> using the <b>CTFrameGetLineOrigins</b> method or by asking for some Very Tricky Algorithm. <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CFArrayRef</span></span> lines = <span class="hljs-built_in"><span class="hljs-built_in">CTFrameGetLines</span></span>(textFrame); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">CFIndex</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, linesCount = <span class="hljs-built_in"><span class="hljs-built_in">CFArrayGetCount</span></span>(lines); i &lt; linesCount; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> lineOrigin = <span class="hljs-built_in"><span class="hljs-built_in">CGPointZero</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">CTFrameGetLineOrigins</span></span>(textFrame, <span class="hljs-built_in"><span class="hljs-built_in">CFRangeMake</span></span>(i, <span class="hljs-number"><span class="hljs-number">1</span></span>), &amp;lineOrigin); <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetTextPosition</span></span>(context, lineOrigin.x, lineOrigin.y); <span class="hljs-built_in"><span class="hljs-built_in">CTLineDraw</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CFArrayGetValueAtIndex</span></span>(lines, i), context); }</code> </pre><br>  What else is definitely worth knowing.  The line has several typographical parameters: <i>baseline</i> , <i>ascent</i> , <i>descent</i> , <i>leading</i> .  About each can be read <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B8%25D1%258F_(%25D1%2582%25D0%25B8%25D0%25BF%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0)">here</a> .  <b>CTFrameGetLineOrigins</b> returns exactly the <i>baseline</i> .  The remaining parameters can be found through the method: <br><br><pre> <code class="objectivec hljs">doubCTLineGetTypographicBounds(<span class="hljs-built_in"><span class="hljs-built_in">CTLineRef</span></span> line, <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>* ascent, <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>* descent, <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>* leading);</code> </pre><br><img src="http://habrastorage.org/storage2/1fe/136/52c/1fe13652cd5f32fa3abcb9e078f5e662.png"><br>  Red color - descent, black - baseline, blue - ascent. <br><br>  We will return to these parameters.  In the meantime, I want to note that <i>descent</i> and <i>ascent</i> will be taken for the entire line as the minimum and maximum for all fonts that are used in the line.  For example, for the text above, it is clearly seen that in the line where Hebrew is present, the <i>descent is</i> greater. <br><br>  Some more useful methods: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CFRange</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTLineGetStringRange</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTLineRef</span></span> line)</code> </pre><br>  Returns the string line for the current line.  It is very often used in algorithms when only certain lines are needed that fall into a selected string interval. <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CFIndex</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTLineGetStringIndexForPosition</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTLineRef</span></span> line, <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> position)</code> </pre><br>  Returns the string index for the specified position in the string.  For example, it can be used to define clicks on certain areas of text.  Note that the context is inverted, and (0,0) will be at the very bottom line. <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CTLineRef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTLineCreateWithAttributedString</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CFAttributedStringRef</span></span> string)</code> </pre><br>  To draw a line, it is not necessary to create the whole chain from CTFramesetter-&gt; CTFrame-&gt; CTLine.  You can create a line immediately.  Quite often, the problem also arises to cut it if the text does not fit into a given area: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CTLineRef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTLineCreateTruncatedLine</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTLineRef</span></span> line, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> width, <span class="hljs-built_in"><span class="hljs-built_in">CTLineTruncationType</span></span> truncationType, <span class="hljs-built_in"><span class="hljs-built_in">CTLineRef</span></span> truncationToken)</code> </pre><br><h5>  Fourth level  CTrun </h5><br>  Probably the most useful abstraction for someone who writes his element to enter text.  <b>CTRun</b> is what groups characters with the same styles for grouped drawing.  Or rather, they are grouped starting from iOS6.0, and in everything that is younger - each character will be a separate <b>CTRun</b> .  From the very beginning, you need to understand one easy and obvious point: there are symbols, but there are <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BB%25D0%25B8%25D1%2584">glyphs</a> .  Two more points follow from this fact, which are also light, but already unobvious: one character can consist of one glyph, and maybe of several;  one glyph can represent several characters at once.  For example, most emoticons are one glyph, but consist of several UTF characters. <br>  To all those who are going to work with <b>CTRun,</b> I strongly recommend that you familiarize yourself with CTRun.h - all the methods that are there are extremely useful. <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CFIndex</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetGlyphCount</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTRunRef</span></span> run)</code> </pre><br>  Returns the number of glyphs in <b>CTRun</b> . <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CFRange</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetStringRange</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTRunRef</span></span> run)</code> </pre><br>  Returns the range from the whole line in which <b>CTRun</b> is located.  The length of this range is not always equal to the result of the previous method! <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CFIndex</span></span>* <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetStringIndicesPtr</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTRunRef</span></span> run) <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetStringIndices</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTRunRef</span></span> run, <span class="hljs-built_in"><span class="hljs-built_in">CFRange</span></span> range, <span class="hljs-built_in"><span class="hljs-built_in">CFIndex</span></span> buffer[])</code> </pre><br>  This method is related to the previous one.  It returns the position of the glyphs in the string.  For example, there is a text from several emoticons: <br><img src="http://habrastorage.org/storage2/1d6/f32/e44/1d6f32e4471c8069d8c43c4d143f96d8.png"><br><br>  Starting with iOS6.0 <b>CTrun</b> will be as follows: <br> <code>CTRun: string range = (0, 6), string = "\U0001f437\U0001f434\U0001f428"</code> <br>  As you can see, each glyph actually consists of two characters.  The result of calling the <b>CTRunGetStringIndices</b> method is: [0,2,4]. <br><br>  Please note that this method is available in two variants: copy the required number of indexes into the buffer selected in advance, or get a pointer to the beginning of the array inside <b>CTRun</b> .  Choose what is more convenient for you.  There are quite a few such methods, it can be seen from the signatures, and I will not focus on this. <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CFDictionaryRef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetAttributes</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTRunRef</span></span> run)</code> </pre><br>  The current attributes for <b>CTRun</b> that were specified in <b>CFAttributedString</b> . <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CTRunStatus</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetStatus</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTRunRef</span></span> run)</code> </pre><br>  Returns the display-specific parameters as a bitmask.  Pay special attention to <b>kCTRunStatusRightToLeft</b> - shows that the glyphs in <b>CTRun</b> are written from right to left. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>* <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetPositionsPtr</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTRunRef</span></span> run) <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetPositions</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTRunRef</span></span> run, <span class="hljs-built_in"><span class="hljs-built_in">CFRange</span></span> range, <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> buffer[])</code> </pre><br>  Positions for the glyphs inside <b>CTRun</b> relative to the <b>CTFrame</b> .  I pay special attention to the fact that if you use the second variant of the method and want to take positions of, say, the second glyph, then in the range you need to transfer not 1 (the numbering starts from 0), but the position of this glyph in the line.  For the emoticon version, which was higher, this would be position 2. This applies to all similar methods. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CGSize</span></span>* <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetAdvancesPtr</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTRunRef</span></span> run) <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetAdvances</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTRunRef</span></span> run, <span class="hljs-built_in"><span class="hljs-built_in">CFRange</span></span> range, <span class="hljs-built_in"><span class="hljs-built_in">CGSize</span></span> buffer[])</code> </pre><br>  Returns the size of glyphs. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetTypographicBounds</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTRunRef</span></span> run, <span class="hljs-built_in"><span class="hljs-built_in">CFRange</span></span> range, <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>* ascent, <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>* descent, <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>* leading)</code> </pre><br>  Returns typographical parameters for a single <b>CTRun</b> .  Remember I said that the <i>descent</i> and <i>ascent</i> lines will be taken as extreme for the fonts that were used in this line?  So, now for each part of the line you can find them separately: <br><img src="http://habrastorage.org/storage2/44a/a71/d06/44aa71d06065cbd3473999db3dbe2af1.png"><br><br>  Also, when it became clear what <i>descent</i> and <i>ascent are,</i> I‚Äôll tell you about the <b>kCTRunDelegateAttributeName</b> attribute.  At the input it takes <b>CTRunDelegate</b> , which is created based on a number of methods: <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">CFIndex</span></span> version; <span class="hljs-built_in"><span class="hljs-built_in">CTRunDelegateDeallocateCallback</span></span> dealloc; <span class="hljs-built_in"><span class="hljs-built_in">CTRunDelegateGetAscentCallback</span></span> getAscent; <span class="hljs-built_in"><span class="hljs-built_in">CTRunDelegateGetDescentCallback</span></span> getDescent; <span class="hljs-built_in"><span class="hljs-built_in">CTRunDelegateGetWidthCallback</span></span> getWidth; } <span class="hljs-built_in"><span class="hljs-built_in">CTRunDelegateCallbacks</span></span>;</code> </pre><br>  We are interested in the last three.  Methods are free functions that return the <i>descent</i> , <i>ascent,</i> and width of the glyph that has been marked with this attribute.  A set of methods will be invoked each time the parameters of the current glyph should participate in the calculation of common geometric parameters.  This can be applied to create your own glyphs. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CTRunDraw</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CTRunRef</span></span> run, <span class="hljs-built_in"><span class="hljs-built_in">CGContextRef</span></span> context, <span class="hljs-built_in"><span class="hljs-built_in">CFRange</span></span> range)</code> </pre><br>  Draw <b>CTRun</b> in a graphic context. <br><br><h4>  CoreGraphics </h4><br><h5>  Level five.  Glyphs </h5><br>  Frankly, this level is no longer <b>CoreText</b> , but <b>CoreGraphics</b> - it was available before.  It's just easier now to get the glyphs. <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CFIndex</span></span> glyphCount = <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetGlyphCount</span></span>(run); <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> positions[glyphCount]; <span class="hljs-built_in"><span class="hljs-built_in">CGGlyph</span></span> glyphs[glyphCount]; <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetPositions</span></span>(run, <span class="hljs-built_in"><span class="hljs-built_in">CFRangeMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), positions); <span class="hljs-built_in"><span class="hljs-built_in">CTRunGetGlyphs</span></span>(run, <span class="hljs-built_in"><span class="hljs-built_in">CFRangeMake</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), glyphs); <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetFont</span></span>(context, cgFont); <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetFontSize</span></span>(context, <span class="hljs-built_in"><span class="hljs-built_in">CTFontGetSize</span></span>(runFont)); <span class="hljs-built_in"><span class="hljs-built_in">CGContextSetFillColorWithColor</span></span>(context, runColor); <span class="hljs-built_in"><span class="hljs-built_in">CGContextShowGlyphsAtPositions</span></span>(context, glyphs, positions, glyphCount);</code> </pre><br>  It should be understood that in this case things like underscore styles will not be available, since they are implemented via <b>CoreText</b> .  But when drawing, we are free to arrange the glyphs as desired. <br><br>  Apple, as always, is true to its traditions in designing APIs: for simple things, you can‚Äôt go far and just call the ‚Äúdo-it-good‚Äù method, and for more complex things, you can twist the strings and pull the wheels. </div><p>Source: <a href="https://habr.com/ru/post/172661/">https://habr.com/ru/post/172661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../172643/index.html">School business is not a hindrance. 10 entrepreneurs from 7 to 15 years</a></li>
<li><a href="../172647/index.html">About the intricacies of foreach in PHP</a></li>
<li><a href="../172651/index.html">Building a system for optical recognition of structural information on the example of Imago OCR</a></li>
<li><a href="../172653/index.html">On the responsibility of advertisers placing advertisements on torrents and file hosting</a></li>
<li><a href="../172655/index.html">Device and setting of EPU at cellular base station</a></li>
<li><a href="../172663/index.html">The realities of the Chinese Internet</a></li>
<li><a href="../172665/index.html">Google reader close</a></li>
<li><a href="../172671/index.html">Google arranges spring cleaning and bans AdBlock in Android</a></li>
<li><a href="../172673/index.html">Why did Google decide to close Google Reader or how popular is RSS?</a></li>
<li><a href="../172677/index.html">12 projects will receive $ 25,000 for development from the creator of VKontakte Pavel Durov and Yuri Milner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>