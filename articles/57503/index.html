<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Catamorphism in F #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 I‚Äôll mention right away that this article was written based on a whole series of posts on the excellent blog Inside F # . Nevertheless,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Catamorphism in F #</h1><div class="post__text post__text-html js-mediator-article"><h3>  Introduction </h3><br>  I‚Äôll mention right away that this article was written based on a whole series of posts on the excellent blog <a href="http://lorgonblog.spaces.live.com/">Inside F #</a> .  Nevertheless, it is not a translation in its pure form, but rather a free statement, in order to explain in accessible language what kind of animal this catamorphism is, and what it is eaten with.  I think this word is not very popular, which is at least the fact that there are no articles on it in the Russian Wikipedia (and in general not in one national, except for some reason the Dutch one. Probably the OP somehow corresponds to the spirit of anger smoking) <br>  So, strictly speaking, <a href="http://en.wikipedia.org/wiki/Catamorphism">catamorphism</a> in functional programming is a generalization of the convolution of lists, which (as I have already <a href="http://habrahabr.ru/blogs/programming/55272/">said</a> ) are a specific type of labeled union, to arbitrary labeled associations. <br><a name="habracut"></a><br><h3>  Roll-up lists </h3><br>  Let's start in order - with the convolution of lists.  Actually, we already know what it is and how to use it, but in order to extend it to other data types, we still need to understand how it is implemented. <br>  Here we have a task - to sum up the elements of the list.  And as you know <s>, there is no sex in the USSR</s> .  (Of course there is, but we will not tell anyone about this).  Variant List.fold_left (+) 0 is officially declared cheat.  What comes to mind?  Well, like this (in the style of beloved teachers, examples of recursion for Fibonacci or factorial): <br><blockquote><code><font color="black"><font color="#0000ff">let</font> <font color="#0000ff">rec</font> sum list = <br> <font color="#0000ff">match</font> list <font color="#0000ff">with</font> <br> |[] <font color="#0000ff">-&gt;</font> 0 <br> |head::tail <font color="#0000ff">-&gt;</font> head + sum tail <br></font></code> </blockquote><br>  No friends, this is certainly a solution, but let's be honest with ourselves - there is nothing to brag about.  Because with a cycle length, say, a million, the compiler will give us a System. StackOverflowException, and it will be a thousand times right ‚Äî you can't mock it like that.  Ok, rewrite this case as tail recursion: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> sum_tail list = <br> <font color="#0000ff">let</font> <font color="#0000ff">rec</font> loop list acc = <br> <font color="#0000ff">match</font> list <font color="#0000ff">with</font> <br> |[] <font color="#0000ff">-&gt;</font> acc <br> |head::tail <font color="#0000ff">-&gt;</font> loop tail (acc+head) <br> loop list 0 <br></font></code> </blockquote><br>  Here we have all the calculations immediately, so dragging the whole tail along doesn‚Äôt have any need for the compiler, which always makes him happy.  Well, well, what if we need to say to find the length of the list (again without the List.length method)?  No problem. <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> <font color="#0000ff">rec</font> length list = <br> <font color="#0000ff">let</font> <font color="#0000ff">rec</font> loop list acc = <br> <font color="#0000ff">match</font> list <font color="#0000ff">with</font> <br> |[] <font color="#0000ff">-&gt;</font> acc <br> |head::tail <font color="#0000ff">-&gt;</font> loop tail (acc+1) <br> loop list 0 <br></font></code> </blockquote><br>  I think that even the most observant reader can see the similarity of these two algorithms.  The only difference is in the way the battery value is processed.  In the first case, for each element under consideration (the head of the remaining piece of the list) we add its value to the battery, in the second - just one.  What is it really?  Nothing more than a function of 'a <font color="#0000ff">-&gt;</font> ' b <font color="#0000ff">-&gt;</font> 'a, where' a is a battery type, 'b is a type of a list item. <br>  <font color="#0000ff">fun</font> acc h <font color="#0000ff">-&gt;</font> acc + h (or just (+)) for the first, <font color="#0000ff">fun</font> acc h <font color="#0000ff">-&gt;</font> acc + 1 for the second.  Convolution of a list is just a higher-order function that applies such a function to all elements of the list in order to get some kind of atomic value.  Here's what it looks like: <br><blockquote> <code><font color="black"><font color="#008000">// ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; list&lt;'b&gt; -&gt; 'a</font> <br> <font color="#0000ff">let</font> <font color="#0000ff">rec</font> fold func acc list = <br> <font color="#0000ff">match</font> list <font color="#0000ff">with</font> <br> |[] <font color="#0000ff">-&gt;</font> acc <br> |head::tail <font color="#0000ff">-&gt;</font> fold func (func acc head) tail <br></font></code> </blockquote><br>  And it is obvious that: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> sum_tail = fold (+) 0 <br> <font color="#0000ff">let</font> length = fold ( <font color="#0000ff">fun</font> acc _ <font color="#0000ff">-&gt;</font> acc + 1) 0 <br></font></code> </blockquote><br>  By the way, you should not be so formal with the words that convolution should return an atomic value.  See what this feature does? <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> reverse = fold ( <font color="#0000ff">fun</font> acc h <font color="#0000ff">-&gt;</font> h::acc) [] <br></font></code> </blockquote><br>  I think you guessed it turns the list over.  That is, its result is also a list - such is the atomic value itself. <br>  Well, well, sort of dealt with the convolution.  Not really, really.  After all, this is our so-called left-associative convolution, that is, we look at the elements and perform the coagulation function on them from head to tail.  So (f - coagulation function): f (... f (acc i0) i1) i2) ... ik) And how would we make a right associative function, so that it would be like this: f i0 (f ... (f ik acc)) )) (Why? Because it will be very convenient for her to spread our convolution to other data types) <br>  We write the function by analogy with the left associative convolution: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> <font color="#0000ff">rec</font> fold_right func acc list = <br> <font color="#0000ff">match</font> list <font color="#0000ff">with</font> <br> |[] <font color="#0000ff">-&gt;</font> acc <br> |head::tail <font color="#0000ff">-&gt;</font> func head (fold_right func acc tail) <br></font></code> </blockquote><br>  and note that we now have recursion inside the function calculation, so the compiler will have to drag it to the stack, in short, forgive-bye tail recursion, hello inevitable stack overflow.  To avoid this shame, we need to somehow get to the very end of the list, while remembering a sequence of elements in reverse order to collapse them.  But not in the stack, of course, to do this, as in the above example, but in some data structure.  The simplest way is obvious - expand the list, and then apply a left-associative convolution on it.  In this case, our supporting structure will be an inverted list.  Everything is simple and obvious. <br>  However, we will go the other way.  As an auxiliary structure, we will use the continuation function.  What it is?  - This is a function that contains all the necessary course of calculations, but does not perform, notice, the calculations themselves, until we specifically point out to her.  Here we want to get such a function: cont x = f i0 (f ... (f ik x)))), everything is strictly according to the definition.  At the right moment, it will take as a parameter the initial value of the battery and will count everything at once, as ordered.  A great feature, isn't it?  It remains to receive it: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> fold_right func acc list = <br> <font color="#0000ff">let</font> <font color="#0000ff">rec</font> loop list cont = <font color="#008000">//     </font> <br> <font color="#0000ff">match</font> list <font color="#0000ff">with</font> <br> |[] <font color="#0000ff">-&gt;</font> cont acc <font color="#008000">//     .</font> <br> |head::tail <font color="#0000ff">-&gt;</font> loop tail ( <font color="#0000ff">fun</font> racc <font color="#0000ff">-&gt;</font> cont (func head racc)) <br> loop list ( <font color="#0000ff">fun</font> x <font color="#0000ff">-&gt;</font> x) <br></font></code> </blockquote><br>  Notice that the function has now become tail-recursive again, all calculations are performed immediately, and the next recursion step is passed to their result ‚Äî the updated continuation function.  And yet, throughout the work of the function, until the list is exhausted, acc is equal to the initial value, that is, it is not worthy of being called a battery.  Rather, it is init_value.  And the continuation function itself changes from step to step like this: <br><blockquote> <code><font color="black">0: x -&gt; x <br> 1: x -&gt; f i0 x <br> 2: x -&gt; f i0 (f i1 x) <br> 3: x -&gt; f i0 (f i1 (f i2 x)) <br></font></code> </blockquote><br>  I think further to paint a course of calculations is not necessary.  Substituting the initial value instead of x, we get exactly what we wanted. <br>  Well, we figured out the convolutions of the lists.  True, it is not clear yet what the garden was for, but soon you will understand everything. <br><br><h3>  Convolution of trees </h3><br>  So, as mentioned in the introduction, cathamorphism is a generalization of the convolution of lists to any algebraic types, or labeled unions, as they are called in F #.  (As you remember, the list is also a marked association) <br>  And now we will consider the marked association: <br><blockquote> <code><font color="black"><font color="#0000ff">type</font> Tree&lt;'a&gt; = <br> | Node <font color="#0000ff">of</font> 'a * Tree&lt;'a&gt; * Tree&lt;'a&gt; <br> | Leaf <br></font></code> </blockquote><br>  It‚Äôs not hard to guess, we have a binary tree that has intelligent nodes (the tuple that describes it is a value and two branches), and stub sheets, the use of which in the node tuple simply means that it doesn‚Äôt have this branch . <br>  Here is an example of such a tree: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> tree = Node(4, Node(2,Node(1, Leaf,Leaf),Node(3,Leaf,Leaf)),Node(6,Node(5, Leaf,Leaf),Node(7,Leaf,Leaf))) <br></font></code> </blockquote><br>  And now we really want to perform some quite vital operations on this tree: to find the sum of all values, or to find the height, well, it would be useful to stretch the list.  The naive recursive solutions of these problems are as indigestible as the ones on the lists. <br>  For example, the simplest way to decompose into a list <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> <font color="#0000ff">rec</font> to_list tree = <br> <font color="#0000ff">match</font> tree <font color="#0000ff">with</font> <br> |Node(v, ltree, rtree) <font color="#0000ff">-&gt;</font> (to_list ltree)@[v]@(to_list rtree) <br> |Leaf <font color="#0000ff">-&gt;</font> [] <br></font></code> </blockquote><br>  This method is not only that again can lead to stack overflow, it also uses the concatenation function of lists, which, let's say in secret, processes them very inefficiently.  So we do not go. <br>  But it‚Äôs not for nothing that we, in the end, suffered for so long until we wrote fold_right using the continuation function.  It was no accident.  This method is very well applicable to wood. <br>  Note: And now, if you have drugs that expand consciousness in your home medicine cabinet, you do not take it for work, go and drink a pill.  May be useful. <br>  What is the difference between a tree and a list?  There was simply a second branch for each node.  That is, at each step of our convolution we will have not one, but two tails, and therefore the convolution function should have the form: 'b <font color="#0000ff">-&gt;</font> ' a <font color="#0000ff">-&gt;</font> 'a <font color="#0000ff">-&gt;</font> ' a, where the second and third arguments denote it batteries for the left and right tails.  Such will be the convolution function for summing and searching for height: <br><blockquote> <code><font color="black"><br> <font color="#0000ff">fun</font> x left right <font color="#0000ff">-&gt;</font> x + left + right <br> <font color="#0000ff">fun</font> _ left right <font color="#0000ff">-&gt;</font> 1 + max left right <br></font></code> </blockquote><br>  Let's try.  Since we have two possibilities at each stage to continue viewing, the nested loop should be double.  How to do it in relation to our function of continuation?  - very simple: <br><blockquote> <code><font color="black"><br> <font color="#0000ff">let</font> FoldTree treeF leafV tree = <br> <font color="#0000ff">let</font> <font color="#0000ff">rec</font> loop tree cont = <br> <font color="#0000ff">match</font> tree <font color="#0000ff">with</font> <br> |Node (val, left, right) <font color="#0000ff">-&gt;</font> loop left ( <font color="#0000ff">fun</font> lacc <font color="#0000ff">-&gt;</font> <br> loop right ( <font color="#0000ff">fun</font> racc <font color="#0000ff">-&gt;</font> <br> cont (treeF val lacc racc))) <br> |Leaf <font color="#0000ff">-&gt;</font> cont leafV <br> loop tree ( <font color="#0000ff">fun</font> x <font color="#0000ff">-&gt;</font> x) <br></font></code> </blockquote><br>  As you can see, here, in fact, at each step there are two continuation functions - one accumulates the value for the left subtree, the second, the inner one for the right, after which all this is folded using the treeF function.  When we hit the leaf, we apply the function we have accumulated for the current subtree to the initial value corresponding to the leaves - leafV. <br>  It can be noted that while we are going through the values ‚Äã‚Äãof the left subtree, the continuation function will accumulate recursive calls to the loop for the right subtrees, but it‚Äôs in the function and not in the stack, so from the point of view of the tails, everything is fine. <br>  Here‚Äôs how it looks for our tree: <br>  four <br>  2 6 <br>  1 3 5 7 <br><blockquote> <code><font color="black">4: x -&gt; x <br> 2: x -&gt; loop (6,5,7) (y -&gt; treeF 4 xy) <br> 1: x -&gt; loop (3) (y -&gt; loop (6,5,7) (z -&gt; treeF 4 (treeF 2 xy) z)) <br> Ll: x -&gt; loop Lr (y -&gt; loop (3) (z -&gt; loop (6,5,7) (q -&gt; treeF 4 (treeF 2 (treeF 1 xy) z) q)))</font></code> </blockquote> <br>  Here Ll is the left leaf, Lr is the right one.  Once on the leaf, we must apply the function to the initial value, which means we must also execute the outermost loop. <br><blockquote> <code><font color="black">Lr: y -&gt; loop (3) (z -&gt; loop (6,5,7) (q -&gt; treeF 4 (treeF 2 (treeF 1 leafV y) z) q))</font></code> </blockquote> <br>  Perform the same operation for the right sheet and we get: <br><blockquote> <code><font color="black">3: z -&gt; loop (6,5,7) (q -&gt; treeF 4 (treeF 2 (treeF 1 leafV leafV) z) q)</font></code> </blockquote> <br>  Notice that now (treeF 1 leafV leafV) is no longer a function, but a value, i.e.  for the leftmost tree (the one that is just 1), the fold has already been produced.  Then everything happens in the same way, I think the reader can imagine how. <br>  Now our desired operations are as follows: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> SumTree = FoldTree ( <font color="#0000ff">fun</font> x left right <font color="#0000ff">-&gt;</font> x + left + right) 0 <br> <font color="#0000ff">let</font> HeightTree = FoldTree ( <font color="#0000ff">fun</font> _ left right <font color="#0000ff">-&gt;</font> 1 + max left right) 0 <br> <font color="#0000ff">let</font> Tree2List = FoldTree ( <font color="#0000ff">fun</font> x left right <font color="#0000ff">-&gt;</font> left @ [x] @ right) <br></font></code> </blockquote><br>  In fact, the problem of concatenation in the last function is preserved, but, although it is solvable, we will not talk about this decision now, so as not to delve even more into the not so friendly jungle of AF. <br><br><h3>  Convolution on generalized tagged unions </h3><br>  Finally, we consider catamorphism on another curious type of labeled associations, which, relatively speaking, defines a programming language: <br><blockquote> <code><font color="black"><font color="#0000ff">type</font> Op = <br> |Plus <br> |Minus <br> <font color="#0000ff">override</font> this.ToString() = <br> <font color="#0000ff">match</font> this <font color="#0000ff">with</font> <br> |Plus <font color="#0000ff">-&gt;</font> <font color="#A31515">"+"</font> <br> |Minus -&gt; <font color="#A31515">"-"</font> <br> <br> <font color="#0000ff">type</font> Expr = <br> |Literal <font color="#0000ff">of</font> int <br> |BinaryOp <font color="#0000ff">of</font> Expr*Op*Expr <br> |IfThenElse <font color="#0000ff">of</font> Expr*Expr*Expr <br></font></code> </blockquote><br>  In this case, it is a very simple language for calculating mathematical expressions, provided with an additional conditional operator (for simplicity, we assume that any non-zero value of the expression in the condition corresponds to true).  An example of such an expression: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> expr = IfThenElse (Literal 1, BinaryOp (Literal 12, Minus, Literal 10), Literal 32) <br></font></code> </blockquote><br>  What would we like to do with this expression?  Well, for example, bring it in a digestible form: <br><blockquote> <code><font color="black">if 1 then (12 - 10) else 32 endif <br></font></code> </blockquote><br>  and also - actually calculate the result, here it will be 2. What will help us to simultaneously solve these two seemingly not similar tasks?  - right, katamorfizm.  I think, after the example on the trees, it will not be difficult to write a convolution for this type.  In addition to the expression itself, we need to have three more argument functions ‚Äî one for each type of expression.  We write the convolution function for it: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> FoldExpr funL funB funIf expr = <br> <font color="#0000ff">let</font> <font color="#0000ff">rec</font> loop expr cont = <br> <font color="#0000ff">match</font> expr <font color="#0000ff">with</font> <br> |Literal x <font color="#0000ff">-&gt;</font> cont (funL x) <br> |BinaryOp (left,op,right) <font color="#0000ff">-&gt;</font> loop left ( <font color="#0000ff">fun</font> lacc <font color="#0000ff">-&gt;</font> <br> loop right ( <font color="#0000ff">fun</font> racc <font color="#0000ff">-&gt;</font> <br> cont (funB lacc op racc))) <br> |IfThenElse (condExp,thenExp,elseExp) <font color="#0000ff">-&gt;</font> loop condExp ( <font color="#0000ff">fun</font> cacc <font color="#0000ff">-&gt;</font> <br> loop thenExp ( <font color="#0000ff">fun</font> tacc <font color="#0000ff">-&gt;</font> <br> loop elseExp ( <font color="#0000ff">fun</font> eacc <font color="#0000ff">-&gt;</font> <br> cont (funIf cacc tacc eacc)))) <br> loop e ( <font color="#0000ff">fun</font> x <font color="#0000ff">-&gt;</font> x) <br></font></code> </blockquote><br>  Look, absolutely nothing new compared to trees, except when considering IfThenElse we already have three nested loops, but this is not surprising, because we need to expand both the condition and the two possible branches of the continuation.  Functions funL, funB, funIf are used to process literals, binary operations and conditional operators, respectively. <br>  Now we can calmly write both functions we need.  So we will output an expression in a string (by the way, notice that we have not for nothing redefined the ToString () method in the Op type: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> Printer = <br> FoldExpr ( <font color="#0000ff">fun</font> x <font color="#0000ff">-&gt;</font> sprintf <font color="#A31515">"%d"</font> x) <font color="#008000">// </font> <br> ( <font color="#0000ff">fun</font> l op r <font color="#0000ff">-&gt;</font> sprintf <font color="#A31515">"(%s %s %s)"</font> l (op.ToString()) r) <font color="#008000">//  </font> <br> ( <font color="#0000ff">fun</font> cte <font color="#0000ff">-&gt;</font> sprintf <font color="#A31515">"if %s <font color="#0000ff">then</font> %s <font color="#0000ff">else</font> %s endif"</font> cte) <font color="#008000">//  </font> <br></font></code> </blockquote><br>  And now the ‚Äúcompiler‚Äù itself: <br><blockquote> <code><font color="black"><font color="#0000ff">let</font> Eval = <br> FoldExpr ( <font color="#0000ff">fun</font> x <font color="#0000ff">-&gt;</font> x) <br> ( <font color="#0000ff">fun</font> l op r <font color="#0000ff">-&gt;</font> <font color="#0000ff">match</font> op <font color="#0000ff">with</font> |Plus <font color="#0000ff">-&gt;</font> l + r |Minus <font color="#0000ff">-&gt;</font> l - r) <br> ( <font color="#0000ff">fun</font> cte <font color="#0000ff">-&gt;</font> <font color="#0000ff">if</font> c &gt; 0 then t else e) <br></font></code> </blockquote><br>  As you can see, the processing functions are very simple and intuitive. <br>  Of course, the Expr type itself is not very complicated in this example, but in fact with the help of labeled associations you can implement quite sophisticated ‚ÄúYAP‚Äù, well, not only ‚ÄúYAP‚Äù, of course.  And the convolution on such a marked union will most likely be an indispensable tool for all occasions.  Such is the catamorphism. <br>  PS I don‚Äôt know if it is worth transferring to a collective blog, this is a specific topic. <br>  UPD: I chose where to transfer for a long time, I decided to .Net as the most neutral. </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/57503/">https://habr.com/ru/post/57503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../57491/index.html">Do you think links should always be underlined?</a></li>
<li><a href="../57493/index.html">What are you reading my prince? Words words words‚Ä¶</a></li>
<li><a href="../57495/index.html">YouTube video full screen (Embedded)</a></li>
<li><a href="../57496/index.html">DRAM Price Forecast</a></li>
<li><a href="../57497/index.html">Opensource development on the example of the implementation of the IEEE802.11s standard mesh network support for the Nokia N810 Internet Tablet</a></li>
<li><a href="../57505/index.html">New car</a></li>
<li><a href="../57507/index.html">‚ÄúGrandma-online‚Äù - you give a computer to every pensioner!</a></li>
<li><a href="../57508/index.html">Irkutsk community of habra people</a></li>
<li><a href="../57512/index.html">How Star Wars Changed the World</a></li>
<li><a href="../57513/index.html">Gamer.ru opens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>