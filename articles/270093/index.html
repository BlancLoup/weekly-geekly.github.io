<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using RxJs to bind application components</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ways to "communicate" components 
 The client part of a modern web application is difficult to imagine without modularity, and it involves the exchang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using RxJs to bind application components</h1><div class="post__text post__text-html js-mediator-article"><h4>  Ways to "communicate" components </h4><br>  The client part of a modern web application is difficult to imagine without modularity, and it involves the exchange of data between modules or just communication.  The way this communication is organized depends on the complexity of the project and the technologies it uses. <br><br>  The first thing that comes to mind is publishing and subscribing to named events.  One of the components sends the event to "broadcast", and the rest listen to this "broadcast" and catch those messages that they need.  The idea is extremely simple and well-proven. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/af9/2e2/db7/af92e2db70024019a0dc02f51d5deb2b.png" alt="image"></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is somewhat reminiscent of WI-FI in a cafe, when everyone can exchange messages with everyone, but there is also a router (dispatcher), which ensures the existence of a ‚Äúbroadcast‚Äù and only gives messages to those to whom they are addressed. <br><br>  Such an organization allows, for example, ‚Äúfor free‚Äù to get a weak binding of components.  Its disadvantage is that with an increase in the number of components and, accordingly, the number of events, it becomes difficult to keep track of the names of events and who needs what events are necessary for proper operation.  The namespaces and event names appear from something like ‚ÄúEvent1‚Äù and turn into ‚ÄúApplication_stat1. Component2. Event1‚Äù.  And what is absolutely impossible to do with such an organization is to arrange events.  For example, the requirement ‚Äúdo something when event B occurs after two events A‚Äù results in a ton of local variables storing the latest data from the events and the counters of the events themselves. <br><a name="habracut"></a><br>  Promises are somewhat easier, they allow you to organize the sequence of events and are practically the first step in organizing data flows. <br><br>  Another way to organize communication between components is to stretch ‚Äúwires‚Äù between them, so that only those components that have something to ‚Äúsay‚Äù to each other are connected.  To present this method of binding visually, just look at any printed circuit board. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f09/dca/17c/f09dca17c07d4ff0af24b191b5b72d54.png" alt="image"></div><br><br>  Here, each component is connected to other, to it necessary components, tracks (‚Äúwires‚Äù) or simply ‚Äústreams‚Äù along which the signal is transmitted.  Now, to imagine what kind of data a component needs for work, you do not need to go into the ‚Äúblack box‚Äù and look for event subscriptions.  Just look at which components the streams come from and how the data is transformed along the way.  It is not necessary to name events at such an organization at all, rather a stream that carries data needs a name.  In this case, the task of arranging events is reduced to the composition of the streams containing them. <br><br><h4>  Thread implementation </h4><br>  To now move from words to action, you need to choose the implementation of our "wires."  For me, this implementation was <a href="https://github.com/Reactive-Extensions/RxJS">RxJS</a> , which is a modular library that allows you to create and compose data streams.  The approach used in Rx appeared in .NET and was ported to many popular languages ‚Äã‚Äãfrom there.  Depending on the complexity of the implemented logic, the project can be connected as all RxJS, and its separate <a href="https://github.com/Reactive-Extensions/RxJS">modules</a> .  Consider the key concepts. <br><br>  The streams created in Rx implement the Observable pattern and are inherited from the interface of the same name, which means that each stream can be ‚Äúlistened‚Äù.  This is implemented using the subscribe method, which takes an Observer as an argument. <br><br><pre><code class="javascript hljs">observableStream.subscribe(someObserver)</code> </pre> <br>  In the simplest case, Observer is a function that takes a single argument ‚Äî the transmitted message from the stream.  A message can be either a simple value or a complex object. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someObserver</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">streamEvent</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Received '</span></span> + streamEvent) }</code> </pre><br>  Threads, for example, can be used to handle DOM events.  The most convenient way is to organize a subscription to DOM events using the <a href="https://github.com/Reactive-Extensions/RxJS-jQuery">RxJS-jQuery</a> plugin. <br><br>  For example, a stream that will respond to button presses and send a DOM event as data can be created like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myAwesomeButtonClick = $(<span class="hljs-string"><span class="hljs-string">'#my-awesome-button'</span></span>).onAsObservable(<span class="hljs-string"><span class="hljs-string">'click'</span></span>)</code> </pre><br>  Now the stream myAwesomeButtonClick can be passed to another component if it needs to handle button presses.  To organize an arbitrary stream, Rx.Subject is used, which also implements the Observable pattern, but in addition to the Observable capabilities, it allows to throw arbitrary messages into the stream, for this the onNext method is used. <br><br><pre> <code class="javascript hljs">subjectStream.onNext(<span class="hljs-string"><span class="hljs-string">'new message'</span></span>)</code> </pre><br>  Now a component that wants to send messages to others must return the created stream, and a component that wants to receive messages must receive the flow and subscribe to messages from it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/171/061/f8a/171061f8aefb460ca85e1549208b9eb9.png" alt="image"></div><br><br>  Now, as soon as an event occurs in Component 1, it calls onNext and Component 2 immediately receives this event and processes it. <br>  Complicated, each component will begin to return and take several threads and turn into a kind of chip, the legs of which are threads. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/666/0f1/686/6660f16868af4567a2ada7d016cb0204.png" alt="image"></div><br><br>  But all this could be organized with the help of promises.  What is the advantage of using RxJs streams? <br><br><h4>  Everything that happens in the application can be represented as a data stream: </h4><br><ul><li>  keystrokes </li><li>  mouse movements </li><li>  data from the server </li><li>  complex logical something that happened in one of the components </li></ul><br>  And since all this can be presented in a uniform manner, it means that it is possible to work in a uniform manner, there is no longer any difference where events come from and what these events are, for a component it is just data streams. <br><br><h4>  Event handling in stream, conditions and side effects </h4><br>  Often, one component needs not exactly the data that is initially in the incoming stream and needs to be processed or reformatted in some way.  The easiest way to describe this is by example. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inputChanges = $(<span class="hljs-string"><span class="hljs-string">'input.name'</span></span>).onAsObservable(<span class="hljs-string"><span class="hljs-string">'change, keyup, paste'</span></span>)</code> </pre><br>  An inputChanges stream will be created that reacts to some events in the input field and transmits the DOM event as data, but as a rule, the internal logic of the component needs not DOM events, but specific values, preferably satisfying some rules.  Create a new thread that implements event handling for the inputChanges stream. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inputValueChanges = inputChanges .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $(event.target).val() }) .distinctUntilChanged() .where(isValidName) .do(someAction)</code> </pre><br>  The new inputValueChanges stream returns values ‚Äã‚Äãin the input field, and a new event in it occurs only if the value in the field has really changed and satisfies a certain format.  We will examine in more detail: <br><br><pre> <code class="javascript hljs">.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $(event.target).val() })</code> </pre><br>  The <a href="">map</a> method (also called select) takes a handler function, which takes an event as an argument and returns some value that will later be used as a stream event. <br><br><pre> <code class="javascript hljs">.distinctUntilChanged()</code> </pre><br>  Keeps track of the values ‚Äã‚Äãpassing through it and if the value in the event does not differ from the value in the previous event, do not pass it further. <br><br><pre> <code class="javascript hljs">.where(isValidName)</code> </pre><br>  The <a href="">where</a> method (also known as filter), as well as <a href="">distinctUntilChanged,</a> allows you to skip some events further, but accepts a function as a condition that checks whether these events satisfy certain requirements. <br><br><pre> <code class="javascript hljs">.do(someAction)</code> </pre><br>  <a href="">do</a> (or doAction) implements side effects, while not affecting the event itself in the stream.  The function someAction, as in the case of map, takes a single argument, the event. <br><br><h4>  Threading </h4><br>  It often happens that one component waits for data from two other components in order to perform some kind of action.  For example, to show the price for a trip, the ‚Äúsummary‚Äù component needs to get data from the ‚Äúcalendar‚Äù and ‚Äúroute‚Äù components and then update it as soon as something changes in one of the components. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/73f/792/a3b/73f792a3bf034786849af18df8a473a6.png" alt="image"></div><br><br>  In order to get data from two streams, you can combine them into one stream, which will contain data from both.  In the above example, you can use the <a href="">combineLatest</a> method <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> routeAndDateChangesStream = routeChangesStream .combineLatest(dateChangesStream, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">route, date</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">date</span></span>: date, <span class="hljs-attr"><span class="hljs-attr">route</span></span>: route } })</code> </pre><br>  The combineLatest method combines two (or more) streams into one.  An event in the resulting stream occurs when an event occurs in one of the merged streams, provided that there is at least one event in each of the merged streams.  The first argument combineLatest takes the stream with which to merge, the second function that determines how to merge data from events.  When an event occurs in any stream, recent events are taken from the remaining streams to merge. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dc8/5aa/00c/dc85aa00c98c4222be88830326a0405e.png" alt="image"></div><br><br>  In addition to combining recent events, it may be necessary to combine events in pairs in the order of their occurrence.  For example, some action generates two Ajax requests and needs to be reacted when both requests return data, and the data need to be combined only from the corresponding requests.  In such a situation, it is convenient to use the <a href="">zip</a> method, which combines not the latest events from the streams, but events with matching sequence numbers. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> routeAndDateChangesStream = response1Stream .zip(response2Stream, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data1, data2</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.extend(data1, data2) })</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7ce/4d1/685/7ce4d16854fa4c8c84696b74fc1ded49.png" alt="image"></div><br>  And finally, there is a situation where you don‚Äôt need to combine data from streams, but simply a component receives the same information from different streams, for example, there are two calendars on the page, one detailed per year, the second for the next two weeks, both calendars transmit the date to the ‚Äúsummary‚Äù component .  Here you just need to combine the two streams into one. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataChangesStream = bigCalendarDateChange.merge(miniCalendarDateChanges)</code> </pre><br>  Here, the events from both calendars fall into the result stream, and the component receiving them can process them as if the selection always occurred in only one component. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/640/f67/f0c/640f67f0cc5a4ad4b792a0f1d6a1fbaa.png" alt="image"></div><br><br><h4>  Testing </h4><br>  The organization of components according to the ‚ÄúChip‚Äù type gives another advantage - testability. <br><br>  If a component receives all incoming data through a set of streams and also sends data through a set of streams, this greatly simplifies the testing of such a component.  It is enough to create a set of empty incoming streams and give them to the component as incoming.  Then, sending certain combinations of events to the streams, it is easy to see whether the component behaves correctly and whether it sends the correct data to the outgoing streams. </div><p>Source: <a href="https://habr.com/ru/post/270093/">https://habr.com/ru/post/270093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270081/index.html">Where is the type: right or left?</a></li>
<li><a href="../270083/index.html">30 years of C ++</a></li>
<li><a href="../270087/index.html">How do we equip an alternative to 1C</a></li>
<li><a href="../270089/index.html">Is IT infrastructure a black Pandora's box?</a></li>
<li><a href="../270091/index.html">Errors and problems of the Big Three servers: part one. Dell</a></li>
<li><a href="../270095/index.html">We invite to the webinars for beginners Android programmers on Delphi</a></li>
<li><a href="../270097/index.html">Some YAML Tricks</a></li>
<li><a href="../270099/index.html">Does C # need a ‚Äústate‚Äù?</a></li>
<li><a href="../270101/index.html">Iron's little strange browser bug</a></li>
<li><a href="../270103/index.html">CSS modules</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>