<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>URiX - Review of Not uNix</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I Draw 
 In the beginning was ‚ÄúI‚Äù 

 Hello! 
 I often research different tasks and problems, and one of them turned out to be that there are many many...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>URiX - Review of Not uNix</h1><div class="post__text post__text-html js-mediator-article">  I Draw <br>  In the beginning was ‚ÄúI‚Äù <br><img src="https://habrastorage.org/getpro/habr/post_images/88a/64f/c80/88a64fc805e6b1e09be577a14affcc94.png" alt="xRain Logo"><br>  Hello! <br>  I often research different tasks and problems, and one of them turned out to be that there are many many GNU distributions, but all of them work in one way or another according to the principles of unix, that is, as such, development does not occur, programs are developed, the core, but the structure is was x-year-old and remained, in general, this is due to compatibility problems that may arise in the event of an attempt to jump on the spot.  I decided to think about what could be the development of GNU / Linux and at the same time about the options for combining communities of different distributions, so I suspect that there are adherents including window crafts, and bsdelok, and for me and non-xx, about all the same, at least in terms of the distribution of transactions between cache / caches of processor cores, I suggest immediately git together. <br>  The task of this post is to attract the attention of the audience to the problem, assess the degree of its importance and try to find a better performing solution, I would like to have good intentions and possible voluntary assistance in the implementation. <br>  Beware of odd words!  Text below is very hard to read and understand! <br>  Unreadable-Formation-Occurrence spotted! <br><a name="habracut"></a><br><br>  The loading process is often quite long (regarding the execution of programs for example) and this can be simplified using hardware profiles and snapshots (snapshots) of memory, I once suggested using the <a href="https://bugzilla.kernel.org/show_bug.cgi%3Fid%3D55301">simutrans x-kernel</a> model, it may already be working, or when they will do it because there are not so many alternatives in using the transaction scheme and the position of the soft-core in memory in order to distribute the threads between different processor cores in order to get a reduction in the processing time of them  Using the computing factories of all the physical cores of the processor, and not just the one on which the current code is executed. <br><br><div class="spoiler">  <b class="spoiler_title">RawX Visual Core Model</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/f14/2ff/51b/f142ff51b2d65d7f2029a931f49ffd65.png" alt="kernel">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      cone - root hash user <br>  cube - boot kernel <br>  icosahedra - the first wave of core services <br>  spheres - the second wave of services <br>  bagels are peripherals loaded by services from a hash-root user <br>  at the very top - user-friendly environmental process <br>  the task of review of "not unix" - (understand and forgive) to make the system more flexible and stable <br>  approximately three states <br>  logic-structure-data and also boot-system-user <br></div></div><br><br>  At the boot kernel stage, the initial instructions will be loaded - the cpu mem bus, so that the first wave of services can determine the basic equipment and load modules for it, but even before the primary user (root) is activated, each computer must have its own hash code for this user, to be the owner of all processes and resources.  For me, this is important because now any root can view files on an unencrypted system and gain access to any hardware.  Therefore, I decided that there should be a system-root-hash user that can be authenticated if the user did not ignore such a function during installation.  The same hash can be used as a salt to encrypt user / home, pam / ssl, and therefore the pam-auth service must also be loaded in the first wave along with the basic equipment so that additional authentication can be performed - keyboard, video, sound (yeah, I want voice authentication and voice commands), can be data storage.  I think all this is already done by the Linux kernel, you only need to raise the authentication so that you can then manage the resources of the hash user and delegate them to real users. <br><br>  Knowing that all the data will then be transferred via aufs, you can try to separate them into a more computer-readable form, I think that all executable files should not be dumped into one directory, since it takes time when listing, searching and matching files in this directory , we divide them into heaps at least having human logic, for example 1,2,3- / a / b / c as for example in the spool / squid hierarchy, but I think it may be better to divide scripts / php as follows. js.sh and execs / c.java.fortran texts / html.txt.pdf - that is, such reverse sorting by extension  it is easier to determine the interpreter or program for opening this file type integrated into system processes, so that in any case any jpg can be found in data / img / jpg and any cron script in scripts / sh.  I‚Äôm not completely sure that this should definitely be like this, I just think that if all permissions and restrictions in the kernel are about the same and are executed from one user, then there‚Äôs actually no need for dividing into additional folders - this logic is needed more for admins and programmers, and the computer needs the starting point of the file and to which buffer to load / unload it, so maybe just such a name is 01.011.this.program.file.jpg - yes, this is a new / non-unix / scheme and here it can also be The priority and the order of loading the file by the kernel are noted. <br>  and a human-friendly form will appear only at the next higher level, which can easily reproduce the unix data scheme using empty hard symlinks in squashfs <br><br>  An executable kernel loaded into memory can be recompiled at least once according to the tasks it performs for each machine, something like initrd.img, so that it does not need to detect and load non-existent hardware modules and this is a kind of kernel sharpening for iron and most frequent tasks  Such statistics can be collected for several working sessions, and the exhaust will be in a finer allocation of resources and a simple check on the identity of the equipment - then the sharpened core can be immediately loaded into memory (snapshot) without initialization and other things, the basic functions of the boot core are stitched to it and immediately after loading into memory this kernel can already work. <br><br>  After the first wave, the kernel load ends, and the second causes extended services of the system and equipment ‚Äî the network, x.org, cron, additional devices, file systems, management for users and everything else related to the basic functionality of the system, that is, gnome, apache, squid is not loaded here, but compilers, interpreters, drivers, fonts are loaded, so that the user can already cope with their services <br>  on the second wave, the standard nix model / usr / lib / bin is built up to create a working environment for unix / gnu programs using aufs, zfs or virtual machines so that you can move away from the rawx kernel abstraction level and emulate the work of the gnu / linux model for it end-user interfaces. <br>  at the top of the rawx operation, we get a virtual linux-compatible kernel that works with user processes, that is, the real kernel is reliably protected behind the virtual layer, but it also means that we can have as many cores as the resources allow and will keep the hardware, so deal with the distribution of memory and cp resources between users - this is approximately like a virtual machine, only without a machine, we turn to kernel services, perhaps this is already implemented in KVM, that is, we are not virtualizing the kernel and <br>  machine, but only high-level processes <br><br>  In general, the kernel loads and intercepts links from different libraries, emulates the environment in some strange cases and emulates distribution structures when necessary for each user or process. <br>  Sometimes, I imagine users as a process, and processes as users - such a model can show how to distribute programs between users, why one process cannot have different users?  Now each user runs his own copy of the program, although he basically needs only some of its functions, it is possible to divide this program into basic logic, system libraries and user data <br>  then everyone will not need to launch their ‚Äúown‚Äù browser - all users run one process in which the basic logic and system libraries are loaded, and all user ones are loaded into a separate memory space, much smaller than the program itself.  Users only work with separate cache and memory, personal settings are contained in the profile and are stored in the browser memory snapshot for a specific user, and when there is no activity for all users, this process is also unloaded entirely from memory in squashfs or img.gz, that is, if there is one If it started successfully and also completed successfully, then this image of the process is saved and used by the system without reloading all configurations, libraries and interpreters - a snapshot (snapshot) of the memory of this process is loaded  Ssa, which immediately works in the same way as the rawx kernel, and users connect their settings to this process and work through agents. <br><br>  Core profiling <br>  Several levels of kernel loading allow you to return to the level below and dump accumulated errors or simply unload programs and equipment from memory, this allows you to create kernel profiles to perform certain capacious tasks, for example, virtual machines use quite a lot of iron resources, but do not require loading all compilers and libraries, and the calculation of 3D models or programming-compilation of the code need to load only some of the libraries and can fully load the system, that is, require power  n and memory tasks in a narrow range.  In such cases, the core can be redeveloped on-the-fly, and program memory cards and libraries can also be useful for this.  In principle, the Linux kernel now allows unloading and loading modules and drivers during operation, the task is to do this automatically depending on the running applications (tasks), so that user intervention is not required, and there are not so many functions At the same time, it is not necessary to search for these functions by the memory stacks during the execution of programs. <br><br>  Some assigned tasks will require a static arrangement of some inputs / outputs of the kernel, so that other programs can access them directly and this can be spelled out when compiling the programs, however such libraries will not be too frequent and in general you only need to connect user-level agents to them Let's say that these agents will cope with the assignment of requests and responses - they will become a kind of intelligent services, they need to be provided with high speed, therefore, stats are offered  Other memory addresses are buffer stacks for certain libraries; this can be compared with partitioning a disk into different areas.  After the second recompilation of the kernel, the free memory addresses will be accurately known, if you specify a small interval for data exchange between libraries, then theoretically it can help in solving some problems. <br>  The X-core model assumes the use of several cores and the distribution of functions of the common Linux-core between them, in such a model there should be a fairly rigid structure of parallelization of functions and distribution of processor-a-core resources (s), which means that deep work with memory, which may already create certain static points for internal work, I think that it will be necessary to connect the libraries directly to these points - the compilation will take place on-the-fly.  And in fact, the compilation will not need to occur and traditional application loading will not occur, since  the application will occupy its previous place in memory along with all the necessary modules from the snapshot of memory stored in squashfs and connect to the base entry points of the rawx-core. <br>  Possible problems will arise when there is a lack of memory and the forced transfer of programs from one area to another, then these programs will need to be restarted to recompile their squash image in accordance with the new constitution of memory. Probably, prioritization should be introduced for processes so that unnecessary conflicts do not occur. <br><br>  in general, everything has already been done in parallel computing programs, in distributed cloud solutions, <a href="http://svn.oscar.openclustergroup.org/trac/oscar/wiki">oscar</a> , <a href="http://www.openstack.org/">openstack</a> , <a href="http://www.mosix.org/txt_distributions.html">moSix</a> render farms, or even squid, nginx + fpm, that is, you don‚Äôt need to do just such a bike, but just generalize the knowledge and apply it in a new light . <br>  in principle, some problems between network machines can be solved using squashfs modules, as is done in <a href="http://magos-linux.ru/">magos</a> , that is, transferring a file system with the necessary working files to a client host, for a particular program, these files can be saved there, but this is a special case of parallelization, in general, a unified stack of libraries is needed for several types of programs that the user will load into his local virtual core and it turns out that this can also be solved using squashfs for several cores on one or not  how many processors of one computer. <br><br>  P / S <br>  I am far from a system programmer or architect, I studied asm only in terms of mov (ax, bx), system administration is my weakness, I try hard not to get involved in it and do not abuse it, so if there is true knowledge in the paths, correct it, and if the question is not even interesting and does not cause conscious motivation, but only emotional reactions - you can simply skipanut post or try to comprehend <br><br>  encore une foi, ') <br><br>  My site will not sustain the popularity, so there are no links here, and I wrote in GooglePly in English. <br>  In general, I am not sure that the topic is of concern to anyone, the question of the development of open source software is deeply cashless. <br>  Some of this is difficult to understand, because it seems to me that these are not simple things and to explain to everyone and everyone ‚Äî it is impossible in a short period of time until the concentration of attention of the consciousness subsides, on average for new information it is 2-4 minutes ¬± 2 time of popular music.  You can slightly explore your musical preferences, find your favorite track, see its duration, it is better to highlight the moment that you especially like - this is the likely peak of perception. <br>  I'm used to a minute and a half. ‚Äù  ) <br>  It‚Äôs interesting to invent, but gaps arise ... between what I came up with and what other people know, because in order to create and create something you need to analyze a lot of what has already been done, understand mistakes, forgive differences, determine probable directions - this is called intuition, to confirm the correctness, I cannot describe all my initial data, I think that this is not necessary, I proposed a model, and partly in the comments there is already a proof of the concept in the form of links to other projects that are already implemented a similar i n  edlagayu move on the basis of current data, I thought I had a bicycle or a wheel, but it turns out it's a flying saucer. "  ) <br>  To "our open source software" was - it must be done. <br>  btw 10x 4 add.  + read ++ understand </div><p>Source: <a href="https://habr.com/ru/post/189598/">https://habr.com/ru/post/189598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../189584/index.html">Between Samsung Galaxy S III and OPPO Find 5 (quite a bit more about the latter)</a></li>
<li><a href="../189586/index.html">Hipster approach or ‚Äúwhat to do when writing press releases is boring‚Äù</a></li>
<li><a href="../189588/index.html">How to create a cluster in JBoss AS 7.1 in standalone mode?</a></li>
<li><a href="../189594/index.html">Paul Graham: How to convince investors</a></li>
<li><a href="../189596/index.html">Mixed (client / server) xmlDsig digital signature generation algorithm based on CryptoPro Browser Plugin</a></li>
<li><a href="../189606/index.html">Control your website with the new monitoring service from REG.RU</a></li>
<li><a href="../189610/index.html">The phrase "perezalil on habrastorage" loses its meaning</a></li>
<li><a href="../189612/index.html">Like spawns like: what affects the rating on the Internet</a></li>
<li><a href="../189614/index.html">mySQLgame 2.0</a></li>
<li><a href="../189616/index.html">Another way to control the fan in Linux (for example, Acer S3-391)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>