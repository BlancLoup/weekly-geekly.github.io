<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Everything you wanted to know about scopes in JavaScript (but were afraid to ask)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JS has several concepts related to scope that are not always clear to novice developers (and sometimes even experienced ones). This article is dedicat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Everything you wanted to know about scopes in JavaScript (but were afraid to ask)</h1><div class="post__text post__text-html js-mediator-article">  JS has several concepts related to scope that are not always clear to novice developers (and sometimes even experienced ones).  This article is dedicated to those who seek to plunge into the abyss of JS scope, hearing such words as scope, closure, ‚Äúthis‚Äù, namespace, function scope, global variables, lexical scope, private and public domains ... I hope reading the material you can answer the following questions: <br><br>  - what is the scope? <br>  - what is a global / local OS? <br>  - what is the namespace and how does it differ from the OB? <br>  - What does this keyword mean, and how does it relate to agents? <br>  - What is a functional and lexical agents? <br>  - what is a closure? <br>  - How can I understand and create all this? <br><a name="habracut"></a><br><h4>  What is the scope? </h4><br><br>  In JS, scope is the current context in the code.  OBs can be defined locally or globally.  The key to writing bulletproof code is to understand OB.  Let's understand where variables and functions are available, how to change the context in the code and write faster and more supported code (which is easier to debug).  It is easy to deal with agents - we ask ourselves which of them are we in A or B? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  What is a global / local OS? </h4><br><br>  Without writing a single line of code, we are already in the global OB.  If we immediately define a variable, it is in the global OB. <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   var name = 'Todd';</span></span></code> </pre> <br><br>  Global OB is your best friend and worst nightmare.  While learning how to work with different agents, you will not encounter problems with a global agent, unless you see name intersections.  You can often hear the ‚Äúglobal OB ‚Äî this is bad,‚Äù but it is rarely possible to get an explanation of why.  GOV is not bad, you need to use it when creating modules and APIs that will be available from different agents, you just need to use it for good and for good. <br><br>  We all used jQuery.  As soon as we write <br><br><pre> <code class="javascript hljs">jQuery(<span class="hljs-string"><span class="hljs-string">'.myClass'</span></span>);</code> </pre><br><br>  we access jQuery in a global OB, and we can call this access a namespace.  Sometimes the term ‚Äúnamespace‚Äù is used instead of the term OB, however, they usually denote the OB of the level itself.  In our case, jQuery is in a global OB, and is our namespace.  The jQuery namespace is defined in a global OB, which works as a PI for the jQuery library, while all its contents are inherited from this PI. <br><br><h4>  What is a local OB? </h4><br><br>  Local OB call any OB defined after global.  Usually we have one GOV, and each defined function carries a local OB.  Each function defined inside another function has its own local OB associated with the OB of the external function. <br><br>  If I define functions and define variables inside them, they belong to a local OB.  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  A:  var myFunction = function () { //  B:  };</span></span></code> </pre><br><br>  All variables from BOV are not visible in GOV.  They cannot be accessed from the outside directly.  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = <span class="hljs-string"><span class="hljs-string">'Todd'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); <span class="hljs-comment"><span class="hljs-comment">// Todd }; // ReferenceError: name is not defined console.log(name);</span></span></code> </pre><br><br>  The variable "name" refers to the local OB, it is not visible from the outside and therefore is not defined. <br><br><h4>  Functional OB. </h4><br><br>  All local OBs are created only in functional OBs, they are not created by for or while cycles or by if or switch directives.  New feature - new scope.  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  A var myFunction = function () { //  B var myOtherFunction = function () { //  C }; };</span></span></code> </pre><br><br>  So simply you can create a new OB and local variables, functions and objects. <br><br><h4>  Lexical OV </h4><br><br>  If one function is defined inside another, the internal one has access to the external OB.  This is called ‚Äúlexical OB‚Äù, or ‚Äúclosure‚Äù, or else ‚Äústatic OB‚Äù. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = <span class="hljs-string"><span class="hljs-string">'Todd'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myOtherFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'My name is '</span></span> + name); }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name); myOtherFunction(); <span class="hljs-comment"><span class="hljs-comment">//   }; // : // `Todd` // `My name is Todd`</span></span></code> </pre><br><br>  It is quite simple to work with the lexical OB ‚Äî everything that is defined in the parent's OB is available in the child's OB.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = <span class="hljs-string"><span class="hljs-string">'Todd'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope1 = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// name   var scope2 = function () { // name   var scope3 = function () { // name   ! }; }; };</span></span></code> </pre><br><br>  In the opposite direction it does not work: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// name = undefined var scope1 = function () { // name = undefined var scope2 = function () { // name = undefined var scope3 = function () { var name = 'Todd'; //   }; }; };</span></span></code> </pre><br><br>  You can always return a reference to ‚Äúname‚Äù, but not the variable itself. <br><br><h4>  OB sequences </h4><br><br>  OB sequences determine the OB of any selected function.  Each defined function has its own OB, and each function defined inside the other has its own OB associated with the external OB ‚Äî this is the sequence or chain.  Position in the code determines the OB.  Defining the value of a variable, JS goes from the deepest nested OB to the outside until it finds the desired function, object, or variable. <br><br><h4>  Closures </h4><br><br>  They live in close union with lexical agents.  A good use case is returning a reference to a function.  We can return to the outside various links that make it possible to access what has been defined inside. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sayHello = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text = <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span> + name; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(text); }; };</code> </pre><br><br>  To display text, it is not enough just to call the function sayHello: <br><br><pre> <code class="javascript hljs">sayHello(<span class="hljs-string"><span class="hljs-string">'Todd'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre><br><br>  The function returns the function, so it must first be assigned and then called: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> helloTodd = sayHello(<span class="hljs-string"><span class="hljs-string">'Todd'</span></span>); helloTodd(); <span class="hljs-comment"><span class="hljs-comment">//     'Hello, Todd'</span></span></code> </pre><br><br>  You can of course cause a closure and directly: <br><br><pre> <code class="javascript hljs">sayHello(<span class="hljs-string"><span class="hljs-string">'Bob'</span></span>)(); <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre><br><br>  AngularJS uses similar calls in the $ compile methods, where you need to pass a link to the current OB: <br><br><pre> <code class="javascript hljs">$compile(template)(scope);</code> </pre><br><br>  One can guess that, simplified, their code looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $compile = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">template</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   //    scope return function (scope) { //      `template`   `scope` }; };</span></span></code> </pre><br><br>  The function does not have to return anything to be a closure.  Any access to variables from outside the current OB creates a closure. <br><br><h4>  OB and 'this' </h4><br><br>  Each OB assigns its own value to the variable ‚Äúthis‚Äù, depending on how the function is called.  We all used the keyword this, but not everyone understands how it works and what the differences are when calling.  By default, it refers to the object of the outermost OB, the current window.  An example of how different calls change this values: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">// this = , [ Window] }; myFunction(); var myObject = {}; myObject.myMethod = function () { console.log(this); // this =   { myObject } }; var nav = document.querySelector('.nav'); // &lt;nav class="nav"&gt; var toggleNav = function () { console.log(this); // this =  &lt;nav&gt; }; nav.addEventListener('click', toggleNav, false);</span></span></code> </pre><br><br>  There are also problems with the value of this.  In the following example, the value and OB may vary within the same function: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nav = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.nav'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;nav class="nav"&gt; var toggleNav = function () { console.log(this); // &lt;nav&gt; element setTimeout(function () { console.log(this); // [ Window] }, 1000); }; nav.addEventListener('click', toggleNav, false);</span></span></code> </pre><br><br>  Here we have created a new OB, which is not called from an event handler, which means it refers to the window object.  You can, for example, remember the value of this in another variable, so that there is no confusion: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nav = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.nav'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;nav class="nav"&gt; var toggleNav = function () { var that = this; console.log(that); //  &lt;nav&gt; setTimeout(function () { console.log(that); //  &lt;nav&gt; }, 1000); }; nav.addEventListener('click', toggleNav, false);</span></span></code> </pre><br><br><h4>  Change OBs with .call (), .apply () and .bind () </h4><br><br>  Sometimes there is a need to change agents depending on what you need. <br>  In the example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> links = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'nav li'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; links.length; i++) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">// [ Window] }</span></span></code> </pre><br><br>  The value of this does not apply to enumerated elements, we do not call or change anything.  Let's look at how we can change the OB (more precisely, we change the context of the function call). <br><br><h4>  .call () and .apply () </h4><br><br>  The methods .call () and .apply () allow you to transfer the OB to a function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> links = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'nav li'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; links.length; i++) { (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }).call(links[i]); }</code> </pre><br><br>  As a result, the values ‚Äã‚Äãof the enumerated elements are transferred to this.  The .call method (scope, arg1, arg2, arg3) takes a comma-separated list of arguments, and the .apply method (scope, [arg1, arg2]) takes an array of arguments. <br><br>  It is important to remember that the .call () or .apply () methods call functions, so instead of <br><br><pre> <code class="javascript hljs">myFunction(); <span class="hljs-comment"><span class="hljs-comment">//  myFunction</span></span></code> </pre><br><br>  Let .call () call a function and pass a parameter: <br><br><pre> <code class="javascript hljs">myFunction.call(scope);</code> </pre><br><br><h4>  .bind () </h4><br><br>  .bind () does not call a function, but simply binds the values ‚Äã‚Äãof variables before calling it.  As you know, we cannot pass parameters to function references: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  nav.addEventListener('click', toggleNav, false); //      nav.addEventListener('click', toggleNav(arg1, arg2), false);</span></span></code> </pre><br><br>  This can be fixed by creating a new nested function: <br><br><pre> <code class="javascript hljs">nav.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ toggleNav(arg1, arg2); }, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><br>  But here again there is a change in the OV, the creation of an extra function, which will negatively affect the speed.  Therefore, we use .bind (), as a result, we can pass arguments in such a way that a function call does not occur: <br><br><pre> <code class="javascript hljs">nav.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, toggleNav.bind(scope, arg1, arg2), <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><h4>  Private and public agents </h4><br><br>  In JavaScript, unlike many other languages, there are no concepts of public and private agents, but we can emulate them with closures.  To create a private OB, we can wrap our functions in other functions. <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    })();</span></span></code> </pre><br><br>  Add functionality: <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,   }; })();</span></span></code> </pre><br><br>  But you cannot call this function directly: <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,   }; })(); myFunction(); // Uncaught ReferenceError: myFunction is not defined</span></span></code> </pre><br><br>  Here you have a private OB.  If you need a public OB, use the following trick.  Create a Module namespace that contains everything related to this module: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   var Module = (function () { return { myMethod: function () { console.log('myMethod has been called.'); } }; })(); //    Module.myMethod();</span></span></code> </pre><br><br>  The return directive returns publicly available methods in a global OB.  However, they belong to the desired namespace.  A Module can contain as many methods as needed. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   var Module = (function () { return { myMethod: function () { }, someOtherMethod: function () { } }; })(); //    Module.myMethod(); Module.someOtherMethod();</span></span></code> </pre><br><br>  No need to try to dump all methods into a global OB and pollute it.  This is how you can organize a private OB without returning the function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Module = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> privateMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">publicMethod</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ } }; })();</code> </pre><br><br>  We can call publicMethod, but we cannot call privateMethod - it belongs to a private OB.  Anything can be thrown into these functions ‚Äî addClass, removeClass, Ajax / XHR calls, Array, Object, etc. <br><br>  An interesting twist is that within one OB, all functions have access to any other, so we can call private methods from public methods that are not available in the global OB: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Module = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> privateMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">publicMethod</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     `privateMethod`: // privateMethod(); } }; })();</span></span></code> </pre><br><br>  This increases the interactivity and security of the code.  For the sake of safety, it is not necessary to dump all functions into a global OB, so that functions that do not need to be called up would not inadvertently cause. <br><br>  An example of returning an object using private and public methods: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Module = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myModule = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> privateMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; myModule.publicMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; myModule.anotherPublicMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> myModule; <span class="hljs-comment"><span class="hljs-comment">// returns the Object with public methods })(); //  Module.publicMethod();</span></span></code> </pre><br><br>  It is convenient to begin the name of private methods with an underline in order to visually distinguish them from public ones: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Module = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _privateMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> publicMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; })();</code> </pre><br><br>  It is also convenient to return methods in a list, returning references to functions: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Module = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _privateMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> publicMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">publicMethod</span></span>: publicMethod, <span class="hljs-attr"><span class="hljs-attr">anotherPublicMethod</span></span>: anotherPublicMethod } })();</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/239863/">https://habr.com/ru/post/239863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239849/index.html">We design information architecture for e-commerce. Part 1</a></li>
<li><a href="../239853/index.html">We create a video wall with the image broadcast from ip-cameras via satellite with a minimum of traffic</a></li>
<li><a href="../239855/index.html">What can the optimizer do that no one else can do?</a></li>
<li><a href="../239857/index.html">Features of cloning in an educational institution</a></li>
<li><a href="../239861/index.html">Direct access to Cach√© classes via REST, for example DHTMLX Grid</a></li>
<li><a href="../239865/index.html">Not like in "Gravity": how astronauts repair the ISS</a></li>
<li><a href="../239871/index.html">Experience in developing a total caching engine</a></li>
<li><a href="../239875/index.html">Imgur offers to switch to gifv: as gif, only easier, better and without brakes</a></li>
<li><a href="../239879/index.html">Presentation of new Lenovo products in London</a></li>
<li><a href="../239881/index.html">The release of large iPad postponed due to the sixth "iPhones"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>