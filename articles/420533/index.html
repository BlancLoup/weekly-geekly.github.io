<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Emulate Property Literals with Java 8 Method Reference</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: to the translation of this article I was pushed by the insult from the lack of the nameOf operator in the Java language. For the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Emulate Property Literals with Java 8 Method Reference</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/rx/cy/ut/rxcyutfwkaqvjicfkhp78xtv_ts.png"></div><br>  <i>From the translator: to the translation of this article I was pushed by the insult from the lack of the nameOf operator in the Java language.</i>  <i>For the impatient - at the end of the article there is a ready implementation in source codes and binaries.</i> <br><br>  One of the things that Java library developers often lack is property literals.  In this post, I will show how you can creatively use the Method Reference from Java 8 to emulate property literals using bytecode generation. <br><br>  Akin to class literals (for example, <code>Customer.class</code> ), property literals would make it possible to refer to the properties of bin classes as type-safe.  This would be useful for an API design where there is a need to perform actions on properties or to configure them in some way. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>From the translator: We analyze how to implement it from improvised means.</i> <br><a name="habracut"></a><br>  For example, consider the index mapping configuration API in Hibernate Search: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SearchMapping().entity(Address.class) .indexed() .property(<span class="hljs-string"><span class="hljs-string">"city"</span></span>, ElementType.METHOD) .field();</code> </pre><br>  Alternatively, the <code>validateValue()</code> method from the Bean Validation API allows you to check the value of the property constraints: <br><br><pre> <code class="java hljs">Set&lt;ConstraintViolation&lt;Address&gt;&gt; violations = validator.validateValue(Address.class, <span class="hljs-string"><span class="hljs-string">"city"</span></span>, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span> );</code> </pre><br>  In both cases, the <code>String</code> type is used to refer to the <code>city</code> property of the <code>Address</code> object. <br><br>  This can lead to errors: <br><ul><li>  The Address class may not have a <code>city</code> property at all.  Or someone might forget to update the string property name after renaming the get / set methods when refactoring. </li><li>  in the case of <code>validateValue()</code> , we are not able to verify that the type of the passed value corresponds to the type of the property. </li></ul><br>  Users of this API can learn about these problems only by running the application.  Wouldn't it be cool if the compiler and type system prevented such use from the very beginning?  If there were property literals in Java, we could do this (this code does not compile): <br><br><pre> <code class="java hljs">mapping.entity(Address.class) .indexed() .property(Address::city, ElementType.METHOD ) .field();</code> </pre><br>  AND: <br><br><pre> <code class="java hljs">validator.validateValue(Address.class, Address::city, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span>);</code> </pre><br>  We could avoid the problems mentioned above: any slip in the name of the property would lead to a compilation error, which can be seen right in your IDE.  This would allow the Hibernate Search Configuration API to be developed to accept only the properties of the Address class when we configure the Address entity.  And in the case of c Bean Validation <code>validateValue()</code> property literals would help ensure that we pass the value of the correct type. <br><br><h2>  Java 8 Method Reference </h2><br>  Java 8 does not support property literals (and is not planned to support them in Java 11), but at the same time it provides an interesting way to emulate them: Method Reference (method reference).  Initially, Method Reference was added to simplify working with lambda expressions, but they can be used as property literals for the poor. <br><br>  Consider the idea of ‚Äã‚Äãusing a reference to a getter method as a literal property: <br><br><pre> <code class="java hljs">validator.validateValue(Address.class, Address::getCity, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span>);</code> </pre><br>  Obviously, this will work only if you have a getter.  But if your classes already follow the JavaBeans convention, which is most often the case, this is normal. <br><br>  What would a <code>validateValue()</code> method declaration look like?  The key point is the use of the new <code>Function</code> type: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T, P&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue( Class&lt;T&gt; type, Function&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T, P&gt; property, P value);</code> </pre><br>  Using two typing parameters, we can verify that the bean type, properties, and the value passed are correct.  From the point of view of the API, we got what we needed: it is safe to use and the IDE will even automatically supplement method names beginning with <code>Address::</code> .  But how to display the property name from the <code>Function</code> object in the implementation of the <code>validateValue()</code> method? <br><br>  And then the fun begins, since the Function functional interface only declares one method ‚Äî <code>apply()</code> , which executes the function code for the passed-in instance <code>T</code>  This is not what we needed. <br><br><h2>  ByteBuddy to the rescue </h2><br>  As it turns out, the application of the function is the trick!  By creating a proxy instance of type T, we have a goal to call the method and get its name in the proxy call handler.  (From the translator: hereinafter we are talking about dynamic Java proxies - java.lang.reflect.Proxy). <br><br>  Java supports dynamic proxies out of the box, but this support is limited only by interfaces.  Since our API should work with any bin, including real classes, I am going to use an excellent tool instead of Proxy - ByteBuddy.  ByteBuddy provides a simple DSL for creating classes on the fly, which is what we need. <br><br>  Let's start by defining an interface that would allow storing and retrieving the property name extracted from the Method Reference. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNameCapturer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropertyName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPropertyName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String propertyName)</span></span></span></span>; }</code> </pre> <br>  Now we use ByteBuddy to programmatically create proxy classes that are compatible with the types of interest to us (for example: Address) and implement <code>PropertyNameCapturer</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; T <span class="hljs-comment"><span class="hljs-comment">/* &amp; PropertyNameCapturer */</span></span> getPropertyNameCapturer(Class&lt;T&gt; type) { DynamicType.Builder&lt;?&gt; builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteBuddy() (<span class="hljs-number"><span class="hljs-number">1</span></span>) .subclass( type.isInterface() ? Object.class : type ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.isInterface()) { (<span class="hljs-number"><span class="hljs-number">2</span></span>) builder = builder.implement(type); } Class&lt;?&gt; proxyType = builder .implement(PropertyNameCapturer.class) (<span class="hljs-number"><span class="hljs-number">3</span></span>) .defineField(<span class="hljs-string"><span class="hljs-string">"propertyName"</span></span>, String.class, Visibility.PRIVATE) .method( ElementMatchers.any()) (<span class="hljs-number"><span class="hljs-number">4</span></span>) .intercept(MethodDelegation.to( PropertyNameCapturingInterceptor.class )) .method(named(<span class="hljs-string"><span class="hljs-string">"setPropertyName"</span></span>).or(named(<span class="hljs-string"><span class="hljs-string">"getPropertyName"</span></span>))) (<span class="hljs-number"><span class="hljs-number">5</span></span>) .intercept(FieldAccessor.ofBeanProperty()) .make() .load( (<span class="hljs-number"><span class="hljs-number">6</span></span>) PropertyNameCapturer.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER ) .getLoaded(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unchecked"</span></span>) Class&lt;T&gt; typed = (Class&lt;T&gt;) proxyType; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typed.newInstance(); (<span class="hljs-number"><span class="hljs-number">7</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InstantiationException | IllegalAccessException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HibernateException( <span class="hljs-string"><span class="hljs-string">"Couldn't instantiate proxy for method name retrieval"</span></span>, e ); } }</code> </pre><br>  The code may seem a bit confusing, so let me explain it.  First we get an instance of ByteBuddy (1), which is the DSL input point.  It is used to create dynamic types that either extend the desired type (if it is a class) or inherit Object and implement the desired type (if it is an interface) (2). <br><br>  Then, we specify that the type implements the PropertyNameCapturer interface and add a field to store the name of the desired property (3).  Then we say that calls of all methods should be intercepted by PropertyNameCapturingInterceptor (4).  Only setPropertyName () and getPropertyName () (from the PropertyNameCapturer interface) should access the real property created earlier (5).  Finally, a class is created, loaded (6), and instantiated (7). <br><br>  This is all we need to create proxy types, thanks ByteBuddy, this can be done in a few lines of code.  Now let's look at call interceptor: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNameCapturingInterceptor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@RuntimeType</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intercept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@This PropertyNameCapturer capturer, @Origin Method method)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-number"><span class="hljs-number">1</span></span>) capturer.setPropertyName(getPropertyName(method)); (<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method.getReturnType() == <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>.class) { (<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ... ) { } <span class="hljs-comment"><span class="hljs-comment">// ... handle all primitve types // ... } else { return null; } } private static String getPropertyName(Method method) { (4) final boolean hasGetterSignature = method.getParameterTypes().length == 0 &amp;&amp; method.getReturnType() != null; String name = method.getName(); String propName = null; if (hasGetterSignature) { if (name.startsWith("get") &amp;&amp; hasGetterSignature) { propName = name.substring(3, 4).toLowerCase() + name.substring(4); } else if (name.startsWith("is") &amp;&amp; hasGetterSignature) { propName = name.substring(2, 3).toLowerCase() + name.substring(3); } } else { throw new HibernateException( "Only property getter methods are expected to be passed"); (5) } return propName; } }</span></span></code> </pre><br>  The intercept () method accepts the called Method and the target for the call (1).  The <code>@Origin</code> and <code>@This</code> are used to specify the appropriate parameters so that ByteBuddy can generate the correct intercept () calls in a dynamic proxy. <br><br>  Notice that there is no strict dependence of the inteptor on ByteBuddy types, since ByteBuddy is used only to create a dynamic proxy, but not when using it. <br><br>  By calling <code>getPropertyName()</code> (4) we can get the name of the property corresponding to the given Method Reference, and save it in <code>PropertyNameCapturer</code> (2).  If the method is not a getter, then the code throws an exception (5).  The return type of the getter does not matter, so we return null based on the type of property (3). <br><br>  Now we have everything ready to get the name of the property in the <code>validateValue()</code> method: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T, P&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue( Class&lt;T&gt; type, Function&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T, P&gt; property, P value) { T capturer = getPropertyNameCapturer(type); property.apply(capturer); String propertyName = ((PropertyLiteralCapturer) capturer).getPropertyName(); <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre><br>  After applying the function to the created proxy, we cast the type to PropertyNameCapturer and get the name from Method. <br><br>  So using a bit of bytecode generation magic, we used the Java 8 Method Reference to emulate property literals. <br><br>  Of course, if we had real literals of properties in a language, we would all be better off.  I would even allow you to work with private properties and, probably, you could refer to properties from annotations.  Real property literals would be more accurate (without the ‚Äúget‚Äù prefix) and would not look like a hack. <br><br><h2>  From translator </h2><br>  It is worth noting that other good languages ‚Äã‚Äãalready support (or almost) a similar mechanism: <br><br><ul><li>  C # - <a href="https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/nameof">nameOf operator</a> </li><li>  Groovy and Scala - there are famous <a href="https://strangeway.org/2014/12/%25D1%2582%25D0%25B8%25D0%25BF%25D0%25BE%25D0%25B1%25D0%25B5%25D0%25B7%25D0%25BE%25D0%25BF%25D0%25B0%25D1%2581%25D0%25BD%25D1%258B%25D0%25B9-%25D0%25B1%25D0%25B8%25D0%25BD%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B3-%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585-%25D0%25B4%25D0%25BB%25D1%258F-ui-%25D0%25BA%25D0%25BE/">hacks with metaprogramming and macros</a> </li><li>  Kotlin - is the normal syntax for <code>User::login.name</code> </li></ul><br>  If you suddenly use the Lombok Java project with c, then the <a href="https://dzone.com/articles/typesafe-property-literals">compile-time generator bytecode is</a> written for it. <br><br>  Inspired by the approach described in the article, your humble servant compiled a small library that implements nameOfProperty () for Java 8: <br><br>  <a href="https://github.com/strangeway-org/nameof">Sources</a> <br>  <a href="https://bintray.com/strangeway-org/libs/nameof">Binary</a> </div><p>Source: <a href="https://habr.com/ru/post/420533/">https://habr.com/ru/post/420533/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420521/index.html">Now officially: TLS 1.3 is recognized as standard</a></li>
<li><a href="../420523/index.html">Analysis of binary options charts or how I once again proved to myself that freebies do not exist</a></li>
<li><a href="../420525/index.html">Networks for the harshest. Part fifteen. QoS</a></li>
<li><a href="../420527/index.html">A smile can sound and it is contagious.</a></li>
<li><a href="../420529/index.html">Advanced use of Gita or how to retire half a year earlier?</a></li>
<li><a href="../420537/index.html">Another tale about how relatively megaphone relatively honestly rob money</a></li>
<li><a href="../420539/index.html">Custom approach to normalize and reset styles (custom-reset.css)</a></li>
<li><a href="../420541/index.html">Researchers at Carnegie Mellon have so far created the most believable "deepfakes"</a></li>
<li><a href="../420547/index.html">As I wrote and defended a degree in DEVOPS and engineering practices in 1C from scratch</a></li>
<li><a href="../420549/index.html">Freemarker templates</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>