<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What's new in Swift 4.1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is a free translation of the article What's new in Swift 4.1 by Paul Hudson 


 Swift 4.1 is the first minor release of Swift 4, which broug...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What's new in Swift 4.1</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/x5/m5/_e/x5m5_ezhhd6xvzytvd_kptslocm.png"></div><br><p>  <em>This post is a free translation of the article <a href="https://www.hackingwithswift.com/articles/50/whats-new-in-swift-4-1">What's new in Swift 4.1</a> by <a href="https://www.hackingwithswift.com/about">Paul Hudson</a></em> </p><br><p>  Swift 4.1 is the first minor release of Swift 4, which brought with it some useful features, such as automatic use of Equatable and Hashable, conditional matches, etc. </p><br><p>  Be sure to set yourself at least <a href="https://developer.apple.com/download/">Xcode 9.3</a> , then create a new playground.  Let's look at the new features of this version ... </p><br><p><a name="habracut"></a></p><h1>  Equatable and Hashable </h1><br>  <code>Equatable</code> protocol allows <code>Equatable</code> to compare one entity with another.  When we say <code>5 == 5</code> , Swift understands what this means because <code>Int</code> complies with the <code>Equatable</code> protocol, which means it implements a function that describes what " <code>==</code> " means for entities of type <code>Int</code> . <br><p>  Implementing <code>Equatable</code> in your own types (structures, enumerations) allows you to work with them as well as with strings, arrays, numbers, etc.  And it will be good if your structures comply with the <code>Equatable</code> protocol in order to better fit the general concept of types that are passed by value. </p><br><p>  However, the implementation of <code>Equatable</code> may not be too elegant.  For example, we have the following structure: </p><br><pre> <code class="hljs javascript">struct Person { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> middleName: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> age: Int <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> city: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> }</code> </pre> <br><p>  And if you have two entities of type <code>Person</code> and you want to compare them, you need to compare all four properties, like this: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> age: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> city: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> ==</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: Person, rhs: Person)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.firstName == rhs.firstName &amp;&amp; lhs.lastName == rhs.lastName &amp;&amp; lhs.age == rhs.age &amp;&amp; lhs.city == rhs.city } }</code> </pre> <br><p>  It's hard to even <em>read</em> , not like <em>writing</em> . </p><br><p>  Fortunately, in Swift 4.1 it is possible to automatically match for <code>Equatable</code> , the method <code>==</code> will be generated automatically and will compare all the properties of the first entity with all the properties of the second, as described above.  All you need to do is add <code>Equatable</code> to your type, and Swift does the rest. </p><br><p>  Naturally, you can implement your own version of the method <code>==</code> .  For example, if your type has an <code>id</code> property that uniquely identifies an entity, you could write <code>==</code> to compare only this property, instead of Swift doing the extra work. </p><br><p>  Similar to <code>Equatable</code> , Swift 4.1 also introduced support for <code>Hashable</code> .  Now <code>hashValue</code> can be automatically generated to match this protocol.  <code>Hashable</code> usually annoying, because you need to return a unique (more or less unique) hash for each entity.  This is important because it allows you to use your entities as keys for dictionaries, or allows you to store entities in sets. </p><br><p>  Previously, it was necessary to write something like this: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hashValue: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstName.hashValue ^ lastName.hashValue &amp;* <span class="hljs-number"><span class="hljs-number">16777619</span></span> }</code> </pre> <br><p>  Given this, you now hardly need to write your own implementation of <code>hashValue</code> in Swift 4.1, but if you still need it, you can do it (similarly <code>==</code> in <code>Equatable</code> ). </p><br><p>  <b>Note:</b> Add, if necessary, these protocols to your types, and do not forget that all fields of your types must also correspond to them. </p><br><p>  More information can be found here: <a href="">Swift Evolution proposal SE-0185</a> . </p><br><h1>  Conditional matches </h1><br><p>  <a href="">Swift Evolution proposal SE-0143</a> offered conditional correspondences, and they are now in Swift 4.1.  This is a powerful feature that will be useful to very many.  With her now earn things that have not worked before.  For example, in Swift 4.0, such code will not compile: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>: [<span class="hljs-type"><span class="hljs-type">String?</span></span>] = [<span class="hljs-string"><span class="hljs-string">"Andrew"</span></span>, <span class="hljs-string"><span class="hljs-string">"Lizzie"</span></span>, <span class="hljs-string"><span class="hljs-string">"Sophie"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>: [<span class="hljs-type"><span class="hljs-type">String?</span></span>] = [<span class="hljs-string"><span class="hljs-string">"Charlotte"</span></span>, <span class="hljs-string"><span class="hljs-string">"Paul"</span></span>, <span class="hljs-string"><span class="hljs-string">"John"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">right</span></span></code> </pre> <br><p>  That's because <code>String</code> and <code>[String]</code> are <code>Equatable</code> , but <code>[String?]</code> Is not.  A conditional match means that the type will conform to the protocol as long as a certain condition is satisfied.  This means that if the elements of the array match <code>Equatable</code> - the whole array corresponds to <code>Equatable</code> . </p><br><p>  Conditional matching is common to the <code>Codable</code> protocol, and this will make some things more secure.  Take a look at this code: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = <span class="hljs-string"><span class="hljs-string">"Taylor"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> people = [<span class="hljs-type"><span class="hljs-type">Person</span></span>()] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> encoder = <span class="hljs-type"><span class="hljs-type">JSONEncoder</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> encoder.encode(people)</code> </pre> <br><p>  We have an array of one element of type <code>Person</code> , and we are trying to convert this array to JSON.  Such code is quietly compiled in Swift 4.0, but in runtime you will get an error, because <code>Person</code> does not comply with the <code>Codable</code> protocol.  Swift 4.1 solves this problem: <code>Optional</code> , <code>Array</code> , <code>Dictionary</code> and <code>Set</code> now conform to the <code>Codable</code> protocol only if their contents conform to this protocol, therefore in Swift 4.1 such code simply does not compile. </p><br><p>  Conditional matching is one of the features that makes life easier for most people, even those who do not write a lot of code. </p><br><h1>  flatMap is now (almost) compactMap </h1><br><p>  <code>flatMap()</code> is useful for many things in Swift 4.0, but its main feature is to convert entities into collections, removing nil from the result. </p><br><p>  In <a href="">Swift Evolution proposal, SE-0187 was</a> proposed to change this, and in Swift 4.1, <code>flatMap()</code> renamed to <code>compactMap()</code> to more clearly convey its meaning. </p><br><p>  For example: </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = [<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"Fish"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>.compactMap { <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br><p>  This will create an array with <code>Int</code> elements, which will contain the numbers 1 and 2, because "Fish" when converted to <code>Int</code> will return <code>nil</code> and will be ignored. </p><br><h1>  We are waiting for Swift 5.0 </h1><br><p>  Implementing conditional compliance contributes to stability, and automatic support for <code>Equatable</code> and <code>Hashable</code> definitely simplify the lives of developers. </p><br><p>  Other proposals are now either under review or under development, including: <a href="">SE-0192: Non-Exhaustive Enums</a> , <a href="">SE-0194: Derived Collection of Enum Cases</a> and <a href="">SE-0195: Dynamic Member Lookup</a> . </p><br><p>  It is equally important that this year Apple will hopefully release ABI stabilization for Swift, and it will be <em>great</em> .  We are waiting, sir. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/352514/">https://habr.com/ru/post/352514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352500/index.html">For beginners: 5 tips on github</a></li>
<li><a href="../352502/index.html">What's new in Swift 4.1?</a></li>
<li><a href="../352508/index.html">Heading "We read articles for you." December 2017 - January 2018</a></li>
<li><a href="../352510/index.html">Security Trends: why attackers attack non-financial accounts to steal money</a></li>
<li><a href="../352512/index.html">As we in Smart Engines taught Sailfish OS recognition</a></li>
<li><a href="../352516/index.html">Alternative approaches to the development of new IT products</a></li>
<li><a href="../352518/index.html">Heading "We read articles for you." February - March 2018</a></li>
<li><a href="../352520/index.html">Java Learning Framework for Deep Learning</a></li>
<li><a href="../352524/index.html">Conference DEFCON 16. "Cisco iOS Development Crime." Felix Lindner, head of Recurity Labs</a></li>
<li><a href="../352526/index.html">Pot vari or 4 methods of creative approach to solving problems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>