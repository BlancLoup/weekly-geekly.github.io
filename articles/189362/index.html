<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Technology Real Time MapReduce in Yandex. How to speed up something very big</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago, we told Habr√© that the search for Yandex had become more personalized. It takes into account not only constant, but also immediate inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Technology Real Time MapReduce in Yandex. How to speed up something very big</h1><div class="post__text post__text-html js-mediator-article">  Some time ago, we <a href="http://habrahabr.ru/company/yandex/blog/181514/">told Habr√©</a> that the search for Yandex had become more personalized.  It takes into account not only constant, but also immediate interests of the user, focusing on the last few requests and actions. <br><br>  Today we want to talk about technology Real Time MapReduce, through which all this has become possible.  It provides the transfer and processing of huge amounts of data needed for this task, and to do this, we did not even have to rewrite the code for MapReduce, which we have already used. <br><br> <a href="http://habrahabr.ru/company/yandex/blog/189362/"><img src="https://habrastorage.org/getpro/habr/post_images/1e1/5d3/b63/1e15d3b6358b5bc70e92bd21221f2f28.png" title="How to speed up something big"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In order to personalize the search results, you need to define the range of interests of the user, for which we store information about his behavior on the search page.  Data on user actions are recorded in the logs, and then processed using special algorithms that allow us to make the most relevant issue on request for each individual user.  At first, log processing was launched once a day, for which the <a href="http://ru.wikipedia.org/wiki/MapReduce">MapReduce</a> distributed computing technology was very well suited.  It does an excellent job analyzing large amounts of data. <br><a name="habracut"></a><br>  The incoming data (in our case, the logs) goes through several successive steps Map (data is broken down by keys) and Reduce (calculations are performed on a specific function and the result is collected).  In this case, the result of the calculations that occur at each stage is simultaneously input data for the next stage.  By running through special algorithms at each Reduce-step, the amount of data is reduced.  As a result, we get a small amount of useful data from a huge amount of raw data. <br><br>  However, as already mentioned in previous posts, users have not only permanent, but also momentary interests, which can be replaced literally in seconds.  And here the data from the daily prescription can no longer help.  We could speed up this process up to half an hour, some logs are processed with such frequency, but our task requires an instant reaction.  Unfortunately, when using MapReduce, there is a well-defined reactivity ceiling, due to the nature of the treatment. <br><br>  The processing steps are performed in strict sequence (after all, each stage generates data that will be processed in the next), and to get the final result using one key, you need to wait until all processing is completed.  Even with minor changes in the input data, the entire chain of steps needs to be re-performed, since without recalculation it is impossible to determine which of the intermediate results will be affected by these changes.  With a constant stream of incoming data (and from our search engines there is a stream at a speed of about 200 MB / s), such a system is unable to work effectively, and it is impossible to achieve a response to user actions in a few seconds. <br><br>  We also need a system that could quickly change the final result with small changes in the incoming data.  To do this, it must be able to determine which keys will be modified as a result of changes, and carry out recalculation only for them.  Thus, the volume of data processed at each stage will decrease, and at the same time the processing speed will increase. <br><br>  In Yandex, there are several projects that use classic cluster applications, where data is divided into nodes, between which there is an exchange of messages that allow you to change states for individual keys without producing a full recalculation.  However, for complex calculations, which involves processing logs, such a model is not suitable because of too much load on the message handler. <br>  In addition, most of the code that has accumulated in us that provides search quality is written under MapReduce.  And almost all of this code, with minor modifications, could be reused to process user actions in real time.  So the idea was born to create a system with an API, identical to the MapReduce interface, but at the same time capable of independently recognizing the keys affected by changes to the incoming data. <br><br><h5>  Architecture </h5><br>  Initially, the plan seemed simple enough: it was necessary to make an architecture that can calculate MapReduce-functions, but also can incrementally and effectively update the value of functions in seconds with small changes in input data.  The first prototype of RealTime MapReduce (RTMR) was ready in two weeks.  However, in the process of testing began to open weaknesses. <br><br>  Separately, all the problems seemed trivial, but in systems of this magnitude, linking everything with each other is not so easy.  As a result, after the elimination of all problems, practically nothing remained of the initial prototype, and the amount of code increased by an order of magnitude. <br><br>  In addition, it became clear that to ensure the necessary speed, all the data involved in the calculations must be stored in memory, for which we implemented a special architecture. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca5/dfd/050/ca5dfd05066563eccdb0e7fa321cec2b.png" alt="image"><br><br>  Let us examine in more detail the sequence of actions displayed on the diagram: <br><br><ol><li>  It all starts with the fact that the handler of the incoming request parses the data and starts a separate transaction for each key. </li><li>  In this case, the transaction is considered to be started only after receiving confirmation that the record of the start of the operation (PrepareRecord) is saved on the disk. </li><li>  After starting a transaction over the network, a response is sent to the incoming request, and the transaction is queued for processing by the workflow. </li><li>  Next, the workflow picks up the transaction and, depending on the locality of the key, either sends it over the network and waits for confirmation or creates content processing in which operations are performed. </li><li>  Subsequently, transactions are processed in isolation from each other: after the start, a brunch is set aside from the general state of the system, and at the end of processing changes are accepted. </li><li>  All data is stored in memory, which is extremely important for optimizing reduce-operations. </li><li>  Data on modified keys are periodically stored in permanent storage as backup copies. </li><li>  After processing the transaction, its result is recorded on the disk, and when it receives confirmation of the record from the log, it is considered complete. </li><li>  Also, a transaction can generate child transactions, in which case everything repeats, starting with the fourth item. </li><li>  In the process of restoring the state, the data is retrieved from the persistent storage and reproduced by the log, while the incomplete transactions are restarted.  If it is necessary to abort a transaction, AbortRecord is written to the log (an indicator that this transaction does not need to be restarted when the state is restored). </li></ol><br><br>  The second part of the scheme demonstrates the principle of operation of the log storage.  It supports asynchronous recording with the incoming queue, as well as callback for notifications.  The append-only structure and index for filtering records by key are implemented on the disk.  The adaptive scheduler uses read-operation statistics to determine the size of a record, finding the optimal balance between the recording speed and the waiting time before it starts.  Log storage consists of four non-RAID HDDs with sharding by key.  Direct I / O is used to write data to discs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/785/fdd/6ea/785fdd6eafac7b86c42b4ad406c5eed5.png" alt="image"><br><br>  In-memory storage implements a sequential write and parallel read approach.  Sharding is carried out by key.  Data is stored for a certain period of time in the settings, after which it can be overwritten with new ones.  A lock-free ring buffer is used to store the value data.  For entries (key, subkey, table, timestamp + additional information) use the append-only lock-free Skip List.  After filling in the Skip List, a new one is created, and the old one is combined with the existing immutable data.  For each key, entries are sorted and delta-encoded. <br><br>  Coordination of nodes in the cluster is carried out with the help of Zookeeper.  The master / slave definition is done through consistent hashing.  Outgoing transactions are processed by the master and additionally saved on the slaves.  Sections are also placed both on the master and on the slaves.  When reshuffling a new master collects data from the slice on the cluster, as well as the raw transaction from the log on its range of keys, catches up with its state and is included in the processing. <br><br><h5>  Perspective RealTime MapReduce </h5><br>  It is worth noting that in addition to personalizing the search for RTMR, you can find other applications.  In most cases, the algorithms used in the search can be rearranged to work in real time.  For example, it can be used to improve the quality of searching through fresh documents, publications in the media and blogs.  After all, the ranking of fresh documents depends not only on the speed of their crawling and indexing, this is not the most difficult process, and in most cases our robot has been doing this for quite some time in a few seconds.  However, much of the data for ranking is taken from information sources external to the document, and MapReduce is used to aggregate this data.  As mentioned above, the limitations of the batch processing methods do not allow aggregation in less than 20-30 minutes.  Therefore, without RTMR, part of the external signals for fresh documents comes with a delay. <br><br>  Adjustment of search hints can also be made instant.  Then the query options offered to the user will depend on what he was looking for a few seconds ago. <br><br>  Since our system is still quite young, in the near future we have an expansion of the MapReduce paradigm: the addition of new interfaces to it, sharpened specifically for real-time work.  For example, operations that are capable of doing preliminary incomplete preaggregation. <br><br>  In addition, we plan to produce a unified for MapReduce and RTMR declarative description of data flows and a graph of calculations.  Stages of RTMR calculations for different keys, unlike MapReduce, work inconsistently, which means that the sequential launching of stages from code loses all meaning. </div><p>Source: <a href="https://habr.com/ru/post/189362/">https://habr.com/ru/post/189362/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../189348/index.html">John Carmack joins Oculus and ... still remains in id Software</a></li>
<li><a href="../189350/index.html">As I wrote the update module on C #</a></li>
<li><a href="../189352/index.html">Interaction of php-soap on linux with certificate authorization using GOST algorithms</a></li>
<li><a href="../189356/index.html">Trace - Tracker for Extremes</a></li>
<li><a href="../189360/index.html">Sylph: Deep Stubs for tests from the creators of PHPixie, or how to convert an array to a class</a></li>
<li><a href="../189366/index.html">MODX EVO store - the first repository for MODX EVOLUTION</a></li>
<li><a href="../189370/index.html">10Gbit network storage - 2</a></li>
<li><a href="../189372/index.html">Elementary OS RC1</a></li>
<li><a href="../189374/index.html">NASA launched the first Russian-language site</a></li>
<li><a href="../189376/index.html">"Turbofilm" deleted copyrighted TV series</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>