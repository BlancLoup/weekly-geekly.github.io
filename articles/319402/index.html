<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Windows: Sleep (0.5)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As many probably know, the number of milliseconds in WinAPI'sshny Sleep function is transmitted by how much we want to sleep. Therefore, the minimum t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Windows: Sleep (0.5)</h1><div class="post__text post__text-html js-mediator-article">  As many probably know, the number of milliseconds in WinAPI'sshny <i>Sleep</i> function is transmitted by how much we want to sleep.  Therefore, the minimum that we can request is to fall asleep for 1 millisecond.  But what if we want to sleep even less?  For those interested in how to do this <s>in pictures</s> , welcome under cat. <br><a name="habracut"></a><br>  First, let me remind you that Windows (like any non-real-time system) does not guarantee that the thread (some people call it a thread, thread) will sleep exactly the requested time.  Starting from Vista, OS logic is simple.  There is a certain quantum of time allocated to the thread for execution (yes, yes, the very 20 ms that everyone heard about during the 2000 / XP and still hear about it on the server axes).  And the Windows reschedules the threads (stops some threads, starts others) only after this quantum has expired.  Those.  if the quantum in the OS is 20 ms (by default in XP it was just such a value, for example), even if we requested <i>Sleep (1),</i> in the worst case, the control will return to us in the same 20 ms.  There are multimedia functions for managing this quantum of time, in particular <i>timeBeginPeriod / timeEndPeriod</i> . <br><br>  Second, I will make a brief digression, why such accuracy may be required.  Microsoft says that only multimedia applications need this accuracy.  For example, you make a new WinAMP with blackjet, and here it is very important that we send a new piece of audio data to the system on time.  I needed another area.  We had a H264 flow decompressor.  And he was on ffmpeg'e.  And he had a synchronous interface (Frame * decompressor.Decompress (Frame * compressedFrame)).  And everything was fine until they decompressed the Intel chips in the processors.  I don‚Äôt remember what reasons I had to work with him not through the native Intel Media SDK, but through the DXVA2 interface.  And it is asynchronous.  So I had to work like this: <br><br><ul><li>  Copy data to video memory </li><li>  We do Sleep, so that the frame has time to expand </li><li>  Interrogate whether decompression has ended, and if so, then pick up the compressed frame from the video memory </li></ul><br>  The problem was in the second paragraph.  If you believe GPUView, then the frames had time to be shrunk for 50-200 microseconds.  If you put <i>Sleep (1)</i> then you can maximize 1000 * 4 * (cores) = 4000 frames per second on core i5.  If we assume that the usual fps is equal to 25, then it turns out that only 40 * 4 = 160 video streams are simultaneously decompressed.  And the goal was to pull out 200. Actually there were 2 options: either to redo everything for asynchronous work with a hardware decompressor, or to reduce the time of Sleep. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  First measurements </h3><br>  To roughly estimate the current runtime quantum of a thread, let's write a simple program: <br><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Starting test"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::high_resolution_clock::now(); ::Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::high_resolution_clock::now(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> elapsedMicrosec = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::duration_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::microseconds&gt;(t2 - t1).count(); total += elapsedMicrosec; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": Elapsed "</span></span> &lt;&lt; elapsedMicrosec &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Finished. average time:"</span></span> &lt;&lt; (total / <span class="hljs-number"><span class="hljs-number">5</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ test(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Here is a typical output on Win 8.1</b> <div class="spoiler_text">  Starting test <br>  0: Elapsed 1977 <br>  1: Elapsed 1377 <br>  2: Elapsed 1409 <br>  3: Elapsed 1396 <br>  4: Elapsed 1432 <br>  Finished.  average time: 1518 <br></div></div><br>  Immediately, I want to warn you that if you have for example MSVS 2012, then std :: chrono :: high_resolution_clock you do not intend anything.  And in general, we recall that the surest way to measure the duration of something is the Performance Counter.  We will rewrite our code a bit to make sure that we measure the times correctly.  First, let's write a helper class.  <sub>I did tests now on MSVS2015, there the implementation of high_resolution_clock is already correct, through performance counts.</sub>  <sub>I do this step, all of a sudden, who wants to repeat the tests on an older compiler</sub> <br><br><div class="spoiler">  <b class="spoiler_title">PreciseTimer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once class PreciseTimer { public: PreciseTimer(); std::int64_t Microsec() const; private: LARGE_INTEGER m_freq; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   . }; inline PreciseTimer::PreciseTimer() { if (!QueryPerformanceFrequency(&amp;m_freq)) m_freq.QuadPart = 0; } inline int64_t PreciseTimer::Microsec() const { LARGE_INTEGER current; if (m_freq.QuadPart == 0 || !QueryPerformanceCounter(¬§t)) return 0; //      . return current.QuadPart * 1000'000 / m_freq.QuadPart; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Modified test function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PreciseTimer timer; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Starting test"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t1 = timer.Microsec(); ::Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t2 = timer.Microsec(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> elapsedMicrosec = t2 - t1; total += elapsedMicrosec; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": Elapsed "</span></span> &lt;&lt; elapsedMicrosec &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Finished. average time:"</span></span> &lt;&lt; (total / <span class="hljs-number"><span class="hljs-number">5</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Well, the typical output of our program on Windows Server 2008 R2</b> <div class="spoiler_text">  Starting test <br>  0: Elapsed 10578 <br>  1: Elapsed 14519 <br>  2: Elapsed 14592 <br>  3: Elapsed 14625 <br>  4: Elapsed 14354 <br>  Finished.  average time: 13733 <br></div></div><br><h3>  We are trying to solve the problem in the forehead </h3><br>  Let's rewrite our program a little.  And try to use the obvious: <br><br><div class="spoiler">  <b class="spoiler_title">std :: this_thread :: sleep_for (std :: chrono :: microseconds (500))</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; description, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)&gt;&amp; f)</span></span></span><span class="hljs-function"> </span></span>{ PreciseTimer timer; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Starting test: "</span></span> &lt;&lt; description &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t1 = timer.Microsec(); f(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t2 = timer.Microsec(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> elapsedMicrosec = t2 - t1; total += elapsedMicrosec; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": Elapsed "</span></span> &lt;&lt; elapsedMicrosec &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Finished. average time:"</span></span> &lt;&lt; (total / <span class="hljs-number"><span class="hljs-number">5</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ test(<span class="hljs-string"><span class="hljs-string">"Sleep(1)"</span></span>, [] { ::Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); test(<span class="hljs-string"><span class="hljs-string">"sleep_for(microseconds(500))"</span></span>, [] { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::sleep_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::microseconds(<span class="hljs-number"><span class="hljs-number">500</span></span>)); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Typical output on Windows 8.1</b> <div class="spoiler_text">  Starting test: Sleep (1) <br>  0: Elapsed 1187 <br>  1: Elapsed 1315 <br>  2: Elapsed 1427 <br>  3: Elapsed 1432 <br>  4: Elapsed 1449 <br>  Finished.  average time: 1362 <br>  Starting test: sleep_for (microseconds (500)) <br>  0: Elapsed 1297 <br>  1: Elapsed 1434 <br>  2: Elapsed 1280 <br>  3: Elapsed 1451 <br>  4: Elapsed 1459 <br>  Finished.  average time: 1384 <br></div></div><br>  Those.  as we see, there is no gain on the move.  Take a closer look at <i>this_thread :: sleep_for</i> .  And we notice that it is generally implemented through <i>this_thread :: sleep_until</i> , i.e.  Unlike <i>Sleep,</i> it is not even immune to translating hours, for example.  Let's try to find a better alternative. <br><br><h3>  Slip that can </h3><br>  Searching for MSDN and stackoverflow directs us towards Waitable Timers, as the only alternative.  Well, let's write another helper class. <br><br><div class="spoiler">  <b class="spoiler_title">WaitableTimer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once class WaitableTimer { public: WaitableTimer() { m_timer = ::CreateWaitableTimer(NULL, FALSE, NULL); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!m_timer) throw std::runtime_error(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Failed to create waitable time (CreateWaitableTimer), error:"</span></span></span><span class="hljs-meta"> + std::to_string(::GetLastError())); } ~WaitableTimer() { ::CloseHandle(m_timer); m_timer = NULL; } void SetAndWait(unsigned relativeTime100Ns) { LARGE_INTEGER dueTime = { 0 }; dueTime.QuadPart = static_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;LONGLONG&gt;(relativeTime100Ns) * -1; BOOL res = ::SetWaitableTimer(m_timer, &amp;dueTime, 0, NULL, NULL, FALSE); if (!res) throw std::runtime_error("SetAndWait: failed set waitable time (SetWaitableTimer), error:" + std::to_string(::GetLastError())); DWORD waitRes = ::WaitForSingleObject(m_timer, INFINITE); if (waitRes == WAIT_FAILED) throw std::runtime_error("SetAndWait: failed wait for waitable time (WaitForSingleObject)" + std::to_string(::GetLastError())); } private: HANDLE m_timer; };</span></span></span></span></code> </pre><br></div></div><br>  And supplement our tests with new: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ test(<span class="hljs-string"><span class="hljs-string">"Sleep(1)"</span></span>, [] { ::Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); test(<span class="hljs-string"><span class="hljs-string">"sleep_for(microseconds(500))"</span></span>, [] { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::sleep_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::microseconds(<span class="hljs-number"><span class="hljs-number">500</span></span>)); }); WaitableTimer timer; test(<span class="hljs-string"><span class="hljs-string">"WaitableTimer"</span></span>, [&amp;timer] { timer.SetAndWait(<span class="hljs-number"><span class="hljs-number">5000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Let's see what has changed. <br><br><div class="spoiler">  <b class="spoiler_title">Typical output on Windows Server 2008 R2</b> <div class="spoiler_text">  Starting test: Sleep (1) <br>  0: Elapsed 10413 <br>  1: Elapsed 8467 <br>  2: Elapsed 14365 <br>  3: Elapsed 14563 <br>  4: Elapsed 14389 <br>  Finished.  average time: 12439 <br>  Starting test: sleep_for (microseconds (500)) <br>  0: Elapsed 11771 <br>  1: Elapsed 14247 <br>  2: Elapsed 14323 <br>  3: Elapsed 14426 <br>  4: Elapsed 14757 <br>  Finished.  average time: 13904 <br>  Starting test: WaitableTimer <br>  0: Elapsed 12654 <br>  1: Elapsed 14700 <br>  2: Elapsed 14259 <br>  3: Elapsed 14505 <br>  4: Elapsed 14493 <br>  Finished.  average time: 14122 <br></div></div><br>  As we can see, on server-side operations on the move, nothing has changed.  Since the default runtime quantum of a thread on it is usually huge.  I will not look for virtual machines with XP and Windows 7, but I‚Äôll say that most likely there will be a completely similar situation on XP, but on Windows 7 it‚Äôs like a default time slice of 1ms.  Those.  The new test should give the same performance as the previous tests on Windows 8.1. <br><br><div class="spoiler">  <b class="spoiler_title">Now let's take a look at the output of our program on Windows 8.1.</b> <div class="spoiler_text">  Starting test: Sleep (1) <br>  0: Elapsed 1699 <br>  1: Elapsed 1444 <br>  2: Elapsed 1493 <br>  3: Elapsed 1482 <br>  4: Elapsed 1403 <br>  Finished.  average time: 1504 <br>  Starting test: sleep_for (microseconds (500)) <br>  0: Elapsed 1259 <br>  1: Elapsed 1088 <br>  2: Elapsed 1497 <br>  3: Elapsed 1497 <br>  4: Elapsed 1528 <br>  Finished.  average time: 1373 <br>  Starting test: WaitableTimer <br>  0: Elapsed 643 <br>  1: Elapsed 481 <br>  2: Elapsed 424 <br>  3: Elapsed 330 <br>  4: Elapsed 468 <br>  Finished.  average time: 469 <br></div></div><br>  What do we see?  That's right, that our new slip could!  Those.  on Windows 8.1, we have already solved our task.  Why did this happen?  This happened due to the fact that in windows 8.1 the time quantum was made just 500 microseconds.  Yes, yes, the threads run for 500 microseconds (on my system, the default resolution is set to 500.8 microseconds and less is not set, unlike XP / Win7, where it was possible to set 500 microseconds exactly), then rescheduled again according to their priorities and run on new execution. <br><br>  <b>Conclusion 1</b> : To make <i>Sleep (0.5) is</i> necessary, but not sufficient, the right slip.  Always use the Waitable timers for this. <br><br>  <b>Conclusion 2</b> : If you write only under Win 8.1 / Win 10 and are guaranteed not to run on other operating systems, then you can stop using Waitable Timers. <br><br><h3>  We remove the dependence on the circumstances or how to increase the accuracy of the system timer </h3><br>  I have already mentioned the multimedia function timeBeginPeriod.  The documentation states that using this function you can set the desired timer accuracy.  Let's check.  Once again we modify our program. <br><br><div class="spoiler">  <b class="spoiler_title">v3 program</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"PreciseTimer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"WaitableTimer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> comment (lib, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Winmm.lib"</span></span></span><span class="hljs-meta">) void test(const std::string&amp; description, const std::function</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;void(void)&gt;&amp; f) { PreciseTimer timer; std::cout &lt;&lt; "Starting test: " &lt;&lt; description &lt;&lt; std::endl; std::int64_t total = 0; for (unsigned i = 0; i &lt; 5; ++i) { auto t1 = timer.Microsec(); f(); auto t2 = timer.Microsec(); auto elapsedMicrosec = t2 - t1; total += elapsedMicrosec; std::cout &lt;&lt; i &lt;&lt; ": Elapsed " &lt;&lt; elapsedMicrosec &lt;&lt; std::endl; } std::cout &lt;&lt; "Finished. average time:" &lt;&lt; (total / 5) &lt;&lt; std::endl; } void runTestPack() { test("Sleep(1)", [] { ::Sleep(1); }); test("sleep_for(microseconds(500))", [] { std::this_thread::sleep_for(std::chrono::microseconds(500)); }); WaitableTimer timer; test("WaitableTimer", [&amp;timer] { timer.SetAndWait(5000); }); } int main() { runTestPack(); std::cout &lt;&lt; "Timer resolution is set to 1 ms" &lt;&lt; std::endl; //     timeGetDevCaps   ,   ,      //    ,        timeBeginPeriod(1); ::Sleep(1); //      ::Sleep(1); //      runTestPack(); timeEndPeriod(1); return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  Traditionally, the typical findings of our program. <br><br><div class="spoiler">  <b class="spoiler_title">On Windows 8.1</b> <div class="spoiler_text">  Starting test: Sleep (1) <br>  0: Elapsed 2006 <br>  1: Elapsed 1398 <br>  2: Elapsed 1390 <br>  3: Elapsed 1424 <br>  4: Elapsed 1424 <br>  Finished.  average time: 1528 <br>  Starting test: sleep_for (microseconds (500)) <br>  0: Elapsed 1348 <br>  1: Elapsed 1418 <br>  2: Elapsed 1459 <br>  3: Elapsed 1475 <br>  4: Elapsed 1503 <br>  Finished.  average time: 1440 <br>  Starting test: WaitableTimer <br>  0: Elapsed 200 <br>  1: Elapsed 469 <br>  2: Elapsed 442 <br>  3: Elapsed 456 <br>  4: Elapsed 462 <br>  Finished.  average time: 405 <br>  Timer resolution is set to 1 ms <br>  Starting test: Sleep (1) <br>  0: Elapsed 1705 <br>  1: Elapsed 1412 <br>  2: Elapsed 1411 <br>  3: Elapsed 1441 <br>  4: Elapsed 1408 <br>  Finished.  average time: 1475 <br>  Starting test: sleep_for (microseconds (500)) <br>  0: Elapsed 1916 <br>  1: Elapsed 1451 <br>  2: Elapsed 1415 <br>  3: Elapsed 1429 <br>  4: Elapsed 1223 <br>  Finished.  average time: 1486 <br>  Starting test: WaitableTimer <br>  0: Elapsed 602 <br>  1: Elapsed 445 <br>  2: Elapsed 994 <br>  3: Elapsed 347 <br>  4: Elapsed 345 <br>  Finished.  average time: 546 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">And on Windows Server 2008 R2</b> <div class="spoiler_text">  Starting test: Sleep (1) <br>  0: Elapsed 10306 <br>  1: Elapsed 13799 <br>  2: Elapsed 13867 <br>  3: Elapsed 13877 <br>  4: Elapsed 13869 <br>  Finished.  average time: 13143 <br>  Starting test: sleep_for (microseconds (500)) <br>  0: Elapsed 10847 <br>  1: Elapsed 13986 <br>  2: Elapsed 14000 <br>  3: Elapsed 13898 <br>  4: Elapsed 13834 <br>  Finished.  average time: 13313 <br>  Starting test: WaitableTimer <br>  0: Elapsed 11454 <br>  1: Elapsed 13821 <br>  2: Elapsed 14014 <br>  3: Elapsed 13852 <br>  4: Elapsed 13837 <br>  Finished.  average time: 13395 <br>  Timer resolution is set to 1 ms <br>  Starting test: Sleep (1) <br>  0: Elapsed 940 <br>  1: Elapsed 218 <br>  2: Elapsed 276 <br>  3: Elapsed 352 <br>  4: Elapsed 384 <br>  Finished.  average time: 434 <br>  Starting test: sleep_for (microseconds (500)) <br>  0: Elapsed 797 <br>  1: Elapsed 386 <br>  2: Elapsed 371 <br>  3: Elapsed 389 <br>  4: Elapsed 371 <br>  Finished.  average time: 462 <br>  Starting test: WaitableTimer <br>  0: Elapsed 323 <br>  1: Elapsed 338 <br>  2: Elapsed 309 <br>  3: Elapsed 359 <br>  4: Elapsed 391 <br>  Finished.  average time: 344 <br></div></div><br>  Let's analyze the interesting facts that are visible from the results: <br><br><ol><li>  On windows 8.1, nothing has changed.  We conclude that <i>timeBeginPeriod</i> is smart enough, i.e.  if N applications have requested permission of the system timer to different values, then this resolution will not be reduced.  On Windows 7, we would also not notice any changes, since there the resolution of the timer is already 1 ms. <br><br></li><li>  On the server OS, <i>timeBeginPeriod (1)</i> worked unexpectedly: it set the resolution of the system timer to the highest possible value.  Those.  On such operating systems, a workplace of the type is clearly sewn somewhere: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeBeginPerion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UINT uPeriod)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uPeriod == <span class="hljs-number"><span class="hljs-number">1</span></span>) { setMaxTimerResolution(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ... }</code> </pre> <br>  I note that this was not yet on Windows Server 2003 R2.  This is an innovation in the 2008m server. <br><br></li><li>  On server OSes, <i>Sleep (1)</i> also worked in unexpected ways.  Those.  <i>Sleep (1) is</i> interpreted on <b>server operating systems, starting from the 2008th server,</b> not as " <b>make a pause of 1 millisecond</b> ", but as " <b>make the minimum possible pause</b> ."  <sup>Next is the case that this statement is not true.</sup> </li></ol><br>  We continue our conclusions: <br><br>  <b>Conclusion 3</b> : If you write only under Win Server 2008/2012/2016 and are guaranteed not to run on other operating <i>systems</i> , then you can not bother at all, <i>timeBeginPeriod (1)</i> and the subsequent <i>Sleep (1)</i> will do everything you need. <br><br>  <b>Conclusion 4</b> : <i>timeBeginPeriod</i> for our purposes is good only for server axes.  but sharing it with Waitable Devices covers our task on Win Server 2008/2012/2016 and on Windows 8.1 / Windows 10 <br><br><h3>  What if we want everything at once? </h3><br>  Let's think about what we should do if we need Sleep (0.5) to work under Win XP / Win Vista / Win 7 / Win Server 2003. <br><br>  Only the native api will come to the rescue - the undocumented api that is accessible to us from the user space via ntdll.dll.  There are interesting functions NtQueryTimerResolution / NtSetTimerResolution. <br><br><div class="spoiler">  <b class="spoiler_title">Let's write the AdjustSystemTimerResolutionTo500mcs function.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustSystemTimerResolutionTo500mcs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ULONG resolution = <span class="hljs-number"><span class="hljs-number">5000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 0.5   100- . ULONG sysTimerOrigResolution = 10000; ULONG minRes; ULONG maxRes; NTSTATUS ntRes = NtQueryTimerResolution(&amp;maxRes, &amp;minRes, &amp;sysTimerOrigResolution); if (NT_ERROR(ntRes)) { std::cerr &lt;&lt; "Failed query system timer resolution: " &lt;&lt; ntRes; } ULONG curRes; ntRes = NtSetTimerResolution(resolution, TRUE, &amp;curRes); if (NT_ERROR(ntRes)) { std::cerr &lt;&lt; "Failed set system timer resolution: " &lt;&lt; ntRes; } else if (curRes != resolution) { //        curRes  resolution,   . ..  , , //   5000,    5008 std::cerr &lt;&lt; "Failed set system timer resolution: req=" &lt;&lt; resolution &lt;&lt; ", set=" &lt;&lt; curRes; } return sysTimerOrigResolution; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">To make the code compile, add the ads of the necessary functions.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;winnt.h&gt; #ifndef NT_ERROR #define NT_ERROR(Status) ((((ULONG)(Status)) &gt;&gt; 30) == 3) #endif extern "C" { NTSYSAPI NTSTATUS NTAPI NtSetTimerResolution( _In_ ULONG DesiredResolution, _In_ BOOLEAN SetResolution, _Out_ PULONG CurrentResolution); NTSYSAPI NTSTATUS NTAPI NtQueryTimerResolution( _Out_ PULONG MaximumResolution, _Out_ PULONG MinimumResolution, _Out_ PULONG CurrentResolution); } #pragma comment (lib, "ntdll.lib")</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Typical output from Windows 8.1</b> <div class="spoiler_text">  Starting test: Sleep (1) <br>  0: Elapsed 13916 <br>  1: Elapsed 14995 <br>  2: Elapsed 3041 <br>  3: Elapsed 2247 <br>  4: Elapsed 15141 <br>  Finished.  average time: 9868 <br>  Starting test: sleep_for (microseconds (500)) <br>  0: Elapsed 12359 <br>  1: Elapsed 14607 <br>  2: Elapsed 15019 <br>  3: Elapsed 14957 <br>  4: Elapsed 14888 <br>  Finished.  average time: 14366 <br>  Starting test: WaitableTimer <br>  0: Elapsed 12783 <br>  1: Elapsed 14848 <br>  2: Elapsed 14647 <br>  3: Elapsed 14550 <br>  4: Elapsed 14888 <br>  Finished.  average time: 14343 <br>  Timer resolution is set to 1 ms <br>  Starting test: Sleep (1) <br>  0: Elapsed 1175 <br>  1: Elapsed 1501 <br>  2: Elapsed 1473 <br>  3: Elapsed 1147 <br>  4: Elapsed 1462 <br>  Finished.  average time: 1351 <br>  Starting test: sleep_for (microseconds (500)) <br>  0: Elapsed 1030 <br>  1: Elapsed 1376 <br>  2: Elapsed 1452 <br>  3: Elapsed 1335 <br>  4: Elapsed 1467 <br>  Finished.  average time: 1332 <br>  Starting test: WaitableTimer <br>  0: Elapsed 105 <br>  1: Elapsed 394 <br>  2: Elapsed 429 <br>  3: Elapsed 927 <br>  4: Elapsed 505 <br>  Finished.  average time: 472 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Typical output from Windows Server 2008 R2</b> <div class="spoiler_text">  Starting test: Sleep (1) <br>  0: Elapsed 7364 <br>  1: Elapsed 14056 <br>  2: Elapsed 14188 <br>  3: Elapsed 13910 <br>  4: Elapsed 14178 <br>  Finished.  average time: 12739 <br>  Starting test: sleep_for (microseconds (500)) <br>  0: Elapsed 11404 <br>  1: Elapsed 13745 <br>  2: Elapsed 13975 <br>  3: Elapsed 14006 <br>  4: Elapsed 14037 <br>  Finished.  average time: 13433 <br>  Starting test: WaitableTimer <br>  0: Elapsed 11697 <br>  1: Elapsed 14174 <br>  2: Elapsed 13808 <br>  3: Elapsed 14010 <br>  4: Elapsed 14054 <br>  Finished.  average time: 13548 <br>  Timer resolution is set to 1 ms <br>  Starting test: Sleep (1) <br>  0: Elapsed 10690 <br>  1: Elapsed 14308 <br>  2: Elapsed 768 <br>  3: Elapsed 823 <br>  4: Elapsed 803 <br>  Finished.  average time: 5478 <br>  Starting test: sleep_for (microseconds (500)) <br>  0: Elapsed 983 <br>  1: Elapsed 955 <br>  2: Elapsed 946 <br>  3: Elapsed 937 <br>  4: Elapsed 946 <br>  Finished.  average time: 953 <br>  Starting test: WaitableTimer <br>  0: Elapsed 259 <br>  1: Elapsed 456 <br>  2: Elapsed 453 <br>  3: Elapsed 456 <br>  4: Elapsed 460 <br>  Finished.  average time: 416 <br></div></div><br>  It remains to make observations and conclusions. <br><br>  Observations: <br><br><ol><li>  On Win8, after the first launch of the program, the resolution of the system timer was reset to a large value.  Those.  <b>Conclusion 2</b> was made by us wrong. <br><br></li><li>  After manual installation, the spread of real slips for the case of the WaitableTimer has grown, even though the average slip is about 500 microseconds. <br><br></li><li>  On the server OS, <i>Sleep (1)</i> very unexpectedly stopped working (as <i>did this_thread :: sleep_for</i> ) compared to the case of <i>timeBeginPeriod</i> .  Those.  <i>Sleep (1)</i> began to work as it should, in the sense of " <b>pause 1 millisecond</b> ." </li></ol><br><h3>  Final conclusions </h3><br><ul><li>  <b>Conclusion 1</b> remained unchanged: To make <i>Sleep (0.5) is</i> necessary, but not sufficient, the correct slip.  Always use the Waitable timers for this. <br><br></li><li>  <b>Conclusion 2</b> : The resolution of the system timer on Windows depends on the type of Windows, on the version of Windows, on the currently running processes, on what processes could be performed before.  Those.  nothing can be stated or guaranteed!  If you need any guarantees, then you need to always request / set the necessary accuracy yourself.  For values ‚Äã‚Äãless than 1 millisecond, you need to use native api.  For larger values, it is better to use <i>timeBeginPeriod</i> . <br><br></li><li>  <b>Conclusion 3</b> : If possible, it is better to test the code not only on your working Win 10, but also on the one specified by the customer.  We must remember that server operating systems can be very different from the desktop </li></ul></div><p>Source: <a href="https://habr.com/ru/post/319402/">https://habr.com/ru/post/319402/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319392/index.html">Realistic UI: a realistic look at the Optimistic UI</a></li>
<li><a href="../319394/index.html">Own image slider on jQuery</a></li>
<li><a href="../319396/index.html">Evernote overview and integration (based on GTD using the Wunderlist example)</a></li>
<li><a href="../319398/index.html">‚ÄúMy cloud is my fortress‚Äù: Trends of cloud security</a></li>
<li><a href="../319400/index.html">Texture Remastering for BioShock: The Collection</a></li>
<li><a href="../319404/index.html">Monitoring mac addresses on Cisco network device ports using snmp protocol</a></li>
<li><a href="../319406/index.html">Through thorns to the clouds: creating a cloud service for 3D design and design of premises based on the C3D and WebGL core</a></li>
<li><a href="../319408/index.html">How to become a product manager. Part 4 about Data Science and ASO</a></li>
<li><a href="../319410/index.html">Dynamic network traffic redirection</a></li>
<li><a href="../319414/index.html">Training acid battery somehow and do it yourself</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>