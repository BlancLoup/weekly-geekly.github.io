<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to automate the creation of virtual machines? We tell in detail</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Creating a new virtual machine is a time-consuming routine. And the more infrastructure and organization, the more procedures associated with this pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to automate the creation of virtual machines? We tell in detail</h1><div class="post__text post__text-html js-mediator-article">  Creating a new virtual machine is a time-consuming routine.  And the more infrastructure and organization, the more procedures associated with this process.  We automated this process using PowerShell. <br><br>  Welcome under the cat, if you are interested. <br><br><img src="https://habrastorage.org/webt/fv/fr/cc/fvfrccl_crsi5nfvcnstarorits.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  Programmers do not like to do double work, system administrators, too. <br><br>  Below is an example of the automation of one of our customers. <br><br>  We wanted to make sure that any engineer or project manager could create a new virtual machine with minimal effort and in the shortest possible time.  Our customer has an ITSM system, in this example it is ServiceNow, we created the corresponding web form in the service catalog.  To ‚Äúorder‚Äù a new machine, the manager needs to fill in the fields and confirm the ‚Äúorder‚Äù, after that the process chain is started, and at the output we get a ready-to-use machine. <br><br>  So let's consider what the manager needs to define in order to create a new virtual machine: <br><br><img src="https://habrastorage.org/webt/3l/8d/yo/3l8dyowobrfvbgpznotayqjywvu.png"><br><br>  <b>VM Description: virtual machine description</b> <b><br></b>  Here we need some explanations.  PowerShell 5.1 is actively used in our solution, so for now Windows-only, in the future we will try to add support for Unix-machines and switch to PowerShell Core. <br><br>  <b>OS</b> , operating system.  There are no particular obstacles to using Windows 2008 (R2), but we use 2012R2 or 2016. <br><br>  <b>VM Size</b> , the size of the virtual machine.  For each, this can be defined differently, in this example, Small 1CPU-4Gb Ram, Medium 2CPU-8Gb, Large 4-16. <br><br>  <b>VM Storage</b> , Disk 0 (C: \) has a fixed size that you cannot change, only the Fast / Slow storage selector is available.  ‚ÄúFast‚Äù - this could be a Storage Tier with SSD, and ‚ÄúSlow‚Äù is storage on ‚Äúregular‚Äù HDDs (of course - SAN).  Disk1 (Disk2 and on) also has a selector for the type of Storage, as well as fields for entering the desired size in gigabytes, Letter for the partition and cluster size (which is important for SQL Server). <br><br>  <b>Trust</b> , we determine that the machine must be Domain-joined or not, with access from the Public Network or not. <br><br>  <b>Type</b> , type of machine.  Almost every car can be defined as front-end or back-end applications or other in all other cases.  Based on the selected type, we will be able to further determine the most appropriate subnet for the machine. <br><br>  <b>Environment</b> , in the customer's infrastructure there are two data centers: Primary (Production) and Secondary (Dev / test), DC are interconnected by a fast communication channel and provide fault tolerance.  By convention, all virtual machines in Primary DC have an IP address starting at 10.230, and in Secondary DC at 10.231. <br><br>  <b>(SLA) Service Level Agreement</b> , this parameter affects the quality of service of this machine. <br><br>  <b>Applications</b> .  We added the ability to install and configure SQL Server.  You must select edition, instance name and collation.  It is also possible to set up a Web Server role and more. <br><br>  Now we need to determine how to store the selected values.  We decided that the most convenient format is a JSON file.  As I said earlier, ITSM ServiceNow is used in the customer‚Äôs environment;  the manager, after he has selected all the necessary values, clicks the ‚Äúorder‚Äù button and after that ServiceNow transfers all the parameters to our PowerShell script (to the back-end ServiceNow), which will create the JSON file.  It looks like this: <br><br><pre><code class="plaintext hljs">.\CreateConfiguration.ps1 -SecurityZone trusted -VMDescription "VM for CRM System" -Requestor "evgeniy.vpro" -OSVersion 2k16 -OSEdition Standard -BuildNewVM -VMEnvironment Prod -VMServiceLevel GOLD -VMSize Medium -Disk0Tier Fast -Disk1Size 50 -Disk1Tier Eco -Disk1Letter D -MSSQLServer -MSSQLInstanceName "Instance1" -SQLCollation Latin1_General_CI_AS -SQLEdition Standard -Disk2Size 35 -Disk3Size 65</code> </pre> <br><br>  In the body of the CreateConfiguration .ps1 script: <br><br><pre> <code class="plaintext hljs"># PowerShell- $config = [ordered]@{} #    . $config.SecurityZone=$SecurityZone</code> </pre><br><br>  At the end, export our object to a JSON file: <br><br><pre> <code class="plaintext hljs">$ServerConfig = New-Object ‚ÄìTypeName PSObject $config ConvertTo-Json -InputObject $ServerConfig -Depth 100 | Out-File "C:\Configs\TargetNodes\Build\$($Hostname.ToLower()).json" -Force</code> </pre><br><br>  Approximate sample of configuration: <br><br><pre> <code class="plaintext hljs">{ "Hostname": "dsctest552", "SecurityZone": "trusted", "Domain": "testdomain", "Requestor": "evgeniy.vpro", "VM": { "Size": "Medium", "Environment": "Prod", "SLA": "GOLD", "DbEngine": "MSSQL", "RAM": 8, "Storage": [ { "Id": 0, "Tier": "Fast", "Size": "100", "Allocation": 4, "Letter": "C" }, { "Id": 1, "Tier": "Eco", "Size": 50, "Label": "Data", "Allocation": 64, "Letter": "D" }, { "Id": 2, "Tier": "Fast", "Size": 35, "Label": "Data", "Allocation": 64, "Letter": "E" }, { "Id": 3, "Tier": "Fast", "Size": 65, "Label": "Data", "Allocation": 64, "Letter": "F" } ] }, "Network": { "MAC": "", "IP": "10.230.168.50", "Gateway": "10.230.168.1", "VLAN": ‚ÄúVLAN168‚Äù }, "OS": { "Version": "2k16", "Edition": "Standard", "Administrators": [ "LocaAdmin", "testdomain\\ Security-LocalAdmins" ] }, "OU": "OU=Servers,OU=Staging,DC=testdomain", "Applications": [ { "Application": "Microsoft SQL Server 2016", "InstanceName": "vd", "Collation": "Latin1_General_CI_AS", "Edition": "Standard", "Features": "SQLENGINE", "Folders": { "DataRoot": "E:\\MSSQL", "UserDB": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Data", "UserLog": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Log", "TempDB": "D:\\MSSQL\\MSSQL11.vd\\MSSQL\\TempDB", "TempDBLog": "D:\\MSSQL\\MSSQL11.vd\\MSSQL\\TempDB", "Backup": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Backup" }, "MaxMemory": 2147483647 } ], "Description": "VM for CRM", "Certificate": { "File": null, "Thumbprint": null }, "Version": 0 }</code> </pre><br><br>  You may have noticed that the web form was missing the name of the virtual machine and the IP address.  We get these values ‚Äã‚Äãautomatically as follows: <br><br>  <b>The name of the machine</b> , ITSM ServiceNow has a special section: CMDB (Configuration Management Data Base), this database stores all records of existing virtual machines, their status, support team, and so on.  We have created about 200 backup records with the status Allocated.  To get the name for the virtual machine, we make a REST request to the CMDB and get the first ‚Äúfree‚Äù record and change its status from Allocated to Pending install. <br><br>  <b>IP address and VLAN</b> , we deployed IPAM on our network - this is a built-in feature in Windows Server 2016 that allows you to manage IP addresses on your network.  It is not necessary to use all the capabilities of IPAM (DHCP, DNS, AD), but to use it only as a database of IP addresses with a potential extension of functionality.  The script that creates the JSON file makes a request to IPAM for the first free IP address in the subnet.  A VLAN subnet (x / 24 subnet) is determined based on the selected SLA, Environment, Trust, and Type values. <br>  The configuration file is ready, all fields are in place, you can create a machine.  The question is "how to store credentials for all of our scripts?".  We use the <a href="">CredentialManager</a> package.  This package works with the built-in Windows Credential Manager API for storing passwords.  Example of creating a password: <br><br><pre> <code class="plaintext hljs">New-StoredCredential -Target "ESXi" -UserName "testdomain.eu\vmwareadm" -Password "veryultraP@ssw00rd." -Type Generic -Persist LocalMachine</code> </pre><br><br>  The password will be readable within this machine and account. <br><br><pre> <code class="plaintext hljs">$ESXiAdmin = Get-StoredCredential -Type Generic -Target ESXi</code> </pre> <br><br>  We have a server that stores all configurations with GIT, now we can reliably track all changes in configurations: who, what, where, and when. <br><br>  The scheduled task is configured on this server: check the configuration folder and write all changes to the Windows Event Log. <br><br>  After 15 minutes, the scheduled task will write to the Windows EventLog that a new configuration file has been detected. <br><br>  It's time to check out this configuration.  First of all, we need to make sure that the file has the correct formatting: <br><br><pre> <code class="plaintext hljs">$Configuration=(Get-Content -Raw $File | Out-String | ConvertFrom-Json)</code> </pre> <br><br>  If everything is good, it's time to start building the machine and run the BuildVM.ps1 script. <br><br>  In BuildVM.ps1, we verify that the configuration file has a description of all the characteristics of the virtual machine: size, env, sla, type, storage, ram, network. <br><br>  Be sure to check if there is a machine with the same name in the infrastructure (CheckVM.ps1). <br>  Connect via <a href="https://www.powershellgallery.com/packages/VMware.PowerCLI/10.1.1.8827524">VMWare PowerShell CLI</a> to our vSphere: <br><br><pre> <code class="plaintext hljs">$VmWareAdmin = Get-StoredCredential -Type Generic -Target ESXi Connect-VIServer -Server "vSphereSrv" -Credential $VmWareAdmin | Out-Null</code> </pre><br><br>  Check if there is a machine with the same name in the infrastructure <br><br><pre> <code class="plaintext hljs">$VM=Get-VM $server -ErrorAction SilentlyContinue</code> </pre> <br><br>  And disconnect: <br><br><pre> <code class="plaintext hljs">Disconnect-VIServer * -Force -Confirm:$false</code> </pre> <br><br>  Make sure the machine is also not available via WinRM <br><br><pre> <code class="plaintext hljs">$ping=Test-NetConnection -ComputerName $Configuration.Hostname -CommonTCPPort WINRM -InformationLevel Quiet -ErrorAction SilentlyContinue</code> </pre> <br><br>  If $ VM and $ ping are empty, then you can create a new machine.  (We handle situations when the machine is already created in ESXi manually or this machine is in another data center.) <br><br><blockquote>  A few words about the car.  This is a prepared virtual machine image that was finalized by sysprep and converted to a template in our vSphere.  The image has a local administrator with a known password, this account does not crash after sysprep, which will allow us to access each machine from this template, and later we will be able to replace this password for security reasons. </blockquote><br><br><h3>  Create a virtual machine <br></h3><br>  Find the corresponding SLR cluster: <br><br><pre> <code class="plaintext hljs">$Cluster=Get-Cluster -Name $Configuration.VM.SLA</code> </pre> <br><br>  Check that we have enough space on the Datastore: <br><br><pre> <code class="plaintext hljs">$DatastoreCluster = Get-DatastoreCluster |Where-Object {$_.Name -like $Datastore1Name} $Datastore1 = Get-Datastore -Location $DatastoreCluster |sort -Property "FreeSpaceGB" |select -Last 1 IF ($Datastore1.FreeSpaceGB -le "200"){ Write-Host -foreground red "STOP: Not enough datastore capacity for DISK" $vdisk.Id Break }</code> </pre><br><br>  And enough memory: <br><br><pre> <code class="plaintext hljs">$VMHost = Get-VMHost -Location $Cluster |sort -Property "MemoryUsageGB" |select -First 1 IF ($VMHost.MemoryUsageGB -le "20"){ Write-Host -foreground red "STOP: No enough ESXi host capacity" Break }</code> </pre><br><br>  We take our template <br><br><pre> <code class="plaintext hljs">$VMTemplate = Get-Template -Name 'Win2016_Std_x64_Template'</code> </pre> <br><br>  And create a new virtual machine <br><br><pre> <code class="plaintext hljs">New-VM -Name $Configuration.Hostname.ToUpper() -VMHost $VMHost -ResourcePool $ResourcePool -Datastore $Datastore -Template $VMTemplate -Location "AutoDeployed VMs"</code> </pre> <br><br>  It is important to connect the network interface to a subnet with DHCP enabled. <br><br>  We start the virtual machine <br><br><pre> <code class="plaintext hljs">Start-VM $VM</code> </pre> <br><br>  And save the description of the machine, so that you can then determine the machine at the VMWare level. <br><br><pre> <code class="plaintext hljs">Set-Annotation -Entity $VM -CustomAttribute "Change request" -Value $Configuration.Request -Confirm:$false Set-VM $VM -Notes $Configuration.Description -Confirm:$false</code> </pre><br><br>  The machine has started and now we can find out the received MAC address: <br><br><pre> <code class="plaintext hljs">$vMAC = (($VM | Get-NetworkAdapter | Select-Object -Property "MacAddress").MacAddress).Replace(':','')</code> </pre> <br><br>  Save this value to our JSON file <br><br><pre> <code class="plaintext hljs">$Configuration.Network.MAC=$VMAC ConvertTo-Json -InputObject $Configuration -Depth 100 | Out-File "C:\Configs\TargetNodes\Build\$Hostname.json" -Force</code> </pre><br><br>  Here is the time to commit to our Git, that the machine is created and has its own unique MAC. <br><br>  The machine starts to initialize (after sysprep), tune the hardware and initial configuration. <br><br>  Let's wait for our WinRM machine to be available with the EstablishConnection.ps1 script. <br><br>  First, find out what IP the machine received from DHCP: <br><br><pre> <code class="plaintext hljs"># $MAC = $vMAC while($isOnline -ne $true){ if((Get-DhcpServerv4Lease -ClientId $MAC -ScopeId $StagingDHCPScope -ComputerName $DHCPServer -ErrorAction Ignore).IPAddress.IPAddressToString){ $tempIP=(Get-DhcpServerv4Lease -ClientId $MAC -ScopeId $StagingDHCPScope -ComputerName $DHCPServer).IPAddress.IPAddressToString break } else{ if($isOnline -ne $true){ Write-Host "`r$i`t" -NoNewline $i++ } } }</code> </pre><br><br>  Now let's wait until the machine is available via WinRM: <br><br><pre> <code class="plaintext hljs">$LocalAdmin = Get-StoredCredential -Type Generic -Target LocalAdmin $i=0 $isOnline=$false while($isOnline -ne $true){ if(Invoke-Command -ComputerName $tempIP -ScriptBlock{ Get-ItemProperty -Path "Registry::\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing" } -Credential $LocalAdmin -ErrorAction SilentlyContinue){ $isOnline=$true break } else{ if($isOnline -ne $true){ Write-Host "`r$i" -NoNewline $i++ Start-Sleep -Seconds 1 } } }</code> </pre><br><br>  The machine is ready to drive. <br><br><h3>  Desired State Configuration <br></h3><br>  To configure the desired configuration, we use the PowerShell part - DSC (Desired State Configuration).  The network has a configured DSC Pull Server: dscpull.testdomain.eu. <br>  Below is the configuration of our DSC Pull Server.  <a href="https://docs.microsoft.com/ru-ru/powershell/dsc/pullserver">Good article on setting up DSC Pull.</a> <br><br><pre> <code class="plaintext hljs">Node $NodeName { WindowsFeature DSCServiceFeature { Ensure = "Present" Name = "DSC-Service" } xDscWebService PSDSCPullServer { Ensure = "Present" EndpointName = "PSDSCPullServer" Port = 8080 PhysicalPath = "$env:SystemDrive\inetpub\PSDSCPullServer" CertificateThumbPrint = $certificateThumbPrint ModulePath = "$env:PROGRAMFILES\WindowsPowerShell\DscService\Modules" ConfigurationPath = "$env:PROGRAMFILES\WindowsPowerShell\DscService\Configuration" State = "Started" DependsOn = "[WindowsFeature]DSCServiceFeature" RegistrationKeyPath = "$env:PROGRAMFILES\WindowsPowerShell\DscService" AcceptSelfSignedCertificates = $true UseSecurityBestPractices = $true } File RegistrationKeyFile { Ensure = 'Present' Type = 'File' DestinationPath = "$env:ProgramFiles\WindowsPowerShell\DscService\RegistrationKeys.txt" Contents = $RegistrationKey } }</code> </pre><br><br>  It is available at: <a href="https://dscpull.testdomain.eu:8080/">https://dscpull.testdomain.eu:8080</a> <br><br>  His endpoint: <a href="">https://dscpull.testdomain.eu:8080/PSDSCPullserver.svc</a> <br><br>  PowerShell 5.1 must be installed on all client pull servers <br>  If non-PowerShell 5.1 is installed: <br><br><pre> <code class="plaintext hljs">$PSVersionTable.PSVersion.Major ‚Äìlt 5</code> </pre> <br><br>  Install PowerShell 5.1: <br><br><pre> <code class="plaintext hljs">Write-Host "Download PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock { [System.Net.ServicePointManager]::SecurityProtocol=[System.Net.SecurityProtocolType]::Tls12;Invoke-WebRequest -Uri "https://dscpull.testdomain.eu:8080/Files/Updates/WMF.msu" -OutFile C:\TEMP\WMF.MSU } Write-Host "Extract PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock {Start-Process -FilePath 'wusa.exe' -ArgumentList "C:\temp\WMF.msu /extract:C:\temp\" -Wait -PassThru } Write-Host "Apply PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock {Start-Process -FilePath 'dism.exe' -ArgumentList "/online /add-package /PackagePath:C:\temp\WindowsBlue-KB3191564-x64.cab /Quiet" -Wait -PassThru } Write-Host "PowerShell 5.1 has been installed"</code> </pre><br><br>  A PKI server is also deployed in our network.  This is a condition for securely encrypting credentials stored in DSC mof files (Mof files are the ‚Äúlanguage‚Äù in which the Pull Server and its clients communicate).  When a client tries to register with the Pull Server, you must specify the Thumbprint certificate and later the Pull Server will use this certificate to encrypt passwords.  Below we look at how this works. <br><br>  We import Root CA to our new machine: <br><br><pre> <code class="plaintext hljs"> Invoke-Command -ComputerName $server -ScriptBlock{ $PKI="-----BEGIN CERTIFICATE----- MIIF2TCCA8GgAwIBAgIQSPIjcff9rotNdxbg3+ygqDANBgkqhkiG9w0BAQUFADAe **************************************************************** znafMvVx0B4tGEz2PFss/FviGdC3RohBHG0rF5jO50J4nS/3cGGm+HGdn1w/tZd0 a0FWpn9VCOSmXM2It+tSW1f4nZVt6T2kr1ZlTxkDhT7HMSGsrX/XJswzCkDGe3dE qrVVjNUkhVTaeeBWdujB5J6mcx7YkNsAUhODiS9Cf7FnYnxLFA72M0pijI48P5F0 ShM9HWAAUIrLkv13ug== -----END CERTIFICATE-----" $PKI | Out-File RootCA.cer Import-Certificate RootCA.cer -CertStoreLocation Cert:\LocalMachine\Root | select Thumbprint | Out-Null } -Credential $LocalAdmin | Out-Null</code> </pre><br><br>  For further work, we need a pair of RSA-keys.  <a href="https://gallery.technet.microsoft.com/scriptcenter/Self-signed-certificate-5920a7c6">We will generate a self-signed certificate</a> and will temporarily work with it. <br><br>  Now we can register on the Pull Server: <br><br><pre> <code class="plaintext hljs">$DscHostFQDN = [System.Net.Dns]::GetHostEntry([string]$env:computername).HostName $DscPullServerURL = "https://$($DscHostFQDN):8080/PSDSCPullserver.svc" $DscWebConfigChildPath = '\inetpub\psdscpullserver\web.config' $DscWebConfigPath = Join-Path -Path $env:SystemDrive -ChildPath $DscWebConfigChildPath $DscWebConfigXML = [xml](Get-Content $DscWebConfigPath) $DscRegKeyName = 'RegistrationKeys.txt' $DscRegKeyXMLNode = "//appSettings/add[@key = 'RegistrationKeyPath']" $DscRegKeyParentPath = ($DscWebConfigXML.SelectNodes($DscRegKeyXMLNode)).value $DscRegKeyPath = Join-Path -Path $DscRegKeyParentPath -ChildPath $DscRegKeyName $DscRegKey = Get-Content $DscRegKeyPath [DSCLocalConfigurationManager()] configuration RegisterOnPull { Node $Node { Settings { ConfigurationModeFrequencyMins = 1440 CertificateID = $Thumbprint RefreshMode ='Pull' RefreshFrequencyMins = 1440 RebootNodeIfNeeded = $true ConfigurationMode ='ApplyAndAutoCorrect' AllowModuleOverwrite = $true DebugMode = 'None' StatusRetentionTimeInDays = 1 } ConfigurationRepositoryWeb $([string]$env:computername) { ServerURL = $DscPullServerURL RegistrationKey = $DscRegKey CertificateID = $Thumbprint ConfigurationNames = @("$hostx") } } } RegisterOnPull -OutputPath $MetaConfigsStorage Set-DscLocalConfigurationManager -ComputerName $Node -Path $MetaConfigsStorage -Verbose -Force -Credential $LocalAdmin</code> </pre><br><br>  Send the first configuration to our machine <br><br><pre> <code class="plaintext hljs">Configuration Rename { param ( [Parameter()] [System.String[]] $Node, $hostname ) Import-DscResource -ModuleName xComputerManagement Import-DscResource ‚ÄìModuleName PSDesiredStateConfiguration Node $Node { xComputer JoinDomain { Name = $hostname } } } Rename -Node $Node -OutputPath $DscConfigPath -hostname $hostname New-DscChecksum $DscConfigPath -Force Invoke-Command -ComputerName $Node -ScriptBlock{Update-DscConfiguration -Verbose -Wait } -Credential $LocalAdmin -Verbose</code> </pre><br><br>  The server is automatically renamed and rebooted.  Now we can perform the Join Domain. <br><br><pre> <code class="plaintext hljs">Configuration JoinAD { param ( [Parameter()] [System.String[]] $Node, [Parameter(Mandatory = $true)] [ValidateNotNullorEmpty()] [System.Management.Automation.PSCredential] $DomainAdmin, $hostname, $domain ) Import-DscResource -ModuleName xComputerManagement Import-DscResource ‚ÄìModuleName PSDesiredStateConfiguration Node $Node { xComputer JoinDomain { Name = $hostname DomainName = $domain Credential = $DomainAdmin JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu" } GroupSet LocalAdmins { GroupName = @( 'Administrators') Ensure = 'Present' MembersToInclude = @( 'testdomain-eu\dscstaging' ) } } } $cd = @{ AllNodes = @( @{ NodeName = $Node PSDscAllowPlainTextPassword = $false PSDscAllowDomainUser=$true Certificatefile = $CertFile Thumbprint = $Certificate.ToString() } ) } JoinAD -Node $Node -OutputPath $DscConfigPath -DomainAdmin $DomainAdmin -hostname $hostname -ConfigurationData $cd -domain $domain New-DscChecksum $DscConfigPath -Force Invoke-Command -ComputerName $Node -ScriptBlock{Update-DscConfiguration -Verbose -Wait } -Credential $LocalAdmin -Verbose</code> </pre><br><br>  Here‚Äôs what our mof file looks like: <br><br><pre> <code class="plaintext hljs">instance of MSFT_Credential as $MSFT_Credential1ref { Password = "-----BEGIN CMS-----\nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H\nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO+BEyD2cr6vKHdn\nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT+GX4IkPezR\nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp+VQCx2ljlwif6ac4X/PqG\n-----END CMS-----"; UserName = "testdomain.eu\\service_DomainJoin_001"; }; instance of MSFT_xComputer as $MSFT_xComputer1ref { ResourceID = "[xComputer]JoinDomain"; Credential = $MSFT_Credential1ref; DomainName = "testdomain.eu"; SourceInfo = "C:\\Program Files\\WindowsPowerShell\\Scripts\\JoinAD.ps1::34::9::xComputer"; Name = "dsctest51"; JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu"; ModuleName = "xComputerManagement"; ModuleVersion = "4.1.0.0"; ConfigurationName = "JoinAD"; };</code> nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H \ nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO + BEyD2cr6vKHdn \ nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT + GX4IkPezR \ nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp + VQCx2ljlwif6ac4X / PqG \ n ----- END CMS -----"; <code class="plaintext hljs">instance of MSFT_Credential as $MSFT_Credential1ref { Password = "-----BEGIN CMS-----\nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H\nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO+BEyD2cr6vKHdn\nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT+GX4IkPezR\nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp+VQCx2ljlwif6ac4X/PqG\n-----END CMS-----"; UserName = "testdomain.eu\\service_DomainJoin_001"; }; instance of MSFT_xComputer as $MSFT_xComputer1ref { ResourceID = "[xComputer]JoinDomain"; Credential = $MSFT_Credential1ref; DomainName = "testdomain.eu"; SourceInfo = "C:\\Program Files\\WindowsPowerShell\\Scripts\\JoinAD.ps1::34::9::xComputer"; Name = "dsctest51"; JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu"; ModuleName = "xComputerManagement"; ModuleVersion = "4.1.0.0"; ConfigurationName = "JoinAD"; };</code> </pre><br><br>  DSC encrypted credentials from the service account with Domain Admin rights: testdomain.eu \\ service_DomainJoin_001 with a self-signed certificate.  The DSC Client decrypts its credentials with its Private Key and applies all configuration modules with the specified domain credentials.  In this case, performs a Domain Join to the specified organization unit. <br><br><pre> <code class="plaintext hljs">GroupSet LocalAdmins { GroupName = @( 'Administrators') Ensure = 'Present' MembersToInclude = @( testdomain-eu\dscstaging' ) }</code> </pre><br><br>  This module adds dscstaging to local administrators for further configuration. <br><br>  After the reboot, we can log into the machine with domain credentials. <br><br>  We are waiting for the server to receive a certificate from our PKI (we have configured auto enrollment) and in the future we will work with the certificate issued by our PKI. <br><br><pre> <code class="plaintext hljs">$vmcert=Invoke-Command -ComputerName $server -ScriptBlock{ return Get-ChildItem -Path cert:\LocalMachine\My | where {$_.EnhancedKeyUsageList.FriendlyName -eq "Document Encryption"-and $_.Issuer -eq "CN=TestDomain Issuing CA, DC=testdomain, DC=eu"} } -ErrorAction Ignore</code> </pre> <br><br>  Now you will register again on the Pull Server with the updated thumbprint. <br><br>  Everything, the domain-joined machine, and we can use it as it is convenient for us. <br><br><h3>  Installing SQL Server <br></h3><br>  The JSON file describes the requirements for MS SQL Server, and we also use DSC to install and configure SQL Server.  Here is the configuration: <br><br><pre> <code class="plaintext hljs">Configuration $Node{ WindowsFeature "NetFramework35"{ Name = "NET-Framework-Core" Ensure = "Present" Source = "\\$DscHostFQDN\Files\Updates" } WindowsFeature "NetFramework45"{ Name = "NET-Framework-45-Core" Ensure= "Present" } SqlSetup "MSSQL2012NamedInstance"{ InstanceName = $MSSQL.InstanceName Features = $MSSQL.Features ProductKey = $ProductKey SQLCollation = $MSSQL.Collation SQLSysAdminAccounts = @('testdomain-EU\SQLAdmins',' testdomain-EU\Backup') InstallSharedDir = "C:\Program Files\Microsoft SQL Server" InstallSharedWOWDir = "C:\Program Files (x86)\Microsoft SQL Server" InstallSQLDataDir = $MSSQL.DataRoot SQLUserDBDir = $MSSQL.UserDBDir SQLUserDBLogDir = $MSSQL.UserLogDir SQLTempDBDir = $MSSQL.TempDBDir SQLTempDBLogDir = $MSSQL.TempDBLogDir SQLBackupDir = $MSSQL.BackupDir SourcePath = $SQLSource SAPwd = $SA SecurityMode = 'SQL' UpdateSource = ".\Updates" Action = "Install" ForceReboot = $True SQLSvcAccount = $SqlServiceCredential AgtSvcAccount = $SqlServiceCredential ISSvcAccount = $SqlServiceCredential BrowserSvcStartupType = "Automatic" DependsOn = '[WindowsFeature]NetFramework35', '[WindowsFeature]NetFramework45' }</code> </pre><br>  Where $ MSSQL is defined: <br><pre> <code class="plaintext hljs">$MSSQL=$Configuration.Applications | where {$_.Application -eq "Microsoft SQL Server 2012"}</code> </pre> <br><br>  $ MSSQL.InstanceName - all this is indicated in our Json file.  Applying this configuration will install MS SQL Server with all updates in the Updates folder and restart the server if necessary. <br><br>  The machine is ready. <br><br><h2>  Service-Now </h2><br>  There <a href="https://docs.servicenow.com/bundle/london-application-development/page/build/applications/reference/api-script-landing-page.html">are several APIs available</a> in Service-Now.  We use Rest API. <br>  To get the list of machines with Allocated status, use the following query: <br>  <a href="https://instance.service-now.com/cmdb_ci_server_list.do%3Fsysparm_query%3Dinstall_status%3D16">instance.service-now.com/cmdb_ci_server_list.do?sysparm_query=install_status=16</a> ^ u_subtype = ^ ORDERBYname <br>  In PowerShell, it looks like this: <br><pre> <code class="plaintext hljs">$url="https://instance.service-now.com/api/now/table/cmdb_ci_server?sysparm_query=install_status=16^u_subtype=^ORDERBYname" $uri= new-object System.Uri("https://instance.service-now.com/") #       $credentials = (Get-StoredCredential -Type Generic -Target DSC).GetNetworkCredential() $credentials = new-object System.Net.NetworkCredential $credentials.UserName, $credentials.SecurePassword Add-Type -AssemblyName System.Net.Http $handler = New-Object System.Net.Http.HttpClientHandler $handler.CookieContainer = New-Object System.Net.CookieContainer $handler.UseCookies=$true $handler.Credentials=$credentials $HttpClient = New-Object System.Net.Http.HttpClient($handler) $HttpClient.BaseAddress= $uri $Header = New-Object System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json") $HttpClient.DefaultRequestHeaders.Accept.Clear() $HttpClient.DefaultRequestHeaders.Accept.Add($Header); $response=$HttpClient.GetAsync($url) $respStream=$response.Result.Content.ReadAsStringAsync() $Servers = $respStream.Result | ConvertFrom-Json #   Configuration Items  $ServersCI=$Servers.result</code> </pre> <br>  The first array object is the hostname we need. <br>  If the machine is ready, you can change the status of the machine in Service-Now, for this the UpdateCI.ps1 script: <br><pre> <code class="plaintext hljs">param( $CI, [ValidateSet("Allocated","In use","Pending install")] $NewStatus='In use' ) $url="https://instance.service-now.com/api/now/table/cmdb_ci_server?sysparm_query=name=$CI" $uri= new-object System.Uri("https://instance.service-now.com/") $credentials = (Get-StoredCredential -Type Generic -Target DSC).GetNetworkCredential() $credentials = new-object System.Net.NetworkCredential $credentials.UserName, $credentials.SecurePassword Add-Type -AssemblyName System.Net.Http $handler = New-Object System.Net.Http.HttpClientHandler $handler.CookieContainer = New-Object System.Net.CookieContainer $handler.UseCookies=$true $handler.Credentials=$credentials $HttpClient = New-Object System.Net.Http.HttpClient($handler) $HttpClient.BaseAddress= $uri $Header = New-Object System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json") $HttpClient.DefaultRequestHeaders.Accept.Clear() $HttpClient.DefaultRequestHeaders.Accept.Add($Header); $response=$HttpClient.GetAsync($url) $respStream=$response.Result.Content.ReadAsStringAsync() $Servers = $respStream.Result | ConvertFrom-Json $ServerCI=$Servers.result[0] $update=@{} if($NewStatus -eq "In use"){ $update.install_status=1 } if($NewStatus -eq "Pending install"){ $update.install_status=4 } $stringcontent = New-Object System.Net.Http.StringContent((ConvertTo-Json -InputObject $update -Depth 100),[System.Text.Encoding]::UTF8, "application/json"); $result=$HttpClient.PutAsync("https://instance.service-now.com/api/now/table/cmdb_ci_server/$($ServerCI.sys_id)", $stringcontent)</code> </pre> <br>  To get the table and records, REST API GET requests are used, to change the PUT / POST request record, in the body of which the fields to be changed. <br><br>  <i>We have created a convenient tool with a graphical tool similar to Azure Portal, which allows you to manage on-premises infrastructure as convenient as possible for us and our customer.</i> <br>  PS 12/24/2018.  It all seems outdated?  Time to use Azure DevOps.  In the next article I will tell you how to do all this using the Azure DevOps pipelines </div><p>Source: <a href="https://habr.com/ru/post/425129/">https://habr.com/ru/post/425129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425113/index.html">‚ÄúDigital typography‚Äù or my experience in mobile book digitization</a></li>
<li><a href="../425115/index.html">Full-blown DevOps: Greek tragedy in three acts</a></li>
<li><a href="../425117/index.html">Two bits per transistor: Intel 8087 floating point high density ROM</a></li>
<li><a href="../425123/index.html">Mysterious heart of the drum machine Roland TR-808</a></li>
<li><a href="../425125/index.html">Selection @pythonetc, September 2018</a></li>
<li><a href="../425131/index.html">What to read about blockchain technologies: manuals, books and articles</a></li>
<li><a href="../425133/index.html">Problems of cross-border payments - why and how blockchains are used here</a></li>
<li><a href="../425135/index.html">Why VoIP was recognized as an information service in the USA, and what it means for the telecom industry and users</a></li>
<li><a href="../425137/index.html">We work in the console quickly and efficiently</a></li>
<li><a href="../425139/index.html">Pop stars under the lens of artificial intelligence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>