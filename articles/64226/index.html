<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Boost is easy. Part 1. Boost.Regex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is the first in a series of articles that I am going to devote, probably the best, to the C ++ library. 
 This article addresses the foll...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Boost is easy. Part 1. Boost.Regex</h1><div class="post__text post__text-html js-mediator-article">  This article is the first in a series of articles that I am going to devote, probably the best, to the C ++ library. <br>  This article addresses the following questions regarding regular expressions: <br><ul><li>  regex_match </li><li>  regex_search </li><li>  regex_replace </li><li>  regex_iterator </li><li>  regex_token_iterator </li><li>  Partial match </li></ul><br><a name="habracut"></a><br><h1>  Introduction </h1><br>  I do not want to engage in controversy about the need or non-use of regular expressions, everyone decides for himself.  My goal was to convey the ease of use of Boost.Regex for those who like to use regular expressions.  For those who are not familiar with regular expressions, I advise you to read at least <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D1%258B%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">Wikipedia</a> , and if someone wants to get acquainted with them more deeply, then I would advise <a href="http://www.amazon.com/Mastering-Regular-Expressions-Jeffrey-Friedl/dp/0596528124/ref%3Dsr_1_1%3Fie%3DUTF8%26s%3Dbooks%26qid%3D1247388556%26sr%3D8-1">Mastering regular expressions</a> . <br>  Boost.Regex is a compiled library, that is, to use it you need to build it.  How to do this is written in <a href="http://www.boost.org/doc/libs/1_39_0/more/getting_started/index.html">Getting started</a> . <br>  When compiling libraries, you can choose one of two algorithms that will be used in the regulatory expression engine: recursive and non-recursive.  The first one is fast, but can threaten with stack overflow, the second is a bit slower, but safe.  Macros for defining different BOOST_REGEX_RECURSIVE and BOOST_REGEX_NON_RECURSIVE methods, respectively.  Also, each algorithm can be slightly configured.  Macros for setting and their description can be found <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/configuration/tuning.html">here.</a> <br>  Boost.Regex supports the following syntax types for regular expressions: <br><ol><li>  <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html">Perl (default)</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/syntax/basic_extended.html">Posix extended</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/syntax/basic_syntax.html">POSIX Basic</a> </li></ol><br>  Note that the '.' (Dot) by default includes '\ n'.  This can be changed by passing a special flag to the appropriate algorithm. <br><br><h1>  Basic algorithms </h1><br><h2>  <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/ref/regex_match.html">boost :: regex_match</a> </h2><br>  This algorithm is used to check the correspondence of the incoming string and some regular expression, returning true If the string matches and false otherwise. <br>  Typical usage: <strong>regex_match (incoming_line, [matches_find_cards], regular_expression, [flags])</strong> . <br>  For a complete list of all overloaded ads, see the documentation. <br>  An example of its use: <br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">std:: <font color="#0000ff">string</font> xStr( <font color="#A31515">"AAAA-12222-BBBBB-44455"</font> ); <br> boost::regex xRegEx( <font color="#A31515">"(\\w+)-(\\d+)-(\\w+)-(\\d+)"</font> ); <br> boost::smatch xResults; <br> std::cout &lt;&lt; <font color="#A31515">"==========================Results============================== \n"</font> ; <br> std::cout &lt;&lt; <font color="#A31515">"Does this line match our needs? "</font> &lt;&lt; std::boolalpha &lt;&lt; boost::regex_match(xStr,  xResults, xRegEx) &lt;&lt; <font color="#A31515">"\n"</font> ; <br> std::cout &lt;&lt; <font color="#A31515">"Print entire match:\n "</font> &lt;&lt; xResults[0] &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"Print the former string into another format:\n"</font> &lt;&lt; xResults[1] &lt;&lt; <font color="#A31515">"+"</font> <br> &lt;&lt; xResults[2] &lt;&lt; <font color="#A31515">"+"</font> <br> &lt;&lt; xResults[3] &lt;&lt; <font color="#A31515">"+"</font> <br> &lt;&lt; xResults[4] &lt;&lt; std::endl;</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  The result of the work will be: <br><blockquote>  ========================== Results ====================== ======= <br>  Does this line match our needs?  true <br>  Print entire match: <br>  AAAA-12222-BBBBB-44455 <br>  Print the former string into another format: <br>  AAAA + 12222 + BBBBB + 44455 <br></blockquote><br><h4>  A small deviation from the algorithm to describe its parameters.  These parameters are used in all algorithms, but we consider them only here. </h4><br>  <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/ref/match_results.html">results_of_consistencies</a> - is an optional parameter and is nothing but an object of the class <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/ref/match_results.html">match_results</a> .  This object is an array of objects of the <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/ref/sub_match.html">sub_match</a> class, which, in turn, is nothing more than the custodial object of the iterators at the beginning and end of the found match in the string.  <strong>results_of_consistencies</strong> serves to save the results of the algorithm.  So, if the algorithm was successfully executed, then the zero member of the array will store sub_match for the whole match (the exception is using partial match, but more on that later).  Each subsequent array member will store iterators for each capture contained in the regular expression.  Each array element can be checked for content through the matched flag.  It is important to remember that each sub_match stores iterators on <strong>incoming_string</strong> , so you cannot pass a temporary object as the source line and use the results of the algorithm in the future, at best, get assert in debug, at worst undefined behavior with a headache.  For recursive captures in a regular expression (for example, "(\ w) +")), only the last capture will fall into the resulting match_result, this is the default behavior that can be changed.  In order for us to access all recursive captures, we must pass the match_extra flag to [flags], but that‚Äôs not all, in order for match_extra to work, we need to declare the default BOOST_REGEX_MATCH_EXTRA in all translated units.  Or just uncomment the define in boost / regex / user.hpp.  This functionality is labeled as experimental and greatly reduces performance.  I didn‚Äôt manage to try it, because my VS2008 issues an Access violation in the xutulity depth when trying to use regex_ * algorithms with uncommented define.  An untested example of its use: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">std:: <font color="#0000ff">string</font> xStr( <font color="#A31515">"The boost library has a great opportunity for the regex!"</font> ); <br> boost::regex xRegEx( <font color="#A31515">"(\\b\\w{5}\\b)*"</font> ); <br> boost::smatch xResults; <br> std::cout &lt;&lt; <font color="#A31515">"==========================Results============================== \n"</font> ; <br> <font color="#0000ff">if</font> ( boost::regex_search(xStr, xResults, xRegEx, boost::match_extra) ) <br> { <br> std::cout &lt;&lt; <font color="#A31515">"Words consist from exact 5 digits have been found in our line:\n"</font> ; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> j = 0; j &lt; xResults.captures(1).size(); ++j) <br> std::cout &lt;&lt; xResults.captures(1)[j] &lt;&lt; std::endl; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  <strong>[Flags]</strong> is an optional parameter with the default match_default value.  About available flags, you can see <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/ref/match_flag_type.html">here</a> .  Flags are combined using '|' (or). <br><br><h4>  Partial match </h4><br>  Partial matching is necessary for checking the input string, for partial matching the regular expression.  This can be useful when validating incoming data asynchronously or with large amounts of data, that is, in cases where at a particular point in time there is no possibility to draw a full correspondence between a regular expression and the original string.  To use partial match, you must pass the match_partial flag to [flags].  In this case, if a partial match is used, the algorithm used (regex_match, regex_search, etc.) returns true, but the matched flag of the zero element match_results will be set to false.  What was found as a result of a partial match can be obtained through the same zero element. <br>  Example of use: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">std:: <font color="#0000ff">string</font> xStr( <font color="#A31515">"AAAA-12222"</font> ); <br> boost::regex xRegEx( <font color="#A31515">"(\\w+)-(\\d+)-(\\w+)-(\\d+)"</font> ); <br> boost::smatch xResults; <br> std::cout &lt;&lt; <font color="#A31515">"==========================Results============================== \n"</font> ; <br> std::cout &lt;&lt; <font color="#A31515">"Does this line match the regex? "</font> &lt;&lt; std::boolalpha &lt;&lt; boost::regex_match(xStr, xResults, xRegEx, <br> boost::match_default | boost::match_partial) &lt;&lt; <font color="#A31515">"\n"</font> ; <br> std::cout &lt;&lt; <font color="#A31515">"Is it the partial match? "</font> &lt;&lt; std::boolalpha &lt;&lt;  !xResults[0].matched &lt;&lt; <font color="#A31515">"\nPrint the partial match:\n"</font> &lt;&lt; xResults[0] &lt;&lt; std::endl;</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Conclusion: <br><blockquote>  ========================== Results ====================== ======= <br>  Does this line match the regex?  true <br>  Is it a partial match?  true <br>  Print the partial match: <br>  AAAA-12222 <br></blockquote><br><h2>  <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/ref/regex_search.html">regex_search</a> </h2><br>  This algorithm is designed to search for a substring in the source string, by a given regular expression. <br>  The usage format is as follows: <br>  <strong>regex_search (incoming_line, [match_find_lear_count], regular_expression, [flags])</strong> . <br>  Example of use: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">std:: <font color="#0000ff">string</font> xStr( <font color="#A31515">"The boost library has a great opportunity for the regex!"</font> ); <br> boost::regex xRegEx( <font color="#A31515">"\\b(?:\\w+?)((\\w)\\2)(?:\\w+?)\\b"</font> ); <br> boost::smatch xResults; <br> std::cout &lt;&lt; <font color="#A31515">"==========================Results============================== \n"</font> ; <br> std:: <font color="#0000ff">string</font> ::const_iterator xItStart = xStr.begin(); <br> std:: <font color="#0000ff">string</font> ::const_iterator xItEnd = xStr.end(); <br> <font color="#0000ff">while</font> ( boost::regex_search(xItStart, xItEnd, xResults, xRegEx) ) <br> { <br> std::cout &lt;&lt; <font color="#A31515">"Word, we've searched, is \""</font> &lt;&lt; xResults[0] &lt;&lt; <font color="#A31515">"\". It has two \""</font> &lt;&lt; xResults[2] &lt;&lt; <font color="#A31515">"\" inside itself.\n"</font> ; <br> xItStart = xResults[1].second; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Conclusion: <br><blockquote>  ========================== Results ====================== ======= <br>  Word, we've searched, is a "boost."  It has two "o" inside itself. <br>  Word, we've searched, is ‚Äúopportunity.‚Äù  It has two "p" inside itself. </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/ref/regex_replace.html">regex_replace</a> </h2><br>  The algorithm is used to replace all occurrences of substrings corresponding to a regular expression with a string specified in a specific format.  The result can be obtained through an iterator, passed as an argument or as a return string.  Parts of the timeline that do not match the regular expression are copied to the output line unchanged, unless the <strong>format_no_copy</strong> flag is <strong>set</strong> , which leaves only broken lines in the result.  When the format_first_only flag is passed, only the first substring corresponding to the regular expression is replaced. <br>  Typically used format: <br>  <strong>regex_replace (incoming_string, regular_expression, format_string, [flags])</strong> . <br>  <strong>format</strong> string defines the string to which the found substring will be replaced. <br>  She can obey one of the following syntax rules: <br><ul><li>  <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/format/sed_format.html">sed</a> flag: format_sed </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/format/perl_format.html">Perl (default)</a> flag: format_perl </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/format/boost_format_syntax.html">Boost-extended</a> flag: format_all </li><li>  Literal, that is, does not use any special characters.  Flag: format_literal </li></ul><br>  Example of use: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">std:: <font color="#0000ff">string</font> xStr( <font color="#A31515">"AAAA-12222-BBBBB-44455"</font> ); <br> boost::regex xRegEx( <font color="#A31515">"(\\w+)-(\\d+)-(\\w+)-(\\d+)"</font> ); <br> std:: <font color="#0000ff">string</font> xFormatString( <font color="#A31515">"$1*$2*$3*$4"</font> ); <br> boost::smatch xResults; <br> std::cout &lt;&lt; <font color="#A31515">"==========================Results============================== \n"</font> ; <br> std::cout &lt;&lt; <font color="#A31515">"Print string after replace:\n "</font> &lt;&lt; boost::regex_replace(xStr, xRegEx, xFormatString, boost::match_default | boost::format_perl) &lt;&lt; std::endl; <br></font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Conclusion: <br><blockquote>  ========================== Results ====================== ======= <br>  Print string after replace: <br>  AAAA * 12222 * BBBBB * 44455 <br></blockquote><br><br><h1>  Auxiliary means </h1><br><h2>  <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/ref/regex_iterator.html">regex_iterator</a> </h2><br>  This iterator can be convenient for sequential search of occurrences of a substring corresponding to a regular expression.  For each increment, the next substring is found using regex_search.  When dereferencing an iterator, we get an object of the type match_results, with which we can get all the necessary information. <br>  Usage format: <strong>regex_iterator (start_iterator, end_iterator, regular_expression)</strong> <br>  Example of use: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">std:: <font color="#0000ff">string</font> xStr( <font color="#A31515">"AAAA-12222-BBBBB-44455"</font> ); <br> boost::regex xRegEx( <font color="#A31515">"(\\w|\\d)+"</font> ); <br> boost::smatch xResults; <br> std::cout &lt;&lt; <font color="#A31515">"==========================Results============================== \n"</font> ; <br> boost::sregex_iterator xIt(xStr.begin(), xStr.end(), xRegEx); <br> boost::sregex_iterator xInvalidIt; <br> <font color="#0000ff">while</font> (xIt != xInvalidIt) <br> std::cout &lt;&lt; *xIt++ &lt;&lt; <font color="#A31515">"*"</font> ;</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Conclusion: <br><blockquote>  ========================== Results ====================== ======= <br>  AAAA * 12222 * BBBBB * 44455 * </blockquote><br><br><h2>  <a href="http://www.boost.org/doc/libs/1_39_0/libs/regex/doc/html/boost_regex/ref/regex_token_iterator.html">regex_token_iterator</a> </h2><br>  A very useful tool for splitting a string into tokens, <br>  Usage format: regex_token_iterator (start_iterator, end_iterator, regular_expression, [submatch]) <br>  <strong>[submatch] is</strong> used to specify how tokens should be interpreted in a string. <br>  When -1, the iterator returns the part of the sequence that does not match the regular expression.  That is, either the string that comes after the first match is returned before the start of the next match (not including the first character of the match).  Or, from the beginning of the line, if the beginning of the line does not satisfy the regular expression.  That is, by passing -1, the regular expression is the delimiter.  At 0, each offset of the iterator (++) gives the next part of the string that was ‚Äúzamatchena‚Äú, that is, each dereferenced iterator is a capture string.  For any positive number, as the parameter, the capture of the regular expression is chosen corresponding to the number passed as the parameter.  You can also pass an array of indices as a parameter, then the iterator will search for each capture according to the indices in the array, that is, if the array consists of {4, 2, 1}, then the initial iterator will point to 4 capture, the next iterator to 2 and etc.  The process will be repeated for the entire sequence until the matches for the given regular expression are completed.  By default, this parameter is 0. <br>  A dereferenced iterator is an object of class sub_match. <br>  Examples of using: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">std:: <font color="#0000ff">string</font> xStr( <font color="#A31515">"AAAA-12222-BBBBB-44455"</font> ); <br> boost::regex xRegEx( <font color="#A31515">"(\\w|\\d)+"</font> ); <br> boost::smatch xResults; <br> std::cout &lt;&lt; <font color="#A31515">"==========================Results============================== \n"</font> ; <br> boost::sregex_token_iterator xItFull(xStr.begin(), xStr.end(), xRegEx, 0); <br> boost::sregex_token_iterator xInvalidIt; <br> std::cout &lt;&lt; <font color="#A31515">"Result the same as the regex_iterator: \n"</font> ; <br> <font color="#0000ff">while</font> (xItFull != xInvalidIt) <br> std::cout &lt;&lt; *xItFull++ &lt;&lt; <font color="#A31515">"*"</font> ; <br> <font color="#008000">//Parts of captures</font> <br> boost::regex xRegEx2( <font color="#A31515">"(\\w+)-(\\d+)"</font> ); <br> boost::sregex_token_iterator xItFirstCapture(xStr.begin(), xStr.end(), xRegEx2, 1); <br> std::cout &lt;&lt; <font color="#A31515">"\nShow only first captures: \n"</font> ; <br> <font color="#0000ff">while</font> (xItFirstCapture != xInvalidIt) <br> std::cout &lt;&lt; *xItFirstCapture++ &lt;&lt; <font color="#A31515">"*"</font> ; <br> <font color="#008000">//Reverse order</font> <br> <font color="#0000ff">int</font> aIndices[] = {2,1}; <br> boost::sregex_token_iterator xItReverseCapture(xStr.begin(), xStr.end(), xRegEx2, aIndices); <br> std::cout &lt;&lt; <font color="#A31515">"\nShow captures in the reverse order: \n"</font> ; <br> <font color="#0000ff">while</font> (xItReverseCapture != xInvalidIt) <br> std::cout &lt;&lt; *xItReverseCapture++ &lt;&lt; <font color="#A31515">"*"</font> ; <br> <font color="#008000">//Delimiters</font> <br> boost::regex xRegEx3( <font color="#A31515">"(\\w|\\d)+"</font> ); <br> boost::sregex_token_iterator xItDelimiters(xStr.begin(), xStr.end(), xRegEx3, -1); <br> std::cout &lt;&lt; <font color="#A31515">"\nShow delimiters: \n"</font> ; <br> <font color="#0000ff">while</font> (xItDelimiters != xInvalidIt) <br> std::cout &lt;&lt; *xItDelimiters++ &lt;&lt; <font color="#A31515">" "</font> ;</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Conclusion: <br><blockquote>  ========================== Results ====================== ======= <br>  Result the same as the regex_iterator: <br>  AAAA * 12222 * BBBBB * 44455 * <br>  Show only first captures: <br>  AAAA * BBBBB * <br>  Show captures in the reverse order: <br>  12222 * AAAA * 44455 * BBBBB * <br>  Show delimiters: <br>  - - - </blockquote><br><h1>  Comment </h1><br>  Any algorithm can throw an exception of type std :: runtime_error if the complexity of checking the full matching (matching) N elements starts to exceed O (N ^ 2) or if the stack overflows (if Boost.Regex was built in recursive mode) <br><br></div><p>Source: <a href="https://habr.com/ru/post/64226/">https://habr.com/ru/post/64226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../64218/index.html">Backpack Charger</a></li>
<li><a href="../64220/index.html">Successful Twitter Recipe</a></li>
<li><a href="../64221/index.html">Usability of ATMs and express payment terminals</a></li>
<li><a href="../64223/index.html">OpenSource Electronic diaries system</a></li>
<li><a href="../64224/index.html">Setting VIM indents</a></li>
<li><a href="../64227/index.html">Photosounder: editing a sonogram</a></li>
<li><a href="../64229/index.html">Implementation of a small asynchronous server</a></li>
<li><a href="../6423/index.html">Let's stop writing +1</a></li>
<li><a href="../64230/index.html">iWallet - wallet with memory</a></li>
<li><a href="../64231/index.html">How to legalize iPhone, imported into Ukraine from abroad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>