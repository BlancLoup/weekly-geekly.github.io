<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell Polymorphia and Classes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear reader! 

 Today we will talk about polymorphism of functions and classes in Haskell, how to use them and what they are for. We all used t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell Polymorphia and Classes</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear reader! <br><br>  Today we will talk about polymorphism of functions and classes in Haskell, how to use them and what they are for.  We all used the method of polymorphism, for example, in the Java language.  And how can this be applied to Haskell?  Haskell is not an object-oriented language, but it still has classes.  Although classes in Haskell have some properties of object-oriented language classes, they are more abstracted and much more powerful.  Drawing a Java analogy further, classes in Haskell are nothing else as interfaces ‚Äî only function declarations are written to a class, and the implementations of these functions will be made later. <br>  I would like to express my gratitude to the user <a href="https://habrahabr.ru/users/darkus/" class="user_link">Darkus</a> for reading and correcting all the shortcomings and inaccuracies in the article, as well as for useful advice and assistance in writing. <br><a name="habracut"></a><br><br><h3>  Polymorphism of functions </h3><br>  In Haskell, there are two types of polymorphism - parametric and special (in English they call the term ‚Äúad hoc‚Äù, which comes from the Latin language). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Parametric </h4><br>  If you have ever programmed in Haskell, then you will certainly meet examples of parametric polymorphism in the functions <code>length, head, teal, curry, uncurry, map, filter, ...</code>  What unites all these functions?  Let's look at the implementation of some of them: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">length</span></span> :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> length [] = [] length (_:xs) = <span class="hljs-number"><span class="hljs-number">1</span></span> + length xs head :: [a] -&gt; a head (x:_) = x tail :: [a] -&gt; [a] tail (_:xs) = xs curry :: ((a,b) -&gt; c) -&gt; (a -&gt; b -&gt; c) curry fxy = f (x,y) uncurry :: (a -&gt; b -&gt; c) -&gt; ((a,b) -&gt; c) uncurry g (x,y) = gxy</code> </pre> <br><br>  The first three functions have an input parameter of type <code>a</code> , and <code>curry</code> and <code>uncurry</code> have <code>b</code> and <code>c</code> .  Instead of a specific data type ( <code>Int, Bool, Char,</code> ...), typing is used.  Java example: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span></span>{...}</code> </pre> <br><br>  Here, too, A is used - an unknown data type that will be determined at compile time.  Polymorphism is used when it is unknown what type of data the parameter will be, but the operations that are performed on it (the same with it) will be known. <br><br>  All identifiers of type variables in Haskell must begin with a small letter (for example, <code>a, abc, aA101</code> ), and all specific types (constructors) begin with a capital letter (for example, <code>String, Int, Node</code> ). <br><br>  The <code>a</code> parameter can take any type, be it Int, String, or even functions (for example, <code>length [f, g, h]</code> , where f, g, h are functions that have the same type).  It is worth noting that type <code>b</code> can also accept any type, including the type of parameter <code>a</code> . <br><br>  The type of the function in the GHCi interpreter (and in the Hugs) can always be found with the help of the command <code>:t</code> , for example: <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Main</span></span>&gt;:t length length :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span></code> </pre> <br><br><h4>  Ad hoc </h4><br>  A synonym for special polymorphism is the term "overloaded functions."  This is a weaker type of polymorphism than parametric.  Take for example the operator (function) of addition (+).  Expressions of this kind <br> <code>(+) 2 3 -&gt;&gt; 5</code> <br> <code>(+) 2.5 3.85 -&gt;&gt; 6.35</code> <br>  different from expressions <br> <code>(+) True False</code> <br> <code>(+) [1,2,3] [3,2,1]</code> <br>  by the fact that in the first case numerical values ‚Äã‚Äãwere used, and in the second values ‚Äã‚Äãof type Bool and [Int].  The addition operator is not defined for non-numeric types.  This is because this function is not of type. <br> <code>(+) :: a -&gt; a -&gt; a</code> <br>  and such <br>  <code>(+) :: Num a =&gt; a -&gt; a -&gt; a</code> .  That is, a restriction is imposed on the type of input (and output) data. <br><br>  The constraint imposed on type <code>a</code> : Num a says that type <code>a</code> must be an element of class Num.  Such type classes are very important in Haskell, as they add additional protection against programming errors, and can also reduce the amount of written code at times.  We will see this in the following example. <br><br>  The following types of binary trees are given: <br>  A binary tree that can store any type of data <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree1</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node1</span></span></span><span class="hljs-class"> a (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><br>  A binary tree that can hold two elements, and each branch ends in a ‚Äúleaf‚Äù with one element (not Nil): <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree2</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Leaf2</span></span></span><span class="hljs-class"> b | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node2</span></span></span><span class="hljs-class"> ab (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ab</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ab</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><br>  A binary tree that can store data of type String and also ends in a sheet: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree3</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Leaf3</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node3</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree3</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree3</span></span></span></span></code> </pre> <br><br>  And let's say there are two more kinds of lists: <br>  usual <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Lst</span></span></span><span class="hljs-class"> a = [a]</span></span></code> </pre> <br>  and type ‚Äúrope‚Äù <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rope</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Twisted</span></span></span><span class="hljs-class"> b (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rope</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ba</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><br>  Having all these data structures, I would like to write the <code>size</code> function, which, regardless of the data structure, would output either its depth (for trees), or length (for lists), or size - in one word.  A naive solution would be to write for each its own function: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sizeT1</span></span> :: <span class="hljs-type"><span class="hljs-type">Tree1</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-comment"><span class="hljs-comment">-- -  sizeT1 Nil = 0 sizeT1 (Node1 _ lr) = 1 + sizeT1 l + sizeT1 r sizeT2 :: (Tree2 ab) -&gt; Int -- -  sizeT2 (Leaf 2 _) = 1 sizeT2 (Node2 _ _ lr) = 2 + sizeT2 l + sizeT2 r sizeT3 :: Tree3 -&gt; Int --    String sizeT3 (Leaf3 m)= length m sizeT3 (Node mlr) = length m + sizeT3 l +sizeT3 r --   : sizeLst :: [a] -&gt; Int sizeLst = length sizeRope :: (Rope ab) -&gt; Int sizeRope Nil = 0 sizeRope (Twisted _ ls) = 1 + sizeRope ls</span></span></code> </pre> </div></div><br><br>  Now, if any other data structure appears, you will have to create a new function that will be suitable <b>only</b> for this structure.  And we would like one function to get the size of <i>any</i> data structure.  As the (+) function had a restriction with the class Num, so we need to make the restriction with the Size class, and for this we need to create it first: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Size</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> size :: a -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span></code> </pre> <br><br>  It remains only to make instances (instances) of this class for specific values ‚Äã‚Äãof <code>a</code> (= for specific data types): <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Size</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> size <span class="hljs-type"><span class="hljs-type">Nil</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> size (<span class="hljs-type"><span class="hljs-type">Node1</span></span> _ lr) = <span class="hljs-number"><span class="hljs-number">1</span></span> + size l + size r <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Size</span></span> (<span class="hljs-type"><span class="hljs-type">Tree2</span></span> ab) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> size (<span class="hljs-type"><span class="hljs-type">Leaf2</span></span> _) = <span class="hljs-number"><span class="hljs-number">1</span></span> size (<span class="hljs-type"><span class="hljs-type">Node2</span></span> _ _ lr) = <span class="hljs-number"><span class="hljs-number">2</span></span> + size l + size r <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Size</span></span> <span class="hljs-type"><span class="hljs-type">Tree3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> size (<span class="hljs-type"><span class="hljs-type">Leaf3</span></span> m) = length m size (<span class="hljs-type"><span class="hljs-type">Node3</span></span> mlr) = length m + size l + size r <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Size</span></span> [a] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> size = length <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Size</span></span> (<span class="hljs-type"><span class="hljs-type">Rope</span></span> ab) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> size <span class="hljs-type"><span class="hljs-type">Nil</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> size (<span class="hljs-type"><span class="hljs-type">Twisted</span></span> _ ls) = <span class="hljs-number"><span class="hljs-number">1</span></span> + size ls</code> </pre> <br><br>  Done!  Now if we write in GHCi <code>:t size</code> , we will see <code>size :: Size a =&gt; a -&gt; Int</code> .  We got what we wanted: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">size</span></span> <span class="hljs-type"><span class="hljs-type">Nil</span></span> -&gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> size (<span class="hljs-type"><span class="hljs-type">Node1</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span> (<span class="hljs-type"><span class="hljs-type">Node1</span></span> <span class="hljs-string"><span class="hljs-string">"bar"</span></span> <span class="hljs-type"><span class="hljs-type">Nil</span></span> <span class="hljs-type"><span class="hljs-type">Nil</span></span>) <span class="hljs-type"><span class="hljs-type">Nil</span></span>) -&gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> size (<span class="hljs-type"><span class="hljs-type">Leaf</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>) -&gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> size (<span class="hljs-type"><span class="hljs-type">Node3</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span> (<span class="hljs-type"><span class="hljs-type">Node3</span></span> <span class="hljs-string"><span class="hljs-string">"bar"</span></span> (<span class="hljs-type"><span class="hljs-type">Leaf3</span></span> <span class="hljs-string"><span class="hljs-string">"abc"</span></span>) (<span class="hljs-type"><span class="hljs-type">Leaf</span></span> <span class="hljs-string"><span class="hljs-string">"cba"</span></span>)) (<span class="hljs-type"><span class="hljs-type">Leaf</span></span> <span class="hljs-string"><span class="hljs-string">"tst"</span></span>)) -&gt;&gt; <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-comment"><span class="hljs-comment">--3*5 size [1..5] -&gt;&gt; 5 size (Rope 2 (Rope 'a' (Rope 5 Nil))) -&gt;&gt; 3</span></span></code> </pre> <br><br>  Each instance of the <code>Size</code> class implemented the size function, which is applicable only to values ‚Äã‚Äãof a certain type (= data structures).  In this case, this function, like other predefined operators (+), (*), (-), is overloaded. <br><br>  But there are also disadvantages to such a decision.  For example, we would like to know the number of items in the pair list, that is, <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">size</span></span> [(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>)] -&gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> size [('a','b'), ('c','d'), ('e','f')] -&gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  Obviously it would do the following: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Size</span></span></span><span class="hljs-class"> [(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">)] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> size = (*<span class="hljs-number"><span class="hljs-number">2</span></span>) . length</code> </pre> <br><br>  But here we have a problem, because of that we already have an instance for a regular list ( <code>instance Size [a] where</code> ), we can no longer use another definition, because, as mentioned earlier, type <code>a</code> can be any type, including <code>(b,c)</code> , that is.  <code>[a] == [(b,c)]</code> To solve this problem, you can use the Overlapping Instances (English overlapping ekzeplyary class).  This solution has its drawbacks (importing one of the modules can change the value of the program, can cause confusing errors, and so on). <br>  Now a little more about classes. <br><br><h3>  Classes </h3><br>  In the previous example, we passed the <code>Size</code> class, but the incomplete class declaration in Haskell: (tv = type variable): <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class"> tv </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span>    tv</code> </pre> <br><br>  Incomplete, because restrictions on <code>tv</code> can also be entered in the class declaration (for example, <code>tv</code> must be an element of the <code>Ord</code> class).  Signatures can be any number, but each of them must include (as an input and / or output parameter) the variable tv. <br>  Typical classes are collections of types for which special functions are defined.  Here are some (some of the most important) classes in Haskell: <br><ul><li>  <b>Eq</b> - class for the test for equality (inequality) of two data types (operations ==, / =) </li><li>  <b>Ord</b> - class for determining the order of types, that is, which element is larger, which is smaller (operations&gt;,&gt; =, &lt;, &lt;=, min, max ...) </li><li>  <b>Enum</b> - class for types whose values ‚Äã‚Äãcan be ‚Äúcounted‚Äù (for example, [1..10]) </li><li>  <b>Bounded</b> - the class is also used for class types Enum.  Used to name the lower and upper bound type. </li><li>  <b>Show</b> - class for types whose values ‚Äã‚Äãcan be converted to a string, (= can be represented as characters) </li><li>  <b>Read</b> - class for types whose values ‚Äã‚Äãcan be converted from string </li></ul><br><br>  Only these classes can automatically inherit any data type (= placed in the <code>deriving</code> section).  There is also a relationship between classes.  For example, if we know how to compare two elements (class Ord), then we should be able to determine in advance whether one element is equal to another (class Eq).  After all, to implement the operator ( <code>&gt;=</code> ) you need to have an implemented operator (==).  Therefore, it can be said that the class Ord depends (inherits) on the class Eq.  Here is a more detailed class dependency diagram: <br><img src="https://habrastorage.org/storage2/9ed/76f/1da/9ed76f1dada934640781a33bcce3066b.png"><br><br>  Let's look at the equivalence <code>Eq</code> more detail.  As previously mentioned, this class should have two functions (==) and (/ =): <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==), (/=) :: a -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-comment"><span class="hljs-comment">--   (==)  (/=) ,     1  x /= y = not (x == y) x == y = not (x /= y)</span></span></code> </pre> <br><br>  From the code it is clear that for any instance of the class Eq, it suffices to implement one of the two functions.  For example, for the Bool type (two types are equal only when they are both True or False) this is done as follows: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) <span class="hljs-type"><span class="hljs-type">True</span></span> <span class="hljs-type"><span class="hljs-type">True</span></span> = <span class="hljs-type"><span class="hljs-type">True</span></span> (==) <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-type"><span class="hljs-type">False</span></span> = <span class="hljs-type"><span class="hljs-type">True</span></span> (==) _ _ = <span class="hljs-type"><span class="hljs-type">False</span></span></code> </pre> <br><br>  As you can see, the case of True False and False True (as well as the last line) is not necessary to write, because  inequality is the inverse operation of equality.  If before we had so that the type is another <b>type of</b> concretization (for example, [Int] is an instance of type [a]), then the type may be an instance of a <b>class</b> (for example, Bool is an instance of class Eq).  By the same analogy, we can write the equality functions of those binary trees that we used above.  For example, for Tree2: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">--   a,      (==) (Leaf2 s) (Leaf2 t) = (s==t) (==) (Node2 s t1 t2) (Node2 t u1 u2)= (s==t) &amp;&amp; (t1 == u1) &amp;&amp; (t2 == u2) (==) _ _ = False</span></span></code> </pre> <br>  For <code>(Tree3 ab)</code> we should already impose a condition on both <code>a</code> and <code>b</code> , that is, <br> <code>instance (Eq a, Eq b) =&gt; Eq (Tree3 ab)</code> <br> <br>  All that to the left of the symbol <code>=&gt;</code> is called a context, all that to the right of this symbol must be either a base type (Int, Bool, ...), or type constructors (Tree a, [...], ...).  The operator (==) is an overloaded function (ad-hoc polymorphism). <br><br>  Equality (==) is a type-dependent property that requires implementation for each type (such as the implementation of equality of binary trees).  I would like to be able to compare the two functions in this way: <br><pre> <code class="haskell hljs">(==) fac fib -&gt;&gt; <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-comment"><span class="hljs-comment">-- fac -  ,  fib -   (==) (\x -&gt; x+x) (\x -&gt; 2*x) -&gt;&gt; True (==) (+2) (2+) -&gt;&gt; True</span></span></code> </pre> <br>  This would require Haskell to write such code: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">instace</span></span> <span class="hljs-type"><span class="hljs-type">Eq</span></span> (<span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (==) fg = ... <span class="hljs-comment"><span class="hljs-comment">-- f  g  - </span></span></code> </pre> <br><br>  Is it possible to write such a function that would produce the result of the equality of <b>any</b> two functions (True or False)?  Unfortunately, from the thesis of Church-Turing it follows that the equality of any two functions cannot be determined.  There is no algorithm that, for any two given functions, always and in a finite number of steps would decide whether the two functions are equal or not.  Such an algorithm cannot be programmed in any programming language. <br><br>  Instead of implementing your function for equality, for example, binary trees, you can always put those classes that are inherited by this type automatically after the keyword <code>deriving</code> .  That is, we could quite calmly write: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node</span></span></span><span class="hljs-class"> a (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span></span></code> </pre> <br><br>  This allows us not to write our own instance of the class Eq ( <code>instance Eq a =&gt; Eq (Tree a) where ...</code> ).  But for any function, then you have to impose a condition on the variable <code>a</code> , that this variable is an element of the class Eq.  Sometimes, you still have to write these functions yourself, since the ‚Äúautomatic‚Äù comparison does not always work the way we would like.  For example for a binary tree <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree3</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Leaf3</span></span></span><span class="hljs-class"> bl | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node3</span></span></span><span class="hljs-class"> ab (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree3</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ab</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree3</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ab</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span></span></code> </pre> <br>  the following function will be implemented (automatically): <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree3</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ab</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) (<span class="hljs-type"><span class="hljs-type">Leaf3</span></span> q) (<span class="hljs-type"><span class="hljs-type">Leaf3</span></span> s) = (q==s) (==) (<span class="hljs-type"><span class="hljs-type">Node3</span></span> _ q t1 t2) (<span class="hljs-type"><span class="hljs-type">Node3</span></span> _ s u1 u2) = (q==s)&amp;&amp;(t1==u1)&amp;&amp;(t2==u2) (==) _ _ = <span class="hljs-type"><span class="hljs-type">False</span></span></code> </pre> <br>  As we can see, the first argument of Node3 was omitted, which we would not want in some cases. <br><br><h4>  Conclusion </h4><br>  Informal difference between the two types of polymorphism: <br><ul><li>  parametric - the same code regardless of type. </li><li>  ad-hoc is a different code, although the same function names. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/166353/">https://habr.com/ru/post/166353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../166333/index.html">Artificial Mind - a schematic diagram</a></li>
<li><a href="../166337/index.html">Microsoft hired a designer who created a futuristic brand</a></li>
<li><a href="../166339/index.html">CRUX 3.0 has been released</a></li>
<li><a href="../166341/index.html">How bad should the code be?</a></li>
<li><a href="../166351/index.html">Marked text in android.widget.TextView</a></li>
<li><a href="../166357/index.html">Little Brave Arkanoid (Part 2 - YAML)</a></li>
<li><a href="../166361/index.html">Project ‚ÄúProkaryotic Genome‚Äù - a scientific startup</a></li>
<li><a href="../166363/index.html">A few words about productivity</a></li>
<li><a href="../166367/index.html">Features of using roles with authentication in Oracle since 10.2.0.5</a></li>
<li><a href="../166369/index.html">Living computer museum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>